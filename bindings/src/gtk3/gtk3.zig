pub const ext = @import("ext.zig");
const gtk = @This();

const std = @import("std");
const compat = @import("compat");
const xlib = @import("xlib2");
const gdk = @import("gdk3");
const cairo = @import("cairo1");
const gobject = @import("gobject2");
const glib = @import("glib2");
const pango = @import("pango1");
const harfbuzz = @import("harfbuzz0");
const freetype2 = @import("freetype22");
const gio = @import("gio2");
const gmodule = @import("gmodule2");
const gdkpixbuf = @import("gdkpixbuf2");
const atk = @import("atk1");
/// A `gtk.Allocation`-struct of a widget represents region
/// which has been allocated to the widget by its parent. It is a subregion
/// of its parents allocation. See
/// [GtkWidget’s geometry management section][geometry-management] for
/// more information.
pub const Allocation = gdk.Rectangle;

pub const Stock = [*:0]u8;

/// The GtkAboutDialog offers a simple way to display information about
/// a program like its logo, name, copyright, website and license. It is
/// also possible to give credits to the authors, documenters, translators
/// and artists who have worked on the program. An about dialog is typically
/// opened when the user selects the `About` option from the `Help` menu.
/// All parts of the dialog are optional.
///
/// About dialogs often contain links and email addresses. GtkAboutDialog
/// displays these as clickable links. By default, it calls `gtk.showUriOnWindow`
/// when a user clicks one. The behaviour can be overridden with the
/// `gtk.AboutDialog.signals.activate`-link signal.
///
/// To specify a person with an email address, use a string like
/// "Edgar Allan Poe <edgar\@poe.com>". To specify a website with a title,
/// use a string like "GTK+ team http://www.gtk.org".
///
/// To make constructing a GtkAboutDialog as convenient as possible, you can
/// use the function `gtk.showAboutDialog` which constructs and shows a dialog
/// and keeps it around so that it can be shown again.
///
/// Note that GTK+ sets a default title of `_("About `s`")` on the dialog
/// window (where \%s is replaced by the name of the application, but in
/// order to ensure proper translation of the title, applications should
/// set the title property explicitly when constructing a GtkAboutDialog,
/// as shown in the following example:
/// ```
/// GdkPixbuf *example_logo = gdk_pixbuf_new_from_file ("./logo.png", NULL);
/// gtk_show_about_dialog (NULL,
///                        "program-name", "ExampleCode",
///                        "logo", example_logo,
///                        "title", _("About ExampleCode"),
///                        NULL);
/// ```
///
/// It is also possible to show a `gtk.AboutDialog` like any other `gtk.Dialog`,
/// e.g. using `gtk.Dialog.run`. In this case, you might need to know that
/// the “Close” button returns the `GTK_RESPONSE_CANCEL` response id.
pub const AboutDialog = extern struct {
    pub const Parent = gtk.Dialog;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.AboutDialogClass;
    f_parent_instance: gtk.Dialog,
    f_priv: ?*gtk.AboutDialogPrivate,

    pub const virtual_methods = struct {
        pub const activate_link = struct {
            pub fn call(p_class: anytype, p_dialog: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8) c_int {
                return gobject.ext.as(AboutDialog.Class, p_class).f_activate_link.?(gobject.ext.as(AboutDialog, p_dialog), p_uri);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_dialog: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8) callconv(.c) c_int) void {
                gobject.ext.as(AboutDialog.Class, p_class).f_activate_link = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The people who contributed artwork to the program, as a `NULL`-terminated
        /// array of strings. Each string may contain email addresses and URLs, which
        /// will be displayed as links, see the introduction for more details.
        pub const artists = struct {
            pub const name = "artists";

            pub const Type = ?[*][*:0]u8;
        };

        /// The authors of the program, as a `NULL`-terminated array of strings.
        /// Each string may contain email addresses and URLs, which will be displayed
        /// as links, see the introduction for more details.
        pub const authors = struct {
            pub const name = "authors";

            pub const Type = ?[*][*:0]u8;
        };

        /// Comments about the program. This string is displayed in a label
        /// in the main dialog, thus it should be a short explanation of
        /// the main purpose of the program, not a detailed list of features.
        pub const comments = struct {
            pub const name = "comments";

            pub const Type = ?[*:0]u8;
        };

        /// Copyright information for the program.
        pub const copyright = struct {
            pub const name = "copyright";

            pub const Type = ?[*:0]u8;
        };

        /// The people documenting the program, as a `NULL`-terminated array of strings.
        /// Each string may contain email addresses and URLs, which will be displayed
        /// as links, see the introduction for more details.
        pub const documenters = struct {
            pub const name = "documenters";

            pub const Type = ?[*][*:0]u8;
        };

        /// The license of the program. This string is displayed in a
        /// text view in a secondary dialog, therefore it is fine to use
        /// a long multi-paragraph text. Note that the text is only wrapped
        /// in the text view if the "wrap-license" property is set to `TRUE`;
        /// otherwise the text itself must contain the intended linebreaks.
        /// When setting this property to a non-`NULL` value, the
        /// `gtk.AboutDialog.properties.license`-type property is set to `GTK_LICENSE_CUSTOM`
        /// as a side effect.
        pub const license = struct {
            pub const name = "license";

            pub const Type = ?[*:0]u8;
        };

        /// The license of the program, as a value of the `gtk.License` enumeration.
        ///
        /// The `gtk.AboutDialog` will automatically fill out a standard disclaimer
        /// and link the user to the appropriate online resource for the license
        /// text.
        ///
        /// If `GTK_LICENSE_UNKNOWN` is used, the link used will be the same
        /// specified in the `gtk.AboutDialog.properties.website` property.
        ///
        /// If `GTK_LICENSE_CUSTOM` is used, the current contents of the
        /// `gtk.AboutDialog.properties.license` property are used.
        ///
        /// For any other `gtk.License` value, the contents of the
        /// `gtk.AboutDialog.properties.license` property are also set by this property as
        /// a side effect.
        pub const license_type = struct {
            pub const name = "license-type";

            pub const Type = gtk.License;
        };

        /// A logo for the about box. If it is `NULL`, the default window icon
        /// set with `gtk.Window.setDefaultIcon` will be used.
        pub const logo = struct {
            pub const name = "logo";

            pub const Type = ?*gdkpixbuf.Pixbuf;
        };

        /// A named icon to use as the logo for the about box. This property
        /// overrides the `gtk.AboutDialog.properties.logo` property.
        pub const logo_icon_name = struct {
            pub const name = "logo-icon-name";

            pub const Type = ?[*:0]u8;
        };

        /// The name of the program.
        /// If this is not set, it defaults to `glib.getApplicationName`.
        pub const program_name = struct {
            pub const name = "program-name";

            pub const Type = ?[*:0]u8;
        };

        /// Credits to the translators. This string should be marked as translatable.
        /// The string may contain email addresses and URLs, which will be displayed
        /// as links, see the introduction for more details.
        pub const translator_credits = struct {
            pub const name = "translator-credits";

            pub const Type = ?[*:0]u8;
        };

        /// The version of the program.
        pub const version = struct {
            pub const name = "version";

            pub const Type = ?[*:0]u8;
        };

        /// The URL for the link to the website of the program.
        /// This should be a string starting with "http://.
        pub const website = struct {
            pub const name = "website";

            pub const Type = ?[*:0]u8;
        };

        /// The label for the link to the website of the program.
        pub const website_label = struct {
            pub const name = "website-label";

            pub const Type = ?[*:0]u8;
        };

        /// Whether to wrap the text in the license dialog.
        pub const wrap_license = struct {
            pub const name = "wrap-license";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The signal which gets emitted to activate a URI.
        /// Applications may connect to it to override the default behaviour,
        /// which is to call `gtk.showUriOnWindow`.
        pub const activate_link = struct {
            pub const name = "activate-link";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_uri: [*:0]u8, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(AboutDialog, p_instance))),
                    gobject.signalLookup("activate-link", AboutDialog.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.AboutDialog`.
    extern fn gtk_about_dialog_new() *gtk.AboutDialog;
    pub const new = gtk_about_dialog_new;

    /// Creates a new section in the Credits page.
    extern fn gtk_about_dialog_add_credit_section(p_about: *AboutDialog, p_section_name: [*:0]const u8, p_people: [*][*:0]const u8) void;
    pub const addCreditSection = gtk_about_dialog_add_credit_section;

    /// Returns the string which are displayed in the artists tab
    /// of the secondary credits dialog.
    extern fn gtk_about_dialog_get_artists(p_about: *AboutDialog) [*]const [*:0]const u8;
    pub const getArtists = gtk_about_dialog_get_artists;

    /// Returns the string which are displayed in the authors tab
    /// of the secondary credits dialog.
    extern fn gtk_about_dialog_get_authors(p_about: *AboutDialog) [*]const [*:0]const u8;
    pub const getAuthors = gtk_about_dialog_get_authors;

    /// Returns the comments string.
    extern fn gtk_about_dialog_get_comments(p_about: *AboutDialog) [*:0]const u8;
    pub const getComments = gtk_about_dialog_get_comments;

    /// Returns the copyright string.
    extern fn gtk_about_dialog_get_copyright(p_about: *AboutDialog) [*:0]const u8;
    pub const getCopyright = gtk_about_dialog_get_copyright;

    /// Returns the string which are displayed in the documenters
    /// tab of the secondary credits dialog.
    extern fn gtk_about_dialog_get_documenters(p_about: *AboutDialog) [*]const [*:0]const u8;
    pub const getDocumenters = gtk_about_dialog_get_documenters;

    /// Returns the license information.
    extern fn gtk_about_dialog_get_license(p_about: *AboutDialog) [*:0]const u8;
    pub const getLicense = gtk_about_dialog_get_license;

    /// Retrieves the license set using `gtk.AboutDialog.setLicenseType`
    extern fn gtk_about_dialog_get_license_type(p_about: *AboutDialog) gtk.License;
    pub const getLicenseType = gtk_about_dialog_get_license_type;

    /// Returns the pixbuf displayed as logo in the about dialog.
    extern fn gtk_about_dialog_get_logo(p_about: *AboutDialog) *gdkpixbuf.Pixbuf;
    pub const getLogo = gtk_about_dialog_get_logo;

    /// Returns the icon name displayed as logo in the about dialog.
    extern fn gtk_about_dialog_get_logo_icon_name(p_about: *AboutDialog) [*:0]const u8;
    pub const getLogoIconName = gtk_about_dialog_get_logo_icon_name;

    /// Returns the program name displayed in the about dialog.
    extern fn gtk_about_dialog_get_program_name(p_about: *AboutDialog) [*:0]const u8;
    pub const getProgramName = gtk_about_dialog_get_program_name;

    /// Returns the translator credits string which is displayed
    /// in the translators tab of the secondary credits dialog.
    extern fn gtk_about_dialog_get_translator_credits(p_about: *AboutDialog) [*:0]const u8;
    pub const getTranslatorCredits = gtk_about_dialog_get_translator_credits;

    /// Returns the version string.
    extern fn gtk_about_dialog_get_version(p_about: *AboutDialog) [*:0]const u8;
    pub const getVersion = gtk_about_dialog_get_version;

    /// Returns the website URL.
    extern fn gtk_about_dialog_get_website(p_about: *AboutDialog) [*:0]const u8;
    pub const getWebsite = gtk_about_dialog_get_website;

    /// Returns the label used for the website link.
    extern fn gtk_about_dialog_get_website_label(p_about: *AboutDialog) [*:0]const u8;
    pub const getWebsiteLabel = gtk_about_dialog_get_website_label;

    /// Returns whether the license text in `about` is
    /// automatically wrapped.
    extern fn gtk_about_dialog_get_wrap_license(p_about: *AboutDialog) c_int;
    pub const getWrapLicense = gtk_about_dialog_get_wrap_license;

    /// Sets the strings which are displayed in the artists tab
    /// of the secondary credits dialog.
    extern fn gtk_about_dialog_set_artists(p_about: *AboutDialog, p_artists: [*][*:0]const u8) void;
    pub const setArtists = gtk_about_dialog_set_artists;

    /// Sets the strings which are displayed in the authors tab
    /// of the secondary credits dialog.
    extern fn gtk_about_dialog_set_authors(p_about: *AboutDialog, p_authors: [*][*:0]const u8) void;
    pub const setAuthors = gtk_about_dialog_set_authors;

    /// Sets the comments string to display in the about dialog.
    /// This should be a short string of one or two lines.
    extern fn gtk_about_dialog_set_comments(p_about: *AboutDialog, p_comments: ?[*:0]const u8) void;
    pub const setComments = gtk_about_dialog_set_comments;

    /// Sets the copyright string to display in the about dialog.
    /// This should be a short string of one or two lines.
    extern fn gtk_about_dialog_set_copyright(p_about: *AboutDialog, p_copyright: ?[*:0]const u8) void;
    pub const setCopyright = gtk_about_dialog_set_copyright;

    /// Sets the strings which are displayed in the documenters tab
    /// of the secondary credits dialog.
    extern fn gtk_about_dialog_set_documenters(p_about: *AboutDialog, p_documenters: [*][*:0]const u8) void;
    pub const setDocumenters = gtk_about_dialog_set_documenters;

    /// Sets the license information to be displayed in the secondary
    /// license dialog. If `license` is `NULL`, the license button is
    /// hidden.
    extern fn gtk_about_dialog_set_license(p_about: *AboutDialog, p_license: ?[*:0]const u8) void;
    pub const setLicense = gtk_about_dialog_set_license;

    /// Sets the license of the application showing the `about` dialog from a
    /// list of known licenses.
    ///
    /// This function overrides the license set using
    /// `gtk.AboutDialog.setLicense`.
    extern fn gtk_about_dialog_set_license_type(p_about: *AboutDialog, p_license_type: gtk.License) void;
    pub const setLicenseType = gtk_about_dialog_set_license_type;

    /// Sets the pixbuf to be displayed as logo in the about dialog.
    /// If it is `NULL`, the default window icon set with
    /// `gtk.Window.setDefaultIcon` will be used.
    extern fn gtk_about_dialog_set_logo(p_about: *AboutDialog, p_logo: ?*gdkpixbuf.Pixbuf) void;
    pub const setLogo = gtk_about_dialog_set_logo;

    /// Sets the pixbuf to be displayed as logo in the about dialog.
    /// If it is `NULL`, the default window icon set with
    /// `gtk.Window.setDefaultIcon` will be used.
    extern fn gtk_about_dialog_set_logo_icon_name(p_about: *AboutDialog, p_icon_name: ?[*:0]const u8) void;
    pub const setLogoIconName = gtk_about_dialog_set_logo_icon_name;

    /// Sets the name to display in the about dialog.
    /// If this is not set, it defaults to `glib.getApplicationName`.
    extern fn gtk_about_dialog_set_program_name(p_about: *AboutDialog, p_name: [*:0]const u8) void;
    pub const setProgramName = gtk_about_dialog_set_program_name;

    /// Sets the translator credits string which is displayed in
    /// the translators tab of the secondary credits dialog.
    ///
    /// The intended use for this string is to display the translator
    /// of the language which is currently used in the user interface.
    /// Using `gettext`, a simple way to achieve that is to mark the
    /// string for translation:
    /// ```
    /// GtkWidget *about = gtk_about_dialog_new ();
    /// gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG (about),
    ///                                          _("translator-credits"));
    /// ```
    /// It is a good idea to use the customary msgid “translator-credits” for this
    /// purpose, since translators will already know the purpose of that msgid, and
    /// since `gtk.AboutDialog` will detect if “translator-credits” is untranslated
    /// and hide the tab.
    extern fn gtk_about_dialog_set_translator_credits(p_about: *AboutDialog, p_translator_credits: ?[*:0]const u8) void;
    pub const setTranslatorCredits = gtk_about_dialog_set_translator_credits;

    /// Sets the version string to display in the about dialog.
    extern fn gtk_about_dialog_set_version(p_about: *AboutDialog, p_version: ?[*:0]const u8) void;
    pub const setVersion = gtk_about_dialog_set_version;

    /// Sets the URL to use for the website link.
    extern fn gtk_about_dialog_set_website(p_about: *AboutDialog, p_website: ?[*:0]const u8) void;
    pub const setWebsite = gtk_about_dialog_set_website;

    /// Sets the label to be used for the website link.
    extern fn gtk_about_dialog_set_website_label(p_about: *AboutDialog, p_website_label: [*:0]const u8) void;
    pub const setWebsiteLabel = gtk_about_dialog_set_website_label;

    /// Sets whether the license text in `about` is
    /// automatically wrapped.
    extern fn gtk_about_dialog_set_wrap_license(p_about: *AboutDialog, p_wrap_license: c_int) void;
    pub const setWrapLicense = gtk_about_dialog_set_wrap_license;

    extern fn gtk_about_dialog_get_type() usize;
    pub const getGObjectType = gtk_about_dialog_get_type;

    extern fn g_object_ref(p_self: *gtk.AboutDialog) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.AboutDialog) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *AboutDialog, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.AccelGroup` represents a group of keyboard accelerators,
/// typically attached to a toplevel `gtk.Window` (with
/// `gtk.Window.addAccelGroup`). Usually you won’t need to create a
/// `gtk.AccelGroup` directly; instead, when using `gtk.UIManager`, GTK+
/// automatically sets up the accelerators for your menus in the ui
/// manager’s `gtk.AccelGroup`.
///
/// Note that “accelerators” are different from
/// “mnemonics”. Accelerators are shortcuts for
/// activating a menu item; they appear alongside the menu item they’re a
/// shortcut for. For example “Ctrl+Q” might appear alongside the “Quit”
/// menu item. Mnemonics are shortcuts for GUI elements such as text
/// entries or buttons; they appear as underlined characters. See
/// `gtk.Label.newWithMnemonic`. Menu items can have both accelerators
/// and mnemonics, of course.
pub const AccelGroup = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.AccelGroupClass;
    f_parent: gobject.Object,
    f_priv: ?*gtk.AccelGroupPrivate,

    pub const virtual_methods = struct {
        /// Signal emitted when an entry is added to or removed
        ///    from the accel group.
        pub const accel_changed = struct {
            pub fn call(p_class: anytype, p_accel_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_keyval: c_uint, p_modifier: gdk.ModifierType, p_accel_closure: *gobject.Closure) void {
                return gobject.ext.as(AccelGroup.Class, p_class).f_accel_changed.?(gobject.ext.as(AccelGroup, p_accel_group), p_keyval, p_modifier, p_accel_closure);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_accel_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_keyval: c_uint, p_modifier: gdk.ModifierType, p_accel_closure: *gobject.Closure) callconv(.c) void) void {
                gobject.ext.as(AccelGroup.Class, p_class).f_accel_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const is_locked = struct {
            pub const name = "is-locked";

            pub const Type = c_int;
        };

        pub const modifier_mask = struct {
            pub const name = "modifier-mask";

            pub const Type = gdk.ModifierType;
        };
    };

    pub const signals = struct {
        /// The accel-activate signal is an implementation detail of
        /// `gtk.AccelGroup` and not meant to be used by applications.
        pub const accel_activate = struct {
            pub const name = "accel-activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_acceleratable: *gobject.Object, p_keyval: c_uint, p_modifier: gdk.ModifierType, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(AccelGroup, p_instance))),
                    gobject.signalLookup("accel-activate", AccelGroup.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The accel-changed signal is emitted when an entry
        /// is added to or removed from the accel group.
        ///
        /// Widgets like `gtk.AccelLabel` which display an associated
        /// accelerator should connect to this signal, and rebuild
        /// their visual representation if the `accel_closure` is theirs.
        pub const accel_changed = struct {
            pub const name = "accel-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_keyval: c_uint, p_modifier: gdk.ModifierType, p_accel_closure: *gobject.Closure, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(AccelGroup, p_instance))),
                    gobject.signalLookup("accel-changed", AccelGroup.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Finds the `gtk.AccelGroup` to which `closure` is connected;
    /// see `gtk.AccelGroup.connect`.
    extern fn gtk_accel_group_from_accel_closure(p_closure: *gobject.Closure) ?*gtk.AccelGroup;
    pub const fromAccelClosure = gtk_accel_group_from_accel_closure;

    /// Creates a new `gtk.AccelGroup`.
    extern fn gtk_accel_group_new() *gtk.AccelGroup;
    pub const new = gtk_accel_group_new;

    /// Finds the first accelerator in `accel_group` that matches
    /// `accel_key` and `accel_mods`, and activates it.
    extern fn gtk_accel_group_activate(p_accel_group: *AccelGroup, p_accel_quark: glib.Quark, p_acceleratable: *gobject.Object, p_accel_key: c_uint, p_accel_mods: gdk.ModifierType) c_int;
    pub const activate = gtk_accel_group_activate;

    /// Installs an accelerator in this group. When `accel_group` is being
    /// activated in response to a call to `gtk.accelGroupsActivate`,
    /// `closure` will be invoked if the `accel_key` and `accel_mods` from
    /// `gtk.accelGroupsActivate` match those of this connection.
    ///
    /// The signature used for the `closure` is that of `gtk.AccelGroupActivate`.
    ///
    /// Note that, due to implementation details, a single closure can
    /// only be connected to one accelerator group.
    extern fn gtk_accel_group_connect(p_accel_group: *AccelGroup, p_accel_key: c_uint, p_accel_mods: gdk.ModifierType, p_accel_flags: gtk.AccelFlags, p_closure: *gobject.Closure) void;
    pub const connect = gtk_accel_group_connect;

    /// Installs an accelerator in this group, using an accelerator path
    /// to look up the appropriate key and modifiers (see
    /// `gtk.AccelMap.addEntry`). When `accel_group` is being activated
    /// in response to a call to `gtk.accelGroupsActivate`, `closure` will
    /// be invoked if the `accel_key` and `accel_mods` from
    /// `gtk.accelGroupsActivate` match the key and modifiers for the path.
    ///
    /// The signature used for the `closure` is that of `gtk.AccelGroupActivate`.
    ///
    /// Note that `accel_path` string will be stored in a `glib.Quark`. Therefore,
    /// if you pass a static string, you can save some memory by interning it
    /// first with `glib.internStaticString`.
    extern fn gtk_accel_group_connect_by_path(p_accel_group: *AccelGroup, p_accel_path: [*:0]const u8, p_closure: *gobject.Closure) void;
    pub const connectByPath = gtk_accel_group_connect_by_path;

    /// Removes an accelerator previously installed through
    /// `gtk.AccelGroup.connect`.
    ///
    /// Since 2.20 `closure` can be `NULL`.
    extern fn gtk_accel_group_disconnect(p_accel_group: *AccelGroup, p_closure: ?*gobject.Closure) c_int;
    pub const disconnect = gtk_accel_group_disconnect;

    /// Removes an accelerator previously installed through
    /// `gtk.AccelGroup.connect`.
    extern fn gtk_accel_group_disconnect_key(p_accel_group: *AccelGroup, p_accel_key: c_uint, p_accel_mods: gdk.ModifierType) c_int;
    pub const disconnectKey = gtk_accel_group_disconnect_key;

    /// Finds the first entry in an accelerator group for which
    /// `find_func` returns `TRUE` and returns its `gtk.AccelKey`.
    extern fn gtk_accel_group_find(p_accel_group: *AccelGroup, p_find_func: gtk.AccelGroupFindFunc, p_data: ?*anyopaque) *gtk.AccelKey;
    pub const find = gtk_accel_group_find;

    /// Locks are added and removed using `gtk.AccelGroup.lock` and
    /// `gtk.AccelGroup.unlock`.
    extern fn gtk_accel_group_get_is_locked(p_accel_group: *AccelGroup) c_int;
    pub const getIsLocked = gtk_accel_group_get_is_locked;

    /// Gets a `gdk.ModifierType` representing the mask for this
    /// `accel_group`. For example, `GDK_CONTROL_MASK`, `GDK_SHIFT_MASK`, etc.
    extern fn gtk_accel_group_get_modifier_mask(p_accel_group: *AccelGroup) gdk.ModifierType;
    pub const getModifierMask = gtk_accel_group_get_modifier_mask;

    /// Locks the given accelerator group.
    ///
    /// Locking an acelerator group prevents the accelerators contained
    /// within it to be changed during runtime. Refer to
    /// `gtk.AccelMap.changeEntry` about runtime accelerator changes.
    ///
    /// If called more than once, `accel_group` remains locked until
    /// `gtk.AccelGroup.unlock` has been called an equivalent number
    /// of times.
    extern fn gtk_accel_group_lock(p_accel_group: *AccelGroup) void;
    pub const lock = gtk_accel_group_lock;

    /// Queries an accelerator group for all entries matching `accel_key`
    /// and `accel_mods`.
    extern fn gtk_accel_group_query(p_accel_group: *AccelGroup, p_accel_key: c_uint, p_accel_mods: gdk.ModifierType, p_n_entries: ?*c_uint) ?[*]gtk.AccelGroupEntry;
    pub const query = gtk_accel_group_query;

    /// Undoes the last call to `gtk.AccelGroup.lock` on this `accel_group`.
    extern fn gtk_accel_group_unlock(p_accel_group: *AccelGroup) void;
    pub const unlock = gtk_accel_group_unlock;

    extern fn gtk_accel_group_get_type() usize;
    pub const getGObjectType = gtk_accel_group_get_type;

    extern fn g_object_ref(p_self: *gtk.AccelGroup) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.AccelGroup) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *AccelGroup, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.AccelLabel` widget is a subclass of `gtk.Label` that also displays an
/// accelerator key on the right of the label text, e.g. “Ctrl+S”.
/// It is commonly used in menus to show the keyboard short-cuts for commands.
///
/// The accelerator key to display is typically not set explicitly (although it
/// can be, with `gtk.AccelLabel.setAccel`). Instead, the `gtk.AccelLabel` displays
/// the accelerators which have been added to a particular widget. This widget is
/// set by calling `gtk.AccelLabel.setAccelWidget`.
///
/// For example, a `gtk.MenuItem` widget may have an accelerator added to emit
/// the “activate” signal when the “Ctrl+S” key combination is pressed.
/// A `gtk.AccelLabel` is created and added to the `gtk.MenuItem`, and
/// `gtk.AccelLabel.setAccelWidget` is called with the `gtk.MenuItem` as the
/// second argument. The `gtk.AccelLabel` will now display “Ctrl+S” after its label.
///
/// Note that creating a `gtk.MenuItem` with `gtk.MenuItem.newWithLabel` (or
/// one of the similar functions for `gtk.CheckMenuItem` and `gtk.RadioMenuItem`)
/// automatically adds a `gtk.AccelLabel` to the `gtk.MenuItem` and calls
/// `gtk.AccelLabel.setAccelWidget` to set it up for you.
///
/// A `gtk.AccelLabel` will only display accelerators which have `GTK_ACCEL_VISIBLE`
/// set (see `gtk.AccelFlags`).
/// A `gtk.AccelLabel` can display multiple accelerators and even signal names,
/// though it is almost always used to display just one accelerator key.
///
/// ## Creating a simple menu item with an accelerator key.
///
/// ```
///   GtkWidget *window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
///   GtkWidget *menu = gtk_menu_new ();
///   GtkWidget *save_item;
///   GtkAccelGroup *accel_group;
///
///   // Create a GtkAccelGroup and add it to the window.
///   accel_group = gtk_accel_group_new ();
///   gtk_window_add_accel_group (GTK_WINDOW (window), accel_group);
///
///   // Create the menu item using the convenience function.
///   save_item = gtk_menu_item_new_with_label ("Save");
///   gtk_widget_show (save_item);
///   gtk_container_add (GTK_CONTAINER (menu), save_item);
///
///   // Now add the accelerator to the GtkMenuItem. Note that since we
///   // called `gtk.MenuItem.newWithLabel` to create the GtkMenuItem
///   // the GtkAccelLabel is automatically set up to display the
///   // GtkMenuItem accelerators. We just need to make sure we use
///   // GTK_ACCEL_VISIBLE here.
///   gtk_widget_add_accelerator (save_item, "activate", accel_group,
///                               GDK_KEY_s, GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
/// ```
///
/// # CSS nodes
///
/// ```
/// label
/// ╰── accelerator
/// ```
///
/// Like `gtk.Label`, GtkAccelLabel has a main CSS node with the name label.
/// It adds a subnode with name accelerator.
pub const AccelLabel = extern struct {
    pub const Parent = gtk.Label;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.AccelLabelClass;
    f_label: gtk.Label,
    f_priv: ?*gtk.AccelLabelPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const accel_closure = struct {
            pub const name = "accel-closure";

            pub const Type = ?*gobject.Closure;
        };

        pub const accel_widget = struct {
            pub const name = "accel-widget";

            pub const Type = ?*gtk.Widget;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.AccelLabel`.
    extern fn gtk_accel_label_new(p_string: [*:0]const u8) *gtk.AccelLabel;
    pub const new = gtk_accel_label_new;

    /// Gets the keyval and modifier mask set with
    /// `gtk.AccelLabel.setAccel`.
    extern fn gtk_accel_label_get_accel(p_accel_label: *AccelLabel, p_accelerator_key: *c_uint, p_accelerator_mods: *gdk.ModifierType) void;
    pub const getAccel = gtk_accel_label_get_accel;

    /// Fetches the widget monitored by this accelerator label. See
    /// `gtk.AccelLabel.setAccelWidget`.
    extern fn gtk_accel_label_get_accel_widget(p_accel_label: *AccelLabel) ?*gtk.Widget;
    pub const getAccelWidget = gtk_accel_label_get_accel_widget;

    /// Returns the width needed to display the accelerator key(s).
    /// This is used by menus to align all of the `gtk.MenuItem` widgets, and shouldn't
    /// be needed by applications.
    extern fn gtk_accel_label_get_accel_width(p_accel_label: *AccelLabel) c_uint;
    pub const getAccelWidth = gtk_accel_label_get_accel_width;

    /// Recreates the string representing the accelerator keys.
    /// This should not be needed since the string is automatically updated whenever
    /// accelerators are added or removed from the associated widget.
    extern fn gtk_accel_label_refetch(p_accel_label: *AccelLabel) c_int;
    pub const refetch = gtk_accel_label_refetch;

    /// Manually sets a keyval and modifier mask as the accelerator rendered
    /// by `accel_label`.
    ///
    /// If a keyval and modifier are explicitly set then these values are
    /// used regardless of any associated accel closure or widget.
    ///
    /// Providing an `accelerator_key` of 0 removes the manual setting.
    extern fn gtk_accel_label_set_accel(p_accel_label: *AccelLabel, p_accelerator_key: c_uint, p_accelerator_mods: gdk.ModifierType) void;
    pub const setAccel = gtk_accel_label_set_accel;

    /// Sets the closure to be monitored by this accelerator label. The closure
    /// must be connected to an accelerator group; see `gtk.AccelGroup.connect`.
    /// Passing `NULL` for `accel_closure` will dissociate `accel_label` from its
    /// current closure, if any.
    extern fn gtk_accel_label_set_accel_closure(p_accel_label: *AccelLabel, p_accel_closure: ?*gobject.Closure) void;
    pub const setAccelClosure = gtk_accel_label_set_accel_closure;

    /// Sets the widget to be monitored by this accelerator label. Passing `NULL` for
    /// `accel_widget` will dissociate `accel_label` from its current widget, if any.
    extern fn gtk_accel_label_set_accel_widget(p_accel_label: *AccelLabel, p_accel_widget: ?*gtk.Widget) void;
    pub const setAccelWidget = gtk_accel_label_set_accel_widget;

    extern fn gtk_accel_label_get_type() usize;
    pub const getGObjectType = gtk_accel_label_get_type;

    extern fn g_object_ref(p_self: *gtk.AccelLabel) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.AccelLabel) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *AccelLabel, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Accelerator maps are used to define runtime configurable accelerators.
/// Functions for manipulating them are are usually used by higher level
/// convenience mechanisms like `gtk.UIManager` and are thus considered
/// “low-level”. You’ll want to use them if you’re manually creating menus that
/// should have user-configurable accelerators.
///
/// An accelerator is uniquely defined by:
/// - accelerator path
/// - accelerator key
/// - accelerator modifiers
///
/// The accelerator path must consist of
/// “<WINDOWTYPE>/Category1/Category2/.../Action”, where WINDOWTYPE
/// should be a unique application-specific identifier that corresponds
/// to the kind of window the accelerator is being used in, e.g.
/// “Gimp-Image”, “Abiword-Document” or “Gnumeric-Settings”.
/// The “Category1/.../Action” portion is most appropriately chosen by
/// the action the accelerator triggers, i.e. for accelerators on menu
/// items, choose the item’s menu path, e.g. “File/Save As”,
/// “Image/View/Zoom” or “Edit/Select All”. So a full valid accelerator
/// path may look like: “<Gimp-Toolbox>/File/Dialogs/Tool Options...”.
///
/// All accelerators are stored inside one global `gtk.AccelMap` that can
/// be obtained using `gtk.AccelMap.get`. See
/// [Monitoring changes][monitoring-changes] for additional
/// details.
///
/// # Manipulating accelerators
///
/// New accelerators can be added using `gtk.AccelMap.addEntry`.
/// To search for specific accelerator, use `gtk.AccelMap.lookupEntry`.
/// Modifications of existing accelerators should be done using
/// `gtk.AccelMap.changeEntry`.
///
/// In order to avoid having some accelerators changed, they can be
/// locked using `gtk.AccelMap.lockPath`. Unlocking is done using
/// `gtk.AccelMap.unlockPath`.
///
/// # Saving and loading accelerator maps
///
/// Accelerator maps can be saved to and loaded from some external
/// resource. For simple saving and loading from file,
/// `gtk.AccelMap.save` and `gtk.AccelMap.load` are provided.
/// Saving and loading can also be done by providing file descriptor
/// to `gtk.AccelMap.saveFd` and `gtk.AccelMap.loadFd`.
///
/// # Monitoring changes
///
/// `gtk.AccelMap` object is only useful for monitoring changes of
/// accelerators. By connecting to `gtk.AccelMap.signals.changed` signal, one
/// can monitor changes of all accelerators. It is also possible to
/// monitor only single accelerator path by using it as a detail of
/// the `gtk.AccelMap.signals.changed` signal.
pub const AccelMap = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.AccelMapClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {
        /// Notifies of a change in the global accelerator map.
        /// The path is also used as the detail for the signal,
        /// so it is possible to connect to
        /// changed::`accel_path`.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_accel_path: [*:0]u8, p_accel_key: c_uint, p_accel_mods: gdk.ModifierType, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(AccelMap, p_instance))),
                    gobject.signalLookup("changed", AccelMap.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Registers a new accelerator with the global accelerator map.
    /// This function should only be called once per `accel_path`
    /// with the canonical `accel_key` and `accel_mods` for this path.
    /// To change the accelerator during runtime programatically, use
    /// `gtk.AccelMap.changeEntry`.
    ///
    /// Set `accel_key` and `accel_mods` to 0 to request a removal of
    /// the accelerator.
    ///
    /// Note that `accel_path` string will be stored in a `glib.Quark`. Therefore, if you
    /// pass a static string, you can save some memory by interning it first with
    /// `glib.internStaticString`.
    extern fn gtk_accel_map_add_entry(p_accel_path: [*:0]const u8, p_accel_key: c_uint, p_accel_mods: gdk.ModifierType) void;
    pub const addEntry = gtk_accel_map_add_entry;

    /// Adds a filter to the global list of accel path filters.
    ///
    /// Accel map entries whose accel path matches one of the filters
    /// are skipped by `gtk.AccelMap.foreach`.
    ///
    /// This function is intended for GTK+ modules that create their own
    /// menus, but don’t want them to be saved into the applications accelerator
    /// map dump.
    extern fn gtk_accel_map_add_filter(p_filter_pattern: [*:0]const u8) void;
    pub const addFilter = gtk_accel_map_add_filter;

    /// Changes the `accel_key` and `accel_mods` currently associated with `accel_path`.
    /// Due to conflicts with other accelerators, a change may not always be possible,
    /// `replace` indicates whether other accelerators may be deleted to resolve such
    /// conflicts. A change will only occur if all conflicts could be resolved (which
    /// might not be the case if conflicting accelerators are locked). Successful
    /// changes are indicated by a `TRUE` return value.
    ///
    /// Note that `accel_path` string will be stored in a `glib.Quark`. Therefore, if you
    /// pass a static string, you can save some memory by interning it first with
    /// `glib.internStaticString`.
    extern fn gtk_accel_map_change_entry(p_accel_path: [*:0]const u8, p_accel_key: c_uint, p_accel_mods: gdk.ModifierType, p_replace: c_int) c_int;
    pub const changeEntry = gtk_accel_map_change_entry;

    /// Loops over the entries in the accelerator map whose accel path
    /// doesn’t match any of the filters added with `gtk.AccelMap.addFilter`,
    /// and execute `foreach_func` on each. The signature of `foreach_func` is
    /// that of `gtk.AccelMapForeach`, the `changed` parameter indicates whether
    /// this accelerator was changed during runtime (thus, would need
    /// saving during an accelerator map dump).
    extern fn gtk_accel_map_foreach(p_data: ?*anyopaque, p_foreach_func: gtk.AccelMapForeach) void;
    pub const foreach = gtk_accel_map_foreach;

    /// Loops over all entries in the accelerator map, and execute
    /// `foreach_func` on each. The signature of `foreach_func` is that of
    /// `gtk.AccelMapForeach`, the `changed` parameter indicates whether
    /// this accelerator was changed during runtime (thus, would need
    /// saving during an accelerator map dump).
    extern fn gtk_accel_map_foreach_unfiltered(p_data: ?*anyopaque, p_foreach_func: gtk.AccelMapForeach) void;
    pub const foreachUnfiltered = gtk_accel_map_foreach_unfiltered;

    /// Gets the singleton global `gtk.AccelMap` object. This object
    /// is useful only for notification of changes to the accelerator
    /// map via the ::changed signal; it isn’t a parameter to the
    /// other accelerator map functions.
    extern fn gtk_accel_map_get() *gtk.AccelMap;
    pub const get = gtk_accel_map_get;

    /// Parses a file previously saved with `gtk.AccelMap.save` for
    /// accelerator specifications, and propagates them accordingly.
    extern fn gtk_accel_map_load(p_file_name: [*:0]const u8) void;
    pub const load = gtk_accel_map_load;

    /// Filedescriptor variant of `gtk.AccelMap.load`.
    ///
    /// Note that the file descriptor will not be closed by this function.
    extern fn gtk_accel_map_load_fd(p_fd: c_int) void;
    pub const loadFd = gtk_accel_map_load_fd;

    /// `glib.Scanner` variant of `gtk.AccelMap.load`.
    extern fn gtk_accel_map_load_scanner(p_scanner: *glib.Scanner) void;
    pub const loadScanner = gtk_accel_map_load_scanner;

    /// Locks the given accelerator path. If the accelerator map doesn’t yet contain
    /// an entry for `accel_path`, a new one is created.
    ///
    /// Locking an accelerator path prevents its accelerator from being changed
    /// during runtime. A locked accelerator path can be unlocked by
    /// `gtk.AccelMap.unlockPath`. Refer to `gtk.AccelMap.changeEntry`
    /// for information about runtime accelerator changes.
    ///
    /// If called more than once, `accel_path` remains locked until
    /// `gtk.AccelMap.unlockPath` has been called an equivalent number
    /// of times.
    ///
    /// Note that locking of individual accelerator paths is independent from
    /// locking the `gtk.AccelGroup` containing them. For runtime accelerator
    /// changes to be possible, both the accelerator path and its `gtk.AccelGroup`
    /// have to be unlocked.
    extern fn gtk_accel_map_lock_path(p_accel_path: [*:0]const u8) void;
    pub const lockPath = gtk_accel_map_lock_path;

    /// Looks up the accelerator entry for `accel_path` and fills in `key`.
    extern fn gtk_accel_map_lookup_entry(p_accel_path: [*:0]const u8, p_key: ?*gtk.AccelKey) c_int;
    pub const lookupEntry = gtk_accel_map_lookup_entry;

    /// Saves current accelerator specifications (accelerator path, key
    /// and modifiers) to `file_name`.
    /// The file is written in a format suitable to be read back in by
    /// `gtk.AccelMap.load`.
    extern fn gtk_accel_map_save(p_file_name: [*:0]const u8) void;
    pub const save = gtk_accel_map_save;

    /// Filedescriptor variant of `gtk.AccelMap.save`.
    ///
    /// Note that the file descriptor will not be closed by this function.
    extern fn gtk_accel_map_save_fd(p_fd: c_int) void;
    pub const saveFd = gtk_accel_map_save_fd;

    /// Undoes the last call to `gtk.AccelMap.lockPath` on this `accel_path`.
    /// Refer to `gtk.AccelMap.lockPath` for information about accelerator path locking.
    extern fn gtk_accel_map_unlock_path(p_accel_path: [*:0]const u8) void;
    pub const unlockPath = gtk_accel_map_unlock_path;

    extern fn gtk_accel_map_get_type() usize;
    pub const getGObjectType = gtk_accel_map_get_type;

    extern fn g_object_ref(p_self: *gtk.AccelMap) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.AccelMap) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *AccelMap, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Accessible` class is the base class for accessible
/// implementations for `gtk.Widget` subclasses. It is a thin
/// wrapper around `atk.Object`, which adds facilities for associating
/// a widget with its accessible object.
///
/// An accessible implementation for a third-party widget should
/// derive from `gtk.Accessible` and implement the suitable interfaces
/// from ATK, such as `atk.Text` or `atk.Selection`. To establish
/// the connection between the widget class and its corresponding
/// acccessible implementation, override the get_accessible vfunc
/// in `gtk.WidgetClass`.
pub const Accessible = extern struct {
    pub const Parent = atk.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.AccessibleClass;
    f_parent: atk.Object,
    f_priv: ?*gtk.AccessiblePrivate,

    pub const virtual_methods = struct {
        /// This function specifies the callback function to be called
        /// when the widget corresponding to a GtkAccessible is destroyed.
        pub const connect_widget_destroyed = struct {
            pub fn call(p_class: anytype, p_accessible: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Accessible.Class, p_class).f_connect_widget_destroyed.?(gobject.ext.as(Accessible, p_accessible));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_accessible: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Accessible.Class, p_class).f_connect_widget_destroyed = @ptrCast(p_implementation);
            }
        };

        pub const widget_set = struct {
            pub fn call(p_class: anytype, p_accessible: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Accessible.Class, p_class).f_widget_set.?(gobject.ext.as(Accessible, p_accessible));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_accessible: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Accessible.Class, p_class).f_widget_set = @ptrCast(p_implementation);
            }
        };

        pub const widget_unset = struct {
            pub fn call(p_class: anytype, p_accessible: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Accessible.Class, p_class).f_widget_unset.?(gobject.ext.as(Accessible, p_accessible));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_accessible: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Accessible.Class, p_class).f_widget_unset = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const widget = struct {
            pub const name = "widget";

            pub const Type = ?*gtk.Widget;
        };
    };

    pub const signals = struct {};

    /// This function specifies the callback function to be called
    /// when the widget corresponding to a GtkAccessible is destroyed.
    extern fn gtk_accessible_connect_widget_destroyed(p_accessible: *Accessible) void;
    pub const connectWidgetDestroyed = gtk_accessible_connect_widget_destroyed;

    /// Gets the `gtk.Widget` corresponding to the `gtk.Accessible`.
    /// The returned widget does not have a reference added, so
    /// you do not need to unref it.
    extern fn gtk_accessible_get_widget(p_accessible: *Accessible) ?*gtk.Widget;
    pub const getWidget = gtk_accessible_get_widget;

    /// Sets the `gtk.Widget` corresponding to the `gtk.Accessible`.
    ///
    /// `accessible` will not hold a reference to `widget`.
    /// It is the caller’s responsibility to ensure that when `widget`
    /// is destroyed, the widget is unset by calling this function
    /// again with `widget` set to `NULL`.
    extern fn gtk_accessible_set_widget(p_accessible: *Accessible, p_widget: ?*gtk.Widget) void;
    pub const setWidget = gtk_accessible_set_widget;

    extern fn gtk_accessible_get_type() usize;
    pub const getGObjectType = gtk_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.Accessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Accessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Accessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// > In GTK+ 3.10, GtkAction has been deprecated. Use `gio.Action`
/// > instead, and associate actions with `gtk.Actionable` widgets. Use
/// > `gio.MenuModel` for creating menus with `gtk.Menu.newFromModel`.
///
/// Actions represent operations that the user can be perform, along with
/// some information how it should be presented in the interface. Each action
/// provides methods to create icons, menu items and toolbar items
/// representing itself.
///
/// As well as the callback that is called when the action gets activated,
/// the following also gets associated with the action:
///
/// - a name (not translated, for path lookup)
///
/// - a label (translated, for display)
///
/// - an accelerator
///
/// - whether label indicates a stock id
///
/// - a tooltip (optional, translated)
///
/// - a toolbar label (optional, shorter than label)
///
///
/// The action will also have some state information:
///
/// - visible (shown/hidden)
///
/// - sensitive (enabled/disabled)
///
/// Apart from regular actions, there are [toggle actions][GtkToggleAction],
/// which can be toggled between two states and
/// [radio actions][GtkRadioAction], of which only one in a group
/// can be in the “active” state. Other actions can be implemented as `gtk.Action`
/// subclasses.
///
/// Each action can have one or more proxy widgets. To act as an action proxy,
/// widget needs to implement `gtk.Activatable` interface. Proxies mirror the state
/// of the action and should change when the action’s state changes. Properties
/// that are always mirrored by proxies are `gtk.Action.properties.sensitive` and
/// `gtk.Action.properties.visible`. `gtk.Action.properties.gicon`, `gtk.Action.properties.icon`-name, `gtk.Action.properties.label`,
/// `gtk.Action.properties.short`-label and `gtk.Action.properties.stock`-id properties are only mirorred
/// if proxy widget has `gtk.Activatable.properties.use`-action-appearance property set to
/// `TRUE`.
///
/// When the proxy is activated, it should activate its action.
pub const Action = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gtk.Buildable};
    pub const Class = gtk.ActionClass;
    f_object: gobject.Object,
    f_private_data: ?*gtk.ActionPrivate,

    pub const virtual_methods = struct {
        /// Emits the “activate” signal on the specified action, if it isn't
        /// insensitive. This gets called by the proxy widgets when they get
        /// activated.
        ///
        /// It can also be used to manually activate an action.
        pub const activate = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Action.Class, p_class).f_activate.?(gobject.ext.as(Action, p_action));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Action.Class, p_class).f_activate = @ptrCast(p_implementation);
            }
        };

        pub const connect_proxy = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_proxy: *gtk.Widget) void {
                return gobject.ext.as(Action.Class, p_class).f_connect_proxy.?(gobject.ext.as(Action, p_action), p_proxy);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_proxy: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(Action.Class, p_class).f_connect_proxy = @ptrCast(p_implementation);
            }
        };

        /// If `action` provides a `gtk.Menu` widget as a submenu for the menu
        /// item or the toolbar item it creates, this function returns an
        /// instance of that menu.
        pub const create_menu = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gtk.Widget {
                return gobject.ext.as(Action.Class, p_class).f_create_menu.?(gobject.ext.as(Action, p_action));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gtk.Widget) void {
                gobject.ext.as(Action.Class, p_class).f_create_menu = @ptrCast(p_implementation);
            }
        };

        /// Creates a menu item widget that proxies for the given action.
        pub const create_menu_item = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gtk.Widget {
                return gobject.ext.as(Action.Class, p_class).f_create_menu_item.?(gobject.ext.as(Action, p_action));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gtk.Widget) void {
                gobject.ext.as(Action.Class, p_class).f_create_menu_item = @ptrCast(p_implementation);
            }
        };

        /// Creates a toolbar item widget that proxies for the given action.
        pub const create_tool_item = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gtk.Widget {
                return gobject.ext.as(Action.Class, p_class).f_create_tool_item.?(gobject.ext.as(Action, p_action));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gtk.Widget) void {
                gobject.ext.as(Action.Class, p_class).f_create_tool_item = @ptrCast(p_implementation);
            }
        };

        pub const disconnect_proxy = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_proxy: *gtk.Widget) void {
                return gobject.ext.as(Action.Class, p_class).f_disconnect_proxy.?(gobject.ext.as(Action, p_action), p_proxy);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_proxy: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(Action.Class, p_class).f_disconnect_proxy = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The GtkActionGroup this GtkAction is associated with, or NULL
        /// (for internal use).
        pub const action_group = struct {
            pub const name = "action-group";

            pub const Type = ?*gtk.ActionGroup;
        };

        /// If `TRUE`, the action's menu item proxies will ignore the `gtk.Settings.properties.gtk`-menu-images
        /// setting and always show their image, if available.
        ///
        /// Use this property if the menu item would be useless or hard to use
        /// without their image.
        pub const always_show_image = struct {
            pub const name = "always-show-image";

            pub const Type = c_int;
        };

        /// The `gio.Icon` displayed in the `gtk.Action`.
        ///
        /// Note that the stock icon is preferred, if the `gtk.Action.properties.stock`-id
        /// property holds the id of an existing stock icon.
        ///
        /// This is an appearance property and thus only applies if
        /// `gtk.Activatable.properties.use`-action-appearance is `TRUE`.
        pub const gicon = struct {
            pub const name = "gicon";

            pub const Type = ?*gio.Icon;
        };

        /// When TRUE, empty menu proxies for this action are hidden.
        pub const hide_if_empty = struct {
            pub const name = "hide-if-empty";

            pub const Type = c_int;
        };

        /// The name of the icon from the icon theme.
        ///
        /// Note that the stock icon is preferred, if the `gtk.Action.properties.stock`-id
        /// property holds the id of an existing stock icon, and the `gio.Icon` is
        /// preferred if the `gtk.Action.properties.gicon` property is set.
        ///
        /// This is an appearance property and thus only applies if
        /// `gtk.Activatable.properties.use`-action-appearance is `TRUE`.
        pub const icon_name = struct {
            pub const name = "icon-name";

            pub const Type = ?[*:0]u8;
        };

        /// Whether the action is considered important. When TRUE, toolitem
        /// proxies for this action show text in GTK_TOOLBAR_BOTH_HORIZ mode.
        pub const is_important = struct {
            pub const name = "is-important";

            pub const Type = c_int;
        };

        /// The label used for menu items and buttons that activate
        /// this action. If the label is `NULL`, GTK+ uses the stock
        /// label specified via the stock-id property.
        ///
        /// This is an appearance property and thus only applies if
        /// `gtk.Activatable.properties.use`-action-appearance is `TRUE`.
        pub const label = struct {
            pub const name = "label";

            pub const Type = ?[*:0]u8;
        };

        /// A unique name for the action.
        pub const name = struct {
            pub const name = "name";

            pub const Type = ?[*:0]u8;
        };

        /// Whether the action is enabled.
        pub const sensitive = struct {
            pub const name = "sensitive";

            pub const Type = c_int;
        };

        /// A shorter label that may be used on toolbar buttons.
        ///
        /// This is an appearance property and thus only applies if
        /// `gtk.Activatable.properties.use`-action-appearance is `TRUE`.
        pub const short_label = struct {
            pub const name = "short-label";

            pub const Type = ?[*:0]u8;
        };

        /// The stock icon displayed in widgets representing this action.
        ///
        /// This is an appearance property and thus only applies if
        /// `gtk.Activatable.properties.use`-action-appearance is `TRUE`.
        pub const stock_id = struct {
            pub const name = "stock-id";

            pub const Type = ?[*:0]u8;
        };

        /// A tooltip for this action.
        pub const tooltip = struct {
            pub const name = "tooltip";

            pub const Type = ?[*:0]u8;
        };

        /// Whether the action is visible.
        pub const visible = struct {
            pub const name = "visible";

            pub const Type = c_int;
        };

        /// Whether the toolbar item is visible when the toolbar is in a horizontal orientation.
        pub const visible_horizontal = struct {
            pub const name = "visible-horizontal";

            pub const Type = c_int;
        };

        /// When `TRUE`, toolitem proxies for this action are represented in the
        /// toolbar overflow menu.
        pub const visible_overflown = struct {
            pub const name = "visible-overflown";

            pub const Type = c_int;
        };

        /// Whether the toolbar item is visible when the toolbar is in a vertical orientation.
        pub const visible_vertical = struct {
            pub const name = "visible-vertical";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The "activate" signal is emitted when the action is activated.
        pub const activate = struct {
            pub const name = "activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Action, p_instance))),
                    gobject.signalLookup("activate", Action.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.Action` object. To add the action to a
    /// `gtk.ActionGroup` and set the accelerator for the action,
    /// call `gtk.ActionGroup.addActionWithAccel`.
    /// See the [UI Definition section][XML-UI] for information on allowed action
    /// names.
    extern fn gtk_action_new(p_name: [*:0]const u8, p_label: ?[*:0]const u8, p_tooltip: ?[*:0]const u8, p_stock_id: ?[*:0]const u8) *gtk.Action;
    pub const new = gtk_action_new;

    /// Emits the “activate” signal on the specified action, if it isn't
    /// insensitive. This gets called by the proxy widgets when they get
    /// activated.
    ///
    /// It can also be used to manually activate an action.
    extern fn gtk_action_activate(p_action: *Action) void;
    pub const activate = gtk_action_activate;

    /// Disable activation signals from the action
    ///
    /// This is needed when updating the state of your proxy
    /// `gtk.Activatable` widget could result in calling `gtk.Action.activate`,
    /// this is a convenience function to avoid recursing in those
    /// cases (updating toggle state for instance).
    extern fn gtk_action_block_activate(p_action: *Action) void;
    pub const blockActivate = gtk_action_block_activate;

    /// Installs the accelerator for `action` if `action` has an
    /// accel path and group. See `gtk.Action.setAccelPath` and
    /// `gtk.Action.setAccelGroup`
    ///
    /// Since multiple proxies may independently trigger the installation
    /// of the accelerator, the `action` counts the number of times this
    /// function has been called and doesn’t remove the accelerator until
    /// `gtk.Action.disconnectAccelerator` has been called as many times.
    extern fn gtk_action_connect_accelerator(p_action: *Action) void;
    pub const connectAccelerator = gtk_action_connect_accelerator;

    /// This function is intended for use by action implementations to
    /// create icons displayed in the proxy widgets.
    extern fn gtk_action_create_icon(p_action: *Action, p_icon_size: c_int) *gtk.Widget;
    pub const createIcon = gtk_action_create_icon;

    /// If `action` provides a `gtk.Menu` widget as a submenu for the menu
    /// item or the toolbar item it creates, this function returns an
    /// instance of that menu.
    extern fn gtk_action_create_menu(p_action: *Action) *gtk.Widget;
    pub const createMenu = gtk_action_create_menu;

    /// Creates a menu item widget that proxies for the given action.
    extern fn gtk_action_create_menu_item(p_action: *Action) *gtk.Widget;
    pub const createMenuItem = gtk_action_create_menu_item;

    /// Creates a toolbar item widget that proxies for the given action.
    extern fn gtk_action_create_tool_item(p_action: *Action) *gtk.Widget;
    pub const createToolItem = gtk_action_create_tool_item;

    /// Undoes the effect of one call to `gtk.Action.connectAccelerator`.
    extern fn gtk_action_disconnect_accelerator(p_action: *Action) void;
    pub const disconnectAccelerator = gtk_action_disconnect_accelerator;

    /// Returns the accel closure for this action.
    extern fn gtk_action_get_accel_closure(p_action: *Action) *gobject.Closure;
    pub const getAccelClosure = gtk_action_get_accel_closure;

    /// Returns the accel path for this action.
    extern fn gtk_action_get_accel_path(p_action: *Action) [*:0]const u8;
    pub const getAccelPath = gtk_action_get_accel_path;

    /// Returns whether `action`'s menu item proxies will always
    /// show their image, if available.
    extern fn gtk_action_get_always_show_image(p_action: *Action) c_int;
    pub const getAlwaysShowImage = gtk_action_get_always_show_image;

    /// Gets the gicon of `action`.
    extern fn gtk_action_get_gicon(p_action: *Action) *gio.Icon;
    pub const getGicon = gtk_action_get_gicon;

    /// Gets the icon name of `action`.
    extern fn gtk_action_get_icon_name(p_action: *Action) [*:0]const u8;
    pub const getIconName = gtk_action_get_icon_name;

    /// Checks whether `action` is important or not
    extern fn gtk_action_get_is_important(p_action: *Action) c_int;
    pub const getIsImportant = gtk_action_get_is_important;

    /// Gets the label text of `action`.
    extern fn gtk_action_get_label(p_action: *Action) [*:0]const u8;
    pub const getLabel = gtk_action_get_label;

    /// Returns the name of the action.
    extern fn gtk_action_get_name(p_action: *Action) [*:0]const u8;
    pub const getName = gtk_action_get_name;

    /// Returns the proxy widgets for an action.
    /// See also `gtk.Activatable.getRelatedAction`.
    extern fn gtk_action_get_proxies(p_action: *Action) *glib.SList;
    pub const getProxies = gtk_action_get_proxies;

    /// Returns whether the action itself is sensitive. Note that this doesn’t
    /// necessarily mean effective sensitivity. See `gtk.Action.isSensitive`
    /// for that.
    extern fn gtk_action_get_sensitive(p_action: *Action) c_int;
    pub const getSensitive = gtk_action_get_sensitive;

    /// Gets the short label text of `action`.
    extern fn gtk_action_get_short_label(p_action: *Action) [*:0]const u8;
    pub const getShortLabel = gtk_action_get_short_label;

    /// Gets the stock id of `action`.
    extern fn gtk_action_get_stock_id(p_action: *Action) [*:0]const u8;
    pub const getStockId = gtk_action_get_stock_id;

    /// Gets the tooltip text of `action`.
    extern fn gtk_action_get_tooltip(p_action: *Action) [*:0]const u8;
    pub const getTooltip = gtk_action_get_tooltip;

    /// Returns whether the action itself is visible. Note that this doesn’t
    /// necessarily mean effective visibility. See `gtk.Action.isSensitive`
    /// for that.
    extern fn gtk_action_get_visible(p_action: *Action) c_int;
    pub const getVisible = gtk_action_get_visible;

    /// Checks whether `action` is visible when horizontal
    extern fn gtk_action_get_visible_horizontal(p_action: *Action) c_int;
    pub const getVisibleHorizontal = gtk_action_get_visible_horizontal;

    /// Checks whether `action` is visible when horizontal
    extern fn gtk_action_get_visible_vertical(p_action: *Action) c_int;
    pub const getVisibleVertical = gtk_action_get_visible_vertical;

    /// Returns whether the action is effectively sensitive.
    extern fn gtk_action_is_sensitive(p_action: *Action) c_int;
    pub const isSensitive = gtk_action_is_sensitive;

    /// Returns whether the action is effectively visible.
    extern fn gtk_action_is_visible(p_action: *Action) c_int;
    pub const isVisible = gtk_action_is_visible;

    /// Sets the `gtk.AccelGroup` in which the accelerator for this action
    /// will be installed.
    extern fn gtk_action_set_accel_group(p_action: *Action, p_accel_group: ?*gtk.AccelGroup) void;
    pub const setAccelGroup = gtk_action_set_accel_group;

    /// Sets the accel path for this action.  All proxy widgets associated
    /// with the action will have this accel path, so that their
    /// accelerators are consistent.
    ///
    /// Note that `accel_path` string will be stored in a `glib.Quark`. Therefore, if you
    /// pass a static string, you can save some memory by interning it first with
    /// `glib.internStaticString`.
    extern fn gtk_action_set_accel_path(p_action: *Action, p_accel_path: [*:0]const u8) void;
    pub const setAccelPath = gtk_action_set_accel_path;

    /// Sets whether `action`'s menu item proxies will ignore the
    /// `gtk.Settings.properties.gtk`-menu-images setting and always show their image, if available.
    ///
    /// Use this if the menu item would be useless or hard to use
    /// without their image.
    extern fn gtk_action_set_always_show_image(p_action: *Action, p_always_show: c_int) void;
    pub const setAlwaysShowImage = gtk_action_set_always_show_image;

    /// Sets the icon of `action`.
    extern fn gtk_action_set_gicon(p_action: *Action, p_icon: *gio.Icon) void;
    pub const setGicon = gtk_action_set_gicon;

    /// Sets the icon name on `action`
    extern fn gtk_action_set_icon_name(p_action: *Action, p_icon_name: [*:0]const u8) void;
    pub const setIconName = gtk_action_set_icon_name;

    /// Sets whether the action is important, this attribute is used
    /// primarily by toolbar items to decide whether to show a label
    /// or not.
    extern fn gtk_action_set_is_important(p_action: *Action, p_is_important: c_int) void;
    pub const setIsImportant = gtk_action_set_is_important;

    /// Sets the label of `action`.
    extern fn gtk_action_set_label(p_action: *Action, p_label: [*:0]const u8) void;
    pub const setLabel = gtk_action_set_label;

    /// Sets the :sensitive property of the action to `sensitive`. Note that
    /// this doesn’t necessarily mean effective sensitivity. See
    /// `gtk.Action.isSensitive`
    /// for that.
    extern fn gtk_action_set_sensitive(p_action: *Action, p_sensitive: c_int) void;
    pub const setSensitive = gtk_action_set_sensitive;

    /// Sets a shorter label text on `action`.
    extern fn gtk_action_set_short_label(p_action: *Action, p_short_label: [*:0]const u8) void;
    pub const setShortLabel = gtk_action_set_short_label;

    /// Sets the stock id on `action`
    extern fn gtk_action_set_stock_id(p_action: *Action, p_stock_id: [*:0]const u8) void;
    pub const setStockId = gtk_action_set_stock_id;

    /// Sets the tooltip text on `action`
    extern fn gtk_action_set_tooltip(p_action: *Action, p_tooltip: [*:0]const u8) void;
    pub const setTooltip = gtk_action_set_tooltip;

    /// Sets the :visible property of the action to `visible`. Note that
    /// this doesn’t necessarily mean effective visibility. See
    /// `gtk.Action.isVisible`
    /// for that.
    extern fn gtk_action_set_visible(p_action: *Action, p_visible: c_int) void;
    pub const setVisible = gtk_action_set_visible;

    /// Sets whether `action` is visible when horizontal
    extern fn gtk_action_set_visible_horizontal(p_action: *Action, p_visible_horizontal: c_int) void;
    pub const setVisibleHorizontal = gtk_action_set_visible_horizontal;

    /// Sets whether `action` is visible when vertical
    extern fn gtk_action_set_visible_vertical(p_action: *Action, p_visible_vertical: c_int) void;
    pub const setVisibleVertical = gtk_action_set_visible_vertical;

    /// Reenable activation signals from the action
    extern fn gtk_action_unblock_activate(p_action: *Action) void;
    pub const unblockActivate = gtk_action_unblock_activate;

    extern fn gtk_action_get_type() usize;
    pub const getGObjectType = gtk_action_get_type;

    extern fn g_object_ref(p_self: *gtk.Action) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Action) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Action, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkActionBar is designed to present contextual actions. It is
/// expected to be displayed below the content and expand horizontally
/// to fill the area.
///
/// It allows placing children at the start or the end. In addition, it
/// contains an internal centered box which is centered with respect to
/// the full width of the box, even if the children at either side take
/// up different amounts of space.
///
/// # CSS nodes
///
/// GtkActionBar has a single CSS node with name actionbar.
pub const ActionBar = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.ActionBarClass;
    f_bin: gtk.Bin,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.ActionBar` widget.
    extern fn gtk_action_bar_new() *gtk.ActionBar;
    pub const new = gtk_action_bar_new;

    /// Retrieves the center bar widget of the bar.
    extern fn gtk_action_bar_get_center_widget(p_action_bar: *ActionBar) ?*gtk.Widget;
    pub const getCenterWidget = gtk_action_bar_get_center_widget;

    /// Adds `child` to `action_bar`, packed with reference to the
    /// end of the `action_bar`.
    extern fn gtk_action_bar_pack_end(p_action_bar: *ActionBar, p_child: *gtk.Widget) void;
    pub const packEnd = gtk_action_bar_pack_end;

    /// Adds `child` to `action_bar`, packed with reference to the
    /// start of the `action_bar`.
    extern fn gtk_action_bar_pack_start(p_action_bar: *ActionBar, p_child: *gtk.Widget) void;
    pub const packStart = gtk_action_bar_pack_start;

    /// Sets the center widget for the `gtk.ActionBar`.
    extern fn gtk_action_bar_set_center_widget(p_action_bar: *ActionBar, p_center_widget: ?*gtk.Widget) void;
    pub const setCenterWidget = gtk_action_bar_set_center_widget;

    extern fn gtk_action_bar_get_type() usize;
    pub const getGObjectType = gtk_action_bar_get_type;

    extern fn g_object_ref(p_self: *gtk.ActionBar) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ActionBar) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ActionBar, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Actions are organised into groups. An action group is essentially a
/// map from names to `gtk.Action` objects.
///
/// All actions that would make sense to use in a particular context
/// should be in a single group. Multiple action groups may be used for a
/// particular user interface. In fact, it is expected that most nontrivial
/// applications will make use of multiple groups. For example, in an
/// application that can edit multiple documents, one group holding global
/// actions (e.g. quit, about, new), and one group per document holding
/// actions that act on that document (eg. save, cut/copy/paste, etc). Each
/// window’s menus would be constructed from a combination of two action
/// groups.
///
/// ## Accelerators
///
/// Accelerators are handled by the GTK+ accelerator map. All actions are
/// assigned an accelerator path (which normally has the form
/// `<Actions>/group-name/action-name`) and a shortcut is associated with
/// this accelerator path. All menuitems and toolitems take on this accelerator
/// path. The GTK+ accelerator map code makes sure that the correct shortcut
/// is displayed next to the menu item.
///
/// # GtkActionGroup as GtkBuildable
///
/// The `gtk.ActionGroup` implementation of the `gtk.Buildable` interface accepts
/// `gtk.Action` objects as `<child>` elements in UI definitions.
///
/// Note that it is probably more common to define actions and action groups
/// in the code, since they are directly related to what the code can do.
///
/// The GtkActionGroup implementation of the GtkBuildable interface supports
/// a custom `<accelerator>` element, which has attributes named “key“ and
/// “modifiers“ and allows to specify accelerators. This is similar to the
/// `<accelerator>` element of `gtk.Widget`, the main difference is that
/// it doesn’t allow you to specify a signal.
///
/// ## A
///
/// ```
/// <object class="GtkActionGroup" id="actiongroup">
///   <child>
///       <object class="GtkAction" id="About">
///           <property name="name">About</property>
///           <property name="stock_id">gtk-about</property>
///           <signal handler="about_activate" name="activate"/>
///       </object>
///       <accelerator key="F1" modifiers="GDK_CONTROL_MASK | GDK_SHIFT_MASK"/>
///   </child>
/// </object>
/// ```
pub const ActionGroup = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gtk.Buildable};
    pub const Class = gtk.ActionGroupClass;
    f_parent: gobject.Object,
    f_priv: ?*gtk.ActionGroupPrivate,

    pub const virtual_methods = struct {
        /// Looks up an action in the action group by name.
        pub const get_action = struct {
            pub fn call(p_class: anytype, p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) *gtk.Action {
                return gobject.ext.as(ActionGroup.Class, p_class).f_get_action.?(gobject.ext.as(ActionGroup, p_action_group), p_action_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) callconv(.c) *gtk.Action) void {
                gobject.ext.as(ActionGroup.Class, p_class).f_get_action = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The accelerator group the actions of this group should use.
        pub const accel_group = struct {
            pub const name = "accel-group";

            pub const Type = ?*gtk.AccelGroup;
        };

        /// A name for the action.
        pub const name = struct {
            pub const name = "name";

            pub const Type = ?[*:0]u8;
        };

        /// Whether the action group is enabled.
        pub const sensitive = struct {
            pub const name = "sensitive";

            pub const Type = c_int;
        };

        /// Whether the action group is visible.
        pub const visible = struct {
            pub const name = "visible";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::connect-proxy signal is emitted after connecting a proxy to
        /// an action in the group. Note that the proxy may have been connected
        /// to a different action before.
        ///
        /// This is intended for simple customizations for which a custom action
        /// class would be too clumsy, e.g. showing tooltips for menuitems in the
        /// statusbar.
        ///
        /// `gtk.UIManager` proxies the signal and provides global notification
        /// just before any action is connected to a proxy, which is probably more
        /// convenient to use.
        pub const connect_proxy = struct {
            pub const name = "connect-proxy";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_action: *gtk.Action, p_proxy: *gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ActionGroup, p_instance))),
                    gobject.signalLookup("connect-proxy", ActionGroup.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::disconnect-proxy signal is emitted after disconnecting a proxy
        /// from an action in the group.
        ///
        /// `gtk.UIManager` proxies the signal and provides global notification
        /// just before any action is connected to a proxy, which is probably more
        /// convenient to use.
        pub const disconnect_proxy = struct {
            pub const name = "disconnect-proxy";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_action: *gtk.Action, p_proxy: *gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ActionGroup, p_instance))),
                    gobject.signalLookup("disconnect-proxy", ActionGroup.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::post-activate signal is emitted just after the `action` in the
        /// `action_group` is activated
        ///
        /// This is intended for `gtk.UIManager` to proxy the signal and provide global
        /// notification just after any action is activated.
        pub const post_activate = struct {
            pub const name = "post-activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_action: *gtk.Action, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ActionGroup, p_instance))),
                    gobject.signalLookup("post-activate", ActionGroup.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::pre-activate signal is emitted just before the `action` in the
        /// `action_group` is activated
        ///
        /// This is intended for `gtk.UIManager` to proxy the signal and provide global
        /// notification just before any action is activated.
        pub const pre_activate = struct {
            pub const name = "pre-activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_action: *gtk.Action, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ActionGroup, p_instance))),
                    gobject.signalLookup("pre-activate", ActionGroup.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.ActionGroup` object. The name of the action group
    /// is used when associating [keybindings][Action-Accel]
    /// with the actions.
    extern fn gtk_action_group_new(p_name: [*:0]const u8) *gtk.ActionGroup;
    pub const new = gtk_action_group_new;

    /// Adds an action object to the action group. Note that this function
    /// does not set up the accel path of the action, which can lead to problems
    /// if a user tries to modify the accelerator of a menuitem associated with
    /// the action. Therefore you must either set the accel path yourself with
    /// `gtk.Action.setAccelPath`, or use
    /// `gtk_action_group_add_action_with_accel (..., NULL)`.
    extern fn gtk_action_group_add_action(p_action_group: *ActionGroup, p_action: *gtk.Action) void;
    pub const addAction = gtk_action_group_add_action;

    /// Adds an action object to the action group and sets up the accelerator.
    ///
    /// If `accelerator` is `NULL`, attempts to use the accelerator associated
    /// with the stock_id of the action.
    ///
    /// Accel paths are set to `<Actions>/group-name/action-name`.
    extern fn gtk_action_group_add_action_with_accel(p_action_group: *ActionGroup, p_action: *gtk.Action, p_accelerator: ?[*:0]const u8) void;
    pub const addActionWithAccel = gtk_action_group_add_action_with_accel;

    /// This is a convenience function to create a number of actions and add them
    /// to the action group.
    ///
    /// The “activate” signals of the actions are connected to the callbacks
    /// and their accel paths are set to `<Actions>/group-name/action-name`.
    extern fn gtk_action_group_add_actions(p_action_group: *ActionGroup, p_entries: [*]const gtk.ActionEntry, p_n_entries: c_uint, p_user_data: ?*anyopaque) void;
    pub const addActions = gtk_action_group_add_actions;

    /// This variant of `gtk.ActionGroup.addActions` adds a `glib.DestroyNotify`
    /// callback for `user_data`.
    extern fn gtk_action_group_add_actions_full(p_action_group: *ActionGroup, p_entries: [*]const gtk.ActionEntry, p_n_entries: c_uint, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const addActionsFull = gtk_action_group_add_actions_full;

    /// This is a convenience routine to create a group of radio actions and
    /// add them to the action group.
    ///
    /// The “changed” signal of the first radio action is connected to the
    /// `on_change` callback and the accel paths of the actions are set to
    /// `<Actions>/group-name/action-name`.
    extern fn gtk_action_group_add_radio_actions(p_action_group: *ActionGroup, p_entries: [*]const gtk.RadioActionEntry, p_n_entries: c_uint, p_value: c_int, p_on_change: gobject.Callback, p_user_data: ?*anyopaque) void;
    pub const addRadioActions = gtk_action_group_add_radio_actions;

    /// This variant of `gtk.ActionGroup.addRadioActions` adds a
    /// `glib.DestroyNotify` callback for `user_data`.
    extern fn gtk_action_group_add_radio_actions_full(p_action_group: *ActionGroup, p_entries: [*]const gtk.RadioActionEntry, p_n_entries: c_uint, p_value: c_int, p_on_change: gobject.Callback, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const addRadioActionsFull = gtk_action_group_add_radio_actions_full;

    /// This is a convenience function to create a number of toggle actions and add them
    /// to the action group.
    ///
    /// The “activate” signals of the actions are connected to the callbacks
    /// and their accel paths are set to `<Actions>/group-name/action-name`.
    extern fn gtk_action_group_add_toggle_actions(p_action_group: *ActionGroup, p_entries: [*]const gtk.ToggleActionEntry, p_n_entries: c_uint, p_user_data: ?*anyopaque) void;
    pub const addToggleActions = gtk_action_group_add_toggle_actions;

    /// This variant of `gtk.ActionGroup.addToggleActions` adds a
    /// `glib.DestroyNotify` callback for `user_data`.
    extern fn gtk_action_group_add_toggle_actions_full(p_action_group: *ActionGroup, p_entries: [*]const gtk.ToggleActionEntry, p_n_entries: c_uint, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const addToggleActionsFull = gtk_action_group_add_toggle_actions_full;

    /// Gets the accelerator group.
    extern fn gtk_action_group_get_accel_group(p_action_group: *ActionGroup) *gtk.AccelGroup;
    pub const getAccelGroup = gtk_action_group_get_accel_group;

    /// Looks up an action in the action group by name.
    extern fn gtk_action_group_get_action(p_action_group: *ActionGroup, p_action_name: [*:0]const u8) *gtk.Action;
    pub const getAction = gtk_action_group_get_action;

    /// Gets the name of the action group.
    extern fn gtk_action_group_get_name(p_action_group: *ActionGroup) [*:0]const u8;
    pub const getName = gtk_action_group_get_name;

    /// Returns `TRUE` if the group is sensitive.  The constituent actions
    /// can only be logically sensitive (see `gtk.Action.isSensitive`) if
    /// they are sensitive (see `gtk.Action.getSensitive`) and their group
    /// is sensitive.
    extern fn gtk_action_group_get_sensitive(p_action_group: *ActionGroup) c_int;
    pub const getSensitive = gtk_action_group_get_sensitive;

    /// Returns `TRUE` if the group is visible.  The constituent actions
    /// can only be logically visible (see `gtk.Action.isVisible`) if
    /// they are visible (see `gtk.Action.getVisible`) and their group
    /// is visible.
    extern fn gtk_action_group_get_visible(p_action_group: *ActionGroup) c_int;
    pub const getVisible = gtk_action_group_get_visible;

    /// Lists the actions in the action group.
    extern fn gtk_action_group_list_actions(p_action_group: *ActionGroup) *glib.List;
    pub const listActions = gtk_action_group_list_actions;

    /// Removes an action object from the action group.
    extern fn gtk_action_group_remove_action(p_action_group: *ActionGroup, p_action: *gtk.Action) void;
    pub const removeAction = gtk_action_group_remove_action;

    /// Sets the accelerator group to be used by every action in this group.
    extern fn gtk_action_group_set_accel_group(p_action_group: *ActionGroup, p_accel_group: ?*gtk.AccelGroup) void;
    pub const setAccelGroup = gtk_action_group_set_accel_group;

    /// Changes the sensitivity of `action_group`
    extern fn gtk_action_group_set_sensitive(p_action_group: *ActionGroup, p_sensitive: c_int) void;
    pub const setSensitive = gtk_action_group_set_sensitive;

    /// Sets a function to be used for translating the `label` and `tooltip` of
    /// `GtkActionEntrys` added by `gtk.ActionGroup.addActions`.
    ///
    /// If you’re using `gettext`, it is enough to set the translation domain
    /// with `gtk.ActionGroup.setTranslationDomain`.
    extern fn gtk_action_group_set_translate_func(p_action_group: *ActionGroup, p_func: gtk.TranslateFunc, p_data: ?*anyopaque, p_notify: ?glib.DestroyNotify) void;
    pub const setTranslateFunc = gtk_action_group_set_translate_func;

    /// Sets the translation domain and uses `glib.dgettext` for translating the
    /// `label` and `tooltip` of `GtkActionEntrys` added by
    /// `gtk.ActionGroup.addActions`.
    ///
    /// If you’re not using `gettext` for localization, see
    /// `gtk.ActionGroup.setTranslateFunc`.
    extern fn gtk_action_group_set_translation_domain(p_action_group: *ActionGroup, p_domain: ?[*:0]const u8) void;
    pub const setTranslationDomain = gtk_action_group_set_translation_domain;

    /// Changes the visible of `action_group`.
    extern fn gtk_action_group_set_visible(p_action_group: *ActionGroup, p_visible: c_int) void;
    pub const setVisible = gtk_action_group_set_visible;

    /// Translates a string using the function set with
    /// `gtk.ActionGroup.setTranslateFunc`. This
    /// is mainly intended for language bindings.
    extern fn gtk_action_group_translate_string(p_action_group: *ActionGroup, p_string: [*:0]const u8) [*:0]const u8;
    pub const translateString = gtk_action_group_translate_string;

    extern fn gtk_action_group_get_type() usize;
    pub const getGObjectType = gtk_action_group_get_type;

    extern fn g_object_ref(p_self: *gtk.ActionGroup) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ActionGroup) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ActionGroup, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Adjustment` object represents a value which has an associated lower
/// and upper bound, together with step and page increments, and a page size.
/// It is used within several GTK+ widgets, including `gtk.SpinButton`, `gtk.Viewport`,
/// and `gtk.Range` (which is a base class for `gtk.Scrollbar` and `gtk.Scale`).
///
/// The `gtk.Adjustment` object does not update the value itself. Instead
/// it is left up to the owner of the `gtk.Adjustment` to control the value.
pub const Adjustment = extern struct {
    pub const Parent = gobject.InitiallyUnowned;
    pub const Implements = [_]type{};
    pub const Class = gtk.AdjustmentClass;
    f_parent_instance: gobject.InitiallyUnowned,
    f_priv: ?*gtk.AdjustmentPrivate,

    pub const virtual_methods = struct {
        /// Emits a `gtk.Adjustment.signals.changed` signal from the `gtk.Adjustment`.
        /// This is typically called by the owner of the `gtk.Adjustment` after it has
        /// changed any of the `gtk.Adjustment` properties other than the value.
        pub const changed = struct {
            pub fn call(p_class: anytype, p_adjustment: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Adjustment.Class, p_class).f_changed.?(gobject.ext.as(Adjustment, p_adjustment));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_adjustment: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Adjustment.Class, p_class).f_changed = @ptrCast(p_implementation);
            }
        };

        /// Emits a `gtk.Adjustment.signals.value`-changed signal from the `gtk.Adjustment`.
        /// This is typically called by the owner of the `gtk.Adjustment` after it has
        /// changed the `gtk.Adjustment.properties.value` property.
        pub const value_changed = struct {
            pub fn call(p_class: anytype, p_adjustment: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Adjustment.Class, p_class).f_value_changed.?(gobject.ext.as(Adjustment, p_adjustment));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_adjustment: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Adjustment.Class, p_class).f_value_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The minimum value of the adjustment.
        pub const lower = struct {
            pub const name = "lower";

            pub const Type = f64;
        };

        /// The page increment of the adjustment.
        pub const page_increment = struct {
            pub const name = "page-increment";

            pub const Type = f64;
        };

        /// The page size of the adjustment.
        /// Note that the page-size is irrelevant and should be set to zero
        /// if the adjustment is used for a simple scalar value, e.g. in a
        /// `gtk.SpinButton`.
        pub const page_size = struct {
            pub const name = "page-size";

            pub const Type = f64;
        };

        /// The step increment of the adjustment.
        pub const step_increment = struct {
            pub const name = "step-increment";

            pub const Type = f64;
        };

        /// The maximum value of the adjustment.
        /// Note that values will be restricted by
        /// `upper - page-size` if the page-size
        /// property is nonzero.
        pub const upper = struct {
            pub const name = "upper";

            pub const Type = f64;
        };

        /// The value of the adjustment.
        pub const value = struct {
            pub const name = "value";

            pub const Type = f64;
        };
    };

    pub const signals = struct {
        /// Emitted when one or more of the `gtk.Adjustment` properties have been
        /// changed, other than the `gtk.Adjustment.properties.value` property.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Adjustment, p_instance))),
                    gobject.signalLookup("changed", Adjustment.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the `gtk.Adjustment.properties.value` property has been changed.
        pub const value_changed = struct {
            pub const name = "value-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Adjustment, p_instance))),
                    gobject.signalLookup("value-changed", Adjustment.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.Adjustment`.
    extern fn gtk_adjustment_new(p_value: f64, p_lower: f64, p_upper: f64, p_step_increment: f64, p_page_increment: f64, p_page_size: f64) *gtk.Adjustment;
    pub const new = gtk_adjustment_new;

    /// Emits a `gtk.Adjustment.signals.changed` signal from the `gtk.Adjustment`.
    /// This is typically called by the owner of the `gtk.Adjustment` after it has
    /// changed any of the `gtk.Adjustment` properties other than the value.
    extern fn gtk_adjustment_changed(p_adjustment: *Adjustment) void;
    pub const changed = gtk_adjustment_changed;

    /// Updates the `gtk.Adjustment.properties.value` property to ensure that the range
    /// between `lower` and `upper` is in the current page (i.e. between
    /// `gtk.Adjustment.properties.value` and `gtk.Adjustment.properties.value` + `gtk.Adjustment.properties.page`-size).
    /// If the range is larger than the page size, then only the start of it will
    /// be in the current page.
    ///
    /// A `gtk.Adjustment.signals.value`-changed signal will be emitted if the value is changed.
    extern fn gtk_adjustment_clamp_page(p_adjustment: *Adjustment, p_lower: f64, p_upper: f64) void;
    pub const clampPage = gtk_adjustment_clamp_page;

    /// Sets all properties of the adjustment at once.
    ///
    /// Use this function to avoid multiple emissions of the
    /// `gtk.Adjustment.signals.changed` signal. See `gtk.Adjustment.setLower`
    /// for an alternative way of compressing multiple emissions of
    /// `gtk.Adjustment.signals.changed` into one.
    extern fn gtk_adjustment_configure(p_adjustment: *Adjustment, p_value: f64, p_lower: f64, p_upper: f64, p_step_increment: f64, p_page_increment: f64, p_page_size: f64) void;
    pub const configure = gtk_adjustment_configure;

    /// Retrieves the minimum value of the adjustment.
    extern fn gtk_adjustment_get_lower(p_adjustment: *Adjustment) f64;
    pub const getLower = gtk_adjustment_get_lower;

    /// Gets the smaller of step increment and page increment.
    extern fn gtk_adjustment_get_minimum_increment(p_adjustment: *Adjustment) f64;
    pub const getMinimumIncrement = gtk_adjustment_get_minimum_increment;

    /// Retrieves the page increment of the adjustment.
    extern fn gtk_adjustment_get_page_increment(p_adjustment: *Adjustment) f64;
    pub const getPageIncrement = gtk_adjustment_get_page_increment;

    /// Retrieves the page size of the adjustment.
    extern fn gtk_adjustment_get_page_size(p_adjustment: *Adjustment) f64;
    pub const getPageSize = gtk_adjustment_get_page_size;

    /// Retrieves the step increment of the adjustment.
    extern fn gtk_adjustment_get_step_increment(p_adjustment: *Adjustment) f64;
    pub const getStepIncrement = gtk_adjustment_get_step_increment;

    /// Retrieves the maximum value of the adjustment.
    extern fn gtk_adjustment_get_upper(p_adjustment: *Adjustment) f64;
    pub const getUpper = gtk_adjustment_get_upper;

    /// Gets the current value of the adjustment.
    /// See `gtk.Adjustment.setValue`.
    extern fn gtk_adjustment_get_value(p_adjustment: *Adjustment) f64;
    pub const getValue = gtk_adjustment_get_value;

    /// Sets the minimum value of the adjustment.
    ///
    /// When setting multiple adjustment properties via their individual
    /// setters, multiple `gtk.Adjustment.signals.changed` signals will be emitted.
    /// However, since the emission of the `gtk.Adjustment.signals.changed` signal
    /// is tied to the emission of the `gobject.Object.signals.notify` signals of the changed
    /// properties, it’s possible to compress the `gtk.Adjustment.signals.changed`
    /// signals into one by calling `gobject.Object.freezeNotify` and
    /// `gobject.Object.thawNotify` around the calls to the individual setters.
    ///
    /// Alternatively, using a single `gobject.Object.set` for all the properties
    /// to change, or using `gtk.Adjustment.configure` has the same effect
    /// of compressing `gtk.Adjustment.signals.changed` emissions.
    extern fn gtk_adjustment_set_lower(p_adjustment: *Adjustment, p_lower: f64) void;
    pub const setLower = gtk_adjustment_set_lower;

    /// Sets the page increment of the adjustment.
    ///
    /// See `gtk.Adjustment.setLower` about how to compress multiple
    /// emissions of the `gtk.Adjustment.signals.changed` signal when setting
    /// multiple adjustment properties.
    extern fn gtk_adjustment_set_page_increment(p_adjustment: *Adjustment, p_page_increment: f64) void;
    pub const setPageIncrement = gtk_adjustment_set_page_increment;

    /// Sets the page size of the adjustment.
    ///
    /// See `gtk.Adjustment.setLower` about how to compress multiple
    /// emissions of the GtkAdjustment::changed signal when setting
    /// multiple adjustment properties.
    extern fn gtk_adjustment_set_page_size(p_adjustment: *Adjustment, p_page_size: f64) void;
    pub const setPageSize = gtk_adjustment_set_page_size;

    /// Sets the step increment of the adjustment.
    ///
    /// See `gtk.Adjustment.setLower` about how to compress multiple
    /// emissions of the `gtk.Adjustment.signals.changed` signal when setting
    /// multiple adjustment properties.
    extern fn gtk_adjustment_set_step_increment(p_adjustment: *Adjustment, p_step_increment: f64) void;
    pub const setStepIncrement = gtk_adjustment_set_step_increment;

    /// Sets the maximum value of the adjustment.
    ///
    /// Note that values will be restricted by `upper - page-size`
    /// if the page-size property is nonzero.
    ///
    /// See `gtk.Adjustment.setLower` about how to compress multiple
    /// emissions of the `gtk.Adjustment.signals.changed` signal when setting
    /// multiple adjustment properties.
    extern fn gtk_adjustment_set_upper(p_adjustment: *Adjustment, p_upper: f64) void;
    pub const setUpper = gtk_adjustment_set_upper;

    /// Sets the `gtk.Adjustment` value. The value is clamped to lie between
    /// `gtk.Adjustment.properties.lower` and `gtk.Adjustment.properties.upper`.
    ///
    /// Note that for adjustments which are used in a `gtk.Scrollbar`, the
    /// effective range of allowed values goes from `gtk.Adjustment.properties.lower` to
    /// `gtk.Adjustment.properties.upper` - `gtk.Adjustment.properties.page`-size.
    extern fn gtk_adjustment_set_value(p_adjustment: *Adjustment, p_value: f64) void;
    pub const setValue = gtk_adjustment_set_value;

    /// Emits a `gtk.Adjustment.signals.value`-changed signal from the `gtk.Adjustment`.
    /// This is typically called by the owner of the `gtk.Adjustment` after it has
    /// changed the `gtk.Adjustment.properties.value` property.
    extern fn gtk_adjustment_value_changed(p_adjustment: *Adjustment) void;
    pub const valueChanged = gtk_adjustment_value_changed;

    extern fn gtk_adjustment_get_type() usize;
    pub const getGObjectType = gtk_adjustment_get_type;

    extern fn g_object_ref(p_self: *gtk.Adjustment) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Adjustment) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Adjustment, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Alignment` widget controls the alignment and size of its child widget.
/// It has four settings: xscale, yscale, xalign, and yalign.
///
/// The scale settings are used to specify how much the child widget should
/// expand to fill the space allocated to the `gtk.Alignment`.
/// The values can range from 0 (meaning the child doesn’t expand at all) to
/// 1 (meaning the child expands to fill all of the available space).
///
/// The align settings are used to place the child widget within the available
/// area. The values range from 0 (top or left) to 1 (bottom or right).
/// Of course, if the scale settings are both set to 1, the alignment settings
/// have no effect.
///
/// GtkAlignment has been deprecated in 3.14 and should not be used in
/// newly-written code. The desired effect can be achieved by using the
/// `gtk.Widget.properties.halign`, `gtk.Widget.properties.valign` and `gtk.Widget.properties.margin` properties on the
/// child widget.
pub const Alignment = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.AlignmentClass;
    f_bin: gtk.Bin,
    f_priv: ?*gtk.AlignmentPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The padding to insert at the bottom of the widget.
        pub const bottom_padding = struct {
            pub const name = "bottom-padding";

            pub const Type = c_uint;
        };

        /// The padding to insert at the left of the widget.
        pub const left_padding = struct {
            pub const name = "left-padding";

            pub const Type = c_uint;
        };

        /// The padding to insert at the right of the widget.
        pub const right_padding = struct {
            pub const name = "right-padding";

            pub const Type = c_uint;
        };

        /// The padding to insert at the top of the widget.
        pub const top_padding = struct {
            pub const name = "top-padding";

            pub const Type = c_uint;
        };

        /// Horizontal position of child in available space. A value of 0.0
        /// will flush the child left (or right, in RTL locales); a value
        /// of 1.0 will flush the child right (or left, in RTL locales).
        pub const xalign = struct {
            pub const name = "xalign";

            pub const Type = f32;
        };

        /// If available horizontal space is bigger than needed, how much
        /// of it to use for the child. A value of 0.0 means none; a value
        /// of 1.0 means all.
        pub const xscale = struct {
            pub const name = "xscale";

            pub const Type = f32;
        };

        /// Vertical position of child in available space. A value of 0.0
        /// will flush the child to the top; a value of 1.0 will flush the
        /// child to the bottom.
        pub const yalign = struct {
            pub const name = "yalign";

            pub const Type = f32;
        };

        /// If available vertical space is bigger than needed, how much
        /// of it to use for the child. A value of 0.0 means none; a value
        /// of 1.0 means all.
        pub const yscale = struct {
            pub const name = "yscale";

            pub const Type = f32;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.Alignment`.
    extern fn gtk_alignment_new(p_xalign: f32, p_yalign: f32, p_xscale: f32, p_yscale: f32) *gtk.Alignment;
    pub const new = gtk_alignment_new;

    /// Gets the padding on the different sides of the widget.
    /// See gtk_alignment_set_padding ().
    extern fn gtk_alignment_get_padding(p_alignment: *Alignment, p_padding_top: ?*c_uint, p_padding_bottom: ?*c_uint, p_padding_left: ?*c_uint, p_padding_right: ?*c_uint) void;
    pub const getPadding = gtk_alignment_get_padding;

    /// Sets the `gtk.Alignment` values.
    extern fn gtk_alignment_set(p_alignment: *Alignment, p_xalign: f32, p_yalign: f32, p_xscale: f32, p_yscale: f32) void;
    pub const set = gtk_alignment_set;

    /// Sets the padding on the different sides of the widget.
    /// The padding adds blank space to the sides of the widget. For instance,
    /// this can be used to indent the child widget towards the right by adding
    /// padding on the left.
    extern fn gtk_alignment_set_padding(p_alignment: *Alignment, p_padding_top: c_uint, p_padding_bottom: c_uint, p_padding_left: c_uint, p_padding_right: c_uint) void;
    pub const setPadding = gtk_alignment_set_padding;

    extern fn gtk_alignment_get_type() usize;
    pub const getGObjectType = gtk_alignment_get_type;

    extern fn g_object_ref(p_self: *gtk.Alignment) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Alignment) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Alignment, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.AppChooserButton` is a widget that lets the user select
/// an application. It implements the `gtk.AppChooser` interface.
///
/// Initially, a `gtk.AppChooserButton` selects the first application
/// in its list, which will either be the most-recently used application
/// or, if `gtk.AppChooserButton.properties.show`-default-item is `TRUE`, the
/// default application.
///
/// The list of applications shown in a `gtk.AppChooserButton` includes
/// the recommended applications for the given content type. When
/// `gtk.AppChooserButton.properties.show`-default-item is set, the default application
/// is also included. To let the user chooser other applications,
/// you can set the `gtk.AppChooserButton.properties.show`-dialog-item property,
/// which allows to open a full `gtk.AppChooserDialog`.
///
/// It is possible to add custom items to the list, using
/// `gtk.AppChooserButton.appendCustomItem`. These items cause
/// the `gtk.AppChooserButton.signals.custom`-item-activated signal to be
/// emitted when they are selected.
///
/// To track changes in the selected application, use the
/// `gtk.ComboBox.signals.changed` signal.
pub const AppChooserButton = extern struct {
    pub const Parent = gtk.ComboBox;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.AppChooser, gtk.Buildable, gtk.CellEditable, gtk.CellLayout };
    pub const Class = gtk.AppChooserButtonClass;
    f_parent: gtk.ComboBox,
    f_priv: ?*gtk.AppChooserButtonPrivate,

    pub const virtual_methods = struct {
        /// Signal emitted when a custom item,
        ///    previously added with `gtk.AppChooserButton.appendCustomItem`,
        ///    is activated from the dropdown menu.
        pub const custom_item_activated = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_item_name: [*:0]const u8) void {
                return gobject.ext.as(AppChooserButton.Class, p_class).f_custom_item_activated.?(gobject.ext.as(AppChooserButton, p_self), p_item_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_item_name: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(AppChooserButton.Class, p_class).f_custom_item_activated = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The text to show at the top of the dialog that can be
        /// opened from the button. The string may contain Pango markup.
        pub const heading = struct {
            pub const name = "heading";

            pub const Type = ?[*:0]u8;
        };

        /// The `gtk.AppChooserButton.properties.show`-default-item property determines
        /// whether the dropdown menu should show the default application
        /// on top for the provided content type.
        pub const show_default_item = struct {
            pub const name = "show-default-item";

            pub const Type = c_int;
        };

        /// The `gtk.AppChooserButton.properties.show`-dialog-item property determines
        /// whether the dropdown menu should show an item that triggers
        /// a `gtk.AppChooserDialog` when clicked.
        pub const show_dialog_item = struct {
            pub const name = "show-dialog-item";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted when a custom item, previously added with
        /// `gtk.AppChooserButton.appendCustomItem`, is activated from the
        /// dropdown menu.
        pub const custom_item_activated = struct {
            pub const name = "custom-item-activated";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_item_name: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(AppChooserButton, p_instance))),
                    gobject.signalLookup("custom-item-activated", AppChooserButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.AppChooserButton` for applications
    /// that can handle content of the given type.
    extern fn gtk_app_chooser_button_new(p_content_type: [*:0]const u8) *gtk.AppChooserButton;
    pub const new = gtk_app_chooser_button_new;

    /// Appends a custom item to the list of applications that is shown
    /// in the popup; the item name must be unique per-widget.
    /// Clients can use the provided name as a detail for the
    /// `gtk.AppChooserButton.signals.custom`-item-activated signal, to add a
    /// callback for the activation of a particular custom item in the list.
    /// See also `gtk.AppChooserButton.appendSeparator`.
    extern fn gtk_app_chooser_button_append_custom_item(p_self: *AppChooserButton, p_name: [*:0]const u8, p_label: [*:0]const u8, p_icon: *gio.Icon) void;
    pub const appendCustomItem = gtk_app_chooser_button_append_custom_item;

    /// Appends a separator to the list of applications that is shown
    /// in the popup.
    extern fn gtk_app_chooser_button_append_separator(p_self: *AppChooserButton) void;
    pub const appendSeparator = gtk_app_chooser_button_append_separator;

    /// Returns the text to display at the top of the dialog.
    extern fn gtk_app_chooser_button_get_heading(p_self: *AppChooserButton) ?[*:0]const u8;
    pub const getHeading = gtk_app_chooser_button_get_heading;

    /// Returns the current value of the `gtk.AppChooserButton.properties.show`-default-item
    /// property.
    extern fn gtk_app_chooser_button_get_show_default_item(p_self: *AppChooserButton) c_int;
    pub const getShowDefaultItem = gtk_app_chooser_button_get_show_default_item;

    /// Returns the current value of the `gtk.AppChooserButton.properties.show`-dialog-item
    /// property.
    extern fn gtk_app_chooser_button_get_show_dialog_item(p_self: *AppChooserButton) c_int;
    pub const getShowDialogItem = gtk_app_chooser_button_get_show_dialog_item;

    /// Selects a custom item previously added with
    /// `gtk.AppChooserButton.appendCustomItem`.
    ///
    /// Use `gtk.AppChooser.refresh` to bring the selection
    /// to its initial state.
    extern fn gtk_app_chooser_button_set_active_custom_item(p_self: *AppChooserButton, p_name: [*:0]const u8) void;
    pub const setActiveCustomItem = gtk_app_chooser_button_set_active_custom_item;

    /// Sets the text to display at the top of the dialog.
    /// If the heading is not set, the dialog displays a default text.
    extern fn gtk_app_chooser_button_set_heading(p_self: *AppChooserButton, p_heading: [*:0]const u8) void;
    pub const setHeading = gtk_app_chooser_button_set_heading;

    /// Sets whether the dropdown menu of this button should show the
    /// default application for the given content type at top.
    extern fn gtk_app_chooser_button_set_show_default_item(p_self: *AppChooserButton, p_setting: c_int) void;
    pub const setShowDefaultItem = gtk_app_chooser_button_set_show_default_item;

    /// Sets whether the dropdown menu of this button should show an
    /// entry to trigger a `gtk.AppChooserDialog`.
    extern fn gtk_app_chooser_button_set_show_dialog_item(p_self: *AppChooserButton, p_setting: c_int) void;
    pub const setShowDialogItem = gtk_app_chooser_button_set_show_dialog_item;

    extern fn gtk_app_chooser_button_get_type() usize;
    pub const getGObjectType = gtk_app_chooser_button_get_type;

    extern fn g_object_ref(p_self: *gtk.AppChooserButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.AppChooserButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *AppChooserButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.AppChooserDialog` shows a `gtk.AppChooserWidget` inside a `gtk.Dialog`.
///
/// Note that `gtk.AppChooserDialog` does not have any interesting methods
/// of its own. Instead, you should get the embedded `gtk.AppChooserWidget`
/// using `gtk.AppChooserDialog.getWidget` and call its methods if
/// the generic `gtk.AppChooser` interface is not sufficient for your needs.
///
/// To set the heading that is shown above the `gtk.AppChooserWidget`,
/// use `gtk.AppChooserDialog.setHeading`.
pub const AppChooserDialog = extern struct {
    pub const Parent = gtk.Dialog;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.AppChooser, gtk.Buildable };
    pub const Class = gtk.AppChooserDialogClass;
    f_parent: gtk.Dialog,
    f_priv: ?*gtk.AppChooserDialogPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The GFile used by the `gtk.AppChooserDialog`.
        /// The dialog's `gtk.AppChooserWidget` content type will be guessed from the
        /// file, if present.
        pub const gfile = struct {
            pub const name = "gfile";

            pub const Type = ?*gio.File;
        };

        /// The text to show at the top of the dialog.
        /// The string may contain Pango markup.
        pub const heading = struct {
            pub const name = "heading";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.AppChooserDialog` for the provided `gio.File`,
    /// to allow the user to select an application for it.
    extern fn gtk_app_chooser_dialog_new(p_parent: ?*gtk.Window, p_flags: gtk.DialogFlags, p_file: *gio.File) *gtk.AppChooserDialog;
    pub const new = gtk_app_chooser_dialog_new;

    /// Creates a new `gtk.AppChooserDialog` for the provided content type,
    /// to allow the user to select an application for it.
    extern fn gtk_app_chooser_dialog_new_for_content_type(p_parent: ?*gtk.Window, p_flags: gtk.DialogFlags, p_content_type: [*:0]const u8) *gtk.AppChooserDialog;
    pub const newForContentType = gtk_app_chooser_dialog_new_for_content_type;

    /// Returns the text to display at the top of the dialog.
    extern fn gtk_app_chooser_dialog_get_heading(p_self: *AppChooserDialog) ?[*:0]const u8;
    pub const getHeading = gtk_app_chooser_dialog_get_heading;

    /// Returns the `gtk.AppChooserWidget` of this dialog.
    extern fn gtk_app_chooser_dialog_get_widget(p_self: *AppChooserDialog) *gtk.Widget;
    pub const getWidget = gtk_app_chooser_dialog_get_widget;

    /// Sets the text to display at the top of the dialog.
    /// If the heading is not set, the dialog displays a default text.
    extern fn gtk_app_chooser_dialog_set_heading(p_self: *AppChooserDialog, p_heading: [*:0]const u8) void;
    pub const setHeading = gtk_app_chooser_dialog_set_heading;

    extern fn gtk_app_chooser_dialog_get_type() usize;
    pub const getGObjectType = gtk_app_chooser_dialog_get_type;

    extern fn g_object_ref(p_self: *gtk.AppChooserDialog) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.AppChooserDialog) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *AppChooserDialog, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.AppChooserWidget` is a widget for selecting applications.
/// It is the main building block for `gtk.AppChooserDialog`. Most
/// applications only need to use the latter; but you can use
/// this widget as part of a larger widget if you have special needs.
///
/// `gtk.AppChooserWidget` offers detailed control over what applications
/// are shown, using the
/// `gtk.AppChooserWidget.properties.show`-default,
/// `gtk.AppChooserWidget.properties.show`-recommended,
/// `gtk.AppChooserWidget.properties.show`-fallback,
/// `gtk.AppChooserWidget.properties.show`-other and
/// `gtk.AppChooserWidget.properties.show`-all
/// properties. See the `gtk.AppChooser` documentation for more information
/// about these groups of applications.
///
/// To keep track of the selected application, use the
/// `gtk.AppChooserWidget.signals.application`-selected and `gtk.AppChooserWidget.signals.application`-activated signals.
///
/// # CSS nodes
///
/// GtkAppChooserWidget has a single CSS node with name appchooser.
pub const AppChooserWidget = extern struct {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.AppChooser, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.AppChooserWidgetClass;
    f_parent: gtk.Box,
    f_priv: ?*gtk.AppChooserWidgetPrivate,

    pub const virtual_methods = struct {
        /// Signal emitted when an application item is
        ///    activated from the widget’s list.
        pub const application_activated = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_app_info: *gio.AppInfo) void {
                return gobject.ext.as(AppChooserWidget.Class, p_class).f_application_activated.?(gobject.ext.as(AppChooserWidget, p_self), p_app_info);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_app_info: *gio.AppInfo) callconv(.c) void) void {
                gobject.ext.as(AppChooserWidget.Class, p_class).f_application_activated = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when an application item is
        ///    selected from the widget’s list.
        pub const application_selected = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_app_info: *gio.AppInfo) void {
                return gobject.ext.as(AppChooserWidget.Class, p_class).f_application_selected.?(gobject.ext.as(AppChooserWidget, p_self), p_app_info);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_app_info: *gio.AppInfo) callconv(.c) void) void {
                gobject.ext.as(AppChooserWidget.Class, p_class).f_application_selected = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when a context menu is about to
        ///    popup over an application item.
        pub const populate_popup = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_menu: *gtk.Menu, p_app_info: *gio.AppInfo) void {
                return gobject.ext.as(AppChooserWidget.Class, p_class).f_populate_popup.?(gobject.ext.as(AppChooserWidget, p_self), p_menu, p_app_info);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_menu: *gtk.Menu, p_app_info: *gio.AppInfo) callconv(.c) void) void {
                gobject.ext.as(AppChooserWidget.Class, p_class).f_populate_popup = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The `gtk.AppChooserWidget.properties.default`-text property determines the text
        /// that appears in the widget when there are no applications for the
        /// given content type.
        /// See also `gtk.AppChooserWidget.setDefaultText`.
        pub const default_text = struct {
            pub const name = "default-text";

            pub const Type = ?[*:0]u8;
        };

        /// If the `gtk.AppChooserWidget.properties.show`-all property is `TRUE`, the app
        /// chooser presents all applications in a single list, without
        /// subsections for default, recommended or related applications.
        pub const show_all = struct {
            pub const name = "show-all";

            pub const Type = c_int;
        };

        /// The ::show-default property determines whether the app chooser
        /// should show the default handler for the content type in a
        /// separate section. If `FALSE`, the default handler is listed
        /// among the recommended applications.
        pub const show_default = struct {
            pub const name = "show-default";

            pub const Type = c_int;
        };

        /// The `gtk.AppChooserWidget.properties.show`-fallback property determines whether
        /// the app chooser should show a section for fallback applications.
        /// If `FALSE`, the fallback applications are listed among the other
        /// applications.
        pub const show_fallback = struct {
            pub const name = "show-fallback";

            pub const Type = c_int;
        };

        /// The `gtk.AppChooserWidget.properties.show`-other property determines whether
        /// the app chooser should show a section for other applications.
        pub const show_other = struct {
            pub const name = "show-other";

            pub const Type = c_int;
        };

        /// The `gtk.AppChooserWidget.properties.show`-recommended property determines
        /// whether the app chooser should show a section for recommended
        /// applications. If `FALSE`, the recommended applications are listed
        /// among the other applications.
        pub const show_recommended = struct {
            pub const name = "show-recommended";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted when an application item is activated from the widget's list.
        ///
        /// This usually happens when the user double clicks an item, or an item
        /// is selected and the user presses one of the keys Space, Shift+Space,
        /// Return or Enter.
        pub const application_activated = struct {
            pub const name = "application-activated";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_application: *gio.AppInfo, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(AppChooserWidget, p_instance))),
                    gobject.signalLookup("application-activated", AppChooserWidget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when an application item is selected from the widget's list.
        pub const application_selected = struct {
            pub const name = "application-selected";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_application: *gio.AppInfo, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(AppChooserWidget, p_instance))),
                    gobject.signalLookup("application-selected", AppChooserWidget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when a context menu is about to popup over an application item.
        /// Clients can insert menu items into the provided `gtk.Menu` object in the
        /// callback of this signal; the context menu will be shown over the item
        /// if at least one item has been added to the menu.
        pub const populate_popup = struct {
            pub const name = "populate-popup";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_menu: *gtk.Menu, p_application: *gio.AppInfo, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(AppChooserWidget, p_instance))),
                    gobject.signalLookup("populate-popup", AppChooserWidget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.AppChooserWidget` for applications
    /// that can handle content of the given type.
    extern fn gtk_app_chooser_widget_new(p_content_type: [*:0]const u8) *gtk.AppChooserWidget;
    pub const new = gtk_app_chooser_widget_new;

    /// Returns the text that is shown if there are not applications
    /// that can handle the content type.
    extern fn gtk_app_chooser_widget_get_default_text(p_self: *AppChooserWidget) [*:0]const u8;
    pub const getDefaultText = gtk_app_chooser_widget_get_default_text;

    /// Returns the current value of the `gtk.AppChooserWidget.properties.show`-all
    /// property.
    extern fn gtk_app_chooser_widget_get_show_all(p_self: *AppChooserWidget) c_int;
    pub const getShowAll = gtk_app_chooser_widget_get_show_all;

    /// Returns the current value of the `gtk.AppChooserWidget.properties.show`-default
    /// property.
    extern fn gtk_app_chooser_widget_get_show_default(p_self: *AppChooserWidget) c_int;
    pub const getShowDefault = gtk_app_chooser_widget_get_show_default;

    /// Returns the current value of the `gtk.AppChooserWidget.properties.show`-fallback
    /// property.
    extern fn gtk_app_chooser_widget_get_show_fallback(p_self: *AppChooserWidget) c_int;
    pub const getShowFallback = gtk_app_chooser_widget_get_show_fallback;

    /// Returns the current value of the `gtk.AppChooserWidget.properties.show`-other
    /// property.
    extern fn gtk_app_chooser_widget_get_show_other(p_self: *AppChooserWidget) c_int;
    pub const getShowOther = gtk_app_chooser_widget_get_show_other;

    /// Returns the current value of the `gtk.AppChooserWidget.properties.show`-recommended
    /// property.
    extern fn gtk_app_chooser_widget_get_show_recommended(p_self: *AppChooserWidget) c_int;
    pub const getShowRecommended = gtk_app_chooser_widget_get_show_recommended;

    /// Sets the text that is shown if there are not applications
    /// that can handle the content type.
    extern fn gtk_app_chooser_widget_set_default_text(p_self: *AppChooserWidget, p_text: [*:0]const u8) void;
    pub const setDefaultText = gtk_app_chooser_widget_set_default_text;

    /// Sets whether the app chooser should show all applications
    /// in a flat list.
    extern fn gtk_app_chooser_widget_set_show_all(p_self: *AppChooserWidget, p_setting: c_int) void;
    pub const setShowAll = gtk_app_chooser_widget_set_show_all;

    /// Sets whether the app chooser should show the default handler
    /// for the content type in a separate section.
    extern fn gtk_app_chooser_widget_set_show_default(p_self: *AppChooserWidget, p_setting: c_int) void;
    pub const setShowDefault = gtk_app_chooser_widget_set_show_default;

    /// Sets whether the app chooser should show related applications
    /// for the content type in a separate section.
    extern fn gtk_app_chooser_widget_set_show_fallback(p_self: *AppChooserWidget, p_setting: c_int) void;
    pub const setShowFallback = gtk_app_chooser_widget_set_show_fallback;

    /// Sets whether the app chooser should show applications
    /// which are unrelated to the content type.
    extern fn gtk_app_chooser_widget_set_show_other(p_self: *AppChooserWidget, p_setting: c_int) void;
    pub const setShowOther = gtk_app_chooser_widget_set_show_other;

    /// Sets whether the app chooser should show recommended applications
    /// for the content type in a separate section.
    extern fn gtk_app_chooser_widget_set_show_recommended(p_self: *AppChooserWidget, p_setting: c_int) void;
    pub const setShowRecommended = gtk_app_chooser_widget_set_show_recommended;

    extern fn gtk_app_chooser_widget_get_type() usize;
    pub const getGObjectType = gtk_app_chooser_widget_get_type;

    extern fn g_object_ref(p_self: *gtk.AppChooserWidget) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.AppChooserWidget) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *AppChooserWidget, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.Application` is a class that handles many important aspects
/// of a GTK+ application in a convenient fashion, without enforcing
/// a one-size-fits-all application model.
///
/// Currently, GtkApplication handles GTK+ initialization, application
/// uniqueness, session management, provides some basic scriptability and
/// desktop shell integration by exporting actions and menus and manages a
/// list of toplevel windows whose life-cycle is automatically tied to the
/// life-cycle of your application.
///
/// While GtkApplication works fine with plain `GtkWindows`, it is recommended
/// to use it together with `gtk.ApplicationWindow`.
///
/// When GDK threads are enabled, GtkApplication will acquire the GDK
/// lock when invoking actions that arrive from other processes.  The GDK
/// lock is not touched for local action invocations.  In order to have
/// actions invoked in a predictable context it is therefore recommended
/// that the GDK lock be held while invoking actions locally with
/// `gio.ActionGroup.activateAction`.  The same applies to actions
/// associated with `gtk.ApplicationWindow` and to the “activate” and
/// “open” `gio.Application` methods.
///
/// ## Automatic resources
///
/// `gtk.Application` will automatically load menus from the `gtk.Builder`
/// resource located at "gtk/menus.ui", relative to the application's
/// resource base path (see `gio.Application.setResourceBasePath`).  The
/// menu with the ID "app-menu" is taken as the application's app menu
/// and the menu with the ID "menubar" is taken as the application's
/// menubar.  Additional menus (most interesting submenus) can be named
/// and accessed via `gtk.Application.getMenuById` which allows for
/// dynamic population of a part of the menu structure.
///
/// If the resources "gtk/menus-appmenu.ui" or "gtk/menus-traditional.ui" are
/// present then these files will be used in preference, depending on the value
/// of `gtk.Application.prefersAppMenu`. If the resource "gtk/menus-common.ui"
/// is present it will be loaded as well. This is useful for storing items that
/// are referenced from both "gtk/menus-appmenu.ui" and
/// "gtk/menus-traditional.ui".
///
/// It is also possible to provide the menus manually using
/// `gtk.Application.setAppMenu` and `gtk.Application.setMenubar`.
///
/// `gtk.Application` will also automatically setup an icon search path for
/// the default icon theme by appending "icons" to the resource base
/// path.  This allows your application to easily store its icons as
/// resources.  See `gtk.IconTheme.addResourcePath` for more
/// information.
///
/// If there is a resource located at "gtk/help-overlay.ui" which
/// defines a `gtk.ShortcutsWindow` with ID "help_overlay" then GtkApplication
/// associates an instance of this shortcuts window with each
/// `gtk.ApplicationWindow` and sets up keyboard accelerators (Control-F1
/// and Control-?) to open it. To create a menu item that displays the
/// shortcuts window, associate the item with the action win.show-help-overlay.
///
/// ## A simple application
///
/// [A simple example](https://gitlab.gnome.org/GNOME/gtk/-/blob/gtk-3-24/examples/bp/bloatpad.c)
///
/// GtkApplication optionally registers with a session manager
/// of the users session (if you set the `gtk.Application.properties.register`-session
/// property) and offers various functionality related to the session
/// life-cycle.
///
/// An application can block various ways to end the session with
/// the `gtk.Application.inhibit` function. Typical use cases for
/// this kind of inhibiting are long-running, uninterruptible operations,
/// such as burning a CD or performing a disk backup. The session
/// manager may not honor the inhibitor, but it can be expected to
/// inform the user about the negative consequences of ending the
/// session while inhibitors are present.
///
/// ## See Also
/// [HowDoI: Using GtkApplication](https://wiki.gnome.org/HowDoI/GtkApplication),
/// [Getting Started with GTK+: Basics](https://developer.gnome.org/gtk3/stable/gtk-getting-started.html`id`-1.2.3.3)
pub const Application = extern struct {
    pub const Parent = gio.Application;
    pub const Implements = [_]type{ gio.ActionGroup, gio.ActionMap };
    pub const Class = gtk.ApplicationClass;
    f_parent: gio.Application,
    f_priv: ?*gtk.ApplicationPrivate,

    pub const virtual_methods = struct {
        /// Signal emitted when a `gtk.Window` is added to
        ///    application through `gtk.Application.addWindow`.
        pub const window_added = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_window: *gtk.Window) void {
                return gobject.ext.as(Application.Class, p_class).f_window_added.?(gobject.ext.as(Application, p_application), p_window);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_window: *gtk.Window) callconv(.c) void) void {
                gobject.ext.as(Application.Class, p_class).f_window_added = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when a `gtk.Window` is removed from
        ///    application, either as a side-effect of being destroyed or
        ///    explicitly through `gtk.Application.removeWindow`.
        pub const window_removed = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_window: *gtk.Window) void {
                return gobject.ext.as(Application.Class, p_class).f_window_removed.?(gobject.ext.as(Application, p_application), p_window);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_window: *gtk.Window) callconv(.c) void) void {
                gobject.ext.as(Application.Class, p_class).f_window_removed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const active_window = struct {
            pub const name = "active-window";

            pub const Type = ?*gtk.Window;
        };

        pub const app_menu = struct {
            pub const name = "app-menu";

            pub const Type = ?*gio.MenuModel;
        };

        pub const menubar = struct {
            pub const name = "menubar";

            pub const Type = ?*gio.MenuModel;
        };

        /// Set this property to `TRUE` to register with the session manager.
        pub const register_session = struct {
            pub const name = "register-session";

            pub const Type = c_int;
        };

        /// This property is `TRUE` if GTK+ believes that the screensaver is
        /// currently active. GTK+ only tracks session state (including this)
        /// when `gtk.Application.signals.register`-session is set to `TRUE`.
        ///
        /// Tracking the screensaver state is supported on Linux.
        pub const screensaver_active = struct {
            pub const name = "screensaver-active";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted when the session manager is about to end the session, only
        /// if `gtk.Application.signals.register`-session is `TRUE`. Applications can
        /// connect to this signal and call `gtk.Application.inhibit` with
        /// `GTK_APPLICATION_INHIBIT_LOGOUT` to delay the end of the session
        /// until state has been saved.
        pub const query_end = struct {
            pub const name = "query-end";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Application, p_instance))),
                    gobject.signalLookup("query-end", Application.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when a `gtk.Window` is added to `application` through
        /// `gtk.Application.addWindow`.
        pub const window_added = struct {
            pub const name = "window-added";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_window: *gtk.Window, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Application, p_instance))),
                    gobject.signalLookup("window-added", Application.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when a `gtk.Window` is removed from `application`,
        /// either as a side-effect of being destroyed or explicitly
        /// through `gtk.Application.removeWindow`.
        pub const window_removed = struct {
            pub const name = "window-removed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_window: *gtk.Window, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Application, p_instance))),
                    gobject.signalLookup("window-removed", Application.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.Application` instance.
    ///
    /// When using `gtk.Application`, it is not necessary to call `gtk.init`
    /// manually. It is called as soon as the application gets registered as
    /// the primary instance.
    ///
    /// Concretely, `gtk.init` is called in the default handler for the
    /// `gio.Application.signals.startup` signal. Therefore, `gtk.Application` subclasses should
    /// chain up in their `gio.Application.signals.startup` handler before using any GTK+ API.
    ///
    /// Note that commandline arguments are not passed to `gtk.init`.
    /// All GTK+ functionality that is available via commandline arguments
    /// can also be achieved by setting suitable environment variables
    /// such as `G_DEBUG`, so this should not be a big
    /// problem. If you absolutely must support GTK+ commandline arguments,
    /// you can explicitly call `gtk.init` before creating the application
    /// instance.
    ///
    /// If non-`NULL`, the application ID must be valid.  See
    /// `gio.Application.idIsValid`.
    ///
    /// If no application ID is given then some features (most notably application
    /// uniqueness) will be disabled. A null application ID is only allowed with
    /// GTK+ 3.6 or later.
    extern fn gtk_application_new(p_application_id: ?[*:0]const u8, p_flags: gio.ApplicationFlags) *gtk.Application;
    pub const new = gtk_application_new;

    /// Installs an accelerator that will cause the named action
    /// to be activated when the key combination specificed by `accelerator`
    /// is pressed.
    ///
    /// `accelerator` must be a string that can be parsed by `gtk.acceleratorParse`,
    /// e.g. "<Primary>q" or “<Control><Alt>p”.
    ///
    /// `action_name` must be the name of an action as it would be used
    /// in the app menu, i.e. actions that have been added to the application
    /// are referred to with an “app.” prefix, and window-specific actions
    /// with a “win.” prefix.
    ///
    /// GtkApplication also extracts accelerators out of “accel” attributes
    /// in the `GMenuModels` passed to `gtk.Application.setAppMenu` and
    /// `gtk.Application.setMenubar`, which is usually more convenient
    /// than calling this function for each accelerator.
    extern fn gtk_application_add_accelerator(p_application: *Application, p_accelerator: [*:0]const u8, p_action_name: [*:0]const u8, p_parameter: ?*glib.Variant) void;
    pub const addAccelerator = gtk_application_add_accelerator;

    /// Adds a window to `application`.
    ///
    /// This call can only happen after the `application` has started;
    /// typically, you should add new application windows in response
    /// to the emission of the `gio.Application.signals.activate` signal.
    ///
    /// This call is equivalent to setting the `gtk.Window.properties.application`
    /// property of `window` to `application`.
    ///
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it with `gtk.Application.removeWindow`.
    ///
    /// GTK+ will keep the `application` running as long as it has
    /// any windows.
    extern fn gtk_application_add_window(p_application: *Application, p_window: *gtk.Window) void;
    pub const addWindow = gtk_application_add_window;

    /// Gets the accelerators that are currently associated with
    /// the given action.
    extern fn gtk_application_get_accels_for_action(p_application: *Application, p_detailed_action_name: [*:0]const u8) [*][*:0]u8;
    pub const getAccelsForAction = gtk_application_get_accels_for_action;

    /// Returns the list of actions (possibly empty) that `accel` maps to.
    /// Each item in the list is a detailed action name in the usual form.
    ///
    /// This might be useful to discover if an accel already exists in
    /// order to prevent installation of a conflicting accelerator (from
    /// an accelerator editor or a plugin system, for example). Note that
    /// having more than one action per accelerator may not be a bad thing
    /// and might make sense in cases where the actions never appear in the
    /// same context.
    ///
    /// In case there are no actions for a given accelerator, an empty array
    /// is returned.  `NULL` is never returned.
    ///
    /// It is a programmer error to pass an invalid accelerator string.
    /// If you are unsure, check it with `gtk.acceleratorParse` first.
    extern fn gtk_application_get_actions_for_accel(p_application: *Application, p_accel: [*:0]const u8) [*][*:0]u8;
    pub const getActionsForAccel = gtk_application_get_actions_for_accel;

    /// Gets the “active” window for the application.
    ///
    /// The active window is the one that was most recently focused (within
    /// the application).  This window may not have the focus at the moment
    /// if another application has it — this is just the most
    /// recently-focused window within this application.
    extern fn gtk_application_get_active_window(p_application: *Application) ?*gtk.Window;
    pub const getActiveWindow = gtk_application_get_active_window;

    /// Returns the menu model that has been set with
    /// `gtk.Application.setAppMenu`.
    extern fn gtk_application_get_app_menu(p_application: *Application) ?*gio.MenuModel;
    pub const getAppMenu = gtk_application_get_app_menu;

    /// Gets a menu from automatically loaded resources.
    /// See [Automatic resources][automatic-resources]
    /// for more information.
    extern fn gtk_application_get_menu_by_id(p_application: *Application, p_id: [*:0]const u8) *gio.Menu;
    pub const getMenuById = gtk_application_get_menu_by_id;

    /// Returns the menu model that has been set with
    /// `gtk.Application.setMenubar`.
    extern fn gtk_application_get_menubar(p_application: *Application) *gio.MenuModel;
    pub const getMenubar = gtk_application_get_menubar;

    /// Returns the `gtk.ApplicationWindow` with the given ID.
    ///
    /// The ID of a `gtk.ApplicationWindow` can be retrieved with
    /// `gtk.ApplicationWindow.getId`.
    extern fn gtk_application_get_window_by_id(p_application: *Application, p_id: c_uint) ?*gtk.Window;
    pub const getWindowById = gtk_application_get_window_by_id;

    /// Gets a list of the `GtkWindows` associated with `application`.
    ///
    /// The list is sorted by most recently focused window, such that the first
    /// element is the currently focused window. (Useful for choosing a parent
    /// for a transient window.)
    ///
    /// The list that is returned should not be modified in any way. It will
    /// only remain valid until the next focus change or window creation or
    /// deletion.
    extern fn gtk_application_get_windows(p_application: *Application) *glib.List;
    pub const getWindows = gtk_application_get_windows;

    /// Inform the session manager that certain types of actions should be
    /// inhibited. This is not guaranteed to work on all platforms and for
    /// all types of actions.
    ///
    /// Applications should invoke this method when they begin an operation
    /// that should not be interrupted, such as creating a CD or DVD. The
    /// types of actions that may be blocked are specified by the `flags`
    /// parameter. When the application completes the operation it should
    /// call `gtk.Application.uninhibit` to remove the inhibitor. Note that
    /// an application can have multiple inhibitors, and all of them must
    /// be individually removed. Inhibitors are also cleared when the
    /// application exits.
    ///
    /// Applications should not expect that they will always be able to block
    /// the action. In most cases, users will be given the option to force
    /// the action to take place.
    ///
    /// Reasons should be short and to the point.
    ///
    /// If `window` is given, the session manager may point the user to
    /// this window to find out more about why the action is inhibited.
    extern fn gtk_application_inhibit(p_application: *Application, p_window: ?*gtk.Window, p_flags: gtk.ApplicationInhibitFlags, p_reason: ?[*:0]const u8) c_uint;
    pub const inhibit = gtk_application_inhibit;

    /// Determines if any of the actions specified in `flags` are
    /// currently inhibited (possibly by another application).
    ///
    /// Note that this information may not be available (for example
    /// when the application is running in a sandbox).
    extern fn gtk_application_is_inhibited(p_application: *Application, p_flags: gtk.ApplicationInhibitFlags) c_int;
    pub const isInhibited = gtk_application_is_inhibited;

    /// Lists the detailed action names which have associated accelerators.
    /// See `gtk.Application.setAccelsForAction`.
    extern fn gtk_application_list_action_descriptions(p_application: *Application) [*][*:0]u8;
    pub const listActionDescriptions = gtk_application_list_action_descriptions;

    /// Determines if the desktop environment in which the application is
    /// running would prefer an application menu be shown.
    ///
    /// If this function returns `TRUE` then the application should call
    /// `gtk.Application.setAppMenu` with the contents of an application
    /// menu, which will be shown by the desktop environment.  If it returns
    /// `FALSE` then you should consider using an alternate approach, such as
    /// a menubar.
    ///
    /// The value returned by this function is purely advisory and you are
    /// free to ignore it.  If you call `gtk.Application.setAppMenu` even
    /// if the desktop environment doesn't support app menus, then a fallback
    /// will be provided.
    ///
    /// Applications are similarly free not to set an app menu even if the
    /// desktop environment wants to show one.  In that case, a fallback will
    /// also be created by the desktop environment (GNOME, for example, uses
    /// a menu with only a "Quit" item in it).
    ///
    /// The value returned by this function never changes.  Once it returns a
    /// particular value, it is guaranteed to always return the same value.
    ///
    /// You may only call this function after the application has been
    /// registered and after the base startup handler has run.  You're most
    /// likely to want to use this from your own startup handler.  It may
    /// also make sense to consult this function while constructing UI (in
    /// activate, open or an action activation handler) in order to determine
    /// if you should show a gear menu or not.
    ///
    /// This function will return `FALSE` on Mac OS and a default app menu
    /// will be created automatically with the "usual" contents of that menu
    /// typical to most Mac OS applications.  If you call
    /// `gtk.Application.setAppMenu` anyway, then this menu will be
    /// replaced with your own.
    extern fn gtk_application_prefers_app_menu(p_application: *Application) c_int;
    pub const prefersAppMenu = gtk_application_prefers_app_menu;

    /// Removes an accelerator that has been previously added
    /// with `gtk.Application.addAccelerator`.
    extern fn gtk_application_remove_accelerator(p_application: *Application, p_action_name: [*:0]const u8, p_parameter: ?*glib.Variant) void;
    pub const removeAccelerator = gtk_application_remove_accelerator;

    /// Remove a window from `application`.
    ///
    /// If `window` belongs to `application` then this call is equivalent to
    /// setting the `gtk.Window.properties.application` property of `window` to
    /// `NULL`.
    ///
    /// The application may stop running as a result of a call to this
    /// function.
    extern fn gtk_application_remove_window(p_application: *Application, p_window: *gtk.Window) void;
    pub const removeWindow = gtk_application_remove_window;

    /// Sets zero or more keyboard accelerators that will trigger the
    /// given action. The first item in `accels` will be the primary
    /// accelerator, which may be displayed in the UI.
    ///
    /// To remove all accelerators for an action, use an empty, zero-terminated
    /// array for `accels`.
    ///
    /// For the `detailed_action_name`, see `gio.actionParseDetailedName` and
    /// `gio.actionPrintDetailedName`.
    extern fn gtk_application_set_accels_for_action(p_application: *Application, p_detailed_action_name: [*:0]const u8, p_accels: [*]const [*:0]const u8) void;
    pub const setAccelsForAction = gtk_application_set_accels_for_action;

    /// Sets or unsets the application menu for `application`.
    ///
    /// This can only be done in the primary instance of the application,
    /// after it has been registered.  `gio.Application.signals.startup` is a good place
    /// to call this.
    ///
    /// The application menu is a single menu containing items that typically
    /// impact the application as a whole, rather than acting on a specific
    /// window or document.  For example, you would expect to see
    /// “Preferences” or “Quit” in an application menu, but not “Save” or
    /// “Print”.
    ///
    /// If supported, the application menu will be rendered by the desktop
    /// environment.
    ///
    /// Use the base `gio.ActionMap` interface to add actions, to respond to the user
    /// selecting these menu items.
    extern fn gtk_application_set_app_menu(p_application: *Application, p_app_menu: ?*gio.MenuModel) void;
    pub const setAppMenu = gtk_application_set_app_menu;

    /// Sets or unsets the menubar for windows of `application`.
    ///
    /// This is a menubar in the traditional sense.
    ///
    /// This can only be done in the primary instance of the application,
    /// after it has been registered.  `gio.Application.signals.startup` is a good place
    /// to call this.
    ///
    /// Depending on the desktop environment, this may appear at the top of
    /// each window, or at the top of the screen.  In some environments, if
    /// both the application menu and the menubar are set, the application
    /// menu will be presented as if it were the first item of the menubar.
    /// Other environments treat the two as completely separate — for example,
    /// the application menu may be rendered by the desktop shell while the
    /// menubar (if set) remains in each individual window.
    ///
    /// Use the base `gio.ActionMap` interface to add actions, to respond to the
    /// user selecting these menu items.
    extern fn gtk_application_set_menubar(p_application: *Application, p_menubar: ?*gio.MenuModel) void;
    pub const setMenubar = gtk_application_set_menubar;

    /// Removes an inhibitor that has been established with `gtk.Application.inhibit`.
    /// Inhibitors are also cleared when the application exits.
    extern fn gtk_application_uninhibit(p_application: *Application, p_cookie: c_uint) void;
    pub const uninhibit = gtk_application_uninhibit;

    extern fn gtk_application_get_type() usize;
    pub const getGObjectType = gtk_application_get_type;

    extern fn g_object_ref(p_self: *gtk.Application) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Application) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Application, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.ApplicationWindow` is a `gtk.Window` subclass that offers some
/// extra functionality for better integration with `gtk.Application`
/// features.  Notably, it can handle both the application menu as well
/// as the menubar. See `gtk.Application.setAppMenu` and
/// `gtk.Application.setMenubar`.
///
/// This class implements the `gio.ActionGroup` and `gio.ActionMap` interfaces,
/// to let you add window-specific actions that will be exported by the
/// associated `gtk.Application`, together with its application-wide
/// actions.  Window-specific actions are prefixed with the “win.”
/// prefix and application-wide actions are prefixed with the “app.”
/// prefix.  Actions must be addressed with the prefixed name when
/// referring to them from a `gio.MenuModel`.
///
/// Note that widgets that are placed inside a `gtk.ApplicationWindow`
/// can also activate these actions, if they implement the
/// `gtk.Actionable` interface.
///
/// As with `gtk.Application`, the GDK lock will be acquired when
/// processing actions arriving from other processes and should therefore
/// be held when activating actions locally (if GDK threads are enabled).
///
/// The settings `gtk.Settings.properties.gtk`-shell-shows-app-menu and
/// `gtk.Settings.properties.gtk`-shell-shows-menubar tell GTK+ whether the
/// desktop environment is showing the application menu and menubar
/// models outside the application as part of the desktop shell.
/// For instance, on OS X, both menus will be displayed remotely;
/// on Windows neither will be. gnome-shell (starting with version 3.4)
/// will display the application menu, but not the menubar.
///
/// If the desktop environment does not display the menubar, then
/// `gtk.ApplicationWindow` will automatically show a `gtk.MenuBar` for it.
/// This behaviour can be overridden with the `gtk.ApplicationWindow.properties.show`-menubar
/// property. If the desktop environment does not display the application
/// menu, then it will automatically be included in the menubar or in the
/// windows client-side decorations.
///
/// ## A GtkApplicationWindow with a menubar
///
/// ```
/// GtkApplication *app = gtk_application_new ("org.gtk.test", 0);
///
/// GtkBuilder *builder = gtk_builder_new_from_string (
///     "<interface>"
///     "  <menu id='menubar'>"
///     "    <submenu label='_Edit'>"
///     "      <item label='_Copy' action='win.copy'/>"
///     "      <item label='_Paste' action='win.paste'/>"
///     "    </submenu>"
///     "  </menu>"
///     "</interface>",
///     -1);
///
/// GMenuModel *menubar = G_MENU_MODEL (gtk_builder_get_object (builder,
///                                                             "menubar"));
/// gtk_application_set_menubar (GTK_APPLICATION (app), menubar);
/// g_object_unref (builder);
///
/// // ...
///
/// GtkWidget *window = gtk_application_window_new (app);
/// ```
///
/// ## Handling fallback yourself
///
/// [A simple example](https://git.gnome.org/browse/gtk+/tree/examples/sunny.c)
///
/// The XML format understood by `gtk.Builder` for `gio.MenuModel` consists
/// of a toplevel `<menu>` element, which contains one or more `<item>`
/// elements. Each `<item>` element contains `<attribute>` and `<link>`
/// elements with a mandatory name attribute. `<link>` elements have the
/// same content model as `<menu>`. Instead of `<link name="submenu>` or
/// `<link name="section">`, you can use `<submenu>` or `<section>`
/// elements.
///
/// Attribute values can be translated using gettext, like other `gtk.Builder`
/// content. `<attribute>` elements can be marked for translation with a
/// `translatable="yes"` attribute. It is also possible to specify message
/// context and translator comments, using the context and comments attributes.
/// To make use of this, the `gtk.Builder` must have been given the gettext
/// domain to use.
///
/// The following attributes are used when constructing menu items:
/// - "label": a user-visible string to display
/// - "action": the prefixed name of the action to trigger
/// - "target": the parameter to use when activating the action
/// - "icon" and "verb-icon": names of icons that may be displayed
/// - "submenu-action": name of an action that may be used to determine
///      if a submenu can be opened
/// - "hidden-when": a string used to determine when the item will be hidden.
///      Possible values include "action-disabled", "action-missing", "macos-menubar".
///
/// The following attributes are used when constructing sections:
/// - "label": a user-visible string to use as section heading
/// - "display-hint": a string used to determine special formatting for the section.
///     Possible values include "horizontal-buttons".
/// - "text-direction": a string used to determine the `gtk.TextDirection` to use
///     when "display-hint" is set to "horizontal-buttons". Possible values
///     include "rtl", "ltr", and "none".
///
/// The following attributes are used when constructing submenus:
/// - "label": a user-visible string to display
/// - "icon": icon name to display
pub const ApplicationWindow = extern struct {
    pub const Parent = gtk.Window;
    pub const Implements = [_]type{ atk.ImplementorIface, gio.ActionGroup, gio.ActionMap, gtk.Buildable };
    pub const Class = gtk.ApplicationWindowClass;
    f_parent_instance: gtk.Window,
    f_priv: ?*gtk.ApplicationWindowPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// If this property is `TRUE`, the window will display a menubar
        /// that includes the app menu and menubar, unless these are
        /// shown by the desktop shell. See `gtk.Application.setAppMenu`
        /// and `gtk.Application.setMenubar`.
        ///
        /// If `FALSE`, the window will not display a menubar, regardless
        /// of whether the desktop shell is showing the menus or not.
        pub const show_menubar = struct {
            pub const name = "show-menubar";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.ApplicationWindow`.
    extern fn gtk_application_window_new(p_application: *gtk.Application) *gtk.ApplicationWindow;
    pub const new = gtk_application_window_new;

    /// Gets the `gtk.ShortcutsWindow` that has been set up with
    /// a prior call to `gtk.ApplicationWindow.setHelpOverlay`.
    extern fn gtk_application_window_get_help_overlay(p_window: *ApplicationWindow) ?*gtk.ShortcutsWindow;
    pub const getHelpOverlay = gtk_application_window_get_help_overlay;

    /// Returns the unique ID of the window. If the window has not yet been added to
    /// a `gtk.Application`, returns `0`.
    extern fn gtk_application_window_get_id(p_window: *ApplicationWindow) c_uint;
    pub const getId = gtk_application_window_get_id;

    /// Returns whether the window will display a menubar for the app menu
    /// and menubar as needed.
    extern fn gtk_application_window_get_show_menubar(p_window: *ApplicationWindow) c_int;
    pub const getShowMenubar = gtk_application_window_get_show_menubar;

    /// Associates a shortcuts window with the application window, and
    /// sets up an action with the name win.show-help-overlay to present
    /// it.
    ///
    /// `window` takes resposibility for destroying `help_overlay`.
    extern fn gtk_application_window_set_help_overlay(p_window: *ApplicationWindow, p_help_overlay: ?*gtk.ShortcutsWindow) void;
    pub const setHelpOverlay = gtk_application_window_set_help_overlay;

    /// Sets whether the window will display a menubar for the app menu
    /// and menubar as needed.
    extern fn gtk_application_window_set_show_menubar(p_window: *ApplicationWindow, p_show_menubar: c_int) void;
    pub const setShowMenubar = gtk_application_window_set_show_menubar;

    extern fn gtk_application_window_get_type() usize;
    pub const getGObjectType = gtk_application_window_get_type;

    extern fn g_object_ref(p_self: *gtk.ApplicationWindow) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ApplicationWindow) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ApplicationWindow, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkArrow should be used to draw simple arrows that need to point in
/// one of the four cardinal directions (up, down, left, or right).  The
/// style of the arrow can be one of shadow in, shadow out, etched in, or
/// etched out.  Note that these directions and style types may be
/// amended in versions of GTK+ to come.
///
/// GtkArrow will fill any space alloted to it, but since it is inherited
/// from `gtk.Misc`, it can be padded and/or aligned, to fill exactly the
/// space the programmer desires.
///
/// Arrows are created with a call to `gtk.Arrow.new`.  The direction or
/// style of an arrow can be changed after creation by using `gtk.Arrow.set`.
///
/// GtkArrow has been deprecated; you can simply use a `gtk.Image` with a
/// suitable icon name, such as “pan-down-symbolic“. When replacing
/// GtkArrow by an image, pay attention to the fact that GtkArrow is
/// doing automatic flipping between `GTK_ARROW_LEFT` and `GTK_ARROW_RIGHT`,
/// depending on the text direction. To get the same effect with an image,
/// use the icon names “pan-start-symbolic“ and “pan-end-symbolic“, which
/// react to the text direction.
pub const Arrow = extern struct {
    pub const Parent = gtk.Misc;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.ArrowClass;
    f_misc: gtk.Misc,
    f_priv: ?*gtk.ArrowPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const arrow_type = struct {
            pub const name = "arrow-type";

            pub const Type = gtk.ArrowType;
        };

        pub const shadow_type = struct {
            pub const name = "shadow-type";

            pub const Type = gtk.ShadowType;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.Arrow` widget.
    extern fn gtk_arrow_new(p_arrow_type: gtk.ArrowType, p_shadow_type: gtk.ShadowType) *gtk.Arrow;
    pub const new = gtk_arrow_new;

    /// Sets the direction and style of the `gtk.Arrow`, `arrow`.
    extern fn gtk_arrow_set(p_arrow: *Arrow, p_arrow_type: gtk.ArrowType, p_shadow_type: gtk.ShadowType) void;
    pub const set = gtk_arrow_set;

    extern fn gtk_arrow_get_type() usize;
    pub const getGObjectType = gtk_arrow_get_type;

    extern fn g_object_ref(p_self: *gtk.Arrow) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Arrow) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Arrow, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ArrowAccessible = extern struct {
    pub const Parent = gtk.WidgetAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Image };
    pub const Class = gtk.ArrowAccessibleClass;
    f_parent: gtk.WidgetAccessible,
    f_priv: ?*gtk.ArrowAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_arrow_accessible_get_type() usize;
    pub const getGObjectType = gtk_arrow_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ArrowAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ArrowAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ArrowAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.AspectFrame` is useful when you want
/// pack a widget so that it can resize but always retains
/// the same aspect ratio. For instance, one might be
/// drawing a small preview of a larger image. `gtk.AspectFrame`
/// derives from `gtk.Frame`, so it can draw a label and
/// a frame around the child. The frame will be
/// “shrink-wrapped” to the size of the child.
///
/// # CSS nodes
///
/// GtkAspectFrame uses a CSS node with name frame.
pub const AspectFrame = extern struct {
    pub const Parent = gtk.Frame;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.AspectFrameClass;
    f_frame: gtk.Frame,
    f_priv: ?*gtk.AspectFramePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const obey_child = struct {
            pub const name = "obey-child";

            pub const Type = c_int;
        };

        pub const ratio = struct {
            pub const name = "ratio";

            pub const Type = f32;
        };

        pub const xalign = struct {
            pub const name = "xalign";

            pub const Type = f32;
        };

        pub const yalign = struct {
            pub const name = "yalign";

            pub const Type = f32;
        };
    };

    pub const signals = struct {};

    /// Create a new `gtk.AspectFrame`.
    extern fn gtk_aspect_frame_new(p_label: ?[*:0]const u8, p_xalign: f32, p_yalign: f32, p_ratio: f32, p_obey_child: c_int) *gtk.AspectFrame;
    pub const new = gtk_aspect_frame_new;

    /// Set parameters for an existing `gtk.AspectFrame`.
    extern fn gtk_aspect_frame_set(p_aspect_frame: *AspectFrame, p_xalign: f32, p_yalign: f32, p_ratio: f32, p_obey_child: c_int) void;
    pub const set = gtk_aspect_frame_set;

    extern fn gtk_aspect_frame_get_type() usize;
    pub const getGObjectType = gtk_aspect_frame_get_type;

    extern fn g_object_ref(p_self: *gtk.AspectFrame) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.AspectFrame) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *AspectFrame, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.Assistant` is a widget used to represent a generally complex
/// operation splitted in several steps, guiding the user through its
/// pages and controlling the page flow to collect the necessary data.
///
/// The design of GtkAssistant is that it controls what buttons to show
/// and to make sensitive, based on what it knows about the page sequence
/// and the [type][GtkAssistantPageType] of each page,
/// in addition to state information like the page
/// [completion][gtk-assistant-set-page-complete]
/// and [committed][gtk-assistant-commit] status.
///
/// If you have a case that doesn’t quite fit in `GtkAssistants` way of
/// handling buttons, you can use the `GTK_ASSISTANT_PAGE_CUSTOM` page
/// type and handle buttons yourself.
///
/// # GtkAssistant as GtkBuildable
///
/// The GtkAssistant implementation of the `gtk.Buildable` interface
/// exposes the `action_area` as internal children with the name
/// “action_area”.
///
/// To add pages to an assistant in `gtk.Builder`, simply add it as a
/// child to the GtkAssistant object, and set its child properties
/// as necessary.
///
/// # CSS nodes
///
/// GtkAssistant has a single CSS node with the name assistant.
pub const Assistant = extern struct {
    pub const Parent = gtk.Window;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.AssistantClass;
    f_parent: gtk.Window,
    f_priv: ?*gtk.AssistantPrivate,

    pub const virtual_methods = struct {
        /// Signal emitted when the apply button is clicked.
        pub const apply = struct {
            pub fn call(p_class: anytype, p_assistant: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Assistant.Class, p_class).f_apply.?(gobject.ext.as(Assistant, p_assistant));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_assistant: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Assistant.Class, p_class).f_apply = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the cancel button is clicked.
        pub const cancel = struct {
            pub fn call(p_class: anytype, p_assistant: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Assistant.Class, p_class).f_cancel.?(gobject.ext.as(Assistant, p_assistant));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_assistant: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Assistant.Class, p_class).f_cancel = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted either when the close button or last page apply button is clicked.
        pub const close = struct {
            pub fn call(p_class: anytype, p_assistant: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Assistant.Class, p_class).f_close.?(gobject.ext.as(Assistant, p_assistant));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_assistant: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Assistant.Class, p_class).f_close = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when a new page is set as the assistant’s current page, before making the new page visible.
        pub const prepare = struct {
            pub fn call(p_class: anytype, p_assistant: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_page: *gtk.Widget) void {
                return gobject.ext.as(Assistant.Class, p_class).f_prepare.?(gobject.ext.as(Assistant, p_assistant), p_page);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_assistant: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_page: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(Assistant.Class, p_class).f_prepare = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// `TRUE` if the assistant uses a `gtk.HeaderBar` for action buttons
        /// instead of the action-area.
        ///
        /// For technical reasons, this property is declared as an integer
        /// property, but you should only set it to `TRUE` or `FALSE`.
        pub const use_header_bar = struct {
            pub const name = "use-header-bar";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::apply signal is emitted when the apply button is clicked.
        ///
        /// The default behavior of the `gtk.Assistant` is to switch to the page
        /// after the current page, unless the current page is the last one.
        ///
        /// A handler for the ::apply signal should carry out the actions for
        /// which the wizard has collected data. If the action takes a long time
        /// to complete, you might consider putting a page of type
        /// `GTK_ASSISTANT_PAGE_PROGRESS` after the confirmation page and handle
        /// this operation within the `gtk.Assistant.signals.prepare` signal of the progress
        /// page.
        pub const apply = struct {
            pub const name = "apply";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Assistant, p_instance))),
                    gobject.signalLookup("apply", Assistant.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::cancel signal is emitted when then the cancel button is clicked.
        pub const cancel = struct {
            pub const name = "cancel";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Assistant, p_instance))),
                    gobject.signalLookup("cancel", Assistant.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::close signal is emitted either when the close button of
        /// a summary page is clicked, or when the apply button in the last
        /// page in the flow (of type `GTK_ASSISTANT_PAGE_CONFIRM`) is clicked.
        pub const close = struct {
            pub const name = "close";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Assistant, p_instance))),
                    gobject.signalLookup("close", Assistant.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const escape = struct {
            pub const name = "escape";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Assistant, p_instance))),
                    gobject.signalLookup("escape", Assistant.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::prepare signal is emitted when a new page is set as the
        /// assistant's current page, before making the new page visible.
        ///
        /// A handler for this signal can do any preparations which are
        /// necessary before showing `page`.
        pub const prepare = struct {
            pub const name = "prepare";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_page: *gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Assistant, p_instance))),
                    gobject.signalLookup("prepare", Assistant.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.Assistant`.
    extern fn gtk_assistant_new() *gtk.Assistant;
    pub const new = gtk_assistant_new;

    /// Adds a widget to the action area of a `gtk.Assistant`.
    extern fn gtk_assistant_add_action_widget(p_assistant: *Assistant, p_child: *gtk.Widget) void;
    pub const addActionWidget = gtk_assistant_add_action_widget;

    /// Appends a page to the `assistant`.
    extern fn gtk_assistant_append_page(p_assistant: *Assistant, p_page: *gtk.Widget) c_int;
    pub const appendPage = gtk_assistant_append_page;

    /// Erases the visited page history so the back button is not
    /// shown on the current page, and removes the cancel button
    /// from subsequent pages.
    ///
    /// Use this when the information provided up to the current
    /// page is hereafter deemed permanent and cannot be modified
    /// or undone. For example, showing a progress page to track
    /// a long-running, unreversible operation after the user has
    /// clicked apply on a confirmation page.
    extern fn gtk_assistant_commit(p_assistant: *Assistant) void;
    pub const commit = gtk_assistant_commit;

    /// Returns the page number of the current page.
    extern fn gtk_assistant_get_current_page(p_assistant: *Assistant) c_int;
    pub const getCurrentPage = gtk_assistant_get_current_page;

    /// Returns the number of pages in the `assistant`
    extern fn gtk_assistant_get_n_pages(p_assistant: *Assistant) c_int;
    pub const getNPages = gtk_assistant_get_n_pages;

    /// Returns the child widget contained in page number `page_num`.
    extern fn gtk_assistant_get_nth_page(p_assistant: *Assistant, p_page_num: c_int) ?*gtk.Widget;
    pub const getNthPage = gtk_assistant_get_nth_page;

    /// Gets whether `page` is complete.
    extern fn gtk_assistant_get_page_complete(p_assistant: *Assistant, p_page: *gtk.Widget) c_int;
    pub const getPageComplete = gtk_assistant_get_page_complete;

    /// Gets whether page has padding.
    extern fn gtk_assistant_get_page_has_padding(p_assistant: *Assistant, p_page: *gtk.Widget) c_int;
    pub const getPageHasPadding = gtk_assistant_get_page_has_padding;

    /// Gets the header image for `page`.
    extern fn gtk_assistant_get_page_header_image(p_assistant: *Assistant, p_page: *gtk.Widget) *gdkpixbuf.Pixbuf;
    pub const getPageHeaderImage = gtk_assistant_get_page_header_image;

    /// Gets the side image for `page`.
    extern fn gtk_assistant_get_page_side_image(p_assistant: *Assistant, p_page: *gtk.Widget) *gdkpixbuf.Pixbuf;
    pub const getPageSideImage = gtk_assistant_get_page_side_image;

    /// Gets the title for `page`.
    extern fn gtk_assistant_get_page_title(p_assistant: *Assistant, p_page: *gtk.Widget) [*:0]const u8;
    pub const getPageTitle = gtk_assistant_get_page_title;

    /// Gets the page type of `page`.
    extern fn gtk_assistant_get_page_type(p_assistant: *Assistant, p_page: *gtk.Widget) gtk.AssistantPageType;
    pub const getPageType = gtk_assistant_get_page_type;

    /// Inserts a page in the `assistant` at a given position.
    extern fn gtk_assistant_insert_page(p_assistant: *Assistant, p_page: *gtk.Widget, p_position: c_int) c_int;
    pub const insertPage = gtk_assistant_insert_page;

    /// Navigate to the next page.
    ///
    /// It is a programming error to call this function when
    /// there is no next page.
    ///
    /// This function is for use when creating pages of the
    /// `GTK_ASSISTANT_PAGE_CUSTOM` type.
    extern fn gtk_assistant_next_page(p_assistant: *Assistant) void;
    pub const nextPage = gtk_assistant_next_page;

    /// Prepends a page to the `assistant`.
    extern fn gtk_assistant_prepend_page(p_assistant: *Assistant, p_page: *gtk.Widget) c_int;
    pub const prependPage = gtk_assistant_prepend_page;

    /// Navigate to the previous visited page.
    ///
    /// It is a programming error to call this function when
    /// no previous page is available.
    ///
    /// This function is for use when creating pages of the
    /// `GTK_ASSISTANT_PAGE_CUSTOM` type.
    extern fn gtk_assistant_previous_page(p_assistant: *Assistant) void;
    pub const previousPage = gtk_assistant_previous_page;

    /// Removes a widget from the action area of a `gtk.Assistant`.
    extern fn gtk_assistant_remove_action_widget(p_assistant: *Assistant, p_child: *gtk.Widget) void;
    pub const removeActionWidget = gtk_assistant_remove_action_widget;

    /// Removes the `page_num`’s page from `assistant`.
    extern fn gtk_assistant_remove_page(p_assistant: *Assistant, p_page_num: c_int) void;
    pub const removePage = gtk_assistant_remove_page;

    /// Switches the page to `page_num`.
    ///
    /// Note that this will only be necessary in custom buttons,
    /// as the `assistant` flow can be set with
    /// `gtk.Assistant.setForwardPageFunc`.
    extern fn gtk_assistant_set_current_page(p_assistant: *Assistant, p_page_num: c_int) void;
    pub const setCurrentPage = gtk_assistant_set_current_page;

    /// Sets the page forwarding function to be `page_func`.
    ///
    /// This function will be used to determine what will be
    /// the next page when the user presses the forward button.
    /// Setting `page_func` to `NULL` will make the assistant to
    /// use the default forward function, which just goes to the
    /// next visible page.
    extern fn gtk_assistant_set_forward_page_func(p_assistant: *Assistant, p_page_func: ?gtk.AssistantPageFunc, p_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setForwardPageFunc = gtk_assistant_set_forward_page_func;

    /// Sets whether `page` contents are complete.
    ///
    /// This will make `assistant` update the buttons state
    /// to be able to continue the task.
    extern fn gtk_assistant_set_page_complete(p_assistant: *Assistant, p_page: *gtk.Widget, p_complete: c_int) void;
    pub const setPageComplete = gtk_assistant_set_page_complete;

    /// Sets whether the assistant is adding padding around
    /// the page.
    extern fn gtk_assistant_set_page_has_padding(p_assistant: *Assistant, p_page: *gtk.Widget, p_has_padding: c_int) void;
    pub const setPageHasPadding = gtk_assistant_set_page_has_padding;

    /// Sets a header image for `page`.
    extern fn gtk_assistant_set_page_header_image(p_assistant: *Assistant, p_page: *gtk.Widget, p_pixbuf: ?*gdkpixbuf.Pixbuf) void;
    pub const setPageHeaderImage = gtk_assistant_set_page_header_image;

    /// Sets a side image for `page`.
    ///
    /// This image used to be displayed in the side area of the assistant
    /// when `page` is the current page.
    extern fn gtk_assistant_set_page_side_image(p_assistant: *Assistant, p_page: *gtk.Widget, p_pixbuf: ?*gdkpixbuf.Pixbuf) void;
    pub const setPageSideImage = gtk_assistant_set_page_side_image;

    /// Sets a title for `page`.
    ///
    /// The title is displayed in the header area of the assistant
    /// when `page` is the current page.
    extern fn gtk_assistant_set_page_title(p_assistant: *Assistant, p_page: *gtk.Widget, p_title: [*:0]const u8) void;
    pub const setPageTitle = gtk_assistant_set_page_title;

    /// Sets the page type for `page`.
    ///
    /// The page type determines the page behavior in the `assistant`.
    extern fn gtk_assistant_set_page_type(p_assistant: *Assistant, p_page: *gtk.Widget, p_type: gtk.AssistantPageType) void;
    pub const setPageType = gtk_assistant_set_page_type;

    /// Forces `assistant` to recompute the buttons state.
    ///
    /// GTK+ automatically takes care of this in most situations,
    /// e.g. when the user goes to a different page, or when the
    /// visibility or completeness of a page changes.
    ///
    /// One situation where it can be necessary to call this
    /// function is when changing a value on the current page
    /// affects the future page flow of the assistant.
    extern fn gtk_assistant_update_buttons_state(p_assistant: *Assistant) void;
    pub const updateButtonsState = gtk_assistant_update_buttons_state;

    extern fn gtk_assistant_get_type() usize;
    pub const getGObjectType = gtk_assistant_get_type;

    extern fn g_object_ref(p_self: *gtk.Assistant) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Assistant) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Assistant, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Bin` widget is a container with just one child.
/// It is not very useful itself, but it is useful for deriving subclasses,
/// since it provides common code needed for handling a single child widget.
///
/// Many GTK+ widgets are subclasses of `gtk.Bin`, including `gtk.Window`,
/// `gtk.Button`, `gtk.Frame`, `gtk.HandleBox` or `gtk.ScrolledWindow`.
pub const Bin = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.BinClass;
    f_container: gtk.Container,
    f_priv: ?*gtk.BinPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Gets the child of the `gtk.Bin`, or `NULL` if the bin contains
    /// no child widget. The returned widget does not have a reference
    /// added, so you do not need to unref it.
    extern fn gtk_bin_get_child(p_bin: *Bin) ?*gtk.Widget;
    pub const getChild = gtk_bin_get_child;

    extern fn gtk_bin_get_type() usize;
    pub const getGObjectType = gtk_bin_get_type;

    extern fn g_object_ref(p_self: *gtk.Bin) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Bin) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Bin, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const BooleanCellAccessible = extern struct {
    pub const Parent = gtk.RendererCellAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.TableCell };
    pub const Class = gtk.BooleanCellAccessibleClass;
    f_parent: gtk.RendererCellAccessible,
    f_priv: ?*gtk.BooleanCellAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_boolean_cell_accessible_get_type() usize;
    pub const getGObjectType = gtk_boolean_cell_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.BooleanCellAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.BooleanCellAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *BooleanCellAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The GtkBox widget arranges child widgets into a single row or column,
/// depending upon the value of its `gtk.Orientable.properties.orientation` property. Within
/// the other dimension, all children are allocated the same size. Of course,
/// the `gtk.Widget.properties.halign` and `gtk.Widget.properties.valign` properties can be used on
/// the children to influence their allocation.
///
/// GtkBox uses a notion of packing. Packing refers
/// to adding widgets with reference to a particular position in a
/// `gtk.Container`. For a GtkBox, there are two reference positions: the
/// start and the end of the box.
/// For a vertical `gtk.Box`, the start is defined as the top of the box and
/// the end is defined as the bottom. For a horizontal `gtk.Box` the start
/// is defined as the left side and the end is defined as the right side.
///
/// Use repeated calls to `gtk.Box.packStart` to pack widgets into a
/// GtkBox from start to end. Use `gtk.Box.packEnd` to add widgets from
/// end to start. You may intersperse these calls and add widgets from
/// both ends of the same GtkBox.
///
/// Because GtkBox is a `gtk.Container`, you may also use `gtk.Container.add`
/// to insert widgets into the box, and they will be packed with the default
/// values for expand and fill child properties. Use `gtk.Container.remove`
/// to remove widgets from the GtkBox.
///
/// Use `gtk.Box.setHomogeneous` to specify whether or not all children
/// of the GtkBox are forced to get the same amount of space.
///
/// Use `gtk.Box.setSpacing` to determine how much space will be
/// minimally placed between all children in the GtkBox. Note that
/// spacing is added between the children, while
/// padding added by `gtk.Box.packStart` or `gtk.Box.packEnd` is added
/// on either side of the widget it belongs to.
///
/// Use `gtk.Box.reorderChild` to move a GtkBox child to a different
/// place in the box.
///
/// Use `gtk.Box.setChildPacking` to reset the expand,
/// fill and padding child properties.
/// Use `gtk.Box.queryChildPacking` to query these fields.
///
/// # CSS nodes
///
/// GtkBox uses a single CSS node with name box.
///
/// In horizontal orientation, the nodes of the children are always arranged
/// from left to right. So :first-child will always select the leftmost child,
/// regardless of text direction.
pub const Box = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.BoxClass;
    f_container: gtk.Container,
    f_priv: ?*gtk.BoxPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const baseline_position = struct {
            pub const name = "baseline-position";

            pub const Type = gtk.BaselinePosition;
        };

        pub const homogeneous = struct {
            pub const name = "homogeneous";

            pub const Type = c_int;
        };

        pub const spacing = struct {
            pub const name = "spacing";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.Box`.
    extern fn gtk_box_new(p_orientation: gtk.Orientation, p_spacing: c_int) *gtk.Box;
    pub const new = gtk_box_new;

    /// Gets the value set by `gtk.Box.setBaselinePosition`.
    extern fn gtk_box_get_baseline_position(p_box: *Box) gtk.BaselinePosition;
    pub const getBaselinePosition = gtk_box_get_baseline_position;

    /// Retrieves the center widget of the box.
    extern fn gtk_box_get_center_widget(p_box: *Box) ?*gtk.Widget;
    pub const getCenterWidget = gtk_box_get_center_widget;

    /// Returns whether the box is homogeneous (all children are the
    /// same size). See `gtk.Box.setHomogeneous`.
    extern fn gtk_box_get_homogeneous(p_box: *Box) c_int;
    pub const getHomogeneous = gtk_box_get_homogeneous;

    /// Gets the value set by `gtk.Box.setSpacing`.
    extern fn gtk_box_get_spacing(p_box: *Box) c_int;
    pub const getSpacing = gtk_box_get_spacing;

    /// Adds `child` to `box`, packed with reference to the end of `box`.
    /// The `child` is packed after (away from end of) any other child
    /// packed with reference to the end of `box`.
    extern fn gtk_box_pack_end(p_box: *Box, p_child: *gtk.Widget, p_expand: c_int, p_fill: c_int, p_padding: c_uint) void;
    pub const packEnd = gtk_box_pack_end;

    /// Adds `child` to `box`, packed with reference to the start of `box`.
    /// The `child` is packed after any other child packed with reference
    /// to the start of `box`.
    extern fn gtk_box_pack_start(p_box: *Box, p_child: *gtk.Widget, p_expand: c_int, p_fill: c_int, p_padding: c_uint) void;
    pub const packStart = gtk_box_pack_start;

    /// Obtains information about how `child` is packed into `box`.
    extern fn gtk_box_query_child_packing(p_box: *Box, p_child: *gtk.Widget, p_expand: *c_int, p_fill: *c_int, p_padding: *c_uint, p_pack_type: *gtk.PackType) void;
    pub const queryChildPacking = gtk_box_query_child_packing;

    /// Moves `child` to a new `position` in the list of `box` children.
    /// The list contains widgets packed `GTK_PACK_START`
    /// as well as widgets packed `GTK_PACK_END`, in the order that these
    /// widgets were added to `box`.
    ///
    /// A widget’s position in the `box` children list determines where
    /// the widget is packed into `box`.  A child widget at some position
    /// in the list will be packed just after all other widgets of the
    /// same packing type that appear earlier in the list.
    extern fn gtk_box_reorder_child(p_box: *Box, p_child: *gtk.Widget, p_position: c_int) void;
    pub const reorderChild = gtk_box_reorder_child;

    /// Sets the baseline position of a box. This affects
    /// only horizontal boxes with at least one baseline aligned
    /// child. If there is more vertical space available than requested,
    /// and the baseline is not allocated by the parent then
    /// `position` is used to allocate the baseline wrt the
    /// extra space available.
    extern fn gtk_box_set_baseline_position(p_box: *Box, p_position: gtk.BaselinePosition) void;
    pub const setBaselinePosition = gtk_box_set_baseline_position;

    /// Sets a center widget; that is a child widget that will be
    /// centered with respect to the full width of the box, even
    /// if the children at either side take up different amounts
    /// of space.
    extern fn gtk_box_set_center_widget(p_box: *Box, p_widget: ?*gtk.Widget) void;
    pub const setCenterWidget = gtk_box_set_center_widget;

    /// Sets the way `child` is packed into `box`.
    extern fn gtk_box_set_child_packing(p_box: *Box, p_child: *gtk.Widget, p_expand: c_int, p_fill: c_int, p_padding: c_uint, p_pack_type: gtk.PackType) void;
    pub const setChildPacking = gtk_box_set_child_packing;

    /// Sets the `gtk.Box.properties.homogeneous` property of `box`, controlling
    /// whether or not all children of `box` are given equal space
    /// in the box.
    extern fn gtk_box_set_homogeneous(p_box: *Box, p_homogeneous: c_int) void;
    pub const setHomogeneous = gtk_box_set_homogeneous;

    /// Sets the `gtk.Box.properties.spacing` property of `box`, which is the
    /// number of pixels to place between children of `box`.
    extern fn gtk_box_set_spacing(p_box: *Box, p_spacing: c_int) void;
    pub const setSpacing = gtk_box_set_spacing;

    extern fn gtk_box_get_type() usize;
    pub const getGObjectType = gtk_box_get_type;

    extern fn g_object_ref(p_self: *gtk.Box) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Box) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Box, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkBuilder is an auxiliary object that reads textual descriptions
/// of a user interface and instantiates the described objects. To create
/// a GtkBuilder from a user interface description, call
/// `gtk.Builder.newFromFile`, `gtk.Builder.newFromResource` or
/// `gtk.Builder.newFromString`.
///
/// In the (unusual) case that you want to add user interface
/// descriptions from multiple sources to the same GtkBuilder you can
/// call `gtk.Builder.new` to get an empty builder and populate it by
/// (multiple) calls to `gtk.Builder.addFromFile`,
/// `gtk.Builder.addFromResource` or `gtk.Builder.addFromString`.
///
/// A GtkBuilder holds a reference to all objects that it has constructed
/// and drops these references when it is finalized. This finalization can
/// cause the destruction of non-widget objects or widgets which are not
/// contained in a toplevel window. For toplevel windows constructed by a
/// builder, it is the responsibility of the user to call `gtk.Widget.destroy`
/// to get rid of them and all the widgets they contain.
///
/// The functions `gtk.Builder.getObject` and `gtk.Builder.getObjects`
/// can be used to access the widgets in the interface by the names assigned
/// to them inside the UI description. Toplevel windows returned by these
/// functions will stay around until the user explicitly destroys them
/// with `gtk.Widget.destroy`. Other widgets will either be part of a
/// larger hierarchy constructed by the builder (in which case you should
/// not have to worry about their lifecycle), or without a parent, in which
/// case they have to be added to some container to make use of them.
/// Non-widget objects need to be reffed with `gobject.Object.ref` to keep them
/// beyond the lifespan of the builder.
///
/// The function `gtk.Builder.connectSignals` and variants thereof can be
/// used to connect handlers to the named signals in the description.
///
/// # GtkBuilder UI Definitions
///
/// GtkBuilder parses textual descriptions of user interfaces which are
/// specified in an XML format which can be roughly described by the
/// RELAX NG schema below. We refer to these descriptions as “GtkBuilder
/// UI definitions” or just “UI definitions” if the context is clear.
/// Do not confuse GtkBuilder UI Definitions with
/// [GtkUIManager UI Definitions][XML-UI], which are more limited in scope.
/// It is common to use `.ui` as the filename extension for files containing
/// GtkBuilder UI definitions.
///
/// [RELAX NG Compact Syntax](https://gitlab.gnome.org/GNOME/gtk/-/blob/gtk-3-24/gtk/gtkbuilder.rnc)
///
/// The toplevel element is `<interface>`. It optionally takes a “domain”
/// attribute, which will make the builder look for translated strings
/// using `dgettext` in the domain specified. This can also be done by
/// calling `gtk.Builder.setTranslationDomain` on the builder.
/// Objects are described by `<object>` elements, which can contain
/// `<property>` elements to set properties, `<signal>` elements which
/// connect signals to handlers, and `<child>` elements, which describe
/// child objects (most often widgets inside a container, but also e.g.
/// actions in an action group, or columns in a tree model). A `<child>`
/// element contains an `<object>` element which describes the child object.
/// The target toolkit version(s) are described by `<requires>` elements,
/// the “lib” attribute specifies the widget library in question (currently
/// the only supported value is “gtk+”) and the “version” attribute specifies
/// the target version in the form `<major>.<minor>`. The builder will error
/// out if the version requirements are not met.
///
/// Typically, the specific kind of object represented by an `<object>`
/// element is specified by the “class” attribute. If the type has not
/// been loaded yet, GTK+ tries to find the ``get_type`` function from the
/// class name by applying heuristics. This works in most cases, but if
/// necessary, it is possible to specify the name of the `get_type` function
/// explictly with the "type-func" attribute. As a special case, GtkBuilder
/// allows to use an object that has been constructed by a `gtk.UIManager` in
/// another part of the UI definition by specifying the id of the `gtk.UIManager`
/// in the “constructor” attribute and the name of the object in the “id”
/// attribute.
///
/// Objects may be given a name with the “id” attribute, which allows the
/// application to retrieve them from the builder with `gtk.Builder.getObject`.
/// An id is also necessary to use the object as property value in other
/// parts of the UI definition. GTK+ reserves ids starting and ending
/// with `___` (3 underscores) for its own purposes.
///
/// Setting properties of objects is pretty straightforward with the
/// `<property>` element: the “name” attribute specifies the name of the
/// property, and the content of the element specifies the value.
/// If the “translatable” attribute is set to a true value, GTK+ uses
/// `gettext` (or `dgettext` if the builder has a translation domain set)
/// to find a translation for the value. This happens before the value
/// is parsed, so it can be used for properties of any type, but it is
/// probably most useful for string properties. It is also possible to
/// specify a context to disambiguate short strings, and comments which
/// may help the translators.
///
/// GtkBuilder can parse textual representations for the most common
/// property types: characters, strings, integers, floating-point numbers,
/// booleans (strings like “TRUE”, “t”, “yes”, “y”, “1” are interpreted
/// as `TRUE`, strings like “FALSE”, “f”, “no”, “n”, “0” are interpreted
/// as `FALSE`), enumerations (can be specified by their name, nick or
/// integer value), flags (can be specified by their name, nick, integer
/// value, optionally combined with “|”, e.g. “GTK_VISIBLE|GTK_REALIZED”)
/// and colors (in a format understood by `gdk.RGBA.parse`).
///
/// GVariants can be specified in the format understood by `glib.variantParse`,
/// and pixbufs can be specified as a filename of an image file to load.
///
/// Objects can be referred to by their name and by default refer to
/// objects declared in the local xml fragment and objects exposed via
/// `gtk.Builder.exposeObject`. In general, GtkBuilder allows forward
/// references to objects — declared in the local xml; an object doesn’t
/// have to be constructed before it can be referred to. The exception
/// to this rule is that an object has to be constructed before it can
/// be used as the value of a construct-only property.
///
/// It is also possible to bind a property value to another object's
/// property value using the attributes
/// "bind-source" to specify the source object of the binding,
/// "bind-property" to specify the source property and optionally
/// "bind-flags" to specify the binding flags.
/// Internally builder implements this using GBinding objects.
/// For more information see `gobject.Object.bindProperty`
///
/// Signal handlers are set up with the `<signal>` element. The “name”
/// attribute specifies the name of the signal, and the “handler” attribute
/// specifies the function to connect to the signal. By default, GTK+ tries
/// to find the handler using `gmodule.Module.symbol`, but this can be changed by
/// passing a custom `gtk.BuilderConnectFunc` to
/// `gtk.Builder.connectSignalsFull`. The remaining attributes, “after”,
/// “swapped” and “object”, have the same meaning as the corresponding
/// parameters of the `gobject.signalConnectObject` or
/// `gobject.signalConnectData` functions. A “last_modification_time”
/// attribute is also allowed, but it does not have a meaning to the
/// builder.
///
/// Sometimes it is necessary to refer to widgets which have implicitly
/// been constructed by GTK+ as part of a composite widget, to set
/// properties on them or to add further children (e.g. the `vbox` of
/// a `gtk.Dialog`). This can be achieved by setting the “internal-child”
/// property of the `<child>` element to a true value. Note that GtkBuilder
/// still requires an `<object>` element for the internal child, even if it
/// has already been constructed.
///
/// A number of widgets have different places where a child can be added
/// (e.g. tabs vs. page content in notebooks). This can be reflected in
/// a UI definition by specifying the “type” attribute on a `<child>`
/// The possible values for the “type” attribute are described in the
/// sections describing the widget-specific portions of UI definitions.
///
/// # A GtkBuilder UI Definition
///
/// ```
/// <interface>
///   <object class="GtkDialog" id="dialog1">
///     <child internal-child="vbox">
///       <object class="GtkBox" id="vbox1">
///         <property name="border-width">10</property>
///         <child internal-child="action_area">
///           <object class="GtkButtonBox" id="hbuttonbox1">
///             <property name="border-width">20</property>
///             <child>
///               <object class="GtkButton" id="ok_button">
///                 <property name="label">gtk-ok</property>
///                 <property name="use-stock">TRUE</property>
///                 <signal name="clicked" handler="ok_button_clicked"/>
///               </object>
///             </child>
///           </object>
///         </child>
///       </object>
///     </child>
///   </object>
/// </interface>
/// ```
///
/// Beyond this general structure, several object classes define their
/// own XML DTD fragments for filling in the ANY placeholders in the DTD
/// above. Note that a custom element in a `<child>` element gets parsed by
/// the custom tag handler of the parent object, while a custom element in
/// an `<object>` element gets parsed by the custom tag handler of the object.
///
/// These XML fragments are explained in the documentation of the
/// respective objects.
///
/// Additionally, since 3.10 a special `<template>` tag has been added
/// to the format allowing one to define a widget class’s components.
/// See the [GtkWidget documentation][composite-templates] for details.
pub const Builder = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.BuilderClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.BuilderPrivate,

    pub const virtual_methods = struct {
        /// Looks up a type by name, using the virtual function that
        /// `gtk.Builder` has for that purpose. This is mainly used when
        /// implementing the `gtk.Buildable` interface on a type.
        pub const get_type_from_name = struct {
            pub fn call(p_class: anytype, p_builder: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_type_name: [*:0]const u8) usize {
                return gobject.ext.as(Builder.Class, p_class).f_get_type_from_name.?(gobject.ext.as(Builder, p_builder), p_type_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_builder: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_type_name: [*:0]const u8) callconv(.c) usize) void {
                gobject.ext.as(Builder.Class, p_class).f_get_type_from_name = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The translation domain used when translating property values that
        /// have been marked as translatable in interface descriptions.
        /// If the translation domain is `NULL`, `gtk.Builder` uses `gettext`,
        /// otherwise `glib.dgettext`.
        pub const translation_domain = struct {
            pub const name = "translation-domain";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new empty builder object.
    ///
    /// This function is only useful if you intend to make multiple calls
    /// to `gtk.Builder.addFromFile`, `gtk.Builder.addFromResource`
    /// or `gtk.Builder.addFromString` in order to merge multiple UI
    /// descriptions into a single builder.
    ///
    /// Most users will probably want to use `gtk.Builder.newFromFile`,
    /// `gtk.Builder.newFromResource` or `gtk.Builder.newFromString`.
    extern fn gtk_builder_new() *gtk.Builder;
    pub const new = gtk_builder_new;

    /// Builds the [GtkBuilder UI definition][BUILDER-UI]
    /// in the file `filename`.
    ///
    /// If there is an error opening the file or parsing the description then
    /// the program will be aborted.  You should only ever attempt to parse
    /// user interface descriptions that are shipped as part of your program.
    extern fn gtk_builder_new_from_file(p_filename: [*:0]const u8) *gtk.Builder;
    pub const newFromFile = gtk_builder_new_from_file;

    /// Builds the [GtkBuilder UI definition][BUILDER-UI]
    /// at `resource_path`.
    ///
    /// If there is an error locating the resource or parsing the
    /// description, then the program will be aborted.
    extern fn gtk_builder_new_from_resource(p_resource_path: [*:0]const u8) *gtk.Builder;
    pub const newFromResource = gtk_builder_new_from_resource;

    /// Builds the user interface described by `string` (in the
    /// [GtkBuilder UI definition][BUILDER-UI] format).
    ///
    /// If `string` is `NULL`-terminated, then `length` should be -1.
    /// If `length` is not -1, then it is the length of `string`.
    ///
    /// If there is an error parsing `string` then the program will be
    /// aborted. You should not attempt to parse user interface description
    /// from untrusted sources.
    extern fn gtk_builder_new_from_string(p_string: [*:0]const u8, p_length: isize) *gtk.Builder;
    pub const newFromString = gtk_builder_new_from_string;

    /// Adds the `callback_symbol` to the scope of `builder` under the given `callback_name`.
    ///
    /// Using this function overrides the behavior of `gtk.Builder.connectSignals`
    /// for any callback symbols that are added. Using this method allows for better
    /// encapsulation as it does not require that callback symbols be declared in
    /// the global namespace.
    extern fn gtk_builder_add_callback_symbol(p_builder: *Builder, p_callback_name: [*:0]const u8, p_callback_symbol: gobject.Callback) void;
    pub const addCallbackSymbol = gtk_builder_add_callback_symbol;

    /// A convenience function to add many callbacks instead of calling
    /// `gtk.Builder.addCallbackSymbol` for each symbol.
    extern fn gtk_builder_add_callback_symbols(p_builder: *Builder, p_first_callback_name: [*:0]const u8, p_first_callback_symbol: gobject.Callback, ...) void;
    pub const addCallbackSymbols = gtk_builder_add_callback_symbols;

    /// Parses a file containing a [GtkBuilder UI definition][BUILDER-UI]
    /// and merges it with the current contents of `builder`.
    ///
    /// Most users will probably want to use `gtk.Builder.newFromFile`.
    ///
    /// If an error occurs, 0 will be returned and `error` will be assigned a
    /// `glib.Error` from the `GTK_BUILDER_ERROR`, `G_MARKUP_ERROR` or `G_FILE_ERROR`
    /// domain.
    ///
    /// It’s not really reasonable to attempt to handle failures of this
    /// call. You should not use this function with untrusted files (ie:
    /// files that are not part of your application). Broken `gtk.Builder`
    /// files can easily crash your program, and it’s possible that memory
    /// was leaked leading up to the reported failure. The only reasonable
    /// thing to do when an error is detected is to call `g_error`.
    extern fn gtk_builder_add_from_file(p_builder: *Builder, p_filename: [*:0]const u8, p_error: ?*?*glib.Error) c_uint;
    pub const addFromFile = gtk_builder_add_from_file;

    /// Parses a resource file containing a [GtkBuilder UI definition][BUILDER-UI]
    /// and merges it with the current contents of `builder`.
    ///
    /// Most users will probably want to use `gtk.Builder.newFromResource`.
    ///
    /// If an error occurs, 0 will be returned and `error` will be assigned a
    /// `glib.Error` from the `GTK_BUILDER_ERROR`, `G_MARKUP_ERROR` or `G_RESOURCE_ERROR`
    /// domain.
    ///
    /// It’s not really reasonable to attempt to handle failures of this
    /// call.  The only reasonable thing to do when an error is detected is
    /// to call `g_error`.
    extern fn gtk_builder_add_from_resource(p_builder: *Builder, p_resource_path: [*:0]const u8, p_error: ?*?*glib.Error) c_uint;
    pub const addFromResource = gtk_builder_add_from_resource;

    /// Parses a string containing a [GtkBuilder UI definition][BUILDER-UI]
    /// and merges it with the current contents of `builder`.
    ///
    /// Most users will probably want to use `gtk.Builder.newFromString`.
    ///
    /// Upon errors 0 will be returned and `error` will be assigned a
    /// `glib.Error` from the `GTK_BUILDER_ERROR`, `G_MARKUP_ERROR` or
    /// `G_VARIANT_PARSE_ERROR` domain.
    ///
    /// It’s not really reasonable to attempt to handle failures of this
    /// call.  The only reasonable thing to do when an error is detected is
    /// to call `g_error`.
    extern fn gtk_builder_add_from_string(p_builder: *Builder, p_buffer: [*:0]const u8, p_length: usize, p_error: ?*?*glib.Error) c_uint;
    pub const addFromString = gtk_builder_add_from_string;

    /// Parses a file containing a [GtkBuilder UI definition][BUILDER-UI]
    /// building only the requested objects and merges
    /// them with the current contents of `builder`.
    ///
    /// Upon errors 0 will be returned and `error` will be assigned a
    /// `glib.Error` from the `GTK_BUILDER_ERROR`, `G_MARKUP_ERROR` or `G_FILE_ERROR`
    /// domain.
    ///
    /// If you are adding an object that depends on an object that is not
    /// its child (for instance a `gtk.TreeView` that depends on its
    /// `gtk.TreeModel`), you have to explicitly list all of them in `object_ids`.
    extern fn gtk_builder_add_objects_from_file(p_builder: *Builder, p_filename: [*:0]const u8, p_object_ids: [*][*:0]u8, p_error: ?*?*glib.Error) c_uint;
    pub const addObjectsFromFile = gtk_builder_add_objects_from_file;

    /// Parses a resource file containing a [GtkBuilder UI definition][BUILDER-UI]
    /// building only the requested objects and merges
    /// them with the current contents of `builder`.
    ///
    /// Upon errors 0 will be returned and `error` will be assigned a
    /// `glib.Error` from the `GTK_BUILDER_ERROR`, `G_MARKUP_ERROR` or `G_RESOURCE_ERROR`
    /// domain.
    ///
    /// If you are adding an object that depends on an object that is not
    /// its child (for instance a `gtk.TreeView` that depends on its
    /// `gtk.TreeModel`), you have to explicitly list all of them in `object_ids`.
    extern fn gtk_builder_add_objects_from_resource(p_builder: *Builder, p_resource_path: [*:0]const u8, p_object_ids: [*][*:0]u8, p_error: ?*?*glib.Error) c_uint;
    pub const addObjectsFromResource = gtk_builder_add_objects_from_resource;

    /// Parses a string containing a [GtkBuilder UI definition][BUILDER-UI]
    /// building only the requested objects and merges
    /// them with the current contents of `builder`.
    ///
    /// Upon errors 0 will be returned and `error` will be assigned a
    /// `glib.Error` from the `GTK_BUILDER_ERROR` or `G_MARKUP_ERROR` domain.
    ///
    /// If you are adding an object that depends on an object that is not
    /// its child (for instance a `gtk.TreeView` that depends on its
    /// `gtk.TreeModel`), you have to explicitly list all of them in `object_ids`.
    extern fn gtk_builder_add_objects_from_string(p_builder: *Builder, p_buffer: [*:0]const u8, p_length: usize, p_object_ids: [*][*:0]u8, p_error: ?*?*glib.Error) c_uint;
    pub const addObjectsFromString = gtk_builder_add_objects_from_string;

    /// This method is a simpler variation of `gtk.Builder.connectSignalsFull`.
    /// It uses symbols explicitly added to `builder` with prior calls to
    /// `gtk.Builder.addCallbackSymbol`. In the case that symbols are not
    /// explicitly added; it uses `gmodule.Module`’s introspective features (by opening the module `NULL`)
    /// to look at the application’s symbol table. From here it tries to match
    /// the signal handler names given in the interface description with
    /// symbols in the application and connects the signals. Note that this
    /// function can only be called once, subsequent calls will do nothing.
    ///
    /// Note that unless `gtk.Builder.addCallbackSymbol` is called for
    /// all signal callbacks which are referenced by the loaded XML, this
    /// function will require that `gmodule.Module` be supported on the platform.
    ///
    /// If you rely on `gmodule.Module` support to lookup callbacks in the symbol table,
    /// the following details should be noted:
    ///
    /// When compiling applications for Windows, you must declare signal callbacks
    /// with `G_MODULE_EXPORT`, or they will not be put in the symbol table.
    /// On Linux and Unices, this is not necessary; applications should instead
    /// be compiled with the -Wl,--export-dynamic CFLAGS, and linked against
    /// gmodule-export-2.0.
    extern fn gtk_builder_connect_signals(p_builder: *Builder, p_user_data: ?*anyopaque) void;
    pub const connectSignals = gtk_builder_connect_signals;

    /// This function can be thought of the interpreted language binding
    /// version of `gtk.Builder.connectSignals`, except that it does not
    /// require GModule to function correctly.
    extern fn gtk_builder_connect_signals_full(p_builder: *Builder, p_func: gtk.BuilderConnectFunc, p_user_data: ?*anyopaque) void;
    pub const connectSignalsFull = gtk_builder_connect_signals_full;

    /// Add `object` to the `builder` object pool so it can be referenced just like any
    /// other object built by builder.
    extern fn gtk_builder_expose_object(p_builder: *Builder, p_name: [*:0]const u8, p_object: *gobject.Object) void;
    pub const exposeObject = gtk_builder_expose_object;

    /// Main private entry point for building composite container
    /// components from template XML.
    ///
    /// This is exported purely to let gtk-builder-tool validate
    /// templates, applications have no need to call this function.
    extern fn gtk_builder_extend_with_template(p_builder: *Builder, p_widget: *gtk.Widget, p_template_type: usize, p_buffer: [*:0]const u8, p_length: usize, p_error: ?*?*glib.Error) c_uint;
    pub const extendWithTemplate = gtk_builder_extend_with_template;

    /// Gets the `gtk.Application` associated with the builder.
    ///
    /// The `gtk.Application` is used for creating action proxies as requested
    /// from XML that the builder is loading.
    ///
    /// By default, the builder uses the default application: the one from
    /// `gio.Application.getDefault`. If you want to use another application
    /// for constructing proxies, use `gtk.Builder.setApplication`.
    extern fn gtk_builder_get_application(p_builder: *Builder) ?*gtk.Application;
    pub const getApplication = gtk_builder_get_application;

    /// Gets the object named `name`. Note that this function does not
    /// increment the reference count of the returned object.
    extern fn gtk_builder_get_object(p_builder: *Builder, p_name: [*:0]const u8) ?*gobject.Object;
    pub const getObject = gtk_builder_get_object;

    /// Gets all objects that have been constructed by `builder`. Note that
    /// this function does not increment the reference counts of the returned
    /// objects.
    extern fn gtk_builder_get_objects(p_builder: *Builder) *glib.SList;
    pub const getObjects = gtk_builder_get_objects;

    /// Gets the translation domain of `builder`.
    extern fn gtk_builder_get_translation_domain(p_builder: *Builder) [*:0]const u8;
    pub const getTranslationDomain = gtk_builder_get_translation_domain;

    /// Looks up a type by name, using the virtual function that
    /// `gtk.Builder` has for that purpose. This is mainly used when
    /// implementing the `gtk.Buildable` interface on a type.
    extern fn gtk_builder_get_type_from_name(p_builder: *Builder, p_type_name: [*:0]const u8) usize;
    pub const getTypeFromName = gtk_builder_get_type_from_name;

    /// Fetches a symbol previously added to `builder`
    /// with `gtk.Builder.addCallbackSymbols`
    ///
    /// This function is intended for possible use in language bindings
    /// or for any case that one might be cusomizing signal connections
    /// using `gtk.Builder.connectSignalsFull`
    extern fn gtk_builder_lookup_callback_symbol(p_builder: *Builder, p_callback_name: [*:0]const u8) ?gobject.Callback;
    pub const lookupCallbackSymbol = gtk_builder_lookup_callback_symbol;

    /// Sets the application associated with `builder`.
    ///
    /// You only need this function if there is more than one `gio.Application`
    /// in your process. `application` cannot be `NULL`.
    extern fn gtk_builder_set_application(p_builder: *Builder, p_application: *gtk.Application) void;
    pub const setApplication = gtk_builder_set_application;

    /// Sets the translation domain of `builder`.
    /// See `gtk.Builder.properties.translation`-domain.
    extern fn gtk_builder_set_translation_domain(p_builder: *Builder, p_domain: ?[*:0]const u8) void;
    pub const setTranslationDomain = gtk_builder_set_translation_domain;

    /// This function demarshals a value from a string. This function
    /// calls `gobject.Value.init` on the `value` argument, so it need not be
    /// initialised beforehand.
    ///
    /// This function can handle char, uchar, boolean, int, uint, long,
    /// ulong, enum, flags, float, double, string, `gdk.Color`, `gdk.RGBA` and
    /// `gtk.Adjustment` type values. Support for `gtk.Widget` type values is
    /// still to come.
    ///
    /// Upon errors `FALSE` will be returned and `error` will be assigned a
    /// `glib.Error` from the `GTK_BUILDER_ERROR` domain.
    extern fn gtk_builder_value_from_string(p_builder: *Builder, p_pspec: *gobject.ParamSpec, p_string: [*:0]const u8, p_value: *gobject.Value, p_error: ?*?*glib.Error) c_int;
    pub const valueFromString = gtk_builder_value_from_string;

    /// Like `gtk.Builder.valueFromString`, this function demarshals
    /// a value from a string, but takes a `gobject.Type` instead of `gobject.ParamSpec`.
    /// This function calls `gobject.Value.init` on the `value` argument, so it
    /// need not be initialised beforehand.
    ///
    /// Upon errors `FALSE` will be returned and `error` will be assigned a
    /// `glib.Error` from the `GTK_BUILDER_ERROR` domain.
    extern fn gtk_builder_value_from_string_type(p_builder: *Builder, p_type: usize, p_string: [*:0]const u8, p_value: *gobject.Value, p_error: ?*?*glib.Error) c_int;
    pub const valueFromStringType = gtk_builder_value_from_string_type;

    extern fn gtk_builder_get_type() usize;
    pub const getGObjectType = gtk_builder_get_type;

    extern fn g_object_ref(p_self: *gtk.Builder) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Builder) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Builder, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Button` widget is generally used to trigger a callback function that is
/// called when the button is pressed.  The various signals and how to use them
/// are outlined below.
///
/// The `gtk.Button` widget can hold any valid child widget.  That is, it can hold
/// almost any other standard `gtk.Widget`.  The most commonly used child is the
/// `gtk.Label`.
///
/// # CSS nodes
///
/// GtkButton has a single CSS node with name button. The node will get the
/// style classes .image-button or .text-button, if the content is just an
/// image or label, respectively. It may also receive the .flat style class.
///
/// Other style classes that are commonly used with GtkButton include
/// .suggested-action and .destructive-action. In special cases, buttons
/// can be made round by adding the .circular style class.
///
/// Button-like widgets like `gtk.ToggleButton`, `gtk.MenuButton`, `gtk.VolumeButton`,
/// `gtk.LockButton`, `gtk.ColorButton`, `gtk.FontButton` or `gtk.FileChooserButton` use
/// style classes such as .toggle, .popup, .scale, .lock, .color, .font, .file
/// to differentiate themselves from a plain GtkButton.
pub const Button = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.ButtonClass;
    f_bin: gtk.Bin,
    f_priv: ?*gtk.ButtonPrivate,

    pub const virtual_methods = struct {
        /// Signal that causes the button to animate press then
        ///    release. Applications should never connect to this signal, but use
        ///    the `clicked` signal.
        pub const activate = struct {
            pub fn call(p_class: anytype, p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Button.Class, p_class).f_activate.?(gobject.ext.as(Button, p_button));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Button.Class, p_class).f_activate = @ptrCast(p_implementation);
            }
        };

        /// Emits a `gtk.Button.signals.clicked` signal to the given `gtk.Button`.
        pub const clicked = struct {
            pub fn call(p_class: anytype, p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Button.Class, p_class).f_clicked.?(gobject.ext.as(Button, p_button));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Button.Class, p_class).f_clicked = @ptrCast(p_implementation);
            }
        };

        /// Emits a `gtk.Button.signals.enter` signal to the given `gtk.Button`.
        pub const enter = struct {
            pub fn call(p_class: anytype, p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Button.Class, p_class).f_enter.?(gobject.ext.as(Button, p_button));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Button.Class, p_class).f_enter = @ptrCast(p_implementation);
            }
        };

        /// Emits a `gtk.Button.signals.leave` signal to the given `gtk.Button`.
        pub const leave = struct {
            pub fn call(p_class: anytype, p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Button.Class, p_class).f_leave.?(gobject.ext.as(Button, p_button));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Button.Class, p_class).f_leave = @ptrCast(p_implementation);
            }
        };

        /// Emits a `gtk.Button.signals.pressed` signal to the given `gtk.Button`.
        pub const pressed = struct {
            pub fn call(p_class: anytype, p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Button.Class, p_class).f_pressed.?(gobject.ext.as(Button, p_button));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Button.Class, p_class).f_pressed = @ptrCast(p_implementation);
            }
        };

        /// Emits a `gtk.Button.signals.released` signal to the given `gtk.Button`.
        pub const released = struct {
            pub fn call(p_class: anytype, p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Button.Class, p_class).f_released.?(gobject.ext.as(Button, p_button));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Button.Class, p_class).f_released = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// If `TRUE`, the button will ignore the `gtk.Settings.properties.gtk`-button-images
        /// setting and always show the image, if available.
        ///
        /// Use this property if the button would be useless or hard to use
        /// without the image.
        pub const always_show_image = struct {
            pub const name = "always-show-image";

            pub const Type = c_int;
        };

        /// The child widget to appear next to the button text.
        pub const image = struct {
            pub const name = "image";

            pub const Type = ?*gtk.Widget;
        };

        /// The position of the image relative to the text inside the button.
        pub const image_position = struct {
            pub const name = "image-position";

            pub const Type = gtk.PositionType;
        };

        pub const label = struct {
            pub const name = "label";

            pub const Type = ?[*:0]u8;
        };

        pub const relief = struct {
            pub const name = "relief";

            pub const Type = gtk.ReliefStyle;
        };

        pub const use_stock = struct {
            pub const name = "use-stock";

            pub const Type = c_int;
        };

        pub const use_underline = struct {
            pub const name = "use-underline";

            pub const Type = c_int;
        };

        /// If the child of the button is a `gtk.Misc` or `gtk.Alignment`, this property
        /// can be used to control its horizontal alignment. 0.0 is left aligned,
        /// 1.0 is right aligned.
        pub const xalign = struct {
            pub const name = "xalign";

            pub const Type = f32;
        };

        /// If the child of the button is a `gtk.Misc` or `gtk.Alignment`, this property
        /// can be used to control its vertical alignment. 0.0 is top aligned,
        /// 1.0 is bottom aligned.
        pub const yalign = struct {
            pub const name = "yalign";

            pub const Type = f32;
        };
    };

    pub const signals = struct {
        /// The ::activate signal on GtkButton is an action signal and
        /// emitting it causes the button to animate press then release.
        /// Applications should never connect to this signal, but use the
        /// `gtk.Button.signals.clicked` signal.
        pub const activate = struct {
            pub const name = "activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Button, p_instance))),
                    gobject.signalLookup("activate", Button.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the button has been activated (pressed and released).
        pub const clicked = struct {
            pub const name = "clicked";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Button, p_instance))),
                    gobject.signalLookup("clicked", Button.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the pointer enters the button.
        pub const enter = struct {
            pub const name = "enter";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Button, p_instance))),
                    gobject.signalLookup("enter", Button.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the pointer leaves the button.
        pub const leave = struct {
            pub const name = "leave";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Button, p_instance))),
                    gobject.signalLookup("leave", Button.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the button is pressed.
        pub const pressed = struct {
            pub const name = "pressed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Button, p_instance))),
                    gobject.signalLookup("pressed", Button.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the button is released.
        pub const released = struct {
            pub const name = "released";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Button, p_instance))),
                    gobject.signalLookup("released", Button.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.Button` widget. To add a child widget to the button,
    /// use `gtk.Container.add`.
    extern fn gtk_button_new() *gtk.Button;
    pub const new = gtk_button_new;

    /// Creates a new button containing an icon from the current icon theme.
    ///
    /// If the icon name isn’t known, a “broken image” icon will be
    /// displayed instead. If the current icon theme is changed, the icon
    /// will be updated appropriately.
    ///
    /// This function is a convenience wrapper around `gtk.Button.new` and
    /// `gtk.Button.setImage`.
    extern fn gtk_button_new_from_icon_name(p_icon_name: ?[*:0]const u8, p_size: c_int) *gtk.Button;
    pub const newFromIconName = gtk_button_new_from_icon_name;

    /// Creates a new `gtk.Button` containing the image and text from a
    /// [stock item][gtkstock].
    /// Some stock ids have preprocessor macros like `GTK_STOCK_OK` and
    /// `GTK_STOCK_APPLY`.
    ///
    /// If `stock_id` is unknown, then it will be treated as a mnemonic
    /// label (as for `gtk.Button.newWithMnemonic`).
    extern fn gtk_button_new_from_stock(p_stock_id: [*:0]const u8) *gtk.Button;
    pub const newFromStock = gtk_button_new_from_stock;

    /// Creates a `gtk.Button` widget with a `gtk.Label` child containing the given
    /// text.
    extern fn gtk_button_new_with_label(p_label: [*:0]const u8) *gtk.Button;
    pub const newWithLabel = gtk_button_new_with_label;

    /// Creates a new `gtk.Button` containing a label.
    /// If characters in `label` are preceded by an underscore, they are underlined.
    /// If you need a literal underscore character in a label, use “__” (two
    /// underscores). The first underlined character represents a keyboard
    /// accelerator called a mnemonic.
    /// Pressing Alt and that key activates the button.
    extern fn gtk_button_new_with_mnemonic(p_label: [*:0]const u8) *gtk.Button;
    pub const newWithMnemonic = gtk_button_new_with_mnemonic;

    /// Emits a `gtk.Button.signals.clicked` signal to the given `gtk.Button`.
    extern fn gtk_button_clicked(p_button: *Button) void;
    pub const clicked = gtk_button_clicked;

    /// Emits a `gtk.Button.signals.enter` signal to the given `gtk.Button`.
    extern fn gtk_button_enter(p_button: *Button) void;
    pub const enter = gtk_button_enter;

    /// Gets the alignment of the child in the button.
    extern fn gtk_button_get_alignment(p_button: *Button, p_xalign: *f32, p_yalign: *f32) void;
    pub const getAlignment = gtk_button_get_alignment;

    /// Returns whether the button will ignore the `gtk.Settings.properties.gtk`-button-images
    /// setting and always show the image, if available.
    extern fn gtk_button_get_always_show_image(p_button: *Button) c_int;
    pub const getAlwaysShowImage = gtk_button_get_always_show_image;

    /// Returns the button’s event window if it is realized, `NULL` otherwise.
    /// This function should be rarely needed.
    extern fn gtk_button_get_event_window(p_button: *Button) *gdk.Window;
    pub const getEventWindow = gtk_button_get_event_window;

    /// Returns whether the button grabs focus when it is clicked with the mouse.
    /// See `gtk.Button.setFocusOnClick`.
    extern fn gtk_button_get_focus_on_click(p_button: *Button) c_int;
    pub const getFocusOnClick = gtk_button_get_focus_on_click;

    /// Gets the widget that is currenty set as the image of `button`.
    /// This may have been explicitly set by `gtk.Button.setImage`
    /// or constructed by `gtk.Button.newFromStock`.
    extern fn gtk_button_get_image(p_button: *Button) ?*gtk.Widget;
    pub const getImage = gtk_button_get_image;

    /// Gets the position of the image relative to the text
    /// inside the button.
    extern fn gtk_button_get_image_position(p_button: *Button) gtk.PositionType;
    pub const getImagePosition = gtk_button_get_image_position;

    /// Fetches the text from the label of the button, as set by
    /// `gtk.Button.setLabel`. If the label text has not
    /// been set the return value will be `NULL`. This will be the
    /// case if you create an empty button with `gtk.Button.new` to
    /// use as a container.
    extern fn gtk_button_get_label(p_button: *Button) [*:0]const u8;
    pub const getLabel = gtk_button_get_label;

    /// Returns the current relief style of the given `gtk.Button`.
    extern fn gtk_button_get_relief(p_button: *Button) gtk.ReliefStyle;
    pub const getRelief = gtk_button_get_relief;

    /// Returns whether the button label is a stock item.
    extern fn gtk_button_get_use_stock(p_button: *Button) c_int;
    pub const getUseStock = gtk_button_get_use_stock;

    /// Returns whether an embedded underline in the button label indicates a
    /// mnemonic. See gtk_button_set_use_underline ().
    extern fn gtk_button_get_use_underline(p_button: *Button) c_int;
    pub const getUseUnderline = gtk_button_get_use_underline;

    /// Emits a `gtk.Button.signals.leave` signal to the given `gtk.Button`.
    extern fn gtk_button_leave(p_button: *Button) void;
    pub const leave = gtk_button_leave;

    /// Emits a `gtk.Button.signals.pressed` signal to the given `gtk.Button`.
    extern fn gtk_button_pressed(p_button: *Button) void;
    pub const pressed = gtk_button_pressed;

    /// Emits a `gtk.Button.signals.released` signal to the given `gtk.Button`.
    extern fn gtk_button_released(p_button: *Button) void;
    pub const released = gtk_button_released;

    /// Sets the alignment of the child. This property has no effect unless
    /// the child is a `gtk.Misc` or a `gtk.Alignment`.
    extern fn gtk_button_set_alignment(p_button: *Button, p_xalign: f32, p_yalign: f32) void;
    pub const setAlignment = gtk_button_set_alignment;

    /// If `TRUE`, the button will ignore the `gtk.Settings.properties.gtk`-button-images
    /// setting and always show the image, if available.
    ///
    /// Use this property if the button  would be useless or hard to use
    /// without the image.
    extern fn gtk_button_set_always_show_image(p_button: *Button, p_always_show: c_int) void;
    pub const setAlwaysShowImage = gtk_button_set_always_show_image;

    /// Sets whether the button will grab focus when it is clicked with the mouse.
    /// Making mouse clicks not grab focus is useful in places like toolbars where
    /// you don’t want the keyboard focus removed from the main area of the
    /// application.
    extern fn gtk_button_set_focus_on_click(p_button: *Button, p_focus_on_click: c_int) void;
    pub const setFocusOnClick = gtk_button_set_focus_on_click;

    /// Set the image of `button` to the given widget. The image will be
    /// displayed if the label text is `NULL` or if
    /// `gtk.Button.properties.always`-show-image is `TRUE`. You don’t have to call
    /// `gtk.Widget.show` on `image` yourself.
    extern fn gtk_button_set_image(p_button: *Button, p_image: ?*gtk.Widget) void;
    pub const setImage = gtk_button_set_image;

    /// Sets the position of the image relative to the text
    /// inside the button.
    extern fn gtk_button_set_image_position(p_button: *Button, p_position: gtk.PositionType) void;
    pub const setImagePosition = gtk_button_set_image_position;

    /// Sets the text of the label of the button to `str`. This text is
    /// also used to select the stock item if `gtk.Button.setUseStock`
    /// is used.
    ///
    /// This will also clear any previously set labels.
    extern fn gtk_button_set_label(p_button: *Button, p_label: [*:0]const u8) void;
    pub const setLabel = gtk_button_set_label;

    /// Sets the relief style of the edges of the given `gtk.Button` widget.
    /// Two styles exist, `GTK_RELIEF_NORMAL` and `GTK_RELIEF_NONE`.
    /// The default style is, as one can guess, `GTK_RELIEF_NORMAL`.
    /// The deprecated value `GTK_RELIEF_HALF` behaves the same as
    /// `GTK_RELIEF_NORMAL`.
    extern fn gtk_button_set_relief(p_button: *Button, p_relief: gtk.ReliefStyle) void;
    pub const setRelief = gtk_button_set_relief;

    /// If `TRUE`, the label set on the button is used as a
    /// stock id to select the stock item for the button.
    extern fn gtk_button_set_use_stock(p_button: *Button, p_use_stock: c_int) void;
    pub const setUseStock = gtk_button_set_use_stock;

    /// If true, an underline in the text of the button label indicates
    /// the next character should be used for the mnemonic accelerator key.
    extern fn gtk_button_set_use_underline(p_button: *Button, p_use_underline: c_int) void;
    pub const setUseUnderline = gtk_button_set_use_underline;

    extern fn gtk_button_get_type() usize;
    pub const getGObjectType = gtk_button_get_type;

    extern fn g_object_ref(p_self: *gtk.Button) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Button) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Button, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ButtonAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.Image };
    pub const Class = gtk.ButtonAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.ButtonAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_button_accessible_get_type() usize;
    pub const getGObjectType = gtk_button_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ButtonAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ButtonAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ButtonAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ButtonBox = extern struct {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.ButtonBoxClass;
    f_box: gtk.Box,
    f_priv: ?*gtk.ButtonBoxPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const layout_style = struct {
            pub const name = "layout-style";

            pub const Type = gtk.ButtonBoxStyle;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.ButtonBox`.
    extern fn gtk_button_box_new(p_orientation: gtk.Orientation) *gtk.ButtonBox;
    pub const new = gtk_button_box_new;

    /// Returns whether the child is exempted from homogenous
    /// sizing.
    extern fn gtk_button_box_get_child_non_homogeneous(p_widget: *ButtonBox, p_child: *gtk.Widget) c_int;
    pub const getChildNonHomogeneous = gtk_button_box_get_child_non_homogeneous;

    /// Returns whether `child` should appear in a secondary group of children.
    extern fn gtk_button_box_get_child_secondary(p_widget: *ButtonBox, p_child: *gtk.Widget) c_int;
    pub const getChildSecondary = gtk_button_box_get_child_secondary;

    /// Retrieves the method being used to arrange the buttons in a button box.
    extern fn gtk_button_box_get_layout(p_widget: *ButtonBox) gtk.ButtonBoxStyle;
    pub const getLayout = gtk_button_box_get_layout;

    /// Sets whether the child is exempted from homogeous sizing.
    extern fn gtk_button_box_set_child_non_homogeneous(p_widget: *ButtonBox, p_child: *gtk.Widget, p_non_homogeneous: c_int) void;
    pub const setChildNonHomogeneous = gtk_button_box_set_child_non_homogeneous;

    /// Sets whether `child` should appear in a secondary group of children.
    /// A typical use of a secondary child is the help button in a dialog.
    ///
    /// This group appears after the other children if the style
    /// is `GTK_BUTTONBOX_START`, `GTK_BUTTONBOX_SPREAD` or
    /// `GTK_BUTTONBOX_EDGE`, and before the other children if the style
    /// is `GTK_BUTTONBOX_END`. For horizontal button boxes, the definition
    /// of before/after depends on direction of the widget (see
    /// `gtk.Widget.setDirection`). If the style is `GTK_BUTTONBOX_START`
    /// or `GTK_BUTTONBOX_END`, then the secondary children are aligned at
    /// the other end of the button box from the main children. For the
    /// other styles, they appear immediately next to the main children.
    extern fn gtk_button_box_set_child_secondary(p_widget: *ButtonBox, p_child: *gtk.Widget, p_is_secondary: c_int) void;
    pub const setChildSecondary = gtk_button_box_set_child_secondary;

    /// Changes the way buttons are arranged in their container.
    extern fn gtk_button_box_set_layout(p_widget: *ButtonBox, p_layout_style: gtk.ButtonBoxStyle) void;
    pub const setLayout = gtk_button_box_set_layout;

    extern fn gtk_button_box_get_type() usize;
    pub const getGObjectType = gtk_button_box_get_type;

    extern fn g_object_ref(p_self: *gtk.ButtonBox) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ButtonBox) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ButtonBox, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.Calendar` is a widget that displays a Gregorian calendar, one month
/// at a time. It can be created with `gtk.Calendar.new`.
///
/// The month and year currently displayed can be altered with
/// `gtk.Calendar.selectMonth`. The exact day can be selected from the
/// displayed month using `gtk.Calendar.selectDay`.
///
/// To place a visual marker on a particular day, use `gtk.Calendar.markDay`
/// and to remove the marker, `gtk.Calendar.unmarkDay`. Alternative, all
/// marks can be cleared with `gtk.Calendar.clearMarks`.
///
/// The way in which the calendar itself is displayed can be altered using
/// `gtk.Calendar.setDisplayOptions`.
///
/// The selected date can be retrieved from a `gtk.Calendar` using
/// `gtk.Calendar.getDate`.
///
/// Users should be aware that, although the Gregorian calendar is the
/// legal calendar in most countries, it was adopted progressively
/// between 1582 and 1929. Display before these dates is likely to be
/// historically incorrect.
pub const Calendar = extern struct {
    pub const Parent = gtk.Widget;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.CalendarClass;
    f_widget: gtk.Widget,
    f_priv: ?*gtk.CalendarPrivate,

    pub const virtual_methods = struct {
        pub const day_selected = struct {
            pub fn call(p_class: anytype, p_calendar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Calendar.Class, p_class).f_day_selected.?(gobject.ext.as(Calendar, p_calendar));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_calendar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Calendar.Class, p_class).f_day_selected = @ptrCast(p_implementation);
            }
        };

        pub const day_selected_double_click = struct {
            pub fn call(p_class: anytype, p_calendar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Calendar.Class, p_class).f_day_selected_double_click.?(gobject.ext.as(Calendar, p_calendar));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_calendar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Calendar.Class, p_class).f_day_selected_double_click = @ptrCast(p_implementation);
            }
        };

        pub const month_changed = struct {
            pub fn call(p_class: anytype, p_calendar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Calendar.Class, p_class).f_month_changed.?(gobject.ext.as(Calendar, p_calendar));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_calendar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Calendar.Class, p_class).f_month_changed = @ptrCast(p_implementation);
            }
        };

        pub const next_month = struct {
            pub fn call(p_class: anytype, p_calendar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Calendar.Class, p_class).f_next_month.?(gobject.ext.as(Calendar, p_calendar));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_calendar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Calendar.Class, p_class).f_next_month = @ptrCast(p_implementation);
            }
        };

        pub const next_year = struct {
            pub fn call(p_class: anytype, p_calendar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Calendar.Class, p_class).f_next_year.?(gobject.ext.as(Calendar, p_calendar));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_calendar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Calendar.Class, p_class).f_next_year = @ptrCast(p_implementation);
            }
        };

        pub const prev_month = struct {
            pub fn call(p_class: anytype, p_calendar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Calendar.Class, p_class).f_prev_month.?(gobject.ext.as(Calendar, p_calendar));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_calendar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Calendar.Class, p_class).f_prev_month = @ptrCast(p_implementation);
            }
        };

        pub const prev_year = struct {
            pub fn call(p_class: anytype, p_calendar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Calendar.Class, p_class).f_prev_year.?(gobject.ext.as(Calendar, p_calendar));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_calendar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Calendar.Class, p_class).f_prev_year = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The selected day (as a number between 1 and 31, or 0
        /// to unselect the currently selected day).
        /// This property gets initially set to the current day.
        pub const day = struct {
            pub const name = "day";

            pub const Type = c_int;
        };

        /// Height of a detail cell, in rows.
        /// A value of 0 allows any width. See `gtk.Calendar.setDetailFunc`.
        pub const detail_height_rows = struct {
            pub const name = "detail-height-rows";

            pub const Type = c_int;
        };

        /// Width of a detail cell, in characters.
        /// A value of 0 allows any width. See `gtk.Calendar.setDetailFunc`.
        pub const detail_width_chars = struct {
            pub const name = "detail-width-chars";

            pub const Type = c_int;
        };

        /// The selected month (as a number between 0 and 11).
        /// This property gets initially set to the current month.
        pub const month = struct {
            pub const name = "month";

            pub const Type = c_int;
        };

        /// Determines whether the selected month can be changed.
        pub const no_month_change = struct {
            pub const name = "no-month-change";

            pub const Type = c_int;
        };

        /// Determines whether day names are displayed.
        pub const show_day_names = struct {
            pub const name = "show-day-names";

            pub const Type = c_int;
        };

        /// Determines whether details are shown directly in the widget, or if they are
        /// available only as tooltip. When this property is set days with details are
        /// marked.
        pub const show_details = struct {
            pub const name = "show-details";

            pub const Type = c_int;
        };

        /// Determines whether a heading is displayed.
        pub const show_heading = struct {
            pub const name = "show-heading";

            pub const Type = c_int;
        };

        /// Determines whether week numbers are displayed.
        pub const show_week_numbers = struct {
            pub const name = "show-week-numbers";

            pub const Type = c_int;
        };

        /// The selected year.
        /// This property gets initially set to the current year.
        pub const year = struct {
            pub const name = "year";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted when the user selects a day.
        pub const day_selected = struct {
            pub const name = "day-selected";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Calendar, p_instance))),
                    gobject.signalLookup("day-selected", Calendar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the user double-clicks a day.
        pub const day_selected_double_click = struct {
            pub const name = "day-selected-double-click";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Calendar, p_instance))),
                    gobject.signalLookup("day-selected-double-click", Calendar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the user clicks a button to change the selected month on a
        /// calendar.
        pub const month_changed = struct {
            pub const name = "month-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Calendar, p_instance))),
                    gobject.signalLookup("month-changed", Calendar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the user switched to the next month.
        pub const next_month = struct {
            pub const name = "next-month";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Calendar, p_instance))),
                    gobject.signalLookup("next-month", Calendar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when user switched to the next year.
        pub const next_year = struct {
            pub const name = "next-year";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Calendar, p_instance))),
                    gobject.signalLookup("next-year", Calendar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the user switched to the previous month.
        pub const prev_month = struct {
            pub const name = "prev-month";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Calendar, p_instance))),
                    gobject.signalLookup("prev-month", Calendar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when user switched to the previous year.
        pub const prev_year = struct {
            pub const name = "prev-year";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Calendar, p_instance))),
                    gobject.signalLookup("prev-year", Calendar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new calendar, with the current date being selected.
    extern fn gtk_calendar_new() *gtk.Calendar;
    pub const new = gtk_calendar_new;

    /// Remove all visual markers.
    extern fn gtk_calendar_clear_marks(p_calendar: *Calendar) void;
    pub const clearMarks = gtk_calendar_clear_marks;

    /// Obtains the selected date from a `gtk.Calendar`.
    extern fn gtk_calendar_get_date(p_calendar: *Calendar, p_year: ?*c_uint, p_month: ?*c_uint, p_day: ?*c_uint) void;
    pub const getDate = gtk_calendar_get_date;

    /// Returns if the `day` of the `calendar` is already marked.
    extern fn gtk_calendar_get_day_is_marked(p_calendar: *Calendar, p_day: c_uint) c_int;
    pub const getDayIsMarked = gtk_calendar_get_day_is_marked;

    /// Queries the height of detail cells, in rows.
    /// See `gtk.Calendar.properties.detail`-width-chars.
    extern fn gtk_calendar_get_detail_height_rows(p_calendar: *Calendar) c_int;
    pub const getDetailHeightRows = gtk_calendar_get_detail_height_rows;

    /// Queries the width of detail cells, in characters.
    /// See `gtk.Calendar.properties.detail`-width-chars.
    extern fn gtk_calendar_get_detail_width_chars(p_calendar: *Calendar) c_int;
    pub const getDetailWidthChars = gtk_calendar_get_detail_width_chars;

    /// Returns the current display options of `calendar`.
    extern fn gtk_calendar_get_display_options(p_calendar: *Calendar) gtk.CalendarDisplayOptions;
    pub const getDisplayOptions = gtk_calendar_get_display_options;

    /// Places a visual marker on a particular day.
    extern fn gtk_calendar_mark_day(p_calendar: *Calendar, p_day: c_uint) void;
    pub const markDay = gtk_calendar_mark_day;

    /// Selects a day from the current month.
    extern fn gtk_calendar_select_day(p_calendar: *Calendar, p_day: c_uint) void;
    pub const selectDay = gtk_calendar_select_day;

    /// Shifts the calendar to a different month.
    extern fn gtk_calendar_select_month(p_calendar: *Calendar, p_month: c_uint, p_year: c_uint) void;
    pub const selectMonth = gtk_calendar_select_month;

    /// Installs a function which provides Pango markup with detail information
    /// for each day. Examples for such details are holidays or appointments. That
    /// information is shown below each day when `gtk.Calendar.properties.show`-details is set.
    /// A tooltip containing with full detail information is provided, if the entire
    /// text should not fit into the details area, or if `gtk.Calendar.properties.show`-details
    /// is not set.
    ///
    /// The size of the details area can be restricted by setting the
    /// `gtk.Calendar.properties.detail`-width-chars and `gtk.Calendar.properties.detail`-height-rows
    /// properties.
    extern fn gtk_calendar_set_detail_func(p_calendar: *Calendar, p_func: gtk.CalendarDetailFunc, p_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setDetailFunc = gtk_calendar_set_detail_func;

    /// Updates the height of detail cells.
    /// See `gtk.Calendar.properties.detail`-height-rows.
    extern fn gtk_calendar_set_detail_height_rows(p_calendar: *Calendar, p_rows: c_int) void;
    pub const setDetailHeightRows = gtk_calendar_set_detail_height_rows;

    /// Updates the width of detail cells.
    /// See `gtk.Calendar.properties.detail`-width-chars.
    extern fn gtk_calendar_set_detail_width_chars(p_calendar: *Calendar, p_chars: c_int) void;
    pub const setDetailWidthChars = gtk_calendar_set_detail_width_chars;

    /// Sets display options (whether to display the heading and the month
    /// headings).
    extern fn gtk_calendar_set_display_options(p_calendar: *Calendar, p_flags: gtk.CalendarDisplayOptions) void;
    pub const setDisplayOptions = gtk_calendar_set_display_options;

    /// Removes the visual marker from a particular day.
    extern fn gtk_calendar_unmark_day(p_calendar: *Calendar, p_day: c_uint) void;
    pub const unmarkDay = gtk_calendar_unmark_day;

    extern fn gtk_calendar_get_type() usize;
    pub const getGObjectType = gtk_calendar_get_type;

    extern fn g_object_ref(p_self: *gtk.Calendar) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Calendar) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Calendar, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellAccessible = extern struct {
    pub const Parent = gtk.Accessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.TableCell };
    pub const Class = gtk.CellAccessibleClass;
    f_parent: gtk.Accessible,
    f_priv: ?*gtk.CellAccessiblePrivate,

    pub const virtual_methods = struct {
        pub const update_cache = struct {
            pub fn call(p_class: anytype, p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_emit_signal: c_int) void {
                return gobject.ext.as(CellAccessible.Class, p_class).f_update_cache.?(gobject.ext.as(CellAccessible, p_cell), p_emit_signal);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_emit_signal: c_int) callconv(.c) void) void {
                gobject.ext.as(CellAccessible.Class, p_class).f_update_cache = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_cell_accessible_get_type() usize;
    pub const getGObjectType = gtk_cell_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.CellAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.CellArea` is an abstract class for `gtk.CellLayout` widgets
/// (also referred to as "layouting widgets") to interface with an
/// arbitrary number of `GtkCellRenderers` and interact with the user
/// for a given `gtk.TreeModel` row.
///
/// The cell area handles events, focus navigation, drawing and
/// size requests and allocations for a given row of data.
///
/// Usually users dont have to interact with the `gtk.CellArea` directly
/// unless they are implementing a cell-layouting widget themselves.
///
/// # Requesting area sizes
///
/// As outlined in
/// [GtkWidget’s geometry management section][geometry-management],
/// GTK+ uses a height-for-width
/// geometry management system to compute the sizes of widgets and user
/// interfaces. `gtk.CellArea` uses the same semantics to calculate the
/// size of an area for an arbitrary number of `gtk.TreeModel` rows.
///
/// When requesting the size of a cell area one needs to calculate
/// the size for a handful of rows, and this will be done differently by
/// different layouting widgets. For instance a `gtk.TreeViewColumn`
/// always lines up the areas from top to bottom while a `gtk.IconView`
/// on the other hand might enforce that all areas received the same
/// width and wrap the areas around, requesting height for more cell
/// areas when allocated less width.
///
/// It’s also important for areas to maintain some cell
/// alignments with areas rendered for adjacent rows (cells can
/// appear “columnized” inside an area even when the size of
/// cells are different in each row). For this reason the `gtk.CellArea`
/// uses a `gtk.CellAreaContext` object to store the alignments
/// and sizes along the way (as well as the overall largest minimum
/// and natural size for all the rows which have been calculated
/// with the said context).
///
/// The `gtk.CellAreaContext` is an opaque object specific to the
/// `gtk.CellArea` which created it (see `gtk.CellArea.createContext`).
/// The owning cell-layouting widget can create as many contexts as
/// it wishes to calculate sizes of rows which should receive the
/// same size in at least one orientation (horizontally or vertically),
/// However, it’s important that the same `gtk.CellAreaContext` which
/// was used to request the sizes for a given `gtk.TreeModel` row be
/// used when rendering or processing events for that row.
///
/// In order to request the width of all the rows at the root level
/// of a `gtk.TreeModel` one would do the following:
///
/// ```
/// GtkTreeIter iter;
/// gint        minimum_width;
/// gint        natural_width;
///
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
///
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
/// ```
///
/// Note that in this example it’s not important to observe the
/// returned minimum and natural width of the area for each row
/// unless the cell-layouting object is actually interested in the
/// widths of individual rows. The overall width is however stored
/// in the accompanying `gtk.CellAreaContext` object and can be consulted
/// at any time.
///
/// This can be useful since `gtk.CellLayout` widgets usually have to
/// support requesting and rendering rows in treemodels with an
/// exceedingly large amount of rows. The `gtk.CellLayout` widget in
/// that case would calculate the required width of the rows in an
/// idle or timeout source (see `glib.timeoutAdd`) and when the widget
/// is requested its actual width in `gtk.WidgetClass.virtual_methods.get_preferred_width`
/// it can simply consult the width accumulated so far in the
/// `gtk.CellAreaContext` object.
///
/// A simple example where rows are rendered from top to bottom and
/// take up the full width of the layouting widget would look like:
///
/// ```
/// static void
/// foo_get_preferred_width (GtkWidget       *widget,
///                          gint            *minimum_size,
///                          gint            *natural_size)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
///
///   foo_ensure_at_least_one_handfull_of_rows_have_been_requested (foo);
///
///   gtk_cell_area_context_get_preferred_width (priv->context, minimum_size, natural_size);
/// }
/// ```
///
/// In the above example the Foo widget has to make sure that some
/// row sizes have been calculated (the amount of rows that Foo judged
/// was appropriate to request space for in a single timeout iteration)
/// before simply returning the amount of space required by the area via
/// the `gtk.CellAreaContext`.
///
/// Requesting the height for width (or width for height) of an area is
/// a similar task except in this case the `gtk.CellAreaContext` does not
/// store the data (actually, it does not know how much space the layouting
/// widget plans to allocate it for every row. It’s up to the layouting
/// widget to render each row of data with the appropriate height and
/// width which was requested by the `gtk.CellArea`).
///
/// In order to request the height for width of all the rows at the
/// root level of a `gtk.TreeModel` one would do the following:
///
/// ```
/// GtkTreeIter iter;
/// gint        minimum_height;
/// gint        natural_height;
/// gint        full_minimum_height = 0;
/// gint        full_natural_height = 0;
///
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_height_for_width (area, context, widget,
///                                                   width, &minimum_height, &natural_height);
///
///     if (width_is_for_allocation)
///        cache_row_height (&iter, minimum_height, natural_height);
///
///     full_minimum_height += minimum_height;
///     full_natural_height += natural_height;
///
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
///
/// Note that in the above example we would need to cache the heights
/// returned for each row so that we would know what sizes to render the
/// areas for each row. However we would only want to really cache the
/// heights if the request is intended for the layouting widgets real
/// allocation.
///
/// In some cases the layouting widget is requested the height for an
/// arbitrary for_width, this is a special case for layouting widgets
/// who need to request size for tens of thousands  of rows. For this
/// case it’s only important that the layouting widget calculate
/// one reasonably sized chunk of rows and return that height
/// synchronously. The reasoning here is that any layouting widget is
/// at least capable of synchronously calculating enough height to fill
/// the screen height (or scrolled window height) in response to a single
/// call to `gtk.WidgetClass.virtual_methods.get_preferred_height_for_width`. Returning
/// a perfect height for width that is larger than the screen area is
/// inconsequential since after the layouting receives an allocation
/// from a scrolled window it simply continues to drive the scrollbar
/// values while more and more height is required for the row heights
/// that are calculated in the background.
///
/// # Rendering Areas
///
/// Once area sizes have been aquired at least for the rows in the
/// visible area of the layouting widget they can be rendered at
/// `gtk.WidgetClass.virtual_methods.draw` time.
///
/// A crude example of how to render all the rows at the root level
/// runs as follows:
///
/// ```
/// GtkAllocation allocation;
/// GdkRectangle  cell_area = { 0, };
/// GtkTreeIter   iter;
/// gint          minimum_width;
/// gint          natural_width;
///
/// gtk_widget_get_allocation (widget, &allocation);
/// cell_area.width = allocation.width;
///
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     cell_area.height = get_cached_height_for_row (&iter);
///
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_render (area, context, widget, cr,
///                           &cell_area, &cell_area, state_flags, FALSE);
///
///     cell_area.y += cell_area.height;
///
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
///
/// Note that the cached height in this example really depends on how
/// the layouting widget works. The layouting widget might decide to
/// give every row its minimum or natural height or, if the model content
/// is expected to fit inside the layouting widget without scrolling, it
/// would make sense to calculate the allocation for each row at
/// `gtk.Widget.signals.size`-allocate time using `gtk.distributeNaturalAllocation`.
///
/// # Handling Events and Driving Keyboard Focus
///
/// Passing events to the area is as simple as handling events on any
/// normal widget and then passing them to the `gtk.CellArea.event`
/// API as they come in. Usually `gtk.CellArea` is only interested in
/// button events, however some customized derived areas can be implemented
/// who are interested in handling other events. Handling an event can
/// trigger the `gtk.CellArea.signals.focus`-changed signal to fire; as well as
/// `gtk.CellArea.signals.add`-editable in the case that an editable cell was
/// clicked and needs to start editing. You can call
/// `gtk.CellArea.stopEditing` at any time to cancel any cell editing
/// that is currently in progress.
///
/// The `gtk.CellArea` drives keyboard focus from cell to cell in a way
/// similar to `gtk.Widget`. For layouting widgets that support giving
/// focus to cells it’s important to remember to pass `GTK_CELL_RENDERER_FOCUSED`
/// to the area functions for the row that has focus and to tell the
/// area to paint the focus at render time.
///
/// Layouting widgets that accept focus on cells should implement the
/// `gtk.WidgetClass.virtual_methods.focus` virtual method. The layouting widget is always
/// responsible for knowing where `gtk.TreeModel` rows are rendered inside
/// the widget, so at `gtk.WidgetClass.virtual_methods.focus` time the layouting widget
/// should use the `gtk.CellArea` methods to navigate focus inside the area
/// and then observe the GtkDirectionType to pass the focus to adjacent
/// rows and areas.
///
/// A basic example of how the `gtk.WidgetClass.virtual_methods.focus` virtual method
/// should be implemented:
///
/// ```
/// static gboolean
/// foo_focus (GtkWidget       *widget,
///            GtkDirectionType direction)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
///   gint        focus_row;
///   gboolean    have_focus = FALSE;
///
///   focus_row = priv->focus_row;
///
///   if (!gtk_widget_has_focus (widget))
///     gtk_widget_grab_focus (widget);
///
///   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
///   while (valid)
///     {
///       gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
///
///       if (gtk_cell_area_focus (priv->area, direction))
///         {
///            priv->focus_row = focus_row;
///            have_focus = TRUE;
///            break;
///         }
///       else
///         {
///           if (direction == GTK_DIR_RIGHT ||
///               direction == GTK_DIR_LEFT)
///             break;
///           else if (direction == GTK_DIR_UP ||
///                    direction == GTK_DIR_TAB_BACKWARD)
///            {
///               if (focus_row == 0)
///                 break;
///               else
///                {
///                   focus_row--;
///                   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
///                }
///             }
///           else
///             {
///               if (focus_row == last_row)
///                 break;
///               else
///                 {
///                   focus_row++;
///                   valid = gtk_tree_model_iter_next (priv->model, &iter);
///                 }
///             }
///         }
///     }
///     return have_focus;
/// }
/// ```
///
/// Note that the layouting widget is responsible for matching the
/// GtkDirectionType values to the way it lays out its cells.
///
/// # Cell Properties
///
/// The `gtk.CellArea` introduces cell properties for `GtkCellRenderers`
/// in very much the same way that `gtk.Container` introduces
/// [child properties][child-properties]
/// for `GtkWidgets`. This provides some general interfaces for defining
/// the relationship cell areas have with their cells. For instance in a
/// `gtk.CellAreaBox` a cell might “expand” and receive extra space when
/// the area is allocated more than its full natural request, or a cell
/// might be configured to “align” with adjacent rows which were requested
/// and rendered with the same `gtk.CellAreaContext`.
///
/// Use `gtk.CellAreaClass.installCellProperty` to install cell
/// properties for a cell area class and `gtk.CellAreaClass.findCellProperty`
/// or `gtk.CellAreaClass.listCellProperties` to get information about
/// existing cell properties.
///
/// To set the value of a cell property, use `gtk.CellArea.cellSetProperty`,
/// `gtk.CellArea.cellSet` or `gtk.CellArea.cellSetValist`. To obtain
/// the value of a cell property, use `gtk.CellArea.cellGetProperty`,
/// `gtk.CellArea.cellGet` or `gtk.CellArea.cellGetValist`.
pub const CellArea = extern struct {
    pub const Parent = gobject.InitiallyUnowned;
    pub const Implements = [_]type{ gtk.Buildable, gtk.CellLayout };
    pub const Class = gtk.CellAreaClass;
    f_parent_instance: gobject.InitiallyUnowned,
    f_priv: ?*gtk.CellAreaPrivate,

    pub const virtual_methods = struct {
        /// Activates `area`, usually by activating the currently focused
        /// cell, however some subclasses which embed widgets in the area
        /// can also activate a widget if it currently has the focus.
        pub const activate = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState, p_edit_only: c_int) c_int {
                return gobject.ext.as(CellArea.Class, p_class).f_activate.?(gobject.ext.as(CellArea, p_area), p_context, p_widget, p_cell_area, p_flags, p_edit_only);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState, p_edit_only: c_int) callconv(.c) c_int) void {
                gobject.ext.as(CellArea.Class, p_class).f_activate = @ptrCast(p_implementation);
            }
        };

        /// Adds `renderer` to `area` with the default child cell properties.
        pub const add = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_renderer: *gtk.CellRenderer) void {
                return gobject.ext.as(CellArea.Class, p_class).f_add.?(gobject.ext.as(CellArea, p_area), p_renderer);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_renderer: *gtk.CellRenderer) callconv(.c) void) void {
                gobject.ext.as(CellArea.Class, p_class).f_add = @ptrCast(p_implementation);
            }
        };

        /// Applies any connected attributes to the renderers in
        /// `area` by pulling the values from `tree_model`.
        pub const apply_attributes = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_is_expander: c_int, p_is_expanded: c_int) void {
                return gobject.ext.as(CellArea.Class, p_class).f_apply_attributes.?(gobject.ext.as(CellArea, p_area), p_tree_model, p_iter, p_is_expander, p_is_expanded);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_is_expander: c_int, p_is_expanded: c_int) callconv(.c) void) void {
                gobject.ext.as(CellArea.Class, p_class).f_apply_attributes = @ptrCast(p_implementation);
            }
        };

        /// This is sometimes needed for cases where rows need to share
        /// alignments in one orientation but may be separately grouped
        /// in the opposing orientation.
        ///
        /// For instance, `gtk.IconView` creates all icons (rows) to have
        /// the same width and the cells theirin to have the same
        /// horizontal alignments. However each row of icons may have
        /// a separate collective height. `gtk.IconView` uses this to
        /// request the heights of each row based on a context which
        /// was already used to request all the row widths that are
        /// to be displayed.
        pub const copy_context = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext) *gtk.CellAreaContext {
                return gobject.ext.as(CellArea.Class, p_class).f_copy_context.?(gobject.ext.as(CellArea, p_area), p_context);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext) callconv(.c) *gtk.CellAreaContext) void {
                gobject.ext.as(CellArea.Class, p_class).f_copy_context = @ptrCast(p_implementation);
            }
        };

        /// Creates a `gtk.CellAreaContext` to be used with `area` for
        /// all purposes. `gtk.CellAreaContext` stores geometry information
        /// for rows for which it was operated on, it is important to use
        /// the same context for the same row of data at all times (i.e.
        /// one should render and handle events with the same `gtk.CellAreaContext`
        /// which was used to request the size of those rows of data).
        pub const create_context = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gtk.CellAreaContext {
                return gobject.ext.as(CellArea.Class, p_class).f_create_context.?(gobject.ext.as(CellArea, p_area));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gtk.CellAreaContext) void {
                gobject.ext.as(CellArea.Class, p_class).f_create_context = @ptrCast(p_implementation);
            }
        };

        /// Delegates event handling to a `gtk.CellArea`.
        pub const event = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_event: *gdk.Event, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) c_int {
                return gobject.ext.as(CellArea.Class, p_class).f_event.?(gobject.ext.as(CellArea, p_area), p_context, p_widget, p_event, p_cell_area, p_flags);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_event: *gdk.Event, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) callconv(.c) c_int) void {
                gobject.ext.as(CellArea.Class, p_class).f_event = @ptrCast(p_implementation);
            }
        };

        /// This should be called by the `area`’s owning layout widget
        /// when focus is to be passed to `area`, or moved within `area`
        /// for a given `direction` and row data.
        ///
        /// Implementing `gtk.CellArea` classes should implement this
        /// method to receive and navigate focus in its own way particular
        /// to how it lays out cells.
        pub const focus = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.DirectionType) c_int {
                return gobject.ext.as(CellArea.Class, p_class).f_focus.?(gobject.ext.as(CellArea, p_area), p_direction);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.DirectionType) callconv(.c) c_int) void {
                gobject.ext.as(CellArea.Class, p_class).f_focus = @ptrCast(p_implementation);
            }
        };

        /// Calls `callback` for every `gtk.CellRenderer` in `area`.
        pub const foreach = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_callback: gtk.CellCallback, p_callback_data: ?*anyopaque) void {
                return gobject.ext.as(CellArea.Class, p_class).f_foreach.?(gobject.ext.as(CellArea, p_area), p_callback, p_callback_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_callback: gtk.CellCallback, p_callback_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(CellArea.Class, p_class).f_foreach = @ptrCast(p_implementation);
            }
        };

        /// Calls `callback` for every `gtk.CellRenderer` in `area` with the
        /// allocated rectangle inside `cell_area`.
        pub const foreach_alloc = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_cell_area: *const gdk.Rectangle, p_background_area: *const gdk.Rectangle, p_callback: gtk.CellAllocCallback, p_callback_data: ?*anyopaque) void {
                return gobject.ext.as(CellArea.Class, p_class).f_foreach_alloc.?(gobject.ext.as(CellArea, p_area), p_context, p_widget, p_cell_area, p_background_area, p_callback, p_callback_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_cell_area: *const gdk.Rectangle, p_background_area: *const gdk.Rectangle, p_callback: gtk.CellAllocCallback, p_callback_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(CellArea.Class, p_class).f_foreach_alloc = @ptrCast(p_implementation);
            }
        };

        /// This should be implemented to report the values of
        ///     child cell properties for a given child `gtk.CellRenderer`.
        pub const get_cell_property = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_renderer: *gtk.CellRenderer, p_property_id: c_uint, p_value: *gobject.Value, p_pspec: *gobject.ParamSpec) void {
                return gobject.ext.as(CellArea.Class, p_class).f_get_cell_property.?(gobject.ext.as(CellArea, p_area), p_renderer, p_property_id, p_value, p_pspec);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_renderer: *gtk.CellRenderer, p_property_id: c_uint, p_value: *gobject.Value, p_pspec: *gobject.ParamSpec) callconv(.c) void) void {
                gobject.ext.as(CellArea.Class, p_class).f_get_cell_property = @ptrCast(p_implementation);
            }
        };

        /// Retrieves a cell area’s initial minimum and natural height.
        ///
        /// `area` will store some geometrical information in `context` along the way;
        /// when requesting sizes over an arbitrary number of rows, it’s not important
        /// to check the `minimum_height` and `natural_height` of this call but rather to
        /// consult `gtk.CellAreaContext.getPreferredHeight` after a series of
        /// requests.
        pub const get_preferred_height = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) void {
                return gobject.ext.as(CellArea.Class, p_class).f_get_preferred_height.?(gobject.ext.as(CellArea, p_area), p_context, p_widget, p_minimum_height, p_natural_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(CellArea.Class, p_class).f_get_preferred_height = @ptrCast(p_implementation);
            }
        };

        /// Retrieves a cell area’s minimum and natural height if it would be given
        /// the specified `width`.
        ///
        /// `area` stores some geometrical information in `context` along the way
        /// while calling `gtk.CellArea.getPreferredWidth`. It’s important to
        /// perform a series of `gtk.CellArea.getPreferredWidth` requests with
        /// `context` first and then call `gtk.CellArea.getPreferredHeightForWidth`
        /// on each cell area individually to get the height for width of each
        /// fully requested row.
        ///
        /// If at some point, the width of a single row changes, it should be
        /// requested with `gtk.CellArea.getPreferredWidth` again and then
        /// the full width of the requested rows checked again with
        /// `gtk.CellAreaContext.getPreferredWidth`.
        pub const get_preferred_height_for_width = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) void {
                return gobject.ext.as(CellArea.Class, p_class).f_get_preferred_height_for_width.?(gobject.ext.as(CellArea, p_area), p_context, p_widget, p_width, p_minimum_height, p_natural_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(CellArea.Class, p_class).f_get_preferred_height_for_width = @ptrCast(p_implementation);
            }
        };

        /// Retrieves a cell area’s initial minimum and natural width.
        ///
        /// `area` will store some geometrical information in `context` along the way;
        /// when requesting sizes over an arbitrary number of rows, it’s not important
        /// to check the `minimum_width` and `natural_width` of this call but rather to
        /// consult `gtk.CellAreaContext.getPreferredWidth` after a series of
        /// requests.
        pub const get_preferred_width = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) void {
                return gobject.ext.as(CellArea.Class, p_class).f_get_preferred_width.?(gobject.ext.as(CellArea, p_area), p_context, p_widget, p_minimum_width, p_natural_width);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(CellArea.Class, p_class).f_get_preferred_width = @ptrCast(p_implementation);
            }
        };

        /// Retrieves a cell area’s minimum and natural width if it would be given
        /// the specified `height`.
        ///
        /// `area` stores some geometrical information in `context` along the way
        /// while calling `gtk.CellArea.getPreferredHeight`. It’s important to
        /// perform a series of `gtk.CellArea.getPreferredHeight` requests with
        /// `context` first and then call `gtk.CellArea.getPreferredWidthForHeight`
        /// on each cell area individually to get the height for width of each
        /// fully requested row.
        ///
        /// If at some point, the height of a single row changes, it should be
        /// requested with `gtk.CellArea.getPreferredHeight` again and then
        /// the full height of the requested rows checked again with
        /// `gtk.CellAreaContext.getPreferredHeight`.
        pub const get_preferred_width_for_height = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) void {
                return gobject.ext.as(CellArea.Class, p_class).f_get_preferred_width_for_height.?(gobject.ext.as(CellArea, p_area), p_context, p_widget, p_height, p_minimum_width, p_natural_width);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(CellArea.Class, p_class).f_get_preferred_width_for_height = @ptrCast(p_implementation);
            }
        };

        /// Gets whether the area prefers a height-for-width layout
        /// or a width-for-height layout.
        pub const get_request_mode = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) gtk.SizeRequestMode {
                return gobject.ext.as(CellArea.Class, p_class).f_get_request_mode.?(gobject.ext.as(CellArea, p_area));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) gtk.SizeRequestMode) void {
                gobject.ext.as(CellArea.Class, p_class).f_get_request_mode = @ptrCast(p_implementation);
            }
        };

        /// Returns whether the area can do anything when activated,
        /// after applying new attributes to `area`.
        pub const is_activatable = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(CellArea.Class, p_class).f_is_activatable.?(gobject.ext.as(CellArea, p_area));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(CellArea.Class, p_class).f_is_activatable = @ptrCast(p_implementation);
            }
        };

        /// Removes `renderer` from `area`.
        pub const remove = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_renderer: *gtk.CellRenderer) void {
                return gobject.ext.as(CellArea.Class, p_class).f_remove.?(gobject.ext.as(CellArea, p_area), p_renderer);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_renderer: *gtk.CellRenderer) callconv(.c) void) void {
                gobject.ext.as(CellArea.Class, p_class).f_remove = @ptrCast(p_implementation);
            }
        };

        /// Renders `area`’s cells according to `area`’s layout onto `widget` at
        /// the given coordinates.
        pub const render = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_cr: *cairo.Context, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState, p_paint_focus: c_int) void {
                return gobject.ext.as(CellArea.Class, p_class).f_render.?(gobject.ext.as(CellArea, p_area), p_context, p_widget, p_cr, p_background_area, p_cell_area, p_flags, p_paint_focus);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_cr: *cairo.Context, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState, p_paint_focus: c_int) callconv(.c) void) void {
                gobject.ext.as(CellArea.Class, p_class).f_render = @ptrCast(p_implementation);
            }
        };

        /// This should be implemented to handle changes in child
        ///     cell properties for a given `gtk.CellRenderer` that were previously
        ///     installed on the `gtk.CellAreaClass` with `gtk.CellAreaClass.installCellProperty`.
        pub const set_cell_property = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_renderer: *gtk.CellRenderer, p_property_id: c_uint, p_value: *const gobject.Value, p_pspec: *gobject.ParamSpec) void {
                return gobject.ext.as(CellArea.Class, p_class).f_set_cell_property.?(gobject.ext.as(CellArea, p_area), p_renderer, p_property_id, p_value, p_pspec);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_renderer: *gtk.CellRenderer, p_property_id: c_uint, p_value: *const gobject.Value, p_pspec: *gobject.ParamSpec) callconv(.c) void) void {
                gobject.ext.as(CellArea.Class, p_class).f_set_cell_property = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The widget currently editing the edited cell
        ///
        /// This property is read-only and only changes as
        /// a result of a call `gtk.CellArea.activateCell`.
        pub const edit_widget = struct {
            pub const name = "edit-widget";

            pub const Type = ?*gtk.CellEditable;
        };

        /// The cell in the area that is currently edited
        ///
        /// This property is read-only and only changes as
        /// a result of a call `gtk.CellArea.activateCell`.
        pub const edited_cell = struct {
            pub const name = "edited-cell";

            pub const Type = ?*gtk.CellRenderer;
        };

        /// The cell in the area that currently has focus
        pub const focus_cell = struct {
            pub const name = "focus-cell";

            pub const Type = ?*gtk.CellRenderer;
        };
    };

    pub const signals = struct {
        /// Indicates that editing has started on `renderer` and that `editable`
        /// should be added to the owning cell-layouting widget at `cell_area`.
        pub const add_editable = struct {
            pub const name = "add-editable";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_renderer: *gtk.CellRenderer, p_editable: *gtk.CellEditable, p_cell_area: *gdk.Rectangle, p_path: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(CellArea, p_instance))),
                    gobject.signalLookup("add-editable", CellArea.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted whenever applying attributes to `area` from `model`
        pub const apply_attributes = struct {
            pub const name = "apply-attributes";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_is_expander: c_int, p_is_expanded: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(CellArea, p_instance))),
                    gobject.signalLookup("apply-attributes", CellArea.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Indicates that focus changed on this `area`. This signal
        /// is emitted either as a result of focus handling or event
        /// handling.
        ///
        /// It's possible that the signal is emitted even if the
        /// currently focused renderer did not change, this is
        /// because focus may change to the same renderer in the
        /// same cell area for a different row of data.
        pub const focus_changed = struct {
            pub const name = "focus-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_renderer: *gtk.CellRenderer, p_path: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(CellArea, p_instance))),
                    gobject.signalLookup("focus-changed", CellArea.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Indicates that editing finished on `renderer` and that `editable`
        /// should be removed from the owning cell-layouting widget.
        pub const remove_editable = struct {
            pub const name = "remove-editable";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_renderer: *gtk.CellRenderer, p_editable: *gtk.CellEditable, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(CellArea, p_instance))),
                    gobject.signalLookup("remove-editable", CellArea.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Activates `area`, usually by activating the currently focused
    /// cell, however some subclasses which embed widgets in the area
    /// can also activate a widget if it currently has the focus.
    extern fn gtk_cell_area_activate(p_area: *CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState, p_edit_only: c_int) c_int;
    pub const activate = gtk_cell_area_activate;

    /// This is used by `gtk.CellArea` subclasses when handling events
    /// to activate cells, the base `gtk.CellArea` class activates cells
    /// for keyboard events for free in its own GtkCellArea->`activate`
    /// implementation.
    extern fn gtk_cell_area_activate_cell(p_area: *CellArea, p_widget: *gtk.Widget, p_renderer: *gtk.CellRenderer, p_event: *gdk.Event, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) c_int;
    pub const activateCell = gtk_cell_area_activate_cell;

    /// Adds `renderer` to `area` with the default child cell properties.
    extern fn gtk_cell_area_add(p_area: *CellArea, p_renderer: *gtk.CellRenderer) void;
    pub const add = gtk_cell_area_add;

    /// Adds `sibling` to `renderer`’s focusable area, focus will be drawn
    /// around `renderer` and all of its siblings if `renderer` can
    /// focus for a given row.
    ///
    /// Events handled by focus siblings can also activate the given
    /// focusable `renderer`.
    extern fn gtk_cell_area_add_focus_sibling(p_area: *CellArea, p_renderer: *gtk.CellRenderer, p_sibling: *gtk.CellRenderer) void;
    pub const addFocusSibling = gtk_cell_area_add_focus_sibling;

    /// Adds `renderer` to `area`, setting cell properties at the same time.
    /// See `gtk.CellArea.add` and `gtk.CellArea.cellSet` for more details.
    extern fn gtk_cell_area_add_with_properties(p_area: *CellArea, p_renderer: *gtk.CellRenderer, p_first_prop_name: [*:0]const u8, ...) void;
    pub const addWithProperties = gtk_cell_area_add_with_properties;

    /// Applies any connected attributes to the renderers in
    /// `area` by pulling the values from `tree_model`.
    extern fn gtk_cell_area_apply_attributes(p_area: *CellArea, p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_is_expander: c_int, p_is_expanded: c_int) void;
    pub const applyAttributes = gtk_cell_area_apply_attributes;

    /// Connects an `attribute` to apply values from `column` for the
    /// `gtk.TreeModel` in use.
    extern fn gtk_cell_area_attribute_connect(p_area: *CellArea, p_renderer: *gtk.CellRenderer, p_attribute: [*:0]const u8, p_column: c_int) void;
    pub const attributeConnect = gtk_cell_area_attribute_connect;

    /// Disconnects `attribute` for the `renderer` in `area` so that
    /// attribute will no longer be updated with values from the
    /// model.
    extern fn gtk_cell_area_attribute_disconnect(p_area: *CellArea, p_renderer: *gtk.CellRenderer, p_attribute: [*:0]const u8) void;
    pub const attributeDisconnect = gtk_cell_area_attribute_disconnect;

    /// Returns the model column that an attribute has been mapped to,
    /// or -1 if the attribute is not mapped.
    extern fn gtk_cell_area_attribute_get_column(p_area: *CellArea, p_renderer: *gtk.CellRenderer, p_attribute: [*:0]const u8) c_int;
    pub const attributeGetColumn = gtk_cell_area_attribute_get_column;

    /// Gets the values of one or more cell properties for `renderer` in `area`.
    extern fn gtk_cell_area_cell_get(p_area: *CellArea, p_renderer: *gtk.CellRenderer, p_first_prop_name: [*:0]const u8, ...) void;
    pub const cellGet = gtk_cell_area_cell_get;

    /// Gets the value of a cell property for `renderer` in `area`.
    extern fn gtk_cell_area_cell_get_property(p_area: *CellArea, p_renderer: *gtk.CellRenderer, p_property_name: [*:0]const u8, p_value: *gobject.Value) void;
    pub const cellGetProperty = gtk_cell_area_cell_get_property;

    /// Gets the values of one or more cell properties for `renderer` in `area`.
    extern fn gtk_cell_area_cell_get_valist(p_area: *CellArea, p_renderer: *gtk.CellRenderer, p_first_property_name: [*:0]const u8, p_var_args: std.builtin.VaList) void;
    pub const cellGetValist = gtk_cell_area_cell_get_valist;

    /// Sets one or more cell properties for `cell` in `area`.
    extern fn gtk_cell_area_cell_set(p_area: *CellArea, p_renderer: *gtk.CellRenderer, p_first_prop_name: [*:0]const u8, ...) void;
    pub const cellSet = gtk_cell_area_cell_set;

    /// Sets a cell property for `renderer` in `area`.
    extern fn gtk_cell_area_cell_set_property(p_area: *CellArea, p_renderer: *gtk.CellRenderer, p_property_name: [*:0]const u8, p_value: *const gobject.Value) void;
    pub const cellSetProperty = gtk_cell_area_cell_set_property;

    /// Sets one or more cell properties for `renderer` in `area`.
    extern fn gtk_cell_area_cell_set_valist(p_area: *CellArea, p_renderer: *gtk.CellRenderer, p_first_property_name: [*:0]const u8, p_var_args: std.builtin.VaList) void;
    pub const cellSetValist = gtk_cell_area_cell_set_valist;

    /// This is sometimes needed for cases where rows need to share
    /// alignments in one orientation but may be separately grouped
    /// in the opposing orientation.
    ///
    /// For instance, `gtk.IconView` creates all icons (rows) to have
    /// the same width and the cells theirin to have the same
    /// horizontal alignments. However each row of icons may have
    /// a separate collective height. `gtk.IconView` uses this to
    /// request the heights of each row based on a context which
    /// was already used to request all the row widths that are
    /// to be displayed.
    extern fn gtk_cell_area_copy_context(p_area: *CellArea, p_context: *gtk.CellAreaContext) *gtk.CellAreaContext;
    pub const copyContext = gtk_cell_area_copy_context;

    /// Creates a `gtk.CellAreaContext` to be used with `area` for
    /// all purposes. `gtk.CellAreaContext` stores geometry information
    /// for rows for which it was operated on, it is important to use
    /// the same context for the same row of data at all times (i.e.
    /// one should render and handle events with the same `gtk.CellAreaContext`
    /// which was used to request the size of those rows of data).
    extern fn gtk_cell_area_create_context(p_area: *CellArea) *gtk.CellAreaContext;
    pub const createContext = gtk_cell_area_create_context;

    /// Delegates event handling to a `gtk.CellArea`.
    extern fn gtk_cell_area_event(p_area: *CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_event: *gdk.Event, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) c_int;
    pub const event = gtk_cell_area_event;

    /// This should be called by the `area`’s owning layout widget
    /// when focus is to be passed to `area`, or moved within `area`
    /// for a given `direction` and row data.
    ///
    /// Implementing `gtk.CellArea` classes should implement this
    /// method to receive and navigate focus in its own way particular
    /// to how it lays out cells.
    extern fn gtk_cell_area_focus(p_area: *CellArea, p_direction: gtk.DirectionType) c_int;
    pub const focus = gtk_cell_area_focus;

    /// Calls `callback` for every `gtk.CellRenderer` in `area`.
    extern fn gtk_cell_area_foreach(p_area: *CellArea, p_callback: gtk.CellCallback, p_callback_data: ?*anyopaque) void;
    pub const foreach = gtk_cell_area_foreach;

    /// Calls `callback` for every `gtk.CellRenderer` in `area` with the
    /// allocated rectangle inside `cell_area`.
    extern fn gtk_cell_area_foreach_alloc(p_area: *CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_cell_area: *const gdk.Rectangle, p_background_area: *const gdk.Rectangle, p_callback: gtk.CellAllocCallback, p_callback_data: ?*anyopaque) void;
    pub const foreachAlloc = gtk_cell_area_foreach_alloc;

    /// Derives the allocation of `renderer` inside `area` if `area`
    /// were to be renderered in `cell_area`.
    extern fn gtk_cell_area_get_cell_allocation(p_area: *CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_renderer: *gtk.CellRenderer, p_cell_area: *const gdk.Rectangle, p_allocation: *gdk.Rectangle) void;
    pub const getCellAllocation = gtk_cell_area_get_cell_allocation;

    /// Gets the `gtk.CellRenderer` at `x` and `y` coordinates inside `area` and optionally
    /// returns the full cell allocation for it inside `cell_area`.
    extern fn gtk_cell_area_get_cell_at_position(p_area: *CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_cell_area: *const gdk.Rectangle, p_x: c_int, p_y: c_int, p_alloc_area: ?*gdk.Rectangle) *gtk.CellRenderer;
    pub const getCellAtPosition = gtk_cell_area_get_cell_at_position;

    /// Gets the current `gtk.TreePath` string for the currently
    /// applied `gtk.TreeIter`, this is implicitly updated when
    /// `gtk.CellArea.applyAttributes` is called and can be
    /// used to interact with renderers from `gtk.CellArea`
    /// subclasses.
    extern fn gtk_cell_area_get_current_path_string(p_area: *CellArea) [*:0]const u8;
    pub const getCurrentPathString = gtk_cell_area_get_current_path_string;

    /// Gets the `gtk.CellEditable` widget currently used
    /// to edit the currently edited cell.
    extern fn gtk_cell_area_get_edit_widget(p_area: *CellArea) *gtk.CellEditable;
    pub const getEditWidget = gtk_cell_area_get_edit_widget;

    /// Gets the `gtk.CellRenderer` in `area` that is currently
    /// being edited.
    extern fn gtk_cell_area_get_edited_cell(p_area: *CellArea) *gtk.CellRenderer;
    pub const getEditedCell = gtk_cell_area_get_edited_cell;

    /// Retrieves the currently focused cell for `area`
    extern fn gtk_cell_area_get_focus_cell(p_area: *CellArea) *gtk.CellRenderer;
    pub const getFocusCell = gtk_cell_area_get_focus_cell;

    /// Gets the `gtk.CellRenderer` which is expected to be focusable
    /// for which `renderer` is, or may be a sibling.
    ///
    /// This is handy for `gtk.CellArea` subclasses when handling events,
    /// after determining the renderer at the event location it can
    /// then chose to activate the focus cell for which the event
    /// cell may have been a sibling.
    extern fn gtk_cell_area_get_focus_from_sibling(p_area: *CellArea, p_renderer: *gtk.CellRenderer) ?*gtk.CellRenderer;
    pub const getFocusFromSibling = gtk_cell_area_get_focus_from_sibling;

    /// Gets the focus sibling cell renderers for `renderer`.
    extern fn gtk_cell_area_get_focus_siblings(p_area: *CellArea, p_renderer: *gtk.CellRenderer) *const glib.List;
    pub const getFocusSiblings = gtk_cell_area_get_focus_siblings;

    /// Retrieves a cell area’s initial minimum and natural height.
    ///
    /// `area` will store some geometrical information in `context` along the way;
    /// when requesting sizes over an arbitrary number of rows, it’s not important
    /// to check the `minimum_height` and `natural_height` of this call but rather to
    /// consult `gtk.CellAreaContext.getPreferredHeight` after a series of
    /// requests.
    extern fn gtk_cell_area_get_preferred_height(p_area: *CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) void;
    pub const getPreferredHeight = gtk_cell_area_get_preferred_height;

    /// Retrieves a cell area’s minimum and natural height if it would be given
    /// the specified `width`.
    ///
    /// `area` stores some geometrical information in `context` along the way
    /// while calling `gtk.CellArea.getPreferredWidth`. It’s important to
    /// perform a series of `gtk.CellArea.getPreferredWidth` requests with
    /// `context` first and then call `gtk.CellArea.getPreferredHeightForWidth`
    /// on each cell area individually to get the height for width of each
    /// fully requested row.
    ///
    /// If at some point, the width of a single row changes, it should be
    /// requested with `gtk.CellArea.getPreferredWidth` again and then
    /// the full width of the requested rows checked again with
    /// `gtk.CellAreaContext.getPreferredWidth`.
    extern fn gtk_cell_area_get_preferred_height_for_width(p_area: *CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) void;
    pub const getPreferredHeightForWidth = gtk_cell_area_get_preferred_height_for_width;

    /// Retrieves a cell area’s initial minimum and natural width.
    ///
    /// `area` will store some geometrical information in `context` along the way;
    /// when requesting sizes over an arbitrary number of rows, it’s not important
    /// to check the `minimum_width` and `natural_width` of this call but rather to
    /// consult `gtk.CellAreaContext.getPreferredWidth` after a series of
    /// requests.
    extern fn gtk_cell_area_get_preferred_width(p_area: *CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) void;
    pub const getPreferredWidth = gtk_cell_area_get_preferred_width;

    /// Retrieves a cell area’s minimum and natural width if it would be given
    /// the specified `height`.
    ///
    /// `area` stores some geometrical information in `context` along the way
    /// while calling `gtk.CellArea.getPreferredHeight`. It’s important to
    /// perform a series of `gtk.CellArea.getPreferredHeight` requests with
    /// `context` first and then call `gtk.CellArea.getPreferredWidthForHeight`
    /// on each cell area individually to get the height for width of each
    /// fully requested row.
    ///
    /// If at some point, the height of a single row changes, it should be
    /// requested with `gtk.CellArea.getPreferredHeight` again and then
    /// the full height of the requested rows checked again with
    /// `gtk.CellAreaContext.getPreferredHeight`.
    extern fn gtk_cell_area_get_preferred_width_for_height(p_area: *CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) void;
    pub const getPreferredWidthForHeight = gtk_cell_area_get_preferred_width_for_height;

    /// Gets whether the area prefers a height-for-width layout
    /// or a width-for-height layout.
    extern fn gtk_cell_area_get_request_mode(p_area: *CellArea) gtk.SizeRequestMode;
    pub const getRequestMode = gtk_cell_area_get_request_mode;

    /// Checks if `area` contains `renderer`.
    extern fn gtk_cell_area_has_renderer(p_area: *CellArea, p_renderer: *gtk.CellRenderer) c_int;
    pub const hasRenderer = gtk_cell_area_has_renderer;

    /// This is a convenience function for `gtk.CellArea` implementations
    /// to get the inner area where a given `gtk.CellRenderer` will be
    /// rendered. It removes any padding previously added by `gtk.CellArea.requestRenderer`.
    extern fn gtk_cell_area_inner_cell_area(p_area: *CellArea, p_widget: *gtk.Widget, p_cell_area: *const gdk.Rectangle, p_inner_area: *gdk.Rectangle) void;
    pub const innerCellArea = gtk_cell_area_inner_cell_area;

    /// Returns whether the area can do anything when activated,
    /// after applying new attributes to `area`.
    extern fn gtk_cell_area_is_activatable(p_area: *CellArea) c_int;
    pub const isActivatable = gtk_cell_area_is_activatable;

    /// Returns whether `sibling` is one of `renderer`’s focus siblings
    /// (see `gtk.CellArea.addFocusSibling`).
    extern fn gtk_cell_area_is_focus_sibling(p_area: *CellArea, p_renderer: *gtk.CellRenderer, p_sibling: *gtk.CellRenderer) c_int;
    pub const isFocusSibling = gtk_cell_area_is_focus_sibling;

    /// Removes `renderer` from `area`.
    extern fn gtk_cell_area_remove(p_area: *CellArea, p_renderer: *gtk.CellRenderer) void;
    pub const remove = gtk_cell_area_remove;

    /// Removes `sibling` from `renderer`’s focus sibling list
    /// (see `gtk.CellArea.addFocusSibling`).
    extern fn gtk_cell_area_remove_focus_sibling(p_area: *CellArea, p_renderer: *gtk.CellRenderer, p_sibling: *gtk.CellRenderer) void;
    pub const removeFocusSibling = gtk_cell_area_remove_focus_sibling;

    /// Renders `area`’s cells according to `area`’s layout onto `widget` at
    /// the given coordinates.
    extern fn gtk_cell_area_render(p_area: *CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_cr: *cairo.Context, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState, p_paint_focus: c_int) void;
    pub const render = gtk_cell_area_render;

    /// This is a convenience function for `gtk.CellArea` implementations
    /// to request size for cell renderers. It’s important to use this
    /// function to request size and then use `gtk.CellArea.innerCellArea`
    /// at render and event time since this function will add padding
    /// around the cell for focus painting.
    extern fn gtk_cell_area_request_renderer(p_area: *CellArea, p_renderer: *gtk.CellRenderer, p_orientation: gtk.Orientation, p_widget: *gtk.Widget, p_for_size: c_int, p_minimum_size: ?*c_int, p_natural_size: ?*c_int) void;
    pub const requestRenderer = gtk_cell_area_request_renderer;

    /// Explicitly sets the currently focused cell to `renderer`.
    ///
    /// This is generally called by implementations of
    /// `gtk.CellAreaClass.virtual_methods.focus` or `gtk.CellAreaClass.virtual_methods.event`,
    /// however it can also be used to implement functions such
    /// as `gtk.TreeView.setCursorOnCell`.
    extern fn gtk_cell_area_set_focus_cell(p_area: *CellArea, p_renderer: *gtk.CellRenderer) void;
    pub const setFocusCell = gtk_cell_area_set_focus_cell;

    /// Explicitly stops the editing of the currently edited cell.
    ///
    /// If `canceled` is `TRUE`, the currently edited cell renderer
    /// will emit the ::editing-canceled signal, otherwise the
    /// the ::editing-done signal will be emitted on the current
    /// edit widget.
    ///
    /// See `gtk.CellArea.getEditedCell` and `gtk.CellArea.getEditWidget`.
    extern fn gtk_cell_area_stop_editing(p_area: *CellArea, p_canceled: c_int) void;
    pub const stopEditing = gtk_cell_area_stop_editing;

    extern fn gtk_cell_area_get_type() usize;
    pub const getGObjectType = gtk_cell_area_get_type;

    extern fn g_object_ref(p_self: *gtk.CellArea) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellArea) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellArea, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.CellAreaBox` renders cell renderers into a row or a column
/// depending on its `gtk.Orientation`.
///
/// GtkCellAreaBox uses a notion of packing. Packing
/// refers to adding cell renderers with reference to a particular position
/// in a `gtk.CellAreaBox`. There are two reference positions: the
/// start and the end of the box.
/// When the `gtk.CellAreaBox` is oriented in the `GTK_ORIENTATION_VERTICAL`
/// orientation, the start is defined as the top of the box and the end is
/// defined as the bottom. In the `GTK_ORIENTATION_HORIZONTAL` orientation
/// start is defined as the left side and the end is defined as the right
/// side.
///
/// Alignments of `GtkCellRenderers` rendered in adjacent rows can be
/// configured by configuring the `gtk.CellAreaBox` align child cell property
/// with `gtk.CellArea.cellSetProperty` or by specifying the "align"
/// argument to `gtk.CellAreaBox.packStart` and `gtk.CellAreaBox.packEnd`.
pub const CellAreaBox = extern struct {
    pub const Parent = gtk.CellArea;
    pub const Implements = [_]type{ gtk.Buildable, gtk.CellLayout, gtk.Orientable };
    pub const Class = gtk.CellAreaBoxClass;
    f_parent_instance: gtk.CellArea,
    f_priv: ?*gtk.CellAreaBoxPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The amount of space to reserve between cells.
        pub const spacing = struct {
            pub const name = "spacing";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.CellAreaBox`.
    extern fn gtk_cell_area_box_new() *gtk.CellAreaBox;
    pub const new = gtk_cell_area_box_new;

    /// Gets the spacing added between cell renderers.
    extern fn gtk_cell_area_box_get_spacing(p_box: *CellAreaBox) c_int;
    pub const getSpacing = gtk_cell_area_box_get_spacing;

    /// Adds `renderer` to `box`, packed with reference to the end of `box`.
    ///
    /// The `renderer` is packed after (away from end of) any other
    /// `gtk.CellRenderer` packed with reference to the end of `box`.
    extern fn gtk_cell_area_box_pack_end(p_box: *CellAreaBox, p_renderer: *gtk.CellRenderer, p_expand: c_int, p_align: c_int, p_fixed: c_int) void;
    pub const packEnd = gtk_cell_area_box_pack_end;

    /// Adds `renderer` to `box`, packed with reference to the start of `box`.
    ///
    /// The `renderer` is packed after any other `gtk.CellRenderer` packed
    /// with reference to the start of `box`.
    extern fn gtk_cell_area_box_pack_start(p_box: *CellAreaBox, p_renderer: *gtk.CellRenderer, p_expand: c_int, p_align: c_int, p_fixed: c_int) void;
    pub const packStart = gtk_cell_area_box_pack_start;

    /// Sets the spacing to add between cell renderers in `box`.
    extern fn gtk_cell_area_box_set_spacing(p_box: *CellAreaBox, p_spacing: c_int) void;
    pub const setSpacing = gtk_cell_area_box_set_spacing;

    extern fn gtk_cell_area_box_get_type() usize;
    pub const getGObjectType = gtk_cell_area_box_get_type;

    extern fn g_object_ref(p_self: *gtk.CellAreaBox) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellAreaBox) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellAreaBox, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.CellAreaContext` object is created by a given `gtk.CellArea`
/// implementation via its `gtk.CellAreaClass.virtual_methods.create_context` virtual
/// method and is used to store cell sizes and alignments for a series of
/// `gtk.TreeModel` rows that are requested and rendered in the same context.
///
/// `gtk.CellLayout` widgets can create any number of contexts in which to
/// request and render groups of data rows. However, it’s important that the
/// same context which was used to request sizes for a given `gtk.TreeModel`
/// row also be used for the same row when calling other `gtk.CellArea` APIs
/// such as `gtk.CellArea.render` and `gtk.CellArea.event`.
pub const CellAreaContext = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.CellAreaContextClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.CellAreaContextPrivate,

    pub const virtual_methods = struct {
        /// Allocates a width and/or a height for all rows which are to be
        /// rendered with `context`.
        ///
        /// Usually allocation is performed only horizontally or sometimes
        /// vertically since a group of rows are usually rendered side by
        /// side vertically or horizontally and share either the same width
        /// or the same height. Sometimes they are allocated in both horizontal
        /// and vertical orientations producing a homogeneous effect of the
        /// rows. This is generally the case for `gtk.TreeView` when
        /// `gtk.TreeView.properties.fixed`-height-mode is enabled.
        ///
        /// Since 3.0
        pub const allocate = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_width: c_int, p_height: c_int) void {
                return gobject.ext.as(CellAreaContext.Class, p_class).f_allocate.?(gobject.ext.as(CellAreaContext, p_context), p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_width: c_int, p_height: c_int) callconv(.c) void) void {
                gobject.ext.as(CellAreaContext.Class, p_class).f_allocate = @ptrCast(p_implementation);
            }
        };

        /// Gets the accumulative preferred height for `width` for all rows
        /// which have been requested for the same said `width` with this context.
        ///
        /// After `gtk.CellAreaContext.reset` is called and/or before ever
        /// requesting the size of a `gtk.CellArea`, the returned values are -1.
        pub const get_preferred_height_for_width = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) void {
                return gobject.ext.as(CellAreaContext.Class, p_class).f_get_preferred_height_for_width.?(gobject.ext.as(CellAreaContext, p_context), p_width, p_minimum_height, p_natural_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(CellAreaContext.Class, p_class).f_get_preferred_height_for_width = @ptrCast(p_implementation);
            }
        };

        /// Gets the accumulative preferred width for `height` for all rows which
        /// have been requested for the same said `height` with this context.
        ///
        /// After `gtk.CellAreaContext.reset` is called and/or before ever
        /// requesting the size of a `gtk.CellArea`, the returned values are -1.
        pub const get_preferred_width_for_height = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) void {
                return gobject.ext.as(CellAreaContext.Class, p_class).f_get_preferred_width_for_height.?(gobject.ext.as(CellAreaContext, p_context), p_height, p_minimum_width, p_natural_width);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(CellAreaContext.Class, p_class).f_get_preferred_width_for_height = @ptrCast(p_implementation);
            }
        };

        /// Resets any previously cached request and allocation
        /// data.
        ///
        /// When underlying `gtk.TreeModel` data changes its
        /// important to reset the context if the content
        /// size is allowed to shrink. If the content size
        /// is only allowed to grow (this is usually an option
        /// for views rendering large data stores as a measure
        /// of optimization), then only the row that changed
        /// or was inserted needs to be (re)requested with
        /// `gtk.CellArea.getPreferredWidth`.
        ///
        /// When the new overall size of the context requires
        /// that the allocated size changes (or whenever this
        /// allocation changes at all), the variable row
        /// sizes need to be re-requested for every row.
        ///
        /// For instance, if the rows are displayed all with
        /// the same width from top to bottom then a change
        /// in the allocated width necessitates a recalculation
        /// of all the displayed row heights using
        /// `gtk.CellArea.getPreferredHeightForWidth`.
        ///
        /// Since 3.0
        pub const reset = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(CellAreaContext.Class, p_class).f_reset.?(gobject.ext.as(CellAreaContext, p_context));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(CellAreaContext.Class, p_class).f_reset = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The `gtk.CellArea` this context was created by
        pub const area = struct {
            pub const name = "area";

            pub const Type = ?*gtk.CellArea;
        };

        /// The minimum height for the `gtk.CellArea` in this context
        /// for all `gtk.TreeModel` rows that this context was requested
        /// for using `gtk.CellArea.getPreferredHeight`.
        pub const minimum_height = struct {
            pub const name = "minimum-height";

            pub const Type = c_int;
        };

        /// The minimum width for the `gtk.CellArea` in this context
        /// for all `gtk.TreeModel` rows that this context was requested
        /// for using `gtk.CellArea.getPreferredWidth`.
        pub const minimum_width = struct {
            pub const name = "minimum-width";

            pub const Type = c_int;
        };

        /// The natural height for the `gtk.CellArea` in this context
        /// for all `gtk.TreeModel` rows that this context was requested
        /// for using `gtk.CellArea.getPreferredHeight`.
        pub const natural_height = struct {
            pub const name = "natural-height";

            pub const Type = c_int;
        };

        /// The natural width for the `gtk.CellArea` in this context
        /// for all `gtk.TreeModel` rows that this context was requested
        /// for using `gtk.CellArea.getPreferredWidth`.
        pub const natural_width = struct {
            pub const name = "natural-width";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Allocates a width and/or a height for all rows which are to be
    /// rendered with `context`.
    ///
    /// Usually allocation is performed only horizontally or sometimes
    /// vertically since a group of rows are usually rendered side by
    /// side vertically or horizontally and share either the same width
    /// or the same height. Sometimes they are allocated in both horizontal
    /// and vertical orientations producing a homogeneous effect of the
    /// rows. This is generally the case for `gtk.TreeView` when
    /// `gtk.TreeView.properties.fixed`-height-mode is enabled.
    ///
    /// Since 3.0
    extern fn gtk_cell_area_context_allocate(p_context: *CellAreaContext, p_width: c_int, p_height: c_int) void;
    pub const allocate = gtk_cell_area_context_allocate;

    /// Fetches the current allocation size for `context`.
    ///
    /// If the context was not allocated in width or height, or if the
    /// context was recently reset with `gtk.CellAreaContext.reset`,
    /// the returned value will be -1.
    extern fn gtk_cell_area_context_get_allocation(p_context: *CellAreaContext, p_width: ?*c_int, p_height: ?*c_int) void;
    pub const getAllocation = gtk_cell_area_context_get_allocation;

    /// Fetches the `gtk.CellArea` this `context` was created by.
    ///
    /// This is generally unneeded by layouting widgets; however,
    /// it is important for the context implementation itself to
    /// fetch information about the area it is being used for.
    ///
    /// For instance at `gtk.CellAreaContextClass.virtual_methods.allocate` time
    /// it’s important to know details about any cell spacing
    /// that the `gtk.CellArea` is configured with in order to
    /// compute a proper allocation.
    extern fn gtk_cell_area_context_get_area(p_context: *CellAreaContext) *gtk.CellArea;
    pub const getArea = gtk_cell_area_context_get_area;

    /// Gets the accumulative preferred height for all rows which have been
    /// requested with this context.
    ///
    /// After `gtk.CellAreaContext.reset` is called and/or before ever
    /// requesting the size of a `gtk.CellArea`, the returned values are 0.
    extern fn gtk_cell_area_context_get_preferred_height(p_context: *CellAreaContext, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) void;
    pub const getPreferredHeight = gtk_cell_area_context_get_preferred_height;

    /// Gets the accumulative preferred height for `width` for all rows
    /// which have been requested for the same said `width` with this context.
    ///
    /// After `gtk.CellAreaContext.reset` is called and/or before ever
    /// requesting the size of a `gtk.CellArea`, the returned values are -1.
    extern fn gtk_cell_area_context_get_preferred_height_for_width(p_context: *CellAreaContext, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) void;
    pub const getPreferredHeightForWidth = gtk_cell_area_context_get_preferred_height_for_width;

    /// Gets the accumulative preferred width for all rows which have been
    /// requested with this context.
    ///
    /// After `gtk.CellAreaContext.reset` is called and/or before ever
    /// requesting the size of a `gtk.CellArea`, the returned values are 0.
    extern fn gtk_cell_area_context_get_preferred_width(p_context: *CellAreaContext, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) void;
    pub const getPreferredWidth = gtk_cell_area_context_get_preferred_width;

    /// Gets the accumulative preferred width for `height` for all rows which
    /// have been requested for the same said `height` with this context.
    ///
    /// After `gtk.CellAreaContext.reset` is called and/or before ever
    /// requesting the size of a `gtk.CellArea`, the returned values are -1.
    extern fn gtk_cell_area_context_get_preferred_width_for_height(p_context: *CellAreaContext, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) void;
    pub const getPreferredWidthForHeight = gtk_cell_area_context_get_preferred_width_for_height;

    /// Causes the minimum and/or natural height to grow if the new
    /// proposed sizes exceed the current minimum and natural height.
    ///
    /// This is used by `gtk.CellAreaContext` implementations during
    /// the request process over a series of `gtk.TreeModel` rows to
    /// progressively push the requested height over a series of
    /// `gtk.CellArea.getPreferredHeight` requests.
    extern fn gtk_cell_area_context_push_preferred_height(p_context: *CellAreaContext, p_minimum_height: c_int, p_natural_height: c_int) void;
    pub const pushPreferredHeight = gtk_cell_area_context_push_preferred_height;

    /// Causes the minimum and/or natural width to grow if the new
    /// proposed sizes exceed the current minimum and natural width.
    ///
    /// This is used by `gtk.CellAreaContext` implementations during
    /// the request process over a series of `gtk.TreeModel` rows to
    /// progressively push the requested width over a series of
    /// `gtk.CellArea.getPreferredWidth` requests.
    extern fn gtk_cell_area_context_push_preferred_width(p_context: *CellAreaContext, p_minimum_width: c_int, p_natural_width: c_int) void;
    pub const pushPreferredWidth = gtk_cell_area_context_push_preferred_width;

    /// Resets any previously cached request and allocation
    /// data.
    ///
    /// When underlying `gtk.TreeModel` data changes its
    /// important to reset the context if the content
    /// size is allowed to shrink. If the content size
    /// is only allowed to grow (this is usually an option
    /// for views rendering large data stores as a measure
    /// of optimization), then only the row that changed
    /// or was inserted needs to be (re)requested with
    /// `gtk.CellArea.getPreferredWidth`.
    ///
    /// When the new overall size of the context requires
    /// that the allocated size changes (or whenever this
    /// allocation changes at all), the variable row
    /// sizes need to be re-requested for every row.
    ///
    /// For instance, if the rows are displayed all with
    /// the same width from top to bottom then a change
    /// in the allocated width necessitates a recalculation
    /// of all the displayed row heights using
    /// `gtk.CellArea.getPreferredHeightForWidth`.
    ///
    /// Since 3.0
    extern fn gtk_cell_area_context_reset(p_context: *CellAreaContext) void;
    pub const reset = gtk_cell_area_context_reset;

    extern fn gtk_cell_area_context_get_type() usize;
    pub const getGObjectType = gtk_cell_area_context_get_type;

    extern fn g_object_ref(p_self: *gtk.CellAreaContext) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellAreaContext) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellAreaContext, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.CellRenderer` is a base class of a set of objects used for
/// rendering a cell to a `cairo.Context`.  These objects are used primarily by
/// the `gtk.TreeView` widget, though they aren’t tied to them in any
/// specific way.  It is worth noting that `gtk.CellRenderer` is not a
/// `gtk.Widget` and cannot be treated as such.
///
/// The primary use of a `gtk.CellRenderer` is for drawing a certain graphical
/// elements on a `cairo.Context`. Typically, one cell renderer is used to
/// draw many cells on the screen.  To this extent, it isn’t expected that a
/// CellRenderer keep any permanent state around.  Instead, any state is set
/// just prior to use using `GObjects` property system.  Then, the
/// cell is measured using `gtk.CellRenderer.getSize`. Finally, the cell
/// is rendered in the correct location using `gtk.CellRenderer.render`.
///
/// There are a number of rules that must be followed when writing a new
/// `gtk.CellRenderer`.  First and foremost, it’s important that a certain set
/// of properties will always yield a cell renderer of the same size,
/// barring a `gtk.Style` change.  The `gtk.CellRenderer` also has a number of
/// generic properties that are expected to be honored by all children.
///
/// Beyond merely rendering a cell, cell renderers can optionally
/// provide active user interface elements. A cell renderer can be
/// “activatable” like `gtk.CellRendererToggle`,
/// which toggles when it gets activated by a mouse click, or it can be
/// “editable” like `gtk.CellRendererText`, which
/// allows the user to edit the text using a widget implementing the
/// `gtk.CellEditable` interface, e.g. `gtk.Entry`.
/// To make a cell renderer activatable or editable, you have to
/// implement the `gtk.CellRendererClass.activate` or
/// `gtk.CellRendererClass.start_editing` virtual functions, respectively.
///
/// Many properties of `gtk.CellRenderer` and its subclasses have a
/// corresponding “set” property, e.g. “cell-background-set” corresponds
/// to “cell-background”. These “set” properties reflect whether a property
/// has been set or not. You should not set them independently.
pub const CellRenderer = extern struct {
    pub const Parent = gobject.InitiallyUnowned;
    pub const Implements = [_]type{};
    pub const Class = gtk.CellRendererClass;
    f_parent_instance: gobject.InitiallyUnowned,
    f_priv: ?*gtk.CellRendererPrivate,

    pub const virtual_methods = struct {
        /// Passes an activate event to the cell renderer for possible processing.
        /// Some cell renderers may use events; for example, `gtk.CellRendererToggle`
        /// toggles when it gets a mouse click.
        pub const activate = struct {
            pub fn call(p_class: anytype, p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.Event, p_widget: *gtk.Widget, p_path: [*:0]const u8, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) c_int {
                return gobject.ext.as(CellRenderer.Class, p_class).f_activate.?(gobject.ext.as(CellRenderer, p_cell), p_event, p_widget, p_path, p_background_area, p_cell_area, p_flags);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.Event, p_widget: *gtk.Widget, p_path: [*:0]const u8, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) callconv(.c) c_int) void {
                gobject.ext.as(CellRenderer.Class, p_class).f_activate = @ptrCast(p_implementation);
            }
        };

        /// Signal gets emitted when the user cancels the process of editing a cell.
        pub const editing_canceled = struct {
            pub fn call(p_class: anytype, p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(CellRenderer.Class, p_class).f_editing_canceled.?(gobject.ext.as(CellRenderer, p_cell));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(CellRenderer.Class, p_class).f_editing_canceled = @ptrCast(p_implementation);
            }
        };

        /// Signal gets emitted when a cell starts to be edited.
        pub const editing_started = struct {
            pub fn call(p_class: anytype, p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_editable: *gtk.CellEditable, p_path: [*:0]const u8) void {
                return gobject.ext.as(CellRenderer.Class, p_class).f_editing_started.?(gobject.ext.as(CellRenderer, p_cell), p_editable, p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_editable: *gtk.CellEditable, p_path: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(CellRenderer.Class, p_class).f_editing_started = @ptrCast(p_implementation);
            }
        };

        /// Gets the aligned area used by `cell` inside `cell_area`. Used for finding
        /// the appropriate edit and focus rectangle.
        pub const get_aligned_area = struct {
            pub fn call(p_class: anytype, p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_flags: gtk.CellRendererState, p_cell_area: *const gdk.Rectangle, p_aligned_area: *gdk.Rectangle) void {
                return gobject.ext.as(CellRenderer.Class, p_class).f_get_aligned_area.?(gobject.ext.as(CellRenderer, p_cell), p_widget, p_flags, p_cell_area, p_aligned_area);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_flags: gtk.CellRendererState, p_cell_area: *const gdk.Rectangle, p_aligned_area: *gdk.Rectangle) callconv(.c) void) void {
                gobject.ext.as(CellRenderer.Class, p_class).f_get_aligned_area = @ptrCast(p_implementation);
            }
        };

        /// Retreives a renderer’s natural size when rendered to `widget`.
        pub const get_preferred_height = struct {
            pub fn call(p_class: anytype, p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_minimum_size: ?*c_int, p_natural_size: ?*c_int) void {
                return gobject.ext.as(CellRenderer.Class, p_class).f_get_preferred_height.?(gobject.ext.as(CellRenderer, p_cell), p_widget, p_minimum_size, p_natural_size);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_minimum_size: ?*c_int, p_natural_size: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(CellRenderer.Class, p_class).f_get_preferred_height = @ptrCast(p_implementation);
            }
        };

        /// Retreives a cell renderers’s minimum and natural height if it were rendered to
        /// `widget` with the specified `width`.
        pub const get_preferred_height_for_width = struct {
            pub fn call(p_class: anytype, p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) void {
                return gobject.ext.as(CellRenderer.Class, p_class).f_get_preferred_height_for_width.?(gobject.ext.as(CellRenderer, p_cell), p_widget, p_width, p_minimum_height, p_natural_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(CellRenderer.Class, p_class).f_get_preferred_height_for_width = @ptrCast(p_implementation);
            }
        };

        /// Retreives a renderer’s natural size when rendered to `widget`.
        pub const get_preferred_width = struct {
            pub fn call(p_class: anytype, p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_minimum_size: ?*c_int, p_natural_size: ?*c_int) void {
                return gobject.ext.as(CellRenderer.Class, p_class).f_get_preferred_width.?(gobject.ext.as(CellRenderer, p_cell), p_widget, p_minimum_size, p_natural_size);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_minimum_size: ?*c_int, p_natural_size: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(CellRenderer.Class, p_class).f_get_preferred_width = @ptrCast(p_implementation);
            }
        };

        /// Retreives a cell renderers’s minimum and natural width if it were rendered to
        /// `widget` with the specified `height`.
        pub const get_preferred_width_for_height = struct {
            pub fn call(p_class: anytype, p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) void {
                return gobject.ext.as(CellRenderer.Class, p_class).f_get_preferred_width_for_height.?(gobject.ext.as(CellRenderer, p_cell), p_widget, p_height, p_minimum_width, p_natural_width);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(CellRenderer.Class, p_class).f_get_preferred_width_for_height = @ptrCast(p_implementation);
            }
        };

        /// Gets whether the cell renderer prefers a height-for-width layout
        /// or a width-for-height layout.
        pub const get_request_mode = struct {
            pub fn call(p_class: anytype, p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) gtk.SizeRequestMode {
                return gobject.ext.as(CellRenderer.Class, p_class).f_get_request_mode.?(gobject.ext.as(CellRenderer, p_cell));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) gtk.SizeRequestMode) void {
                gobject.ext.as(CellRenderer.Class, p_class).f_get_request_mode = @ptrCast(p_implementation);
            }
        };

        /// Obtains the width and height needed to render the cell. Used by view
        /// widgets to determine the appropriate size for the cell_area passed to
        /// `gtk.CellRenderer.render`.  If `cell_area` is not `NULL`, fills in the
        /// x and y offsets (if set) of the cell relative to this location.
        ///
        /// Please note that the values set in `width` and `height`, as well as those
        /// in `x_offset` and `y_offset` are inclusive of the xpad and ypad properties.
        pub const get_size = struct {
            pub fn call(p_class: anytype, p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_cell_area: ?*const gdk.Rectangle, p_x_offset: ?*c_int, p_y_offset: ?*c_int, p_width: ?*c_int, p_height: ?*c_int) void {
                return gobject.ext.as(CellRenderer.Class, p_class).f_get_size.?(gobject.ext.as(CellRenderer, p_cell), p_widget, p_cell_area, p_x_offset, p_y_offset, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_cell_area: ?*const gdk.Rectangle, p_x_offset: ?*c_int, p_y_offset: ?*c_int, p_width: ?*c_int, p_height: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(CellRenderer.Class, p_class).f_get_size = @ptrCast(p_implementation);
            }
        };

        /// Invokes the virtual render function of the `gtk.CellRenderer`. The three
        /// passed-in rectangles are areas in `cr`. Most renderers will draw within
        /// `cell_area`; the xalign, yalign, xpad, and ypad fields of the `gtk.CellRenderer`
        /// should be honored with respect to `cell_area`. `background_area` includes the
        /// blank space around the cell, and also the area containing the tree expander;
        /// so the `background_area` rectangles for all cells tile to cover the entire
        /// `window`.
        pub const render = struct {
            pub fn call(p_class: anytype, p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_widget: *gtk.Widget, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) void {
                return gobject.ext.as(CellRenderer.Class, p_class).f_render.?(gobject.ext.as(CellRenderer, p_cell), p_cr, p_widget, p_background_area, p_cell_area, p_flags);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_widget: *gtk.Widget, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) callconv(.c) void) void {
                gobject.ext.as(CellRenderer.Class, p_class).f_render = @ptrCast(p_implementation);
            }
        };

        /// Starts editing the contents of this `cell`, through a new `gtk.CellEditable`
        /// widget created by the `gtk.CellRendererClass.start_editing` virtual function.
        pub const start_editing = struct {
            pub fn call(p_class: anytype, p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: ?*gdk.Event, p_widget: *gtk.Widget, p_path: [*:0]const u8, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) ?*gtk.CellEditable {
                return gobject.ext.as(CellRenderer.Class, p_class).f_start_editing.?(gobject.ext.as(CellRenderer, p_cell), p_event, p_widget, p_path, p_background_area, p_cell_area, p_flags);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: ?*gdk.Event, p_widget: *gtk.Widget, p_path: [*:0]const u8, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) callconv(.c) ?*gtk.CellEditable) void {
                gobject.ext.as(CellRenderer.Class, p_class).f_start_editing = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const cell_background = struct {
            pub const name = "cell-background";

            pub const Type = ?[*:0]u8;
        };

        /// Cell background as a `gdk.Color`
        pub const cell_background_gdk = struct {
            pub const name = "cell-background-gdk";

            pub const Type = ?*gdk.Color;
        };

        /// Cell background as a `gdk.RGBA`
        pub const cell_background_rgba = struct {
            pub const name = "cell-background-rgba";

            pub const Type = ?*gdk.RGBA;
        };

        pub const cell_background_set = struct {
            pub const name = "cell-background-set";

            pub const Type = c_int;
        };

        pub const editing = struct {
            pub const name = "editing";

            pub const Type = c_int;
        };

        pub const height = struct {
            pub const name = "height";

            pub const Type = c_int;
        };

        pub const is_expanded = struct {
            pub const name = "is-expanded";

            pub const Type = c_int;
        };

        pub const is_expander = struct {
            pub const name = "is-expander";

            pub const Type = c_int;
        };

        pub const mode = struct {
            pub const name = "mode";

            pub const Type = gtk.CellRendererMode;
        };

        pub const sensitive = struct {
            pub const name = "sensitive";

            pub const Type = c_int;
        };

        pub const visible = struct {
            pub const name = "visible";

            pub const Type = c_int;
        };

        pub const width = struct {
            pub const name = "width";

            pub const Type = c_int;
        };

        pub const xalign = struct {
            pub const name = "xalign";

            pub const Type = f32;
        };

        pub const xpad = struct {
            pub const name = "xpad";

            pub const Type = c_uint;
        };

        pub const yalign = struct {
            pub const name = "yalign";

            pub const Type = f32;
        };

        pub const ypad = struct {
            pub const name = "ypad";

            pub const Type = c_uint;
        };
    };

    pub const signals = struct {
        /// This signal gets emitted when the user cancels the process of editing a
        /// cell.  For example, an editable cell renderer could be written to cancel
        /// editing when the user presses Escape.
        ///
        /// See also: `gtk.CellRenderer.stopEditing`.
        pub const editing_canceled = struct {
            pub const name = "editing-canceled";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(CellRenderer, p_instance))),
                    gobject.signalLookup("editing-canceled", CellRenderer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal gets emitted when a cell starts to be edited.
        /// The intended use of this signal is to do special setup
        /// on `editable`, e.g. adding a `gtk.EntryCompletion` or setting
        /// up additional columns in a `gtk.ComboBox`.
        ///
        /// See `gtk.CellEditable.startEditing` for information on the lifecycle of
        /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
        ///
        /// Note that GTK+ doesn't guarantee that cell renderers will
        /// continue to use the same kind of widget for editing in future
        /// releases, therefore you should check the type of `editable`
        /// before doing any specific setup, as in the following example:
        /// ```
        /// static void
        /// text_editing_started (GtkCellRenderer *cell,
        ///                       GtkCellEditable *editable,
        ///                       const gchar     *path,
        ///                       gpointer         data)
        /// {
        ///   if (GTK_IS_ENTRY (editable))
        ///     {
        ///       GtkEntry *entry = GTK_ENTRY (editable);
        ///
        ///       // ... create a GtkEntryCompletion
        ///
        ///       gtk_entry_set_completion (entry, completion);
        ///     }
        /// }
        /// ```
        pub const editing_started = struct {
            pub const name = "editing-started";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_editable: *gtk.CellEditable, p_path: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(CellRenderer, p_instance))),
                    gobject.signalLookup("editing-started", CellRenderer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Passes an activate event to the cell renderer for possible processing.
    /// Some cell renderers may use events; for example, `gtk.CellRendererToggle`
    /// toggles when it gets a mouse click.
    extern fn gtk_cell_renderer_activate(p_cell: *CellRenderer, p_event: *gdk.Event, p_widget: *gtk.Widget, p_path: [*:0]const u8, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) c_int;
    pub const activate = gtk_cell_renderer_activate;

    /// Gets the aligned area used by `cell` inside `cell_area`. Used for finding
    /// the appropriate edit and focus rectangle.
    extern fn gtk_cell_renderer_get_aligned_area(p_cell: *CellRenderer, p_widget: *gtk.Widget, p_flags: gtk.CellRendererState, p_cell_area: *const gdk.Rectangle, p_aligned_area: *gdk.Rectangle) void;
    pub const getAlignedArea = gtk_cell_renderer_get_aligned_area;

    /// Fills in `xalign` and `yalign` with the appropriate values of `cell`.
    extern fn gtk_cell_renderer_get_alignment(p_cell: *CellRenderer, p_xalign: ?*f32, p_yalign: ?*f32) void;
    pub const getAlignment = gtk_cell_renderer_get_alignment;

    /// Fills in `width` and `height` with the appropriate size of `cell`.
    extern fn gtk_cell_renderer_get_fixed_size(p_cell: *CellRenderer, p_width: ?*c_int, p_height: ?*c_int) void;
    pub const getFixedSize = gtk_cell_renderer_get_fixed_size;

    /// Fills in `xpad` and `ypad` with the appropriate values of `cell`.
    extern fn gtk_cell_renderer_get_padding(p_cell: *CellRenderer, p_xpad: ?*c_int, p_ypad: ?*c_int) void;
    pub const getPadding = gtk_cell_renderer_get_padding;

    /// Retreives a renderer’s natural size when rendered to `widget`.
    extern fn gtk_cell_renderer_get_preferred_height(p_cell: *CellRenderer, p_widget: *gtk.Widget, p_minimum_size: ?*c_int, p_natural_size: ?*c_int) void;
    pub const getPreferredHeight = gtk_cell_renderer_get_preferred_height;

    /// Retreives a cell renderers’s minimum and natural height if it were rendered to
    /// `widget` with the specified `width`.
    extern fn gtk_cell_renderer_get_preferred_height_for_width(p_cell: *CellRenderer, p_widget: *gtk.Widget, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) void;
    pub const getPreferredHeightForWidth = gtk_cell_renderer_get_preferred_height_for_width;

    /// Retrieves the minimum and natural size of a cell taking
    /// into account the widget’s preference for height-for-width management.
    extern fn gtk_cell_renderer_get_preferred_size(p_cell: *CellRenderer, p_widget: *gtk.Widget, p_minimum_size: ?*gtk.Requisition, p_natural_size: ?*gtk.Requisition) void;
    pub const getPreferredSize = gtk_cell_renderer_get_preferred_size;

    /// Retreives a renderer’s natural size when rendered to `widget`.
    extern fn gtk_cell_renderer_get_preferred_width(p_cell: *CellRenderer, p_widget: *gtk.Widget, p_minimum_size: ?*c_int, p_natural_size: ?*c_int) void;
    pub const getPreferredWidth = gtk_cell_renderer_get_preferred_width;

    /// Retreives a cell renderers’s minimum and natural width if it were rendered to
    /// `widget` with the specified `height`.
    extern fn gtk_cell_renderer_get_preferred_width_for_height(p_cell: *CellRenderer, p_widget: *gtk.Widget, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) void;
    pub const getPreferredWidthForHeight = gtk_cell_renderer_get_preferred_width_for_height;

    /// Gets whether the cell renderer prefers a height-for-width layout
    /// or a width-for-height layout.
    extern fn gtk_cell_renderer_get_request_mode(p_cell: *CellRenderer) gtk.SizeRequestMode;
    pub const getRequestMode = gtk_cell_renderer_get_request_mode;

    /// Returns the cell renderer’s sensitivity.
    extern fn gtk_cell_renderer_get_sensitive(p_cell: *CellRenderer) c_int;
    pub const getSensitive = gtk_cell_renderer_get_sensitive;

    /// Obtains the width and height needed to render the cell. Used by view
    /// widgets to determine the appropriate size for the cell_area passed to
    /// `gtk.CellRenderer.render`.  If `cell_area` is not `NULL`, fills in the
    /// x and y offsets (if set) of the cell relative to this location.
    ///
    /// Please note that the values set in `width` and `height`, as well as those
    /// in `x_offset` and `y_offset` are inclusive of the xpad and ypad properties.
    extern fn gtk_cell_renderer_get_size(p_cell: *CellRenderer, p_widget: *gtk.Widget, p_cell_area: ?*const gdk.Rectangle, p_x_offset: ?*c_int, p_y_offset: ?*c_int, p_width: ?*c_int, p_height: ?*c_int) void;
    pub const getSize = gtk_cell_renderer_get_size;

    /// Translates the cell renderer state to `gtk.StateFlags`,
    /// based on the cell renderer and widget sensitivity, and
    /// the given `gtk.CellRendererState`.
    extern fn gtk_cell_renderer_get_state(p_cell: ?*CellRenderer, p_widget: ?*gtk.Widget, p_cell_state: gtk.CellRendererState) gtk.StateFlags;
    pub const getState = gtk_cell_renderer_get_state;

    /// Returns the cell renderer’s visibility.
    extern fn gtk_cell_renderer_get_visible(p_cell: *CellRenderer) c_int;
    pub const getVisible = gtk_cell_renderer_get_visible;

    /// Checks whether the cell renderer can do something when activated.
    extern fn gtk_cell_renderer_is_activatable(p_cell: *CellRenderer) c_int;
    pub const isActivatable = gtk_cell_renderer_is_activatable;

    /// Invokes the virtual render function of the `gtk.CellRenderer`. The three
    /// passed-in rectangles are areas in `cr`. Most renderers will draw within
    /// `cell_area`; the xalign, yalign, xpad, and ypad fields of the `gtk.CellRenderer`
    /// should be honored with respect to `cell_area`. `background_area` includes the
    /// blank space around the cell, and also the area containing the tree expander;
    /// so the `background_area` rectangles for all cells tile to cover the entire
    /// `window`.
    extern fn gtk_cell_renderer_render(p_cell: *CellRenderer, p_cr: *cairo.Context, p_widget: *gtk.Widget, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) void;
    pub const render = gtk_cell_renderer_render;

    /// Sets the renderer’s alignment within its available space.
    extern fn gtk_cell_renderer_set_alignment(p_cell: *CellRenderer, p_xalign: f32, p_yalign: f32) void;
    pub const setAlignment = gtk_cell_renderer_set_alignment;

    /// Sets the renderer size to be explicit, independent of the properties set.
    extern fn gtk_cell_renderer_set_fixed_size(p_cell: *CellRenderer, p_width: c_int, p_height: c_int) void;
    pub const setFixedSize = gtk_cell_renderer_set_fixed_size;

    /// Sets the renderer’s padding.
    extern fn gtk_cell_renderer_set_padding(p_cell: *CellRenderer, p_xpad: c_int, p_ypad: c_int) void;
    pub const setPadding = gtk_cell_renderer_set_padding;

    /// Sets the cell renderer’s sensitivity.
    extern fn gtk_cell_renderer_set_sensitive(p_cell: *CellRenderer, p_sensitive: c_int) void;
    pub const setSensitive = gtk_cell_renderer_set_sensitive;

    /// Sets the cell renderer’s visibility.
    extern fn gtk_cell_renderer_set_visible(p_cell: *CellRenderer, p_visible: c_int) void;
    pub const setVisible = gtk_cell_renderer_set_visible;

    /// Starts editing the contents of this `cell`, through a new `gtk.CellEditable`
    /// widget created by the `gtk.CellRendererClass.start_editing` virtual function.
    extern fn gtk_cell_renderer_start_editing(p_cell: *CellRenderer, p_event: ?*gdk.Event, p_widget: *gtk.Widget, p_path: [*:0]const u8, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) ?*gtk.CellEditable;
    pub const startEditing = gtk_cell_renderer_start_editing;

    /// Informs the cell renderer that the editing is stopped.
    /// If `canceled` is `TRUE`, the cell renderer will emit the
    /// `gtk.CellRenderer.signals.editing`-canceled signal.
    ///
    /// This function should be called by cell renderer implementations
    /// in response to the `gtk.CellEditable.signals.editing`-done signal of
    /// `gtk.CellEditable`.
    extern fn gtk_cell_renderer_stop_editing(p_cell: *CellRenderer, p_canceled: c_int) void;
    pub const stopEditing = gtk_cell_renderer_stop_editing;

    extern fn gtk_cell_renderer_get_type() usize;
    pub const getGObjectType = gtk_cell_renderer_get_type;

    extern fn g_object_ref(p_self: *gtk.CellRenderer) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellRenderer) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellRenderer, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.CellRendererAccel` displays a keyboard accelerator (i.e. a key
/// combination like `Control + a`). If the cell renderer is editable,
/// the accelerator can be changed by simply typing the new combination.
///
/// The `gtk.CellRendererAccel` cell renderer was added in GTK+ 2.10.
pub const CellRendererAccel = extern struct {
    pub const Parent = gtk.CellRendererText;
    pub const Implements = [_]type{};
    pub const Class = gtk.CellRendererAccelClass;
    f_parent: gtk.CellRendererText,
    f_priv: ?*gtk.CellRendererAccelPrivate,

    pub const virtual_methods = struct {
        pub const accel_cleared = struct {
            pub fn call(p_class: anytype, p_accel: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path_string: [*:0]const u8) void {
                return gobject.ext.as(CellRendererAccel.Class, p_class).f_accel_cleared.?(gobject.ext.as(CellRendererAccel, p_accel), p_path_string);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_accel: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path_string: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(CellRendererAccel.Class, p_class).f_accel_cleared = @ptrCast(p_implementation);
            }
        };

        pub const accel_edited = struct {
            pub fn call(p_class: anytype, p_accel: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path_string: [*:0]const u8, p_accel_key: c_uint, p_accel_mods: gdk.ModifierType, p_hardware_keycode: c_uint) void {
                return gobject.ext.as(CellRendererAccel.Class, p_class).f_accel_edited.?(gobject.ext.as(CellRendererAccel, p_accel), p_path_string, p_accel_key, p_accel_mods, p_hardware_keycode);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_accel: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path_string: [*:0]const u8, p_accel_key: c_uint, p_accel_mods: gdk.ModifierType, p_hardware_keycode: c_uint) callconv(.c) void) void {
                gobject.ext.as(CellRendererAccel.Class, p_class).f_accel_edited = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The keyval of the accelerator.
        pub const accel_key = struct {
            pub const name = "accel-key";

            pub const Type = c_uint;
        };

        /// Determines if the edited accelerators are GTK+ accelerators. If
        /// they are, consumed modifiers are suppressed, only accelerators
        /// accepted by GTK+ are allowed, and the accelerators are rendered
        /// in the same way as they are in menus.
        pub const accel_mode = struct {
            pub const name = "accel-mode";

            pub const Type = gtk.CellRendererAccelMode;
        };

        /// The modifier mask of the accelerator.
        pub const accel_mods = struct {
            pub const name = "accel-mods";

            pub const Type = gdk.ModifierType;
        };

        /// The hardware keycode of the accelerator. Note that the hardware keycode is
        /// only relevant if the key does not have a keyval. Normally, the keyboard
        /// configuration should assign keyvals to all keys.
        pub const keycode = struct {
            pub const name = "keycode";

            pub const Type = c_uint;
        };
    };

    pub const signals = struct {
        /// Gets emitted when the user has removed the accelerator.
        pub const accel_cleared = struct {
            pub const name = "accel-cleared";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_path_string: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(CellRendererAccel, p_instance))),
                    gobject.signalLookup("accel-cleared", CellRendererAccel.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Gets emitted when the user has selected a new accelerator.
        pub const accel_edited = struct {
            pub const name = "accel-edited";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_path_string: [*:0]u8, p_accel_key: c_uint, p_accel_mods: gdk.ModifierType, p_hardware_keycode: c_uint, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(CellRendererAccel, p_instance))),
                    gobject.signalLookup("accel-edited", CellRendererAccel.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.CellRendererAccel`.
    extern fn gtk_cell_renderer_accel_new() *gtk.CellRendererAccel;
    pub const new = gtk_cell_renderer_accel_new;

    extern fn gtk_cell_renderer_accel_get_type() usize;
    pub const getGObjectType = gtk_cell_renderer_accel_get_type;

    extern fn g_object_ref(p_self: *gtk.CellRendererAccel) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellRendererAccel) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellRendererAccel, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.CellRendererCombo` renders text in a cell like `gtk.CellRendererText` from
/// which it is derived. But while `gtk.CellRendererText` offers a simple entry to
/// edit the text, `gtk.CellRendererCombo` offers a `gtk.ComboBox`
/// widget to edit the text. The values to display in the combo box are taken from
/// the tree model specified in the `gtk.CellRendererCombo.properties.model` property.
///
/// The combo cell renderer takes care of adding a text cell renderer to the combo
/// box and sets it to display the column specified by its
/// `gtk.CellRendererCombo.properties.text`-column property. Further properties of the combo box
/// can be set in a handler for the `gtk.CellRenderer.signals.editing`-started signal.
///
/// The `gtk.CellRendererCombo` cell renderer was added in GTK+ 2.6.
pub const CellRendererCombo = extern struct {
    pub const Parent = gtk.CellRendererText;
    pub const Implements = [_]type{};
    pub const Class = gtk.CellRendererComboClass;
    f_parent: gtk.CellRendererText,
    f_priv: ?*gtk.CellRendererComboPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// If `TRUE`, the cell renderer will include an entry and allow to enter
        /// values other than the ones in the popup list.
        pub const has_entry = struct {
            pub const name = "has-entry";

            pub const Type = c_int;
        };

        /// Holds a tree model containing the possible values for the combo box.
        /// Use the text_column property to specify the column holding the values.
        pub const model = struct {
            pub const name = "model";

            pub const Type = ?*gtk.TreeModel;
        };

        /// Specifies the model column which holds the possible values for the
        /// combo box.
        ///
        /// Note that this refers to the model specified in the model property,
        /// not the model backing the tree view to which
        /// this cell renderer is attached.
        ///
        /// `gtk.CellRendererCombo` automatically adds a text cell renderer for
        /// this column to its combo box.
        pub const text_column = struct {
            pub const name = "text-column";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// This signal is emitted each time after the user selected an item in
        /// the combo box, either by using the mouse or the arrow keys.  Contrary
        /// to GtkComboBox, GtkCellRendererCombo::changed is not emitted for
        /// changes made to a selected item in the entry.  The argument `new_iter`
        /// corresponds to the newly selected item in the combo box and it is relative
        /// to the GtkTreeModel set via the model property on GtkCellRendererCombo.
        ///
        /// Note that as soon as you change the model displayed in the tree view,
        /// the tree view will immediately cease the editing operating.  This
        /// means that you most probably want to refrain from changing the model
        /// until the combo cell renderer emits the edited or editing_canceled signal.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_path_string: [*:0]u8, p_new_iter: *gtk.TreeIter, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(CellRendererCombo, p_instance))),
                    gobject.signalLookup("changed", CellRendererCombo.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.CellRendererCombo`.
    /// Adjust how text is drawn using object properties.
    /// Object properties can be set globally (with `gobject.Object.set`).
    /// Also, with `gtk.TreeViewColumn`, you can bind a property to a value
    /// in a `gtk.TreeModel`. For example, you can bind the “text” property
    /// on the cell renderer to a string value in the model, thus rendering
    /// a different string in each row of the `gtk.TreeView`.
    extern fn gtk_cell_renderer_combo_new() *gtk.CellRendererCombo;
    pub const new = gtk_cell_renderer_combo_new;

    extern fn gtk_cell_renderer_combo_get_type() usize;
    pub const getGObjectType = gtk_cell_renderer_combo_get_type;

    extern fn g_object_ref(p_self: *gtk.CellRendererCombo) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellRendererCombo) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellRendererCombo, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.CellRendererPixbuf` can be used to render an image in a cell. It allows
/// to render either a given `gdkpixbuf.Pixbuf` (set via the
/// `gtk.CellRendererPixbuf.properties.pixbuf` property) or a named icon (set via the
/// `gtk.CellRendererPixbuf.properties.icon`-name property).
///
/// To support the tree view, `gtk.CellRendererPixbuf` also supports rendering two
/// alternative pixbufs, when the `gtk.CellRenderer.properties.is`-expander property is `TRUE`.
/// If the `gtk.CellRenderer.properties.is`-expanded property is `TRUE` and the
/// `gtk.CellRendererPixbuf.properties.pixbuf`-expander-open property is set to a pixbuf, it
/// renders that pixbuf, if the `gtk.CellRenderer.properties.is`-expanded property is `FALSE`
/// and the `gtk.CellRendererPixbuf.properties.pixbuf`-expander-closed property is set to a
/// pixbuf, it renders that one.
pub const CellRendererPixbuf = extern struct {
    pub const Parent = gtk.CellRenderer;
    pub const Implements = [_]type{};
    pub const Class = gtk.CellRendererPixbufClass;
    f_parent: gtk.CellRenderer,
    f_priv: ?*gtk.CellRendererPixbufPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Specifies whether the rendered pixbuf should be colorized
        /// according to the `gtk.CellRendererState`.
        pub const follow_state = struct {
            pub const name = "follow-state";

            pub const Type = c_int;
        };

        /// The GIcon representing the icon to display.
        /// If the icon theme is changed, the image will be updated
        /// automatically.
        pub const gicon = struct {
            pub const name = "gicon";

            pub const Type = ?*gio.Icon;
        };

        /// The name of the themed icon to display.
        /// This property only has an effect if not overridden by "stock_id"
        /// or "pixbuf" properties.
        pub const icon_name = struct {
            pub const name = "icon-name";

            pub const Type = ?[*:0]u8;
        };

        pub const pixbuf = struct {
            pub const name = "pixbuf";

            pub const Type = ?*gdkpixbuf.Pixbuf;
        };

        pub const pixbuf_expander_closed = struct {
            pub const name = "pixbuf-expander-closed";

            pub const Type = ?*gdkpixbuf.Pixbuf;
        };

        pub const pixbuf_expander_open = struct {
            pub const name = "pixbuf-expander-open";

            pub const Type = ?*gdkpixbuf.Pixbuf;
        };

        pub const stock_detail = struct {
            pub const name = "stock-detail";

            pub const Type = ?[*:0]u8;
        };

        pub const stock_id = struct {
            pub const name = "stock-id";

            pub const Type = ?[*:0]u8;
        };

        /// The `gtk.IconSize` value that specifies the size of the rendered icon.
        pub const stock_size = struct {
            pub const name = "stock-size";

            pub const Type = c_uint;
        };

        pub const surface = struct {
            pub const name = "surface";

            pub const Type = ?*cairo.Surface;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.CellRendererPixbuf`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `gobject.Object.set`). Also, with `gtk.TreeViewColumn`, you
    /// can bind a property to a value in a `gtk.TreeModel`. For example, you
    /// can bind the “pixbuf” property on the cell renderer to a pixbuf value
    /// in the model, thus rendering a different image in each row of the
    /// `gtk.TreeView`.
    extern fn gtk_cell_renderer_pixbuf_new() *gtk.CellRendererPixbuf;
    pub const new = gtk_cell_renderer_pixbuf_new;

    extern fn gtk_cell_renderer_pixbuf_get_type() usize;
    pub const getGObjectType = gtk_cell_renderer_pixbuf_get_type;

    extern fn g_object_ref(p_self: *gtk.CellRendererPixbuf) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellRendererPixbuf) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellRendererPixbuf, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.CellRendererProgress` renders a numeric value as a progress par in a cell.
/// Additionally, it can display a text on top of the progress bar.
///
/// The `gtk.CellRendererProgress` cell renderer was added in GTK+ 2.6.
pub const CellRendererProgress = extern struct {
    pub const Parent = gtk.CellRenderer;
    pub const Implements = [_]type{gtk.Orientable};
    pub const Class = gtk.CellRendererProgressClass;
    f_parent_instance: gtk.CellRenderer,
    f_priv: ?*gtk.CellRendererProgressPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const inverted = struct {
            pub const name = "inverted";

            pub const Type = c_int;
        };

        /// Setting this to a non-negative value causes the cell renderer to
        /// enter "activity mode", where a block bounces back and forth to
        /// indicate that some progress is made, without specifying exactly how
        /// much.
        ///
        /// Each increment of the property causes the block to move by a little
        /// bit.
        ///
        /// To indicate that the activity has not started yet, set the property
        /// to zero. To indicate completion, set the property to `G_MAXINT`.
        pub const pulse = struct {
            pub const name = "pulse";

            pub const Type = c_int;
        };

        /// The "text" property determines the label which will be drawn
        /// over the progress bar. Setting this property to `NULL` causes the default
        /// label to be displayed. Setting this property to an empty string causes
        /// no label to be displayed.
        pub const text = struct {
            pub const name = "text";

            pub const Type = ?[*:0]u8;
        };

        /// The "text-xalign" property controls the horizontal alignment of the
        /// text in the progress bar.  Valid values range from 0 (left) to 1
        /// (right).  Reserved for RTL layouts.
        pub const text_xalign = struct {
            pub const name = "text-xalign";

            pub const Type = f32;
        };

        /// The "text-yalign" property controls the vertical alignment of the
        /// text in the progress bar.  Valid values range from 0 (top) to 1
        /// (bottom).
        pub const text_yalign = struct {
            pub const name = "text-yalign";

            pub const Type = f32;
        };

        /// The "value" property determines the percentage to which the
        /// progress bar will be "filled in".
        pub const value = struct {
            pub const name = "value";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.CellRendererProgress`.
    extern fn gtk_cell_renderer_progress_new() *gtk.CellRendererProgress;
    pub const new = gtk_cell_renderer_progress_new;

    extern fn gtk_cell_renderer_progress_get_type() usize;
    pub const getGObjectType = gtk_cell_renderer_progress_get_type;

    extern fn g_object_ref(p_self: *gtk.CellRendererProgress) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellRendererProgress) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellRendererProgress, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.CellRendererSpin` renders text in a cell like `gtk.CellRendererText` from
/// which it is derived. But while `gtk.CellRendererText` offers a simple entry to
/// edit the text, `gtk.CellRendererSpin` offers a `gtk.SpinButton` widget. Of course,
/// that means that the text has to be parseable as a floating point number.
///
/// The range of the spinbutton is taken from the adjustment property of the
/// cell renderer, which can be set explicitly or mapped to a column in the
/// tree model, like all properties of cell renders. `gtk.CellRendererSpin`
/// also has properties for the `gtk.CellRendererSpin.properties.climb`-rate and the number
/// of `gtk.CellRendererSpin.properties.digits` to display. Other `gtk.SpinButton` properties
/// can be set in a handler for the `gtk.CellRenderer.signals.editing`-started signal.
///
/// The `gtk.CellRendererSpin` cell renderer was added in GTK+ 2.10.
pub const CellRendererSpin = extern struct {
    pub const Parent = gtk.CellRendererText;
    pub const Implements = [_]type{};
    pub const Class = gtk.CellRendererSpinClass;
    f_parent: gtk.CellRendererText,
    f_priv: ?*gtk.CellRendererSpinPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The adjustment that holds the value of the spinbutton.
        /// This must be non-`NULL` for the cell renderer to be editable.
        pub const adjustment = struct {
            pub const name = "adjustment";

            pub const Type = ?*gtk.Adjustment;
        };

        /// The acceleration rate when you hold down a button.
        pub const climb_rate = struct {
            pub const name = "climb-rate";

            pub const Type = f64;
        };

        /// The number of decimal places to display.
        pub const digits = struct {
            pub const name = "digits";

            pub const Type = c_uint;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.CellRendererSpin`.
    extern fn gtk_cell_renderer_spin_new() *gtk.CellRendererSpin;
    pub const new = gtk_cell_renderer_spin_new;

    extern fn gtk_cell_renderer_spin_get_type() usize;
    pub const getGObjectType = gtk_cell_renderer_spin_get_type;

    extern fn g_object_ref(p_self: *gtk.CellRendererSpin) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellRendererSpin) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellRendererSpin, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkCellRendererSpinner renders a spinning animation in a cell, very
/// similar to `gtk.Spinner`. It can often be used as an alternative
/// to a `gtk.CellRendererProgress` for displaying indefinite activity,
/// instead of actual progress.
///
/// To start the animation in a cell, set the `gtk.CellRendererSpinner.properties.active`
/// property to `TRUE` and increment the `gtk.CellRendererSpinner.properties.pulse` property
/// at regular intervals. The usual way to set the cell renderer properties
/// for each cell is to bind them to columns in your tree model using e.g.
/// `gtk.TreeViewColumn.addAttribute`.
pub const CellRendererSpinner = extern struct {
    pub const Parent = gtk.CellRenderer;
    pub const Implements = [_]type{};
    pub const Class = gtk.CellRendererSpinnerClass;
    f_parent: gtk.CellRenderer,
    f_priv: ?*gtk.CellRendererSpinnerPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const active = struct {
            pub const name = "active";

            pub const Type = c_int;
        };

        /// Pulse of the spinner. Increment this value to draw the next frame of the
        /// spinner animation. Usually, you would update this value in a timeout.
        ///
        /// By default, the `gtk.Spinner` widget draws one full cycle of the animation,
        /// consisting of 12 frames, in 750 milliseconds.
        pub const pulse = struct {
            pub const name = "pulse";

            pub const Type = c_uint;
        };

        /// The `gtk.IconSize` value that specifies the size of the rendered spinner.
        pub const size = struct {
            pub const name = "size";

            pub const Type = gtk.IconSize;
        };
    };

    pub const signals = struct {};

    /// Returns a new cell renderer which will show a spinner to indicate
    /// activity.
    extern fn gtk_cell_renderer_spinner_new() *gtk.CellRendererSpinner;
    pub const new = gtk_cell_renderer_spinner_new;

    extern fn gtk_cell_renderer_spinner_get_type() usize;
    pub const getGObjectType = gtk_cell_renderer_spinner_get_type;

    extern fn g_object_ref(p_self: *gtk.CellRendererSpinner) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellRendererSpinner) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellRendererSpinner, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.CellRendererText` renders a given text in its cell, using the font, color and
/// style information provided by its properties. The text will be ellipsized if it is
/// too long and the `gtk.CellRendererText.properties.ellipsize` property allows it.
///
/// If the `gtk.CellRenderer.properties.mode` is `GTK_CELL_RENDERER_MODE_EDITABLE`,
/// the `gtk.CellRendererText` allows to edit its text using an entry.
pub const CellRendererText = extern struct {
    pub const Parent = gtk.CellRenderer;
    pub const Implements = [_]type{};
    pub const Class = gtk.CellRendererTextClass;
    f_parent: gtk.CellRenderer,
    f_priv: ?*gtk.CellRendererTextPrivate,

    pub const virtual_methods = struct {
        pub const edited = struct {
            pub fn call(p_class: anytype, p_cell_renderer_text: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: [*:0]const u8, p_new_text: [*:0]const u8) void {
                return gobject.ext.as(CellRendererText.Class, p_class).f_edited.?(gobject.ext.as(CellRendererText, p_cell_renderer_text), p_path, p_new_text);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell_renderer_text: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: [*:0]const u8, p_new_text: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(CellRendererText.Class, p_class).f_edited = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const align_set = struct {
            pub const name = "align-set";

            pub const Type = c_int;
        };

        /// Specifies how to align the lines of text with respect to each other.
        ///
        /// Note that this property describes how to align the lines of text in
        /// case there are several of them. The "xalign" property of `gtk.CellRenderer`,
        /// on the other hand, sets the horizontal alignment of the whole text.
        pub const alignment = struct {
            pub const name = "alignment";

            pub const Type = pango.Alignment;
        };

        pub const attributes = struct {
            pub const name = "attributes";

            pub const Type = ?*pango.AttrList;
        };

        pub const background = struct {
            pub const name = "background";

            pub const Type = ?[*:0]u8;
        };

        /// Background color as a `gdk.Color`
        pub const background_gdk = struct {
            pub const name = "background-gdk";

            pub const Type = ?*gdk.Color;
        };

        /// Background color as a `gdk.RGBA`
        pub const background_rgba = struct {
            pub const name = "background-rgba";

            pub const Type = ?*gdk.RGBA;
        };

        pub const background_set = struct {
            pub const name = "background-set";

            pub const Type = c_int;
        };

        pub const editable = struct {
            pub const name = "editable";

            pub const Type = c_int;
        };

        pub const editable_set = struct {
            pub const name = "editable-set";

            pub const Type = c_int;
        };

        /// Specifies the preferred place to ellipsize the string, if the cell renderer
        /// does not have enough room to display the entire string. Setting it to
        /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
        /// for another way of making the text fit into a given width.
        pub const ellipsize = struct {
            pub const name = "ellipsize";

            pub const Type = pango.EllipsizeMode;
        };

        pub const ellipsize_set = struct {
            pub const name = "ellipsize-set";

            pub const Type = c_int;
        };

        pub const family = struct {
            pub const name = "family";

            pub const Type = ?[*:0]u8;
        };

        pub const family_set = struct {
            pub const name = "family-set";

            pub const Type = c_int;
        };

        pub const font = struct {
            pub const name = "font";

            pub const Type = ?[*:0]u8;
        };

        pub const font_desc = struct {
            pub const name = "font-desc";

            pub const Type = ?*pango.FontDescription;
        };

        pub const foreground = struct {
            pub const name = "foreground";

            pub const Type = ?[*:0]u8;
        };

        /// Foreground color as a `gdk.Color`
        pub const foreground_gdk = struct {
            pub const name = "foreground-gdk";

            pub const Type = ?*gdk.Color;
        };

        /// Foreground color as a `gdk.RGBA`
        pub const foreground_rgba = struct {
            pub const name = "foreground-rgba";

            pub const Type = ?*gdk.RGBA;
        };

        pub const foreground_set = struct {
            pub const name = "foreground-set";

            pub const Type = c_int;
        };

        pub const language = struct {
            pub const name = "language";

            pub const Type = ?[*:0]u8;
        };

        pub const language_set = struct {
            pub const name = "language-set";

            pub const Type = c_int;
        };

        pub const markup = struct {
            pub const name = "markup";

            pub const Type = ?[*:0]u8;
        };

        /// The desired maximum width of the cell, in characters. If this property
        /// is set to -1, the width will be calculated automatically.
        ///
        /// For cell renderers that ellipsize or wrap text; this property
        /// controls the maximum reported width of the cell. The
        /// cell should not receive any greater allocation unless it is
        /// set to expand in its `gtk.CellLayout` and all of the cell's siblings
        /// have received their natural width.
        pub const max_width_chars = struct {
            pub const name = "max-width-chars";

            pub const Type = c_int;
        };

        /// The text that will be displayed in the `gtk.CellRenderer` if
        /// `gtk.CellRendererText.properties.editable` is `TRUE` and the cell is empty.
        ///
        /// Since 3.6
        pub const placeholder_text = struct {
            pub const name = "placeholder-text";

            pub const Type = ?[*:0]u8;
        };

        pub const rise = struct {
            pub const name = "rise";

            pub const Type = c_int;
        };

        pub const rise_set = struct {
            pub const name = "rise-set";

            pub const Type = c_int;
        };

        pub const scale = struct {
            pub const name = "scale";

            pub const Type = f64;
        };

        pub const scale_set = struct {
            pub const name = "scale-set";

            pub const Type = c_int;
        };

        pub const single_paragraph_mode = struct {
            pub const name = "single-paragraph-mode";

            pub const Type = c_int;
        };

        pub const size = struct {
            pub const name = "size";

            pub const Type = c_int;
        };

        pub const size_points = struct {
            pub const name = "size-points";

            pub const Type = f64;
        };

        pub const size_set = struct {
            pub const name = "size-set";

            pub const Type = c_int;
        };

        pub const stretch = struct {
            pub const name = "stretch";

            pub const Type = pango.Stretch;
        };

        pub const stretch_set = struct {
            pub const name = "stretch-set";

            pub const Type = c_int;
        };

        pub const strikethrough = struct {
            pub const name = "strikethrough";

            pub const Type = c_int;
        };

        pub const strikethrough_set = struct {
            pub const name = "strikethrough-set";

            pub const Type = c_int;
        };

        pub const style = struct {
            pub const name = "style";

            pub const Type = pango.Style;
        };

        pub const style_set = struct {
            pub const name = "style-set";

            pub const Type = c_int;
        };

        pub const text = struct {
            pub const name = "text";

            pub const Type = ?[*:0]u8;
        };

        pub const underline = struct {
            pub const name = "underline";

            pub const Type = pango.Underline;
        };

        pub const underline_set = struct {
            pub const name = "underline-set";

            pub const Type = c_int;
        };

        pub const variant = struct {
            pub const name = "variant";

            pub const Type = pango.Variant;
        };

        pub const variant_set = struct {
            pub const name = "variant-set";

            pub const Type = c_int;
        };

        pub const weight = struct {
            pub const name = "weight";

            pub const Type = c_int;
        };

        pub const weight_set = struct {
            pub const name = "weight-set";

            pub const Type = c_int;
        };

        /// The desired width of the cell, in characters. If this property is set to
        /// -1, the width will be calculated automatically, otherwise the cell will
        /// request either 3 characters or the property value, whichever is greater.
        pub const width_chars = struct {
            pub const name = "width-chars";

            pub const Type = c_int;
        };

        /// Specifies how to break the string into multiple lines, if the cell
        /// renderer does not have enough room to display the entire string.
        /// This property has no effect unless the wrap-width property is set.
        pub const wrap_mode = struct {
            pub const name = "wrap-mode";

            pub const Type = pango.WrapMode;
        };

        /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
        /// be used to influence at what character positions the line breaks can be placed.
        /// Setting wrap-width to -1 turns wrapping off.
        pub const wrap_width = struct {
            pub const name = "wrap-width";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// This signal is emitted after `renderer` has been edited.
        ///
        /// It is the responsibility of the application to update the model
        /// and store `new_text` at the position indicated by `path`.
        pub const edited = struct {
            pub const name = "edited";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_path: [*:0]u8, p_new_text: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(CellRendererText, p_instance))),
                    gobject.signalLookup("edited", CellRendererText.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.CellRendererText`. Adjust how text is drawn using
    /// object properties. Object properties can be
    /// set globally (with `gobject.Object.set`). Also, with `gtk.TreeViewColumn`,
    /// you can bind a property to a value in a `gtk.TreeModel`. For example,
    /// you can bind the “text” property on the cell renderer to a string
    /// value in the model, thus rendering a different string in each row
    /// of the `gtk.TreeView`
    extern fn gtk_cell_renderer_text_new() *gtk.CellRendererText;
    pub const new = gtk_cell_renderer_text_new;

    /// Sets the height of a renderer to explicitly be determined by the “font” and
    /// “y_pad” property set on it.  Further changes in these properties do not
    /// affect the height, so they must be accompanied by a subsequent call to this
    /// function.  Using this function is unflexible, and should really only be used
    /// if calculating the size of a cell is too slow (ie, a massive number of cells
    /// displayed).  If `number_of_rows` is -1, then the fixed height is unset, and
    /// the height is determined by the properties again.
    extern fn gtk_cell_renderer_text_set_fixed_height_from_font(p_renderer: *CellRendererText, p_number_of_rows: c_int) void;
    pub const setFixedHeightFromFont = gtk_cell_renderer_text_set_fixed_height_from_font;

    extern fn gtk_cell_renderer_text_get_type() usize;
    pub const getGObjectType = gtk_cell_renderer_text_get_type;

    extern fn g_object_ref(p_self: *gtk.CellRendererText) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellRendererText) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellRendererText, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.CellRendererToggle` renders a toggle button in a cell. The
/// button is drawn as a radio or a checkbutton, depending on the
/// `gtk.CellRendererToggle.properties.radio` property.
/// When activated, it emits the `gtk.CellRendererToggle.signals.toggled` signal.
pub const CellRendererToggle = extern struct {
    pub const Parent = gtk.CellRenderer;
    pub const Implements = [_]type{};
    pub const Class = gtk.CellRendererToggleClass;
    f_parent: gtk.CellRenderer,
    f_priv: ?*gtk.CellRendererTogglePrivate,

    pub const virtual_methods = struct {
        pub const toggled = struct {
            pub fn call(p_class: anytype, p_cell_renderer_toggle: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: [*:0]const u8) void {
                return gobject.ext.as(CellRendererToggle.Class, p_class).f_toggled.?(gobject.ext.as(CellRendererToggle, p_cell_renderer_toggle), p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell_renderer_toggle: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(CellRendererToggle.Class, p_class).f_toggled = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const activatable = struct {
            pub const name = "activatable";

            pub const Type = c_int;
        };

        pub const active = struct {
            pub const name = "active";

            pub const Type = c_int;
        };

        pub const inconsistent = struct {
            pub const name = "inconsistent";

            pub const Type = c_int;
        };

        pub const indicator_size = struct {
            pub const name = "indicator-size";

            pub const Type = c_int;
        };

        pub const radio = struct {
            pub const name = "radio";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::toggled signal is emitted when the cell is toggled.
        ///
        /// It is the responsibility of the application to update the model
        /// with the correct value to store at `path`.  Often this is simply the
        /// opposite of the value currently stored at `path`.
        pub const toggled = struct {
            pub const name = "toggled";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_path: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(CellRendererToggle, p_instance))),
                    gobject.signalLookup("toggled", CellRendererToggle.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.CellRendererToggle`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `gobject.Object.set`). Also, with `gtk.TreeViewColumn`, you
    /// can bind a property to a value in a `gtk.TreeModel`. For example, you
    /// can bind the “active” property on the cell renderer to a boolean value
    /// in the model, thus causing the check button to reflect the state of
    /// the model.
    extern fn gtk_cell_renderer_toggle_new() *gtk.CellRendererToggle;
    pub const new = gtk_cell_renderer_toggle_new;

    /// Returns whether the cell renderer is activatable. See
    /// `gtk.CellRendererToggle.setActivatable`.
    extern fn gtk_cell_renderer_toggle_get_activatable(p_toggle: *CellRendererToggle) c_int;
    pub const getActivatable = gtk_cell_renderer_toggle_get_activatable;

    /// Returns whether the cell renderer is active. See
    /// `gtk.CellRendererToggle.setActive`.
    extern fn gtk_cell_renderer_toggle_get_active(p_toggle: *CellRendererToggle) c_int;
    pub const getActive = gtk_cell_renderer_toggle_get_active;

    /// Returns whether we’re rendering radio toggles rather than checkboxes.
    extern fn gtk_cell_renderer_toggle_get_radio(p_toggle: *CellRendererToggle) c_int;
    pub const getRadio = gtk_cell_renderer_toggle_get_radio;

    /// Makes the cell renderer activatable.
    extern fn gtk_cell_renderer_toggle_set_activatable(p_toggle: *CellRendererToggle, p_setting: c_int) void;
    pub const setActivatable = gtk_cell_renderer_toggle_set_activatable;

    /// Activates or deactivates a cell renderer.
    extern fn gtk_cell_renderer_toggle_set_active(p_toggle: *CellRendererToggle, p_setting: c_int) void;
    pub const setActive = gtk_cell_renderer_toggle_set_active;

    /// If `radio` is `TRUE`, the cell renderer renders a radio toggle
    /// (i.e. a toggle in a group of mutually-exclusive toggles).
    /// If `FALSE`, it renders a check toggle (a standalone boolean option).
    /// This can be set globally for the cell renderer, or changed just
    /// before rendering each cell in the model (for `gtk.TreeView`, you set
    /// up a per-row setting using `gtk.TreeViewColumn` to associate model
    /// columns with cell renderer properties).
    extern fn gtk_cell_renderer_toggle_set_radio(p_toggle: *CellRendererToggle, p_radio: c_int) void;
    pub const setRadio = gtk_cell_renderer_toggle_set_radio;

    extern fn gtk_cell_renderer_toggle_get_type() usize;
    pub const getGObjectType = gtk_cell_renderer_toggle_get_type;

    extern fn g_object_ref(p_self: *gtk.CellRendererToggle) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellRendererToggle) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellRendererToggle, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.CellView` displays a single row of a `gtk.TreeModel` using a `gtk.CellArea`
/// and `gtk.CellAreaContext`. A `gtk.CellAreaContext` can be provided to the
/// `gtk.CellView` at construction time in order to keep the cellview in context
/// of a group of cell views, this ensures that the renderers displayed will
/// be properly aligned with eachother (like the aligned cells in the menus
/// of `gtk.ComboBox`).
///
/// `gtk.CellView` is `gtk.Orientable` in order to decide in which orientation
/// the underlying `gtk.CellAreaContext` should be allocated. Taking the `gtk.ComboBox`
/// menu as an example, cellviews should be oriented horizontally if the menus are
/// listed top-to-bottom and thus all share the same width but may have separate
/// individual heights (left-to-right menus should be allocated vertically since
/// they all share the same height but may have variable widths).
///
/// # CSS nodes
///
/// GtkCellView has a single CSS node with name cellview.
pub const CellView = extern struct {
    pub const Parent = gtk.Widget;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.CellLayout, gtk.Orientable };
    pub const Class = gtk.CellViewClass;
    f_parent_instance: gtk.Widget,
    f_priv: ?*gtk.CellViewPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const background = struct {
            pub const name = "background";

            pub const Type = ?[*:0]u8;
        };

        /// The background color as a `gdk.Color`
        pub const background_gdk = struct {
            pub const name = "background-gdk";

            pub const Type = ?*gdk.Color;
        };

        /// The background color as a `gdk.RGBA`
        pub const background_rgba = struct {
            pub const name = "background-rgba";

            pub const Type = ?*gdk.RGBA;
        };

        pub const background_set = struct {
            pub const name = "background-set";

            pub const Type = c_int;
        };

        /// The `gtk.CellArea` rendering cells
        ///
        /// If no area is specified when creating the cell view with `gtk.CellView.newWithContext`
        /// a horizontally oriented `gtk.CellAreaBox` will be used.
        ///
        /// since 3.0
        pub const cell_area = struct {
            pub const name = "cell-area";

            pub const Type = ?*gtk.CellArea;
        };

        /// The `gtk.CellAreaContext` used to compute the geometry of the cell view.
        ///
        /// A group of cell views can be assigned the same context in order to
        /// ensure the sizes and cell alignments match across all the views with
        /// the same context.
        ///
        /// `gtk.ComboBox` menus uses this to assign the same context to all cell views
        /// in the menu items for a single menu (each submenu creates its own
        /// context since the size of each submenu does not depend on parent
        /// or sibling menus).
        ///
        /// since 3.0
        pub const cell_area_context = struct {
            pub const name = "cell-area-context";

            pub const Type = ?*gtk.CellAreaContext;
        };

        /// Whether all cells should be draw as sensitive for this view regardless
        /// of the actual cell properties (used to make menus with submenus appear
        /// sensitive when the items in submenus might be insensitive).
        ///
        /// since 3.0
        pub const draw_sensitive = struct {
            pub const name = "draw-sensitive";

            pub const Type = c_int;
        };

        /// Whether the view should request enough space to always fit
        /// the size of every row in the model (used by the combo box to
        /// ensure the combo box size doesnt change when different items
        /// are selected).
        ///
        /// since 3.0
        pub const fit_model = struct {
            pub const name = "fit-model";

            pub const Type = c_int;
        };

        /// The model for cell view
        ///
        /// since 2.10
        pub const model = struct {
            pub const name = "model";

            pub const Type = ?*gtk.TreeModel;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.CellView` widget.
    extern fn gtk_cell_view_new() *gtk.CellView;
    pub const new = gtk_cell_view_new;

    /// Creates a new `gtk.CellView` widget with a specific `gtk.CellArea`
    /// to layout cells and a specific `gtk.CellAreaContext`.
    ///
    /// Specifying the same context for a handfull of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    extern fn gtk_cell_view_new_with_context(p_area: *gtk.CellArea, p_context: *gtk.CellAreaContext) *gtk.CellView;
    pub const newWithContext = gtk_cell_view_new_with_context;

    /// Creates a new `gtk.CellView` widget, adds a `gtk.CellRendererText`
    /// to it, and makes it show `markup`. The text can be
    /// marked up with the [Pango text markup language][PangoMarkupFormat].
    extern fn gtk_cell_view_new_with_markup(p_markup: [*:0]const u8) *gtk.CellView;
    pub const newWithMarkup = gtk_cell_view_new_with_markup;

    /// Creates a new `gtk.CellView` widget, adds a `gtk.CellRendererPixbuf`
    /// to it, and makes it show `pixbuf`.
    extern fn gtk_cell_view_new_with_pixbuf(p_pixbuf: *gdkpixbuf.Pixbuf) *gtk.CellView;
    pub const newWithPixbuf = gtk_cell_view_new_with_pixbuf;

    /// Creates a new `gtk.CellView` widget, adds a `gtk.CellRendererText`
    /// to it, and makes it show `text`.
    extern fn gtk_cell_view_new_with_text(p_text: [*:0]const u8) *gtk.CellView;
    pub const newWithText = gtk_cell_view_new_with_text;

    /// Returns a `gtk.TreePath` referring to the currently
    /// displayed row. If no row is currently displayed,
    /// `NULL` is returned.
    extern fn gtk_cell_view_get_displayed_row(p_cell_view: *CellView) ?*gtk.TreePath;
    pub const getDisplayedRow = gtk_cell_view_get_displayed_row;

    /// Gets whether `cell_view` is configured to draw all of its
    /// cells in a sensitive state.
    extern fn gtk_cell_view_get_draw_sensitive(p_cell_view: *CellView) c_int;
    pub const getDrawSensitive = gtk_cell_view_get_draw_sensitive;

    /// Gets whether `cell_view` is configured to request space
    /// to fit the entire `gtk.TreeModel`.
    extern fn gtk_cell_view_get_fit_model(p_cell_view: *CellView) c_int;
    pub const getFitModel = gtk_cell_view_get_fit_model;

    /// Returns the model for `cell_view`. If no model is used `NULL` is
    /// returned.
    extern fn gtk_cell_view_get_model(p_cell_view: *CellView) ?*gtk.TreeModel;
    pub const getModel = gtk_cell_view_get_model;

    /// Sets `requisition` to the size needed by `cell_view` to display
    /// the model row pointed to by `path`.
    extern fn gtk_cell_view_get_size_of_row(p_cell_view: *CellView, p_path: *gtk.TreePath, p_requisition: *gtk.Requisition) c_int;
    pub const getSizeOfRow = gtk_cell_view_get_size_of_row;

    /// Sets the background color of `view`.
    extern fn gtk_cell_view_set_background_color(p_cell_view: *CellView, p_color: *const gdk.Color) void;
    pub const setBackgroundColor = gtk_cell_view_set_background_color;

    /// Sets the background color of `cell_view`.
    extern fn gtk_cell_view_set_background_rgba(p_cell_view: *CellView, p_rgba: *const gdk.RGBA) void;
    pub const setBackgroundRgba = gtk_cell_view_set_background_rgba;

    /// Sets the row of the model that is currently displayed
    /// by the `gtk.CellView`. If the path is unset, then the
    /// contents of the cellview “stick” at their last value;
    /// this is not normally a desired result, but may be
    /// a needed intermediate state if say, the model for
    /// the `gtk.CellView` becomes temporarily empty.
    extern fn gtk_cell_view_set_displayed_row(p_cell_view: *CellView, p_path: ?*gtk.TreePath) void;
    pub const setDisplayedRow = gtk_cell_view_set_displayed_row;

    /// Sets whether `cell_view` should draw all of its
    /// cells in a sensitive state, this is used by `gtk.ComboBox` menus
    /// to ensure that rows with insensitive cells that contain
    /// children appear sensitive in the parent menu item.
    extern fn gtk_cell_view_set_draw_sensitive(p_cell_view: *CellView, p_draw_sensitive: c_int) void;
    pub const setDrawSensitive = gtk_cell_view_set_draw_sensitive;

    /// Sets whether `cell_view` should request space to fit the entire `gtk.TreeModel`.
    ///
    /// This is used by `gtk.ComboBox` to ensure that the cell view displayed on
    /// the combo box’s button always gets enough space and does not resize
    /// when selection changes.
    extern fn gtk_cell_view_set_fit_model(p_cell_view: *CellView, p_fit_model: c_int) void;
    pub const setFitModel = gtk_cell_view_set_fit_model;

    /// Sets the model for `cell_view`.  If `cell_view` already has a model
    /// set, it will remove it before setting the new model.  If `model` is
    /// `NULL`, then it will unset the old model.
    extern fn gtk_cell_view_set_model(p_cell_view: *CellView, p_model: ?*gtk.TreeModel) void;
    pub const setModel = gtk_cell_view_set_model;

    extern fn gtk_cell_view_get_type() usize;
    pub const getGObjectType = gtk_cell_view_get_type;

    extern fn g_object_ref(p_self: *gtk.CellView) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellView) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellView, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.CheckButton` places a discrete `gtk.ToggleButton` next to a widget,
/// (usually a `gtk.Label`). See the section on `gtk.ToggleButton` widgets for
/// more information about toggle/check buttons.
///
/// The important signal ( `gtk.ToggleButton.signals.toggled` ) is also inherited from
/// `gtk.ToggleButton`.
///
/// # CSS nodes
///
/// ```
/// checkbutton
/// ├── check
/// ╰── <child>
/// ```
///
/// A GtkCheckButton with indicator (see `gtk.ToggleButton.setMode`) has a
/// main CSS node with name checkbutton and a subnode with name check.
///
/// ```
/// button.check
/// ├── check
/// ╰── <child>
/// ```
///
/// A GtkCheckButton without indicator changes the name of its main node
/// to button and adds a .check style class to it. The subnode is invisible
/// in this case.
pub const CheckButton = extern struct {
    pub const Parent = gtk.ToggleButton;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.CheckButtonClass;
    f_toggle_button: gtk.ToggleButton,

    pub const virtual_methods = struct {
        pub const draw_indicator = struct {
            pub fn call(p_class: anytype, p_check_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context) void {
                return gobject.ext.as(CheckButton.Class, p_class).f_draw_indicator.?(gobject.ext.as(CheckButton, p_check_button), p_cr);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_check_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context) callconv(.c) void) void {
                gobject.ext.as(CheckButton.Class, p_class).f_draw_indicator = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.CheckButton`.
    extern fn gtk_check_button_new() *gtk.CheckButton;
    pub const new = gtk_check_button_new;

    /// Creates a new `gtk.CheckButton` with a `gtk.Label` to the right of it.
    extern fn gtk_check_button_new_with_label(p_label: [*:0]const u8) *gtk.CheckButton;
    pub const newWithLabel = gtk_check_button_new_with_label;

    /// Creates a new `gtk.CheckButton` containing a label. The label
    /// will be created using `gtk.Label.newWithMnemonic`, so underscores
    /// in `label` indicate the mnemonic for the check button.
    extern fn gtk_check_button_new_with_mnemonic(p_label: [*:0]const u8) *gtk.CheckButton;
    pub const newWithMnemonic = gtk_check_button_new_with_mnemonic;

    extern fn gtk_check_button_get_type() usize;
    pub const getGObjectType = gtk_check_button_get_type;

    extern fn g_object_ref(p_self: *gtk.CheckButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CheckButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CheckButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.CheckMenuItem` is a menu item that maintains the state of a boolean
/// value in addition to a `gtk.MenuItem` usual role in activating application
/// code.
///
/// A check box indicating the state of the boolean value is displayed
/// at the left side of the `gtk.MenuItem`.  Activating the `gtk.MenuItem`
/// toggles the value.
///
/// # CSS nodes
///
/// ```
/// menuitem
/// ├── check.left
/// ╰── <child>
/// ```
///
/// GtkCheckMenuItem has a main CSS node with name menuitem, and a subnode
/// with name check, which gets the .left or .right style class.
pub const CheckMenuItem = extern struct {
    pub const Parent = gtk.MenuItem;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.CheckMenuItemClass;
    f_menu_item: gtk.MenuItem,
    f_priv: ?*gtk.CheckMenuItemPrivate,

    pub const virtual_methods = struct {
        /// Called to draw the check indicator.
        pub const draw_indicator = struct {
            pub fn call(p_class: anytype, p_check_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context) void {
                return gobject.ext.as(CheckMenuItem.Class, p_class).f_draw_indicator.?(gobject.ext.as(CheckMenuItem, p_check_menu_item), p_cr);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_check_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context) callconv(.c) void) void {
                gobject.ext.as(CheckMenuItem.Class, p_class).f_draw_indicator = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gtk.CheckMenuItem.signals.toggled` signal.
        pub const toggled = struct {
            pub fn call(p_class: anytype, p_check_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(CheckMenuItem.Class, p_class).f_toggled.?(gobject.ext.as(CheckMenuItem, p_check_menu_item));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_check_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(CheckMenuItem.Class, p_class).f_toggled = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const active = struct {
            pub const name = "active";

            pub const Type = c_int;
        };

        pub const draw_as_radio = struct {
            pub const name = "draw-as-radio";

            pub const Type = c_int;
        };

        pub const inconsistent = struct {
            pub const name = "inconsistent";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// This signal is emitted when the state of the check box is changed.
        ///
        /// A signal handler can use `gtk.CheckMenuItem.getActive`
        /// to discover the new state.
        pub const toggled = struct {
            pub const name = "toggled";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(CheckMenuItem, p_instance))),
                    gobject.signalLookup("toggled", CheckMenuItem.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.CheckMenuItem`.
    extern fn gtk_check_menu_item_new() *gtk.CheckMenuItem;
    pub const new = gtk_check_menu_item_new;

    /// Creates a new `gtk.CheckMenuItem` with a label.
    extern fn gtk_check_menu_item_new_with_label(p_label: [*:0]const u8) *gtk.CheckMenuItem;
    pub const newWithLabel = gtk_check_menu_item_new_with_label;

    /// Creates a new `gtk.CheckMenuItem` containing a label. The label
    /// will be created using `gtk.Label.newWithMnemonic`, so underscores
    /// in `label` indicate the mnemonic for the menu item.
    extern fn gtk_check_menu_item_new_with_mnemonic(p_label: [*:0]const u8) *gtk.CheckMenuItem;
    pub const newWithMnemonic = gtk_check_menu_item_new_with_mnemonic;

    /// Returns whether the check menu item is active. See
    /// gtk_check_menu_item_set_active ().
    extern fn gtk_check_menu_item_get_active(p_check_menu_item: *CheckMenuItem) c_int;
    pub const getActive = gtk_check_menu_item_get_active;

    /// Returns whether `check_menu_item` looks like a `gtk.RadioMenuItem`
    extern fn gtk_check_menu_item_get_draw_as_radio(p_check_menu_item: *CheckMenuItem) c_int;
    pub const getDrawAsRadio = gtk_check_menu_item_get_draw_as_radio;

    /// Retrieves the value set by `gtk.CheckMenuItem.setInconsistent`.
    extern fn gtk_check_menu_item_get_inconsistent(p_check_menu_item: *CheckMenuItem) c_int;
    pub const getInconsistent = gtk_check_menu_item_get_inconsistent;

    /// Sets the active state of the menu item’s check box.
    extern fn gtk_check_menu_item_set_active(p_check_menu_item: *CheckMenuItem, p_is_active: c_int) void;
    pub const setActive = gtk_check_menu_item_set_active;

    /// Sets whether `check_menu_item` is drawn like a `gtk.RadioMenuItem`
    extern fn gtk_check_menu_item_set_draw_as_radio(p_check_menu_item: *CheckMenuItem, p_draw_as_radio: c_int) void;
    pub const setDrawAsRadio = gtk_check_menu_item_set_draw_as_radio;

    /// If the user has selected a range of elements (such as some text or
    /// spreadsheet cells) that are affected by a boolean setting, and the
    /// current values in that range are inconsistent, you may want to
    /// display the check in an “in between” state. This function turns on
    /// “in between” display.  Normally you would turn off the inconsistent
    /// state again if the user explicitly selects a setting. This has to be
    /// done manually, `gtk.CheckMenuItem.setInconsistent` only affects
    /// visual appearance, it doesn’t affect the semantics of the widget.
    extern fn gtk_check_menu_item_set_inconsistent(p_check_menu_item: *CheckMenuItem, p_setting: c_int) void;
    pub const setInconsistent = gtk_check_menu_item_set_inconsistent;

    /// Emits the `gtk.CheckMenuItem.signals.toggled` signal.
    extern fn gtk_check_menu_item_toggled(p_check_menu_item: *CheckMenuItem) void;
    pub const toggled = gtk_check_menu_item_toggled;

    extern fn gtk_check_menu_item_get_type() usize;
    pub const getGObjectType = gtk_check_menu_item_get_type;

    extern fn g_object_ref(p_self: *gtk.CheckMenuItem) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CheckMenuItem) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CheckMenuItem, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CheckMenuItemAccessible = extern struct {
    pub const Parent = gtk.MenuItemAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.Selection };
    pub const Class = gtk.CheckMenuItemAccessibleClass;
    f_parent: gtk.MenuItemAccessible,
    f_priv: ?*gtk.CheckMenuItemAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_check_menu_item_accessible_get_type() usize;
    pub const getGObjectType = gtk_check_menu_item_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.CheckMenuItemAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CheckMenuItemAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CheckMenuItemAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Clipboard` object represents a clipboard of data shared
/// between different processes or between different widgets in
/// the same process. Each clipboard is identified by a name encoded as a
/// `gdk.Atom`. (Conversion to and from strings can be done with
/// `gdk.atomIntern` and `gdk.Atom.name`.) The default clipboard
/// corresponds to the “CLIPBOARD” atom; another commonly used clipboard
/// is the “PRIMARY” clipboard, which, in X, traditionally contains
/// the currently selected text.
///
/// To support having a number of different formats on the clipboard
/// at the same time, the clipboard mechanism allows providing
/// callbacks instead of the actual data.  When you set the contents
/// of the clipboard, you can either supply the data directly (via
/// functions like `gtk.Clipboard.setText`), or you can supply a
/// callback to be called at a later time when the data is needed (via
/// `gtk.Clipboard.setWithData` or `gtk.Clipboard.setWithOwner`.)
/// Providing a callback also avoids having to make copies of the data
/// when it is not needed.
///
/// `gtk.Clipboard.setWithData` and `gtk.Clipboard.setWithOwner`
/// are quite similar; the choice between the two depends mostly on
/// which is more convenient in a particular situation.
/// The former is most useful when you want to have a blob of data
/// with callbacks to convert it into the various data types that you
/// advertise. When the `clear_func` you provided is called, you
/// simply free the data blob. The latter is more useful when the
/// contents of clipboard reflect the internal state of a `gobject.Object`
/// (As an example, for the PRIMARY clipboard, when an entry widget
/// provides the clipboard’s contents the contents are simply the
/// text within the selected region.) If the contents change, the
/// entry widget can call `gtk.Clipboard.setWithOwner` to update
/// the timestamp for clipboard ownership, without having to worry
/// about `clear_func` being called.
///
/// Requesting the data from the clipboard is essentially
/// asynchronous. If the contents of the clipboard are provided within
/// the same process, then a direct function call will be made to
/// retrieve the data, but if they are provided by another process,
/// then the data needs to be retrieved from the other process, which
/// may take some time. To avoid blocking the user interface, the call
/// to request the selection, `gtk.Clipboard.requestContents` takes a
/// callback that will be called when the contents are received (or
/// when the request fails.) If you don’t want to deal with providing
/// a separate callback, you can also use `gtk.Clipboard.waitForContents`.
/// What this does is run the GLib main loop recursively waiting for
/// the contents. This can simplify the code flow, but you still have
/// to be aware that other callbacks in your program can be called
/// while this recursive mainloop is running.
///
/// Along with the functions to get the clipboard contents as an
/// arbitrary data chunk, there are also functions to retrieve
/// it as text, `gtk.Clipboard.requestText` and
/// `gtk.Clipboard.waitForText`. These functions take care of
/// determining which formats are advertised by the clipboard
/// provider, asking for the clipboard in the best available format
/// and converting the results into the UTF-8 encoding. (The standard
/// form for representing strings in GTK+.)
pub const Clipboard = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = Clipboard;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {
        /// The ::owner-change signal is emitted when GTK+ receives an
        /// event that indicates that the ownership of the selection
        /// associated with `clipboard` has changed.
        pub const owner_change = struct {
            pub const name = "owner-change";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventOwnerChange, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Clipboard, p_instance))),
                    gobject.signalLookup("owner-change", Clipboard.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Returns the clipboard object for the given selection.
    /// See `gtk.Clipboard.getForDisplay` for complete details.
    extern fn gtk_clipboard_get(p_selection: gdk.Atom) *gtk.Clipboard;
    pub const get = gtk_clipboard_get;

    /// Returns the default clipboard object for use with cut/copy/paste menu items
    /// and keyboard shortcuts.
    extern fn gtk_clipboard_get_default(p_display: *gdk.Display) *gtk.Clipboard;
    pub const getDefault = gtk_clipboard_get_default;

    /// Returns the clipboard object for the given selection.
    /// Cut/copy/paste menu items and keyboard shortcuts should use
    /// the default clipboard, returned by passing `GDK_SELECTION_CLIPBOARD` for `selection`.
    /// (`GDK_NONE` is supported as a synonym for GDK_SELECTION_CLIPBOARD
    /// for backwards compatibility reasons.)
    /// The currently-selected object or text should be provided on the clipboard
    /// identified by `GDK_SELECTION_PRIMARY`. Cut/copy/paste menu items
    /// conceptually copy the contents of the `GDK_SELECTION_PRIMARY` clipboard
    /// to the default clipboard, i.e. they copy the selection to what the
    /// user sees as the clipboard.
    ///
    /// (Passing `GDK_NONE` is the same as using `gdk_atom_intern
    /// ("CLIPBOARD", FALSE)`.
    ///
    /// See the
    /// [FreeDesktop Clipboard Specification](http://www.freedesktop.org/Standards/clipboards-spec)
    /// for a detailed discussion of the “CLIPBOARD” vs. “PRIMARY”
    /// selections under the X window system. On Win32 the
    /// `GDK_SELECTION_PRIMARY` clipboard is essentially ignored.)
    ///
    /// It’s possible to have arbitrary named clipboards; if you do invent
    /// new clipboards, you should prefix the selection name with an
    /// underscore (because the ICCCM requires that nonstandard atoms are
    /// underscore-prefixed), and namespace it as well. For example,
    /// if your application called “Foo” has a special-purpose
    /// clipboard, you might call it “_FOO_SPECIAL_CLIPBOARD”.
    extern fn gtk_clipboard_get_for_display(p_display: *gdk.Display, p_selection: gdk.Atom) *gtk.Clipboard;
    pub const getForDisplay = gtk_clipboard_get_for_display;

    /// Clears the contents of the clipboard. Generally this should only
    /// be called between the time you call `gtk.Clipboard.setWithOwner`
    /// or `gtk.Clipboard.setWithData`,
    /// and when the `clear_func` you supplied is called. Otherwise, the
    /// clipboard may be owned by someone else.
    extern fn gtk_clipboard_clear(p_clipboard: *Clipboard) void;
    pub const clear = gtk_clipboard_clear;

    /// Gets the `gdk.Display` associated with `clipboard`
    extern fn gtk_clipboard_get_display(p_clipboard: *Clipboard) *gdk.Display;
    pub const getDisplay = gtk_clipboard_get_display;

    /// If the clipboard contents callbacks were set with
    /// `gtk.Clipboard.setWithOwner`, and the `gtk.Clipboard.setWithData` or
    /// `gtk.Clipboard.clear` has not subsequently called, returns the owner set
    /// by `gtk.Clipboard.setWithOwner`.
    extern fn gtk_clipboard_get_owner(p_clipboard: *Clipboard) ?*gobject.Object;
    pub const getOwner = gtk_clipboard_get_owner;

    /// Gets the selection that this clipboard is for.
    extern fn gtk_clipboard_get_selection(p_clipboard: *Clipboard) gdk.Atom;
    pub const getSelection = gtk_clipboard_get_selection;

    /// Requests the contents of clipboard as the given target.
    /// When the results of the result are later received the supplied callback
    /// will be called.
    extern fn gtk_clipboard_request_contents(p_clipboard: *Clipboard, p_target: gdk.Atom, p_callback: gtk.ClipboardReceivedFunc, p_user_data: ?*anyopaque) void;
    pub const requestContents = gtk_clipboard_request_contents;

    /// Requests the contents of the clipboard as image. When the image is
    /// later received, it will be converted to a `gdkpixbuf.Pixbuf`, and
    /// `callback` will be called.
    ///
    /// The `pixbuf` parameter to `callback` will contain the resulting
    /// `gdkpixbuf.Pixbuf` if the request succeeded, or `NULL` if it failed. This
    /// could happen for various reasons, in particular if the clipboard
    /// was empty or if the contents of the clipboard could not be
    /// converted into an image.
    extern fn gtk_clipboard_request_image(p_clipboard: *Clipboard, p_callback: gtk.ClipboardImageReceivedFunc, p_user_data: ?*anyopaque) void;
    pub const requestImage = gtk_clipboard_request_image;

    /// Requests the contents of the clipboard as rich text. When the rich
    /// text is later received, `callback` will be called.
    ///
    /// The `text` parameter to `callback` will contain the resulting rich
    /// text if the request succeeded, or `NULL` if it failed. The `length`
    /// parameter will contain `text`’s length. This function can fail for
    /// various reasons, in particular if the clipboard was empty or if the
    /// contents of the clipboard could not be converted into rich text form.
    extern fn gtk_clipboard_request_rich_text(p_clipboard: *Clipboard, p_buffer: *gtk.TextBuffer, p_callback: gtk.ClipboardRichTextReceivedFunc, p_user_data: ?*anyopaque) void;
    pub const requestRichText = gtk_clipboard_request_rich_text;

    /// Requests the contents of the clipboard as list of supported targets.
    /// When the list is later received, `callback` will be called.
    ///
    /// The `targets` parameter to `callback` will contain the resulting targets if
    /// the request succeeded, or `NULL` if it failed.
    extern fn gtk_clipboard_request_targets(p_clipboard: *Clipboard, p_callback: gtk.ClipboardTargetsReceivedFunc, p_user_data: ?*anyopaque) void;
    pub const requestTargets = gtk_clipboard_request_targets;

    /// Requests the contents of the clipboard as text. When the text is
    /// later received, it will be converted to UTF-8 if necessary, and
    /// `callback` will be called.
    ///
    /// The `text` parameter to `callback` will contain the resulting text if
    /// the request succeeded, or `NULL` if it failed. This could happen for
    /// various reasons, in particular if the clipboard was empty or if the
    /// contents of the clipboard could not be converted into text form.
    extern fn gtk_clipboard_request_text(p_clipboard: *Clipboard, p_callback: gtk.ClipboardTextReceivedFunc, p_user_data: ?*anyopaque) void;
    pub const requestText = gtk_clipboard_request_text;

    /// Requests the contents of the clipboard as URIs. When the URIs are
    /// later received `callback` will be called.
    ///
    /// The `uris` parameter to `callback` will contain the resulting array of
    /// URIs if the request succeeded, or `NULL` if it failed. This could happen
    /// for various reasons, in particular if the clipboard was empty or if the
    /// contents of the clipboard could not be converted into URI form.
    extern fn gtk_clipboard_request_uris(p_clipboard: *Clipboard, p_callback: gtk.ClipboardURIReceivedFunc, p_user_data: ?*anyopaque) void;
    pub const requestUris = gtk_clipboard_request_uris;

    /// Hints that the clipboard data should be stored somewhere when the
    /// application exits or when gtk_clipboard_store () is called.
    ///
    /// This value is reset when the clipboard owner changes.
    /// Where the clipboard data is stored is platform dependent,
    /// see gdk_display_store_clipboard () for more information.
    extern fn gtk_clipboard_set_can_store(p_clipboard: *Clipboard, p_targets: ?[*]const gtk.TargetEntry, p_n_targets: c_int) void;
    pub const setCanStore = gtk_clipboard_set_can_store;

    /// Sets the contents of the clipboard to the given `gdkpixbuf.Pixbuf`.
    /// GTK+ will take responsibility for responding for requests
    /// for the image, and for converting the image into the
    /// requested format.
    extern fn gtk_clipboard_set_image(p_clipboard: *Clipboard, p_pixbuf: *gdkpixbuf.Pixbuf) void;
    pub const setImage = gtk_clipboard_set_image;

    /// Sets the contents of the clipboard to the given UTF-8 string. GTK+ will
    /// make a copy of the text and take responsibility for responding
    /// for requests for the text, and for converting the text into
    /// the requested format.
    extern fn gtk_clipboard_set_text(p_clipboard: *Clipboard, p_text: [*:0]const u8, p_len: c_int) void;
    pub const setText = gtk_clipboard_set_text;

    /// Virtually sets the contents of the specified clipboard by providing
    /// a list of supported formats for the clipboard data and a function
    /// to call to get the actual data when it is requested.
    extern fn gtk_clipboard_set_with_data(p_clipboard: *Clipboard, p_targets: [*]const gtk.TargetEntry, p_n_targets: c_uint, p_get_func: gtk.ClipboardGetFunc, p_clear_func: gtk.ClipboardClearFunc, p_user_data: ?*anyopaque) c_int;
    pub const setWithData = gtk_clipboard_set_with_data;

    /// Virtually sets the contents of the specified clipboard by providing
    /// a list of supported formats for the clipboard data and a function
    /// to call to get the actual data when it is requested.
    ///
    /// The difference between this function and `gtk.Clipboard.setWithData`
    /// is that instead of an generic `user_data` pointer, a `gobject.Object` is passed
    /// in.
    extern fn gtk_clipboard_set_with_owner(p_clipboard: *Clipboard, p_targets: [*]const gtk.TargetEntry, p_n_targets: c_uint, p_get_func: gtk.ClipboardGetFunc, p_clear_func: gtk.ClipboardClearFunc, p_owner: *gobject.Object) c_int;
    pub const setWithOwner = gtk_clipboard_set_with_owner;

    /// Stores the current clipboard data somewhere so that it will stay
    /// around after the application has quit.
    extern fn gtk_clipboard_store(p_clipboard: *Clipboard) void;
    pub const store = gtk_clipboard_store;

    /// Requests the contents of the clipboard using the given target.
    /// This function waits for the data to be received using the main
    /// loop, so events, timeouts, etc, may be dispatched during the wait.
    extern fn gtk_clipboard_wait_for_contents(p_clipboard: *Clipboard, p_target: gdk.Atom) ?*gtk.SelectionData;
    pub const waitForContents = gtk_clipboard_wait_for_contents;

    /// Requests the contents of the clipboard as image and converts
    /// the result to a `gdkpixbuf.Pixbuf`. This function waits for
    /// the data to be received using the main loop, so events,
    /// timeouts, etc, may be dispatched during the wait.
    extern fn gtk_clipboard_wait_for_image(p_clipboard: *Clipboard) ?*gdkpixbuf.Pixbuf;
    pub const waitForImage = gtk_clipboard_wait_for_image;

    /// Requests the contents of the clipboard as rich text.  This function
    /// waits for the data to be received using the main loop, so events,
    /// timeouts, etc, may be dispatched during the wait.
    extern fn gtk_clipboard_wait_for_rich_text(p_clipboard: *Clipboard, p_buffer: *gtk.TextBuffer, p_format: *gdk.Atom, p_length: *usize) ?[*]u8;
    pub const waitForRichText = gtk_clipboard_wait_for_rich_text;

    /// Returns a list of targets that are present on the clipboard, or `NULL`
    /// if there aren’t any targets available. The returned list must be
    /// freed with `glib.free`.
    /// This function waits for the data to be received using the main
    /// loop, so events, timeouts, etc, may be dispatched during the wait.
    extern fn gtk_clipboard_wait_for_targets(p_clipboard: *Clipboard, p_targets: *[*]gdk.Atom, p_n_targets: *c_int) c_int;
    pub const waitForTargets = gtk_clipboard_wait_for_targets;

    /// Requests the contents of the clipboard as text and converts
    /// the result to UTF-8 if necessary. This function waits for
    /// the data to be received using the main loop, so events,
    /// timeouts, etc, may be dispatched during the wait.
    extern fn gtk_clipboard_wait_for_text(p_clipboard: *Clipboard) ?[*:0]u8;
    pub const waitForText = gtk_clipboard_wait_for_text;

    /// Requests the contents of the clipboard as URIs. This function waits
    /// for the data to be received using the main loop, so events,
    /// timeouts, etc, may be dispatched during the wait.
    extern fn gtk_clipboard_wait_for_uris(p_clipboard: *Clipboard) ?[*][*:0]u8;
    pub const waitForUris = gtk_clipboard_wait_for_uris;

    /// Test to see if there is an image available to be pasted
    /// This is done by requesting the TARGETS atom and checking
    /// if it contains any of the supported image targets. This function
    /// waits for the data to be received using the main loop, so events,
    /// timeouts, etc, may be dispatched during the wait.
    ///
    /// This function is a little faster than calling
    /// `gtk.Clipboard.waitForImage` since it doesn’t need to retrieve
    /// the actual image data.
    extern fn gtk_clipboard_wait_is_image_available(p_clipboard: *Clipboard) c_int;
    pub const waitIsImageAvailable = gtk_clipboard_wait_is_image_available;

    /// Test to see if there is rich text available to be pasted
    /// This is done by requesting the TARGETS atom and checking
    /// if it contains any of the supported rich text targets. This function
    /// waits for the data to be received using the main loop, so events,
    /// timeouts, etc, may be dispatched during the wait.
    ///
    /// This function is a little faster than calling
    /// `gtk.Clipboard.waitForRichText` since it doesn’t need to retrieve
    /// the actual text.
    extern fn gtk_clipboard_wait_is_rich_text_available(p_clipboard: *Clipboard, p_buffer: *gtk.TextBuffer) c_int;
    pub const waitIsRichTextAvailable = gtk_clipboard_wait_is_rich_text_available;

    /// Checks if a clipboard supports pasting data of a given type. This
    /// function can be used to determine if a “Paste” menu item should be
    /// insensitive or not.
    ///
    /// If you want to see if there’s text available on the clipboard, use
    /// gtk_clipboard_wait_is_text_available () instead.
    extern fn gtk_clipboard_wait_is_target_available(p_clipboard: *Clipboard, p_target: gdk.Atom) c_int;
    pub const waitIsTargetAvailable = gtk_clipboard_wait_is_target_available;

    /// Test to see if there is text available to be pasted
    /// This is done by requesting the TARGETS atom and checking
    /// if it contains any of the supported text targets. This function
    /// waits for the data to be received using the main loop, so events,
    /// timeouts, etc, may be dispatched during the wait.
    ///
    /// This function is a little faster than calling
    /// `gtk.Clipboard.waitForText` since it doesn’t need to retrieve
    /// the actual text.
    extern fn gtk_clipboard_wait_is_text_available(p_clipboard: *Clipboard) c_int;
    pub const waitIsTextAvailable = gtk_clipboard_wait_is_text_available;

    /// Test to see if there is a list of URIs available to be pasted
    /// This is done by requesting the TARGETS atom and checking
    /// if it contains the URI targets. This function
    /// waits for the data to be received using the main loop, so events,
    /// timeouts, etc, may be dispatched during the wait.
    ///
    /// This function is a little faster than calling
    /// `gtk.Clipboard.waitForUris` since it doesn’t need to retrieve
    /// the actual URI data.
    extern fn gtk_clipboard_wait_is_uris_available(p_clipboard: *Clipboard) c_int;
    pub const waitIsUrisAvailable = gtk_clipboard_wait_is_uris_available;

    extern fn gtk_clipboard_get_type() usize;
    pub const getGObjectType = gtk_clipboard_get_type;

    extern fn g_object_ref(p_self: *gtk.Clipboard) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Clipboard) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Clipboard, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.ColorButton` is a button which displays the currently selected
/// color and allows to open a color selection dialog to change the color.
/// It is suitable widget for selecting a color in a preference dialog.
///
/// # CSS nodes
///
/// GtkColorButton has a single CSS node with name button. To differentiate
/// it from a plain `gtk.Button`, it gets the .color style class.
pub const ColorButton = extern struct {
    pub const Parent = gtk.Button;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable, gtk.ColorChooser };
    pub const Class = gtk.ColorButtonClass;
    f_button: gtk.Button,
    f_priv: ?*gtk.ColorButtonPrivate,

    pub const virtual_methods = struct {
        pub const color_set = struct {
            pub fn call(p_class: anytype, p_cp: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ColorButton.Class, p_class).f_color_set.?(gobject.ext.as(ColorButton, p_cp));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cp: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ColorButton.Class, p_class).f_color_set = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The selected opacity value (0 fully transparent, 65535 fully opaque).
        pub const alpha = struct {
            pub const name = "alpha";

            pub const Type = c_uint;
        };

        /// The selected color.
        pub const color = struct {
            pub const name = "color";

            pub const Type = ?*gdk.Color;
        };

        /// The RGBA color.
        pub const rgba = struct {
            pub const name = "rgba";

            pub const Type = ?*gdk.RGBA;
        };

        /// Set this property to `TRUE` to skip the palette
        /// in the dialog and go directly to the color editor.
        ///
        /// This property should be used in cases where the palette
        /// in the editor would be redundant, such as when the color
        /// button is already part of a palette.
        pub const show_editor = struct {
            pub const name = "show-editor";

            pub const Type = c_int;
        };

        /// The title of the color selection dialog
        pub const title = struct {
            pub const name = "title";

            pub const Type = ?[*:0]u8;
        };

        /// If this property is set to `TRUE`, the color swatch on the button is
        /// rendered against a checkerboard background to show its opacity and
        /// the opacity slider is displayed in the color selection dialog.
        pub const use_alpha = struct {
            pub const name = "use-alpha";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::color-set signal is emitted when the user selects a color.
        /// When handling this signal, use `gtk.ColorButton.getRgba` to
        /// find out which color was just selected.
        ///
        /// Note that this signal is only emitted when the user
        /// changes the color. If you need to react to programmatic color changes
        /// as well, use the notify::color signal.
        pub const color_set = struct {
            pub const name = "color-set";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ColorButton, p_instance))),
                    gobject.signalLookup("color-set", ColorButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new color button.
    ///
    /// This returns a widget in the form of a small button containing
    /// a swatch representing the current selected color. When the button
    /// is clicked, a color-selection dialog will open, allowing the user
    /// to select a color. The swatch will be updated to reflect the new
    /// color when the user finishes.
    extern fn gtk_color_button_new() *gtk.ColorButton;
    pub const new = gtk_color_button_new;

    /// Creates a new color button.
    extern fn gtk_color_button_new_with_color(p_color: *const gdk.Color) *gtk.ColorButton;
    pub const newWithColor = gtk_color_button_new_with_color;

    /// Creates a new color button.
    extern fn gtk_color_button_new_with_rgba(p_rgba: *const gdk.RGBA) *gtk.ColorButton;
    pub const newWithRgba = gtk_color_button_new_with_rgba;

    /// Returns the current alpha value.
    extern fn gtk_color_button_get_alpha(p_button: *ColorButton) u16;
    pub const getAlpha = gtk_color_button_get_alpha;

    /// Sets `color` to be the current color in the `gtk.ColorButton` widget.
    extern fn gtk_color_button_get_color(p_button: *ColorButton, p_color: *gdk.Color) void;
    pub const getColor = gtk_color_button_get_color;

    /// Sets `rgba` to be the current color in the `gtk.ColorButton` widget.
    extern fn gtk_color_button_get_rgba(p_button: *ColorButton, p_rgba: *gdk.RGBA) void;
    pub const getRgba = gtk_color_button_get_rgba;

    /// Gets the title of the color selection dialog.
    extern fn gtk_color_button_get_title(p_button: *ColorButton) [*:0]const u8;
    pub const getTitle = gtk_color_button_get_title;

    /// Does the color selection dialog use the alpha channel ?
    extern fn gtk_color_button_get_use_alpha(p_button: *ColorButton) c_int;
    pub const getUseAlpha = gtk_color_button_get_use_alpha;

    /// Sets the current opacity to be `alpha`.
    extern fn gtk_color_button_set_alpha(p_button: *ColorButton, p_alpha: u16) void;
    pub const setAlpha = gtk_color_button_set_alpha;

    /// Sets the current color to be `color`.
    extern fn gtk_color_button_set_color(p_button: *ColorButton, p_color: *const gdk.Color) void;
    pub const setColor = gtk_color_button_set_color;

    /// Sets the current color to be `rgba`.
    extern fn gtk_color_button_set_rgba(p_button: *ColorButton, p_rgba: *const gdk.RGBA) void;
    pub const setRgba = gtk_color_button_set_rgba;

    /// Sets the title for the color selection dialog.
    extern fn gtk_color_button_set_title(p_button: *ColorButton, p_title: [*:0]const u8) void;
    pub const setTitle = gtk_color_button_set_title;

    /// Sets whether or not the color button should use the alpha channel.
    extern fn gtk_color_button_set_use_alpha(p_button: *ColorButton, p_use_alpha: c_int) void;
    pub const setUseAlpha = gtk_color_button_set_use_alpha;

    extern fn gtk_color_button_get_type() usize;
    pub const getGObjectType = gtk_color_button_get_type;

    extern fn g_object_ref(p_self: *gtk.ColorButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ColorButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ColorButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.ColorChooserDialog` widget is a dialog for choosing
/// a color. It implements the `gtk.ColorChooser` interface.
pub const ColorChooserDialog = extern struct {
    pub const Parent = gtk.Dialog;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.ColorChooser };
    pub const Class = gtk.ColorChooserDialogClass;
    f_parent_instance: gtk.Dialog,
    f_priv: ?*gtk.ColorChooserDialogPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const show_editor = struct {
            pub const name = "show-editor";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.ColorChooserDialog`.
    extern fn gtk_color_chooser_dialog_new(p_title: ?[*:0]const u8, p_parent: ?*gtk.Window) *gtk.ColorChooserDialog;
    pub const new = gtk_color_chooser_dialog_new;

    extern fn gtk_color_chooser_dialog_get_type() usize;
    pub const getGObjectType = gtk_color_chooser_dialog_get_type;

    extern fn g_object_ref(p_self: *gtk.ColorChooserDialog) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ColorChooserDialog) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ColorChooserDialog, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.ColorChooserWidget` widget lets the user select a
/// color. By default, the chooser presents a predefined palette
/// of colors, plus a small number of settable custom colors.
/// It is also possible to select a different color with the
/// single-color editor. To enter the single-color editing mode,
/// use the context menu of any color of the palette, or use the
/// '+' button to add a new custom color.
///
/// The chooser automatically remembers the last selection, as well
/// as custom colors.
///
/// To change the initially selected color, use `gtk.ColorChooser.setRgba`.
/// To get the selected color use `gtk.ColorChooser.getRgba`.
///
/// The `gtk.ColorChooserWidget` is used in the `gtk.ColorChooserDialog`
/// to provide a dialog for selecting colors.
///
/// # CSS names
///
/// GtkColorChooserWidget has a single CSS node with name colorchooser.
pub const ColorChooserWidget = extern struct {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.ColorChooser, gtk.Orientable };
    pub const Class = gtk.ColorChooserWidgetClass;
    f_parent_instance: gtk.Box,
    f_priv: ?*gtk.ColorChooserWidgetPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The ::show-editor property is `TRUE` when the color chooser
        /// is showing the single-color editor. It can be set to switch
        /// the color chooser into single-color editing mode.
        pub const show_editor = struct {
            pub const name = "show-editor";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.ColorChooserWidget`.
    extern fn gtk_color_chooser_widget_new() *gtk.ColorChooserWidget;
    pub const new = gtk_color_chooser_widget_new;

    extern fn gtk_color_chooser_widget_get_type() usize;
    pub const getGObjectType = gtk_color_chooser_widget_get_type;

    extern fn g_object_ref(p_self: *gtk.ColorChooserWidget) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ColorChooserWidget) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ColorChooserWidget, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ColorSelection = extern struct {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.ColorSelectionClass;
    f_parent_instance: gtk.Box,
    f_private_data: ?*gtk.ColorSelectionPrivate,

    pub const virtual_methods = struct {
        pub const color_changed = struct {
            pub fn call(p_class: anytype, p_color_selection: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ColorSelection.Class, p_class).f_color_changed.?(gobject.ext.as(ColorSelection, p_color_selection));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_color_selection: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ColorSelection.Class, p_class).f_color_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const current_alpha = struct {
            pub const name = "current-alpha";

            pub const Type = c_uint;
        };

        /// The current GdkColor color.
        pub const current_color = struct {
            pub const name = "current-color";

            pub const Type = ?*gdk.Color;
        };

        /// The current RGBA color.
        pub const current_rgba = struct {
            pub const name = "current-rgba";

            pub const Type = ?*gdk.RGBA;
        };

        pub const has_opacity_control = struct {
            pub const name = "has-opacity-control";

            pub const Type = c_int;
        };

        pub const has_palette = struct {
            pub const name = "has-palette";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// This signal is emitted when the color changes in the `gtk.ColorSelection`
        /// according to its update policy.
        pub const color_changed = struct {
            pub const name = "color-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ColorSelection, p_instance))),
                    gobject.signalLookup("color-changed", ColorSelection.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Parses a color palette string; the string is a colon-separated
    /// list of color names readable by `gdk.colorParse`.
    extern fn gtk_color_selection_palette_from_string(p_str: [*:0]const u8, p_colors: *[*]gdk.Color, p_n_colors: *c_int) c_int;
    pub const paletteFromString = gtk_color_selection_palette_from_string;

    /// Encodes a palette as a string, useful for persistent storage.
    extern fn gtk_color_selection_palette_to_string(p_colors: [*]const gdk.Color, p_n_colors: c_int) [*:0]u8;
    pub const paletteToString = gtk_color_selection_palette_to_string;

    /// Installs a global function to be called whenever the user
    /// tries to modify the palette in a color selection.
    ///
    /// This function should save the new palette contents, and update
    /// the `gtk.Settings.properties.gtk`-color-palette GtkSettings property so all
    /// GtkColorSelection widgets will be modified.
    extern fn gtk_color_selection_set_change_palette_with_screen_hook(p_func: gtk.ColorSelectionChangePaletteWithScreenFunc) gtk.ColorSelectionChangePaletteWithScreenFunc;
    pub const setChangePaletteWithScreenHook = gtk_color_selection_set_change_palette_with_screen_hook;

    /// Creates a new GtkColorSelection.
    extern fn gtk_color_selection_new() *gtk.ColorSelection;
    pub const new = gtk_color_selection_new;

    /// Returns the current alpha value.
    extern fn gtk_color_selection_get_current_alpha(p_colorsel: *ColorSelection) u16;
    pub const getCurrentAlpha = gtk_color_selection_get_current_alpha;

    /// Sets `color` to be the current color in the GtkColorSelection widget.
    extern fn gtk_color_selection_get_current_color(p_colorsel: *ColorSelection, p_color: *gdk.Color) void;
    pub const getCurrentColor = gtk_color_selection_get_current_color;

    /// Sets `rgba` to be the current color in the GtkColorSelection widget.
    extern fn gtk_color_selection_get_current_rgba(p_colorsel: *ColorSelection, p_rgba: *gdk.RGBA) void;
    pub const getCurrentRgba = gtk_color_selection_get_current_rgba;

    /// Determines whether the colorsel has an opacity control.
    extern fn gtk_color_selection_get_has_opacity_control(p_colorsel: *ColorSelection) c_int;
    pub const getHasOpacityControl = gtk_color_selection_get_has_opacity_control;

    /// Determines whether the color selector has a color palette.
    extern fn gtk_color_selection_get_has_palette(p_colorsel: *ColorSelection) c_int;
    pub const getHasPalette = gtk_color_selection_get_has_palette;

    /// Returns the previous alpha value.
    extern fn gtk_color_selection_get_previous_alpha(p_colorsel: *ColorSelection) u16;
    pub const getPreviousAlpha = gtk_color_selection_get_previous_alpha;

    /// Fills `color` in with the original color value.
    extern fn gtk_color_selection_get_previous_color(p_colorsel: *ColorSelection, p_color: *gdk.Color) void;
    pub const getPreviousColor = gtk_color_selection_get_previous_color;

    /// Fills `rgba` in with the original color value.
    extern fn gtk_color_selection_get_previous_rgba(p_colorsel: *ColorSelection, p_rgba: *gdk.RGBA) void;
    pub const getPreviousRgba = gtk_color_selection_get_previous_rgba;

    /// Gets the current state of the `colorsel`.
    extern fn gtk_color_selection_is_adjusting(p_colorsel: *ColorSelection) c_int;
    pub const isAdjusting = gtk_color_selection_is_adjusting;

    /// Sets the current opacity to be `alpha`.
    ///
    /// The first time this is called, it will also set
    /// the original opacity to be `alpha` too.
    extern fn gtk_color_selection_set_current_alpha(p_colorsel: *ColorSelection, p_alpha: u16) void;
    pub const setCurrentAlpha = gtk_color_selection_set_current_alpha;

    /// Sets the current color to be `color`.
    ///
    /// The first time this is called, it will also set
    /// the original color to be `color` too.
    extern fn gtk_color_selection_set_current_color(p_colorsel: *ColorSelection, p_color: *const gdk.Color) void;
    pub const setCurrentColor = gtk_color_selection_set_current_color;

    /// Sets the current color to be `rgba`.
    ///
    /// The first time this is called, it will also set
    /// the original color to be `rgba` too.
    extern fn gtk_color_selection_set_current_rgba(p_colorsel: *ColorSelection, p_rgba: *const gdk.RGBA) void;
    pub const setCurrentRgba = gtk_color_selection_set_current_rgba;

    /// Sets the `colorsel` to use or not use opacity.
    extern fn gtk_color_selection_set_has_opacity_control(p_colorsel: *ColorSelection, p_has_opacity: c_int) void;
    pub const setHasOpacityControl = gtk_color_selection_set_has_opacity_control;

    /// Shows and hides the palette based upon the value of `has_palette`.
    extern fn gtk_color_selection_set_has_palette(p_colorsel: *ColorSelection, p_has_palette: c_int) void;
    pub const setHasPalette = gtk_color_selection_set_has_palette;

    /// Sets the “previous” alpha to be `alpha`.
    ///
    /// This function should be called with some hesitations,
    /// as it might seem confusing to have that alpha change.
    extern fn gtk_color_selection_set_previous_alpha(p_colorsel: *ColorSelection, p_alpha: u16) void;
    pub const setPreviousAlpha = gtk_color_selection_set_previous_alpha;

    /// Sets the “previous” color to be `color`.
    ///
    /// This function should be called with some hesitations,
    /// as it might seem confusing to have that color change.
    /// Calling `gtk.ColorSelection.setCurrentColor` will also
    /// set this color the first time it is called.
    extern fn gtk_color_selection_set_previous_color(p_colorsel: *ColorSelection, p_color: *const gdk.Color) void;
    pub const setPreviousColor = gtk_color_selection_set_previous_color;

    /// Sets the “previous” color to be `rgba`.
    ///
    /// This function should be called with some hesitations,
    /// as it might seem confusing to have that color change.
    /// Calling `gtk.ColorSelection.setCurrentRgba` will also
    /// set this color the first time it is called.
    extern fn gtk_color_selection_set_previous_rgba(p_colorsel: *ColorSelection, p_rgba: *const gdk.RGBA) void;
    pub const setPreviousRgba = gtk_color_selection_set_previous_rgba;

    extern fn gtk_color_selection_get_type() usize;
    pub const getGObjectType = gtk_color_selection_get_type;

    extern fn g_object_ref(p_self: *gtk.ColorSelection) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ColorSelection) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ColorSelection, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ColorSelectionDialog = extern struct {
    pub const Parent = gtk.Dialog;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.ColorSelectionDialogClass;
    f_parent_instance: gtk.Dialog,
    f_priv: ?*gtk.ColorSelectionDialogPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const cancel_button = struct {
            pub const name = "cancel-button";

            pub const Type = ?*gtk.Widget;
        };

        pub const color_selection = struct {
            pub const name = "color-selection";

            pub const Type = ?*gtk.Widget;
        };

        pub const help_button = struct {
            pub const name = "help-button";

            pub const Type = ?*gtk.Widget;
        };

        pub const ok_button = struct {
            pub const name = "ok-button";

            pub const Type = ?*gtk.Widget;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.ColorSelectionDialog`.
    extern fn gtk_color_selection_dialog_new(p_title: [*:0]const u8) *gtk.ColorSelectionDialog;
    pub const new = gtk_color_selection_dialog_new;

    /// Retrieves the `gtk.ColorSelection` widget embedded in the dialog.
    extern fn gtk_color_selection_dialog_get_color_selection(p_colorsel: *ColorSelectionDialog) *gtk.Widget;
    pub const getColorSelection = gtk_color_selection_dialog_get_color_selection;

    extern fn gtk_color_selection_dialog_get_type() usize;
    pub const getGObjectType = gtk_color_selection_dialog_get_type;

    extern fn g_object_ref(p_self: *gtk.ColorSelectionDialog) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ColorSelectionDialog) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ColorSelectionDialog, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkComboBox is a widget that allows the user to choose from a list of
/// valid choices. The GtkComboBox displays the selected choice. When
/// activated, the GtkComboBox displays a popup which allows the user to
/// make a new choice. The style in which the selected value is displayed,
/// and the style of the popup is determined by the current theme. It may
/// be similar to a Windows-style combo box.
///
/// The GtkComboBox uses the model-view pattern; the list of valid choices
/// is specified in the form of a tree model, and the display of the choices
/// can be adapted to the data in the model by using cell renderers, as you
/// would in a tree view. This is possible since GtkComboBox implements the
/// `gtk.CellLayout` interface. The tree model holding the valid choices is
/// not restricted to a flat list, it can be a real tree, and the popup will
/// reflect the tree structure.
///
/// To allow the user to enter values not in the model, the “has-entry”
/// property allows the GtkComboBox to contain a `gtk.Entry`. This entry
/// can be accessed by calling `gtk.Bin.getChild` on the combo box.
///
/// For a simple list of textual choices, the model-view API of GtkComboBox
/// can be a bit overwhelming. In this case, `gtk.ComboBoxText` offers a
/// simple alternative. Both GtkComboBox and `gtk.ComboBoxText` can contain
/// an entry.
///
/// # CSS nodes
///
/// ```
/// combobox
/// ├── box.linked
/// │   ╰── button.combo
/// │       ╰── box
/// │           ├── cellview
/// │           ╰── arrow
/// ╰── window.popup
/// ```
///
/// A normal combobox contains a box with the .linked class, a button
/// with the .combo class and inside those buttons, there are a cellview and
/// an arrow.
///
/// ```
/// combobox
/// ├── box.linked
/// │   ├── entry.combo
/// │   ╰── button.combo
/// │       ╰── box
/// │           ╰── arrow
/// ╰── window.popup
/// ```
///
/// A GtkComboBox with an entry has a single CSS node with name combobox. It
/// contains a box with the .linked class. That box contains an entry and a
/// button, both with the .combo class added.
/// The button also contains another node with name arrow.
pub const ComboBox = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.CellEditable, gtk.CellLayout };
    pub const Class = gtk.ComboBoxClass;
    f_parent_instance: gtk.Bin,
    f_priv: ?*gtk.ComboBoxPrivate,

    pub const virtual_methods = struct {
        /// Signal is emitted when the active item is changed.
        pub const changed = struct {
            pub fn call(p_class: anytype, p_combo_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ComboBox.Class, p_class).f_changed.?(gobject.ext.as(ComboBox, p_combo_box));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_combo_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ComboBox.Class, p_class).f_changed = @ptrCast(p_implementation);
            }
        };

        /// Signal which allows you to change how the text
        ///    displayed in a combo box’s entry is displayed.
        pub const format_entry_text = struct {
            pub fn call(p_class: anytype, p_combo_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: [*:0]const u8) [*:0]u8 {
                return gobject.ext.as(ComboBox.Class, p_class).f_format_entry_text.?(gobject.ext.as(ComboBox, p_combo_box), p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_combo_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: [*:0]const u8) callconv(.c) [*:0]u8) void {
                gobject.ext.as(ComboBox.Class, p_class).f_format_entry_text = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The item which is currently active. If the model is a non-flat treemodel,
        /// and the active item is not an immediate child of the root of the tree,
        /// this property has the value
        /// `gtk_tree_path_get_indices (path)[0]`,
        /// where `path` is the `gtk.TreePath` of the active item.
        pub const active = struct {
            pub const name = "active";

            pub const Type = c_int;
        };

        /// The value of the ID column of the active row.
        pub const active_id = struct {
            pub const name = "active-id";

            pub const Type = ?[*:0]u8;
        };

        /// The add-tearoffs property controls whether generated menus
        /// have tearoff menu items.
        ///
        /// Note that this only affects menu style combo boxes.
        pub const add_tearoffs = struct {
            pub const name = "add-tearoffs";

            pub const Type = c_int;
        };

        /// Whether the dropdown button is sensitive when
        /// the model is empty.
        pub const button_sensitivity = struct {
            pub const name = "button-sensitivity";

            pub const Type = gtk.SensitivityType;
        };

        /// The `gtk.CellArea` used to layout cell renderers for this combo box.
        ///
        /// If no area is specified when creating the combo box with `gtk.ComboBox.newWithArea`
        /// a horizontally oriented `gtk.CellAreaBox` will be used.
        pub const cell_area = struct {
            pub const name = "cell-area";

            pub const Type = ?*gtk.CellArea;
        };

        /// If this is set to a non-negative value, it must be the index of a column
        /// of type `G_TYPE_INT` in the model. The value in that column for each item
        /// will determine how many columns that item will span in the popup.
        /// Therefore, values in this column must be greater than zero, and the sum of
        /// an item’s column position + span should not exceed `gtk.ComboBox.properties.wrap`-width.
        pub const column_span_column = struct {
            pub const name = "column-span-column";

            pub const Type = c_int;
        };

        /// The column in the combo box's model to associate with strings from the entry
        /// if the combo was created with `gtk.ComboBox.properties.has`-entry = `TRUE`.
        pub const entry_text_column = struct {
            pub const name = "entry-text-column";

            pub const Type = c_int;
        };

        /// Whether the combo box has an entry.
        pub const has_entry = struct {
            pub const name = "has-entry";

            pub const Type = c_int;
        };

        /// The has-frame property controls whether a frame
        /// is drawn around the entry.
        pub const has_frame = struct {
            pub const name = "has-frame";

            pub const Type = c_int;
        };

        /// The column in the combo box's model that provides string
        /// IDs for the values in the model, if != -1.
        pub const id_column = struct {
            pub const name = "id-column";

            pub const Type = c_int;
        };

        /// The model from which the combo box takes the values shown
        /// in the list.
        pub const model = struct {
            pub const name = "model";

            pub const Type = ?*gtk.TreeModel;
        };

        /// Whether the popup's width should be a fixed width matching the
        /// allocated width of the combo box.
        pub const popup_fixed_width = struct {
            pub const name = "popup-fixed-width";

            pub const Type = c_int;
        };

        /// Whether the combo boxes dropdown is popped up.
        /// Note that this property is mainly useful, because
        /// it allows you to connect to notify::popup-shown.
        pub const popup_shown = struct {
            pub const name = "popup-shown";

            pub const Type = c_int;
        };

        /// If this is set to a non-negative value, it must be the index of a column
        /// of type `G_TYPE_INT` in the model. The value in that column for each item
        /// will determine how many rows that item will span in the popup. Therefore,
        /// values in this column must be greater than zero.
        pub const row_span_column = struct {
            pub const name = "row-span-column";

            pub const Type = c_int;
        };

        /// A title that may be displayed by the window manager
        /// when the popup is torn-off.
        pub const tearoff_title = struct {
            pub const name = "tearoff-title";

            pub const Type = ?[*:0]u8;
        };

        /// If wrap-width is set to a positive value, items in the popup will be laid
        /// out along multiple columns, starting a new row on reaching the wrap width.
        pub const wrap_width = struct {
            pub const name = "wrap-width";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The changed signal is emitted when the active
        /// item is changed. The can be due to the user selecting
        /// a different item from the list, or due to a
        /// call to `gtk.ComboBox.setActiveIter`.
        /// It will also be emitted while typing into the entry of a combo box
        /// with an entry.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ComboBox, p_instance))),
                    gobject.signalLookup("changed", ComboBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// For combo boxes that are created with an entry (See GtkComboBox:has-entry).
        ///
        /// A signal which allows you to change how the text displayed in a combo box's
        /// entry is displayed.
        ///
        /// Connect a signal handler which returns an allocated string representing
        /// `path`. That string will then be used to set the text in the combo box's entry.
        /// The default signal handler uses the text from the GtkComboBox::entry-text-column
        /// model column.
        ///
        /// Here's an example signal handler which fetches data from the model and
        /// displays it in the entry.
        /// ```
        /// static gchar*
        /// format_entry_text_callback (GtkComboBox *combo,
        ///                             const gchar *path,
        ///                             gpointer     user_data)
        /// {
        ///   GtkTreeIter iter;
        ///   GtkTreeModel model;
        ///   gdouble      value;
        ///
        ///   model = gtk_combo_box_get_model (combo);
        ///
        ///   gtk_tree_model_get_iter_from_string (model, &iter, path);
        ///   gtk_tree_model_get (model, &iter,
        ///                       THE_DOUBLE_VALUE_COLUMN, &value,
        ///                       -1);
        ///
        ///   return g_strdup_printf ("`g`", value);
        /// }
        /// ```
        pub const format_entry_text = struct {
            pub const name = "format-entry-text";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_path: [*:0]u8, P_Data) callconv(.c) [*:0]u8, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ComboBox, p_instance))),
                    gobject.signalLookup("format-entry-text", ComboBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::move-active signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to move the active selection.
        pub const move_active = struct {
            pub const name = "move-active";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_scroll_type: gtk.ScrollType, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ComboBox, p_instance))),
                    gobject.signalLookup("move-active", ComboBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::popdown signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to popdown the combo box list.
        ///
        /// The default bindings for this signal are Alt+Up and Escape.
        pub const popdown = struct {
            pub const name = "popdown";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ComboBox, p_instance))),
                    gobject.signalLookup("popdown", ComboBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::popup signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to popup the combo box list.
        ///
        /// The default binding for this signal is Alt+Down.
        pub const popup = struct {
            pub const name = "popup";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ComboBox, p_instance))),
                    gobject.signalLookup("popup", ComboBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new empty `gtk.ComboBox`.
    extern fn gtk_combo_box_new() *gtk.ComboBox;
    pub const new = gtk_combo_box_new;

    /// Creates a new empty `gtk.ComboBox` using `area` to layout cells.
    extern fn gtk_combo_box_new_with_area(p_area: *gtk.CellArea) *gtk.ComboBox;
    pub const newWithArea = gtk_combo_box_new_with_area;

    /// Creates a new empty `gtk.ComboBox` with an entry.
    ///
    /// The new combo box will use `area` to layout cells.
    extern fn gtk_combo_box_new_with_area_and_entry(p_area: *gtk.CellArea) *gtk.ComboBox;
    pub const newWithAreaAndEntry = gtk_combo_box_new_with_area_and_entry;

    /// Creates a new empty `gtk.ComboBox` with an entry.
    extern fn gtk_combo_box_new_with_entry() *gtk.ComboBox;
    pub const newWithEntry = gtk_combo_box_new_with_entry;

    /// Creates a new `gtk.ComboBox` with the model initialized to `model`.
    extern fn gtk_combo_box_new_with_model(p_model: *gtk.TreeModel) *gtk.ComboBox;
    pub const newWithModel = gtk_combo_box_new_with_model;

    /// Creates a new empty `gtk.ComboBox` with an entry
    /// and with the model initialized to `model`.
    extern fn gtk_combo_box_new_with_model_and_entry(p_model: *gtk.TreeModel) *gtk.ComboBox;
    pub const newWithModelAndEntry = gtk_combo_box_new_with_model_and_entry;

    /// Returns the index of the currently active item, or -1 if there’s no
    /// active item. If the model is a non-flat treemodel, and the active item
    /// is not an immediate child of the root of the tree, this function returns
    /// `gtk_tree_path_get_indices (path)[0]`, where
    /// `path` is the `gtk.TreePath` of the active item.
    extern fn gtk_combo_box_get_active(p_combo_box: *ComboBox) c_int;
    pub const getActive = gtk_combo_box_get_active;

    /// Returns the ID of the active row of `combo_box`.  This value is taken
    /// from the active row and the column specified by the `gtk.ComboBox.properties.id`-column
    /// property of `combo_box` (see `gtk.ComboBox.setIdColumn`).
    ///
    /// The returned value is an interned string which means that you can
    /// compare the pointer by value to other interned strings and that you
    /// must not free it.
    ///
    /// If the `gtk.ComboBox.properties.id`-column property of `combo_box` is not set, or if
    /// no row is active, or if the active row has a `NULL` ID value, then `NULL`
    /// is returned.
    extern fn gtk_combo_box_get_active_id(p_combo_box: *ComboBox) ?[*:0]const u8;
    pub const getActiveId = gtk_combo_box_get_active_id;

    /// Sets `iter` to point to the currently active item, if any item is active.
    /// Otherwise, `iter` is left unchanged.
    extern fn gtk_combo_box_get_active_iter(p_combo_box: *ComboBox, p_iter: *gtk.TreeIter) c_int;
    pub const getActiveIter = gtk_combo_box_get_active_iter;

    /// Gets the current value of the :add-tearoffs property.
    extern fn gtk_combo_box_get_add_tearoffs(p_combo_box: *ComboBox) c_int;
    pub const getAddTearoffs = gtk_combo_box_get_add_tearoffs;

    /// Returns whether the combo box sets the dropdown button
    /// sensitive or not when there are no items in the model.
    extern fn gtk_combo_box_get_button_sensitivity(p_combo_box: *ComboBox) gtk.SensitivityType;
    pub const getButtonSensitivity = gtk_combo_box_get_button_sensitivity;

    /// Returns the column with column span information for `combo_box`.
    extern fn gtk_combo_box_get_column_span_column(p_combo_box: *ComboBox) c_int;
    pub const getColumnSpanColumn = gtk_combo_box_get_column_span_column;

    /// Returns the column which `combo_box` is using to get the strings
    /// from to display in the internal entry.
    extern fn gtk_combo_box_get_entry_text_column(p_combo_box: *ComboBox) c_int;
    pub const getEntryTextColumn = gtk_combo_box_get_entry_text_column;

    /// Returns whether the combo box grabs focus when it is clicked
    /// with the mouse. See `gtk.ComboBox.setFocusOnClick`.
    extern fn gtk_combo_box_get_focus_on_click(p_combo: *ComboBox) c_int;
    pub const getFocusOnClick = gtk_combo_box_get_focus_on_click;

    /// Returns whether the combo box has an entry.
    extern fn gtk_combo_box_get_has_entry(p_combo_box: *ComboBox) c_int;
    pub const getHasEntry = gtk_combo_box_get_has_entry;

    /// Returns the column which `combo_box` is using to get string IDs
    /// for values from.
    extern fn gtk_combo_box_get_id_column(p_combo_box: *ComboBox) c_int;
    pub const getIdColumn = gtk_combo_box_get_id_column;

    /// Returns the `gtk.TreeModel` which is acting as data source for `combo_box`.
    extern fn gtk_combo_box_get_model(p_combo_box: *ComboBox) *gtk.TreeModel;
    pub const getModel = gtk_combo_box_get_model;

    /// Gets the accessible object corresponding to the combo box’s popup.
    ///
    /// This function is mostly intended for use by accessibility technologies;
    /// applications should have little use for it.
    extern fn gtk_combo_box_get_popup_accessible(p_combo_box: *ComboBox) *atk.Object;
    pub const getPopupAccessible = gtk_combo_box_get_popup_accessible;

    /// Gets whether the popup uses a fixed width matching
    /// the allocated width of the combo box.
    extern fn gtk_combo_box_get_popup_fixed_width(p_combo_box: *ComboBox) c_int;
    pub const getPopupFixedWidth = gtk_combo_box_get_popup_fixed_width;

    /// Returns the current row separator function.
    extern fn gtk_combo_box_get_row_separator_func(p_combo_box: *ComboBox) gtk.TreeViewRowSeparatorFunc;
    pub const getRowSeparatorFunc = gtk_combo_box_get_row_separator_func;

    /// Returns the column with row span information for `combo_box`.
    extern fn gtk_combo_box_get_row_span_column(p_combo_box: *ComboBox) c_int;
    pub const getRowSpanColumn = gtk_combo_box_get_row_span_column;

    /// Gets the current title of the menu in tearoff mode. See
    /// `gtk.ComboBox.setAddTearoffs`.
    extern fn gtk_combo_box_get_title(p_combo_box: *ComboBox) [*:0]const u8;
    pub const getTitle = gtk_combo_box_get_title;

    /// Returns the wrap width which is used to determine the number of columns
    /// for the popup menu. If the wrap width is larger than 1, the combo box
    /// is in table mode.
    extern fn gtk_combo_box_get_wrap_width(p_combo_box: *ComboBox) c_int;
    pub const getWrapWidth = gtk_combo_box_get_wrap_width;

    /// Hides the menu or dropdown list of `combo_box`.
    ///
    /// This function is mostly intended for use by accessibility technologies;
    /// applications should have little use for it.
    extern fn gtk_combo_box_popdown(p_combo_box: *ComboBox) void;
    pub const popdown = gtk_combo_box_popdown;

    /// Pops up the menu or dropdown list of `combo_box`.
    ///
    /// This function is mostly intended for use by accessibility technologies;
    /// applications should have little use for it.
    ///
    /// Before calling this, `combo_box` must be mapped, or nothing will happen.
    extern fn gtk_combo_box_popup(p_combo_box: *ComboBox) void;
    pub const popup = gtk_combo_box_popup;

    /// Pops up the menu or dropdown list of `combo_box`, the popup window
    /// will be grabbed so only `device` and its associated pointer/keyboard
    /// are the only `GdkDevices` able to send events to it.
    extern fn gtk_combo_box_popup_for_device(p_combo_box: *ComboBox, p_device: *gdk.Device) void;
    pub const popupForDevice = gtk_combo_box_popup_for_device;

    /// Sets the active item of `combo_box` to be the item at `index`.
    extern fn gtk_combo_box_set_active(p_combo_box: *ComboBox, p_index_: c_int) void;
    pub const setActive = gtk_combo_box_set_active;

    /// Changes the active row of `combo_box` to the one that has an ID equal to
    /// `active_id`, or unsets the active row if `active_id` is `NULL`.  Rows having
    /// a `NULL` ID string cannot be made active by this function.
    ///
    /// If the `gtk.ComboBox.properties.id`-column property of `combo_box` is unset or if no
    /// row has the given ID then the function does nothing and returns `FALSE`.
    extern fn gtk_combo_box_set_active_id(p_combo_box: *ComboBox, p_active_id: ?[*:0]const u8) c_int;
    pub const setActiveId = gtk_combo_box_set_active_id;

    /// Sets the current active item to be the one referenced by `iter`, or
    /// unsets the active item if `iter` is `NULL`.
    extern fn gtk_combo_box_set_active_iter(p_combo_box: *ComboBox, p_iter: ?*gtk.TreeIter) void;
    pub const setActiveIter = gtk_combo_box_set_active_iter;

    /// Sets whether the popup menu should have a tearoff
    /// menu item.
    extern fn gtk_combo_box_set_add_tearoffs(p_combo_box: *ComboBox, p_add_tearoffs: c_int) void;
    pub const setAddTearoffs = gtk_combo_box_set_add_tearoffs;

    /// Sets whether the dropdown button of the combo box should be
    /// always sensitive (`GTK_SENSITIVITY_ON`), never sensitive (`GTK_SENSITIVITY_OFF`)
    /// or only if there is at least one item to display (`GTK_SENSITIVITY_AUTO`).
    extern fn gtk_combo_box_set_button_sensitivity(p_combo_box: *ComboBox, p_sensitivity: gtk.SensitivityType) void;
    pub const setButtonSensitivity = gtk_combo_box_set_button_sensitivity;

    /// Sets the column with column span information for `combo_box` to be
    /// `column_span`. The column span column contains integers which indicate
    /// how many columns an item should span.
    extern fn gtk_combo_box_set_column_span_column(p_combo_box: *ComboBox, p_column_span: c_int) void;
    pub const setColumnSpanColumn = gtk_combo_box_set_column_span_column;

    /// Sets the model column which `combo_box` should use to get strings from
    /// to be `text_column`. The column `text_column` in the model of `combo_box`
    /// must be of type `G_TYPE_STRING`.
    ///
    /// This is only relevant if `combo_box` has been created with
    /// `gtk.ComboBox.properties.has`-entry as `TRUE`.
    extern fn gtk_combo_box_set_entry_text_column(p_combo_box: *ComboBox, p_text_column: c_int) void;
    pub const setEntryTextColumn = gtk_combo_box_set_entry_text_column;

    /// Sets whether the combo box will grab focus when it is clicked with
    /// the mouse. Making mouse clicks not grab focus is useful in places
    /// like toolbars where you don’t want the keyboard focus removed from
    /// the main area of the application.
    extern fn gtk_combo_box_set_focus_on_click(p_combo: *ComboBox, p_focus_on_click: c_int) void;
    pub const setFocusOnClick = gtk_combo_box_set_focus_on_click;

    /// Sets the model column which `combo_box` should use to get string IDs
    /// for values from. The column `id_column` in the model of `combo_box`
    /// must be of type `G_TYPE_STRING`.
    extern fn gtk_combo_box_set_id_column(p_combo_box: *ComboBox, p_id_column: c_int) void;
    pub const setIdColumn = gtk_combo_box_set_id_column;

    /// Sets the model used by `combo_box` to be `model`. Will unset a previously set
    /// model (if applicable). If model is `NULL`, then it will unset the model.
    ///
    /// Note that this function does not clear the cell renderers, you have to
    /// call `gtk.CellLayout.clear` yourself if you need to set up different
    /// cell renderers for the new model.
    extern fn gtk_combo_box_set_model(p_combo_box: *ComboBox, p_model: ?*gtk.TreeModel) void;
    pub const setModel = gtk_combo_box_set_model;

    /// Specifies whether the popup’s width should be a fixed width
    /// matching the allocated width of the combo box.
    extern fn gtk_combo_box_set_popup_fixed_width(p_combo_box: *ComboBox, p_fixed: c_int) void;
    pub const setPopupFixedWidth = gtk_combo_box_set_popup_fixed_width;

    /// Sets the row separator function, which is used to determine
    /// whether a row should be drawn as a separator. If the row separator
    /// function is `NULL`, no separators are drawn. This is the default value.
    extern fn gtk_combo_box_set_row_separator_func(p_combo_box: *ComboBox, p_func: gtk.TreeViewRowSeparatorFunc, p_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setRowSeparatorFunc = gtk_combo_box_set_row_separator_func;

    /// Sets the column with row span information for `combo_box` to be `row_span`.
    /// The row span column contains integers which indicate how many rows
    /// an item should span.
    extern fn gtk_combo_box_set_row_span_column(p_combo_box: *ComboBox, p_row_span: c_int) void;
    pub const setRowSpanColumn = gtk_combo_box_set_row_span_column;

    /// Sets the menu’s title in tearoff mode.
    extern fn gtk_combo_box_set_title(p_combo_box: *ComboBox, p_title: [*:0]const u8) void;
    pub const setTitle = gtk_combo_box_set_title;

    /// Sets the wrap width of `combo_box` to be `width`. The wrap width is basically
    /// the preferred number of columns when you want the popup to be layed out
    /// in a table.
    extern fn gtk_combo_box_set_wrap_width(p_combo_box: *ComboBox, p_width: c_int) void;
    pub const setWrapWidth = gtk_combo_box_set_wrap_width;

    extern fn gtk_combo_box_get_type() usize;
    pub const getGObjectType = gtk_combo_box_get_type;

    extern fn g_object_ref(p_self: *gtk.ComboBox) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ComboBox) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ComboBox, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ComboBoxAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.Selection };
    pub const Class = gtk.ComboBoxAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.ComboBoxAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_combo_box_accessible_get_type() usize;
    pub const getGObjectType = gtk_combo_box_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ComboBoxAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ComboBoxAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ComboBoxAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkComboBoxText is a simple variant of `gtk.ComboBox` that hides
/// the model-view complexity for simple text-only use cases.
///
/// To create a GtkComboBoxText, use `gtk.ComboBoxText.new` or
/// `gtk.ComboBoxText.newWithEntry`.
///
/// You can add items to a GtkComboBoxText with
/// `gtk.ComboBoxText.appendText`, `gtk.ComboBoxText.insertText`
/// or `gtk.ComboBoxText.prependText` and remove options with
/// `gtk.ComboBoxText.remove`.
///
/// If the GtkComboBoxText contains an entry (via the “has-entry” property),
/// its contents can be retrieved using `gtk.ComboBoxText.getActiveText`.
/// The entry itself can be accessed by calling `gtk.Bin.getChild` on the
/// combo box.
///
/// You should not call `gtk.ComboBox.setModel` or attempt to pack more cells
/// into this combo box via its GtkCellLayout interface.
///
/// # GtkComboBoxText as GtkBuildable
///
/// The GtkComboBoxText implementation of the GtkBuildable interface supports
/// adding items directly using the `<items>` element and specifying `<item>`
/// elements for each item. Each `<item>` element can specify the “id”
/// corresponding to the appended text and also supports the regular
/// translation attributes “translatable”, “context” and “comments”.
///
/// Here is a UI definition fragment specifying GtkComboBoxText items:
///
/// ```
/// <object class="GtkComboBoxText">
///   <items>
///     <item translatable="yes" id="factory">Factory</item>
///     <item translatable="yes" id="home">Home</item>
///     <item translatable="yes" id="subway">Subway</item>
///   </items>
/// </object>
/// ```
///
/// # CSS nodes
///
/// ```
/// combobox
/// ╰── box.linked
///     ├── entry.combo
///     ├── button.combo
///     ╰── window.popup
/// ```
///
/// GtkComboBoxText has a single CSS node with name combobox. It adds
/// the style class .combo to the main CSS nodes of its entry and button
/// children, and the .linked class to the node of its internal box.
pub const ComboBoxText = extern struct {
    pub const Parent = gtk.ComboBox;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.CellEditable, gtk.CellLayout };
    pub const Class = gtk.ComboBoxTextClass;
    f_parent_instance: gtk.ComboBox,
    f_priv: ?*gtk.ComboBoxTextPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.ComboBoxText`, which is a `gtk.ComboBox` just displaying
    /// strings.
    extern fn gtk_combo_box_text_new() *gtk.ComboBoxText;
    pub const new = gtk_combo_box_text_new;

    /// Creates a new `gtk.ComboBoxText`, which is a `gtk.ComboBox` just displaying
    /// strings. The combo box created by this function has an entry.
    extern fn gtk_combo_box_text_new_with_entry() *gtk.ComboBoxText;
    pub const newWithEntry = gtk_combo_box_text_new_with_entry;

    /// Appends `text` to the list of strings stored in `combo_box`.
    /// If `id` is non-`NULL` then it is used as the ID of the row.
    ///
    /// This is the same as calling `gtk.ComboBoxText.insert` with a
    /// position of -1.
    extern fn gtk_combo_box_text_append(p_combo_box: *ComboBoxText, p_id: ?[*:0]const u8, p_text: [*:0]const u8) void;
    pub const append = gtk_combo_box_text_append;

    /// Appends `text` to the list of strings stored in `combo_box`.
    ///
    /// This is the same as calling `gtk.ComboBoxText.insertText` with a
    /// position of -1.
    extern fn gtk_combo_box_text_append_text(p_combo_box: *ComboBoxText, p_text: [*:0]const u8) void;
    pub const appendText = gtk_combo_box_text_append_text;

    /// Returns the currently active string in `combo_box`, or `NULL`
    /// if none is selected. If `combo_box` contains an entry, this
    /// function will return its contents (which will not necessarily
    /// be an item from the list).
    extern fn gtk_combo_box_text_get_active_text(p_combo_box: *ComboBoxText) [*:0]u8;
    pub const getActiveText = gtk_combo_box_text_get_active_text;

    /// Inserts `text` at `position` in the list of strings stored in `combo_box`.
    /// If `id` is non-`NULL` then it is used as the ID of the row.  See
    /// `gtk.ComboBox.properties.id`-column.
    ///
    /// If `position` is negative then `text` is appended.
    extern fn gtk_combo_box_text_insert(p_combo_box: *ComboBoxText, p_position: c_int, p_id: ?[*:0]const u8, p_text: [*:0]const u8) void;
    pub const insert = gtk_combo_box_text_insert;

    /// Inserts `text` at `position` in the list of strings stored in `combo_box`.
    ///
    /// If `position` is negative then `text` is appended.
    ///
    /// This is the same as calling `gtk.ComboBoxText.insert` with a `NULL`
    /// ID string.
    extern fn gtk_combo_box_text_insert_text(p_combo_box: *ComboBoxText, p_position: c_int, p_text: [*:0]const u8) void;
    pub const insertText = gtk_combo_box_text_insert_text;

    /// Prepends `text` to the list of strings stored in `combo_box`.
    /// If `id` is non-`NULL` then it is used as the ID of the row.
    ///
    /// This is the same as calling `gtk.ComboBoxText.insert` with a
    /// position of 0.
    extern fn gtk_combo_box_text_prepend(p_combo_box: *ComboBoxText, p_id: ?[*:0]const u8, p_text: [*:0]const u8) void;
    pub const prepend = gtk_combo_box_text_prepend;

    /// Prepends `text` to the list of strings stored in `combo_box`.
    ///
    /// This is the same as calling `gtk.ComboBoxText.insertText` with a
    /// position of 0.
    extern fn gtk_combo_box_text_prepend_text(p_combo_box: *ComboBoxText, p_text: [*:0]const u8) void;
    pub const prependText = gtk_combo_box_text_prepend_text;

    /// Removes the string at `position` from `combo_box`.
    extern fn gtk_combo_box_text_remove(p_combo_box: *ComboBoxText, p_position: c_int) void;
    pub const remove = gtk_combo_box_text_remove;

    /// Removes all the text entries from the combo box.
    extern fn gtk_combo_box_text_remove_all(p_combo_box: *ComboBoxText) void;
    pub const removeAll = gtk_combo_box_text_remove_all;

    extern fn gtk_combo_box_text_get_type() usize;
    pub const getGObjectType = gtk_combo_box_text_get_type;

    extern fn g_object_ref(p_self: *gtk.ComboBoxText) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ComboBoxText) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ComboBoxText, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GTK+ user interface is constructed by nesting widgets inside widgets.
/// Container widgets are the inner nodes in the resulting tree of widgets:
/// they contain other widgets. So, for example, you might have a `gtk.Window`
/// containing a `gtk.Frame` containing a `gtk.Label`. If you wanted an image instead
/// of a textual label inside the frame, you might replace the `gtk.Label` widget
/// with a `gtk.Image` widget.
///
/// There are two major kinds of container widgets in GTK+. Both are subclasses
/// of the abstract GtkContainer base class.
///
/// The first type of container widget has a single child widget and derives
/// from `gtk.Bin`. These containers are decorators, which
/// add some kind of functionality to the child. For example, a `gtk.Button` makes
/// its child into a clickable button; a `gtk.Frame` draws a frame around its child
/// and a `gtk.Window` places its child widget inside a top-level window.
///
/// The second type of container can have more than one child; its purpose is to
/// manage layout. This means that these containers assign
/// sizes and positions to their children. For example, a `gtk.HBox` arranges its
/// children in a horizontal row, and a `gtk.Grid` arranges the widgets it contains
/// in a two-dimensional grid.
///
/// For implementations of `gtk.Container` the virtual method `gtk.ContainerClass.virtual_methods.forall`
/// is always required, since it's used for drawing and other internal operations
/// on the children.
/// If the `gtk.Container` implementation expect to have non internal children
/// it's needed to implement both `gtk.ContainerClass.virtual_methods.add` and `gtk.ContainerClass.virtual_methods.remove`.
/// If the GtkContainer implementation has internal children, they should be added
/// with `gtk.Widget.setParent` on `init` and removed with `gtk.Widget.unparent`
/// in the `gtk.WidgetClass.virtual_methods.destroy` implementation.
/// See more about implementing custom widgets at https://wiki.gnome.org/HowDoI/CustomWidgets
///
/// # Height for width geometry management
///
/// GTK+ uses a height-for-width (and width-for-height) geometry management system.
/// Height-for-width means that a widget can change how much vertical space it needs,
/// depending on the amount of horizontal space that it is given (and similar for
/// width-for-height).
///
/// There are some things to keep in mind when implementing container widgets
/// that make use of GTK+’s height for width geometry management system. First,
/// it’s important to note that a container must prioritize one of its
/// dimensions, that is to say that a widget or container can only have a
/// `gtk.SizeRequestMode` that is `GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH` or
/// `GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT`. However, every widget and container
/// must be able to respond to the APIs for both dimensions, i.e. even if a
/// widget has a request mode that is height-for-width, it is possible that
/// its parent will request its sizes using the width-for-height APIs.
///
/// To ensure that everything works properly, here are some guidelines to follow
/// when implementing height-for-width (or width-for-height) containers.
///
/// Each request mode involves 2 virtual methods. Height-for-width apis run
/// through `gtk.Widget.getPreferredWidth` and then through `gtk.Widget.getPreferredHeightForWidth`.
/// When handling requests in the opposite `gtk.SizeRequestMode` it is important that
/// every widget request at least enough space to display all of its content at all times.
///
/// When `gtk.Widget.getPreferredHeight` is called on a container that is height-for-width,
/// the container must return the height for its minimum width. This is easily achieved by
/// simply calling the reverse apis implemented for itself as follows:
///
/// ```
/// static void
/// foo_container_get_preferred_height (GtkWidget *widget,
///                                     gint *min_height,
///                                     gint *nat_height)
/// {
///    if (i_am_in_height_for_width_mode)
///      {
///        gint min_width;
///
///        GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
///                                                            &min_width,
///                                                            NULL);
///        GTK_WIDGET_GET_CLASS (widget)->get_preferred_height_for_width
///                                                           (widget,
///                                                            min_width,
///                                                            min_height,
///                                                            nat_height);
///      }
///    else
///      {
///        ... many containers support both request modes, execute the
///        real width-for-height request here by returning the
///        collective heights of all widgets that are stacked
///        vertically (or whatever is appropriate for this container)
///        ...
///      }
/// }
/// ```
///
/// Similarly, when `gtk.Widget.getPreferredWidthForHeight` is called for a container or widget
/// that is height-for-width, it then only needs to return the base minimum width like so:
///
/// ```
/// static void
/// foo_container_get_preferred_width_for_height (GtkWidget *widget,
///                                               gint for_height,
///                                               gint *min_width,
///                                               gint *nat_width)
/// {
///    if (i_am_in_height_for_width_mode)
///      {
///        GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
///                                                            min_width,
///                                                            nat_width);
///      }
///    else
///      {
///        ... execute the real width-for-height request here based on
///        the required width of the children collectively if the
///        container were to be allocated the said height ...
///      }
/// }
/// ```
///
/// Height for width requests are generally implemented in terms of a virtual allocation
/// of widgets in the input orientation. Assuming an height-for-width request mode, a container
/// would implement the `get_preferred_height_for_width` virtual function by first calling
/// `gtk.Widget.getPreferredWidth` for each of its children.
///
/// For each potential group of children that are lined up horizontally, the values returned by
/// `gtk.Widget.getPreferredWidth` should be collected in an array of `gtk.RequestedSize` structures.
/// Any child spacing should be removed from the input `for_width` and then the collective size should be
/// allocated using the `gtk.distributeNaturalAllocation` convenience function.
///
/// The container will then move on to request the preferred height for each child by using
/// `gtk.Widget.getPreferredHeightForWidth` and using the sizes stored in the `gtk.RequestedSize` array.
///
/// To allocate a height-for-width container, it’s again important
/// to consider that a container must prioritize one dimension over the other. So if
/// a container is a height-for-width container it must first allocate all widgets horizontally
/// using a `gtk.RequestedSize` array and `gtk.distributeNaturalAllocation` and then add any
/// extra space (if and where appropriate) for the widget to expand.
///
/// After adding all the expand space, the container assumes it was allocated sufficient
/// height to fit all of its content. At this time, the container must use the total horizontal sizes
/// of each widget to request the height-for-width of each of its children and store the requests in a
/// `gtk.RequestedSize` array for any widgets that stack vertically (for tabular containers this can
/// be generalized into the heights and widths of rows and columns).
/// The vertical space must then again be distributed using `gtk.distributeNaturalAllocation`
/// while this time considering the allocated height of the widget minus any vertical spacing
/// that the container adds. Then vertical expand space should be added where appropriate and available
/// and the container should go on to actually allocating the child widgets.
///
/// See [GtkWidget’s geometry management section][geometry-management]
/// to learn more about implementing height-for-width geometry management for widgets.
///
/// # Child properties
///
/// GtkContainer introduces child properties.
/// These are object properties that are not specific
/// to either the container or the contained widget, but rather to their relation.
/// Typical examples of child properties are the position or pack-type of a widget
/// which is contained in a `gtk.Box`.
///
/// Use `gtk.ContainerClass.installChildProperty` to install child properties
/// for a container class and `gtk.ContainerClass.findChildProperty` or
/// `gtk.ContainerClass.listChildProperties` to get information about existing
/// child properties.
///
/// To set the value of a child property, use `gtk.Container.childSetProperty`,
/// `gtk.Container.childSet` or `gtk.Container.childSetValist`.
/// To obtain the value of a child property, use
/// `gtk.Container.childGetProperty`, `gtk.Container.childGet` or
/// `gtk.Container.childGetValist`. To emit notification about child property
/// changes, use `gtk.Widget.childNotify`.
///
/// # GtkContainer as GtkBuildable
///
/// The GtkContainer implementation of the GtkBuildable interface supports
/// a `<packing>` element for children, which can contain multiple `<property>`
/// elements that specify child properties for the child.
///
/// Since 2.16, child properties can also be marked as translatable using
/// the same “translatable”, “comments” and “context” attributes that are used
/// for regular properties.
///
/// Since 3.16, containers can have a `<focus-chain>` element containing multiple
/// `<widget>` elements, one for each child that should be added to the focus
/// chain. The ”name” attribute gives the id of the widget.
///
/// An example of these properties in UI definitions:
///
/// ```
/// <object class="GtkBox">
///   <child>
///     <object class="GtkEntry" id="entry1"/>
///     <packing>
///       <property name="pack-type">start</property>
///     </packing>
///   </child>
///   <child>
///     <object class="GtkEntry" id="entry2"/>
///   </child>
///   <focus-chain>
///     <widget name="entry1"/>
///     <widget name="entry2"/>
///   </focus-chain>
/// </object>
/// ```
pub const Container = extern struct {
    pub const Parent = gtk.Widget;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.ContainerClass;
    f_widget: gtk.Widget,
    f_priv: ?*gtk.ContainerPrivate,

    pub const virtual_methods = struct {
        /// Adds `widget` to `container`. Typically used for simple containers
        /// such as `gtk.Window`, `gtk.Frame`, or `gtk.Button`; for more complicated
        /// layout containers such as `gtk.Box` or `gtk.Grid`, this function will
        /// pick default packing parameters that may not be correct.  So
        /// consider functions such as `gtk.Box.packStart` and
        /// `gtk.Grid.attach` as an alternative to `gtk.Container.add` in
        /// those cases. A widget may be added to only one container at a time;
        /// you can’t place the same widget inside two different containers.
        ///
        /// Note that some containers, such as `gtk.ScrolledWindow` or `gtk.ListBox`,
        /// may add intermediate children between the added widget and the
        /// container.
        pub const add = struct {
            pub fn call(p_class: anytype, p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget) void {
                return gobject.ext.as(Container.Class, p_class).f_add.?(gobject.ext.as(Container, p_container), p_widget);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(Container.Class, p_class).f_add = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when a size recalculation is needed.
        pub const check_resize = struct {
            pub fn call(p_class: anytype, p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Container.Class, p_class).f_check_resize.?(gobject.ext.as(Container, p_container));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Container.Class, p_class).f_check_resize = @ptrCast(p_implementation);
            }
        };

        /// Returns the type of the children supported by the container.
        ///
        /// Note that this may return `G_TYPE_NONE` to indicate that no more
        /// children can be added, e.g. for a `gtk.Paned` which already has two
        /// children.
        pub const child_type = struct {
            pub fn call(p_class: anytype, p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) usize {
                return gobject.ext.as(Container.Class, p_class).f_child_type.?(gobject.ext.as(Container, p_container));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) usize) void {
                gobject.ext.as(Container.Class, p_class).f_child_type = @ptrCast(p_implementation);
            }
        };

        /// Gets a widget’s composite name. Deprecated: 3.10.
        pub const composite_name = struct {
            pub fn call(p_class: anytype, p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget) [*:0]u8 {
                return gobject.ext.as(Container.Class, p_class).f_composite_name.?(gobject.ext.as(Container, p_container), p_child);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget) callconv(.c) [*:0]u8) void {
                gobject.ext.as(Container.Class, p_class).f_composite_name = @ptrCast(p_implementation);
            }
        };

        /// Invokes `callback` on each direct child of `container`, including
        /// children that are considered “internal” (implementation details
        /// of the container). “Internal” children generally weren’t added
        /// by the user of the container, but were added by the container
        /// implementation itself.
        ///
        /// Most applications should use `gtk.Container.foreach`, rather
        /// than `gtk.Container.forall`.
        pub const forall = struct {
            pub fn call(p_class: anytype, p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_include_internals: c_int, p_callback: gtk.Callback, p_callback_data: ?*anyopaque) void {
                return gobject.ext.as(Container.Class, p_class).f_forall.?(gobject.ext.as(Container, p_container), p_include_internals, p_callback, p_callback_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_include_internals: c_int, p_callback: gtk.Callback, p_callback_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Container.Class, p_class).f_forall = @ptrCast(p_implementation);
            }
        };

        /// Get a property from a child of container.
        pub const get_child_property = struct {
            pub fn call(p_class: anytype, p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget, p_property_id: c_uint, p_value: *gobject.Value, p_pspec: *gobject.ParamSpec) void {
                return gobject.ext.as(Container.Class, p_class).f_get_child_property.?(gobject.ext.as(Container, p_container), p_child, p_property_id, p_value, p_pspec);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget, p_property_id: c_uint, p_value: *gobject.Value, p_pspec: *gobject.ParamSpec) callconv(.c) void) void {
                gobject.ext.as(Container.Class, p_class).f_get_child_property = @ptrCast(p_implementation);
            }
        };

        /// Returns a newly created widget path representing all the widget hierarchy
        /// from the toplevel down to and including `child`.
        pub const get_path_for_child = struct {
            pub fn call(p_class: anytype, p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget) *gtk.WidgetPath {
                return gobject.ext.as(Container.Class, p_class).f_get_path_for_child.?(gobject.ext.as(Container, p_container), p_child);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget) callconv(.c) *gtk.WidgetPath) void {
                gobject.ext.as(Container.Class, p_class).f_get_path_for_child = @ptrCast(p_implementation);
            }
        };

        /// Removes `widget` from `container`. `widget` must be inside `container`.
        /// Note that `container` will own a reference to `widget`, and that this
        /// may be the last reference held; so removing a widget from its
        /// container can destroy that widget. If you want to use `widget`
        /// again, you need to add a reference to it before removing it from
        /// a container, using `gobject.Object.ref`. If you don’t want to use `widget`
        /// again it’s usually more efficient to simply destroy it directly
        /// using `gtk.Widget.destroy` since this will remove it from the
        /// container and help break any circular reference count cycles.
        pub const remove = struct {
            pub fn call(p_class: anytype, p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget) void {
                return gobject.ext.as(Container.Class, p_class).f_remove.?(gobject.ext.as(Container, p_container), p_widget);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(Container.Class, p_class).f_remove = @ptrCast(p_implementation);
            }
        };

        /// Set a property on a child of container.
        pub const set_child_property = struct {
            pub fn call(p_class: anytype, p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget, p_property_id: c_uint, p_value: *const gobject.Value, p_pspec: *gobject.ParamSpec) void {
                return gobject.ext.as(Container.Class, p_class).f_set_child_property.?(gobject.ext.as(Container, p_container), p_child, p_property_id, p_value, p_pspec);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget, p_property_id: c_uint, p_value: *const gobject.Value, p_pspec: *gobject.ParamSpec) callconv(.c) void) void {
                gobject.ext.as(Container.Class, p_class).f_set_child_property = @ptrCast(p_implementation);
            }
        };

        /// Sets, or unsets if `child` is `NULL`, the focused child of `container`.
        ///
        /// This function emits the GtkContainer::set_focus_child signal of
        /// `container`. Implementations of `gtk.Container` can override the
        /// default behaviour by overriding the class closure of this signal.
        ///
        /// This is function is mostly meant to be used by widgets. Applications can use
        /// `gtk.Widget.grabFocus` to manually set the focus to a specific widget.
        pub const set_focus_child = struct {
            pub fn call(p_class: anytype, p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: ?*gtk.Widget) void {
                return gobject.ext.as(Container.Class, p_class).f_set_focus_child.?(gobject.ext.as(Container, p_container), p_child);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_container: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: ?*gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(Container.Class, p_class).f_set_focus_child = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const border_width = struct {
            pub const name = "border-width";

            pub const Type = c_uint;
        };

        pub const child = struct {
            pub const name = "child";

            pub const Type = ?*gtk.Widget;
        };

        pub const resize_mode = struct {
            pub const name = "resize-mode";

            pub const Type = gtk.ResizeMode;
        };
    };

    pub const signals = struct {
        pub const add = struct {
            pub const name = "add";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: *gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Container, p_instance))),
                    gobject.signalLookup("add", Container.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const check_resize = struct {
            pub const name = "check-resize";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Container, p_instance))),
                    gobject.signalLookup("check-resize", Container.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const remove = struct {
            pub const name = "remove";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: *gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Container, p_instance))),
                    gobject.signalLookup("remove", Container.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const set_focus_child = struct {
            pub const name = "set-focus-child";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: *gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Container, p_instance))),
                    gobject.signalLookup("set-focus-child", Container.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Adds `widget` to `container`. Typically used for simple containers
    /// such as `gtk.Window`, `gtk.Frame`, or `gtk.Button`; for more complicated
    /// layout containers such as `gtk.Box` or `gtk.Grid`, this function will
    /// pick default packing parameters that may not be correct.  So
    /// consider functions such as `gtk.Box.packStart` and
    /// `gtk.Grid.attach` as an alternative to `gtk.Container.add` in
    /// those cases. A widget may be added to only one container at a time;
    /// you can’t place the same widget inside two different containers.
    ///
    /// Note that some containers, such as `gtk.ScrolledWindow` or `gtk.ListBox`,
    /// may add intermediate children between the added widget and the
    /// container.
    extern fn gtk_container_add(p_container: *Container, p_widget: *gtk.Widget) void;
    pub const add = gtk_container_add;

    /// Adds `widget` to `container`, setting child properties at the same time.
    /// See `gtk.Container.add` and `gtk.Container.childSet` for more details.
    extern fn gtk_container_add_with_properties(p_container: *Container, p_widget: *gtk.Widget, p_first_prop_name: [*:0]const u8, ...) void;
    pub const addWithProperties = gtk_container_add_with_properties;

    extern fn gtk_container_check_resize(p_container: *Container) void;
    pub const checkResize = gtk_container_check_resize;

    /// Gets the values of one or more child properties for `child` and `container`.
    extern fn gtk_container_child_get(p_container: *Container, p_child: *gtk.Widget, p_first_prop_name: [*:0]const u8, ...) void;
    pub const childGet = gtk_container_child_get;

    /// Gets the value of a child property for `child` and `container`.
    extern fn gtk_container_child_get_property(p_container: *Container, p_child: *gtk.Widget, p_property_name: [*:0]const u8, p_value: *gobject.Value) void;
    pub const childGetProperty = gtk_container_child_get_property;

    /// Gets the values of one or more child properties for `child` and `container`.
    extern fn gtk_container_child_get_valist(p_container: *Container, p_child: *gtk.Widget, p_first_property_name: [*:0]const u8, p_var_args: std.builtin.VaList) void;
    pub const childGetValist = gtk_container_child_get_valist;

    /// Emits a `gtk.Widget.signals.child`-notify signal for the
    /// [child property][child-properties]
    /// `child_property` on the child.
    ///
    /// This is an analogue of `gobject.Object.notify` for child properties.
    ///
    /// Also see `gtk.Widget.childNotify`.
    extern fn gtk_container_child_notify(p_container: *Container, p_child: *gtk.Widget, p_child_property: [*:0]const u8) void;
    pub const childNotify = gtk_container_child_notify;

    /// Emits a `gtk.Widget.signals.child`-notify signal for the
    /// [child property][child-properties] specified by
    /// `pspec` on the child.
    ///
    /// This is an analogue of `gobject.Object.notifyByPspec` for child properties.
    extern fn gtk_container_child_notify_by_pspec(p_container: *Container, p_child: *gtk.Widget, p_pspec: *gobject.ParamSpec) void;
    pub const childNotifyByPspec = gtk_container_child_notify_by_pspec;

    /// Sets one or more child properties for `child` and `container`.
    extern fn gtk_container_child_set(p_container: *Container, p_child: *gtk.Widget, p_first_prop_name: [*:0]const u8, ...) void;
    pub const childSet = gtk_container_child_set;

    /// Sets a child property for `child` and `container`.
    extern fn gtk_container_child_set_property(p_container: *Container, p_child: *gtk.Widget, p_property_name: [*:0]const u8, p_value: *const gobject.Value) void;
    pub const childSetProperty = gtk_container_child_set_property;

    /// Sets one or more child properties for `child` and `container`.
    extern fn gtk_container_child_set_valist(p_container: *Container, p_child: *gtk.Widget, p_first_property_name: [*:0]const u8, p_var_args: std.builtin.VaList) void;
    pub const childSetValist = gtk_container_child_set_valist;

    /// Returns the type of the children supported by the container.
    ///
    /// Note that this may return `G_TYPE_NONE` to indicate that no more
    /// children can be added, e.g. for a `gtk.Paned` which already has two
    /// children.
    extern fn gtk_container_child_type(p_container: *Container) usize;
    pub const childType = gtk_container_child_type;

    /// Invokes `callback` on each direct child of `container`, including
    /// children that are considered “internal” (implementation details
    /// of the container). “Internal” children generally weren’t added
    /// by the user of the container, but were added by the container
    /// implementation itself.
    ///
    /// Most applications should use `gtk.Container.foreach`, rather
    /// than `gtk.Container.forall`.
    extern fn gtk_container_forall(p_container: *Container, p_callback: gtk.Callback, p_callback_data: ?*anyopaque) void;
    pub const forall = gtk_container_forall;

    /// Invokes `callback` on each non-internal child of `container`.
    /// See `gtk.Container.forall` for details on what constitutes
    /// an “internal” child. For all practical purposes, this function
    /// should iterate over precisely those child widgets that were
    /// added to the container by the application with explicit `add`
    /// calls.
    ///
    /// It is permissible to remove the child from the `callback` handler.
    ///
    /// Most applications should use `gtk.Container.foreach`,
    /// rather than `gtk.Container.forall`.
    extern fn gtk_container_foreach(p_container: *Container, p_callback: gtk.Callback, p_callback_data: ?*anyopaque) void;
    pub const foreach = gtk_container_foreach;

    /// Retrieves the border width of the container. See
    /// `gtk.Container.setBorderWidth`.
    extern fn gtk_container_get_border_width(p_container: *Container) c_uint;
    pub const getBorderWidth = gtk_container_get_border_width;

    /// Returns the container’s non-internal children. See
    /// `gtk.Container.forall` for details on what constitutes an "internal" child.
    extern fn gtk_container_get_children(p_container: *Container) *glib.List;
    pub const getChildren = gtk_container_get_children;

    /// Retrieves the focus chain of the container, if one has been
    /// set explicitly. If no focus chain has been explicitly
    /// set, GTK+ computes the focus chain based on the positions
    /// of the children. In that case, GTK+ stores `NULL` in
    /// `focusable_widgets` and returns `FALSE`.
    extern fn gtk_container_get_focus_chain(p_container: *Container, p_focusable_widgets: **glib.List) c_int;
    pub const getFocusChain = gtk_container_get_focus_chain;

    /// Returns the current focus child widget inside `container`. This is not the
    /// currently focused widget. That can be obtained by calling
    /// `gtk.Window.getFocus`.
    extern fn gtk_container_get_focus_child(p_container: *Container) ?*gtk.Widget;
    pub const getFocusChild = gtk_container_get_focus_child;

    /// Retrieves the horizontal focus adjustment for the container. See
    /// gtk_container_set_focus_hadjustment ().
    extern fn gtk_container_get_focus_hadjustment(p_container: *Container) ?*gtk.Adjustment;
    pub const getFocusHadjustment = gtk_container_get_focus_hadjustment;

    /// Retrieves the vertical focus adjustment for the container. See
    /// `gtk.Container.setFocusVadjustment`.
    extern fn gtk_container_get_focus_vadjustment(p_container: *Container) ?*gtk.Adjustment;
    pub const getFocusVadjustment = gtk_container_get_focus_vadjustment;

    /// Returns a newly created widget path representing all the widget hierarchy
    /// from the toplevel down to and including `child`.
    extern fn gtk_container_get_path_for_child(p_container: *Container, p_child: *gtk.Widget) *gtk.WidgetPath;
    pub const getPathForChild = gtk_container_get_path_for_child;

    /// Returns the resize mode for the container. See
    /// gtk_container_set_resize_mode ().
    extern fn gtk_container_get_resize_mode(p_container: *Container) gtk.ResizeMode;
    pub const getResizeMode = gtk_container_get_resize_mode;

    /// When a container receives a call to the draw function, it must send
    /// synthetic `gtk.Widget.signals.draw` calls to all children that don’t have their
    /// own `GdkWindows`. This function provides a convenient way of doing this.
    /// A container, when it receives a call to its `gtk.Widget.signals.draw` function,
    /// calls `gtk.Container.propagateDraw` once for each child, passing in
    /// the `cr` the container received.
    ///
    /// `gtk.Container.propagateDraw` takes care of translating the origin of `cr`,
    /// and deciding whether the draw needs to be sent to the child. It is a
    /// convenient and optimized way of getting the same effect as calling
    /// `gtk.Widget.draw` on the child directly.
    ///
    /// In most cases, a container can simply either inherit the
    /// `gtk.Widget.signals.draw` implementation from `gtk.Container`, or do some drawing
    /// and then chain to the ::draw implementation from `gtk.Container`.
    extern fn gtk_container_propagate_draw(p_container: *Container, p_child: *gtk.Widget, p_cr: *cairo.Context) void;
    pub const propagateDraw = gtk_container_propagate_draw;

    /// Removes `widget` from `container`. `widget` must be inside `container`.
    /// Note that `container` will own a reference to `widget`, and that this
    /// may be the last reference held; so removing a widget from its
    /// container can destroy that widget. If you want to use `widget`
    /// again, you need to add a reference to it before removing it from
    /// a container, using `gobject.Object.ref`. If you don’t want to use `widget`
    /// again it’s usually more efficient to simply destroy it directly
    /// using `gtk.Widget.destroy` since this will remove it from the
    /// container and help break any circular reference count cycles.
    extern fn gtk_container_remove(p_container: *Container, p_widget: *gtk.Widget) void;
    pub const remove = gtk_container_remove;

    extern fn gtk_container_resize_children(p_container: *Container) void;
    pub const resizeChildren = gtk_container_resize_children;

    /// Sets the border width of the container.
    ///
    /// The border width of a container is the amount of space to leave
    /// around the outside of the container. The only exception to this is
    /// `gtk.Window`; because toplevel windows can’t leave space outside,
    /// they leave the space inside. The border is added on all sides of
    /// the container. To add space to only one side, use a specific
    /// `gtk.Widget.properties.margin` property on the child widget, for example
    /// `gtk.Widget.properties.margin`-top.
    extern fn gtk_container_set_border_width(p_container: *Container, p_border_width: c_uint) void;
    pub const setBorderWidth = gtk_container_set_border_width;

    /// Sets a focus chain, overriding the one computed automatically by GTK+.
    ///
    /// In principle each widget in the chain should be a descendant of the
    /// container, but this is not enforced by this method, since it’s allowed
    /// to set the focus chain before you pack the widgets, or have a widget
    /// in the chain that isn’t always packed. The necessary checks are done
    /// when the focus chain is actually traversed.
    extern fn gtk_container_set_focus_chain(p_container: *Container, p_focusable_widgets: *glib.List) void;
    pub const setFocusChain = gtk_container_set_focus_chain;

    /// Sets, or unsets if `child` is `NULL`, the focused child of `container`.
    ///
    /// This function emits the GtkContainer::set_focus_child signal of
    /// `container`. Implementations of `gtk.Container` can override the
    /// default behaviour by overriding the class closure of this signal.
    ///
    /// This is function is mostly meant to be used by widgets. Applications can use
    /// `gtk.Widget.grabFocus` to manually set the focus to a specific widget.
    extern fn gtk_container_set_focus_child(p_container: *Container, p_child: ?*gtk.Widget) void;
    pub const setFocusChild = gtk_container_set_focus_child;

    /// Hooks up an adjustment to focus handling in a container, so when a child
    /// of the container is focused, the adjustment is scrolled to show that
    /// widget. This function sets the horizontal alignment.
    /// See `gtk.ScrolledWindow.getHadjustment` for a typical way of obtaining
    /// the adjustment and `gtk.Container.setFocusVadjustment` for setting
    /// the vertical adjustment.
    ///
    /// The adjustments have to be in pixel units and in the same coordinate
    /// system as the allocation for immediate children of the container.
    extern fn gtk_container_set_focus_hadjustment(p_container: *Container, p_adjustment: *gtk.Adjustment) void;
    pub const setFocusHadjustment = gtk_container_set_focus_hadjustment;

    /// Hooks up an adjustment to focus handling in a container, so when a
    /// child of the container is focused, the adjustment is scrolled to
    /// show that widget. This function sets the vertical alignment. See
    /// `gtk.ScrolledWindow.getVadjustment` for a typical way of obtaining
    /// the adjustment and `gtk.Container.setFocusHadjustment` for setting
    /// the horizontal adjustment.
    ///
    /// The adjustments have to be in pixel units and in the same coordinate
    /// system as the allocation for immediate children of the container.
    extern fn gtk_container_set_focus_vadjustment(p_container: *Container, p_adjustment: *gtk.Adjustment) void;
    pub const setFocusVadjustment = gtk_container_set_focus_vadjustment;

    /// Sets the `reallocate_redraws` flag of the container to the given value.
    ///
    /// Containers requesting reallocation redraws get automatically
    /// redrawn if any of their children changed allocation.
    extern fn gtk_container_set_reallocate_redraws(p_container: *Container, p_needs_redraws: c_int) void;
    pub const setReallocateRedraws = gtk_container_set_reallocate_redraws;

    /// Sets the resize mode for the container.
    ///
    /// The resize mode of a container determines whether a resize request
    /// will be passed to the container’s parent, queued for later execution
    /// or executed immediately.
    extern fn gtk_container_set_resize_mode(p_container: *Container, p_resize_mode: gtk.ResizeMode) void;
    pub const setResizeMode = gtk_container_set_resize_mode;

    /// Removes a focus chain explicitly set with `gtk.Container.setFocusChain`.
    extern fn gtk_container_unset_focus_chain(p_container: *Container) void;
    pub const unsetFocusChain = gtk_container_unset_focus_chain;

    extern fn gtk_container_get_type() usize;
    pub const getGObjectType = gtk_container_get_type;

    extern fn g_object_ref(p_self: *gtk.Container) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Container) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Container, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ContainerAccessible = extern struct {
    pub const Parent = gtk.WidgetAccessible;
    pub const Implements = [_]type{atk.Component};
    pub const Class = gtk.ContainerAccessibleClass;
    f_parent: gtk.WidgetAccessible,
    f_priv: ?*gtk.ContainerAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_container_accessible_get_type() usize;
    pub const getGObjectType = gtk_container_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ContainerAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ContainerAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ContainerAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ContainerCellAccessible = extern struct {
    pub const Parent = gtk.CellAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.TableCell };
    pub const Class = gtk.ContainerCellAccessibleClass;
    f_parent: gtk.CellAccessible,
    f_priv: ?*gtk.ContainerCellAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_container_cell_accessible_new() *gtk.ContainerCellAccessible;
    pub const new = gtk_container_cell_accessible_new;

    extern fn gtk_container_cell_accessible_add_child(p_container: *ContainerCellAccessible, p_child: *gtk.CellAccessible) void;
    pub const addChild = gtk_container_cell_accessible_add_child;

    /// Get a list of children.
    extern fn gtk_container_cell_accessible_get_children(p_container: *ContainerCellAccessible) *glib.List;
    pub const getChildren = gtk_container_cell_accessible_get_children;

    extern fn gtk_container_cell_accessible_remove_child(p_container: *ContainerCellAccessible, p_child: *gtk.CellAccessible) void;
    pub const removeChild = gtk_container_cell_accessible_remove_child;

    extern fn gtk_container_cell_accessible_get_type() usize;
    pub const getGObjectType = gtk_container_cell_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ContainerCellAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ContainerCellAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ContainerCellAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkCssProvider is an object implementing the `gtk.StyleProvider` interface.
/// It is able to parse [CSS-like][css-overview] input in order to style widgets.
///
/// An application can make GTK+ parse a specific CSS style sheet by calling
/// `gtk.CssProvider.loadFromFile` or `gtk.CssProvider.loadFromResource`
/// and adding the provider with `gtk.StyleContext.addProvider` or
/// `gtk.StyleContext.addProviderForScreen`.
///
/// In addition, certain files will be read when GTK+ is initialized. First, the
/// file `$XDG_CONFIG_HOME/gtk-3.0/gtk.css` is loaded if it exists. Then, GTK+
/// loads the first existing file among
/// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk.css`,
/// `$HOME/.themes/THEME/gtk-VERSION/gtk.css`,
/// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk.css` and
/// `DATADIR/share/themes/THEME/gtk-VERSION/gtk.css`, where `THEME` is the name of
/// the current theme (see the `gtk.Settings.properties.gtk`-theme-name setting), `DATADIR`
/// is the prefix configured when GTK+ was compiled (unless overridden by the
/// `GTK_DATA_PREFIX` environment variable), and `VERSION` is the GTK+ version number.
/// If no file is found for the current version, GTK+ tries older versions all the
/// way back to 3.0.
///
/// In the same way, GTK+ tries to load a gtk-keys.css file for the current
/// key theme, as defined by `gtk.Settings.properties.gtk`-key-theme-name.
pub const CssProvider = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gtk.StyleProvider};
    pub const Class = gtk.CssProviderClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.CssProviderPrivate,

    pub const virtual_methods = struct {
        pub const parsing_error = struct {
            pub fn call(p_class: anytype, p_provider: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_section: *gtk.CssSection, p_error: *const glib.Error) void {
                return gobject.ext.as(CssProvider.Class, p_class).f_parsing_error.?(gobject.ext.as(CssProvider, p_provider), p_section, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_provider: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_section: *gtk.CssSection, p_error: *const glib.Error) callconv(.c) void) void {
                gobject.ext.as(CssProvider.Class, p_class).f_parsing_error = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// Signals that a parsing error occurred. the `path`, `line` and `position`
        /// describe the actual location of the error as accurately as possible.
        ///
        /// Parsing errors are never fatal, so the parsing will resume after
        /// the error. Errors may however cause parts of the given
        /// data or even all of it to not be parsed at all. So it is a useful idea
        /// to check that the parsing succeeds by connecting to this signal.
        ///
        /// Note that this signal may be emitted at any time as the css provider
        /// may opt to defer parsing parts or all of the input to a later time
        /// than when a loading function was called.
        pub const parsing_error = struct {
            pub const name = "parsing-error";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_section: *gtk.CssSection, p_error: *glib.Error, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(CssProvider, p_instance))),
                    gobject.signalLookup("parsing-error", CssProvider.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Returns the provider containing the style settings used as a
    /// fallback for all widgets.
    extern fn gtk_css_provider_get_default() *gtk.CssProvider;
    pub const getDefault = gtk_css_provider_get_default;

    /// Loads a theme from the usual theme paths
    extern fn gtk_css_provider_get_named(p_name: [*:0]const u8, p_variant: ?[*:0]const u8) *gtk.CssProvider;
    pub const getNamed = gtk_css_provider_get_named;

    /// Returns a newly created `gtk.CssProvider`.
    extern fn gtk_css_provider_new() *gtk.CssProvider;
    pub const new = gtk_css_provider_new;

    /// Loads `data` into `css_provider`, and by doing so clears any previously loaded
    /// information.
    extern fn gtk_css_provider_load_from_data(p_css_provider: *CssProvider, p_data: [*]const u8, p_length: isize, p_error: ?*?*glib.Error) c_int;
    pub const loadFromData = gtk_css_provider_load_from_data;

    /// Loads the data contained in `file` into `css_provider`, making it
    /// clear any previously loaded information.
    extern fn gtk_css_provider_load_from_file(p_css_provider: *CssProvider, p_file: *gio.File, p_error: ?*?*glib.Error) c_int;
    pub const loadFromFile = gtk_css_provider_load_from_file;

    /// Loads the data contained in `path` into `css_provider`, making it clear
    /// any previously loaded information.
    extern fn gtk_css_provider_load_from_path(p_css_provider: *CssProvider, p_path: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const loadFromPath = gtk_css_provider_load_from_path;

    /// Loads the data contained in the resource at `resource_path` into
    /// the `gtk.CssProvider`, clearing any previously loaded information.
    ///
    /// To track errors while loading CSS, connect to the
    /// `gtk.CssProvider.signals.parsing`-error signal.
    extern fn gtk_css_provider_load_from_resource(p_css_provider: *CssProvider, p_resource_path: [*:0]const u8) void;
    pub const loadFromResource = gtk_css_provider_load_from_resource;

    /// Converts the `provider` into a string representation in CSS
    /// format.
    ///
    /// Using `gtk.CssProvider.loadFromData` with the return value
    /// from this function on a new provider created with
    /// `gtk.CssProvider.new` will basically create a duplicate of
    /// this `provider`.
    extern fn gtk_css_provider_to_string(p_provider: *CssProvider) [*:0]u8;
    pub const toString = gtk_css_provider_to_string;

    extern fn gtk_css_provider_get_type() usize;
    pub const getGObjectType = gtk_css_provider_get_type;

    extern fn g_object_ref(p_self: *gtk.CssProvider) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CssProvider) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CssProvider, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Dialog boxes are a convenient way to prompt the user for a small amount
/// of input, e.g. to display a message, ask a question, or anything else
/// that does not require extensive effort on the user’s part.
///
/// GTK+ treats a dialog as a window split vertically. The top section is a
/// `gtk.VBox`, and is where widgets such as a `gtk.Label` or a `gtk.Entry` should
/// be packed. The bottom area is known as the
/// “action area”. This is generally used for
/// packing buttons into the dialog which may perform functions such as
/// cancel, ok, or apply.
///
/// `gtk.Dialog` boxes are created with a call to `gtk.Dialog.new` or
/// `gtk.Dialog.newWithButtons`. `gtk.Dialog.newWithButtons` is
/// recommended; it allows you to set the dialog title, some convenient
/// flags, and add simple buttons.
///
/// If “dialog” is a newly created dialog, the two primary areas of the
/// window can be accessed through `gtk.Dialog.getContentArea` and
/// `gtk.Dialog.getActionArea`, as can be seen from the example below.
///
/// A “modal” dialog (that is, one which freezes the rest of the application
/// from user input), can be created by calling `gtk.Window.setModal` on the
/// dialog. Use the `GTK_WINDOW` macro to cast the widget returned from
/// `gtk.Dialog.new` into a `gtk.Window`. When using `gtk.Dialog.newWithButtons`
/// you can also pass the `GTK_DIALOG_MODAL` flag to make a dialog modal.
///
/// If you add buttons to `gtk.Dialog` using `gtk.Dialog.newWithButtons`,
/// `gtk.Dialog.addButton`, `gtk.Dialog.addButtons`, or
/// `gtk.Dialog.addActionWidget`, clicking the button will emit a signal
/// called `gtk.Dialog.signals.response` with a response ID that you specified. GTK+
/// will never assign a meaning to positive response IDs; these are entirely
/// user-defined. But for convenience, you can use the response IDs in the
/// `gtk.ResponseType` enumeration (these all have values less than zero). If
/// a dialog receives a delete event, the `gtk.Dialog.signals.response` signal will
/// be emitted with a response ID of `GTK_RESPONSE_DELETE_EVENT`.
///
/// If you want to block waiting for a dialog to return before returning
/// control flow to your code, you can call `gtk.Dialog.run`. This function
/// enters a recursive main loop and waits for the user to respond to the
/// dialog, returning the response ID corresponding to the button the user
/// clicked.
///
/// For the simple dialog in the following example, in reality you’d probably
/// use `gtk.MessageDialog` to save yourself some effort. But you’d need to
/// create the dialog contents manually if you had more than a simple message
/// in the dialog.
///
/// An example for simple GtkDialog usage:
/// ```
/// // Function to open a dialog box with a message
/// void
/// quick_message (GtkWindow *parent, gchar *message)
/// {
///  GtkWidget *dialog, *label, *content_area;
///  GtkDialogFlags flags;
///
///  // Create the widgets
///  flags = GTK_DIALOG_DESTROY_WITH_PARENT;
///  dialog = gtk_dialog_new_with_buttons ("Message",
///                                        parent,
///                                        flags,
///                                        _("_OK"),
///                                        GTK_RESPONSE_NONE,
///                                        NULL);
///  content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
///  label = gtk_label_new (message);
///
///  // Ensure that the dialog box is destroyed when the user responds
///
///  g_signal_connect_swapped (dialog,
///                            "response",
///                            G_CALLBACK (gtk_widget_destroy),
///                            dialog);
///
///  // Add the label, and show everything we’ve added
///
///  gtk_container_add (GTK_CONTAINER (content_area), label);
///  gtk_widget_show_all (dialog);
/// }
/// ```
///
/// # GtkDialog as GtkBuildable
///
/// The GtkDialog implementation of the `gtk.Buildable` interface exposes the
/// `vbox` and `action_area` as internal children with the names “vbox” and
/// “action_area”.
///
/// GtkDialog supports a custom `<action-widgets>` element, which can contain
/// multiple `<action-widget>` elements. The “response” attribute specifies a
/// numeric response, and the content of the element is the id of widget
/// (which should be a child of the dialogs `action_area`). To mark a response
/// as default, set the “default“ attribute of the `<action-widget>` element
/// to true.
///
/// GtkDialog supports adding action widgets by specifying “action“ as
/// the “type“ attribute of a `<child>` element. The widget will be added
/// either to the action area or the headerbar of the dialog, depending
/// on the “use-header-bar“ property. The response id has to be associated
/// with the action widget using the `<action-widgets>` element.
///
/// An example of a `gtk.Dialog` UI definition fragment:
///
/// ```
/// <object class="GtkDialog" id="dialog1">
///   <child type="action">
///     <object class="GtkButton" id="button_cancel"/>
///   </child>
///   <child type="action">
///     <object class="GtkButton" id="button_ok">
///       <property name="can-default">True</property>
///     </object>
///   </child>
///   <action-widgets>
///     <action-widget response="cancel">button_cancel</action-widget>
///     <action-widget response="ok" default="true">button_ok</action-widget>
///   </action-widgets>
/// </object>
/// ```
pub const Dialog = extern struct {
    pub const Parent = gtk.Window;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.DialogClass;
    f_window: gtk.Window,
    f_priv: ?*gtk.DialogPrivate,

    pub const virtual_methods = struct {
        /// Signal emitted when the user uses a keybinding to close the dialog.
        pub const close = struct {
            pub fn call(p_class: anytype, p_dialog: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Dialog.Class, p_class).f_close.?(gobject.ext.as(Dialog, p_dialog));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_dialog: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Dialog.Class, p_class).f_close = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gtk.Dialog.signals.response` signal with the given response ID.
        /// Used to indicate that the user has responded to the dialog in some way;
        /// typically either you or `gtk.Dialog.run` will be monitoring the
        /// ::response signal and take appropriate action.
        pub const response = struct {
            pub fn call(p_class: anytype, p_dialog: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_response_id: c_int) void {
                return gobject.ext.as(Dialog.Class, p_class).f_response.?(gobject.ext.as(Dialog, p_dialog), p_response_id);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_dialog: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_response_id: c_int) callconv(.c) void) void {
                gobject.ext.as(Dialog.Class, p_class).f_response = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// `TRUE` if the dialog uses a `gtk.HeaderBar` for action buttons
        /// instead of the action-area.
        ///
        /// For technical reasons, this property is declared as an integer
        /// property, but you should only set it to `TRUE` or `FALSE`.
        pub const use_header_bar = struct {
            pub const name = "use-header-bar";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::close signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user uses a keybinding to close
        /// the dialog.
        ///
        /// The default binding for this signal is the Escape key.
        pub const close = struct {
            pub const name = "close";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Dialog, p_instance))),
                    gobject.signalLookup("close", Dialog.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when an action widget is clicked, the dialog receives a
        /// delete event, or the application programmer calls `gtk.Dialog.response`.
        /// On a delete event, the response ID is `GTK_RESPONSE_DELETE_EVENT`.
        /// Otherwise, it depends on which action widget was clicked.
        pub const response = struct {
            pub const name = "response";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_response_id: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Dialog, p_instance))),
                    gobject.signalLookup("response", Dialog.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new dialog box.
    ///
    /// Widgets should not be packed into this `gtk.Window`
    /// directly, but into the `vbox` and `action_area`, as described above.
    extern fn gtk_dialog_new() *gtk.Dialog;
    pub const new = gtk_dialog_new;

    /// Creates a new `gtk.Dialog` with title `title` (or `NULL` for the default
    /// title; see `gtk.Window.setTitle`) and transient parent `parent` (or
    /// `NULL` for none; see `gtk.Window.setTransientFor`). The `flags`
    /// argument can be used to make the dialog modal (`GTK_DIALOG_MODAL`)
    /// and/or to have it destroyed along with its transient parent
    /// (`GTK_DIALOG_DESTROY_WITH_PARENT`). After `flags`, button
    /// text/response ID pairs should be listed, with a `NULL` pointer ending
    /// the list. Button text can be arbitrary text. A response ID can be
    /// any positive number, or one of the values in the `gtk.ResponseType`
    /// enumeration. If the user clicks one of these dialog buttons,
    /// `gtk.Dialog` will emit the `gtk.Dialog.signals.response` signal with the corresponding
    /// response ID. If a `gtk.Dialog` receives the `gtk.Widget.signals.delete`-event signal,
    /// it will emit ::response with a response ID of `GTK_RESPONSE_DELETE_EVENT`.
    /// However, destroying a dialog does not emit the ::response signal;
    /// so be careful relying on ::response when using the
    /// `GTK_DIALOG_DESTROY_WITH_PARENT` flag. Buttons are from left to right,
    /// so the first button in the list will be the leftmost button in the dialog.
    ///
    /// Here’s a simple example:
    /// ```
    ///  GtkWidget *main_app_window; // Window the dialog should show up on
    ///  GtkWidget *dialog;
    ///  GtkDialogFlags flags = GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT;
    ///  dialog = gtk_dialog_new_with_buttons ("My dialog",
    ///                                        main_app_window,
    ///                                        flags,
    ///                                        _("_OK"),
    ///                                        GTK_RESPONSE_ACCEPT,
    ///                                        _("_Cancel"),
    ///                                        GTK_RESPONSE_REJECT,
    ///                                        NULL);
    /// ```
    extern fn gtk_dialog_new_with_buttons(p_title: ?[*:0]const u8, p_parent: ?*gtk.Window, p_flags: gtk.DialogFlags, p_first_button_text: ?[*:0]const u8, ...) *gtk.Dialog;
    pub const newWithButtons = gtk_dialog_new_with_buttons;

    /// Adds an activatable widget to the action area of a `gtk.Dialog`,
    /// connecting a signal handler that will emit the `gtk.Dialog.signals.response`
    /// signal on the dialog when the widget is activated. The widget is
    /// appended to the end of the dialog’s action area. If you want to add a
    /// non-activatable widget, simply pack it into the `action_area` field
    /// of the `gtk.Dialog` struct.
    extern fn gtk_dialog_add_action_widget(p_dialog: *Dialog, p_child: *gtk.Widget, p_response_id: c_int) void;
    pub const addActionWidget = gtk_dialog_add_action_widget;

    /// Adds a button with the given text and sets things up so that
    /// clicking the button will emit the `gtk.Dialog.signals.response` signal with
    /// the given `response_id`. The button is appended to the end of the
    /// dialog’s action area. The button widget is returned, but usually
    /// you don’t need it.
    extern fn gtk_dialog_add_button(p_dialog: *Dialog, p_button_text: [*:0]const u8, p_response_id: c_int) *gtk.Widget;
    pub const addButton = gtk_dialog_add_button;

    /// Adds more buttons, same as calling `gtk.Dialog.addButton`
    /// repeatedly.  The variable argument list should be `NULL`-terminated
    /// as with `gtk.Dialog.newWithButtons`. Each button must have both
    /// text and response ID.
    extern fn gtk_dialog_add_buttons(p_dialog: *Dialog, p_first_button_text: [*:0]const u8, ...) void;
    pub const addButtons = gtk_dialog_add_buttons;

    /// Returns the action area of `dialog`.
    extern fn gtk_dialog_get_action_area(p_dialog: *Dialog) *gtk.Box;
    pub const getActionArea = gtk_dialog_get_action_area;

    /// Returns the content area of `dialog`.
    extern fn gtk_dialog_get_content_area(p_dialog: *Dialog) *gtk.Box;
    pub const getContentArea = gtk_dialog_get_content_area;

    /// Returns the header bar of `dialog`. Note that the
    /// headerbar is only used by the dialog if the
    /// `gtk.Dialog.properties.use`-header-bar property is `TRUE`.
    extern fn gtk_dialog_get_header_bar(p_dialog: *Dialog) *gtk.HeaderBar;
    pub const getHeaderBar = gtk_dialog_get_header_bar;

    /// Gets the response id of a widget in the action area
    /// of a dialog.
    extern fn gtk_dialog_get_response_for_widget(p_dialog: *Dialog, p_widget: *gtk.Widget) c_int;
    pub const getResponseForWidget = gtk_dialog_get_response_for_widget;

    /// Gets the widget button that uses the given response ID in the action area
    /// of a dialog.
    extern fn gtk_dialog_get_widget_for_response(p_dialog: *Dialog, p_response_id: c_int) ?*gtk.Widget;
    pub const getWidgetForResponse = gtk_dialog_get_widget_for_response;

    /// Emits the `gtk.Dialog.signals.response` signal with the given response ID.
    /// Used to indicate that the user has responded to the dialog in some way;
    /// typically either you or `gtk.Dialog.run` will be monitoring the
    /// ::response signal and take appropriate action.
    extern fn gtk_dialog_response(p_dialog: *Dialog, p_response_id: c_int) void;
    pub const response = gtk_dialog_response;

    /// Blocks in a recursive main loop until the `dialog` either emits the
    /// `gtk.Dialog.signals.response` signal, or is destroyed. If the dialog is
    /// destroyed during the call to `gtk.Dialog.run`, `gtk.Dialog.run` returns
    /// `GTK_RESPONSE_NONE`. Otherwise, it returns the response ID from the
    /// ::response signal emission.
    ///
    /// Before entering the recursive main loop, `gtk.Dialog.run` calls
    /// `gtk.Widget.show` on the dialog for you. Note that you still
    /// need to show any children of the dialog yourself.
    ///
    /// During `gtk.Dialog.run`, the default behavior of `gtk.Widget.signals.delete`-event
    /// is disabled; if the dialog receives ::delete_event, it will not be
    /// destroyed as windows usually are, and `gtk.Dialog.run` will return
    /// `GTK_RESPONSE_DELETE_EVENT`. Also, during `gtk.Dialog.run` the dialog
    /// will be modal. You can force `gtk.Dialog.run` to return at any time by
    /// calling `gtk.Dialog.response` to emit the ::response signal. Destroying
    /// the dialog during `gtk.Dialog.run` is a very bad idea, because your
    /// post-run code won’t know whether the dialog was destroyed or not.
    ///
    /// After `gtk.Dialog.run` returns, you are responsible for hiding or
    /// destroying the dialog if you wish to do so.
    ///
    /// Typical usage of this function might be:
    /// ```
    ///   GtkWidget *dialog = gtk_dialog_new ();
    ///   // Set up dialog...
    ///
    ///   int result = gtk_dialog_run (GTK_DIALOG (dialog));
    ///   switch (result)
    ///     {
    ///       case GTK_RESPONSE_ACCEPT:
    ///          // do_application_specific_something ();
    ///          break;
    ///       default:
    ///          // do_nothing_since_dialog_was_cancelled ();
    ///          break;
    ///     }
    ///   gtk_widget_destroy (dialog);
    /// ```
    ///
    /// Note that even though the recursive main loop gives the effect of a
    /// modal dialog (it prevents the user from interacting with other
    /// windows in the same window group while the dialog is run), callbacks
    /// such as timeouts, IO channel watches, DND drops, etc, will
    /// be triggered during a `gtk.Dialog.run` call.
    extern fn gtk_dialog_run(p_dialog: *Dialog) c_int;
    pub const run = gtk_dialog_run;

    /// Sets an alternative button order. If the
    /// `gtk.Settings.properties.gtk`-alternative-button-order setting is set to `TRUE`,
    /// the dialog buttons are reordered according to the order of the
    /// response ids passed to this function.
    ///
    /// By default, GTK+ dialogs use the button order advocated by the
    /// [GNOME Human Interface Guidelines](http://library.gnome.org/devel/hig-book/stable/)
    /// with the affirmative button at the far
    /// right, and the cancel button left of it. But the builtin GTK+ dialogs
    /// and `GtkMessageDialogs` do provide an alternative button order,
    /// which is more suitable on some platforms, e.g. Windows.
    ///
    /// Use this function after adding all the buttons to your dialog, as the
    /// following example shows:
    ///
    /// ```
    /// cancel_button = gtk_dialog_add_button (GTK_DIALOG (dialog),
    ///                                        _("_Cancel"),
    ///                                        GTK_RESPONSE_CANCEL);
    ///
    /// ok_button = gtk_dialog_add_button (GTK_DIALOG (dialog),
    ///                                    _("_OK"),
    ///                                    GTK_RESPONSE_OK);
    ///
    /// gtk_widget_grab_default (ok_button);
    ///
    /// help_button = gtk_dialog_add_button (GTK_DIALOG (dialog),
    ///                                      _("_Help"),
    ///                                      GTK_RESPONSE_HELP);
    ///
    /// gtk_dialog_set_alternative_button_order (GTK_DIALOG (dialog),
    ///                                          GTK_RESPONSE_OK,
    ///                                          GTK_RESPONSE_CANCEL,
    ///                                          GTK_RESPONSE_HELP,
    ///                                          -1);
    /// ```
    extern fn gtk_dialog_set_alternative_button_order(p_dialog: *Dialog, p_first_response_id: c_int, ...) void;
    pub const setAlternativeButtonOrder = gtk_dialog_set_alternative_button_order;

    /// Sets an alternative button order. If the
    /// `gtk.Settings.properties.gtk`-alternative-button-order setting is set to `TRUE`,
    /// the dialog buttons are reordered according to the order of the
    /// response ids in `new_order`.
    ///
    /// See `gtk.Dialog.setAlternativeButtonOrder` for more information.
    ///
    /// This function is for use by language bindings.
    extern fn gtk_dialog_set_alternative_button_order_from_array(p_dialog: *Dialog, p_n_params: c_int, p_new_order: [*]c_int) void;
    pub const setAlternativeButtonOrderFromArray = gtk_dialog_set_alternative_button_order_from_array;

    /// Sets the last widget in the dialog’s action area with the given `response_id`
    /// as the default widget for the dialog. Pressing “Enter” normally activates
    /// the default widget.
    extern fn gtk_dialog_set_default_response(p_dialog: *Dialog, p_response_id: c_int) void;
    pub const setDefaultResponse = gtk_dialog_set_default_response;

    /// Calls `gtk_widget_set_sensitive (widget, `setting`)`
    /// for each widget in the dialog’s action area with the given `response_id`.
    /// A convenient way to sensitize/desensitize dialog buttons.
    extern fn gtk_dialog_set_response_sensitive(p_dialog: *Dialog, p_response_id: c_int, p_setting: c_int) void;
    pub const setResponseSensitive = gtk_dialog_set_response_sensitive;

    extern fn gtk_dialog_get_type() usize;
    pub const getGObjectType = gtk_dialog_get_type;

    extern fn g_object_ref(p_self: *gtk.Dialog) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Dialog) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Dialog, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.DrawingArea` widget is used for creating custom user interface
/// elements. It’s essentially a blank widget; you can draw on it. After
/// creating a drawing area, the application may want to connect to:
///
/// - Mouse and button press signals to respond to input from
///   the user. (Use `gtk.Widget.addEvents` to enable events
///   you wish to receive.)
///
/// - The `gtk.Widget.signals.realize` signal to take any necessary actions
///   when the widget is instantiated on a particular display.
///   (Create GDK resources in response to this signal.)
///
/// - The `gtk.Widget.signals.size`-allocate signal to take any necessary
///   actions when the widget changes size.
///
/// - The `gtk.Widget.signals.draw` signal to handle redrawing the
///   contents of the widget.
///
/// The following code portion demonstrates using a drawing
/// area to display a circle in the normal widget foreground
/// color.
///
/// Note that GDK automatically clears the exposed area before sending
/// the expose event, and that drawing is implicitly clipped to the exposed
/// area. If you want to have a theme-provided background, you need
/// to call `gtk.renderBackground` in your ::draw method.
///
/// ## Simple GtkDrawingArea usage
///
/// ```
/// gboolean
/// draw_callback (GtkWidget *widget, cairo_t *cr, gpointer data)
/// {
///   guint width, height;
///   GdkRGBA color;
///   GtkStyleContext *context;
///
///   context = gtk_widget_get_style_context (widget);
///
///   width = gtk_widget_get_allocated_width (widget);
///   height = gtk_widget_get_allocated_height (widget);
///
///   gtk_render_background (context, cr, 0, 0, width, height);
///
///   cairo_arc (cr,
///              width / 2.0, height / 2.0,
///              MIN (width, height) / 2.0,
///              0, 2 * G_PI);
///
///   gtk_style_context_get_color (context,
///                                gtk_style_context_get_state (context),
///                                &color);
///   gdk_cairo_set_source_rgba (cr, &color);
///
///   cairo_fill (cr);
///
///  return FALSE;
/// }
/// [...]
///   GtkWidget *drawing_area = gtk_drawing_area_new ();
///   gtk_widget_set_size_request (drawing_area, 100, 100);
///   g_signal_connect (G_OBJECT (drawing_area), "draw",
///                     G_CALLBACK (draw_callback), NULL);
/// ```
///
/// Draw signals are normally delivered when a drawing area first comes
/// onscreen, or when it’s covered by another window and then uncovered.
/// You can also force an expose event by adding to the “damage region”
/// of the drawing area’s window; `gtk.Widget.queueDrawArea` and
/// `gdk.Window.invalidateRect` are equally good ways to do this.
/// You’ll then get a draw signal for the invalid region.
///
/// The available routines for drawing are documented on the
/// [GDK Drawing Primitives][gdk3-Cairo-Interaction] page
/// and the cairo documentation.
///
/// To receive mouse events on a drawing area, you will need to enable
/// them with `gtk.Widget.addEvents`. To receive keyboard events, you
/// will need to set the “can-focus” property on the drawing area, and you
/// should probably draw some user-visible indication that the drawing
/// area is focused. Use `gtk.Widget.hasFocus` in your expose event
/// handler to decide whether to draw the focus indicator. See
/// `gtk.renderFocus` for one way to draw focus.
pub const DrawingArea = extern struct {
    pub const Parent = gtk.Widget;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.DrawingAreaClass;
    f_widget: gtk.Widget,
    f_dummy: ?*anyopaque,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new drawing area.
    extern fn gtk_drawing_area_new() *gtk.DrawingArea;
    pub const new = gtk_drawing_area_new;

    extern fn gtk_drawing_area_get_type() usize;
    pub const getGObjectType = gtk_drawing_area_get_type;

    extern fn g_object_ref(p_self: *gtk.DrawingArea) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.DrawingArea) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DrawingArea, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Entry` widget is a single line text entry
/// widget. A fairly large set of key bindings are supported
/// by default. If the entered text is longer than the allocation
/// of the widget, the widget will scroll so that the cursor
/// position is visible.
///
/// When using an entry for passwords and other sensitive information,
/// it can be put into “password mode” using `gtk.Entry.setVisibility`.
/// In this mode, entered text is displayed using a “invisible” character.
/// By default, GTK+ picks the best invisible character that is available
/// in the current font, but it can be changed with
/// `gtk.Entry.setInvisibleChar`. Since 2.16, GTK+ displays a warning
/// when Caps Lock or input methods might interfere with entering text in
/// a password entry. The warning can be turned off with the
/// `gtk.Entry.properties.caps`-lock-warning property.
///
/// Since 2.16, GtkEntry has the ability to display progress or activity
/// information behind the text. To make an entry display such information,
/// use `gtk.Entry.setProgressFraction` or `gtk.Entry.setProgressPulseStep`.
///
/// Additionally, GtkEntry can show icons at either side of the entry. These
/// icons can be activatable by clicking, can be set up as drag source and
/// can have tooltips. To add an icon, use `gtk.Entry.setIconFromGicon` or
/// one of the various other functions that set an icon from a stock id, an
/// icon name or a pixbuf. To trigger an action when the user clicks an icon,
/// connect to the `gtk.Entry.signals.icon`-press signal. To allow DND operations
/// from an icon, use `gtk.Entry.setIconDragSource`. To set a tooltip on
/// an icon, use `gtk.Entry.setIconTooltipText` or the corresponding function
/// for markup.
///
/// Note that functionality or information that is only available by clicking
/// on an icon in an entry may not be accessible at all to users which are not
/// able to use a mouse or other pointing device. It is therefore recommended
/// that any such functionality should also be available by other means, e.g.
/// via the context menu of the entry.
///
/// # CSS nodes
///
/// ```
/// entry[.read-only][.flat][.warning][.error]
/// ├── image.left
/// ├── image.right
/// ├── undershoot.left
/// ├── undershoot.right
/// ├── [selection]
/// ├── [progress[.pulse]]
/// ╰── [window.popup]
/// ```
///
/// GtkEntry has a main node with the name entry. Depending on the properties
/// of the entry, the style classes .read-only and .flat may appear. The style
/// classes .warning and .error may also be used with entries.
///
/// When the entry shows icons, it adds subnodes with the name image and the
/// style class .left or .right, depending on where the icon appears.
///
/// When the entry has a selection, it adds a subnode with the name selection.
///
/// When the entry shows progress, it adds a subnode with the name progress.
/// The node has the style class .pulse when the shown progress is pulsing.
///
/// The CSS node for a context menu is added as a subnode below entry as well.
///
/// The undershoot nodes are used to draw the underflow indication when content
/// is scrolled out of view. These nodes get the .left and .right style classes
/// added depending on where the indication is drawn.
///
/// When touch is used and touch selection handles are shown, they are using
/// CSS nodes with name cursor-handle. They get the .top or .bottom style class
/// depending on where they are shown in relation to the selection. If there is
/// just a single handle for the text cursor, it gets the style class
/// .insertion-cursor.
pub const Entry = extern struct {
    pub const Parent = gtk.Widget;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.CellEditable, gtk.Editable };
    pub const Class = gtk.EntryClass;
    f_parent_instance: gtk.Widget,
    f_priv: ?*gtk.EntryPrivate,

    pub const virtual_methods = struct {
        /// Class handler for the `gtk.Entry.signals.activate` signal. The default
        ///   implementation calls `gtk.Window.activateDefault` on the entry’s top-level
        ///   window.
        pub const activate = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Entry.Class, p_class).f_activate.?(gobject.ext.as(Entry, p_entry));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Entry.Class, p_class).f_activate = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the `gtk.Entry.signals.backspace` signal. The default
        ///   implementation deletes the selection or a single character or word.
        pub const backspace = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Entry.Class, p_class).f_backspace.?(gobject.ext.as(Entry, p_entry));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Entry.Class, p_class).f_backspace = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the `gtk.Entry.signals.copy`-clipboard signal. The
        ///   default implementation copies the selection, if one exists.
        pub const copy_clipboard = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Entry.Class, p_class).f_copy_clipboard.?(gobject.ext.as(Entry, p_entry));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Entry.Class, p_class).f_copy_clipboard = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the `gtk.Entry.signals.cut`-clipboard signal. The
        ///   default implementation cuts the selection, if one exists.
        pub const cut_clipboard = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Entry.Class, p_class).f_cut_clipboard.?(gobject.ext.as(Entry, p_entry));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Entry.Class, p_class).f_cut_clipboard = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the `gtk.Entry.signals.delete`-from-cursor
        ///   signal. The default implementation deletes the selection or the specified
        ///   number of characters or words.
        pub const delete_from_cursor = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_type: gtk.DeleteType, p_count: c_int) void {
                return gobject.ext.as(Entry.Class, p_class).f_delete_from_cursor.?(gobject.ext.as(Entry, p_entry), p_type, p_count);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_type: gtk.DeleteType, p_count: c_int) callconv(.c) void) void {
                gobject.ext.as(Entry.Class, p_class).f_delete_from_cursor = @ptrCast(p_implementation);
            }
        };

        /// Calculate the size of the text area frame, which is its
        ///   allocated width and requested height, minus space for margins and borders,
        ///   and taking baseline and text height into account. This virtual function
        ///   must be non-`NULL`.
        pub const get_frame_size = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_x: *c_int, p_y: *c_int, p_width: *c_int, p_height: *c_int) void {
                return gobject.ext.as(Entry.Class, p_class).f_get_frame_size.?(gobject.ext.as(Entry, p_entry), p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_x: *c_int, p_y: *c_int, p_width: *c_int, p_height: *c_int) callconv(.c) void) void {
                gobject.ext.as(Entry.Class, p_class).f_get_frame_size = @ptrCast(p_implementation);
            }
        };

        /// Calculate the size of the text area, which is its
        ///   allocated width and requested height, minus space for margins and borders.
        ///   This virtual function must be non-`NULL`.
        pub const get_text_area_size = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_x: *c_int, p_y: *c_int, p_width: *c_int, p_height: *c_int) void {
                return gobject.ext.as(Entry.Class, p_class).f_get_text_area_size.?(gobject.ext.as(Entry, p_entry), p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_x: *c_int, p_y: *c_int, p_width: *c_int, p_height: *c_int) callconv(.c) void) void {
                gobject.ext.as(Entry.Class, p_class).f_get_text_area_size = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the `gtk.Entry.signals.insert`-at-cursor signal.
        ///   The default implementation inserts text at the cursor.
        pub const insert_at_cursor = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_str: [*:0]const u8) void {
                return gobject.ext.as(Entry.Class, p_class).f_insert_at_cursor.?(gobject.ext.as(Entry, p_entry), p_str);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_str: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(Entry.Class, p_class).f_insert_at_cursor = @ptrCast(p_implementation);
            }
        };

        pub const insert_emoji = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Entry.Class, p_class).f_insert_emoji.?(gobject.ext.as(Entry, p_entry));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Entry.Class, p_class).f_insert_emoji = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the `gtk.Entry.signals.move`-cursor signal. The
        ///   default implementation specifies the standard `gtk.Entry` cursor movement
        ///   behavior.
        pub const move_cursor = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_step: gtk.MovementStep, p_count: c_int, p_extend_selection: c_int) void {
                return gobject.ext.as(Entry.Class, p_class).f_move_cursor.?(gobject.ext.as(Entry, p_entry), p_step, p_count, p_extend_selection);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_step: gtk.MovementStep, p_count: c_int, p_extend_selection: c_int) callconv(.c) void) void {
                gobject.ext.as(Entry.Class, p_class).f_move_cursor = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the `gtk.Entry.signals.paste`-clipboard signal.
        ///   The default implementation pastes at the current cursor position or over
        ///   the current selection if one exists.
        pub const paste_clipboard = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Entry.Class, p_class).f_paste_clipboard.?(gobject.ext.as(Entry, p_entry));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Entry.Class, p_class).f_paste_clipboard = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the `gtk.Entry.signals.populate`-popup signal. If
        ///   non-`NULL`, this will be called to add additional entries to the context
        ///   menu when it is displayed.
        pub const populate_popup = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_popup: *gtk.Widget) void {
                return gobject.ext.as(Entry.Class, p_class).f_populate_popup.?(gobject.ext.as(Entry, p_entry), p_popup);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_popup: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(Entry.Class, p_class).f_populate_popup = @ptrCast(p_implementation);
            }
        };

        pub const toggle_direction = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Entry.Class, p_class).f_toggle_direction.?(gobject.ext.as(Entry, p_entry));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Entry.Class, p_class).f_toggle_direction = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the `gtk.Entry.signals.toggle`-overwrite signal.
        ///   The default implementation toggles overwrite mode and blinks the cursor.
        pub const toggle_overwrite = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Entry.Class, p_class).f_toggle_overwrite.?(gobject.ext.as(Entry, p_entry));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Entry.Class, p_class).f_toggle_overwrite = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const activates_default = struct {
            pub const name = "activates-default";

            pub const Type = c_int;
        };

        /// A list of Pango attributes to apply to the text of the entry.
        ///
        /// This is mainly useful to change the size or weight of the text.
        ///
        /// The `pango.Attribute`'s `start_index` and `end_index` must refer to the
        /// `gtk.EntryBuffer` text, i.e. without the preedit string.
        pub const attributes = struct {
            pub const name = "attributes";

            pub const Type = ?*pango.AttrList;
        };

        pub const buffer = struct {
            pub const name = "buffer";

            pub const Type = ?*gtk.EntryBuffer;
        };

        /// Whether password entries will show a warning when Caps Lock is on.
        ///
        /// Note that the warning is shown using a secondary icon, and thus
        /// does not work if you are using the secondary icon position for some
        /// other purpose.
        pub const caps_lock_warning = struct {
            pub const name = "caps-lock-warning";

            pub const Type = c_int;
        };

        /// The auxiliary completion object to use with the entry.
        pub const completion = struct {
            pub const name = "completion";

            pub const Type = ?*gtk.EntryCompletion;
        };

        pub const cursor_position = struct {
            pub const name = "cursor-position";

            pub const Type = c_int;
        };

        pub const editable = struct {
            pub const name = "editable";

            pub const Type = c_int;
        };

        pub const enable_emoji_completion = struct {
            pub const name = "enable-emoji-completion";

            pub const Type = c_int;
        };

        pub const has_frame = struct {
            pub const name = "has-frame";

            pub const Type = c_int;
        };

        /// Which IM (input method) module should be used for this entry.
        /// See `gtk.IMContext`.
        ///
        /// Setting this to a non-`NULL` value overrides the
        /// system-wide IM module setting. See the GtkSettings
        /// `gtk.Settings.properties.gtk`-im-module property.
        pub const im_module = struct {
            pub const name = "im-module";

            pub const Type = ?[*:0]u8;
        };

        /// Sets the text area's border between the text and the frame.
        pub const inner_border = struct {
            pub const name = "inner-border";

            pub const Type = ?*gtk.Border;
        };

        /// Additional hints (beyond `gtk.Entry.properties.input`-purpose) that
        /// allow input methods to fine-tune their behaviour.
        pub const input_hints = struct {
            pub const name = "input-hints";

            pub const Type = gtk.InputHints;
        };

        /// The purpose of this text field.
        ///
        /// This property can be used by on-screen keyboards and other input
        /// methods to adjust their behaviour.
        ///
        /// Note that setting the purpose to `GTK_INPUT_PURPOSE_PASSWORD` or
        /// `GTK_INPUT_PURPOSE_PIN` is independent from setting
        /// `gtk.Entry.properties.visibility`.
        pub const input_purpose = struct {
            pub const name = "input-purpose";

            pub const Type = gtk.InputPurpose;
        };

        /// The invisible character is used when masking entry contents (in
        /// \"password mode\")"). When it is not explicitly set with the
        /// `gtk.Entry.properties.invisible`-char property, GTK+ determines the character
        /// to use from a list of possible candidates, depending on availability
        /// in the current font.
        ///
        /// This style property allows the theme to prepend a character
        /// to the list of candidates.
        pub const invisible_char = struct {
            pub const name = "invisible-char";

            pub const Type = c_uint;
        };

        /// Whether the invisible char has been set for the `gtk.Entry`.
        pub const invisible_char_set = struct {
            pub const name = "invisible-char-set";

            pub const Type = c_int;
        };

        pub const max_length = struct {
            pub const name = "max-length";

            pub const Type = c_int;
        };

        /// The desired maximum width of the entry, in characters.
        /// If this property is set to -1, the width will be calculated
        /// automatically.
        pub const max_width_chars = struct {
            pub const name = "max-width-chars";

            pub const Type = c_int;
        };

        /// If text is overwritten when typing in the `gtk.Entry`.
        pub const overwrite_mode = struct {
            pub const name = "overwrite-mode";

            pub const Type = c_int;
        };

        /// The text that will be displayed in the `gtk.Entry` when it is empty
        /// and unfocused.
        pub const placeholder_text = struct {
            pub const name = "placeholder-text";

            pub const Type = ?[*:0]u8;
        };

        /// If :populate-all is `TRUE`, the `gtk.Entry.signals.populate`-popup
        /// signal is also emitted for touch popups.
        pub const populate_all = struct {
            pub const name = "populate-all";

            pub const Type = c_int;
        };

        /// Whether the primary icon is activatable.
        ///
        /// GTK+ emits the `gtk.Entry.signals.icon`-press and `gtk.Entry.signals.icon`-release
        /// signals only on sensitive, activatable icons.
        ///
        /// Sensitive, but non-activatable icons can be used for purely
        /// informational purposes.
        pub const primary_icon_activatable = struct {
            pub const name = "primary-icon-activatable";

            pub const Type = c_int;
        };

        /// The `gio.Icon` to use for the primary icon for the entry.
        pub const primary_icon_gicon = struct {
            pub const name = "primary-icon-gicon";

            pub const Type = ?*gio.Icon;
        };

        /// The icon name to use for the primary icon for the entry.
        pub const primary_icon_name = struct {
            pub const name = "primary-icon-name";

            pub const Type = ?[*:0]u8;
        };

        /// A pixbuf to use as the primary icon for the entry.
        pub const primary_icon_pixbuf = struct {
            pub const name = "primary-icon-pixbuf";

            pub const Type = ?*gdkpixbuf.Pixbuf;
        };

        /// Whether the primary icon is sensitive.
        ///
        /// An insensitive icon appears grayed out. GTK+ does not emit the
        /// `gtk.Entry.signals.icon`-press and `gtk.Entry.signals.icon`-release signals and
        /// does not allow DND from insensitive icons.
        ///
        /// An icon should be set insensitive if the action that would trigger
        /// when clicked is currently not available.
        pub const primary_icon_sensitive = struct {
            pub const name = "primary-icon-sensitive";

            pub const Type = c_int;
        };

        /// The stock id to use for the primary icon for the entry.
        pub const primary_icon_stock = struct {
            pub const name = "primary-icon-stock";

            pub const Type = ?[*:0]u8;
        };

        /// The representation which is used for the primary icon of the entry.
        pub const primary_icon_storage_type = struct {
            pub const name = "primary-icon-storage-type";

            pub const Type = gtk.ImageType;
        };

        /// The contents of the tooltip on the primary icon, which is marked up
        /// with the [Pango text markup language][PangoMarkupFormat].
        ///
        /// Also see `gtk.Entry.setIconTooltipMarkup`.
        pub const primary_icon_tooltip_markup = struct {
            pub const name = "primary-icon-tooltip-markup";

            pub const Type = ?[*:0]u8;
        };

        /// The contents of the tooltip on the primary icon.
        ///
        /// Also see `gtk.Entry.setIconTooltipText`.
        pub const primary_icon_tooltip_text = struct {
            pub const name = "primary-icon-tooltip-text";

            pub const Type = ?[*:0]u8;
        };

        /// The current fraction of the task that's been completed.
        pub const progress_fraction = struct {
            pub const name = "progress-fraction";

            pub const Type = f64;
        };

        /// The fraction of total entry width to move the progress
        /// bouncing block for each call to `gtk.Entry.progressPulse`.
        pub const progress_pulse_step = struct {
            pub const name = "progress-pulse-step";

            pub const Type = f64;
        };

        pub const scroll_offset = struct {
            pub const name = "scroll-offset";

            pub const Type = c_int;
        };

        /// Whether the secondary icon is activatable.
        ///
        /// GTK+ emits the `gtk.Entry.signals.icon`-press and `gtk.Entry.signals.icon`-release
        /// signals only on sensitive, activatable icons.
        ///
        /// Sensitive, but non-activatable icons can be used for purely
        /// informational purposes.
        pub const secondary_icon_activatable = struct {
            pub const name = "secondary-icon-activatable";

            pub const Type = c_int;
        };

        /// The `gio.Icon` to use for the secondary icon for the entry.
        pub const secondary_icon_gicon = struct {
            pub const name = "secondary-icon-gicon";

            pub const Type = ?*gio.Icon;
        };

        /// The icon name to use for the secondary icon for the entry.
        pub const secondary_icon_name = struct {
            pub const name = "secondary-icon-name";

            pub const Type = ?[*:0]u8;
        };

        /// An pixbuf to use as the secondary icon for the entry.
        pub const secondary_icon_pixbuf = struct {
            pub const name = "secondary-icon-pixbuf";

            pub const Type = ?*gdkpixbuf.Pixbuf;
        };

        /// Whether the secondary icon is sensitive.
        ///
        /// An insensitive icon appears grayed out. GTK+ does not emit the
        /// `gtk.Entry.signals.icon`-press and `gtk.Entry.signals.icon`-release signals and
        /// does not allow DND from insensitive icons.
        ///
        /// An icon should be set insensitive if the action that would trigger
        /// when clicked is currently not available.
        pub const secondary_icon_sensitive = struct {
            pub const name = "secondary-icon-sensitive";

            pub const Type = c_int;
        };

        /// The stock id to use for the secondary icon for the entry.
        pub const secondary_icon_stock = struct {
            pub const name = "secondary-icon-stock";

            pub const Type = ?[*:0]u8;
        };

        /// The representation which is used for the secondary icon of the entry.
        pub const secondary_icon_storage_type = struct {
            pub const name = "secondary-icon-storage-type";

            pub const Type = gtk.ImageType;
        };

        /// The contents of the tooltip on the secondary icon, which is marked up
        /// with the [Pango text markup language][PangoMarkupFormat].
        ///
        /// Also see `gtk.Entry.setIconTooltipMarkup`.
        pub const secondary_icon_tooltip_markup = struct {
            pub const name = "secondary-icon-tooltip-markup";

            pub const Type = ?[*:0]u8;
        };

        /// The contents of the tooltip on the secondary icon.
        ///
        /// Also see `gtk.Entry.setIconTooltipText`.
        pub const secondary_icon_tooltip_text = struct {
            pub const name = "secondary-icon-tooltip-text";

            pub const Type = ?[*:0]u8;
        };

        pub const selection_bound = struct {
            pub const name = "selection-bound";

            pub const Type = c_int;
        };

        /// Which kind of shadow to draw around the entry when
        /// `gtk.Entry.properties.has`-frame is set to `TRUE`.
        pub const shadow_type = struct {
            pub const name = "shadow-type";

            pub const Type = gtk.ShadowType;
        };

        pub const show_emoji_icon = struct {
            pub const name = "show-emoji-icon";

            pub const Type = c_int;
        };

        pub const tabs = struct {
            pub const name = "tabs";

            pub const Type = ?*pango.TabArray;
        };

        pub const text = struct {
            pub const name = "text";

            pub const Type = ?[*:0]u8;
        };

        /// The length of the text in the `gtk.Entry`.
        pub const text_length = struct {
            pub const name = "text-length";

            pub const Type = c_uint;
        };

        /// When `TRUE`, pasted multi-line text is truncated to the first line.
        pub const truncate_multiline = struct {
            pub const name = "truncate-multiline";

            pub const Type = c_int;
        };

        pub const visibility = struct {
            pub const name = "visibility";

            pub const Type = c_int;
        };

        pub const width_chars = struct {
            pub const name = "width-chars";

            pub const Type = c_int;
        };

        /// The horizontal alignment, from 0 (left) to 1 (right).
        /// Reversed for RTL layouts.
        pub const xalign = struct {
            pub const name = "xalign";

            pub const Type = f32;
        };
    };

    pub const signals = struct {
        /// The ::activate signal is emitted when the user hits
        /// the Enter key.
        ///
        /// While this signal is used as a
        /// [keybinding signal][GtkBindingSignal],
        /// it is also commonly used by applications to intercept
        /// activation of entries.
        ///
        /// The default bindings for this signal are all forms of the Enter key.
        pub const activate = struct {
            pub const name = "activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Entry, p_instance))),
                    gobject.signalLookup("activate", Entry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::backspace signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user asks for it.
        ///
        /// The default bindings for this signal are
        /// Backspace and Shift-Backspace.
        pub const backspace = struct {
            pub const name = "backspace";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Entry, p_instance))),
                    gobject.signalLookup("backspace", Entry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::copy-clipboard signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to copy the selection to the clipboard.
        ///
        /// The default bindings for this signal are
        /// Ctrl-c and Ctrl-Insert.
        pub const copy_clipboard = struct {
            pub const name = "copy-clipboard";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Entry, p_instance))),
                    gobject.signalLookup("copy-clipboard", Entry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::cut-clipboard signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to cut the selection to the clipboard.
        ///
        /// The default bindings for this signal are
        /// Ctrl-x and Shift-Delete.
        pub const cut_clipboard = struct {
            pub const name = "cut-clipboard";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Entry, p_instance))),
                    gobject.signalLookup("cut-clipboard", Entry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::delete-from-cursor signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user initiates a text deletion.
        ///
        /// If the `type` is `GTK_DELETE_CHARS`, GTK+ deletes the selection
        /// if there is one, otherwise it deletes the requested number
        /// of characters.
        ///
        /// The default bindings for this signal are
        /// Delete for deleting a character and Ctrl-Delete for
        /// deleting a word.
        pub const delete_from_cursor = struct {
            pub const name = "delete-from-cursor";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_type: gtk.DeleteType, p_count: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Entry, p_instance))),
                    gobject.signalLookup("delete-from-cursor", Entry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::icon-press signal is emitted when an activatable icon
        /// is clicked.
        pub const icon_press = struct {
            pub const name = "icon-press";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_icon_pos: gtk.EntryIconPosition, p_event: *gdk.Event, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Entry, p_instance))),
                    gobject.signalLookup("icon-press", Entry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::icon-release signal is emitted on the button release from a
        /// mouse click over an activatable icon.
        pub const icon_release = struct {
            pub const name = "icon-release";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_icon_pos: gtk.EntryIconPosition, p_event: *gdk.Event, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Entry, p_instance))),
                    gobject.signalLookup("icon-release", Entry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::insert-at-cursor signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user initiates the insertion of a
        /// fixed string at the cursor.
        ///
        /// This signal has no default bindings.
        pub const insert_at_cursor = struct {
            pub const name = "insert-at-cursor";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_string: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Entry, p_instance))),
                    gobject.signalLookup("insert-at-cursor", Entry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::insert-emoji signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to present the Emoji chooser for the `entry`.
        ///
        /// The default bindings for this signal are Ctrl-. and Ctrl-;
        pub const insert_emoji = struct {
            pub const name = "insert-emoji";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Entry, p_instance))),
                    gobject.signalLookup("insert-emoji", Entry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::move-cursor signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user initiates a cursor movement.
        /// If the cursor is not visible in `entry`, this signal causes
        /// the viewport to be moved instead.
        ///
        /// Applications should not connect to it, but may emit it with
        /// `gobject.signalEmitByName` if they need to control the cursor
        /// programmatically.
        ///
        /// The default bindings for this signal come in two variants,
        /// the variant with the Shift modifier extends the selection,
        /// the variant without the Shift modifer does not.
        /// There are too many key combinations to list them all here.
        /// - Arrow keys move by individual characters/lines
        /// - Ctrl-arrow key combinations move by words/paragraphs
        /// - Home/End keys move to the ends of the buffer
        pub const move_cursor = struct {
            pub const name = "move-cursor";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_step: gtk.MovementStep, p_count: c_int, p_extend_selection: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Entry, p_instance))),
                    gobject.signalLookup("move-cursor", Entry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::paste-clipboard signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to paste the contents of the clipboard
        /// into the text view.
        ///
        /// The default bindings for this signal are
        /// Ctrl-v and Shift-Insert.
        pub const paste_clipboard = struct {
            pub const name = "paste-clipboard";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Entry, p_instance))),
                    gobject.signalLookup("paste-clipboard", Entry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::populate-popup signal gets emitted before showing the
        /// context menu of the entry.
        ///
        /// If you need to add items to the context menu, connect
        /// to this signal and append your items to the `widget`, which
        /// will be a `gtk.Menu` in this case.
        ///
        /// If `gtk.Entry.properties.populate`-all is `TRUE`, this signal will
        /// also be emitted to populate touch popups. In this case,
        /// `widget` will be a different container, e.g. a `gtk.Toolbar`.
        /// The signal handler should not make assumptions about the
        /// type of `widget`.
        pub const populate_popup = struct {
            pub const name = "populate-popup";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_widget: *gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Entry, p_instance))),
                    gobject.signalLookup("populate-popup", Entry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// If an input method is used, the typed text will not immediately
        /// be committed to the buffer. So if you are interested in the text,
        /// connect to this signal.
        pub const preedit_changed = struct {
            pub const name = "preedit-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_preedit: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Entry, p_instance))),
                    gobject.signalLookup("preedit-changed", Entry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const toggle_direction = struct {
            pub const name = "toggle-direction";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Entry, p_instance))),
                    gobject.signalLookup("toggle-direction", Entry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::toggle-overwrite signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to toggle the overwrite mode of the entry.
        ///
        /// The default bindings for this signal is Insert.
        pub const toggle_overwrite = struct {
            pub const name = "toggle-overwrite";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Entry, p_instance))),
                    gobject.signalLookup("toggle-overwrite", Entry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new entry.
    extern fn gtk_entry_new() *gtk.Entry;
    pub const new = gtk_entry_new;

    /// Creates a new entry with the specified text buffer.
    extern fn gtk_entry_new_with_buffer(p_buffer: *gtk.EntryBuffer) *gtk.Entry;
    pub const newWithBuffer = gtk_entry_new_with_buffer;

    /// Retrieves the value set by `gtk.Entry.setActivatesDefault`.
    extern fn gtk_entry_get_activates_default(p_entry: *Entry) c_int;
    pub const getActivatesDefault = gtk_entry_get_activates_default;

    /// Gets the value set by `gtk.Entry.setAlignment`.
    extern fn gtk_entry_get_alignment(p_entry: *Entry) f32;
    pub const getAlignment = gtk_entry_get_alignment;

    /// Gets the attribute list that was set on the entry using
    /// `gtk.Entry.setAttributes`, if any.
    extern fn gtk_entry_get_attributes(p_entry: *Entry) ?*pango.AttrList;
    pub const getAttributes = gtk_entry_get_attributes;

    /// Get the `gtk.EntryBuffer` object which holds the text for
    /// this widget.
    extern fn gtk_entry_get_buffer(p_entry: *Entry) *gtk.EntryBuffer;
    pub const getBuffer = gtk_entry_get_buffer;

    /// Returns the auxiliary completion object currently in use by `entry`.
    extern fn gtk_entry_get_completion(p_entry: *Entry) *gtk.EntryCompletion;
    pub const getCompletion = gtk_entry_get_completion;

    /// Returns the index of the icon which is the source of the current
    /// DND operation, or -1.
    ///
    /// This function is meant to be used in a `gtk.Widget.signals.drag`-data-get
    /// callback.
    extern fn gtk_entry_get_current_icon_drag_source(p_entry: *Entry) c_int;
    pub const getCurrentIconDragSource = gtk_entry_get_current_icon_drag_source;

    /// Retrieves the horizontal cursor adjustment for the entry.
    /// See `gtk.Entry.setCursorHadjustment`.
    extern fn gtk_entry_get_cursor_hadjustment(p_entry: *Entry) ?*gtk.Adjustment;
    pub const getCursorHadjustment = gtk_entry_get_cursor_hadjustment;

    /// Gets the value set by `gtk.Entry.setHasFrame`.
    extern fn gtk_entry_get_has_frame(p_entry: *Entry) c_int;
    pub const getHasFrame = gtk_entry_get_has_frame;

    /// Returns whether the icon is activatable.
    extern fn gtk_entry_get_icon_activatable(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition) c_int;
    pub const getIconActivatable = gtk_entry_get_icon_activatable;

    /// Gets the area where entry’s icon at `icon_pos` is drawn.
    /// This function is useful when drawing something to the
    /// entry in a draw callback.
    ///
    /// If the entry is not realized or has no icon at the given position,
    /// `icon_area` is filled with zeros. Otherwise, `icon_area` will be filled
    /// with the icon’s allocation, relative to `entry`’s allocation.
    ///
    /// See also `gtk.Entry.getTextArea`
    extern fn gtk_entry_get_icon_area(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition, p_icon_area: *gdk.Rectangle) void;
    pub const getIconArea = gtk_entry_get_icon_area;

    /// Finds the icon at the given position and return its index. The
    /// position’s coordinates are relative to the `entry`’s top left corner.
    /// If `x`, `y` doesn’t lie inside an icon, -1 is returned.
    /// This function is intended for use in a `gtk.Widget.signals.query`-tooltip
    /// signal handler.
    extern fn gtk_entry_get_icon_at_pos(p_entry: *Entry, p_x: c_int, p_y: c_int) c_int;
    pub const getIconAtPos = gtk_entry_get_icon_at_pos;

    /// Retrieves the `gio.Icon` used for the icon, or `NULL` if there is
    /// no icon or if the icon was set by some other method (e.g., by
    /// stock, pixbuf, or icon name).
    extern fn gtk_entry_get_icon_gicon(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition) ?*gio.Icon;
    pub const getIconGicon = gtk_entry_get_icon_gicon;

    /// Retrieves the icon name used for the icon, or `NULL` if there is
    /// no icon or if the icon was set by some other method (e.g., by
    /// pixbuf, stock or gicon).
    extern fn gtk_entry_get_icon_name(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition) ?[*:0]const u8;
    pub const getIconName = gtk_entry_get_icon_name;

    /// Retrieves the image used for the icon.
    ///
    /// Unlike the other methods of setting and getting icon data, this
    /// method will work regardless of whether the icon was set using a
    /// `gdkpixbuf.Pixbuf`, a `gio.Icon`, a stock item, or an icon name.
    extern fn gtk_entry_get_icon_pixbuf(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition) ?*gdkpixbuf.Pixbuf;
    pub const getIconPixbuf = gtk_entry_get_icon_pixbuf;

    /// Returns whether the icon appears sensitive or insensitive.
    extern fn gtk_entry_get_icon_sensitive(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition) c_int;
    pub const getIconSensitive = gtk_entry_get_icon_sensitive;

    /// Retrieves the stock id used for the icon, or `NULL` if there is
    /// no icon or if the icon was set by some other method (e.g., by
    /// pixbuf, icon name or gicon).
    extern fn gtk_entry_get_icon_stock(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition) [*:0]const u8;
    pub const getIconStock = gtk_entry_get_icon_stock;

    /// Gets the type of representation being used by the icon
    /// to store image data. If the icon has no image data,
    /// the return value will be `GTK_IMAGE_EMPTY`.
    extern fn gtk_entry_get_icon_storage_type(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition) gtk.ImageType;
    pub const getIconStorageType = gtk_entry_get_icon_storage_type;

    /// Gets the contents of the tooltip on the icon at the specified
    /// position in `entry`.
    extern fn gtk_entry_get_icon_tooltip_markup(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition) ?[*:0]u8;
    pub const getIconTooltipMarkup = gtk_entry_get_icon_tooltip_markup;

    /// Gets the contents of the tooltip on the icon at the specified
    /// position in `entry`.
    extern fn gtk_entry_get_icon_tooltip_text(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition) ?[*:0]u8;
    pub const getIconTooltipText = gtk_entry_get_icon_tooltip_text;

    /// This function returns the entry’s `gtk.Entry.properties.inner`-border property. See
    /// `gtk.Entry.setInnerBorder` for more information.
    extern fn gtk_entry_get_inner_border(p_entry: *Entry) ?*const gtk.Border;
    pub const getInnerBorder = gtk_entry_get_inner_border;

    /// Gets the value of the `gtk.Entry.properties.input`-hints property.
    extern fn gtk_entry_get_input_hints(p_entry: *Entry) gtk.InputHints;
    pub const getInputHints = gtk_entry_get_input_hints;

    /// Gets the value of the `gtk.Entry.properties.input`-purpose property.
    extern fn gtk_entry_get_input_purpose(p_entry: *Entry) gtk.InputPurpose;
    pub const getInputPurpose = gtk_entry_get_input_purpose;

    /// Retrieves the character displayed in place of the real characters
    /// for entries with visibility set to false. See `gtk.Entry.setInvisibleChar`.
    extern fn gtk_entry_get_invisible_char(p_entry: *Entry) u32;
    pub const getInvisibleChar = gtk_entry_get_invisible_char;

    /// Gets the `pango.Layout` used to display the entry.
    /// The layout is useful to e.g. convert text positions to
    /// pixel positions, in combination with `gtk.Entry.getLayoutOffsets`.
    /// The returned layout is owned by the entry and must not be
    /// modified or freed by the caller.
    ///
    /// Keep in mind that the layout text may contain a preedit string, so
    /// `gtk.Entry.layoutIndexToTextIndex` and
    /// `gtk.Entry.textIndexToLayoutIndex` are needed to convert byte
    /// indices in the layout to byte indices in the entry contents.
    extern fn gtk_entry_get_layout(p_entry: *Entry) *pango.Layout;
    pub const getLayout = gtk_entry_get_layout;

    /// Obtains the position of the `pango.Layout` used to render text
    /// in the entry, in widget coordinates. Useful if you want to line
    /// up the text in an entry with some other text, e.g. when using the
    /// entry to implement editable cells in a sheet widget.
    ///
    /// Also useful to convert mouse events into coordinates inside the
    /// `pango.Layout`, e.g. to take some action if some part of the entry text
    /// is clicked.
    ///
    /// Note that as the user scrolls around in the entry the offsets will
    /// change; you’ll need to connect to the “notify::scroll-offset”
    /// signal to track this. Remember when using the `pango.Layout`
    /// functions you need to convert to and from pixels using
    /// `PANGO_PIXELS` or `PANGO_SCALE`.
    ///
    /// Keep in mind that the layout text may contain a preedit string, so
    /// `gtk.Entry.layoutIndexToTextIndex` and
    /// `gtk.Entry.textIndexToLayoutIndex` are needed to convert byte
    /// indices in the layout to byte indices in the entry contents.
    extern fn gtk_entry_get_layout_offsets(p_entry: *Entry, p_x: ?*c_int, p_y: ?*c_int) void;
    pub const getLayoutOffsets = gtk_entry_get_layout_offsets;

    /// Retrieves the maximum allowed length of the text in
    /// `entry`. See `gtk.Entry.setMaxLength`.
    ///
    /// This is equivalent to getting `entry`'s `gtk.EntryBuffer` and
    /// calling `gtk.EntryBuffer.getMaxLength` on it.
    extern fn gtk_entry_get_max_length(p_entry: *Entry) c_int;
    pub const getMaxLength = gtk_entry_get_max_length;

    /// Retrieves the desired maximum width of `entry`, in characters.
    /// See `gtk.Entry.setMaxWidthChars`.
    extern fn gtk_entry_get_max_width_chars(p_entry: *Entry) c_int;
    pub const getMaxWidthChars = gtk_entry_get_max_width_chars;

    /// Gets the value set by `gtk.Entry.setOverwriteMode`.
    extern fn gtk_entry_get_overwrite_mode(p_entry: *Entry) c_int;
    pub const getOverwriteMode = gtk_entry_get_overwrite_mode;

    /// Retrieves the text that will be displayed when `entry` is empty and unfocused
    extern fn gtk_entry_get_placeholder_text(p_entry: *Entry) [*:0]const u8;
    pub const getPlaceholderText = gtk_entry_get_placeholder_text;

    /// Returns the current fraction of the task that’s been completed.
    /// See `gtk.Entry.setProgressFraction`.
    extern fn gtk_entry_get_progress_fraction(p_entry: *Entry) f64;
    pub const getProgressFraction = gtk_entry_get_progress_fraction;

    /// Retrieves the pulse step set with `gtk.Entry.setProgressPulseStep`.
    extern fn gtk_entry_get_progress_pulse_step(p_entry: *Entry) f64;
    pub const getProgressPulseStep = gtk_entry_get_progress_pulse_step;

    /// Gets the tabstops that were set on the entry using `gtk.Entry.setTabs`, if
    /// any.
    extern fn gtk_entry_get_tabs(p_entry: *Entry) ?*pango.TabArray;
    pub const getTabs = gtk_entry_get_tabs;

    /// Retrieves the contents of the entry widget.
    /// See also `gtk.Editable.getChars`.
    ///
    /// This is equivalent to getting `entry`'s `gtk.EntryBuffer` and calling
    /// `gtk.EntryBuffer.getText` on it.
    extern fn gtk_entry_get_text(p_entry: *Entry) [*:0]const u8;
    pub const getText = gtk_entry_get_text;

    /// Gets the area where the entry’s text is drawn. This function is
    /// useful when drawing something to the entry in a draw callback.
    ///
    /// If the entry is not realized, `text_area` is filled with zeros.
    ///
    /// See also `gtk.Entry.getIconArea`.
    extern fn gtk_entry_get_text_area(p_entry: *Entry, p_text_area: *gdk.Rectangle) void;
    pub const getTextArea = gtk_entry_get_text_area;

    /// Retrieves the current length of the text in
    /// `entry`.
    ///
    /// This is equivalent to getting `entry`'s `gtk.EntryBuffer` and
    /// calling `gtk.EntryBuffer.getLength` on it.
    extern fn gtk_entry_get_text_length(p_entry: *Entry) u16;
    pub const getTextLength = gtk_entry_get_text_length;

    /// Retrieves whether the text in `entry` is visible. See
    /// `gtk.Entry.setVisibility`.
    extern fn gtk_entry_get_visibility(p_entry: *Entry) c_int;
    pub const getVisibility = gtk_entry_get_visibility;

    /// Gets the value set by `gtk.Entry.setWidthChars`.
    extern fn gtk_entry_get_width_chars(p_entry: *Entry) c_int;
    pub const getWidthChars = gtk_entry_get_width_chars;

    /// Causes `entry` to have keyboard focus.
    ///
    /// It behaves like `gtk.Widget.grabFocus`,
    /// except that it doesn't select the contents of the entry.
    /// You only want to call this on some special entries
    /// which the user usually doesn't want to replace all text in,
    /// such as search-as-you-type entries.
    extern fn gtk_entry_grab_focus_without_selecting(p_entry: *Entry) void;
    pub const grabFocusWithoutSelecting = gtk_entry_grab_focus_without_selecting;

    /// Allow the `gtk.Entry` input method to internally handle key press
    /// and release events. If this function returns `TRUE`, then no further
    /// processing should be done for this key event. See
    /// `gtk.IMContext.filterKeypress`.
    ///
    /// Note that you are expected to call this function from your handler
    /// when overriding key event handling. This is needed in the case when
    /// you need to insert your own key handling between the input method
    /// and the default key event handling of the `gtk.Entry`.
    /// See `gtk.TextView.resetImContext` for an example of use.
    extern fn gtk_entry_im_context_filter_keypress(p_entry: *Entry, p_event: *gdk.EventKey) c_int;
    pub const imContextFilterKeypress = gtk_entry_im_context_filter_keypress;

    /// Converts from a position in the entry’s `pango.Layout` (returned by
    /// `gtk.Entry.getLayout`) to a position in the entry contents
    /// (returned by `gtk.Entry.getText`).
    extern fn gtk_entry_layout_index_to_text_index(p_entry: *Entry, p_layout_index: c_int) c_int;
    pub const layoutIndexToTextIndex = gtk_entry_layout_index_to_text_index;

    /// Indicates that some progress is made, but you don’t know how much.
    /// Causes the entry’s progress indicator to enter “activity mode,”
    /// where a block bounces back and forth. Each call to
    /// `gtk.Entry.progressPulse` causes the block to move by a little bit
    /// (the amount of movement per pulse is determined by
    /// `gtk.Entry.setProgressPulseStep`).
    extern fn gtk_entry_progress_pulse(p_entry: *Entry) void;
    pub const progressPulse = gtk_entry_progress_pulse;

    /// Reset the input method context of the entry if needed.
    ///
    /// This can be necessary in the case where modifying the buffer
    /// would confuse on-going input method behavior.
    extern fn gtk_entry_reset_im_context(p_entry: *Entry) void;
    pub const resetImContext = gtk_entry_reset_im_context;

    /// If `setting` is `TRUE`, pressing Enter in the `entry` will activate the default
    /// widget for the window containing the entry. This usually means that
    /// the dialog box containing the entry will be closed, since the default
    /// widget is usually one of the dialog buttons.
    ///
    /// (For experts: if `setting` is `TRUE`, the entry calls
    /// `gtk.Window.activateDefault` on the window containing the entry, in
    /// the default handler for the `gtk.Entry.signals.activate` signal.)
    extern fn gtk_entry_set_activates_default(p_entry: *Entry, p_setting: c_int) void;
    pub const setActivatesDefault = gtk_entry_set_activates_default;

    /// Sets the alignment for the contents of the entry. This controls
    /// the horizontal positioning of the contents when the displayed
    /// text is shorter than the width of the entry.
    extern fn gtk_entry_set_alignment(p_entry: *Entry, p_xalign: f32) void;
    pub const setAlignment = gtk_entry_set_alignment;

    /// Sets a `pango.AttrList`; the attributes in the list are applied to the
    /// entry text.
    extern fn gtk_entry_set_attributes(p_entry: *Entry, p_attrs: *pango.AttrList) void;
    pub const setAttributes = gtk_entry_set_attributes;

    /// Set the `gtk.EntryBuffer` object which holds the text for
    /// this widget.
    extern fn gtk_entry_set_buffer(p_entry: *Entry, p_buffer: *gtk.EntryBuffer) void;
    pub const setBuffer = gtk_entry_set_buffer;

    /// Sets `completion` to be the auxiliary completion object to use with `entry`.
    /// All further configuration of the completion mechanism is done on
    /// `completion` using the `gtk.EntryCompletion` API. Completion is disabled if
    /// `completion` is set to `NULL`.
    extern fn gtk_entry_set_completion(p_entry: *Entry, p_completion: ?*gtk.EntryCompletion) void;
    pub const setCompletion = gtk_entry_set_completion;

    /// Hooks up an adjustment to the cursor position in an entry, so that when
    /// the cursor is moved, the adjustment is scrolled to show that position.
    /// See `gtk.ScrolledWindow.getHadjustment` for a typical way of obtaining
    /// the adjustment.
    ///
    /// The adjustment has to be in pixel units and in the same coordinate system
    /// as the entry.
    extern fn gtk_entry_set_cursor_hadjustment(p_entry: *Entry, p_adjustment: ?*gtk.Adjustment) void;
    pub const setCursorHadjustment = gtk_entry_set_cursor_hadjustment;

    /// Sets whether the entry has a beveled frame around it.
    extern fn gtk_entry_set_has_frame(p_entry: *Entry, p_setting: c_int) void;
    pub const setHasFrame = gtk_entry_set_has_frame;

    /// Sets whether the icon is activatable.
    extern fn gtk_entry_set_icon_activatable(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition, p_activatable: c_int) void;
    pub const setIconActivatable = gtk_entry_set_icon_activatable;

    /// Sets up the icon at the given position so that GTK+ will start a drag
    /// operation when the user clicks and drags the icon.
    ///
    /// To handle the drag operation, you need to connect to the usual
    /// `gtk.Widget.signals.drag`-data-get (or possibly `gtk.Widget.signals.drag`-data-delete)
    /// signal, and use `gtk.Entry.getCurrentIconDragSource` in
    /// your signal handler to find out if the drag was started from
    /// an icon.
    ///
    /// By default, GTK+ uses the icon as the drag icon. You can use the
    /// `gtk.Widget.signals.drag`-begin signal to set a different icon. Note that you
    /// have to use `g_signal_connect_after` to ensure that your signal handler
    /// gets executed after the default handler.
    extern fn gtk_entry_set_icon_drag_source(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition, p_target_list: *gtk.TargetList, p_actions: gdk.DragAction) void;
    pub const setIconDragSource = gtk_entry_set_icon_drag_source;

    /// Sets the icon shown in the entry at the specified position
    /// from the current icon theme.
    /// If the icon isn’t known, a “broken image” icon will be displayed
    /// instead.
    ///
    /// If `icon` is `NULL`, no icon will be shown in the specified position.
    extern fn gtk_entry_set_icon_from_gicon(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition, p_icon: ?*gio.Icon) void;
    pub const setIconFromGicon = gtk_entry_set_icon_from_gicon;

    /// Sets the icon shown in the entry at the specified position
    /// from the current icon theme.
    ///
    /// If the icon name isn’t known, a “broken image” icon will be displayed
    /// instead.
    ///
    /// If `icon_name` is `NULL`, no icon will be shown in the specified position.
    extern fn gtk_entry_set_icon_from_icon_name(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition, p_icon_name: ?[*:0]const u8) void;
    pub const setIconFromIconName = gtk_entry_set_icon_from_icon_name;

    /// Sets the icon shown in the specified position using a pixbuf.
    ///
    /// If `pixbuf` is `NULL`, no icon will be shown in the specified position.
    extern fn gtk_entry_set_icon_from_pixbuf(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition, p_pixbuf: ?*gdkpixbuf.Pixbuf) void;
    pub const setIconFromPixbuf = gtk_entry_set_icon_from_pixbuf;

    /// Sets the icon shown in the entry at the specified position from
    /// a stock image.
    ///
    /// If `stock_id` is `NULL`, no icon will be shown in the specified position.
    extern fn gtk_entry_set_icon_from_stock(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition, p_stock_id: ?[*:0]const u8) void;
    pub const setIconFromStock = gtk_entry_set_icon_from_stock;

    /// Sets the sensitivity for the specified icon.
    extern fn gtk_entry_set_icon_sensitive(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition, p_sensitive: c_int) void;
    pub const setIconSensitive = gtk_entry_set_icon_sensitive;

    /// Sets `tooltip` as the contents of the tooltip for the icon at
    /// the specified position. `tooltip` is assumed to be marked up with
    /// the [Pango text markup language][PangoMarkupFormat].
    ///
    /// Use `NULL` for `tooltip` to remove an existing tooltip.
    ///
    /// See also `gtk.Widget.setTooltipMarkup` and
    /// `gtk.Entry.setIconTooltipText`.
    extern fn gtk_entry_set_icon_tooltip_markup(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition, p_tooltip: ?[*:0]const u8) void;
    pub const setIconTooltipMarkup = gtk_entry_set_icon_tooltip_markup;

    /// Sets `tooltip` as the contents of the tooltip for the icon
    /// at the specified position.
    ///
    /// Use `NULL` for `tooltip` to remove an existing tooltip.
    ///
    /// See also `gtk.Widget.setTooltipText` and
    /// `gtk.Entry.setIconTooltipMarkup`.
    ///
    /// If you unset the widget tooltip via `gtk.Widget.setTooltipText` or
    /// `gtk.Widget.setTooltipMarkup`, this sets GtkWidget:has-tooltip to `FALSE`,
    /// which suppresses icon tooltips too. You can resolve this by then calling
    /// `gtk.Widget.setHasTooltip` to set GtkWidget:has-tooltip back to `TRUE`, or
    /// setting at least one non-empty tooltip on any icon achieves the same result.
    extern fn gtk_entry_set_icon_tooltip_text(p_entry: *Entry, p_icon_pos: gtk.EntryIconPosition, p_tooltip: ?[*:0]const u8) void;
    pub const setIconTooltipText = gtk_entry_set_icon_tooltip_text;

    /// Sets `entry`’s inner-border property to `border`, or clears it if `NULL`
    /// is passed. The inner-border is the area around the entry’s text, but
    /// inside its frame.
    ///
    /// If set, this property overrides the inner-border style property.
    /// Overriding the style-provided border is useful when you want to do
    /// in-place editing of some text in a canvas or list widget, where
    /// pixel-exact positioning of the entry is important.
    extern fn gtk_entry_set_inner_border(p_entry: *Entry, p_border: ?*const gtk.Border) void;
    pub const setInnerBorder = gtk_entry_set_inner_border;

    /// Sets the `gtk.Entry.properties.input`-hints property, which
    /// allows input methods to fine-tune their behaviour.
    extern fn gtk_entry_set_input_hints(p_entry: *Entry, p_hints: gtk.InputHints) void;
    pub const setInputHints = gtk_entry_set_input_hints;

    /// Sets the `gtk.Entry.properties.input`-purpose property which
    /// can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    extern fn gtk_entry_set_input_purpose(p_entry: *Entry, p_purpose: gtk.InputPurpose) void;
    pub const setInputPurpose = gtk_entry_set_input_purpose;

    /// Sets the character to use in place of the actual text when
    /// `gtk.Entry.setVisibility` has been called to set text visibility
    /// to `FALSE`. i.e. this is the character used in “password mode” to
    /// show the user how many characters have been typed. By default, GTK+
    /// picks the best invisible char available in the current font. If you
    /// set the invisible char to 0, then the user will get no feedback
    /// at all; there will be no text on the screen as they type.
    extern fn gtk_entry_set_invisible_char(p_entry: *Entry, p_ch: u32) void;
    pub const setInvisibleChar = gtk_entry_set_invisible_char;

    /// Sets the maximum allowed length of the contents of the widget. If
    /// the current contents are longer than the given length, then they
    /// will be truncated to fit.
    ///
    /// This is equivalent to getting `entry`'s `gtk.EntryBuffer` and
    /// calling `gtk.EntryBuffer.setMaxLength` on it.
    /// ```
    extern fn gtk_entry_set_max_length(p_entry: *Entry, p_max: c_int) void;
    pub const setMaxLength = gtk_entry_set_max_length;

    /// Sets the desired maximum width in characters of `entry`.
    extern fn gtk_entry_set_max_width_chars(p_entry: *Entry, p_n_chars: c_int) void;
    pub const setMaxWidthChars = gtk_entry_set_max_width_chars;

    /// Sets whether the text is overwritten when typing in the `gtk.Entry`.
    extern fn gtk_entry_set_overwrite_mode(p_entry: *Entry, p_overwrite: c_int) void;
    pub const setOverwriteMode = gtk_entry_set_overwrite_mode;

    /// Sets text to be displayed in `entry` when it is empty and unfocused.
    /// This can be used to give a visual hint of the expected contents of
    /// the `gtk.Entry`.
    ///
    /// Note that since the placeholder text gets removed when the entry
    /// received focus, using this feature is a bit problematic if the entry
    /// is given the initial focus in a window. Sometimes this can be
    /// worked around by delaying the initial focus setting until the
    /// first key event arrives.
    extern fn gtk_entry_set_placeholder_text(p_entry: *Entry, p_text: ?[*:0]const u8) void;
    pub const setPlaceholderText = gtk_entry_set_placeholder_text;

    /// Causes the entry’s progress indicator to “fill in” the given
    /// fraction of the bar. The fraction should be between 0.0 and 1.0,
    /// inclusive.
    extern fn gtk_entry_set_progress_fraction(p_entry: *Entry, p_fraction: f64) void;
    pub const setProgressFraction = gtk_entry_set_progress_fraction;

    /// Sets the fraction of total entry width to move the progress
    /// bouncing block for each call to `gtk.Entry.progressPulse`.
    extern fn gtk_entry_set_progress_pulse_step(p_entry: *Entry, p_fraction: f64) void;
    pub const setProgressPulseStep = gtk_entry_set_progress_pulse_step;

    /// Sets a `pango.TabArray`; the tabstops in the array are applied to the entry
    /// text.
    extern fn gtk_entry_set_tabs(p_entry: *Entry, p_tabs: *pango.TabArray) void;
    pub const setTabs = gtk_entry_set_tabs;

    /// Sets the text in the widget to the given
    /// value, replacing the current contents.
    ///
    /// See `gtk.EntryBuffer.setText`.
    extern fn gtk_entry_set_text(p_entry: *Entry, p_text: [*:0]const u8) void;
    pub const setText = gtk_entry_set_text;

    /// Sets whether the contents of the entry are visible or not.
    /// When visibility is set to `FALSE`, characters are displayed
    /// as the invisible char, and will also appear that way when
    /// the text in the entry widget is copied elsewhere.
    ///
    /// By default, GTK+ picks the best invisible character available
    /// in the current font, but it can be changed with
    /// `gtk.Entry.setInvisibleChar`.
    ///
    /// Note that you probably want to set `gtk.Entry.properties.input`-purpose
    /// to `GTK_INPUT_PURPOSE_PASSWORD` or `GTK_INPUT_PURPOSE_PIN` to
    /// inform input methods about the purpose of this entry,
    /// in addition to setting visibility to `FALSE`.
    extern fn gtk_entry_set_visibility(p_entry: *Entry, p_visible: c_int) void;
    pub const setVisibility = gtk_entry_set_visibility;

    /// Changes the size request of the entry to be about the right size
    /// for `n_chars` characters. Note that it changes the size
    /// request, the size can still be affected by
    /// how you pack the widget into containers. If `n_chars` is -1, the
    /// size reverts to the default entry size.
    extern fn gtk_entry_set_width_chars(p_entry: *Entry, p_n_chars: c_int) void;
    pub const setWidthChars = gtk_entry_set_width_chars;

    /// Converts from a position in the entry contents (returned
    /// by `gtk.Entry.getText`) to a position in the
    /// entry’s `pango.Layout` (returned by `gtk.Entry.getLayout`,
    /// with text retrieved via `pango.Layout.getText`).
    extern fn gtk_entry_text_index_to_layout_index(p_entry: *Entry, p_text_index: c_int) c_int;
    pub const textIndexToLayoutIndex = gtk_entry_text_index_to_layout_index;

    /// Unsets the invisible char previously set with
    /// `gtk.Entry.setInvisibleChar`. So that the
    /// default invisible char is used again.
    extern fn gtk_entry_unset_invisible_char(p_entry: *Entry) void;
    pub const unsetInvisibleChar = gtk_entry_unset_invisible_char;

    extern fn gtk_entry_get_type() usize;
    pub const getGObjectType = gtk_entry_get_type;

    extern fn g_object_ref(p_self: *gtk.Entry) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Entry) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Entry, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EntryAccessible = extern struct {
    pub const Parent = gtk.WidgetAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.EditableText, atk.Text };
    pub const Class = gtk.EntryAccessibleClass;
    f_parent: gtk.WidgetAccessible,
    f_priv: ?*gtk.EntryAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_entry_accessible_get_type() usize;
    pub const getGObjectType = gtk_entry_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.EntryAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.EntryAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *EntryAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.EntryBuffer` class contains the actual text displayed in a
/// `gtk.Entry` widget.
///
/// A single `gtk.EntryBuffer` object can be shared by multiple `gtk.Entry`
/// widgets which will then share the same text content, but not the cursor
/// position, visibility attributes, icon etc.
///
/// `gtk.EntryBuffer` may be derived from. Such a derived class might allow
/// text to be stored in an alternate location, such as non-pageable memory,
/// useful in the case of important passwords. Or a derived class could
/// integrate with an application’s concept of undo/redo.
pub const EntryBuffer = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.EntryBufferClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.EntryBufferPrivate,

    pub const virtual_methods = struct {
        /// Deletes a sequence of characters from the buffer. `n_chars` characters are
        /// deleted starting at `position`. If `n_chars` is negative, then all characters
        /// until the end of the text are deleted.
        ///
        /// If `position` or `n_chars` are out of bounds, then they are coerced to sane
        /// values.
        ///
        /// Note that the positions are specified in characters, not bytes.
        pub const delete_text = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_position: c_uint, p_n_chars: c_uint) c_uint {
                return gobject.ext.as(EntryBuffer.Class, p_class).f_delete_text.?(gobject.ext.as(EntryBuffer, p_buffer), p_position, p_n_chars);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_position: c_uint, p_n_chars: c_uint) callconv(.c) c_uint) void {
                gobject.ext.as(EntryBuffer.Class, p_class).f_delete_text = @ptrCast(p_implementation);
            }
        };

        pub const deleted_text = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_position: c_uint, p_n_chars: c_uint) void {
                return gobject.ext.as(EntryBuffer.Class, p_class).f_deleted_text.?(gobject.ext.as(EntryBuffer, p_buffer), p_position, p_n_chars);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_position: c_uint, p_n_chars: c_uint) callconv(.c) void) void {
                gobject.ext.as(EntryBuffer.Class, p_class).f_deleted_text = @ptrCast(p_implementation);
            }
        };

        /// Retrieves the length in characters of the buffer.
        pub const get_length = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_uint {
                return gobject.ext.as(EntryBuffer.Class, p_class).f_get_length.?(gobject.ext.as(EntryBuffer, p_buffer));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_uint) void {
                gobject.ext.as(EntryBuffer.Class, p_class).f_get_length = @ptrCast(p_implementation);
            }
        };

        pub const get_text = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_n_bytes: *usize) [*:0]const u8 {
                return gobject.ext.as(EntryBuffer.Class, p_class).f_get_text.?(gobject.ext.as(EntryBuffer, p_buffer), p_n_bytes);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_n_bytes: *usize) callconv(.c) [*:0]const u8) void {
                gobject.ext.as(EntryBuffer.Class, p_class).f_get_text = @ptrCast(p_implementation);
            }
        };

        /// Inserts `n_chars` characters of `chars` into the contents of the
        /// buffer, at position `position`.
        ///
        /// If `n_chars` is negative, then characters from chars will be inserted
        /// until a null-terminator is found. If `position` or `n_chars` are out of
        /// bounds, or the maximum buffer text length is exceeded, then they are
        /// coerced to sane values.
        ///
        /// Note that the position and length are in characters, not in bytes.
        pub const insert_text = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_position: c_uint, p_chars: [*:0]const u8, p_n_chars: c_uint) c_uint {
                return gobject.ext.as(EntryBuffer.Class, p_class).f_insert_text.?(gobject.ext.as(EntryBuffer, p_buffer), p_position, p_chars, p_n_chars);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_position: c_uint, p_chars: [*:0]const u8, p_n_chars: c_uint) callconv(.c) c_uint) void {
                gobject.ext.as(EntryBuffer.Class, p_class).f_insert_text = @ptrCast(p_implementation);
            }
        };

        pub const inserted_text = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_position: c_uint, p_chars: [*:0]const u8, p_n_chars: c_uint) void {
                return gobject.ext.as(EntryBuffer.Class, p_class).f_inserted_text.?(gobject.ext.as(EntryBuffer, p_buffer), p_position, p_chars, p_n_chars);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_position: c_uint, p_chars: [*:0]const u8, p_n_chars: c_uint) callconv(.c) void) void {
                gobject.ext.as(EntryBuffer.Class, p_class).f_inserted_text = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The length (in characters) of the text in buffer.
        pub const length = struct {
            pub const name = "length";

            pub const Type = c_uint;
        };

        /// The maximum length (in characters) of the text in the buffer.
        pub const max_length = struct {
            pub const name = "max-length";

            pub const Type = c_int;
        };

        /// The contents of the buffer.
        pub const text = struct {
            pub const name = "text";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {
        /// This signal is emitted after text is deleted from the buffer.
        pub const deleted_text = struct {
            pub const name = "deleted-text";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_position: c_uint, p_n_chars: c_uint, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EntryBuffer, p_instance))),
                    gobject.signalLookup("deleted-text", EntryBuffer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted after text is inserted into the buffer.
        pub const inserted_text = struct {
            pub const name = "inserted-text";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_position: c_uint, p_chars: [*:0]u8, p_n_chars: c_uint, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EntryBuffer, p_instance))),
                    gobject.signalLookup("inserted-text", EntryBuffer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Create a new GtkEntryBuffer object.
    ///
    /// Optionally, specify initial text to set in the buffer.
    extern fn gtk_entry_buffer_new(p_initial_chars: ?[*:0]const u8, p_n_initial_chars: c_int) *gtk.EntryBuffer;
    pub const new = gtk_entry_buffer_new;

    /// Deletes a sequence of characters from the buffer. `n_chars` characters are
    /// deleted starting at `position`. If `n_chars` is negative, then all characters
    /// until the end of the text are deleted.
    ///
    /// If `position` or `n_chars` are out of bounds, then they are coerced to sane
    /// values.
    ///
    /// Note that the positions are specified in characters, not bytes.
    extern fn gtk_entry_buffer_delete_text(p_buffer: *EntryBuffer, p_position: c_uint, p_n_chars: c_int) c_uint;
    pub const deleteText = gtk_entry_buffer_delete_text;

    /// Used when subclassing `gtk.EntryBuffer`
    extern fn gtk_entry_buffer_emit_deleted_text(p_buffer: *EntryBuffer, p_position: c_uint, p_n_chars: c_uint) void;
    pub const emitDeletedText = gtk_entry_buffer_emit_deleted_text;

    /// Used when subclassing `gtk.EntryBuffer`
    extern fn gtk_entry_buffer_emit_inserted_text(p_buffer: *EntryBuffer, p_position: c_uint, p_chars: [*:0]const u8, p_n_chars: c_uint) void;
    pub const emitInsertedText = gtk_entry_buffer_emit_inserted_text;

    /// Retrieves the length in bytes of the buffer.
    /// See `gtk.EntryBuffer.getLength`.
    extern fn gtk_entry_buffer_get_bytes(p_buffer: *EntryBuffer) usize;
    pub const getBytes = gtk_entry_buffer_get_bytes;

    /// Retrieves the length in characters of the buffer.
    extern fn gtk_entry_buffer_get_length(p_buffer: *EntryBuffer) c_uint;
    pub const getLength = gtk_entry_buffer_get_length;

    /// Retrieves the maximum allowed length of the text in
    /// `buffer`. See `gtk.EntryBuffer.setMaxLength`.
    extern fn gtk_entry_buffer_get_max_length(p_buffer: *EntryBuffer) c_int;
    pub const getMaxLength = gtk_entry_buffer_get_max_length;

    /// Retrieves the contents of the buffer.
    ///
    /// The memory pointer returned by this call will not change
    /// unless this object emits a signal, or is finalized.
    extern fn gtk_entry_buffer_get_text(p_buffer: *EntryBuffer) [*:0]const u8;
    pub const getText = gtk_entry_buffer_get_text;

    /// Inserts `n_chars` characters of `chars` into the contents of the
    /// buffer, at position `position`.
    ///
    /// If `n_chars` is negative, then characters from chars will be inserted
    /// until a null-terminator is found. If `position` or `n_chars` are out of
    /// bounds, or the maximum buffer text length is exceeded, then they are
    /// coerced to sane values.
    ///
    /// Note that the position and length are in characters, not in bytes.
    extern fn gtk_entry_buffer_insert_text(p_buffer: *EntryBuffer, p_position: c_uint, p_chars: [*:0]const u8, p_n_chars: c_int) c_uint;
    pub const insertText = gtk_entry_buffer_insert_text;

    /// Sets the maximum allowed length of the contents of the buffer. If
    /// the current contents are longer than the given length, then they
    /// will be truncated to fit.
    extern fn gtk_entry_buffer_set_max_length(p_buffer: *EntryBuffer, p_max_length: c_int) void;
    pub const setMaxLength = gtk_entry_buffer_set_max_length;

    /// Sets the text in the buffer.
    ///
    /// This is roughly equivalent to calling `gtk.EntryBuffer.deleteText`
    /// and `gtk.EntryBuffer.insertText`.
    ///
    /// Note that `n_chars` is in characters, not in bytes.
    extern fn gtk_entry_buffer_set_text(p_buffer: *EntryBuffer, p_chars: [*:0]const u8, p_n_chars: c_int) void;
    pub const setText = gtk_entry_buffer_set_text;

    extern fn gtk_entry_buffer_get_type() usize;
    pub const getGObjectType = gtk_entry_buffer_get_type;

    extern fn g_object_ref(p_self: *gtk.EntryBuffer) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.EntryBuffer) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *EntryBuffer, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.EntryCompletion` is an auxiliary object to be used in conjunction with
/// `gtk.Entry` to provide the completion functionality. It implements the
/// `gtk.CellLayout` interface, to allow the user to add extra cells to the
/// `gtk.TreeView` with completion matches.
///
/// “Completion functionality” means that when the user modifies the text
/// in the entry, `gtk.EntryCompletion` checks which rows in the model match
/// the current content of the entry, and displays a list of matches.
/// By default, the matching is done by comparing the entry text
/// case-insensitively against the text column of the model (see
/// `gtk.EntryCompletion.setTextColumn`), but this can be overridden
/// with a custom match function (see `gtk.EntryCompletion.setMatchFunc`).
///
/// When the user selects a completion, the content of the entry is
/// updated. By default, the content of the entry is replaced by the
/// text column of the model, but this can be overridden by connecting
/// to the `gtk.EntryCompletion.signals.match`-selected signal and updating the
/// entry in the signal handler. Note that you should return `TRUE` from
/// the signal handler to suppress the default behaviour.
///
/// To add completion functionality to an entry, use `gtk.Entry.setCompletion`.
///
/// In addition to regular completion matches, which will be inserted into the
/// entry when they are selected, `gtk.EntryCompletion` also allows to display
/// “actions” in the popup window. Their appearance is similar to menuitems,
/// to differentiate them clearly from completion strings. When an action is
/// selected, the `gtk.EntryCompletion.signals.action`-activated signal is emitted.
///
/// GtkEntryCompletion uses a `gtk.TreeModelFilter` model to represent the
/// subset of the entire model that is currently matching. While the
/// GtkEntryCompletion signals `gtk.EntryCompletion.signals.match`-selected and
/// `gtk.EntryCompletion.signals.cursor`-on-match take the original model and an
/// iter pointing to that model as arguments, other callbacks and signals
/// (such as `GtkCellLayoutDataFuncs` or `gtk.CellArea.signals.apply`-attributes)
/// will generally take the filter model as argument. As long as you are
/// only calling `gtk.TreeModel.get`, this will make no difference to
/// you. If for some reason, you need the original model, use
/// `gtk.TreeModelFilter.getModel`. Don’t forget to use
/// `gtk.TreeModelFilter.convertIterToChildIter` to obtain a
/// matching iter.
pub const EntryCompletion = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gtk.Buildable, gtk.CellLayout };
    pub const Class = gtk.EntryCompletionClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.EntryCompletionPrivate,

    pub const virtual_methods = struct {
        pub const action_activated = struct {
            pub fn call(p_class: anytype, p_completion: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_index_: c_int) void {
                return gobject.ext.as(EntryCompletion.Class, p_class).f_action_activated.?(gobject.ext.as(EntryCompletion, p_completion), p_index_);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_completion: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_index_: c_int) callconv(.c) void) void {
                gobject.ext.as(EntryCompletion.Class, p_class).f_action_activated = @ptrCast(p_implementation);
            }
        };

        pub const cursor_on_match = struct {
            pub fn call(p_class: anytype, p_completion: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_model: *gtk.TreeModel, p_iter: *gtk.TreeIter) c_int {
                return gobject.ext.as(EntryCompletion.Class, p_class).f_cursor_on_match.?(gobject.ext.as(EntryCompletion, p_completion), p_model, p_iter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_completion: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_model: *gtk.TreeModel, p_iter: *gtk.TreeIter) callconv(.c) c_int) void {
                gobject.ext.as(EntryCompletion.Class, p_class).f_cursor_on_match = @ptrCast(p_implementation);
            }
        };

        pub const insert_prefix = struct {
            pub fn call(p_class: anytype, p_completion: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_prefix: [*:0]const u8) c_int {
                return gobject.ext.as(EntryCompletion.Class, p_class).f_insert_prefix.?(gobject.ext.as(EntryCompletion, p_completion), p_prefix);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_completion: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_prefix: [*:0]const u8) callconv(.c) c_int) void {
                gobject.ext.as(EntryCompletion.Class, p_class).f_insert_prefix = @ptrCast(p_implementation);
            }
        };

        pub const match_selected = struct {
            pub fn call(p_class: anytype, p_completion: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_model: *gtk.TreeModel, p_iter: *gtk.TreeIter) c_int {
                return gobject.ext.as(EntryCompletion.Class, p_class).f_match_selected.?(gobject.ext.as(EntryCompletion, p_completion), p_model, p_iter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_completion: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_model: *gtk.TreeModel, p_iter: *gtk.TreeIter) callconv(.c) c_int) void {
                gobject.ext.as(EntryCompletion.Class, p_class).f_match_selected = @ptrCast(p_implementation);
            }
        };

        pub const no_matches = struct {
            pub fn call(p_class: anytype, p_completion: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(EntryCompletion.Class, p_class).f_no_matches.?(gobject.ext.as(EntryCompletion, p_completion));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_completion: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(EntryCompletion.Class, p_class).f_no_matches = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The `gtk.CellArea` used to layout cell renderers in the treeview column.
        ///
        /// If no area is specified when creating the entry completion with
        /// `gtk.EntryCompletion.newWithArea` a horizontally oriented
        /// `gtk.CellAreaBox` will be used.
        pub const cell_area = struct {
            pub const name = "cell-area";

            pub const Type = ?*gtk.CellArea;
        };

        /// Determines whether the common prefix of the possible completions
        /// should be inserted automatically in the entry. Note that this
        /// requires text-column to be set, even if you are using a custom
        /// match function.
        pub const inline_completion = struct {
            pub const name = "inline-completion";

            pub const Type = c_int;
        };

        /// Determines whether the possible completions on the popup
        /// will appear in the entry as you navigate through them.
        pub const inline_selection = struct {
            pub const name = "inline-selection";

            pub const Type = c_int;
        };

        pub const minimum_key_length = struct {
            pub const name = "minimum-key-length";

            pub const Type = c_int;
        };

        pub const model = struct {
            pub const name = "model";

            pub const Type = ?*gtk.TreeModel;
        };

        /// Determines whether the possible completions should be
        /// shown in a popup window.
        pub const popup_completion = struct {
            pub const name = "popup-completion";

            pub const Type = c_int;
        };

        /// Determines whether the completions popup window will be
        /// resized to the width of the entry.
        pub const popup_set_width = struct {
            pub const name = "popup-set-width";

            pub const Type = c_int;
        };

        /// Determines whether the completions popup window will shown
        /// for a single possible completion. You probably want to set
        /// this to `FALSE` if you are using
        /// [inline completion][GtkEntryCompletion--inline-completion].
        pub const popup_single_match = struct {
            pub const name = "popup-single-match";

            pub const Type = c_int;
        };

        /// The column of the model containing the strings.
        /// Note that the strings must be UTF-8.
        pub const text_column = struct {
            pub const name = "text-column";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Gets emitted when an action is activated.
        pub const action_activated = struct {
            pub const name = "action-activated";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_index: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EntryCompletion, p_instance))),
                    gobject.signalLookup("action-activated", EntryCompletion.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Gets emitted when a match from the cursor is on a match
        /// of the list. The default behaviour is to replace the contents
        /// of the entry with the contents of the text column in the row
        /// pointed to by `iter`.
        ///
        /// Note that `model` is the model that was passed to
        /// `gtk.EntryCompletion.setModel`.
        pub const cursor_on_match = struct {
            pub const name = "cursor-on-match";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EntryCompletion, p_instance))),
                    gobject.signalLookup("cursor-on-match", EntryCompletion.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Gets emitted when the inline autocompletion is triggered.
        /// The default behaviour is to make the entry display the
        /// whole prefix and select the newly inserted part.
        ///
        /// Applications may connect to this signal in order to insert only a
        /// smaller part of the `prefix` into the entry - e.g. the entry used in
        /// the `gtk.FileChooser` inserts only the part of the prefix up to the
        /// next '/'.
        pub const insert_prefix = struct {
            pub const name = "insert-prefix";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_prefix: [*:0]u8, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EntryCompletion, p_instance))),
                    gobject.signalLookup("insert-prefix", EntryCompletion.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Gets emitted when a match from the list is selected.
        /// The default behaviour is to replace the contents of the
        /// entry with the contents of the text column in the row
        /// pointed to by `iter`.
        ///
        /// Note that `model` is the model that was passed to
        /// `gtk.EntryCompletion.setModel`.
        pub const match_selected = struct {
            pub const name = "match-selected";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EntryCompletion, p_instance))),
                    gobject.signalLookup("match-selected", EntryCompletion.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Gets emitted when the filter model has zero
        /// number of rows in completion_complete method.
        /// (In other words when GtkEntryCompletion is out of
        ///  suggestions)
        pub const no_matches = struct {
            pub const name = "no-matches";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EntryCompletion, p_instance))),
                    gobject.signalLookup("no-matches", EntryCompletion.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.EntryCompletion` object.
    extern fn gtk_entry_completion_new() *gtk.EntryCompletion;
    pub const new = gtk_entry_completion_new;

    /// Creates a new `gtk.EntryCompletion` object using the
    /// specified `area` to layout cells in the underlying
    /// `gtk.TreeViewColumn` for the drop-down menu.
    extern fn gtk_entry_completion_new_with_area(p_area: *gtk.CellArea) *gtk.EntryCompletion;
    pub const newWithArea = gtk_entry_completion_new_with_area;

    /// Requests a completion operation, or in other words a refiltering of the
    /// current list with completions, using the current key. The completion list
    /// view will be updated accordingly.
    extern fn gtk_entry_completion_complete(p_completion: *EntryCompletion) void;
    pub const complete = gtk_entry_completion_complete;

    /// Computes the common prefix that is shared by all rows in `completion`
    /// that start with `key`. If no row matches `key`, `NULL` will be returned.
    /// Note that a text column must have been set for this function to work,
    /// see `gtk.EntryCompletion.setTextColumn` for details.
    extern fn gtk_entry_completion_compute_prefix(p_completion: *EntryCompletion, p_key: [*:0]const u8) ?[*:0]u8;
    pub const computePrefix = gtk_entry_completion_compute_prefix;

    /// Deletes the action at `index_` from `completion`’s action list.
    ///
    /// Note that `index_` is a relative position and the position of an
    /// action may have changed since it was inserted.
    extern fn gtk_entry_completion_delete_action(p_completion: *EntryCompletion, p_index_: c_int) void;
    pub const deleteAction = gtk_entry_completion_delete_action;

    /// Get the original text entered by the user that triggered
    /// the completion or `NULL` if there’s no completion ongoing.
    extern fn gtk_entry_completion_get_completion_prefix(p_completion: *EntryCompletion) [*:0]const u8;
    pub const getCompletionPrefix = gtk_entry_completion_get_completion_prefix;

    /// Gets the entry `completion` has been attached to.
    extern fn gtk_entry_completion_get_entry(p_completion: *EntryCompletion) *gtk.Widget;
    pub const getEntry = gtk_entry_completion_get_entry;

    /// Returns whether the common prefix of the possible completions should
    /// be automatically inserted in the entry.
    extern fn gtk_entry_completion_get_inline_completion(p_completion: *EntryCompletion) c_int;
    pub const getInlineCompletion = gtk_entry_completion_get_inline_completion;

    /// Returns `TRUE` if inline-selection mode is turned on.
    extern fn gtk_entry_completion_get_inline_selection(p_completion: *EntryCompletion) c_int;
    pub const getInlineSelection = gtk_entry_completion_get_inline_selection;

    /// Returns the minimum key length as set for `completion`.
    extern fn gtk_entry_completion_get_minimum_key_length(p_completion: *EntryCompletion) c_int;
    pub const getMinimumKeyLength = gtk_entry_completion_get_minimum_key_length;

    /// Returns the model the `gtk.EntryCompletion` is using as data source.
    /// Returns `NULL` if the model is unset.
    extern fn gtk_entry_completion_get_model(p_completion: *EntryCompletion) ?*gtk.TreeModel;
    pub const getModel = gtk_entry_completion_get_model;

    /// Returns whether the completions should be presented in a popup window.
    extern fn gtk_entry_completion_get_popup_completion(p_completion: *EntryCompletion) c_int;
    pub const getPopupCompletion = gtk_entry_completion_get_popup_completion;

    /// Returns whether the  completion popup window will be resized to the
    /// width of the entry.
    extern fn gtk_entry_completion_get_popup_set_width(p_completion: *EntryCompletion) c_int;
    pub const getPopupSetWidth = gtk_entry_completion_get_popup_set_width;

    /// Returns whether the completion popup window will appear even if there is
    /// only a single match.
    extern fn gtk_entry_completion_get_popup_single_match(p_completion: *EntryCompletion) c_int;
    pub const getPopupSingleMatch = gtk_entry_completion_get_popup_single_match;

    /// Returns the column in the model of `completion` to get strings from.
    extern fn gtk_entry_completion_get_text_column(p_completion: *EntryCompletion) c_int;
    pub const getTextColumn = gtk_entry_completion_get_text_column;

    /// Inserts an action in `completion`’s action item list at position `index_`
    /// with markup `markup`.
    extern fn gtk_entry_completion_insert_action_markup(p_completion: *EntryCompletion, p_index_: c_int, p_markup: [*:0]const u8) void;
    pub const insertActionMarkup = gtk_entry_completion_insert_action_markup;

    /// Inserts an action in `completion`’s action item list at position `index_`
    /// with text `text`. If you want the action item to have markup, use
    /// `gtk.EntryCompletion.insertActionMarkup`.
    ///
    /// Note that `index_` is a relative position in the list of actions and
    /// the position of an action can change when deleting a different action.
    extern fn gtk_entry_completion_insert_action_text(p_completion: *EntryCompletion, p_index_: c_int, p_text: [*:0]const u8) void;
    pub const insertActionText = gtk_entry_completion_insert_action_text;

    /// Requests a prefix insertion.
    extern fn gtk_entry_completion_insert_prefix(p_completion: *EntryCompletion) void;
    pub const insertPrefix = gtk_entry_completion_insert_prefix;

    /// Sets whether the common prefix of the possible completions should
    /// be automatically inserted in the entry.
    extern fn gtk_entry_completion_set_inline_completion(p_completion: *EntryCompletion, p_inline_completion: c_int) void;
    pub const setInlineCompletion = gtk_entry_completion_set_inline_completion;

    /// Sets whether it is possible to cycle through the possible completions
    /// inside the entry.
    extern fn gtk_entry_completion_set_inline_selection(p_completion: *EntryCompletion, p_inline_selection: c_int) void;
    pub const setInlineSelection = gtk_entry_completion_set_inline_selection;

    /// Sets the match function for `completion` to be `func`. The match function
    /// is used to determine if a row should or should not be in the completion
    /// list.
    extern fn gtk_entry_completion_set_match_func(p_completion: *EntryCompletion, p_func: gtk.EntryCompletionMatchFunc, p_func_data: ?*anyopaque, p_func_notify: ?glib.DestroyNotify) void;
    pub const setMatchFunc = gtk_entry_completion_set_match_func;

    /// Requires the length of the search key for `completion` to be at least
    /// `length`. This is useful for long lists, where completing using a small
    /// key takes a lot of time and will come up with meaningless results anyway
    /// (ie, a too large dataset).
    extern fn gtk_entry_completion_set_minimum_key_length(p_completion: *EntryCompletion, p_length: c_int) void;
    pub const setMinimumKeyLength = gtk_entry_completion_set_minimum_key_length;

    /// Sets the model for a `gtk.EntryCompletion`. If `completion` already has
    /// a model set, it will remove it before setting the new model.
    /// If model is `NULL`, then it will unset the model.
    extern fn gtk_entry_completion_set_model(p_completion: *EntryCompletion, p_model: ?*gtk.TreeModel) void;
    pub const setModel = gtk_entry_completion_set_model;

    /// Sets whether the completions should be presented in a popup window.
    extern fn gtk_entry_completion_set_popup_completion(p_completion: *EntryCompletion, p_popup_completion: c_int) void;
    pub const setPopupCompletion = gtk_entry_completion_set_popup_completion;

    /// Sets whether the completion popup window will be resized to be the same
    /// width as the entry.
    extern fn gtk_entry_completion_set_popup_set_width(p_completion: *EntryCompletion, p_popup_set_width: c_int) void;
    pub const setPopupSetWidth = gtk_entry_completion_set_popup_set_width;

    /// Sets whether the completion popup window will appear even if there is
    /// only a single match. You may want to set this to `FALSE` if you
    /// are using [inline completion][GtkEntryCompletion--inline-completion].
    extern fn gtk_entry_completion_set_popup_single_match(p_completion: *EntryCompletion, p_popup_single_match: c_int) void;
    pub const setPopupSingleMatch = gtk_entry_completion_set_popup_single_match;

    /// Convenience function for setting up the most used case of this code: a
    /// completion list with just strings. This function will set up `completion`
    /// to have a list displaying all (and just) strings in the completion list,
    /// and to get those strings from `column` in the model of `completion`.
    ///
    /// This functions creates and adds a `gtk.CellRendererText` for the selected
    /// column. If you need to set the text column, but don't want the cell
    /// renderer, use `gobject.Object.set` to set the `gtk.EntryCompletion.properties.text`-column
    /// property directly.
    extern fn gtk_entry_completion_set_text_column(p_completion: *EntryCompletion, p_column: c_int) void;
    pub const setTextColumn = gtk_entry_completion_set_text_column;

    extern fn gtk_entry_completion_get_type() usize;
    pub const getGObjectType = gtk_entry_completion_get_type;

    extern fn g_object_ref(p_self: *gtk.EntryCompletion) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.EntryCompletion) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *EntryCompletion, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EntryIconAccessible = opaque {
    pub const Parent = atk.Object;
    pub const Implements = [_]type{ atk.Action, atk.Component };
    pub const Class = opaque {
        pub const Instance = EntryIconAccessible;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_entry_icon_accessible_get_type() usize;
    pub const getGObjectType = gtk_entry_icon_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.EntryIconAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.EntryIconAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *EntryIconAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.EventBox` widget is a subclass of `gtk.Bin` which also has its
/// own window. It is useful since it allows you to catch events for widgets
/// which do not have their own window.
pub const EventBox = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.EventBoxClass;
    f_bin: gtk.Bin,
    f_priv: ?*gtk.EventBoxPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const above_child = struct {
            pub const name = "above-child";

            pub const Type = c_int;
        };

        pub const visible_window = struct {
            pub const name = "visible-window";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.EventBox`.
    extern fn gtk_event_box_new() *gtk.EventBox;
    pub const new = gtk_event_box_new;

    /// Returns whether the event box window is above or below the
    /// windows of its child. See `gtk.EventBox.setAboveChild`
    /// for details.
    extern fn gtk_event_box_get_above_child(p_event_box: *EventBox) c_int;
    pub const getAboveChild = gtk_event_box_get_above_child;

    /// Returns whether the event box has a visible window.
    /// See `gtk.EventBox.setVisibleWindow` for details.
    extern fn gtk_event_box_get_visible_window(p_event_box: *EventBox) c_int;
    pub const getVisibleWindow = gtk_event_box_get_visible_window;

    /// Set whether the event box window is positioned above the windows
    /// of its child, as opposed to below it. If the window is above, all
    /// events inside the event box will go to the event box. If the window
    /// is below, events in windows of child widgets will first got to that
    /// widget, and then to its parents.
    ///
    /// The default is to keep the window below the child.
    extern fn gtk_event_box_set_above_child(p_event_box: *EventBox, p_above_child: c_int) void;
    pub const setAboveChild = gtk_event_box_set_above_child;

    /// Set whether the event box uses a visible or invisible child
    /// window. The default is to use visible windows.
    ///
    /// In an invisible window event box, the window that the
    /// event box creates is a `GDK_INPUT_ONLY` window, which
    /// means that it is invisible and only serves to receive
    /// events.
    ///
    /// A visible window event box creates a visible (`GDK_INPUT_OUTPUT`)
    /// window that acts as the parent window for all the widgets
    /// contained in the event box.
    ///
    /// You should generally make your event box invisible if
    /// you just want to trap events. Creating a visible window
    /// may cause artifacts that are visible to the user, especially
    /// if the user is using a theme with gradients or pixmaps.
    ///
    /// The main reason to create a non input-only event box is if
    /// you want to set the background to a different color or
    /// draw on it.
    ///
    /// There is one unexpected issue for an invisible event box that has its
    /// window below the child. (See `gtk.EventBox.setAboveChild`.)
    /// Since the input-only window is not an ancestor window of any windows
    /// that descendent widgets of the event box create, events on these
    /// windows aren’t propagated up by the windowing system, but only by GTK+.
    /// The practical effect of this is if an event isn’t in the event
    /// mask for the descendant window (see `gtk.Widget.addEvents`),
    /// it won’t be received by the event box.
    ///
    /// This problem doesn’t occur for visible event boxes, because in
    /// that case, the event box window is actually the ancestor of the
    /// descendant windows, not just at the same place on the screen.
    extern fn gtk_event_box_set_visible_window(p_event_box: *EventBox, p_visible_window: c_int) void;
    pub const setVisibleWindow = gtk_event_box_set_visible_window;

    extern fn gtk_event_box_get_type() usize;
    pub const getGObjectType = gtk_event_box_get_type;

    extern fn g_object_ref(p_self: *gtk.EventBox) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.EventBox) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *EventBox, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.EventController` is a base, low-level implementation for event
/// controllers. Those react to a series of `GdkEvents`, and possibly trigger
/// actions as a consequence of those.
pub const EventController = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.EventControllerClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The propagation phase at which this controller will handle events.
        pub const propagation_phase = struct {
            pub const name = "propagation-phase";

            pub const Type = gtk.PropagationPhase;
        };

        /// The widget receiving the `GdkEvents` that the controller will handle.
        pub const widget = struct {
            pub const name = "widget";

            pub const Type = ?*gtk.Widget;
        };
    };

    pub const signals = struct {};

    /// Gets the propagation phase at which `controller` handles events.
    extern fn gtk_event_controller_get_propagation_phase(p_controller: *EventController) gtk.PropagationPhase;
    pub const getPropagationPhase = gtk_event_controller_get_propagation_phase;

    /// Returns the `gtk.Widget` this controller relates to.
    extern fn gtk_event_controller_get_widget(p_controller: *EventController) *gtk.Widget;
    pub const getWidget = gtk_event_controller_get_widget;

    /// Feeds an events into `controller`, so it can be interpreted
    /// and the controller actions triggered.
    extern fn gtk_event_controller_handle_event(p_controller: *EventController, p_event: *const gdk.Event) c_int;
    pub const handleEvent = gtk_event_controller_handle_event;

    /// Resets the `controller` to a clean state. Every interaction
    /// the controller did through `gtk.EventController.signals.handle`-event
    /// will be dropped at this point.
    extern fn gtk_event_controller_reset(p_controller: *EventController) void;
    pub const reset = gtk_event_controller_reset;

    /// Sets the propagation phase at which a controller handles events.
    ///
    /// If `phase` is `GTK_PHASE_NONE`, no automatic event handling will be
    /// performed, but other additional gesture maintenance will. In that phase,
    /// the events can be managed by calling `gtk.EventController.handleEvent`.
    extern fn gtk_event_controller_set_propagation_phase(p_controller: *EventController, p_phase: gtk.PropagationPhase) void;
    pub const setPropagationPhase = gtk_event_controller_set_propagation_phase;

    extern fn gtk_event_controller_get_type() usize;
    pub const getGObjectType = gtk_event_controller_get_type;

    extern fn g_object_ref(p_self: *gtk.EventController) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.EventController) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *EventController, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.EventControllerKey` is an event controller meant for situations
/// where you need access to key events.
///
/// This object was added in 3.24.
pub const EventControllerKey = opaque {
    pub const Parent = gtk.EventController;
    pub const Implements = [_]type{};
    pub const Class = gtk.EventControllerKeyClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {
        pub const focus_in = struct {
            pub const name = "focus-in";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EventControllerKey, p_instance))),
                    gobject.signalLookup("focus-in", EventControllerKey.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const focus_out = struct {
            pub const name = "focus-out";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EventControllerKey, p_instance))),
                    gobject.signalLookup("focus-out", EventControllerKey.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const im_update = struct {
            pub const name = "im-update";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EventControllerKey, p_instance))),
                    gobject.signalLookup("im-update", EventControllerKey.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted whenever a key is pressed.
        pub const key_pressed = struct {
            pub const name = "key-pressed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_keyval: c_uint, p_keycode: c_uint, p_state: gdk.ModifierType, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EventControllerKey, p_instance))),
                    gobject.signalLookup("key-pressed", EventControllerKey.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted whenever a key is released.
        pub const key_released = struct {
            pub const name = "key-released";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_keyval: c_uint, p_keycode: c_uint, p_state: gdk.ModifierType, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EventControllerKey, p_instance))),
                    gobject.signalLookup("key-released", EventControllerKey.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const modifiers = struct {
            pub const name = "modifiers";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: gdk.ModifierType, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EventControllerKey, p_instance))),
                    gobject.signalLookup("modifiers", EventControllerKey.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    extern fn gtk_event_controller_key_new(p_widget: *gtk.Widget) *gtk.EventControllerKey;
    pub const new = gtk_event_controller_key_new;

    extern fn gtk_event_controller_key_forward(p_controller: *EventControllerKey, p_widget: *gtk.Widget) c_int;
    pub const forward = gtk_event_controller_key_forward;

    extern fn gtk_event_controller_key_get_group(p_controller: *EventControllerKey) c_uint;
    pub const getGroup = gtk_event_controller_key_get_group;

    /// Gets the IM context of a key controller.
    extern fn gtk_event_controller_key_get_im_context(p_controller: *EventControllerKey) *gtk.IMContext;
    pub const getImContext = gtk_event_controller_key_get_im_context;

    extern fn gtk_event_controller_key_set_im_context(p_controller: *EventControllerKey, p_im_context: *gtk.IMContext) void;
    pub const setImContext = gtk_event_controller_key_set_im_context;

    extern fn gtk_event_controller_key_get_type() usize;
    pub const getGObjectType = gtk_event_controller_key_get_type;

    extern fn g_object_ref(p_self: *gtk.EventControllerKey) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.EventControllerKey) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *EventControllerKey, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.EventControllerMotion` is an event controller meant for situations
/// where you need to track the position of the pointer.
///
/// This object was added in 3.24.
pub const EventControllerMotion = opaque {
    pub const Parent = gtk.EventController;
    pub const Implements = [_]type{};
    pub const Class = gtk.EventControllerMotionClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {
        /// Signals that the pointer has entered the widget.
        pub const enter = struct {
            pub const name = "enter";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_x: f64, p_y: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EventControllerMotion, p_instance))),
                    gobject.signalLookup("enter", EventControllerMotion.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Signals that pointer has left the widget.
        pub const leave = struct {
            pub const name = "leave";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EventControllerMotion, p_instance))),
                    gobject.signalLookup("leave", EventControllerMotion.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the pointer moves inside the widget.
        pub const motion = struct {
            pub const name = "motion";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_x: f64, p_y: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EventControllerMotion, p_instance))),
                    gobject.signalLookup("motion", EventControllerMotion.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new event controller that will handle motion events
    /// for the given `widget`.
    extern fn gtk_event_controller_motion_new(p_widget: *gtk.Widget) *gtk.EventControllerMotion;
    pub const new = gtk_event_controller_motion_new;

    extern fn gtk_event_controller_motion_get_type() usize;
    pub const getGObjectType = gtk_event_controller_motion_get_type;

    extern fn g_object_ref(p_self: *gtk.EventControllerMotion) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.EventControllerMotion) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *EventControllerMotion, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.EventControllerScroll` is an event controller meant to handle
/// scroll events from mice and touchpads. It is capable of handling
/// both discrete and continuous scroll events, abstracting them both
/// on the `gtk.EventControllerScroll.signals.scroll` signal (deltas in the
/// discrete case are multiples of 1).
///
/// In the case of continuous scroll events, `gtk.EventControllerScroll`
/// encloses all `gtk.EventControllerScroll.signals.scroll` events between two
/// `gtk.EventControllerScroll.signals.scroll`-begin and `gtk.EventControllerScroll.signals.scroll`-end
/// signals.
///
/// The behavior of the event controller can be modified by the
/// flags given at creation time, or modified at a later point through
/// `gtk.EventControllerScroll.setFlags` (e.g. because the scrolling
/// conditions of the widget changed).
///
/// The controller can be set up to emit motion for either/both vertical
/// and horizontal scroll events through `GTK_EVENT_CONTROLLER_SCROLL_VERTICAL`,
/// `GTK_EVENT_CONTROLLER_SCROLL_HORIZONTAL` and `GTK_EVENT_CONTROLLER_SCROLL_BOTH`.
/// If any axis is disabled, the respective `gtk.EventControllerScroll.signals.scroll`
/// delta will be 0. Vertical scroll events will be translated to horizontal
/// motion for the devices incapable of horizontal scrolling.
///
/// The event controller can also be forced to emit discrete events on all devices
/// through `GTK_EVENT_CONTROLLER_SCROLL_DISCRETE`. This can be used to implement
/// discrete actions triggered through scroll events (e.g. switching across
/// combobox options).
///
/// The `GTK_EVENT_CONTROLLER_SCROLL_KINETIC` flag toggles the emission of the
/// `gtk.EventControllerScroll.signals.decelerate` signal, emitted at the end of scrolling
/// with two X/Y velocity arguments that are consistent with the motion that
/// was received.
///
/// This object was added in 3.24.
pub const EventControllerScroll = opaque {
    pub const Parent = gtk.EventController;
    pub const Implements = [_]type{};
    pub const Class = gtk.EventControllerScrollClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The flags affecting event controller behavior
        pub const flags = struct {
            pub const name = "flags";

            pub const Type = gtk.EventControllerScrollFlags;
        };
    };

    pub const signals = struct {
        /// Emitted after scroll is finished if the `GTK_EVENT_CONTROLLER_SCROLL_KINETIC`
        /// flag is set. `vel_x` and `vel_y` express the initial velocity that was
        /// imprinted by the scroll events. `vel_x` and `vel_y` are expressed in
        /// pixels/ms.
        pub const decelerate = struct {
            pub const name = "decelerate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_vel_x: f64, p_vel_y: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EventControllerScroll, p_instance))),
                    gobject.signalLookup("decelerate", EventControllerScroll.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Signals that the widget should scroll by the
        /// amount specified by `dx` and `dy`.
        pub const scroll = struct {
            pub const name = "scroll";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_dx: f64, p_dy: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EventControllerScroll, p_instance))),
                    gobject.signalLookup("scroll", EventControllerScroll.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Signals that a new scrolling operation has begun. It will
        /// only be emitted on devices capable of it.
        pub const scroll_begin = struct {
            pub const name = "scroll-begin";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EventControllerScroll, p_instance))),
                    gobject.signalLookup("scroll-begin", EventControllerScroll.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Signals that a new scrolling operation has finished. It will
        /// only be emitted on devices capable of it.
        pub const scroll_end = struct {
            pub const name = "scroll-end";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(EventControllerScroll, p_instance))),
                    gobject.signalLookup("scroll-end", EventControllerScroll.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new event controller that will handle scroll events
    /// for the given `widget`.
    extern fn gtk_event_controller_scroll_new(p_widget: *gtk.Widget, p_flags: gtk.EventControllerScrollFlags) *gtk.EventControllerScroll;
    pub const new = gtk_event_controller_scroll_new;

    /// Gets the flags conditioning the scroll controller behavior.
    extern fn gtk_event_controller_scroll_get_flags(p_scroll: *EventControllerScroll) gtk.EventControllerScrollFlags;
    pub const getFlags = gtk_event_controller_scroll_get_flags;

    /// Sets the flags conditioning scroll controller behavior.
    extern fn gtk_event_controller_scroll_set_flags(p_scroll: *EventControllerScroll, p_flags: gtk.EventControllerScrollFlags) void;
    pub const setFlags = gtk_event_controller_scroll_set_flags;

    extern fn gtk_event_controller_scroll_get_type() usize;
    pub const getGObjectType = gtk_event_controller_scroll_get_type;

    extern fn g_object_ref(p_self: *gtk.EventControllerScroll) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.EventControllerScroll) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *EventControllerScroll, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.Expander` allows the user to hide or show its child by clicking
/// on an expander triangle similar to the triangles used in a `gtk.TreeView`.
///
/// Normally you use an expander as you would use any other descendant
/// of `gtk.Bin`; you create the child widget and use `gtk.Container.add`
/// to add it to the expander. When the expander is toggled, it will take
/// care of showing and hiding the child automatically.
///
/// # Special Usage
///
/// There are situations in which you may prefer to show and hide the
/// expanded widget yourself, such as when you want to actually create
/// the widget at expansion time. In this case, create a `gtk.Expander`
/// but do not add a child to it. The expander widget has an
/// `gtk.Expander.properties.expanded` property which can be used to monitor
/// its expansion state. You should watch this property with a signal
/// connection as follows:
///
/// ```
/// static void
/// expander_callback (GObject    *object,
///                    GParamSpec *param_spec,
///                    gpointer    user_data)
/// {
///   GtkExpander *expander;
///
///   expander = GTK_EXPANDER (object);
///
///   if (gtk_expander_get_expanded (expander))
///     {
///       // Show or create widgets
///     }
///   else
///     {
///       // Hide or destroy widgets
///     }
/// }
///
/// static void
/// create_expander (void)
/// {
///   GtkWidget *expander = gtk_expander_new_with_mnemonic ("_More Options");
///   g_signal_connect (expander, "notify::expanded",
///                     G_CALLBACK (expander_callback), NULL);
///
///   // ...
/// }
/// ```
///
/// # GtkExpander as GtkBuildable
///
/// The GtkExpander implementation of the GtkBuildable interface supports
/// placing a child in the label position by specifying “label” as the
/// “type” attribute of a `<child>` element. A normal content child can be
/// specified without specifying a `<child>` type attribute.
///
/// An example of a UI definition fragment with GtkExpander:
///
/// ```
/// <object class="GtkExpander">
///   <child type="label">
///     <object class="GtkLabel" id="expander-label"/>
///   </child>
///   <child>
///     <object class="GtkEntry" id="expander-content"/>
///   </child>
/// </object>
/// ```
///
/// # CSS nodes
///
/// ```
/// expander
/// ├── title
/// │   ├── arrow
/// │   ╰── <label widget>
/// ╰── <child>
/// ```
///
/// GtkExpander has three CSS nodes, the main node with the name expander,
/// a subnode with name title and node below it with name arrow. The arrow of an
/// expander that is showing its child gets the :checked pseudoclass added to it.
pub const Expander = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.ExpanderClass;
    f_bin: gtk.Bin,
    f_priv: ?*gtk.ExpanderPrivate,

    pub const virtual_methods = struct {
        /// Keybinding signal is emitted when the user hits the Enter key.
        pub const activate = struct {
            pub fn call(p_class: anytype, p_expander: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Expander.Class, p_class).f_activate.?(gobject.ext.as(Expander, p_expander));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_expander: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Expander.Class, p_class).f_activate = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const expanded = struct {
            pub const name = "expanded";

            pub const Type = c_int;
        };

        pub const label = struct {
            pub const name = "label";

            pub const Type = ?[*:0]u8;
        };

        /// Whether the label widget should fill all available horizontal space.
        ///
        /// Note that this property is ignored since 3.20.
        pub const label_fill = struct {
            pub const name = "label-fill";

            pub const Type = c_int;
        };

        pub const label_widget = struct {
            pub const name = "label-widget";

            pub const Type = ?*gtk.Widget;
        };

        /// When this property is `TRUE`, the expander will resize the toplevel
        /// widget containing the expander upon expanding and collapsing.
        pub const resize_toplevel = struct {
            pub const name = "resize-toplevel";

            pub const Type = c_int;
        };

        /// Space to put between the label and the child when the
        /// expander is expanded.
        pub const spacing = struct {
            pub const name = "spacing";

            pub const Type = c_int;
        };

        pub const use_markup = struct {
            pub const name = "use-markup";

            pub const Type = c_int;
        };

        pub const use_underline = struct {
            pub const name = "use-underline";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        pub const activate = struct {
            pub const name = "activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Expander, p_instance))),
                    gobject.signalLookup("activate", Expander.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new expander using `label` as the text of the label.
    extern fn gtk_expander_new(p_label: ?[*:0]const u8) *gtk.Expander;
    pub const new = gtk_expander_new;

    /// Creates a new expander using `label` as the text of the label.
    /// If characters in `label` are preceded by an underscore, they are underlined.
    /// If you need a literal underscore character in a label, use “__” (two
    /// underscores). The first underlined character represents a keyboard
    /// accelerator called a mnemonic.
    /// Pressing Alt and that key activates the button.
    extern fn gtk_expander_new_with_mnemonic(p_label: ?[*:0]const u8) *gtk.Expander;
    pub const newWithMnemonic = gtk_expander_new_with_mnemonic;

    /// Queries a `gtk.Expander` and returns its current state. Returns `TRUE`
    /// if the child widget is revealed.
    ///
    /// See `gtk.Expander.setExpanded`.
    extern fn gtk_expander_get_expanded(p_expander: *Expander) c_int;
    pub const getExpanded = gtk_expander_get_expanded;

    /// Fetches the text from a label widget including any embedded
    /// underlines indicating mnemonics and Pango markup, as set by
    /// `gtk.Expander.setLabel`. If the label text has not been set the
    /// return value will be `NULL`. This will be the case if you create an
    /// empty button with `gtk.Button.new` to use as a container.
    ///
    /// Note that this function behaved differently in versions prior to
    /// 2.14 and used to return the label text stripped of embedded
    /// underlines indicating mnemonics and Pango markup. This problem can
    /// be avoided by fetching the label text directly from the label
    /// widget.
    extern fn gtk_expander_get_label(p_expander: *Expander) ?[*:0]const u8;
    pub const getLabel = gtk_expander_get_label;

    /// Returns whether the label widget will fill all available
    /// horizontal space allocated to `expander`.
    extern fn gtk_expander_get_label_fill(p_expander: *Expander) c_int;
    pub const getLabelFill = gtk_expander_get_label_fill;

    /// Retrieves the label widget for the frame. See
    /// `gtk.Expander.setLabelWidget`.
    extern fn gtk_expander_get_label_widget(p_expander: *Expander) ?*gtk.Widget;
    pub const getLabelWidget = gtk_expander_get_label_widget;

    /// Returns whether the expander will resize the toplevel widget
    /// containing the expander upon resizing and collpasing.
    extern fn gtk_expander_get_resize_toplevel(p_expander: *Expander) c_int;
    pub const getResizeToplevel = gtk_expander_get_resize_toplevel;

    /// Gets the value set by `gtk.Expander.setSpacing`.
    extern fn gtk_expander_get_spacing(p_expander: *Expander) c_int;
    pub const getSpacing = gtk_expander_get_spacing;

    /// Returns whether the label’s text is interpreted as marked up with
    /// the [Pango text markup language][PangoMarkupFormat].
    /// See `gtk.Expander.setUseMarkup`.
    extern fn gtk_expander_get_use_markup(p_expander: *Expander) c_int;
    pub const getUseMarkup = gtk_expander_get_use_markup;

    /// Returns whether an embedded underline in the expander label
    /// indicates a mnemonic. See `gtk.Expander.setUseUnderline`.
    extern fn gtk_expander_get_use_underline(p_expander: *Expander) c_int;
    pub const getUseUnderline = gtk_expander_get_use_underline;

    /// Sets the state of the expander. Set to `TRUE`, if you want
    /// the child widget to be revealed, and `FALSE` if you want the
    /// child widget to be hidden.
    extern fn gtk_expander_set_expanded(p_expander: *Expander, p_expanded: c_int) void;
    pub const setExpanded = gtk_expander_set_expanded;

    /// Sets the text of the label of the expander to `label`.
    ///
    /// This will also clear any previously set labels.
    extern fn gtk_expander_set_label(p_expander: *Expander, p_label: ?[*:0]const u8) void;
    pub const setLabel = gtk_expander_set_label;

    /// Sets whether the label widget should fill all available
    /// horizontal space allocated to `expander`.
    ///
    /// Note that this function has no effect since 3.20.
    extern fn gtk_expander_set_label_fill(p_expander: *Expander, p_label_fill: c_int) void;
    pub const setLabelFill = gtk_expander_set_label_fill;

    /// Set the label widget for the expander. This is the widget
    /// that will appear embedded alongside the expander arrow.
    extern fn gtk_expander_set_label_widget(p_expander: *Expander, p_label_widget: ?*gtk.Widget) void;
    pub const setLabelWidget = gtk_expander_set_label_widget;

    /// Sets whether the expander will resize the toplevel widget
    /// containing the expander upon resizing and collpasing.
    extern fn gtk_expander_set_resize_toplevel(p_expander: *Expander, p_resize_toplevel: c_int) void;
    pub const setResizeToplevel = gtk_expander_set_resize_toplevel;

    /// Sets the spacing field of `expander`, which is the number of
    /// pixels to place between expander and the child.
    extern fn gtk_expander_set_spacing(p_expander: *Expander, p_spacing: c_int) void;
    pub const setSpacing = gtk_expander_set_spacing;

    /// Sets whether the text of the label contains markup in
    /// [Pango’s text markup language][PangoMarkupFormat].
    /// See `gtk.Label.setMarkup`.
    extern fn gtk_expander_set_use_markup(p_expander: *Expander, p_use_markup: c_int) void;
    pub const setUseMarkup = gtk_expander_set_use_markup;

    /// If true, an underline in the text of the expander label indicates
    /// the next character should be used for the mnemonic accelerator key.
    extern fn gtk_expander_set_use_underline(p_expander: *Expander, p_use_underline: c_int) void;
    pub const setUseUnderline = gtk_expander_set_use_underline;

    extern fn gtk_expander_get_type() usize;
    pub const getGObjectType = gtk_expander_get_type;

    extern fn g_object_ref(p_self: *gtk.Expander) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Expander) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Expander, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ExpanderAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component };
    pub const Class = gtk.ExpanderAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.ExpanderAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_expander_accessible_get_type() usize;
    pub const getGObjectType = gtk_expander_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ExpanderAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ExpanderAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ExpanderAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.FileChooserButton` is a widget that lets the user select a
/// file.  It implements the `gtk.FileChooser` interface.  Visually, it is a
/// file name with a button to bring up a `gtk.FileChooserDialog`.
/// The user can then use that dialog to change the file associated with
/// that button.  This widget does not support setting the
/// `gtk.FileChooser.properties.select`-multiple property to `TRUE`.
///
/// ## Create a button to let the user select a file in /etc
///
/// ```
/// {
///   GtkWidget *button;
///
///   button = gtk_file_chooser_button_new (_("Select a file"),
///                                         GTK_FILE_CHOOSER_ACTION_OPEN);
///   gtk_file_chooser_set_current_folder (GTK_FILE_CHOOSER (button),
///                                        "/etc");
/// }
/// ```
///
/// The `gtk.FileChooserButton` supports the `GtkFileChooserActions`
/// `GTK_FILE_CHOOSER_ACTION_OPEN` and `GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER`.
///
/// > The `gtk.FileChooserButton` will ellipsize the label, and will thus
/// > request little horizontal space.  To give the button more space,
/// > you should call `gtk.Widget.getPreferredSize`,
/// > `gtk.FileChooserButton.setWidthChars`, or pack the button in
/// > such a way that other interface elements give space to the
/// > widget.
///
/// # CSS nodes
///
/// GtkFileChooserButton has a CSS node with name “filechooserbutton”, containing
/// a subnode for the internal button with name “button” and style class “.file”.
pub const FileChooserButton = extern struct {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.FileChooser, gtk.Orientable };
    pub const Class = gtk.FileChooserButtonClass;
    f_parent: gtk.Box,
    f_priv: ?*gtk.FileChooserButtonPrivate,

    pub const virtual_methods = struct {
        /// Signal emitted when the user selects a file.
        pub const file_set = struct {
            pub fn call(p_class: anytype, p_fc: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(FileChooserButton.Class, p_class).f_file_set.?(gobject.ext.as(FileChooserButton, p_fc));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_fc: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(FileChooserButton.Class, p_class).f_file_set = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Instance of the `gtk.FileChooserDialog` associated with the button.
        pub const dialog = struct {
            pub const name = "dialog";

            pub const Type = ?*gtk.FileChooser;
        };

        /// Title to put on the `gtk.FileChooserDialog` associated with the button.
        pub const title = struct {
            pub const name = "title";

            pub const Type = ?[*:0]u8;
        };

        /// The width of the entry and label inside the button, in characters.
        pub const width_chars = struct {
            pub const name = "width-chars";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::file-set signal is emitted when the user selects a file.
        ///
        /// Note that this signal is only emitted when the user
        /// changes the file.
        pub const file_set = struct {
            pub const name = "file-set";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooserButton, p_instance))),
                    gobject.signalLookup("file-set", FileChooserButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new file-selecting button widget.
    extern fn gtk_file_chooser_button_new(p_title: [*:0]const u8, p_action: gtk.FileChooserAction) *gtk.FileChooserButton;
    pub const new = gtk_file_chooser_button_new;

    /// Creates a `gtk.FileChooserButton` widget which uses `dialog` as its
    /// file-picking window.
    ///
    /// Note that `dialog` must be a `gtk.Dialog` (or subclass) which
    /// implements the `gtk.FileChooser` interface and must not have
    /// `GTK_DIALOG_DESTROY_WITH_PARENT` set.
    ///
    /// Also note that the dialog needs to have its confirmative button
    /// added with response `GTK_RESPONSE_ACCEPT` or `GTK_RESPONSE_OK` in
    /// order for the button to take over the file selected in the dialog.
    extern fn gtk_file_chooser_button_new_with_dialog(p_dialog: *gtk.Dialog) *gtk.FileChooserButton;
    pub const newWithDialog = gtk_file_chooser_button_new_with_dialog;

    /// Returns whether the button grabs focus when it is clicked with the mouse.
    /// See `gtk.FileChooserButton.setFocusOnClick`.
    extern fn gtk_file_chooser_button_get_focus_on_click(p_button: *FileChooserButton) c_int;
    pub const getFocusOnClick = gtk_file_chooser_button_get_focus_on_click;

    /// Retrieves the title of the browse dialog used by `button`. The returned value
    /// should not be modified or freed.
    extern fn gtk_file_chooser_button_get_title(p_button: *FileChooserButton) [*:0]const u8;
    pub const getTitle = gtk_file_chooser_button_get_title;

    /// Retrieves the width in characters of the `button` widget’s entry and/or label.
    extern fn gtk_file_chooser_button_get_width_chars(p_button: *FileChooserButton) c_int;
    pub const getWidthChars = gtk_file_chooser_button_get_width_chars;

    /// Sets whether the button will grab focus when it is clicked with the mouse.
    /// Making mouse clicks not grab focus is useful in places like toolbars where
    /// you don’t want the keyboard focus removed from the main area of the
    /// application.
    extern fn gtk_file_chooser_button_set_focus_on_click(p_button: *FileChooserButton, p_focus_on_click: c_int) void;
    pub const setFocusOnClick = gtk_file_chooser_button_set_focus_on_click;

    /// Modifies the `title` of the browse dialog used by `button`.
    extern fn gtk_file_chooser_button_set_title(p_button: *FileChooserButton, p_title: [*:0]const u8) void;
    pub const setTitle = gtk_file_chooser_button_set_title;

    /// Sets the width (in characters) that `button` will use to `n_chars`.
    extern fn gtk_file_chooser_button_set_width_chars(p_button: *FileChooserButton, p_n_chars: c_int) void;
    pub const setWidthChars = gtk_file_chooser_button_set_width_chars;

    extern fn gtk_file_chooser_button_get_type() usize;
    pub const getGObjectType = gtk_file_chooser_button_get_type;

    extern fn g_object_ref(p_self: *gtk.FileChooserButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FileChooserButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FileChooserButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.FileChooserDialog` is a dialog box suitable for use with
/// “File/Open” or “File/Save as” commands.  This widget works by
/// putting a `gtk.FileChooserWidget` inside a `gtk.Dialog`.  It exposes
/// the `gtk.FileChooser` interface, so you can use all of the
/// `gtk.FileChooser` functions on the file chooser dialog as well as
/// those for `gtk.Dialog`.
///
/// Note that `gtk.FileChooserDialog` does not have any methods of its
/// own.  Instead, you should use the functions that work on a
/// `gtk.FileChooser`.
///
/// If you want to integrate well with the platform you should use the
/// `gtk.FileChooserNative` API, which will use a platform-specific
/// dialog if available and fall back to GtkFileChooserDialog
/// otherwise.
///
/// ## Typical usage
///
/// In the simplest of cases, you can the following code to use
/// `gtk.FileChooserDialog` to select a file for opening:
///
/// ```
/// GtkWidget *dialog;
/// GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
/// gint res;
///
/// dialog = gtk_file_chooser_dialog_new ("Open File",
///                                       parent_window,
///                                       action,
///                                       _("_Cancel"),
///                                       GTK_RESPONSE_CANCEL,
///                                       _("_Open"),
///                                       GTK_RESPONSE_ACCEPT,
///                                       NULL);
///
/// res = gtk_dialog_run (GTK_DIALOG (dialog));
/// if (res == GTK_RESPONSE_ACCEPT)
///   {
///     char *filename;
///     GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);
///     filename = gtk_file_chooser_get_filename (chooser);
///     open_file (filename);
///     g_free (filename);
///   }
///
/// gtk_widget_destroy (dialog);
/// ```
///
/// To use a dialog for saving, you can use this:
///
/// ```
/// GtkWidget *dialog;
/// GtkFileChooser *chooser;
/// GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
/// gint res;
///
/// dialog = gtk_file_chooser_dialog_new ("Save File",
///                                       parent_window,
///                                       action,
///                                       _("_Cancel"),
///                                       GTK_RESPONSE_CANCEL,
///                                       _("_Save"),
///                                       GTK_RESPONSE_ACCEPT,
///                                       NULL);
/// chooser = GTK_FILE_CHOOSER (dialog);
///
/// gtk_file_chooser_set_do_overwrite_confirmation (chooser, TRUE);
///
/// if (user_edited_a_new_document)
///   gtk_file_chooser_set_current_name (chooser,
///                                      _("Untitled document"));
/// else
///   gtk_file_chooser_set_filename (chooser,
///                                  existing_filename);
///
/// res = gtk_dialog_run (GTK_DIALOG (dialog));
/// if (res == GTK_RESPONSE_ACCEPT)
///   {
///     char *filename;
///
///     filename = gtk_file_chooser_get_filename (chooser);
///     save_to_file (filename);
///     g_free (filename);
///   }
///
/// gtk_widget_destroy (dialog);
/// ```
///
/// ## Setting up a file chooser dialog
///
/// There are various cases in which you may need to use a `gtk.FileChooserDialog`:
///
/// - To select a file for opening. Use `GTK_FILE_CHOOSER_ACTION_OPEN`.
///
/// - To save a file for the first time. Use `GTK_FILE_CHOOSER_ACTION_SAVE`,
///   and suggest a name such as “Untitled” with `gtk.FileChooser.setCurrentName`.
///
/// - To save a file under a different name. Use `GTK_FILE_CHOOSER_ACTION_SAVE`,
///   and set the existing filename with `gtk.FileChooser.setFilename`.
///
/// - To choose a folder instead of a file. Use `GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER`.
///
/// Note that old versions of the file chooser’s documentation suggested
/// using `gtk.FileChooser.setCurrentFolder` in various
/// situations, with the intention of letting the application
/// suggest a reasonable default folder.  This is no longer
/// considered to be a good policy, as now the file chooser is
/// able to make good suggestions on its own.  In general, you
/// should only cause the file chooser to show a specific folder
/// when it is appropriate to use `gtk.FileChooser.setFilename`,
/// i.e. when you are doing a Save As command and you already
/// have a file saved somewhere.
///
/// ## Response Codes
///
/// `gtk.FileChooserDialog` inherits from `gtk.Dialog`, so buttons that
/// go in its action area have response codes such as
/// `GTK_RESPONSE_ACCEPT` and `GTK_RESPONSE_CANCEL`.  For example, you
/// could call `gtk.FileChooserDialog.new` as follows:
///
/// ```
/// GtkWidget *dialog;
/// GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
///
/// dialog = gtk_file_chooser_dialog_new ("Open File",
///                                       parent_window,
///                                       action,
///                                       _("_Cancel"),
///                                       GTK_RESPONSE_CANCEL,
///                                       _("_Open"),
///                                       GTK_RESPONSE_ACCEPT,
///                                       NULL);
/// ```
///
/// This will create buttons for “Cancel” and “Open” that use stock
/// response identifiers from `gtk.ResponseType`.  For most dialog
/// boxes you can use your own custom response codes rather than the
/// ones in `gtk.ResponseType`, but `gtk.FileChooserDialog` assumes that
/// its “accept”-type action, e.g. an “Open” or “Save” button,
/// will have one of the following response codes:
///
/// - `GTK_RESPONSE_ACCEPT`
/// - `GTK_RESPONSE_OK`
/// - `GTK_RESPONSE_YES`
/// - `GTK_RESPONSE_APPLY`
///
/// This is because `gtk.FileChooserDialog` must intercept responses
/// and switch to folders if appropriate, rather than letting the
/// dialog terminate — the implementation uses these known
/// response codes to know which responses can be blocked if
/// appropriate.
///
/// To summarize, make sure you use a
/// [stock response code][gtkfilechooserdialog-responses]
/// when you use `gtk.FileChooserDialog` to ensure proper operation.
pub const FileChooserDialog = extern struct {
    pub const Parent = gtk.Dialog;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.FileChooser };
    pub const Class = gtk.FileChooserDialogClass;
    f_parent_instance: gtk.Dialog,
    f_priv: ?*gtk.FileChooserDialogPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.FileChooserDialog`.  This function is analogous to
    /// `gtk.Dialog.newWithButtons`.
    extern fn gtk_file_chooser_dialog_new(p_title: ?[*:0]const u8, p_parent: ?*gtk.Window, p_action: gtk.FileChooserAction, p_first_button_text: ?[*:0]const u8, ...) *gtk.FileChooserDialog;
    pub const new = gtk_file_chooser_dialog_new;

    extern fn gtk_file_chooser_dialog_get_type() usize;
    pub const getGObjectType = gtk_file_chooser_dialog_get_type;

    extern fn g_object_ref(p_self: *gtk.FileChooserDialog) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FileChooserDialog) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FileChooserDialog, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.FileChooserNative` is an abstraction of a dialog box suitable
/// for use with “File/Open” or “File/Save as” commands. By default, this
/// just uses a `gtk.FileChooserDialog` to implement the actual dialog.
/// However, on certain platforms, such as Windows and macOS, the native platform
/// file chooser is used instead. When the application is running in a
/// sandboxed environment without direct filesystem access (such as Flatpak),
/// `gtk.FileChooserNative` may call the proper APIs (portals) to let the user
/// choose a file and make it available to the application.
///
/// While the API of `gtk.FileChooserNative` closely mirrors `gtk.FileChooserDialog`, the main
/// difference is that there is no access to any `gtk.Window` or `gtk.Widget` for the dialog.
/// This is required, as there may not be one in the case of a platform native dialog.
/// Showing, hiding and running the dialog is handled by the `gtk.NativeDialog` functions.
///
/// ## Typical usage
///
/// In the simplest of cases, you can the following code to use
/// `gtk.FileChooserDialog` to select a file for opening:
///
/// ```
/// GtkFileChooserNative *native;
/// GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
/// gint res;
///
/// native = gtk_file_chooser_native_new ("Open File",
///                                       parent_window,
///                                       action,
///                                       "_Open",
///                                       "_Cancel");
///
/// res = gtk_native_dialog_run (GTK_NATIVE_DIALOG (native));
/// if (res == GTK_RESPONSE_ACCEPT)
///   {
///     char *filename;
///     GtkFileChooser *chooser = GTK_FILE_CHOOSER (native);
///     filename = gtk_file_chooser_get_filename (chooser);
///     open_file (filename);
///     g_free (filename);
///   }
///
/// g_object_unref (native);
/// ```
///
/// To use a dialog for saving, you can use this:
///
/// ```
/// GtkFileChooserNative *native;
/// GtkFileChooser *chooser;
/// GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
/// gint res;
///
/// native = gtk_file_chooser_native_new ("Save File",
///                                       parent_window,
///                                       action,
///                                       "_Save",
///                                       "_Cancel");
/// chooser = GTK_FILE_CHOOSER (native);
///
/// gtk_file_chooser_set_do_overwrite_confirmation (chooser, TRUE);
///
/// if (user_edited_a_new_document)
///   gtk_file_chooser_set_current_name (chooser,
///                                      _("Untitled document"));
/// else
///   gtk_file_chooser_set_filename (chooser,
///                                  existing_filename);
///
/// res = gtk_native_dialog_run (GTK_NATIVE_DIALOG (native));
/// if (res == GTK_RESPONSE_ACCEPT)
///   {
///     char *filename;
///
///     filename = gtk_file_chooser_get_filename (chooser);
///     save_to_file (filename);
///     g_free (filename);
///   }
///
/// g_object_unref (native);
/// ```
///
/// For more information on how to best set up a file dialog, see `gtk.FileChooserDialog`.
///
/// ## Response Codes
///
/// `gtk.FileChooserNative` inherits from `gtk.NativeDialog`, which means it
/// will return `GTK_RESPONSE_ACCEPT` if the user accepted, and
/// `GTK_RESPONSE_CANCEL` if he pressed cancel. It can also return
/// `GTK_RESPONSE_DELETE_EVENT` if the window was unexpectedly closed.
///
/// ## Differences from
///
/// There are a few things in the GtkFileChooser API that are not
/// possible to use with `gtk.FileChooserNative`, as such use would
/// prohibit the use of a native dialog.
///
/// There is no support for the signals that are emitted when the user
/// navigates in the dialog, including:
/// * `gtk.FileChooser.signals.current`-folder-changed
/// * `gtk.FileChooser.signals.selection`-changed
/// * `gtk.FileChooser.signals.file`-activated
/// * `gtk.FileChooser.signals.confirm`-overwrite
///
/// You can also not use the methods that directly control user navigation:
/// * `gtk.FileChooser.unselectFilename`
/// * `gtk.FileChooser.selectAll`
/// * `gtk.FileChooser.unselectAll`
///
/// If you need any of the above you will have to use `gtk.FileChooserDialog` directly.
///
/// No operations that change the the dialog work while the dialog is
/// visible. Set all the properties that are required before showing the dialog.
///
/// ## Win32 details
///
/// On windows the IFileDialog implementation (added in Windows Vista) is
/// used. It supports many of the features that `gtk.FileChooserDialog`
/// does, but there are some things it does not handle:
///
/// * Extra widgets added with `gtk.FileChooser.setExtraWidget`.
///
/// * Use of custom previews by connecting to `gtk.FileChooser.signals.update`-preview.
///
/// * Any `gtk.FileFilter` added using a mimetype or custom filter.
///
/// If any of these features are used the regular `gtk.FileChooserDialog`
/// will be used in place of the native one.
///
/// ## Portal details
///
/// When the org.freedesktop.portal.FileChooser portal is available on the
/// session bus, it is used to bring up an out-of-process file chooser. Depending
/// on the kind of session the application is running in, this may or may not
/// be a GTK+ file chooser. In this situation, the following things are not
/// supported and will be silently ignored:
///
/// * Extra widgets added with `gtk.FileChooser.setExtraWidget`.
///
/// * Use of custom previews by connecting to `gtk.FileChooser.signals.update`-preview.
///
/// * Any `gtk.FileFilter` added with a custom filter.
///
/// ## macOS details
///
/// On macOS the NSSavePanel and NSOpenPanel classes are used to provide native
/// file chooser dialogs. Some features provided by `gtk.FileChooserDialog` are
/// not supported:
///
/// * Extra widgets added with `gtk.FileChooser.setExtraWidget`, unless the
///   widget is an instance of GtkLabel, in which case the label text will be used
///   to set the NSSavePanel message instance property.
///
/// * Use of custom previews by connecting to `gtk.FileChooser.signals.update`-preview.
///
/// * Any `gtk.FileFilter` added with a custom filter.
///
/// * Shortcut folders.
pub const FileChooserNative = opaque {
    pub const Parent = gtk.NativeDialog;
    pub const Implements = [_]type{gtk.FileChooser};
    pub const Class = gtk.FileChooserNativeClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The text used for the label on the accept button in the dialog, or
        /// `NULL` to use the default text.
        pub const accept_label = struct {
            pub const name = "accept-label";

            pub const Type = ?[*:0]u8;
        };

        /// The text used for the label on the cancel button in the dialog, or
        /// `NULL` to use the default text.
        pub const cancel_label = struct {
            pub const name = "cancel-label";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.FileChooserNative`.
    extern fn gtk_file_chooser_native_new(p_title: ?[*:0]const u8, p_parent: ?*gtk.Window, p_action: gtk.FileChooserAction, p_accept_label: ?[*:0]const u8, p_cancel_label: ?[*:0]const u8) *gtk.FileChooserNative;
    pub const new = gtk_file_chooser_native_new;

    /// Retrieves the custom label text for the accept button.
    extern fn gtk_file_chooser_native_get_accept_label(p_self: *FileChooserNative) ?[*:0]const u8;
    pub const getAcceptLabel = gtk_file_chooser_native_get_accept_label;

    /// Retrieves the custom label text for the cancel button.
    extern fn gtk_file_chooser_native_get_cancel_label(p_self: *FileChooserNative) ?[*:0]const u8;
    pub const getCancelLabel = gtk_file_chooser_native_get_cancel_label;

    /// Sets the custom label text for the accept button.
    ///
    /// If characters in `label` are preceded by an underscore, they are underlined.
    /// If you need a literal underscore character in a label, use “__” (two
    /// underscores). The first underlined character represents a keyboard
    /// accelerator called a mnemonic.
    /// Pressing Alt and that key activates the button.
    extern fn gtk_file_chooser_native_set_accept_label(p_self: *FileChooserNative, p_accept_label: ?[*:0]const u8) void;
    pub const setAcceptLabel = gtk_file_chooser_native_set_accept_label;

    /// Sets the custom label text for the cancel button.
    ///
    /// If characters in `label` are preceded by an underscore, they are underlined.
    /// If you need a literal underscore character in a label, use “__” (two
    /// underscores). The first underlined character represents a keyboard
    /// accelerator called a mnemonic.
    /// Pressing Alt and that key activates the button.
    extern fn gtk_file_chooser_native_set_cancel_label(p_self: *FileChooserNative, p_cancel_label: ?[*:0]const u8) void;
    pub const setCancelLabel = gtk_file_chooser_native_set_cancel_label;

    extern fn gtk_file_chooser_native_get_type() usize;
    pub const getGObjectType = gtk_file_chooser_native_get_type;

    extern fn g_object_ref(p_self: *gtk.FileChooserNative) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FileChooserNative) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FileChooserNative, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.FileChooserWidget` is a widget for choosing files.
/// It exposes the `gtk.FileChooser` interface, and you should
/// use the methods of this interface to interact with the
/// widget.
///
/// # CSS nodes
///
/// GtkFileChooserWidget has a single CSS node with name filechooser.
pub const FileChooserWidget = extern struct {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.FileChooser, gtk.Orientable };
    pub const Class = gtk.FileChooserWidgetClass;
    f_parent_instance: gtk.Box,
    f_priv: ?*gtk.FileChooserWidgetPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const search_mode = struct {
            pub const name = "search-mode";

            pub const Type = c_int;
        };

        pub const subtitle = struct {
            pub const name = "subtitle";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {
        /// The ::desktop-folder signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user asks for it.
        ///
        /// This is used to make the file chooser show the user's Desktop
        /// folder in the file list.
        ///
        /// The default binding for this signal is `Alt + D`.
        pub const desktop_folder = struct {
            pub const name = "desktop-folder";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooserWidget, p_instance))),
                    gobject.signalLookup("desktop-folder", FileChooserWidget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::down-folder signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user asks for it.
        ///
        /// This is used to make the file chooser go to a child of the current folder
        /// in the file hierarchy. The subfolder that will be used is displayed in the
        /// path bar widget of the file chooser. For example, if the path bar is showing
        /// "/foo/bar/baz", with bar currently displayed, then this will cause the file
        /// chooser to switch to the "baz" subfolder.
        ///
        /// The default binding for this signal is `Alt + Down`.
        pub const down_folder = struct {
            pub const name = "down-folder";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooserWidget, p_instance))),
                    gobject.signalLookup("down-folder", FileChooserWidget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::home-folder signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user asks for it.
        ///
        /// This is used to make the file chooser show the user's home
        /// folder in the file list.
        ///
        /// The default binding for this signal is `Alt + Home`.
        pub const home_folder = struct {
            pub const name = "home-folder";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooserWidget, p_instance))),
                    gobject.signalLookup("home-folder", FileChooserWidget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::location-popup signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user asks for it.
        ///
        /// This is used to make the file chooser show a "Location" prompt which
        /// the user can use to manually type the name of the file he wishes to select.
        ///
        /// The default bindings for this signal are `Control + L` with a `path` string
        /// of "" (the empty string).  It is also bound to `/` with a `path` string of
        /// "`/`" (a slash):  this lets you type `/` and immediately type a path name.
        /// On Unix systems, this is bound to `~` (tilde) with a `path` string of "~"
        /// itself for access to home directories.
        pub const location_popup = struct {
            pub const name = "location-popup";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_path: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooserWidget, p_instance))),
                    gobject.signalLookup("location-popup", FileChooserWidget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::location-popup-on-paste signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user asks for it.
        ///
        /// This is used to make the file chooser show a "Location" prompt when the user
        /// pastes into a `gtk.FileChooserWidget`.
        ///
        /// The default binding for this signal is `Control + V`.
        pub const location_popup_on_paste = struct {
            pub const name = "location-popup-on-paste";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooserWidget, p_instance))),
                    gobject.signalLookup("location-popup-on-paste", FileChooserWidget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::location-toggle-popup signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user asks for it.
        ///
        /// This is used to toggle the visibility of a "Location" prompt which the user
        /// can use to manually type the name of the file he wishes to select.
        ///
        /// The default binding for this signal is `Control + L`.
        pub const location_toggle_popup = struct {
            pub const name = "location-toggle-popup";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooserWidget, p_instance))),
                    gobject.signalLookup("location-toggle-popup", FileChooserWidget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::places-shortcut signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user asks for it.
        ///
        /// This is used to move the focus to the places sidebar.
        ///
        /// The default binding for this signal is `Alt + P`.
        pub const places_shortcut = struct {
            pub const name = "places-shortcut";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooserWidget, p_instance))),
                    gobject.signalLookup("places-shortcut", FileChooserWidget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::quick-bookmark signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user asks for it.
        ///
        /// This is used to make the file chooser switch to the bookmark specified
        /// in the `bookmark_index` parameter. For example, if you have three bookmarks,
        /// you can pass 0, 1, 2 to this signal to switch to each of them, respectively.
        ///
        /// The default binding for this signal is `Alt + 1`, `Alt + 2`,
        /// etc. until `Alt + 0`.  Note that in the default binding, that
        /// `Alt + 1` is actually defined to switch to the bookmark at index
        /// 0, and so on successively; `Alt + 0` is defined to switch to the
        /// bookmark at index 10.
        pub const quick_bookmark = struct {
            pub const name = "quick-bookmark";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_bookmark_index: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooserWidget, p_instance))),
                    gobject.signalLookup("quick-bookmark", FileChooserWidget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::recent-shortcut signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user asks for it.
        ///
        /// This is used to make the file chooser show the Recent location.
        ///
        /// The default binding for this signal is `Alt + R`.
        pub const recent_shortcut = struct {
            pub const name = "recent-shortcut";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooserWidget, p_instance))),
                    gobject.signalLookup("recent-shortcut", FileChooserWidget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::search-shortcut signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user asks for it.
        ///
        /// This is used to make the file chooser show the search entry.
        ///
        /// The default binding for this signal is `Alt + S`.
        pub const search_shortcut = struct {
            pub const name = "search-shortcut";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooserWidget, p_instance))),
                    gobject.signalLookup("search-shortcut", FileChooserWidget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::show-hidden signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user asks for it.
        ///
        /// This is used to make the file chooser display hidden files.
        ///
        /// The default binding for this signal is `Control + H`.
        pub const show_hidden = struct {
            pub const name = "show-hidden";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooserWidget, p_instance))),
                    gobject.signalLookup("show-hidden", FileChooserWidget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::up-folder signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user asks for it.
        ///
        /// This is used to make the file chooser go to the parent of the current folder
        /// in the file hierarchy.
        ///
        /// The default binding for this signal is `Alt + Up`.
        pub const up_folder = struct {
            pub const name = "up-folder";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooserWidget, p_instance))),
                    gobject.signalLookup("up-folder", FileChooserWidget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.FileChooserWidget`. This is a file chooser widget that can
    /// be embedded in custom windows, and it is the same widget that is used by
    /// `gtk.FileChooserDialog`.
    extern fn gtk_file_chooser_widget_new(p_action: gtk.FileChooserAction) *gtk.FileChooserWidget;
    pub const new = gtk_file_chooser_widget_new;

    extern fn gtk_file_chooser_widget_get_type() usize;
    pub const getGObjectType = gtk_file_chooser_widget_get_type;

    extern fn g_object_ref(p_self: *gtk.FileChooserWidget) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FileChooserWidget) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FileChooserWidget, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileChooserWidgetAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component };
    pub const Class = gtk.FileChooserWidgetAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.FileChooserWidgetAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_file_chooser_widget_accessible_get_type() usize;
    pub const getGObjectType = gtk_file_chooser_widget_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.FileChooserWidgetAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FileChooserWidgetAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FileChooserWidgetAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkFileFilter can be used to restrict the files being shown in a
/// `gtk.FileChooser`. Files can be filtered based on their name (with
/// `gtk.FileFilter.addPattern`), on their mime type (with
/// `gtk.FileFilter.addMimeType`), or by a custom filter function
/// (with `gtk.FileFilter.addCustom`).
///
/// Filtering by mime types handles aliasing and subclassing of mime
/// types; e.g. a filter for text/plain also matches a file with mime
/// type application/rtf, since application/rtf is a subclass of
/// text/plain. Note that `gtk.FileFilter` allows wildcards for the
/// subtype of a mime type, so you can e.g. filter for image/\*.
///
/// Normally, filters are used by adding them to a `gtk.FileChooser`,
/// see `gtk.FileChooser.addFilter`, but it is also possible
/// to manually use a filter on a file with `gtk.FileFilter.filter`.
///
/// # GtkFileFilter as GtkBuildable
///
/// The GtkFileFilter implementation of the GtkBuildable interface
/// supports adding rules using the `<mime-types>`, `<patterns>` and
/// `<applications>` elements and listing the rules within. Specifying
/// a `<mime-type>` or `<pattern>` has the same effect as as calling
/// `gtk.FileFilter.addMimeType` or `gtk.FileFilter.addPattern`.
///
/// An example of a UI definition fragment specifying GtkFileFilter
/// rules:
///
/// ```
/// <object class="GtkFileFilter">
///   <mime-types>
///     <mime-type>text/plain</mime-type>
///     <mime-type>image/ *</mime-type>
///   </mime-types>
///   <patterns>
///     <pattern>*.txt</pattern>
///     <pattern>*.png</pattern>
///   </patterns>
/// </object>
/// ```
pub const FileFilter = opaque {
    pub const Parent = gobject.InitiallyUnowned;
    pub const Implements = [_]type{gtk.Buildable};
    pub const Class = opaque {
        pub const Instance = FileFilter;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.FileFilter` with no rules added to it.
    /// Such a filter doesn’t accept any files, so is not
    /// particularly useful until you add rules with
    /// `gtk.FileFilter.addMimeType`, `gtk.FileFilter.addPattern`,
    /// or `gtk.FileFilter.addCustom`. To create a filter
    /// that accepts any file, use:
    /// ```
    /// GtkFileFilter *filter = gtk_file_filter_new ();
    /// gtk_file_filter_add_pattern (filter, "*");
    /// ```
    extern fn gtk_file_filter_new() *gtk.FileFilter;
    pub const new = gtk_file_filter_new;

    /// Deserialize a file filter from an a{sv} variant in
    /// the format produced by `gtk.FileFilter.toGvariant`.
    extern fn gtk_file_filter_new_from_gvariant(p_variant: *glib.Variant) *gtk.FileFilter;
    pub const newFromGvariant = gtk_file_filter_new_from_gvariant;

    /// Adds rule to a filter that allows files based on a custom callback
    /// function. The bitfield `needed` which is passed in provides information
    /// about what sorts of information that the filter function needs;
    /// this allows GTK+ to avoid retrieving expensive information when
    /// it isn’t needed by the filter.
    extern fn gtk_file_filter_add_custom(p_filter: *FileFilter, p_needed: gtk.FileFilterFlags, p_func: gtk.FileFilterFunc, p_data: ?*anyopaque, p_notify: ?glib.DestroyNotify) void;
    pub const addCustom = gtk_file_filter_add_custom;

    /// Adds a rule allowing a given mime type to `filter`.
    extern fn gtk_file_filter_add_mime_type(p_filter: *FileFilter, p_mime_type: [*:0]const u8) void;
    pub const addMimeType = gtk_file_filter_add_mime_type;

    /// Adds a rule allowing a shell style glob to a filter.
    extern fn gtk_file_filter_add_pattern(p_filter: *FileFilter, p_pattern: [*:0]const u8) void;
    pub const addPattern = gtk_file_filter_add_pattern;

    /// Adds a rule allowing image files in the formats supported
    /// by GdkPixbuf.
    extern fn gtk_file_filter_add_pixbuf_formats(p_filter: *FileFilter) void;
    pub const addPixbufFormats = gtk_file_filter_add_pixbuf_formats;

    /// Tests whether a file should be displayed according to `filter`.
    /// The `gtk.FileFilterInfo` `filter_info` should include
    /// the fields returned from `gtk.FileFilter.getNeeded`.
    ///
    /// This function will not typically be used by applications; it
    /// is intended principally for use in the implementation of
    /// `gtk.FileChooser`.
    extern fn gtk_file_filter_filter(p_filter: *FileFilter, p_filter_info: *const gtk.FileFilterInfo) c_int;
    pub const filter = gtk_file_filter_filter;

    /// Gets the human-readable name for the filter. See `gtk.FileFilter.setName`.
    extern fn gtk_file_filter_get_name(p_filter: *FileFilter) ?[*:0]const u8;
    pub const getName = gtk_file_filter_get_name;

    /// Gets the fields that need to be filled in for the `gtk.FileFilterInfo`
    /// passed to `gtk.FileFilter.filter`
    ///
    /// This function will not typically be used by applications; it
    /// is intended principally for use in the implementation of
    /// `gtk.FileChooser`.
    extern fn gtk_file_filter_get_needed(p_filter: *FileFilter) gtk.FileFilterFlags;
    pub const getNeeded = gtk_file_filter_get_needed;

    /// Sets the human-readable name of the filter; this is the string
    /// that will be displayed in the file selector user interface if
    /// there is a selectable list of filters.
    extern fn gtk_file_filter_set_name(p_filter: *FileFilter, p_name: ?[*:0]const u8) void;
    pub const setName = gtk_file_filter_set_name;

    /// Serialize a file filter to an a{sv} variant.
    extern fn gtk_file_filter_to_gvariant(p_filter: *FileFilter) *glib.Variant;
    pub const toGvariant = gtk_file_filter_to_gvariant;

    extern fn gtk_file_filter_get_type() usize;
    pub const getGObjectType = gtk_file_filter_get_type;

    extern fn g_object_ref(p_self: *gtk.FileFilter) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FileFilter) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FileFilter, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Fixed` widget is a container which can place child widgets
/// at fixed positions and with fixed sizes, given in pixels. `gtk.Fixed`
/// performs no automatic layout management.
///
/// For most applications, you should not use this container! It keeps
/// you from having to learn about the other GTK+ containers, but it
/// results in broken applications.  With `gtk.Fixed`, the following
/// things will result in truncated text, overlapping widgets, and
/// other display bugs:
///
/// - Themes, which may change widget sizes.
///
/// - Fonts other than the one you used to write the app will of course
///   change the size of widgets containing text; keep in mind that
///   users may use a larger font because of difficulty reading the
///   default, or they may be using a different OS that provides different fonts.
///
/// - Translation of text into other languages changes its size. Also,
///   display of non-English text will use a different font in many
///   cases.
///
/// In addition, `gtk.Fixed` does not pay attention to text direction and thus may
/// produce unwanted results if your app is run under right-to-left languages
/// such as Hebrew or Arabic. That is: normally GTK+ will order containers
/// appropriately for the text direction, e.g. to put labels to the right of the
/// thing they label when using an RTL language, but it can’t do that with
/// `gtk.Fixed`. So if you need to reorder widgets depending on the text direction,
/// you would need to manually detect it and adjust child positions accordingly.
///
/// Finally, fixed positioning makes it kind of annoying to add/remove
/// GUI elements, since you have to reposition all the other
/// elements. This is a long-term maintenance problem for your
/// application.
///
/// If you know none of these things are an issue for your application,
/// and prefer the simplicity of `gtk.Fixed`, by all means use the
/// widget. But you should be aware of the tradeoffs.
///
/// See also `gtk.Layout`, which shares the ability to perform fixed positioning
/// of child widgets and additionally adds custom drawing and scrollability.
pub const Fixed = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.FixedClass;
    f_container: gtk.Container,
    f_priv: ?*gtk.FixedPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.Fixed`.
    extern fn gtk_fixed_new() *gtk.Fixed;
    pub const new = gtk_fixed_new;

    /// Moves a child of a `gtk.Fixed` container to the given position.
    extern fn gtk_fixed_move(p_fixed: *Fixed, p_widget: *gtk.Widget, p_x: c_int, p_y: c_int) void;
    pub const move = gtk_fixed_move;

    /// Adds a widget to a `gtk.Fixed` container at the given position.
    extern fn gtk_fixed_put(p_fixed: *Fixed, p_widget: *gtk.Widget, p_x: c_int, p_y: c_int) void;
    pub const put = gtk_fixed_put;

    extern fn gtk_fixed_get_type() usize;
    pub const getGObjectType = gtk_fixed_get_type;

    extern fn g_object_ref(p_self: *gtk.Fixed) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Fixed) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Fixed, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkFlowBox positions child widgets in sequence according to its
/// orientation.
///
/// For instance, with the horizontal orientation, the widgets will be
/// arranged from left to right, starting a new row under the previous
/// row when necessary. Reducing the width in this case will require more
/// rows, so a larger height will be requested.
///
/// Likewise, with the vertical orientation, the widgets will be arranged
/// from top to bottom, starting a new column to the right when necessary.
/// Reducing the height will require more columns, so a larger width will
/// be requested.
///
/// The size request of a GtkFlowBox alone may not be what you expect; if you
/// need to be able to shrink it along both axes and dynamically reflow its
/// children, you may have to wrap it in a `gtk.ScrolledWindow` to enable that.
///
/// The children of a GtkFlowBox can be dynamically sorted and filtered.
///
/// Although a GtkFlowBox must have only `gtk.FlowBoxChild` children,
/// you can add any kind of widget to it via `gtk.Container.add`, and
/// a GtkFlowBoxChild widget will automatically be inserted between
/// the box and the widget.
///
/// Also see `gtk.ListBox`.
///
/// GtkFlowBox was added in GTK+ 3.12.
///
/// # CSS nodes
///
/// ```
/// flowbox
/// ├── flowboxchild
/// │   ╰── <child>
/// ├── flowboxchild
/// │   ╰── <child>
/// ┊
/// ╰── [rubberband]
/// ```
///
/// GtkFlowBox uses a single CSS node with name flowbox. GtkFlowBoxChild
/// uses a single CSS node with name flowboxchild.
/// For rubberband selection, a subnode with name rubberband is used.
pub const FlowBox = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.FlowBoxClass;
    f_container: gtk.Container,

    pub const virtual_methods = struct {
        pub const activate_cursor_child = struct {
            pub fn call(p_class: anytype, p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(FlowBox.Class, p_class).f_activate_cursor_child.?(gobject.ext.as(FlowBox, p_box));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(FlowBox.Class, p_class).f_activate_cursor_child = @ptrCast(p_implementation);
            }
        };

        pub const child_activated = struct {
            pub fn call(p_class: anytype, p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.FlowBoxChild) void {
                return gobject.ext.as(FlowBox.Class, p_class).f_child_activated.?(gobject.ext.as(FlowBox, p_box), p_child);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.FlowBoxChild) callconv(.c) void) void {
                gobject.ext.as(FlowBox.Class, p_class).f_child_activated = @ptrCast(p_implementation);
            }
        };

        pub const move_cursor = struct {
            pub fn call(p_class: anytype, p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_step: gtk.MovementStep, p_count: c_int) c_int {
                return gobject.ext.as(FlowBox.Class, p_class).f_move_cursor.?(gobject.ext.as(FlowBox, p_box), p_step, p_count);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_step: gtk.MovementStep, p_count: c_int) callconv(.c) c_int) void {
                gobject.ext.as(FlowBox.Class, p_class).f_move_cursor = @ptrCast(p_implementation);
            }
        };

        /// Select all children of `box`, if the selection
        /// mode allows it.
        pub const select_all = struct {
            pub fn call(p_class: anytype, p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(FlowBox.Class, p_class).f_select_all.?(gobject.ext.as(FlowBox, p_box));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(FlowBox.Class, p_class).f_select_all = @ptrCast(p_implementation);
            }
        };

        pub const selected_children_changed = struct {
            pub fn call(p_class: anytype, p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(FlowBox.Class, p_class).f_selected_children_changed.?(gobject.ext.as(FlowBox, p_box));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(FlowBox.Class, p_class).f_selected_children_changed = @ptrCast(p_implementation);
            }
        };

        pub const toggle_cursor_child = struct {
            pub fn call(p_class: anytype, p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(FlowBox.Class, p_class).f_toggle_cursor_child.?(gobject.ext.as(FlowBox, p_box));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(FlowBox.Class, p_class).f_toggle_cursor_child = @ptrCast(p_implementation);
            }
        };

        /// Unselect all children of `box`, if the selection
        /// mode allows it.
        pub const unselect_all = struct {
            pub fn call(p_class: anytype, p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(FlowBox.Class, p_class).f_unselect_all.?(gobject.ext.as(FlowBox, p_box));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(FlowBox.Class, p_class).f_unselect_all = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Determines whether children can be activated with a single
        /// click, or require a double-click.
        pub const activate_on_single_click = struct {
            pub const name = "activate-on-single-click";

            pub const Type = c_int;
        };

        /// The amount of horizontal space between two children.
        pub const column_spacing = struct {
            pub const name = "column-spacing";

            pub const Type = c_uint;
        };

        /// Determines whether all children should be allocated the
        /// same size.
        pub const homogeneous = struct {
            pub const name = "homogeneous";

            pub const Type = c_int;
        };

        /// The maximum amount of children to request space for consecutively
        /// in the given orientation.
        pub const max_children_per_line = struct {
            pub const name = "max-children-per-line";

            pub const Type = c_uint;
        };

        /// The minimum number of children to allocate consecutively
        /// in the given orientation.
        ///
        /// Setting the minimum children per line ensures
        /// that a reasonably small height will be requested
        /// for the overall minimum width of the box.
        pub const min_children_per_line = struct {
            pub const name = "min-children-per-line";

            pub const Type = c_uint;
        };

        /// The amount of vertical space between two children.
        pub const row_spacing = struct {
            pub const name = "row-spacing";

            pub const Type = c_uint;
        };

        /// The selection mode used by the flow  box.
        pub const selection_mode = struct {
            pub const name = "selection-mode";

            pub const Type = gtk.SelectionMode;
        };
    };

    pub const signals = struct {
        /// The ::activate-cursor-child signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user activates the `box`.
        pub const activate_cursor_child = struct {
            pub const name = "activate-cursor-child";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FlowBox, p_instance))),
                    gobject.signalLookup("activate-cursor-child", FlowBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::child-activated signal is emitted when a child has been
        /// activated by the user.
        pub const child_activated = struct {
            pub const name = "child-activated";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_child: *gtk.FlowBoxChild, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FlowBox, p_instance))),
                    gobject.signalLookup("child-activated", FlowBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::move-cursor signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user initiates a cursor movement.
        ///
        /// Applications should not connect to it, but may emit it with
        /// `gobject.signalEmitByName` if they need to control the cursor
        /// programmatically.
        ///
        /// The default bindings for this signal come in two variants,
        /// the variant with the Shift modifier extends the selection,
        /// the variant without the Shift modifer does not.
        /// There are too many key combinations to list them all here.
        /// - Arrow keys move by individual children
        /// - Home/End keys move to the ends of the box
        /// - PageUp/PageDown keys move vertically by pages
        pub const move_cursor = struct {
            pub const name = "move-cursor";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_step: gtk.MovementStep, p_count: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FlowBox, p_instance))),
                    gobject.signalLookup("move-cursor", FlowBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::select-all signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to select all children of the box, if
        /// the selection mode permits it.
        ///
        /// The default bindings for this signal is Ctrl-a.
        pub const select_all = struct {
            pub const name = "select-all";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FlowBox, p_instance))),
                    gobject.signalLookup("select-all", FlowBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::selected-children-changed signal is emitted when the
        /// set of selected children changes.
        ///
        /// Use `gtk.FlowBox.selectedForeach` or
        /// `gtk.FlowBox.getSelectedChildren` to obtain the
        /// selected children.
        pub const selected_children_changed = struct {
            pub const name = "selected-children-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FlowBox, p_instance))),
                    gobject.signalLookup("selected-children-changed", FlowBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::toggle-cursor-child signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which toggles the selection of the child that has the focus.
        ///
        /// The default binding for this signal is Ctrl-Space.
        pub const toggle_cursor_child = struct {
            pub const name = "toggle-cursor-child";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FlowBox, p_instance))),
                    gobject.signalLookup("toggle-cursor-child", FlowBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::unselect-all signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to unselect all children of the box, if
        /// the selection mode permits it.
        ///
        /// The default bindings for this signal is Ctrl-Shift-a.
        pub const unselect_all = struct {
            pub const name = "unselect-all";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FlowBox, p_instance))),
                    gobject.signalLookup("unselect-all", FlowBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a GtkFlowBox.
    extern fn gtk_flow_box_new() *gtk.FlowBox;
    pub const new = gtk_flow_box_new;

    /// Binds `model` to `box`.
    ///
    /// If `box` was already bound to a model, that previous binding is
    /// destroyed.
    ///
    /// The contents of `box` are cleared and then filled with widgets that
    /// represent items from `model`. `box` is updated whenever `model` changes.
    /// If `model` is `NULL`, `box` is left empty.
    ///
    /// It is undefined to add or remove widgets directly (for example, with
    /// `gtk.FlowBox.insert` or `gtk.Container.add`) while `box` is bound to a
    /// model.
    ///
    /// Note that using a model is incompatible with the filtering and sorting
    /// functionality in GtkFlowBox. When using a model, filtering and sorting
    /// should be implemented by the model.
    extern fn gtk_flow_box_bind_model(p_box: *FlowBox, p_model: ?*gio.ListModel, p_create_widget_func: gtk.FlowBoxCreateWidgetFunc, p_user_data: ?*anyopaque, p_user_data_free_func: ?glib.DestroyNotify) void;
    pub const bindModel = gtk_flow_box_bind_model;

    /// Returns whether children activate on single clicks.
    extern fn gtk_flow_box_get_activate_on_single_click(p_box: *FlowBox) c_int;
    pub const getActivateOnSingleClick = gtk_flow_box_get_activate_on_single_click;

    /// Gets the nth child in the `box`.
    extern fn gtk_flow_box_get_child_at_index(p_box: *FlowBox, p_idx: c_int) ?*gtk.FlowBoxChild;
    pub const getChildAtIndex = gtk_flow_box_get_child_at_index;

    /// Gets the child in the (`x`, `y`) position.
    extern fn gtk_flow_box_get_child_at_pos(p_box: *FlowBox, p_x: c_int, p_y: c_int) ?*gtk.FlowBoxChild;
    pub const getChildAtPos = gtk_flow_box_get_child_at_pos;

    /// Gets the horizontal spacing.
    extern fn gtk_flow_box_get_column_spacing(p_box: *FlowBox) c_uint;
    pub const getColumnSpacing = gtk_flow_box_get_column_spacing;

    /// Returns whether the box is homogeneous (all children are the
    /// same size). See `gtk.Box.setHomogeneous`.
    extern fn gtk_flow_box_get_homogeneous(p_box: *FlowBox) c_int;
    pub const getHomogeneous = gtk_flow_box_get_homogeneous;

    /// Gets the maximum number of children per line.
    extern fn gtk_flow_box_get_max_children_per_line(p_box: *FlowBox) c_uint;
    pub const getMaxChildrenPerLine = gtk_flow_box_get_max_children_per_line;

    /// Gets the minimum number of children per line.
    extern fn gtk_flow_box_get_min_children_per_line(p_box: *FlowBox) c_uint;
    pub const getMinChildrenPerLine = gtk_flow_box_get_min_children_per_line;

    /// Gets the vertical spacing.
    extern fn gtk_flow_box_get_row_spacing(p_box: *FlowBox) c_uint;
    pub const getRowSpacing = gtk_flow_box_get_row_spacing;

    /// Creates a list of all selected children.
    extern fn gtk_flow_box_get_selected_children(p_box: *FlowBox) *glib.List;
    pub const getSelectedChildren = gtk_flow_box_get_selected_children;

    /// Gets the selection mode of `box`.
    extern fn gtk_flow_box_get_selection_mode(p_box: *FlowBox) gtk.SelectionMode;
    pub const getSelectionMode = gtk_flow_box_get_selection_mode;

    /// Inserts the `widget` into `box` at `position`.
    ///
    /// If a sort function is set, the widget will actually be inserted
    /// at the calculated position and this function has the same effect
    /// as `gtk.Container.add`.
    ///
    /// If `position` is -1, or larger than the total number of children
    /// in the `box`, then the `widget` will be appended to the end.
    extern fn gtk_flow_box_insert(p_box: *FlowBox, p_widget: *gtk.Widget, p_position: c_int) void;
    pub const insert = gtk_flow_box_insert;

    /// Updates the filtering for all children.
    ///
    /// Call this function when the result of the filter
    /// function on the `box` is changed due ot an external
    /// factor. For instance, this would be used if the
    /// filter function just looked for a specific search
    /// term, and the entry with the string has changed.
    extern fn gtk_flow_box_invalidate_filter(p_box: *FlowBox) void;
    pub const invalidateFilter = gtk_flow_box_invalidate_filter;

    /// Updates the sorting for all children.
    ///
    /// Call this when the result of the sort function on
    /// `box` is changed due to an external factor.
    extern fn gtk_flow_box_invalidate_sort(p_box: *FlowBox) void;
    pub const invalidateSort = gtk_flow_box_invalidate_sort;

    /// Select all children of `box`, if the selection
    /// mode allows it.
    extern fn gtk_flow_box_select_all(p_box: *FlowBox) void;
    pub const selectAll = gtk_flow_box_select_all;

    /// Selects a single child of `box`, if the selection
    /// mode allows it.
    extern fn gtk_flow_box_select_child(p_box: *FlowBox, p_child: *gtk.FlowBoxChild) void;
    pub const selectChild = gtk_flow_box_select_child;

    /// Calls a function for each selected child.
    ///
    /// Note that the selection cannot be modified from within
    /// this function.
    extern fn gtk_flow_box_selected_foreach(p_box: *FlowBox, p_func: gtk.FlowBoxForeachFunc, p_data: ?*anyopaque) void;
    pub const selectedForeach = gtk_flow_box_selected_foreach;

    /// If `single` is `TRUE`, children will be activated when you click
    /// on them, otherwise you need to double-click.
    extern fn gtk_flow_box_set_activate_on_single_click(p_box: *FlowBox, p_single: c_int) void;
    pub const setActivateOnSingleClick = gtk_flow_box_set_activate_on_single_click;

    /// Sets the horizontal space to add between children.
    /// See the `gtk.FlowBox.properties.column`-spacing property.
    extern fn gtk_flow_box_set_column_spacing(p_box: *FlowBox, p_spacing: c_uint) void;
    pub const setColumnSpacing = gtk_flow_box_set_column_spacing;

    /// By setting a filter function on the `box` one can decide dynamically
    /// which of the children to show. For instance, to implement a search
    /// function that only shows the children matching the search terms.
    ///
    /// The `filter_func` will be called for each child after the call, and
    /// it will continue to be called each time a child changes (via
    /// `gtk.FlowBoxChild.changed`) or when `gtk.FlowBox.invalidateFilter`
    /// is called.
    ///
    /// Note that using a filter function is incompatible with using a model
    /// (see `gtk.FlowBox.bindModel`).
    extern fn gtk_flow_box_set_filter_func(p_box: *FlowBox, p_filter_func: ?gtk.FlowBoxFilterFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setFilterFunc = gtk_flow_box_set_filter_func;

    /// Hooks up an adjustment to focus handling in `box`.
    /// The adjustment is also used for autoscrolling during
    /// rubberband selection. See `gtk.ScrolledWindow.getHadjustment`
    /// for a typical way of obtaining the adjustment, and
    /// `gtk.FlowBox.setVadjustment`for setting the vertical
    /// adjustment.
    ///
    /// The adjustments have to be in pixel units and in the same
    /// coordinate system as the allocation for immediate children
    /// of the box.
    extern fn gtk_flow_box_set_hadjustment(p_box: *FlowBox, p_adjustment: *gtk.Adjustment) void;
    pub const setHadjustment = gtk_flow_box_set_hadjustment;

    /// Sets the `gtk.FlowBox.properties.homogeneous` property of `box`, controlling
    /// whether or not all children of `box` are given equal space
    /// in the box.
    extern fn gtk_flow_box_set_homogeneous(p_box: *FlowBox, p_homogeneous: c_int) void;
    pub const setHomogeneous = gtk_flow_box_set_homogeneous;

    /// Sets the maximum number of children to request and
    /// allocate space for in `box`’s orientation.
    ///
    /// Setting the maximum number of children per line
    /// limits the overall natural size request to be no more
    /// than `n_children` children long in the given orientation.
    extern fn gtk_flow_box_set_max_children_per_line(p_box: *FlowBox, p_n_children: c_uint) void;
    pub const setMaxChildrenPerLine = gtk_flow_box_set_max_children_per_line;

    /// Sets the minimum number of children to line up
    /// in `box`’s orientation before flowing.
    extern fn gtk_flow_box_set_min_children_per_line(p_box: *FlowBox, p_n_children: c_uint) void;
    pub const setMinChildrenPerLine = gtk_flow_box_set_min_children_per_line;

    /// Sets the vertical space to add between children.
    /// See the `gtk.FlowBox.properties.row`-spacing property.
    extern fn gtk_flow_box_set_row_spacing(p_box: *FlowBox, p_spacing: c_uint) void;
    pub const setRowSpacing = gtk_flow_box_set_row_spacing;

    /// Sets how selection works in `box`.
    /// See `gtk.SelectionMode` for details.
    extern fn gtk_flow_box_set_selection_mode(p_box: *FlowBox, p_mode: gtk.SelectionMode) void;
    pub const setSelectionMode = gtk_flow_box_set_selection_mode;

    /// By setting a sort function on the `box`, one can dynamically
    /// reorder the children of the box, based on the contents of
    /// the children.
    ///
    /// The `sort_func` will be called for each child after the call,
    /// and will continue to be called each time a child changes (via
    /// `gtk.FlowBoxChild.changed`) and when `gtk.FlowBox.invalidateSort`
    /// is called.
    ///
    /// Note that using a sort function is incompatible with using a model
    /// (see `gtk.FlowBox.bindModel`).
    extern fn gtk_flow_box_set_sort_func(p_box: *FlowBox, p_sort_func: ?gtk.FlowBoxSortFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setSortFunc = gtk_flow_box_set_sort_func;

    /// Hooks up an adjustment to focus handling in `box`.
    /// The adjustment is also used for autoscrolling during
    /// rubberband selection. See `gtk.ScrolledWindow.getVadjustment`
    /// for a typical way of obtaining the adjustment, and
    /// `gtk.FlowBox.setHadjustment`for setting the horizontal
    /// adjustment.
    ///
    /// The adjustments have to be in pixel units and in the same
    /// coordinate system as the allocation for immediate children
    /// of the box.
    extern fn gtk_flow_box_set_vadjustment(p_box: *FlowBox, p_adjustment: *gtk.Adjustment) void;
    pub const setVadjustment = gtk_flow_box_set_vadjustment;

    /// Unselect all children of `box`, if the selection
    /// mode allows it.
    extern fn gtk_flow_box_unselect_all(p_box: *FlowBox) void;
    pub const unselectAll = gtk_flow_box_unselect_all;

    /// Unselects a single child of `box`, if the selection
    /// mode allows it.
    extern fn gtk_flow_box_unselect_child(p_box: *FlowBox, p_child: *gtk.FlowBoxChild) void;
    pub const unselectChild = gtk_flow_box_unselect_child;

    extern fn gtk_flow_box_get_type() usize;
    pub const getGObjectType = gtk_flow_box_get_type;

    extern fn g_object_ref(p_self: *gtk.FlowBox) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FlowBox) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FlowBox, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FlowBoxAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Selection };
    pub const Class = gtk.FlowBoxAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.FlowBoxAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_flow_box_accessible_get_type() usize;
    pub const getGObjectType = gtk_flow_box_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.FlowBoxAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FlowBoxAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FlowBoxAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FlowBoxChild = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.FlowBoxChildClass;
    f_parent_instance: gtk.Bin,

    pub const virtual_methods = struct {
        pub const activate = struct {
            pub fn call(p_class: anytype, p_child: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(FlowBoxChild.Class, p_class).f_activate.?(gobject.ext.as(FlowBoxChild, p_child));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_child: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(FlowBoxChild.Class, p_class).f_activate = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// The ::activate signal is emitted when the user activates
        /// a child widget in a `gtk.FlowBox`, either by clicking or
        /// double-clicking, or by using the Space or Enter key.
        ///
        /// While this signal is used as a
        /// [keybinding signal][GtkBindingSignal],
        /// it can be used by applications for their own purposes.
        pub const activate = struct {
            pub const name = "activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FlowBoxChild, p_instance))),
                    gobject.signalLookup("activate", FlowBoxChild.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.FlowBoxChild`, to be used as a child
    /// of a `gtk.FlowBox`.
    extern fn gtk_flow_box_child_new() *gtk.FlowBoxChild;
    pub const new = gtk_flow_box_child_new;

    /// Marks `child` as changed, causing any state that depends on this
    /// to be updated. This affects sorting and filtering.
    ///
    /// Note that calls to this method must be in sync with the data
    /// used for the sorting and filtering functions. For instance, if
    /// the list is mirroring some external data set, and *two* children
    /// changed in the external data set when you call
    /// `gtk.FlowBoxChild.changed` on the first child, the sort function
    /// must only read the new data for the first of the two changed
    /// children, otherwise the resorting of the children will be wrong.
    ///
    /// This generally means that if you don’t fully control the data
    /// model, you have to duplicate the data that affects the sorting
    /// and filtering functions into the widgets themselves. Another
    /// alternative is to call `gtk.FlowBox.invalidateSort` on any
    /// model change, but that is more expensive.
    extern fn gtk_flow_box_child_changed(p_child: *FlowBoxChild) void;
    pub const changed = gtk_flow_box_child_changed;

    /// Gets the current index of the `child` in its `gtk.FlowBox` container.
    extern fn gtk_flow_box_child_get_index(p_child: *FlowBoxChild) c_int;
    pub const getIndex = gtk_flow_box_child_get_index;

    /// Returns whether the `child` is currently selected in its
    /// `gtk.FlowBox` container.
    extern fn gtk_flow_box_child_is_selected(p_child: *FlowBoxChild) c_int;
    pub const isSelected = gtk_flow_box_child_is_selected;

    extern fn gtk_flow_box_child_get_type() usize;
    pub const getGObjectType = gtk_flow_box_child_get_type;

    extern fn g_object_ref(p_self: *gtk.FlowBoxChild) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FlowBoxChild) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FlowBoxChild, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FlowBoxChildAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{atk.Component};
    pub const Class = gtk.FlowBoxChildAccessibleClass;
    f_parent: gtk.ContainerAccessible,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_flow_box_child_accessible_get_type() usize;
    pub const getGObjectType = gtk_flow_box_child_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.FlowBoxChildAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FlowBoxChildAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FlowBoxChildAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.FontButton` is a button which displays the currently selected
/// font an allows to open a font chooser dialog to change the font.
/// It is suitable widget for selecting a font in a preference dialog.
///
/// # CSS nodes
///
/// GtkFontButton has a single CSS node with name button and style class .font.
pub const FontButton = extern struct {
    pub const Parent = gtk.Button;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable, gtk.FontChooser };
    pub const Class = gtk.FontButtonClass;
    f_button: gtk.Button,
    f_priv: ?*gtk.FontButtonPrivate,

    pub const virtual_methods = struct {
        pub const font_set = struct {
            pub fn call(p_class: anytype, p_gfp: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(FontButton.Class, p_class).f_font_set.?(gobject.ext.as(FontButton, p_gfp));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_gfp: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(FontButton.Class, p_class).f_font_set = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The name of the currently selected font.
        pub const font_name = struct {
            pub const name = "font-name";

            pub const Type = ?[*:0]u8;
        };

        /// If this property is set to `TRUE`, the selected font size will be shown
        /// in the label. For a more WYSIWYG way to show the selected size, see the
        /// ::use-size property.
        pub const show_size = struct {
            pub const name = "show-size";

            pub const Type = c_int;
        };

        /// If this property is set to `TRUE`, the name of the selected font style
        /// will be shown in the label. For a more WYSIWYG way to show the selected
        /// style, see the ::use-font property.
        pub const show_style = struct {
            pub const name = "show-style";

            pub const Type = c_int;
        };

        /// The title of the font chooser dialog.
        pub const title = struct {
            pub const name = "title";

            pub const Type = ?[*:0]u8;
        };

        /// If this property is set to `TRUE`, the label will be drawn
        /// in the selected font.
        pub const use_font = struct {
            pub const name = "use-font";

            pub const Type = c_int;
        };

        /// If this property is set to `TRUE`, the label will be drawn
        /// with the selected font size.
        pub const use_size = struct {
            pub const name = "use-size";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::font-set signal is emitted when the user selects a font.
        /// When handling this signal, use `gtk.FontChooser.getFont`
        /// to find out which font was just selected.
        ///
        /// Note that this signal is only emitted when the user
        /// changes the font. If you need to react to programmatic font changes
        /// as well, use the notify::font signal.
        pub const font_set = struct {
            pub const name = "font-set";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FontButton, p_instance))),
                    gobject.signalLookup("font-set", FontButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new font picker widget.
    extern fn gtk_font_button_new() *gtk.FontButton;
    pub const new = gtk_font_button_new;

    /// Creates a new font picker widget.
    extern fn gtk_font_button_new_with_font(p_fontname: [*:0]const u8) *gtk.FontButton;
    pub const newWithFont = gtk_font_button_new_with_font;

    /// Retrieves the name of the currently selected font. This name includes
    /// style and size information as well. If you want to render something
    /// with the font, use this string with `pango.fontDescriptionFromString` .
    /// If you’re interested in peeking certain values (family name,
    /// style, size, weight) just query these properties from the
    /// `pango.FontDescription` object.
    extern fn gtk_font_button_get_font_name(p_font_button: *FontButton) [*:0]const u8;
    pub const getFontName = gtk_font_button_get_font_name;

    /// Returns whether the font size will be shown in the label.
    extern fn gtk_font_button_get_show_size(p_font_button: *FontButton) c_int;
    pub const getShowSize = gtk_font_button_get_show_size;

    /// Returns whether the name of the font style will be shown in the label.
    extern fn gtk_font_button_get_show_style(p_font_button: *FontButton) c_int;
    pub const getShowStyle = gtk_font_button_get_show_style;

    /// Retrieves the title of the font chooser dialog.
    extern fn gtk_font_button_get_title(p_font_button: *FontButton) [*:0]const u8;
    pub const getTitle = gtk_font_button_get_title;

    /// Returns whether the selected font is used in the label.
    extern fn gtk_font_button_get_use_font(p_font_button: *FontButton) c_int;
    pub const getUseFont = gtk_font_button_get_use_font;

    /// Returns whether the selected size is used in the label.
    extern fn gtk_font_button_get_use_size(p_font_button: *FontButton) c_int;
    pub const getUseSize = gtk_font_button_get_use_size;

    /// Sets or updates the currently-displayed font in font picker dialog.
    extern fn gtk_font_button_set_font_name(p_font_button: *FontButton, p_fontname: [*:0]const u8) c_int;
    pub const setFontName = gtk_font_button_set_font_name;

    /// If `show_size` is `TRUE`, the font size will be displayed along with the name of the selected font.
    extern fn gtk_font_button_set_show_size(p_font_button: *FontButton, p_show_size: c_int) void;
    pub const setShowSize = gtk_font_button_set_show_size;

    /// If `show_style` is `TRUE`, the font style will be displayed along with name of the selected font.
    extern fn gtk_font_button_set_show_style(p_font_button: *FontButton, p_show_style: c_int) void;
    pub const setShowStyle = gtk_font_button_set_show_style;

    /// Sets the title for the font chooser dialog.
    extern fn gtk_font_button_set_title(p_font_button: *FontButton, p_title: [*:0]const u8) void;
    pub const setTitle = gtk_font_button_set_title;

    /// If `use_font` is `TRUE`, the font name will be written using the selected font.
    extern fn gtk_font_button_set_use_font(p_font_button: *FontButton, p_use_font: c_int) void;
    pub const setUseFont = gtk_font_button_set_use_font;

    /// If `use_size` is `TRUE`, the font name will be written using the selected size.
    extern fn gtk_font_button_set_use_size(p_font_button: *FontButton, p_use_size: c_int) void;
    pub const setUseSize = gtk_font_button_set_use_size;

    extern fn gtk_font_button_get_type() usize;
    pub const getGObjectType = gtk_font_button_get_type;

    extern fn g_object_ref(p_self: *gtk.FontButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FontButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FontButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.FontChooserDialog` widget is a dialog for selecting a font.
/// It implements the `gtk.FontChooser` interface.
///
/// # GtkFontChooserDialog as GtkBuildable
///
/// The GtkFontChooserDialog implementation of the `gtk.Buildable`
/// interface exposes the buttons with the names “select_button”
/// and “cancel_button”.
pub const FontChooserDialog = extern struct {
    pub const Parent = gtk.Dialog;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.FontChooser };
    pub const Class = gtk.FontChooserDialogClass;
    f_parent_instance: gtk.Dialog,
    f_priv: ?*gtk.FontChooserDialogPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.FontChooserDialog`.
    extern fn gtk_font_chooser_dialog_new(p_title: ?[*:0]const u8, p_parent: ?*gtk.Window) *gtk.FontChooserDialog;
    pub const new = gtk_font_chooser_dialog_new;

    extern fn gtk_font_chooser_dialog_get_type() usize;
    pub const getGObjectType = gtk_font_chooser_dialog_get_type;

    extern fn g_object_ref(p_self: *gtk.FontChooserDialog) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FontChooserDialog) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FontChooserDialog, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.FontChooserWidget` widget lists the available fonts,
/// styles and sizes, allowing the user to select a font. It is
/// used in the `gtk.FontChooserDialog` widget to provide a
/// dialog box for selecting fonts.
///
/// To set the font which is initially selected, use
/// `gtk.FontChooser.setFont` or `gtk.FontChooser.setFontDesc`.
///
/// To get the selected font use `gtk.FontChooser.getFont` or
/// `gtk.FontChooser.getFontDesc`.
///
/// To change the text which is shown in the preview area, use
/// `gtk.FontChooser.setPreviewText`.
///
/// # CSS nodes
///
/// GtkFontChooserWidget has a single CSS node with name fontchooser.
pub const FontChooserWidget = extern struct {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.FontChooser, gtk.Orientable };
    pub const Class = gtk.FontChooserWidgetClass;
    f_parent_instance: gtk.Box,
    f_priv: ?*gtk.FontChooserWidgetPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// A toggle action that can be used to switch to the tweak page
        /// of the font chooser widget, which lets the user tweak the
        /// OpenType features and variation axes of the selected font.
        ///
        /// The action will be enabled or disabled depending on whether
        /// the selected font has any features or axes.
        pub const tweak_action = struct {
            pub const name = "tweak-action";

            pub const Type = ?*gio.Action;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.FontChooserWidget`.
    extern fn gtk_font_chooser_widget_new() *gtk.FontChooserWidget;
    pub const new = gtk_font_chooser_widget_new;

    extern fn gtk_font_chooser_widget_get_type() usize;
    pub const getGObjectType = gtk_font_chooser_widget_get_type;

    extern fn g_object_ref(p_self: *gtk.FontChooserWidget) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FontChooserWidget) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FontChooserWidget, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FontSelection = extern struct {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.FontSelectionClass;
    f_parent_instance: gtk.Box,
    f_priv: ?*gtk.FontSelectionPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const font_name = struct {
            pub const name = "font-name";

            pub const Type = ?[*:0]u8;
        };

        pub const preview_text = struct {
            pub const name = "preview-text";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.FontSelection`.
    extern fn gtk_font_selection_new() *gtk.FontSelection;
    pub const new = gtk_font_selection_new;

    /// Gets the `pango.FontFace` representing the selected font group
    /// details (i.e. family, slant, weight, width, etc).
    extern fn gtk_font_selection_get_face(p_fontsel: *FontSelection) *pango.FontFace;
    pub const getFace = gtk_font_selection_get_face;

    /// This returns the `gtk.TreeView` which lists all styles available for
    /// the selected font. For example, “Regular”, “Bold”, etc.
    extern fn gtk_font_selection_get_face_list(p_fontsel: *FontSelection) *gtk.Widget;
    pub const getFaceList = gtk_font_selection_get_face_list;

    /// Gets the `pango.FontFamily` representing the selected font family.
    extern fn gtk_font_selection_get_family(p_fontsel: *FontSelection) *pango.FontFamily;
    pub const getFamily = gtk_font_selection_get_family;

    /// This returns the `gtk.TreeView` that lists font families, for
    /// example, “Sans”, “Serif”, etc.
    extern fn gtk_font_selection_get_family_list(p_fontsel: *FontSelection) *gtk.Widget;
    pub const getFamilyList = gtk_font_selection_get_family_list;

    /// Gets the currently-selected font name.
    ///
    /// Note that this can be a different string than what you set with
    /// `gtk.FontSelection.setFontName`, as the font selection widget may
    /// normalize font names and thus return a string with a different structure.
    /// For example, “Helvetica Italic Bold 12” could be normalized to
    /// “Helvetica Bold Italic 12”. Use `pango.FontDescription.equal`
    /// if you want to compare two font descriptions.
    extern fn gtk_font_selection_get_font_name(p_fontsel: *FontSelection) [*:0]u8;
    pub const getFontName = gtk_font_selection_get_font_name;

    /// This returns the `gtk.Entry` used to display the font as a preview.
    extern fn gtk_font_selection_get_preview_entry(p_fontsel: *FontSelection) *gtk.Widget;
    pub const getPreviewEntry = gtk_font_selection_get_preview_entry;

    /// Gets the text displayed in the preview area.
    extern fn gtk_font_selection_get_preview_text(p_fontsel: *FontSelection) [*:0]const u8;
    pub const getPreviewText = gtk_font_selection_get_preview_text;

    /// The selected font size.
    extern fn gtk_font_selection_get_size(p_fontsel: *FontSelection) c_int;
    pub const getSize = gtk_font_selection_get_size;

    /// This returns the `gtk.Entry` used to allow the user to edit the font
    /// number manually instead of selecting it from the list of font sizes.
    extern fn gtk_font_selection_get_size_entry(p_fontsel: *FontSelection) *gtk.Widget;
    pub const getSizeEntry = gtk_font_selection_get_size_entry;

    /// This returns the `gtk.TreeView` used to list font sizes.
    extern fn gtk_font_selection_get_size_list(p_fontsel: *FontSelection) *gtk.Widget;
    pub const getSizeList = gtk_font_selection_get_size_list;

    /// Sets the currently-selected font.
    ///
    /// Note that the `fontsel` needs to know the screen in which it will appear
    /// for this to work; this can be guaranteed by simply making sure that the
    /// `fontsel` is inserted in a toplevel window before you call this function.
    extern fn gtk_font_selection_set_font_name(p_fontsel: *FontSelection, p_fontname: [*:0]const u8) c_int;
    pub const setFontName = gtk_font_selection_set_font_name;

    /// Sets the text displayed in the preview area.
    /// The `text` is used to show how the selected font looks.
    extern fn gtk_font_selection_set_preview_text(p_fontsel: *FontSelection, p_text: [*:0]const u8) void;
    pub const setPreviewText = gtk_font_selection_set_preview_text;

    extern fn gtk_font_selection_get_type() usize;
    pub const getGObjectType = gtk_font_selection_get_type;

    extern fn g_object_ref(p_self: *gtk.FontSelection) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FontSelection) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FontSelection, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FontSelectionDialog = extern struct {
    pub const Parent = gtk.Dialog;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.FontSelectionDialogClass;
    f_parent_instance: gtk.Dialog,
    f_priv: ?*gtk.FontSelectionDialogPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.FontSelectionDialog`.
    extern fn gtk_font_selection_dialog_new(p_title: [*:0]const u8) *gtk.FontSelectionDialog;
    pub const new = gtk_font_selection_dialog_new;

    /// Gets the “Cancel” button.
    extern fn gtk_font_selection_dialog_get_cancel_button(p_fsd: *FontSelectionDialog) *gtk.Widget;
    pub const getCancelButton = gtk_font_selection_dialog_get_cancel_button;

    /// Gets the currently-selected font name.
    ///
    /// Note that this can be a different string than what you set with
    /// `gtk.FontSelectionDialog.setFontName`, as the font selection widget
    /// may normalize font names and thus return a string with a different
    /// structure. For example, “Helvetica Italic Bold 12” could be normalized
    /// to “Helvetica Bold Italic 12”.  Use `pango.FontDescription.equal`
    /// if you want to compare two font descriptions.
    extern fn gtk_font_selection_dialog_get_font_name(p_fsd: *FontSelectionDialog) [*:0]u8;
    pub const getFontName = gtk_font_selection_dialog_get_font_name;

    /// Retrieves the `gtk.FontSelection` widget embedded in the dialog.
    extern fn gtk_font_selection_dialog_get_font_selection(p_fsd: *FontSelectionDialog) *gtk.Widget;
    pub const getFontSelection = gtk_font_selection_dialog_get_font_selection;

    /// Gets the “OK” button.
    extern fn gtk_font_selection_dialog_get_ok_button(p_fsd: *FontSelectionDialog) *gtk.Widget;
    pub const getOkButton = gtk_font_selection_dialog_get_ok_button;

    /// Gets the text displayed in the preview area.
    extern fn gtk_font_selection_dialog_get_preview_text(p_fsd: *FontSelectionDialog) [*:0]const u8;
    pub const getPreviewText = gtk_font_selection_dialog_get_preview_text;

    /// Sets the currently selected font.
    extern fn gtk_font_selection_dialog_set_font_name(p_fsd: *FontSelectionDialog, p_fontname: [*:0]const u8) c_int;
    pub const setFontName = gtk_font_selection_dialog_set_font_name;

    /// Sets the text displayed in the preview area.
    extern fn gtk_font_selection_dialog_set_preview_text(p_fsd: *FontSelectionDialog, p_text: [*:0]const u8) void;
    pub const setPreviewText = gtk_font_selection_dialog_set_preview_text;

    extern fn gtk_font_selection_dialog_get_type() usize;
    pub const getGObjectType = gtk_font_selection_dialog_get_type;

    extern fn g_object_ref(p_self: *gtk.FontSelectionDialog) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FontSelectionDialog) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FontSelectionDialog, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The frame widget is a bin that surrounds its child with a decorative
/// frame and an optional label. If present, the label is drawn in a gap
/// in the top side of the frame. The position of the label can be
/// controlled with `gtk.Frame.setLabelAlign`.
///
/// # GtkFrame as GtkBuildable
///
/// The GtkFrame implementation of the `gtk.Buildable` interface supports
/// placing a child in the label position by specifying “label” as the
/// “type” attribute of a `<child>` element. A normal content child can
/// be specified without specifying a `<child>` type attribute.
///
/// An example of a UI definition fragment with `GtkFrame`:
///
/// ```
/// <object class="GtkFrame">
///   <child type="label">
///     <object class="GtkLabel" id="frame-label"/>
///   </child>
///   <child>
///     <object class="GtkEntry" id="frame-content"/>
///   </child>
/// </object>
/// ```
///
/// # CSS nodes
///
/// ```
/// frame
/// ├── border[.flat]
/// ├── <label widget>
/// ╰── <child>
/// ```
///
/// GtkFrame has a main CSS node named “frame” and a subnode named “border”. The
/// “border” node is used to draw the visible border. You can set the appearance
/// of the border using CSS properties like “border-style” on the “border” node.
///
/// The border node can be given the style class “.flat”, which is used by themes
/// to disable drawing of the border. To do this from code, call
/// `gtk.Frame.setShadowType` with `GTK_SHADOW_NONE` to add the “.flat” class or
/// any other shadow type to remove it.
pub const Frame = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.FrameClass;
    f_bin: gtk.Bin,
    f_priv: ?*gtk.FramePrivate,

    pub const virtual_methods = struct {
        pub const compute_child_allocation = struct {
            pub fn call(p_class: anytype, p_frame: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_allocation: *gtk.Allocation) void {
                return gobject.ext.as(Frame.Class, p_class).f_compute_child_allocation.?(gobject.ext.as(Frame, p_frame), p_allocation);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_frame: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_allocation: *gtk.Allocation) callconv(.c) void) void {
                gobject.ext.as(Frame.Class, p_class).f_compute_child_allocation = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const label = struct {
            pub const name = "label";

            pub const Type = ?[*:0]u8;
        };

        pub const label_widget = struct {
            pub const name = "label-widget";

            pub const Type = ?*gtk.Widget;
        };

        pub const label_xalign = struct {
            pub const name = "label-xalign";

            pub const Type = f32;
        };

        pub const label_yalign = struct {
            pub const name = "label-yalign";

            pub const Type = f32;
        };

        pub const shadow_type = struct {
            pub const name = "shadow-type";

            pub const Type = gtk.ShadowType;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.Frame`, with optional label `label`.
    /// If `label` is `NULL`, the label is omitted.
    extern fn gtk_frame_new(p_label: ?[*:0]const u8) *gtk.Frame;
    pub const new = gtk_frame_new;

    /// If the frame’s label widget is a `gtk.Label`, returns the
    /// text in the label widget. (The frame will have a `gtk.Label`
    /// for the label widget if a non-`NULL` argument was passed
    /// to `gtk.Frame.new`.)
    extern fn gtk_frame_get_label(p_frame: *Frame) ?[*:0]const u8;
    pub const getLabel = gtk_frame_get_label;

    /// Retrieves the X and Y alignment of the frame’s label. See
    /// `gtk.Frame.setLabelAlign`.
    extern fn gtk_frame_get_label_align(p_frame: *Frame, p_xalign: ?*f32, p_yalign: ?*f32) void;
    pub const getLabelAlign = gtk_frame_get_label_align;

    /// Retrieves the label widget for the frame. See
    /// `gtk.Frame.setLabelWidget`.
    extern fn gtk_frame_get_label_widget(p_frame: *Frame) ?*gtk.Widget;
    pub const getLabelWidget = gtk_frame_get_label_widget;

    /// Retrieves the shadow type of the frame. See
    /// `gtk.Frame.setShadowType`.
    extern fn gtk_frame_get_shadow_type(p_frame: *Frame) gtk.ShadowType;
    pub const getShadowType = gtk_frame_get_shadow_type;

    /// Removes the current `gtk.Frame.properties.label`-widget. If `label` is not `NULL`, creates a
    /// new `gtk.Label` with that text and adds it as the `gtk.Frame.properties.label`-widget.
    extern fn gtk_frame_set_label(p_frame: *Frame, p_label: ?[*:0]const u8) void;
    pub const setLabel = gtk_frame_set_label;

    /// Sets the alignment of the frame widget’s label. The
    /// default values for a newly created frame are 0.0 and 0.5.
    extern fn gtk_frame_set_label_align(p_frame: *Frame, p_xalign: f32, p_yalign: f32) void;
    pub const setLabelAlign = gtk_frame_set_label_align;

    /// Sets the `gtk.Frame.properties.label`-widget for the frame. This is the widget that
    /// will appear embedded in the top edge of the frame as a title.
    extern fn gtk_frame_set_label_widget(p_frame: *Frame, p_label_widget: ?*gtk.Widget) void;
    pub const setLabelWidget = gtk_frame_set_label_widget;

    /// Sets the `gtk.Frame.properties.shadow`-type for `frame`, i.e. whether it is drawn without
    /// (`GTK_SHADOW_NONE`) or with (other values) a visible border. Values other than
    /// `GTK_SHADOW_NONE` are treated identically by GtkFrame. The chosen type is
    /// applied by removing or adding the .flat class to the CSS node named border.
    extern fn gtk_frame_set_shadow_type(p_frame: *Frame, p_type: gtk.ShadowType) void;
    pub const setShadowType = gtk_frame_set_shadow_type;

    extern fn gtk_frame_get_type() usize;
    pub const getGObjectType = gtk_frame_get_type;

    extern fn g_object_ref(p_self: *gtk.Frame) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Frame) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Frame, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FrameAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{atk.Component};
    pub const Class = gtk.FrameAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.FrameAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_frame_accessible_get_type() usize;
    pub const getGObjectType = gtk_frame_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.FrameAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FrameAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FrameAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.GLArea` is a widget that allows drawing with OpenGL.
///
/// `gtk.GLArea` sets up its own `gdk.GLContext` for the window it creates, and
/// creates a custom GL framebuffer that the widget will do GL rendering onto.
/// It also ensures that this framebuffer is the default GL rendering target
/// when rendering.
///
/// In order to draw, you have to connect to the `gtk.GLArea.signals.render` signal,
/// or subclass `gtk.GLArea` and override the `GtkGLAreaClass`.`render` virtual
/// function.
///
/// The `gtk.GLArea` widget ensures that the `gdk.GLContext` is associated with
/// the widget's drawing area, and it is kept updated when the size and
/// position of the drawing area changes.
///
/// ## Drawing with GtkGLArea
///
/// The simplest way to draw using OpenGL commands in a `gtk.GLArea` is to
/// create a widget instance and connect to the `gtk.GLArea.signals.render` signal:
///
/// ```
///   // create a GtkGLArea instance
///   GtkWidget *gl_area = gtk_gl_area_new ();
///
///   // connect to the "render" signal
///   g_signal_connect (gl_area, "render", G_CALLBACK (render), NULL);
/// ```
///
/// The ``render`` function will be called when the `gtk.GLArea` is ready
/// for you to draw its content:
///
/// ```
///   static gboolean
///   render (GtkGLArea *area, GdkGLContext *context)
///   {
///     // inside this function it's safe to use GL; the given
///     // `gdk.GLContext` has been made current to the drawable
///     // surface used by the `gtk.GLArea` and the viewport has
///     // already been set to be the size of the allocation
///
///     // we can start by clearing the buffer
///     glClearColor (0, 0, 0, 0);
///     glClear (GL_COLOR_BUFFER_BIT);
///
///     // draw your object
///     draw_an_object ();
///
///     // we completed our drawing; the draw commands will be
///     // flushed at the end of the signal emission chain, and
///     // the buffers will be drawn on the window
///     return TRUE;
///   }
/// ```
///
/// If you need to initialize OpenGL state, e.g. buffer objects or
/// shaders, you should use the `gtk.Widget.signals.realize` signal; you
/// can use the `gtk.Widget.signals.unrealize` signal to clean up. Since the
/// `gdk.GLContext` creation and initialization may fail, you will
/// need to check for errors, using `gtk.GLArea.getError`. An example
/// of how to safely initialize the GL state is:
///
/// ```
///   static void
///   on_realize (GtkGLarea *area)
///   {
///     // We need to make the context current if we want to
///     // call GL API
///     gtk_gl_area_make_current (area);
///
///     // If there were errors during the initialization or
///     // when trying to make the context current, this
///     // function will return a `glib.Error` for you to catch
///     if (gtk_gl_area_get_error (area) != NULL)
///       return;
///
///     // You can also use `gtk.GLArea.setError` in order
///     // to show eventual initialization errors on the
///     // GtkGLArea widget itself
///     GError *internal_error = NULL;
///     init_buffer_objects (&error);
///     if (error != NULL)
///       {
///         gtk_gl_area_set_error (area, error);
///         g_error_free (error);
///         return;
///       }
///
///     init_shaders (&error);
///     if (error != NULL)
///       {
///         gtk_gl_area_set_error (area, error);
///         g_error_free (error);
///         return;
///       }
///   }
/// ```
///
/// If you need to change the options for creating the `gdk.GLContext`
/// you should use the `gtk.GLArea.signals.create`-context signal.
pub const GLArea = extern struct {
    pub const Parent = gtk.Widget;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.GLAreaClass;
    f_parent_instance: gtk.Widget,

    pub const virtual_methods = struct {
        /// class closure for the `gtk.GLArea.signals.create`-context signal
        pub const create_context = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gdk.GLContext {
                return gobject.ext.as(GLArea.Class, p_class).f_create_context.?(gobject.ext.as(GLArea, p_area));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gdk.GLContext) void {
                gobject.ext.as(GLArea.Class, p_class).f_create_context = @ptrCast(p_implementation);
            }
        };

        /// class closure for the `gtk.GLArea.signals.render` signal
        pub const render = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.GLContext) c_int {
                return gobject.ext.as(GLArea.Class, p_class).f_render.?(gobject.ext.as(GLArea, p_area), p_context);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.GLContext) callconv(.c) c_int) void {
                gobject.ext.as(GLArea.Class, p_class).f_render = @ptrCast(p_implementation);
            }
        };

        /// class closeure for the `gtk.GLArea.signals.resize` signal
        pub const resize = struct {
            pub fn call(p_class: anytype, p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_width: c_int, p_height: c_int) void {
                return gobject.ext.as(GLArea.Class, p_class).f_resize.?(gobject.ext.as(GLArea, p_area), p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_area: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_width: c_int, p_height: c_int) callconv(.c) void) void {
                gobject.ext.as(GLArea.Class, p_class).f_resize = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// If set to `TRUE` the `gtk.GLArea.signals.render` signal will be emitted every time
        /// the widget draws. This is the default and is useful if drawing the widget
        /// is faster.
        ///
        /// If set to `FALSE` the data from previous rendering is kept around and will
        /// be used for drawing the widget the next time, unless the window is resized.
        /// In order to force a rendering `gtk.GLArea.queueRender` must be called.
        /// This mode is useful when the scene changes seldomly, but takes a long time
        /// to redraw.
        pub const auto_render = struct {
            pub const name = "auto-render";

            pub const Type = c_int;
        };

        /// The `gdk.GLContext` used by the `gtk.GLArea` widget.
        ///
        /// The `gtk.GLArea` widget is responsible for creating the `gdk.GLContext`
        /// instance. If you need to render with other kinds of buffers (stencil,
        /// depth, etc), use render buffers.
        pub const context = struct {
            pub const name = "context";

            pub const Type = ?*gdk.GLContext;
        };

        /// If set to `TRUE` the buffer allocated by the widget will have an alpha channel
        /// component, and when rendering to the window the result will be composited over
        /// whatever is below the widget.
        ///
        /// If set to `FALSE` there will be no alpha channel, and the buffer will fully
        /// replace anything below the widget.
        pub const has_alpha = struct {
            pub const name = "has-alpha";

            pub const Type = c_int;
        };

        /// If set to `TRUE` the widget will allocate and enable a depth buffer for the
        /// target framebuffer.
        pub const has_depth_buffer = struct {
            pub const name = "has-depth-buffer";

            pub const Type = c_int;
        };

        /// If set to `TRUE` the widget will allocate and enable a stencil buffer for the
        /// target framebuffer.
        pub const has_stencil_buffer = struct {
            pub const name = "has-stencil-buffer";

            pub const Type = c_int;
        };

        /// If set to `TRUE` the widget will try to create a `gdk.GLContext` using
        /// OpenGL ES instead of OpenGL.
        ///
        /// See also: `gdk.GLContext.setUseEs`
        pub const use_es = struct {
            pub const name = "use-es";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::create-context signal is emitted when the widget is being
        /// realized, and allows you to override how the GL context is
        /// created. This is useful when you want to reuse an existing GL
        /// context, or if you want to try creating different kinds of GL
        /// options.
        ///
        /// If context creation fails then the signal handler can use
        /// `gtk.GLArea.setError` to register a more detailed error
        /// of how the construction failed.
        pub const create_context = struct {
            pub const name = "create-context";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) *gdk.GLContext, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GLArea, p_instance))),
                    gobject.signalLookup("create-context", GLArea.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::render signal is emitted every time the contents
        /// of the `gtk.GLArea` should be redrawn.
        ///
        /// The `context` is bound to the `area` prior to emitting this function,
        /// and the buffers are painted to the window once the emission terminates.
        pub const render = struct {
            pub const name = "render";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gdk.GLContext, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GLArea, p_instance))),
                    gobject.signalLookup("render", GLArea.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::resize signal is emitted once when the widget is realized, and
        /// then each time the widget is changed while realized. This is useful
        /// in order to keep GL state up to date with the widget size, like for
        /// instance camera properties which may depend on the width/height ratio.
        ///
        /// The GL context for the area is guaranteed to be current when this signal
        /// is emitted.
        ///
        /// The default handler sets up the GL viewport.
        pub const resize = struct {
            pub const name = "resize";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_width: c_int, p_height: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GLArea, p_instance))),
                    gobject.signalLookup("resize", GLArea.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.GLArea` widget.
    extern fn gtk_gl_area_new() *gtk.GLArea;
    pub const new = gtk_gl_area_new;

    /// Ensures that the `area` framebuffer object is made the current draw
    /// and read target, and that all the required buffers for the `area`
    /// are created and bound to the frambuffer.
    ///
    /// This function is automatically called before emitting the
    /// `gtk.GLArea.signals.render` signal, and doesn't normally need to be called
    /// by application code.
    extern fn gtk_gl_area_attach_buffers(p_area: *GLArea) void;
    pub const attachBuffers = gtk_gl_area_attach_buffers;

    /// Returns whether the area is in auto render mode or not.
    extern fn gtk_gl_area_get_auto_render(p_area: *GLArea) c_int;
    pub const getAutoRender = gtk_gl_area_get_auto_render;

    /// Retrieves the `gdk.GLContext` used by `area`.
    extern fn gtk_gl_area_get_context(p_area: *GLArea) *gdk.GLContext;
    pub const getContext = gtk_gl_area_get_context;

    /// Gets the current error set on the `area`.
    extern fn gtk_gl_area_get_error(p_area: *GLArea) ?*glib.Error;
    pub const getError = gtk_gl_area_get_error;

    /// Returns whether the area has an alpha component.
    extern fn gtk_gl_area_get_has_alpha(p_area: *GLArea) c_int;
    pub const getHasAlpha = gtk_gl_area_get_has_alpha;

    /// Returns whether the area has a depth buffer.
    extern fn gtk_gl_area_get_has_depth_buffer(p_area: *GLArea) c_int;
    pub const getHasDepthBuffer = gtk_gl_area_get_has_depth_buffer;

    /// Returns whether the area has a stencil buffer.
    extern fn gtk_gl_area_get_has_stencil_buffer(p_area: *GLArea) c_int;
    pub const getHasStencilBuffer = gtk_gl_area_get_has_stencil_buffer;

    /// Retrieves the required version of OpenGL set
    /// using `gtk.GLArea.setRequiredVersion`.
    extern fn gtk_gl_area_get_required_version(p_area: *GLArea, p_major: *c_int, p_minor: *c_int) void;
    pub const getRequiredVersion = gtk_gl_area_get_required_version;

    /// Retrieves the value set by `gtk.GLArea.setUseEs`.
    extern fn gtk_gl_area_get_use_es(p_area: *GLArea) c_int;
    pub const getUseEs = gtk_gl_area_get_use_es;

    /// Ensures that the `gdk.GLContext` used by `area` is associated with
    /// the `gtk.GLArea`.
    ///
    /// This function is automatically called before emitting the
    /// `gtk.GLArea.signals.render` signal, and doesn't normally need to be called
    /// by application code.
    extern fn gtk_gl_area_make_current(p_area: *GLArea) void;
    pub const makeCurrent = gtk_gl_area_make_current;

    /// Marks the currently rendered data (if any) as invalid, and queues
    /// a redraw of the widget, ensuring that the `gtk.GLArea.signals.render` signal
    /// is emitted during the draw.
    ///
    /// This is only needed when the `gtk.GLArea.setAutoRender` has
    /// been called with a `FALSE` value. The default behaviour is to
    /// emit `gtk.GLArea.signals.render` on each draw.
    extern fn gtk_gl_area_queue_render(p_area: *GLArea) void;
    pub const queueRender = gtk_gl_area_queue_render;

    /// If `auto_render` is `TRUE` the `gtk.GLArea.signals.render` signal will be
    /// emitted every time the widget draws. This is the default and is
    /// useful if drawing the widget is faster.
    ///
    /// If `auto_render` is `FALSE` the data from previous rendering is kept
    /// around and will be used for drawing the widget the next time,
    /// unless the window is resized. In order to force a rendering
    /// `gtk.GLArea.queueRender` must be called. This mode is useful when
    /// the scene changes seldomly, but takes a long time to redraw.
    extern fn gtk_gl_area_set_auto_render(p_area: *GLArea, p_auto_render: c_int) void;
    pub const setAutoRender = gtk_gl_area_set_auto_render;

    /// Sets an error on the area which will be shown instead of the
    /// GL rendering. This is useful in the `gtk.GLArea.signals.create`-context
    /// signal if GL context creation fails.
    extern fn gtk_gl_area_set_error(p_area: *GLArea, p_error: ?*const glib.Error) void;
    pub const setError = gtk_gl_area_set_error;

    /// If `has_alpha` is `TRUE` the buffer allocated by the widget will have
    /// an alpha channel component, and when rendering to the window the
    /// result will be composited over whatever is below the widget.
    ///
    /// If `has_alpha` is `FALSE` there will be no alpha channel, and the
    /// buffer will fully replace anything below the widget.
    extern fn gtk_gl_area_set_has_alpha(p_area: *GLArea, p_has_alpha: c_int) void;
    pub const setHasAlpha = gtk_gl_area_set_has_alpha;

    /// If `has_depth_buffer` is `TRUE` the widget will allocate and
    /// enable a depth buffer for the target framebuffer. Otherwise
    /// there will be none.
    extern fn gtk_gl_area_set_has_depth_buffer(p_area: *GLArea, p_has_depth_buffer: c_int) void;
    pub const setHasDepthBuffer = gtk_gl_area_set_has_depth_buffer;

    /// If `has_stencil_buffer` is `TRUE` the widget will allocate and
    /// enable a stencil buffer for the target framebuffer. Otherwise
    /// there will be none.
    extern fn gtk_gl_area_set_has_stencil_buffer(p_area: *GLArea, p_has_stencil_buffer: c_int) void;
    pub const setHasStencilBuffer = gtk_gl_area_set_has_stencil_buffer;

    /// Sets the required version of OpenGL to be used when creating the context
    /// for the widget.
    ///
    /// This function must be called before the area has been realized.
    extern fn gtk_gl_area_set_required_version(p_area: *GLArea, p_major: c_int, p_minor: c_int) void;
    pub const setRequiredVersion = gtk_gl_area_set_required_version;

    /// Sets whether the `area` should create an OpenGL or an OpenGL ES context.
    ///
    /// You should check the capabilities of the `gdk.GLContext` before drawing
    /// with either API.
    extern fn gtk_gl_area_set_use_es(p_area: *GLArea, p_use_es: c_int) void;
    pub const setUseEs = gtk_gl_area_set_use_es;

    extern fn gtk_gl_area_get_type() usize;
    pub const getGObjectType = gtk_gl_area_get_type;

    extern fn g_object_ref(p_self: *gtk.GLArea) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.GLArea) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *GLArea, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.Gesture` is the base object for gesture recognition, although this
/// object is quite generalized to serve as a base for multi-touch gestures,
/// it is suitable to implement single-touch and pointer-based gestures (using
/// the special `NULL` `gdk.EventSequence` value for these).
///
/// The number of touches that a `gtk.Gesture` need to be recognized is controlled
/// by the `gtk.Gesture.properties.n`-points property, if a gesture is keeping track of less
/// or more than that number of sequences, it won't check wether the gesture
/// is recognized.
///
/// As soon as the gesture has the expected number of touches, the gesture will
/// run the `gtk.Gesture.signals.check` signal regularly on input events until the gesture
/// is recognized, the criteria to consider a gesture as "recognized" is left to
/// `gtk.Gesture` subclasses.
///
/// A recognized gesture will then emit the following signals:
/// - `gtk.Gesture.signals.begin` when the gesture is recognized.
/// - A number of `gtk.Gesture.signals.update`, whenever an input event is processed.
/// - `gtk.Gesture.signals.end` when the gesture is no longer recognized.
///
/// ## Event propagation
///
/// In order to receive events, a gesture needs to either set a propagation phase
/// through `gtk.EventController.setPropagationPhase`, or feed those manually
/// through `gtk.EventController.handleEvent`.
///
/// In the capture phase, events are propagated from the toplevel down to the
/// target widget, and gestures that are attached to containers above the widget
/// get a chance to interact with the event before it reaches the target.
///
/// After the capture phase, GTK+ emits the traditional `gtk.Widget.signals.button`-press-event,
/// `gtk.Widget.signals.button`-release-event, `gtk.Widget.signals.touch`-event, etc signals. Gestures
/// with the `GTK_PHASE_TARGET` phase are fed events from the default `gtk.Widget.signals.event`
/// handlers.
///
/// In the bubble phase, events are propagated up from the target widget to the
/// toplevel, and gestures that are attached to containers above the widget get
/// a chance to interact with events that have not been handled yet.
///
/// ## States of a sequence
///
/// Whenever input interaction happens, a single event may trigger a cascade of
/// `GtkGestures`, both across the parents of the widget receiving the event and
/// in parallel within an individual widget. It is a responsibility of the
/// widgets using those gestures to set the state of touch sequences accordingly
/// in order to enable cooperation of gestures around the `GdkEventSequences`
/// triggering those.
///
/// Within a widget, gestures can be grouped through `gtk.Gesture.group`,
/// grouped gestures synchronize the state of sequences, so calling
/// `gtk.Gesture.setSequenceState` on one will effectively propagate
/// the state throughout the group.
///
/// By default, all sequences start out in the `GTK_EVENT_SEQUENCE_NONE` state,
/// sequences in this state trigger the gesture event handler, but event
/// propagation will continue unstopped by gestures.
///
/// If a sequence enters into the `GTK_EVENT_SEQUENCE_DENIED` state, the gesture
/// group will effectively ignore the sequence, letting events go unstopped
/// through the gesture, but the "slot" will still remain occupied while
/// the touch is active.
///
/// If a sequence enters in the `GTK_EVENT_SEQUENCE_CLAIMED` state, the gesture
/// group will grab all interaction on the sequence, by:
/// - Setting the same sequence to `GTK_EVENT_SEQUENCE_DENIED` on every other gesture
///   group within the widget, and every gesture on parent widgets in the propagation
///   chain.
/// - calling `gtk.Gesture.signals.cancel` on every gesture in widgets underneath in the
///   propagation chain.
/// - Stopping event propagation after the gesture group handles the event.
///
/// Note: if a sequence is set early to `GTK_EVENT_SEQUENCE_CLAIMED` on
/// `GDK_TOUCH_BEGIN`/`GDK_BUTTON_PRESS` (so those events are captured before
/// reaching the event widget, this implies `GTK_PHASE_CAPTURE`), one similar
/// event will emulated if the sequence changes to `GTK_EVENT_SEQUENCE_DENIED`.
/// This way event coherence is preserved before event propagation is unstopped
/// again.
///
/// Sequence states can't be changed freely, see `gtk.Gesture.setSequenceState`
/// to know about the possible lifetimes of a `gdk.EventSequence`.
///
/// ## Touchpad gestures
///
/// On the platforms that support it, `gtk.Gesture` will handle transparently
/// touchpad gesture events. The only precautions users of `gtk.Gesture` should do
/// to enable this support are:
/// - Enabling `GDK_TOUCHPAD_GESTURE_MASK` on their `GdkWindows`
/// - If the gesture has `GTK_PHASE_NONE`, ensuring events of type
///   `GDK_TOUCHPAD_SWIPE` and `GDK_TOUCHPAD_PINCH` are handled by the `gtk.Gesture`
pub const Gesture = opaque {
    pub const Parent = gtk.EventController;
    pub const Implements = [_]type{};
    pub const Class = gtk.GestureClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The number of touch points that trigger recognition on this gesture,
        pub const n_points = struct {
            pub const name = "n-points";

            pub const Type = c_uint;
        };

        /// If non-`NULL`, the gesture will only listen for events that happen on
        /// this `gdk.Window`, or a child of it.
        pub const window = struct {
            pub const name = "window";

            pub const Type = ?*gdk.Window;
        };
    };

    pub const signals = struct {
        /// This signal is emitted when the gesture is recognized. This means the
        /// number of touch sequences matches `gtk.Gesture.properties.n`-points, and the `gtk.Gesture.signals.check`
        /// handler(s) returned `TRUE`.
        ///
        /// Note: These conditions may also happen when an extra touch (eg. a third touch
        /// on a 2-touches gesture) is lifted, in that situation `sequence` won't pertain
        /// to the current set of active touches, so don't rely on this being true.
        pub const begin = struct {
            pub const name = "begin";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_sequence: ?*gdk.EventSequence, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Gesture, p_instance))),
                    gobject.signalLookup("begin", Gesture.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted whenever a sequence is cancelled. This usually
        /// happens on active touches when `gtk.EventController.reset` is called
        /// on `gesture` (manually, due to grabs...), or the individual `sequence`
        /// was claimed by parent widgets' controllers (see `gtk.Gesture.setSequenceState`).
        ///
        /// `gesture` must forget everything about `sequence` as a reaction to this signal.
        pub const cancel = struct {
            pub const name = "cancel";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_sequence: ?*gdk.EventSequence, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Gesture, p_instance))),
                    gobject.signalLookup("cancel", Gesture.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when `gesture` either stopped recognizing the event
        /// sequences as something to be handled (the `gtk.Gesture.signals.check` handler returned
        /// `FALSE`), or the number of touch sequences became higher or lower than
        /// `gtk.Gesture.properties.n`-points.
        ///
        /// Note: `sequence` might not pertain to the group of sequences that were
        /// previously triggering recognition on `gesture` (ie. a just pressed touch
        /// sequence that exceeds `gtk.Gesture.properties.n`-points). This situation may be detected
        /// by checking through `gtk.Gesture.handlesSequence`.
        pub const end = struct {
            pub const name = "end";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_sequence: ?*gdk.EventSequence, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Gesture, p_instance))),
                    gobject.signalLookup("end", Gesture.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted whenever a sequence state changes. See
        /// `gtk.Gesture.setSequenceState` to know more about the expectable
        /// sequence lifetimes.
        pub const sequence_state_changed = struct {
            pub const name = "sequence-state-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_sequence: ?*gdk.EventSequence, p_state: gtk.EventSequenceState, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Gesture, p_instance))),
                    gobject.signalLookup("sequence-state-changed", Gesture.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted whenever an event is handled while the gesture is
        /// recognized. `sequence` is guaranteed to pertain to the set of active touches.
        pub const update = struct {
            pub const name = "update";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_sequence: ?*gdk.EventSequence, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Gesture, p_instance))),
                    gobject.signalLookup("update", Gesture.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// If there are touch sequences being currently handled by `gesture`,
    /// this function returns `TRUE` and fills in `rect` with the bounding
    /// box containing all active touches. Otherwise, `FALSE` will be
    /// returned.
    ///
    /// Note: This function will yield unexpected results on touchpad
    /// gestures. Since there is no correlation between physical and
    /// pixel distances, these will look as if constrained in an
    /// infinitely small area, `rect` width and height will thus be 0
    /// regardless of the number of touchpoints.
    extern fn gtk_gesture_get_bounding_box(p_gesture: *Gesture, p_rect: *gdk.Rectangle) c_int;
    pub const getBoundingBox = gtk_gesture_get_bounding_box;

    /// If there are touch sequences being currently handled by `gesture`,
    /// this function returns `TRUE` and fills in `x` and `y` with the center
    /// of the bounding box containing all active touches. Otherwise, `FALSE`
    /// will be returned.
    extern fn gtk_gesture_get_bounding_box_center(p_gesture: *Gesture, p_x: *f64, p_y: *f64) c_int;
    pub const getBoundingBoxCenter = gtk_gesture_get_bounding_box_center;

    /// Returns the master `gdk.Device` that is currently operating
    /// on `gesture`, or `NULL` if the gesture is not being interacted.
    extern fn gtk_gesture_get_device(p_gesture: *Gesture) ?*gdk.Device;
    pub const getDevice = gtk_gesture_get_device;

    /// Returns all gestures in the group of `gesture`
    extern fn gtk_gesture_get_group(p_gesture: *Gesture) *glib.List;
    pub const getGroup = gtk_gesture_get_group;

    /// Returns the last event that was processed for `sequence`.
    ///
    /// Note that the returned pointer is only valid as long as the `sequence`
    /// is still interpreted by the `gesture`. If in doubt, you should make
    /// a copy of the event.
    extern fn gtk_gesture_get_last_event(p_gesture: *Gesture, p_sequence: ?*gdk.EventSequence) ?*const gdk.Event;
    pub const getLastEvent = gtk_gesture_get_last_event;

    /// Returns the `gdk.EventSequence` that was last updated on `gesture`.
    extern fn gtk_gesture_get_last_updated_sequence(p_gesture: *Gesture) ?*gdk.EventSequence;
    pub const getLastUpdatedSequence = gtk_gesture_get_last_updated_sequence;

    /// If `sequence` is currently being interpreted by `gesture`, this
    /// function returns `TRUE` and fills in `x` and `y` with the last coordinates
    /// stored for that event sequence. The coordinates are always relative to the
    /// widget allocation.
    extern fn gtk_gesture_get_point(p_gesture: *Gesture, p_sequence: ?*gdk.EventSequence, p_x: ?*f64, p_y: ?*f64) c_int;
    pub const getPoint = gtk_gesture_get_point;

    /// Returns the `sequence` state, as seen by `gesture`.
    extern fn gtk_gesture_get_sequence_state(p_gesture: *Gesture, p_sequence: *gdk.EventSequence) gtk.EventSequenceState;
    pub const getSequenceState = gtk_gesture_get_sequence_state;

    /// Returns the list of `GdkEventSequences` currently being interpreted
    /// by `gesture`.
    extern fn gtk_gesture_get_sequences(p_gesture: *Gesture) *glib.List;
    pub const getSequences = gtk_gesture_get_sequences;

    /// Returns the user-defined window that receives the events
    /// handled by `gesture`. See `gtk.Gesture.setWindow` for more
    /// information.
    extern fn gtk_gesture_get_window(p_gesture: *Gesture) ?*gdk.Window;
    pub const getWindow = gtk_gesture_get_window;

    /// Adds `gesture` to the same group than `group_gesture`. Gestures
    /// are by default isolated in their own groups.
    ///
    /// When gestures are grouped, the state of `GdkEventSequences`
    /// is kept in sync for all of those, so calling `gtk.Gesture.setSequenceState`,
    /// on one will transfer the same value to the others.
    ///
    /// Groups also perform an "implicit grabbing" of sequences, if a
    /// `gdk.EventSequence` state is set to `GTK_EVENT_SEQUENCE_CLAIMED` on one group,
    /// every other gesture group attached to the same `gtk.Widget` will switch the
    /// state for that sequence to `GTK_EVENT_SEQUENCE_DENIED`.
    extern fn gtk_gesture_group(p_group_gesture: *Gesture, p_gesture: *gtk.Gesture) void;
    pub const group = gtk_gesture_group;

    /// Returns `TRUE` if `gesture` is currently handling events corresponding to
    /// `sequence`.
    extern fn gtk_gesture_handles_sequence(p_gesture: *Gesture, p_sequence: ?*gdk.EventSequence) c_int;
    pub const handlesSequence = gtk_gesture_handles_sequence;

    /// Returns `TRUE` if the gesture is currently active.
    /// A gesture is active meanwhile there are touch sequences
    /// interacting with it.
    extern fn gtk_gesture_is_active(p_gesture: *Gesture) c_int;
    pub const isActive = gtk_gesture_is_active;

    /// Returns `TRUE` if both gestures pertain to the same group.
    extern fn gtk_gesture_is_grouped_with(p_gesture: *Gesture, p_other: *gtk.Gesture) c_int;
    pub const isGroupedWith = gtk_gesture_is_grouped_with;

    /// Returns `TRUE` if the gesture is currently recognized.
    /// A gesture is recognized if there are as many interacting
    /// touch sequences as required by `gesture`, and `gtk.Gesture.signals.check`
    /// returned `TRUE` for the sequences being currently interpreted.
    extern fn gtk_gesture_is_recognized(p_gesture: *Gesture) c_int;
    pub const isRecognized = gtk_gesture_is_recognized;

    /// Sets the state of `sequence` in `gesture`. Sequences start
    /// in state `GTK_EVENT_SEQUENCE_NONE`, and whenever they change
    /// state, they can never go back to that state. Likewise,
    /// sequences in state `GTK_EVENT_SEQUENCE_DENIED` cannot turn
    /// back to a not denied state. With these rules, the lifetime
    /// of an event sequence is constrained to the next four:
    ///
    /// * None
    /// * None → Denied
    /// * None → Claimed
    /// * None → Claimed → Denied
    ///
    /// Note: Due to event handling ordering, it may be unsafe to
    /// set the state on another gesture within a `gtk.Gesture.signals.begin`
    /// signal handler, as the callback might be executed before
    /// the other gesture knows about the sequence. A safe way to
    /// perform this could be:
    ///
    /// ```
    /// static void
    /// first_gesture_begin_cb (GtkGesture       *first_gesture,
    ///                         GdkEventSequence *sequence,
    ///                         gpointer          user_data)
    /// {
    ///   gtk_gesture_set_sequence_state (first_gesture, sequence, GTK_EVENT_SEQUENCE_CLAIMED);
    ///   gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
    /// }
    ///
    /// static void
    /// second_gesture_begin_cb (GtkGesture       *second_gesture,
    ///                          GdkEventSequence *sequence,
    ///                          gpointer          user_data)
    /// {
    ///   if (gtk_gesture_get_sequence_state (first_gesture, sequence) == GTK_EVENT_SEQUENCE_CLAIMED)
    ///     gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
    /// }
    /// ```
    ///
    /// If both gestures are in the same group, just set the state on
    /// the gesture emitting the event, the sequence will be already
    /// be initialized to the group's global state when the second
    /// gesture processes the event.
    extern fn gtk_gesture_set_sequence_state(p_gesture: *Gesture, p_sequence: *gdk.EventSequence, p_state: gtk.EventSequenceState) c_int;
    pub const setSequenceState = gtk_gesture_set_sequence_state;

    /// Sets the state of all sequences that `gesture` is currently
    /// interacting with. See `gtk.Gesture.setSequenceState`
    /// for more details on sequence states.
    extern fn gtk_gesture_set_state(p_gesture: *Gesture, p_state: gtk.EventSequenceState) c_int;
    pub const setState = gtk_gesture_set_state;

    /// Sets a specific window to receive events about, so `gesture`
    /// will effectively handle only events targeting `window`, or
    /// a child of it. `window` must pertain to `gtk.EventController.getWidget`.
    extern fn gtk_gesture_set_window(p_gesture: *Gesture, p_window: ?*gdk.Window) void;
    pub const setWindow = gtk_gesture_set_window;

    /// Separates `gesture` into an isolated group.
    extern fn gtk_gesture_ungroup(p_gesture: *Gesture) void;
    pub const ungroup = gtk_gesture_ungroup;

    extern fn gtk_gesture_get_type() usize;
    pub const getGObjectType = gtk_gesture_get_type;

    extern fn g_object_ref(p_self: *gtk.Gesture) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Gesture) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Gesture, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.GestureDrag` is a `gtk.Gesture` implementation that recognizes drag
/// operations. The drag operation itself can be tracked throught the
/// `gtk.GestureDrag.signals.drag`-begin, `gtk.GestureDrag.signals.drag`-update and
/// `gtk.GestureDrag.signals.drag`-end signals, or the relevant coordinates be
/// extracted through `gtk.GestureDrag.getOffset` and
/// `gtk.GestureDrag.getStartPoint`.
pub const GestureDrag = opaque {
    pub const Parent = gtk.GestureSingle;
    pub const Implements = [_]type{};
    pub const Class = gtk.GestureDragClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {
        /// This signal is emitted whenever dragging starts.
        pub const drag_begin = struct {
            pub const name = "drag-begin";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_start_x: f64, p_start_y: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GestureDrag, p_instance))),
                    gobject.signalLookup("drag-begin", GestureDrag.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted whenever the dragging is finished.
        pub const drag_end = struct {
            pub const name = "drag-end";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_offset_x: f64, p_offset_y: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GestureDrag, p_instance))),
                    gobject.signalLookup("drag-end", GestureDrag.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted whenever the dragging point moves.
        pub const drag_update = struct {
            pub const name = "drag-update";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_offset_x: f64, p_offset_y: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GestureDrag, p_instance))),
                    gobject.signalLookup("drag-update", GestureDrag.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Returns a newly created `gtk.Gesture` that recognizes drags.
    extern fn gtk_gesture_drag_new(p_widget: *gtk.Widget) *gtk.GestureDrag;
    pub const new = gtk_gesture_drag_new;

    /// If the `gesture` is active, this function returns `TRUE` and
    /// fills in `x` and `y` with the coordinates of the current point,
    /// as an offset to the starting drag point.
    extern fn gtk_gesture_drag_get_offset(p_gesture: *GestureDrag, p_x: ?*f64, p_y: ?*f64) c_int;
    pub const getOffset = gtk_gesture_drag_get_offset;

    /// If the `gesture` is active, this function returns `TRUE`
    /// and fills in `x` and `y` with the drag start coordinates,
    /// in window-relative coordinates.
    extern fn gtk_gesture_drag_get_start_point(p_gesture: *GestureDrag, p_x: ?*f64, p_y: ?*f64) c_int;
    pub const getStartPoint = gtk_gesture_drag_get_start_point;

    extern fn gtk_gesture_drag_get_type() usize;
    pub const getGObjectType = gtk_gesture_drag_get_type;

    extern fn g_object_ref(p_self: *gtk.GestureDrag) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.GestureDrag) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *GestureDrag, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.GestureLongPress` is a `gtk.Gesture` implementation able to recognize
/// long presses, triggering the `gtk.GestureLongPress.signals.pressed` after the
/// timeout is exceeded.
///
/// If the touchpoint is lifted before the timeout passes, or if it drifts
/// too far of the initial press point, the `gtk.GestureLongPress.signals.cancelled`
/// signal will be emitted.
pub const GestureLongPress = opaque {
    pub const Parent = gtk.GestureSingle;
    pub const Implements = [_]type{};
    pub const Class = gtk.GestureLongPressClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const delay_factor = struct {
            pub const name = "delay-factor";

            pub const Type = f64;
        };
    };

    pub const signals = struct {
        /// This signal is emitted whenever a press moved too far, or was released
        /// before `gtk.GestureLongPress.signals.pressed` happened.
        pub const cancelled = struct {
            pub const name = "cancelled";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GestureLongPress, p_instance))),
                    gobject.signalLookup("cancelled", GestureLongPress.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted whenever a press goes unmoved/unreleased longer than
        /// what the GTK+ defaults tell.
        pub const pressed = struct {
            pub const name = "pressed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_x: f64, p_y: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GestureLongPress, p_instance))),
                    gobject.signalLookup("pressed", GestureLongPress.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Returns a newly created `gtk.Gesture` that recognizes long presses.
    extern fn gtk_gesture_long_press_new(p_widget: *gtk.Widget) *gtk.GestureLongPress;
    pub const new = gtk_gesture_long_press_new;

    extern fn gtk_gesture_long_press_get_type() usize;
    pub const getGObjectType = gtk_gesture_long_press_get_type;

    extern fn g_object_ref(p_self: *gtk.GestureLongPress) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.GestureLongPress) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *GestureLongPress, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.GestureMultiPress` is a `gtk.Gesture` implementation able to recognize
/// multiple clicks on a nearby zone, which can be listened for through the
/// `gtk.GestureMultiPress.signals.pressed` signal. Whenever time or distance between
/// clicks exceed the GTK+ defaults, `gtk.GestureMultiPress.signals.stopped` is emitted,
/// and the click counter is reset.
///
/// Callers may also restrict the area that is considered valid for a >1
/// touch/button press through `gtk.GestureMultiPress.setArea`, so any
/// click happening outside that area is considered to be a first click of
/// its own.
pub const GestureMultiPress = opaque {
    pub const Parent = gtk.GestureSingle;
    pub const Implements = [_]type{};
    pub const Class = gtk.GestureMultiPressClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {
        /// This signal is emitted whenever a button or touch press happens.
        pub const pressed = struct {
            pub const name = "pressed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_n_press: c_int, p_x: f64, p_y: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GestureMultiPress, p_instance))),
                    gobject.signalLookup("pressed", GestureMultiPress.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when a button or touch is released. `n_press`
        /// will report the number of press that is paired to this event, note
        /// that `gtk.GestureMultiPress.signals.stopped` may have been emitted between the
        /// press and its release, `n_press` will only start over at the next press.
        pub const released = struct {
            pub const name = "released";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_n_press: c_int, p_x: f64, p_y: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GestureMultiPress, p_instance))),
                    gobject.signalLookup("released", GestureMultiPress.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted whenever any time/distance threshold has
        /// been exceeded.
        pub const stopped = struct {
            pub const name = "stopped";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GestureMultiPress, p_instance))),
                    gobject.signalLookup("stopped", GestureMultiPress.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Returns a newly created `gtk.Gesture` that recognizes single and multiple
    /// presses.
    extern fn gtk_gesture_multi_press_new(p_widget: *gtk.Widget) *gtk.GestureMultiPress;
    pub const new = gtk_gesture_multi_press_new;

    /// If an area was set through `gtk.GestureMultiPress.setArea`,
    /// this function will return `TRUE` and fill in `rect` with the
    /// press area. See `gtk.GestureMultiPress.setArea` for more
    /// details on what the press area represents.
    extern fn gtk_gesture_multi_press_get_area(p_gesture: *GestureMultiPress, p_rect: *gdk.Rectangle) c_int;
    pub const getArea = gtk_gesture_multi_press_get_area;

    /// If `rect` is non-`NULL`, the press area will be checked to be
    /// confined within the rectangle, otherwise the button count
    /// will be reset so the press is seen as being the first one.
    /// If `rect` is `NULL`, the area will be reset to an unrestricted
    /// state.
    ///
    /// Note: The rectangle is only used to determine whether any
    /// non-first click falls within the expected area. This is not
    /// akin to an input shape.
    extern fn gtk_gesture_multi_press_set_area(p_gesture: *GestureMultiPress, p_rect: ?*const gdk.Rectangle) void;
    pub const setArea = gtk_gesture_multi_press_set_area;

    extern fn gtk_gesture_multi_press_get_type() usize;
    pub const getGObjectType = gtk_gesture_multi_press_get_type;

    extern fn g_object_ref(p_self: *gtk.GestureMultiPress) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.GestureMultiPress) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *GestureMultiPress, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.GesturePan` is a `gtk.Gesture` implementation able to recognize
/// pan gestures, those are drags that are locked to happen along one
/// axis. The axis that a `gtk.GesturePan` handles is defined at
/// construct time, and can be changed through
/// `gtk.GesturePan.setOrientation`.
///
/// When the gesture starts to be recognized, `gtk.GesturePan` will
/// attempt to determine as early as possible whether the sequence
/// is moving in the expected direction, and denying the sequence if
/// this does not happen.
///
/// Once a panning gesture along the expected axis is recognized,
/// the `gtk.GesturePan.signals.pan` signal will be emitted as input events
/// are received, containing the offset in the given axis.
pub const GesturePan = opaque {
    pub const Parent = gtk.GestureDrag;
    pub const Implements = [_]type{};
    pub const Class = gtk.GesturePanClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The expected orientation of pan gestures.
        pub const orientation = struct {
            pub const name = "orientation";

            pub const Type = gtk.Orientation;
        };
    };

    pub const signals = struct {
        /// This signal is emitted once a panning gesture along the
        /// expected axis is detected.
        pub const pan = struct {
            pub const name = "pan";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_direction: gtk.PanDirection, p_offset: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GesturePan, p_instance))),
                    gobject.signalLookup("pan", GesturePan.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Returns a newly created `gtk.Gesture` that recognizes pan gestures.
    extern fn gtk_gesture_pan_new(p_widget: *gtk.Widget, p_orientation: gtk.Orientation) *gtk.GesturePan;
    pub const new = gtk_gesture_pan_new;

    /// Returns the orientation of the pan gestures that this `gesture` expects.
    extern fn gtk_gesture_pan_get_orientation(p_gesture: *GesturePan) gtk.Orientation;
    pub const getOrientation = gtk_gesture_pan_get_orientation;

    /// Sets the orientation to be expected on pan gestures.
    extern fn gtk_gesture_pan_set_orientation(p_gesture: *GesturePan, p_orientation: gtk.Orientation) void;
    pub const setOrientation = gtk_gesture_pan_set_orientation;

    extern fn gtk_gesture_pan_get_type() usize;
    pub const getGObjectType = gtk_gesture_pan_get_type;

    extern fn g_object_ref(p_self: *gtk.GesturePan) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.GesturePan) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *GesturePan, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.GestureRotate` is a `gtk.Gesture` implementation able to recognize
/// 2-finger rotations, whenever the angle between both handled sequences
/// changes, the `gtk.GestureRotate.signals.angle`-changed signal is emitted.
pub const GestureRotate = opaque {
    pub const Parent = gtk.Gesture;
    pub const Implements = [_]type{};
    pub const Class = gtk.GestureRotateClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {
        /// This signal is emitted when the angle between both tracked points
        /// changes.
        pub const angle_changed = struct {
            pub const name = "angle-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_angle: f64, p_angle_delta: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GestureRotate, p_instance))),
                    gobject.signalLookup("angle-changed", GestureRotate.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Returns a newly created `gtk.Gesture` that recognizes 2-touch
    /// rotation gestures.
    extern fn gtk_gesture_rotate_new(p_widget: *gtk.Widget) *gtk.GestureRotate;
    pub const new = gtk_gesture_rotate_new;

    /// If `gesture` is active, this function returns the angle difference
    /// in radians since the gesture was first recognized. If `gesture` is
    /// not active, 0 is returned.
    extern fn gtk_gesture_rotate_get_angle_delta(p_gesture: *GestureRotate) f64;
    pub const getAngleDelta = gtk_gesture_rotate_get_angle_delta;

    extern fn gtk_gesture_rotate_get_type() usize;
    pub const getGObjectType = gtk_gesture_rotate_get_type;

    extern fn g_object_ref(p_self: *gtk.GestureRotate) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.GestureRotate) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *GestureRotate, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.GestureSingle` is a subclass of `gtk.Gesture`, optimized (although
/// not restricted) for dealing with mouse and single-touch gestures. Under
/// interaction, these gestures stick to the first interacting sequence, which
/// is accessible through `gtk.GestureSingle.getCurrentSequence` while the
/// gesture is being interacted with.
///
/// By default gestures react to both `GDK_BUTTON_PRIMARY` and touch
/// events, `gtk.GestureSingle.setTouchOnly` can be used to change the
/// touch behavior. Callers may also specify a different mouse button number
/// to interact with through `gtk.GestureSingle.setButton`, or react to any
/// mouse button by setting 0. While the gesture is active, the button being
/// currently pressed can be known through `gtk.GestureSingle.getCurrentButton`.
pub const GestureSingle = opaque {
    pub const Parent = gtk.Gesture;
    pub const Implements = [_]type{};
    pub const Class = gtk.GestureSingleClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Mouse button number to listen to, or 0 to listen for any button.
        pub const button = struct {
            pub const name = "button";

            pub const Type = c_uint;
        };

        /// Whether the gesture is exclusive. Exclusive gestures only listen to pointer
        /// and pointer emulated events.
        pub const exclusive = struct {
            pub const name = "exclusive";

            pub const Type = c_int;
        };

        /// Whether the gesture handles only touch events.
        pub const touch_only = struct {
            pub const name = "touch-only";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Returns the button number `gesture` listens for, or 0 if `gesture`
    /// reacts to any button press.
    extern fn gtk_gesture_single_get_button(p_gesture: *GestureSingle) c_uint;
    pub const getButton = gtk_gesture_single_get_button;

    /// Returns the button number currently interacting with `gesture`, or 0 if there
    /// is none.
    extern fn gtk_gesture_single_get_current_button(p_gesture: *GestureSingle) c_uint;
    pub const getCurrentButton = gtk_gesture_single_get_current_button;

    /// Returns the event sequence currently interacting with `gesture`.
    /// This is only meaningful if `gtk.Gesture.isActive` returns `TRUE`.
    extern fn gtk_gesture_single_get_current_sequence(p_gesture: *GestureSingle) ?*gdk.EventSequence;
    pub const getCurrentSequence = gtk_gesture_single_get_current_sequence;

    /// Gets whether a gesture is exclusive. For more information, see
    /// `gtk.GestureSingle.setExclusive`.
    extern fn gtk_gesture_single_get_exclusive(p_gesture: *GestureSingle) c_int;
    pub const getExclusive = gtk_gesture_single_get_exclusive;

    /// Returns `TRUE` if the gesture is only triggered by touch events.
    extern fn gtk_gesture_single_get_touch_only(p_gesture: *GestureSingle) c_int;
    pub const getTouchOnly = gtk_gesture_single_get_touch_only;

    /// Sets the button number `gesture` listens to. If non-0, every
    /// button press from a different button number will be ignored.
    /// Touch events implicitly match with button 1.
    extern fn gtk_gesture_single_set_button(p_gesture: *GestureSingle, p_button: c_uint) void;
    pub const setButton = gtk_gesture_single_set_button;

    /// Sets whether `gesture` is exclusive. An exclusive gesture will
    /// only handle pointer and "pointer emulated" touch events, so at
    /// any given time, there is only one sequence able to interact with
    /// those.
    extern fn gtk_gesture_single_set_exclusive(p_gesture: *GestureSingle, p_exclusive: c_int) void;
    pub const setExclusive = gtk_gesture_single_set_exclusive;

    /// If `touch_only` is `TRUE`, `gesture` will only handle events of type
    /// `GDK_TOUCH_BEGIN`, `GDK_TOUCH_UPDATE` or `GDK_TOUCH_END`. If `FALSE`,
    /// mouse events will be handled too.
    extern fn gtk_gesture_single_set_touch_only(p_gesture: *GestureSingle, p_touch_only: c_int) void;
    pub const setTouchOnly = gtk_gesture_single_set_touch_only;

    extern fn gtk_gesture_single_get_type() usize;
    pub const getGObjectType = gtk_gesture_single_get_type;

    extern fn g_object_ref(p_self: *gtk.GestureSingle) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.GestureSingle) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *GestureSingle, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.GestureStylus` is a `gtk.Gesture` implementation specific to stylus
/// input. The provided signals just provide the basic information
pub const GestureStylus = opaque {
    pub const Parent = gtk.GestureSingle;
    pub const Implements = [_]type{};
    pub const Class = gtk.GestureStylusClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {
        pub const down = struct {
            pub const name = "down";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: f64, p_p0: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GestureStylus, p_instance))),
                    gobject.signalLookup("down", GestureStylus.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const motion = struct {
            pub const name = "motion";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: f64, p_p0: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GestureStylus, p_instance))),
                    gobject.signalLookup("motion", GestureStylus.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const proximity = struct {
            pub const name = "proximity";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: f64, p_p0: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GestureStylus, p_instance))),
                    gobject.signalLookup("proximity", GestureStylus.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const up = struct {
            pub const name = "up";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: f64, p_p0: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GestureStylus, p_instance))),
                    gobject.signalLookup("up", GestureStylus.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.GestureStylus`.
    extern fn gtk_gesture_stylus_new(p_widget: *gtk.Widget) *gtk.GestureStylus;
    pub const new = gtk_gesture_stylus_new;

    /// Returns the current values for the requested `axes`. This function
    /// must be called from either the `gtk.GestureStylus.properties.down`,
    /// `gtk.GestureStylus.properties.motion`, `gtk.GestureStylus.properties.up` or `gtk.GestureStylus.properties.proximity`
    /// signals.
    extern fn gtk_gesture_stylus_get_axes(p_gesture: *GestureStylus, p_axes: [*]gdk.AxisUse, p_values: *[*]f64) c_int;
    pub const getAxes = gtk_gesture_stylus_get_axes;

    /// Returns the current value for the requested `axis`. This function
    /// must be called from either the `gtk.GestureStylus.properties.down`,
    /// `gtk.GestureStylus.properties.motion`, `gtk.GestureStylus.properties.up` or `gtk.GestureStylus.properties.proximity`
    /// signals.
    extern fn gtk_gesture_stylus_get_axis(p_gesture: *GestureStylus, p_axis: gdk.AxisUse, p_value: *f64) c_int;
    pub const getAxis = gtk_gesture_stylus_get_axis;

    /// Returns the `gdk.DeviceTool` currently driving input through this gesture.
    /// This function must be called from either the `gtk.GestureStylus.signals.down`,
    /// `gtk.GestureStylus.signals.motion`, `gtk.GestureStylus.signals.up` or `gtk.GestureStylus.signals.proximity`
    /// signal handlers.
    extern fn gtk_gesture_stylus_get_device_tool(p_gesture: *GestureStylus) ?*gdk.DeviceTool;
    pub const getDeviceTool = gtk_gesture_stylus_get_device_tool;

    extern fn gtk_gesture_stylus_get_type() usize;
    pub const getGObjectType = gtk_gesture_stylus_get_type;

    extern fn g_object_ref(p_self: *gtk.GestureStylus) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.GestureStylus) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *GestureStylus, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.GestureSwipe` is a `gtk.Gesture` implementation able to recognize
/// swipes, after a press/move/.../move/release sequence happens, the
/// `gtk.GestureSwipe.signals.swipe` signal will be emitted, providing the velocity
/// and directionality of the sequence at the time it was lifted.
///
/// If the velocity is desired in intermediate points,
/// `gtk.GestureSwipe.getVelocity` can be called on eg. a
/// `gtk.Gesture.signals.update` handler.
///
/// All velocities are reported in pixels/sec units.
pub const GestureSwipe = opaque {
    pub const Parent = gtk.GestureSingle;
    pub const Implements = [_]type{};
    pub const Class = gtk.GestureSwipeClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {
        /// This signal is emitted when the recognized gesture is finished, velocity
        /// and direction are a product of previously recorded events.
        pub const swipe = struct {
            pub const name = "swipe";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_velocity_x: f64, p_velocity_y: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GestureSwipe, p_instance))),
                    gobject.signalLookup("swipe", GestureSwipe.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Returns a newly created `gtk.Gesture` that recognizes swipes.
    extern fn gtk_gesture_swipe_new(p_widget: *gtk.Widget) *gtk.GestureSwipe;
    pub const new = gtk_gesture_swipe_new;

    /// If the gesture is recognized, this function returns `TRUE` and fill in
    /// `velocity_x` and `velocity_y` with the recorded velocity, as per the
    /// last event(s) processed.
    extern fn gtk_gesture_swipe_get_velocity(p_gesture: *GestureSwipe, p_velocity_x: *f64, p_velocity_y: *f64) c_int;
    pub const getVelocity = gtk_gesture_swipe_get_velocity;

    extern fn gtk_gesture_swipe_get_type() usize;
    pub const getGObjectType = gtk_gesture_swipe_get_type;

    extern fn g_object_ref(p_self: *gtk.GestureSwipe) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.GestureSwipe) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *GestureSwipe, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.GestureZoom` is a `gtk.Gesture` implementation able to recognize
/// pinch/zoom gestures, whenever the distance between both tracked
/// sequences changes, the `gtk.GestureZoom.signals.scale`-changed signal is
/// emitted to report the scale factor.
pub const GestureZoom = opaque {
    pub const Parent = gtk.Gesture;
    pub const Implements = [_]type{};
    pub const Class = gtk.GestureZoomClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {
        /// This signal is emitted whenever the distance between both tracked
        /// sequences changes.
        pub const scale_changed = struct {
            pub const name = "scale-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_scale: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(GestureZoom, p_instance))),
                    gobject.signalLookup("scale-changed", GestureZoom.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Returns a newly created `gtk.Gesture` that recognizes zoom
    /// in/out gestures (usually known as pinch/zoom).
    extern fn gtk_gesture_zoom_new(p_widget: *gtk.Widget) *gtk.GestureZoom;
    pub const new = gtk_gesture_zoom_new;

    /// If `gesture` is active, this function returns the zooming difference
    /// since the gesture was recognized (hence the starting point is
    /// considered 1:1). If `gesture` is not active, 1 is returned.
    extern fn gtk_gesture_zoom_get_scale_delta(p_gesture: *GestureZoom) f64;
    pub const getScaleDelta = gtk_gesture_zoom_get_scale_delta;

    extern fn gtk_gesture_zoom_get_type() usize;
    pub const getGObjectType = gtk_gesture_zoom_get_type;

    extern fn g_object_ref(p_self: *gtk.GestureZoom) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.GestureZoom) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *GestureZoom, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkGrid is a container which arranges its child widgets in
/// rows and columns, with arbitrary positions and horizontal/vertical spans.
///
/// Children are added using `gtk.Grid.attach`. They can span multiple
/// rows or columns. It is also possible to add a child next to an
/// existing child, using `gtk.Grid.attachNextTo`. The behaviour of
/// GtkGrid when several children occupy the same grid cell is undefined.
///
/// GtkGrid can be used like a `gtk.Box` by just using `gtk.Container.add`,
/// which will place children next to each other in the direction determined
/// by the `gtk.Orientable.properties.orientation` property. However, if all you want is a
/// single row or column, then `gtk.Box` is the preferred widget.
///
/// # CSS nodes
///
/// GtkGrid uses a single CSS node with name grid.
pub const Grid = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.GridClass;
    f_container: gtk.Container,
    f_priv: ?*gtk.GridPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const baseline_row = struct {
            pub const name = "baseline-row";

            pub const Type = c_int;
        };

        pub const column_homogeneous = struct {
            pub const name = "column-homogeneous";

            pub const Type = c_int;
        };

        pub const column_spacing = struct {
            pub const name = "column-spacing";

            pub const Type = c_int;
        };

        pub const row_homogeneous = struct {
            pub const name = "row-homogeneous";

            pub const Type = c_int;
        };

        pub const row_spacing = struct {
            pub const name = "row-spacing";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new grid widget.
    extern fn gtk_grid_new() *gtk.Grid;
    pub const new = gtk_grid_new;

    /// Adds a widget to the grid.
    ///
    /// The position of `child` is determined by `left` and `top`. The
    /// number of “cells” that `child` will occupy is determined by
    /// `width` and `height`.
    extern fn gtk_grid_attach(p_grid: *Grid, p_child: *gtk.Widget, p_left: c_int, p_top: c_int, p_width: c_int, p_height: c_int) void;
    pub const attach = gtk_grid_attach;

    /// Adds a widget to the grid.
    ///
    /// The widget is placed next to `sibling`, on the side determined by
    /// `side`. When `sibling` is `NULL`, the widget is placed in row (for
    /// left or right placement) or column 0 (for top or bottom placement),
    /// at the end indicated by `side`.
    ///
    /// Attaching widgets labeled [1], [2], [3] with `sibling` == `NULL` and
    /// `side` == `GTK_POS_LEFT` yields a layout of [3][2][1].
    extern fn gtk_grid_attach_next_to(p_grid: *Grid, p_child: *gtk.Widget, p_sibling: ?*gtk.Widget, p_side: gtk.PositionType, p_width: c_int, p_height: c_int) void;
    pub const attachNextTo = gtk_grid_attach_next_to;

    /// Returns which row defines the global baseline of `grid`.
    extern fn gtk_grid_get_baseline_row(p_grid: *Grid) c_int;
    pub const getBaselineRow = gtk_grid_get_baseline_row;

    /// Gets the child of `grid` whose area covers the grid
    /// cell whose upper left corner is at `left`, `top`.
    extern fn gtk_grid_get_child_at(p_grid: *Grid, p_left: c_int, p_top: c_int) ?*gtk.Widget;
    pub const getChildAt = gtk_grid_get_child_at;

    /// Returns whether all columns of `grid` have the same width.
    extern fn gtk_grid_get_column_homogeneous(p_grid: *Grid) c_int;
    pub const getColumnHomogeneous = gtk_grid_get_column_homogeneous;

    /// Returns the amount of space between the columns of `grid`.
    extern fn gtk_grid_get_column_spacing(p_grid: *Grid) c_uint;
    pub const getColumnSpacing = gtk_grid_get_column_spacing;

    /// Returns the baseline position of `row` as set
    /// by `gtk.Grid.setRowBaselinePosition` or the default value
    /// `GTK_BASELINE_POSITION_CENTER`.
    extern fn gtk_grid_get_row_baseline_position(p_grid: *Grid, p_row: c_int) gtk.BaselinePosition;
    pub const getRowBaselinePosition = gtk_grid_get_row_baseline_position;

    /// Returns whether all rows of `grid` have the same height.
    extern fn gtk_grid_get_row_homogeneous(p_grid: *Grid) c_int;
    pub const getRowHomogeneous = gtk_grid_get_row_homogeneous;

    /// Returns the amount of space between the rows of `grid`.
    extern fn gtk_grid_get_row_spacing(p_grid: *Grid) c_uint;
    pub const getRowSpacing = gtk_grid_get_row_spacing;

    /// Inserts a column at the specified position.
    ///
    /// Children which are attached at or to the right of this position
    /// are moved one column to the right. Children which span across this
    /// position are grown to span the new column.
    extern fn gtk_grid_insert_column(p_grid: *Grid, p_position: c_int) void;
    pub const insertColumn = gtk_grid_insert_column;

    /// Inserts a row or column at the specified position.
    ///
    /// The new row or column is placed next to `sibling`, on the side
    /// determined by `side`. If `side` is `GTK_POS_TOP` or `GTK_POS_BOTTOM`,
    /// a row is inserted. If `side` is `GTK_POS_LEFT` of `GTK_POS_RIGHT`,
    /// a column is inserted.
    extern fn gtk_grid_insert_next_to(p_grid: *Grid, p_sibling: *gtk.Widget, p_side: gtk.PositionType) void;
    pub const insertNextTo = gtk_grid_insert_next_to;

    /// Inserts a row at the specified position.
    ///
    /// Children which are attached at or below this position
    /// are moved one row down. Children which span across this
    /// position are grown to span the new row.
    extern fn gtk_grid_insert_row(p_grid: *Grid, p_position: c_int) void;
    pub const insertRow = gtk_grid_insert_row;

    /// Removes a column from the grid.
    ///
    /// Children that are placed in this column are removed,
    /// spanning children that overlap this column have their
    /// width reduced by one, and children after the column
    /// are moved to the left.
    extern fn gtk_grid_remove_column(p_grid: *Grid, p_position: c_int) void;
    pub const removeColumn = gtk_grid_remove_column;

    /// Removes a row from the grid.
    ///
    /// Children that are placed in this row are removed,
    /// spanning children that overlap this row have their
    /// height reduced by one, and children below the row
    /// are moved up.
    extern fn gtk_grid_remove_row(p_grid: *Grid, p_position: c_int) void;
    pub const removeRow = gtk_grid_remove_row;

    /// Sets which row defines the global baseline for the entire grid.
    /// Each row in the grid can have its own local baseline, but only
    /// one of those is global, meaning it will be the baseline in the
    /// parent of the `grid`.
    extern fn gtk_grid_set_baseline_row(p_grid: *Grid, p_row: c_int) void;
    pub const setBaselineRow = gtk_grid_set_baseline_row;

    /// Sets whether all columns of `grid` will have the same width.
    extern fn gtk_grid_set_column_homogeneous(p_grid: *Grid, p_homogeneous: c_int) void;
    pub const setColumnHomogeneous = gtk_grid_set_column_homogeneous;

    /// Sets the amount of space between columns of `grid`.
    extern fn gtk_grid_set_column_spacing(p_grid: *Grid, p_spacing: c_uint) void;
    pub const setColumnSpacing = gtk_grid_set_column_spacing;

    /// Sets how the baseline should be positioned on `row` of the
    /// grid, in case that row is assigned more space than is requested.
    extern fn gtk_grid_set_row_baseline_position(p_grid: *Grid, p_row: c_int, p_pos: gtk.BaselinePosition) void;
    pub const setRowBaselinePosition = gtk_grid_set_row_baseline_position;

    /// Sets whether all rows of `grid` will have the same height.
    extern fn gtk_grid_set_row_homogeneous(p_grid: *Grid, p_homogeneous: c_int) void;
    pub const setRowHomogeneous = gtk_grid_set_row_homogeneous;

    /// Sets the amount of space between rows of `grid`.
    extern fn gtk_grid_set_row_spacing(p_grid: *Grid, p_spacing: c_uint) void;
    pub const setRowSpacing = gtk_grid_set_row_spacing;

    extern fn gtk_grid_get_type() usize;
    pub const getGObjectType = gtk_grid_get_type;

    extern fn g_object_ref(p_self: *gtk.Grid) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Grid) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Grid, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.HBox` is a container that organizes child widgets into a single row.
///
/// Use the `gtk.Box` packing interface to determine the arrangement,
/// spacing, width, and alignment of `gtk.HBox` children.
///
/// All children are allocated the same height.
///
/// GtkHBox has been deprecated. You can use `gtk.Box` instead, which is a
/// very quick and easy change. If you have derived your own classes from
/// GtkHBox, you can simply change the inheritance to derive directly
/// from `gtk.Box`. No further changes are needed, since the default
/// value of the `gtk.Orientable.properties.orientation` property is
/// `GTK_ORIENTATION_HORIZONTAL`.
///
/// If you have a grid-like layout composed of nested boxes, and you don’t
/// need first-child or last-child styling, the recommendation is to switch
/// to `gtk.Grid`. For more information about migrating to `gtk.Grid`, see
/// [Migrating from other containers to GtkGrid][gtk-migrating-GtkGrid].
pub const HBox = extern struct {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.HBoxClass;
    f_box: gtk.Box,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.HBox`.
    extern fn gtk_hbox_new(p_homogeneous: c_int, p_spacing: c_int) *gtk.HBox;
    pub const new = gtk_hbox_new;

    extern fn gtk_hbox_get_type() usize;
    pub const getGObjectType = gtk_hbox_get_type;

    extern fn g_object_ref(p_self: *gtk.HBox) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.HBox) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *HBox, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HButtonBox = extern struct {
    pub const Parent = gtk.ButtonBox;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.HButtonBoxClass;
    f_button_box: gtk.ButtonBox,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new horizontal button box.
    extern fn gtk_hbutton_box_new() *gtk.HButtonBox;
    pub const new = gtk_hbutton_box_new;

    extern fn gtk_hbutton_box_get_type() usize;
    pub const getGObjectType = gtk_hbutton_box_get_type;

    extern fn g_object_ref(p_self: *gtk.HButtonBox) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.HButtonBox) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *HButtonBox, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The HPaned widget is a container widget with two
/// children arranged horizontally. The division between
/// the two panes is adjustable by the user by dragging
/// a handle. See `gtk.Paned` for details.
///
/// GtkHPaned has been deprecated, use `gtk.Paned` instead.
pub const HPaned = extern struct {
    pub const Parent = gtk.Paned;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.HPanedClass;
    f_paned: gtk.Paned,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Create a new `gtk.HPaned`
    extern fn gtk_hpaned_new() *gtk.HPaned;
    pub const new = gtk_hpaned_new;

    extern fn gtk_hpaned_get_type() usize;
    pub const getGObjectType = gtk_hpaned_get_type;

    extern fn g_object_ref(p_self: *gtk.HPaned) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.HPaned) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *HPaned, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.HSV` is the “color wheel” part of a complete color selector widget.
/// It allows to select a color by determining its HSV components in an
/// intuitive way. Moving the selection around the outer ring changes the hue,
/// and moving the selection point inside the inner triangle changes value and
/// saturation.
///
/// `gtk.HSV` has been deprecated together with `gtk.ColorSelection`, where
/// it was used.
pub const HSV = extern struct {
    pub const Parent = gtk.Widget;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.HSVClass;
    f_parent_instance: gtk.Widget,
    f_priv: ?*gtk.HSVPrivate,

    pub const virtual_methods = struct {
        pub const changed = struct {
            pub fn call(p_class: anytype, p_hsv: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(HSV.Class, p_class).f_changed.?(gobject.ext.as(HSV, p_hsv));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_hsv: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(HSV.Class, p_class).f_changed = @ptrCast(p_implementation);
            }
        };

        pub const move = struct {
            pub fn call(p_class: anytype, p_hsv: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_type: gtk.DirectionType) void {
                return gobject.ext.as(HSV.Class, p_class).f_move.?(gobject.ext.as(HSV, p_hsv), p_type);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_hsv: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_type: gtk.DirectionType) callconv(.c) void) void {
                gobject.ext.as(HSV.Class, p_class).f_move = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(HSV, p_instance))),
                    gobject.signalLookup("changed", HSV.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const move = struct {
            pub const name = "move";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: gtk.DirectionType, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(HSV, p_instance))),
                    gobject.signalLookup("move", HSV.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Converts a color from HSV space to RGB.
    ///
    /// Input values must be in the [0.0, 1.0] range;
    /// output values will be in the same range.
    extern fn gtk_hsv_to_rgb(p_h: f64, p_s: f64, p_v: f64, p_r: *f64, p_g: *f64, p_b: *f64) void;
    pub const toRgb = gtk_hsv_to_rgb;

    /// Creates a new HSV color selector.
    extern fn gtk_hsv_new() *gtk.HSV;
    pub const new = gtk_hsv_new;

    /// Queries the current color in an HSV color selector.
    /// Returned values will be in the [0.0, 1.0] range.
    extern fn gtk_hsv_get_color(p_hsv: *HSV, p_h: *f64, p_s: *f64, p_v: *f64) void;
    pub const getColor = gtk_hsv_get_color;

    /// Queries the size and ring width of an HSV color selector.
    extern fn gtk_hsv_get_metrics(p_hsv: *HSV, p_size: *c_int, p_ring_width: *c_int) void;
    pub const getMetrics = gtk_hsv_get_metrics;

    /// An HSV color selector can be said to be adjusting if multiple rapid
    /// changes are being made to its value, for example, when the user is
    /// adjusting the value with the mouse. This function queries whether
    /// the HSV color selector is being adjusted or not.
    extern fn gtk_hsv_is_adjusting(p_hsv: *HSV) c_int;
    pub const isAdjusting = gtk_hsv_is_adjusting;

    /// Sets the current color in an HSV color selector.
    /// Color component values must be in the [0.0, 1.0] range.
    extern fn gtk_hsv_set_color(p_hsv: *HSV, p_h: f64, p_s: f64, p_v: f64) void;
    pub const setColor = gtk_hsv_set_color;

    /// Sets the size and ring width of an HSV color selector.
    extern fn gtk_hsv_set_metrics(p_hsv: *HSV, p_size: c_int, p_ring_width: c_int) void;
    pub const setMetrics = gtk_hsv_set_metrics;

    extern fn gtk_hsv_get_type() usize;
    pub const getGObjectType = gtk_hsv_get_type;

    extern fn g_object_ref(p_self: *gtk.HSV) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.HSV) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *HSV, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.HScale` widget is used to allow the user to select a value using
/// a horizontal slider. To create one, use `gtk.HScale.newWithRange`.
///
/// The position to show the current value, and the number of decimal places
/// shown can be set using the parent `gtk.Scale` class’s functions.
///
/// GtkHScale has been deprecated, use `gtk.Scale` instead.
pub const HScale = extern struct {
    pub const Parent = gtk.Scale;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.HScaleClass;
    f_scale: gtk.Scale,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.HScale`.
    extern fn gtk_hscale_new(p_adjustment: ?*gtk.Adjustment) *gtk.HScale;
    pub const new = gtk_hscale_new;

    /// Creates a new horizontal scale widget that lets the user input a
    /// number between `min` and `max` (including `min` and `max`) with the
    /// increment `step`.  `step` must be nonzero; it’s the distance the
    /// slider moves when using the arrow keys to adjust the scale value.
    ///
    /// Note that the way in which the precision is derived works best if `step`
    /// is a power of ten. If the resulting precision is not suitable for your
    /// needs, use `gtk.Scale.setDigits` to correct it.
    extern fn gtk_hscale_new_with_range(p_min: f64, p_max: f64, p_step: f64) *gtk.HScale;
    pub const newWithRange = gtk_hscale_new_with_range;

    extern fn gtk_hscale_get_type() usize;
    pub const getGObjectType = gtk_hscale_get_type;

    extern fn g_object_ref(p_self: *gtk.HScale) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.HScale) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *HScale, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.HScrollbar` widget is a widget arranged horizontally creating a
/// scrollbar. See `gtk.Scrollbar` for details on
/// scrollbars. `gtk.Adjustment` pointers may be added to handle the
/// adjustment of the scrollbar or it may be left `NULL` in which case one
/// will be created for you. See `gtk.Scrollbar` for a description of what the
/// fields in an adjustment represent for a scrollbar.
///
/// GtkHScrollbar has been deprecated, use `gtk.Scrollbar` instead.
pub const HScrollbar = extern struct {
    pub const Parent = gtk.Scrollbar;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.HScrollbarClass;
    f_scrollbar: gtk.Scrollbar,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new horizontal scrollbar.
    extern fn gtk_hscrollbar_new(p_adjustment: ?*gtk.Adjustment) *gtk.HScrollbar;
    pub const new = gtk_hscrollbar_new;

    extern fn gtk_hscrollbar_get_type() usize;
    pub const getGObjectType = gtk_hscrollbar_get_type;

    extern fn g_object_ref(p_self: *gtk.HScrollbar) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.HScrollbar) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *HScrollbar, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.HSeparator` widget is a horizontal separator, used to group the
/// widgets within a window. It displays a horizontal line with a shadow to
/// make it appear sunken into the interface.
///
/// > The `gtk.HSeparator` widget is not used as a separator within menus.
/// > To create a separator in a menu create an empty `gtk.SeparatorMenuItem`
/// > widget using `gtk.SeparatorMenuItem.new` and add it to the menu with
/// > `gtk.MenuShell.append`.
///
/// GtkHSeparator has been deprecated, use `gtk.Separator` instead.
pub const HSeparator = extern struct {
    pub const Parent = gtk.Separator;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.HSeparatorClass;
    f_separator: gtk.Separator,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.HSeparator`.
    extern fn gtk_hseparator_new() *gtk.HSeparator;
    pub const new = gtk_hseparator_new;

    extern fn gtk_hseparator_get_type() usize;
    pub const getGObjectType = gtk_hseparator_get_type;

    extern fn g_object_ref(p_self: *gtk.HSeparator) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.HSeparator) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *HSeparator, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.HandleBox` widget allows a portion of a window to be "torn
/// off". It is a bin widget which displays its child and a handle that
/// the user can drag to tear off a separate window (the “float
/// window”) containing the child widget. A thin
/// “ghost” is drawn in the original location of the
/// handlebox. By dragging the separate window back to its original
/// location, it can be reattached.
///
/// When reattaching, the ghost and float window, must be aligned
/// along one of the edges, the “snap edge”.
/// This either can be specified by the application programmer
/// explicitly, or GTK+ will pick a reasonable default based
/// on the handle position.
///
/// To make detaching and reattaching the handlebox as minimally confusing
/// as possible to the user, it is important to set the snap edge so that
/// the snap edge does not move when the handlebox is deattached. For
/// instance, if the handlebox is packed at the bottom of a VBox, then
/// when the handlebox is detached, the bottom edge of the handlebox's
/// allocation will remain fixed as the height of the handlebox shrinks,
/// so the snap edge should be set to `GTK_POS_BOTTOM`.
///
/// > `gtk.HandleBox` has been deprecated. It is very specialized, lacks features
/// > to make it useful and most importantly does not fit well into modern
/// > application design. Do not use it. There is no replacement.
pub const HandleBox = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.HandleBoxClass;
    f_bin: gtk.Bin,
    f_priv: ?*gtk.HandleBoxPrivate,

    pub const virtual_methods = struct {
        /// Signal emitted when the contents of the handlebox
        ///    are reattached to the main window. Deprecated: 3.4.
        pub const child_attached = struct {
            pub fn call(p_class: anytype, p_handle_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget) void {
                return gobject.ext.as(HandleBox.Class, p_class).f_child_attached.?(gobject.ext.as(HandleBox, p_handle_box), p_child);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_handle_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(HandleBox.Class, p_class).f_child_attached = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the contents of the handlebox
        ///    are detached from the main window. Deprecated: 3.4.
        pub const child_detached = struct {
            pub fn call(p_class: anytype, p_handle_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget) void {
                return gobject.ext.as(HandleBox.Class, p_class).f_child_detached.?(gobject.ext.as(HandleBox, p_handle_box), p_child);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_handle_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(HandleBox.Class, p_class).f_child_detached = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const child_detached = struct {
            pub const name = "child-detached";

            pub const Type = c_int;
        };

        pub const handle_position = struct {
            pub const name = "handle-position";

            pub const Type = gtk.PositionType;
        };

        pub const shadow_type = struct {
            pub const name = "shadow-type";

            pub const Type = gtk.ShadowType;
        };

        pub const snap_edge = struct {
            pub const name = "snap-edge";

            pub const Type = gtk.PositionType;
        };

        pub const snap_edge_set = struct {
            pub const name = "snap-edge-set";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// This signal is emitted when the contents of the
        /// handlebox are reattached to the main window.
        pub const child_attached = struct {
            pub const name = "child-attached";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_widget: *gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(HandleBox, p_instance))),
                    gobject.signalLookup("child-attached", HandleBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when the contents of the
        /// handlebox are detached from the main window.
        pub const child_detached = struct {
            pub const name = "child-detached";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_widget: *gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(HandleBox, p_instance))),
                    gobject.signalLookup("child-detached", HandleBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Create a new handle box.
    extern fn gtk_handle_box_new() *gtk.HandleBox;
    pub const new = gtk_handle_box_new;

    /// Whether the handlebox’s child is currently detached.
    extern fn gtk_handle_box_get_child_detached(p_handle_box: *HandleBox) c_int;
    pub const getChildDetached = gtk_handle_box_get_child_detached;

    /// Gets the handle position of the handle box. See
    /// `gtk.HandleBox.setHandlePosition`.
    extern fn gtk_handle_box_get_handle_position(p_handle_box: *HandleBox) gtk.PositionType;
    pub const getHandlePosition = gtk_handle_box_get_handle_position;

    /// Gets the type of shadow drawn around the handle box. See
    /// `gtk.HandleBox.setShadowType`.
    extern fn gtk_handle_box_get_shadow_type(p_handle_box: *HandleBox) gtk.ShadowType;
    pub const getShadowType = gtk_handle_box_get_shadow_type;

    /// Gets the edge used for determining reattachment of the handle box.
    /// See `gtk.HandleBox.setSnapEdge`.
    extern fn gtk_handle_box_get_snap_edge(p_handle_box: *HandleBox) gtk.PositionType;
    pub const getSnapEdge = gtk_handle_box_get_snap_edge;

    /// Sets the side of the handlebox where the handle is drawn.
    extern fn gtk_handle_box_set_handle_position(p_handle_box: *HandleBox, p_position: gtk.PositionType) void;
    pub const setHandlePosition = gtk_handle_box_set_handle_position;

    /// Sets the type of shadow to be drawn around the border
    /// of the handle box.
    extern fn gtk_handle_box_set_shadow_type(p_handle_box: *HandleBox, p_type: gtk.ShadowType) void;
    pub const setShadowType = gtk_handle_box_set_shadow_type;

    /// Sets the snap edge of a handlebox. The snap edge is
    /// the edge of the detached child that must be aligned
    /// with the corresponding edge of the “ghost” left
    /// behind when the child was detached to reattach
    /// the torn-off window. Usually, the snap edge should
    /// be chosen so that it stays in the same place on
    /// the screen when the handlebox is torn off.
    ///
    /// If the snap edge is not set, then an appropriate value
    /// will be guessed from the handle position. If the
    /// handle position is `GTK_POS_RIGHT` or `GTK_POS_LEFT`,
    /// then the snap edge will be `GTK_POS_TOP`, otherwise
    /// it will be `GTK_POS_LEFT`.
    extern fn gtk_handle_box_set_snap_edge(p_handle_box: *HandleBox, p_edge: gtk.PositionType) void;
    pub const setSnapEdge = gtk_handle_box_set_snap_edge;

    extern fn gtk_handle_box_get_type() usize;
    pub const getGObjectType = gtk_handle_box_get_type;

    extern fn g_object_ref(p_self: *gtk.HandleBox) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.HandleBox) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *HandleBox, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkHeaderBar is similar to a horizontal `gtk.Box`. It allows children to
/// be placed at the start or the end. In addition, it allows a title and
/// subtitle to be displayed. The title will be centered with respect to
/// the width of the box, even if the children at either side take up
/// different amounts of space. The height of the titlebar will be
/// set to provide sufficient space for the subtitle, even if none is
/// currently set. If a subtitle is not needed, the space reservation
/// can be turned off with `gtk.HeaderBar.setHasSubtitle`.
///
/// GtkHeaderBar can add typical window frame controls, such as minimize,
/// maximize and close buttons, or the window icon.
///
/// For these reasons, GtkHeaderBar is the natural choice for use as the custom
/// titlebar widget of a `gtk.Window` (see `gtk.Window.setTitlebar`), as it gives
/// features typical of titlebars while allowing the addition of child widgets.
pub const HeaderBar = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.HeaderBarClass;
    f_container: gtk.Container,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const custom_title = struct {
            pub const name = "custom-title";

            pub const Type = ?*gtk.Widget;
        };

        /// The decoration layout for buttons. If this property is
        /// not set, the `gtk.Settings.properties.gtk`-decoration-layout setting
        /// is used.
        ///
        /// See `gtk.HeaderBar.setDecorationLayout` for information
        /// about the format of this string.
        pub const decoration_layout = struct {
            pub const name = "decoration-layout";

            pub const Type = ?[*:0]u8;
        };

        /// Set to `TRUE` if `gtk.HeaderBar.properties.decoration`-layout is set.
        pub const decoration_layout_set = struct {
            pub const name = "decoration-layout-set";

            pub const Type = c_int;
        };

        /// If `TRUE`, reserve space for a subtitle, even if none
        /// is currently set.
        pub const has_subtitle = struct {
            pub const name = "has-subtitle";

            pub const Type = c_int;
        };

        /// Whether to show window decorations.
        ///
        /// Which buttons are actually shown and where is determined
        /// by the `gtk.HeaderBar.properties.decoration`-layout property, and by
        /// the state of the window (e.g. a close button will not be
        /// shown if the window can't be closed).
        pub const show_close_button = struct {
            pub const name = "show-close-button";

            pub const Type = c_int;
        };

        pub const spacing = struct {
            pub const name = "spacing";

            pub const Type = c_int;
        };

        pub const subtitle = struct {
            pub const name = "subtitle";

            pub const Type = ?[*:0]u8;
        };

        pub const title = struct {
            pub const name = "title";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.HeaderBar` widget.
    extern fn gtk_header_bar_new() *gtk.HeaderBar;
    pub const new = gtk_header_bar_new;

    /// Retrieves the custom title widget of the header. See
    /// `gtk.HeaderBar.setCustomTitle`.
    extern fn gtk_header_bar_get_custom_title(p_bar: *HeaderBar) ?*gtk.Widget;
    pub const getCustomTitle = gtk_header_bar_get_custom_title;

    /// Gets the decoration layout set with
    /// `gtk.HeaderBar.setDecorationLayout`.
    extern fn gtk_header_bar_get_decoration_layout(p_bar: *HeaderBar) [*:0]const u8;
    pub const getDecorationLayout = gtk_header_bar_get_decoration_layout;

    /// Retrieves whether the header bar reserves space for
    /// a subtitle, regardless if one is currently set or not.
    extern fn gtk_header_bar_get_has_subtitle(p_bar: *HeaderBar) c_int;
    pub const getHasSubtitle = gtk_header_bar_get_has_subtitle;

    /// Returns whether this header bar shows the standard window
    /// decorations.
    extern fn gtk_header_bar_get_show_close_button(p_bar: *HeaderBar) c_int;
    pub const getShowCloseButton = gtk_header_bar_get_show_close_button;

    /// Retrieves the subtitle of the header. See `gtk.HeaderBar.setSubtitle`.
    extern fn gtk_header_bar_get_subtitle(p_bar: *HeaderBar) ?[*:0]const u8;
    pub const getSubtitle = gtk_header_bar_get_subtitle;

    /// Retrieves the title of the header. See `gtk.HeaderBar.setTitle`.
    extern fn gtk_header_bar_get_title(p_bar: *HeaderBar) ?[*:0]const u8;
    pub const getTitle = gtk_header_bar_get_title;

    /// Adds `child` to `bar`, packed with reference to the
    /// end of the `bar`.
    extern fn gtk_header_bar_pack_end(p_bar: *HeaderBar, p_child: *gtk.Widget) void;
    pub const packEnd = gtk_header_bar_pack_end;

    /// Adds `child` to `bar`, packed with reference to the
    /// start of the `bar`.
    extern fn gtk_header_bar_pack_start(p_bar: *HeaderBar, p_child: *gtk.Widget) void;
    pub const packStart = gtk_header_bar_pack_start;

    /// Sets a custom title for the `gtk.HeaderBar`.
    ///
    /// The title should help a user identify the current view. This
    /// supersedes any title set by `gtk.HeaderBar.setTitle` or
    /// `gtk.HeaderBar.setSubtitle`. To achieve the same style as
    /// the builtin title and subtitle, use the “title” and “subtitle”
    /// style classes.
    ///
    /// You should set the custom title to `NULL`, for the header title
    /// label to be visible again.
    extern fn gtk_header_bar_set_custom_title(p_bar: *HeaderBar, p_title_widget: ?*gtk.Widget) void;
    pub const setCustomTitle = gtk_header_bar_set_custom_title;

    /// Sets the decoration layout for this header bar, overriding
    /// the `gtk.Settings.properties.gtk`-decoration-layout setting.
    ///
    /// There can be valid reasons for overriding the setting, such
    /// as a header bar design that does not allow for buttons to take
    /// room on the right, or only offers room for a single close button.
    /// Split header bars are another example for overriding the
    /// setting.
    ///
    /// The format of the string is button names, separated by commas.
    /// A colon separates the buttons that should appear on the left
    /// from those on the right. Recognized button names are minimize,
    /// maximize, close, icon (the window icon) and menu (a menu button
    /// for the fallback app menu).
    ///
    /// For example, “menu:minimize,maximize,close” specifies a menu
    /// on the left, and minimize, maximize and close buttons on the right.
    extern fn gtk_header_bar_set_decoration_layout(p_bar: *HeaderBar, p_layout: ?[*:0]const u8) void;
    pub const setDecorationLayout = gtk_header_bar_set_decoration_layout;

    /// Sets whether the header bar should reserve space
    /// for a subtitle, even if none is currently set.
    extern fn gtk_header_bar_set_has_subtitle(p_bar: *HeaderBar, p_setting: c_int) void;
    pub const setHasSubtitle = gtk_header_bar_set_has_subtitle;

    /// Sets whether this header bar shows the standard window decorations,
    /// including close, maximize, and minimize.
    extern fn gtk_header_bar_set_show_close_button(p_bar: *HeaderBar, p_setting: c_int) void;
    pub const setShowCloseButton = gtk_header_bar_set_show_close_button;

    /// Sets the subtitle of the `gtk.HeaderBar`. The title should give a user
    /// an additional detail to help him identify the current view.
    ///
    /// Note that GtkHeaderBar by default reserves room for the subtitle,
    /// even if none is currently set. If this is not desired, set the
    /// `gtk.HeaderBar.properties.has`-subtitle property to `FALSE`.
    extern fn gtk_header_bar_set_subtitle(p_bar: *HeaderBar, p_subtitle: ?[*:0]const u8) void;
    pub const setSubtitle = gtk_header_bar_set_subtitle;

    /// Sets the title of the `gtk.HeaderBar`. The title should help a user
    /// identify the current view. A good title should not include the
    /// application name.
    extern fn gtk_header_bar_set_title(p_bar: *HeaderBar, p_title: ?[*:0]const u8) void;
    pub const setTitle = gtk_header_bar_set_title;

    extern fn gtk_header_bar_get_type() usize;
    pub const getGObjectType = gtk_header_bar_get_type;

    extern fn g_object_ref(p_self: *gtk.HeaderBar) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.HeaderBar) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *HeaderBar, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HeaderBarAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{atk.Component};
    pub const Class = gtk.HeaderBarAccessibleClass;
    f_parent: gtk.ContainerAccessible,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_header_bar_accessible_get_type() usize;
    pub const getGObjectType = gtk_header_bar_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.HeaderBarAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.HeaderBarAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *HeaderBarAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.IMContext` defines the interface for GTK+ input methods. An input method
/// is used by GTK+ text input widgets like `gtk.Entry` to map from key events to
/// Unicode character strings.
///
/// The default input method can be set programmatically via the
/// `gtk.Settings.properties.gtk`-im-module GtkSettings property. Alternatively, you may set
/// the GTK_IM_MODULE environment variable as documented in
/// [Running GTK+ Applications][gtk-running].
///
/// The `gtk.Entry` `gtk.Entry.properties.im`-module and `gtk.TextView` `gtk.TextView.properties.im`-module
/// properties may also be used to set input methods for specific widget
/// instances. For instance, a certain entry widget might be expected to contain
/// certain characters which would be easier to input with a certain input
/// method.
///
/// An input method may consume multiple key events in sequence and finally
/// output the composed result. This is called preediting, and an input method
/// may provide feedback about this process by displaying the intermediate
/// composition states as preedit text. For instance, the default GTK+ input
/// method implements the input of arbitrary Unicode code points by holding down
/// the Control and Shift keys and then typing “U” followed by the hexadecimal
/// digits of the code point.  When releasing the Control and Shift keys,
/// preediting ends and the character is inserted as text. Ctrl+Shift+u20AC for
/// example results in the € sign.
///
/// Additional input methods can be made available for use by GTK+ widgets as
/// loadable modules. An input method module is a small shared library which
/// implements a subclass of `gtk.IMContext` or `gtk.IMContextSimple` and exports
/// these four functions:
///
/// ```
/// void im_module_init(GTypeModule *module);
/// ```
/// This function should register the `gobject.Type` of the `gtk.IMContext` subclass which
/// implements the input method by means of `gobject.TypeModule.registerType`. Note
/// that `gobject.typeRegisterStatic` cannot be used as the type needs to be
/// registered dynamically.
///
/// ```
/// void im_module_exit(void);
/// ```
/// Here goes any cleanup code your input method might require on module unload.
///
/// ```
/// void im_module_list(const GtkIMContextInfo ***contexts, int *n_contexts)
/// {
///   *contexts = info_list;
///   *n_contexts = G_N_ELEMENTS (info_list);
/// }
/// ```
/// This function returns the list of input methods provided by the module. The
/// example implementation above shows a common solution and simply returns a
/// pointer to statically defined array of `gtk.IMContextInfo` items for each
/// provided input method.
///
/// ```
/// GtkIMContext * im_module_create(const gchar *context_id);
/// ```
/// This function should return a pointer to a newly created instance of the
/// `gtk.IMContext` subclass identified by `context_id`. The context ID is the same
/// as specified in the `gtk.IMContextInfo` array returned by `im_module_list`.
///
/// After a new loadable input method module has been installed on the system,
/// the configuration file `gtk.immodules` needs to be
/// regenerated by [gtk-query-immodules-3.0][gtk-query-immodules-3.0],
/// in order for the new input method to become available to GTK+ applications.
pub const IMContext = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.IMContextClass;
    f_parent_instance: gobject.Object,

    pub const virtual_methods = struct {
        /// Default handler of the `gtk.IMContext.signals.commit` signal.
        pub const commit = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_str: [*:0]const u8) void {
                return gobject.ext.as(IMContext.Class, p_class).f_commit.?(gobject.ext.as(IMContext, p_context), p_str);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_str: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(IMContext.Class, p_class).f_commit = @ptrCast(p_implementation);
            }
        };

        /// Asks the widget that the input context is attached to to delete
        /// characters around the cursor position by emitting the
        /// GtkIMContext::delete_surrounding signal. Note that `offset` and `n_chars`
        /// are in characters not in bytes which differs from the usage other
        /// places in `gtk.IMContext`.
        ///
        /// In order to use this function, you should first call
        /// `gtk.IMContext.getSurrounding` to get the current context, and
        /// call this function immediately afterwards to make sure that you
        /// know what you are deleting. You should also account for the fact
        /// that even if the signal was handled, the input context might not
        /// have deleted all the characters that were requested to be deleted.
        ///
        /// This function is used by an input method that wants to make
        /// subsitutions in the existing text in response to new input. It is
        /// not useful for applications.
        pub const delete_surrounding = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_offset: c_int, p_n_chars: c_int) c_int {
                return gobject.ext.as(IMContext.Class, p_class).f_delete_surrounding.?(gobject.ext.as(IMContext, p_context), p_offset, p_n_chars);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_offset: c_int, p_n_chars: c_int) callconv(.c) c_int) void {
                gobject.ext.as(IMContext.Class, p_class).f_delete_surrounding = @ptrCast(p_implementation);
            }
        };

        /// Allow an input method to internally handle key press and release
        /// events. If this function returns `TRUE`, then no further processing
        /// should be done for this key event.
        pub const filter_keypress = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventKey) c_int {
                return gobject.ext.as(IMContext.Class, p_class).f_filter_keypress.?(gobject.ext.as(IMContext, p_context), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventKey) callconv(.c) c_int) void {
                gobject.ext.as(IMContext.Class, p_class).f_filter_keypress = @ptrCast(p_implementation);
            }
        };

        /// Notify the input method that the widget to which this
        /// input context corresponds has gained focus. The input method
        /// may, for example, change the displayed feedback to reflect
        /// this change.
        pub const focus_in = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(IMContext.Class, p_class).f_focus_in.?(gobject.ext.as(IMContext, p_context));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(IMContext.Class, p_class).f_focus_in = @ptrCast(p_implementation);
            }
        };

        /// Notify the input method that the widget to which this
        /// input context corresponds has lost focus. The input method
        /// may, for example, change the displayed feedback or reset the contexts
        /// state to reflect this change.
        pub const focus_out = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(IMContext.Class, p_class).f_focus_out.?(gobject.ext.as(IMContext, p_context));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(IMContext.Class, p_class).f_focus_out = @ptrCast(p_implementation);
            }
        };

        /// Retrieve the current preedit string for the input context,
        /// and a list of attributes to apply to the string.
        /// This string should be displayed inserted at the insertion
        /// point.
        pub const get_preedit_string = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_str: *[*:0]u8, p_attrs: **pango.AttrList, p_cursor_pos: *c_int) void {
                return gobject.ext.as(IMContext.Class, p_class).f_get_preedit_string.?(gobject.ext.as(IMContext, p_context), p_str, p_attrs, p_cursor_pos);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_str: *[*:0]u8, p_attrs: **pango.AttrList, p_cursor_pos: *c_int) callconv(.c) void) void {
                gobject.ext.as(IMContext.Class, p_class).f_get_preedit_string = @ptrCast(p_implementation);
            }
        };

        /// Retrieves context around the insertion point. Input methods
        /// typically want context in order to constrain input text based on
        /// existing text; this is important for languages such as Thai where
        /// only some sequences of characters are allowed.
        ///
        /// This function is implemented by emitting the
        /// GtkIMContext::retrieve_surrounding signal on the input method; in
        /// response to this signal, a widget should provide as much context as
        /// is available, up to an entire paragraph, by calling
        /// `gtk.IMContext.setSurrounding`. Note that there is no obligation
        /// for a widget to respond to the ::retrieve_surrounding signal, so input
        /// methods must be prepared to function without context.
        pub const get_surrounding = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_text: *[*:0]u8, p_cursor_index: *c_int) c_int {
                return gobject.ext.as(IMContext.Class, p_class).f_get_surrounding.?(gobject.ext.as(IMContext, p_context), p_text, p_cursor_index);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_text: *[*:0]u8, p_cursor_index: *c_int) callconv(.c) c_int) void {
                gobject.ext.as(IMContext.Class, p_class).f_get_surrounding = @ptrCast(p_implementation);
            }
        };

        /// Default handler of the `gtk.IMContext.signals.preedit`-changed
        ///   signal.
        pub const preedit_changed = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(IMContext.Class, p_class).f_preedit_changed.?(gobject.ext.as(IMContext, p_context));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(IMContext.Class, p_class).f_preedit_changed = @ptrCast(p_implementation);
            }
        };

        /// Default handler of the `gtk.IMContext.signals.preedit`-end signal.
        pub const preedit_end = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(IMContext.Class, p_class).f_preedit_end.?(gobject.ext.as(IMContext, p_context));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(IMContext.Class, p_class).f_preedit_end = @ptrCast(p_implementation);
            }
        };

        /// Default handler of the `gtk.IMContext.signals.preedit`-start signal.
        pub const preedit_start = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(IMContext.Class, p_class).f_preedit_start.?(gobject.ext.as(IMContext, p_context));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(IMContext.Class, p_class).f_preedit_start = @ptrCast(p_implementation);
            }
        };

        /// Notify the input method that a change such as a change in cursor
        /// position has been made. This will typically cause the input
        /// method to clear the preedit state.
        pub const reset = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(IMContext.Class, p_class).f_reset.?(gobject.ext.as(IMContext, p_context));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(IMContext.Class, p_class).f_reset = @ptrCast(p_implementation);
            }
        };

        /// Default handler of the
        ///   `gtk.IMContext.signals.retrieve`-surrounding signal.
        pub const retrieve_surrounding = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(IMContext.Class, p_class).f_retrieve_surrounding.?(gobject.ext.as(IMContext, p_context));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(IMContext.Class, p_class).f_retrieve_surrounding = @ptrCast(p_implementation);
            }
        };

        /// Set the client window for the input context; this is the
        /// `gdk.Window` in which the input appears. This window is
        /// used in order to correctly position status windows, and may
        /// also be used for purposes internal to the input method.
        pub const set_client_window = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_window: ?*gdk.Window) void {
                return gobject.ext.as(IMContext.Class, p_class).f_set_client_window.?(gobject.ext.as(IMContext, p_context), p_window);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_window: ?*gdk.Window) callconv(.c) void) void {
                gobject.ext.as(IMContext.Class, p_class).f_set_client_window = @ptrCast(p_implementation);
            }
        };

        /// Notify the input method that a change in cursor
        /// position has been made. The location is relative to the client
        /// window.
        pub const set_cursor_location = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_area: *gdk.Rectangle) void {
                return gobject.ext.as(IMContext.Class, p_class).f_set_cursor_location.?(gobject.ext.as(IMContext, p_context), p_area);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_area: *gdk.Rectangle) callconv(.c) void) void {
                gobject.ext.as(IMContext.Class, p_class).f_set_cursor_location = @ptrCast(p_implementation);
            }
        };

        /// Sets surrounding context around the insertion point and preedit
        /// string. This function is expected to be called in response to the
        /// GtkIMContext::retrieve_surrounding signal, and will likely have no
        /// effect if called at other times.
        pub const set_surrounding = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_text: [*:0]const u8, p_len: c_int, p_cursor_index: c_int) void {
                return gobject.ext.as(IMContext.Class, p_class).f_set_surrounding.?(gobject.ext.as(IMContext, p_context), p_text, p_len, p_cursor_index);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_text: [*:0]const u8, p_len: c_int, p_cursor_index: c_int) callconv(.c) void) void {
                gobject.ext.as(IMContext.Class, p_class).f_set_surrounding = @ptrCast(p_implementation);
            }
        };

        /// Sets whether the IM context should use the preedit string
        /// to display feedback. If `use_preedit` is FALSE (default
        /// is TRUE), then the IM context may use some other method to display
        /// feedback, such as displaying it in a child of the root window.
        pub const set_use_preedit = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_use_preedit: c_int) void {
                return gobject.ext.as(IMContext.Class, p_class).f_set_use_preedit.?(gobject.ext.as(IMContext, p_context), p_use_preedit);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_use_preedit: c_int) callconv(.c) void) void {
                gobject.ext.as(IMContext.Class, p_class).f_set_use_preedit = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const input_hints = struct {
            pub const name = "input-hints";

            pub const Type = gtk.InputHints;
        };

        pub const input_purpose = struct {
            pub const name = "input-purpose";

            pub const Type = gtk.InputPurpose;
        };
    };

    pub const signals = struct {
        /// The ::commit signal is emitted when a complete input sequence
        /// has been entered by the user. This can be a single character
        /// immediately after a key press or the final result of preediting.
        pub const commit = struct {
            pub const name = "commit";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_str: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(IMContext, p_instance))),
                    gobject.signalLookup("commit", IMContext.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::delete-surrounding signal is emitted when the input method
        /// needs to delete all or part of the context surrounding the cursor.
        pub const delete_surrounding = struct {
            pub const name = "delete-surrounding";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_offset: c_int, p_n_chars: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(IMContext, p_instance))),
                    gobject.signalLookup("delete-surrounding", IMContext.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::preedit-changed signal is emitted whenever the preedit sequence
        /// currently being entered has changed.  It is also emitted at the end of
        /// a preedit sequence, in which case
        /// `gtk.IMContext.getPreeditString` returns the empty string.
        pub const preedit_changed = struct {
            pub const name = "preedit-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(IMContext, p_instance))),
                    gobject.signalLookup("preedit-changed", IMContext.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::preedit-end signal is emitted when a preediting sequence
        /// has been completed or canceled.
        pub const preedit_end = struct {
            pub const name = "preedit-end";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(IMContext, p_instance))),
                    gobject.signalLookup("preedit-end", IMContext.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::preedit-start signal is emitted when a new preediting sequence
        /// starts.
        pub const preedit_start = struct {
            pub const name = "preedit-start";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(IMContext, p_instance))),
                    gobject.signalLookup("preedit-start", IMContext.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::retrieve-surrounding signal is emitted when the input method
        /// requires the context surrounding the cursor.  The callback should set
        /// the input method surrounding context by calling the
        /// `gtk.IMContext.setSurrounding` method.
        pub const retrieve_surrounding = struct {
            pub const name = "retrieve-surrounding";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(IMContext, p_instance))),
                    gobject.signalLookup("retrieve-surrounding", IMContext.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Asks the widget that the input context is attached to to delete
    /// characters around the cursor position by emitting the
    /// GtkIMContext::delete_surrounding signal. Note that `offset` and `n_chars`
    /// are in characters not in bytes which differs from the usage other
    /// places in `gtk.IMContext`.
    ///
    /// In order to use this function, you should first call
    /// `gtk.IMContext.getSurrounding` to get the current context, and
    /// call this function immediately afterwards to make sure that you
    /// know what you are deleting. You should also account for the fact
    /// that even if the signal was handled, the input context might not
    /// have deleted all the characters that were requested to be deleted.
    ///
    /// This function is used by an input method that wants to make
    /// subsitutions in the existing text in response to new input. It is
    /// not useful for applications.
    extern fn gtk_im_context_delete_surrounding(p_context: *IMContext, p_offset: c_int, p_n_chars: c_int) c_int;
    pub const deleteSurrounding = gtk_im_context_delete_surrounding;

    /// Allow an input method to internally handle key press and release
    /// events. If this function returns `TRUE`, then no further processing
    /// should be done for this key event.
    extern fn gtk_im_context_filter_keypress(p_context: *IMContext, p_event: *gdk.EventKey) c_int;
    pub const filterKeypress = gtk_im_context_filter_keypress;

    /// Notify the input method that the widget to which this
    /// input context corresponds has gained focus. The input method
    /// may, for example, change the displayed feedback to reflect
    /// this change.
    extern fn gtk_im_context_focus_in(p_context: *IMContext) void;
    pub const focusIn = gtk_im_context_focus_in;

    /// Notify the input method that the widget to which this
    /// input context corresponds has lost focus. The input method
    /// may, for example, change the displayed feedback or reset the contexts
    /// state to reflect this change.
    extern fn gtk_im_context_focus_out(p_context: *IMContext) void;
    pub const focusOut = gtk_im_context_focus_out;

    /// Retrieve the current preedit string for the input context,
    /// and a list of attributes to apply to the string.
    /// This string should be displayed inserted at the insertion
    /// point.
    extern fn gtk_im_context_get_preedit_string(p_context: *IMContext, p_str: *[*:0]u8, p_attrs: **pango.AttrList, p_cursor_pos: *c_int) void;
    pub const getPreeditString = gtk_im_context_get_preedit_string;

    /// Retrieves context around the insertion point. Input methods
    /// typically want context in order to constrain input text based on
    /// existing text; this is important for languages such as Thai where
    /// only some sequences of characters are allowed.
    ///
    /// This function is implemented by emitting the
    /// GtkIMContext::retrieve_surrounding signal on the input method; in
    /// response to this signal, a widget should provide as much context as
    /// is available, up to an entire paragraph, by calling
    /// `gtk.IMContext.setSurrounding`. Note that there is no obligation
    /// for a widget to respond to the ::retrieve_surrounding signal, so input
    /// methods must be prepared to function without context.
    extern fn gtk_im_context_get_surrounding(p_context: *IMContext, p_text: *[*:0]u8, p_cursor_index: *c_int) c_int;
    pub const getSurrounding = gtk_im_context_get_surrounding;

    /// Notify the input method that a change such as a change in cursor
    /// position has been made. This will typically cause the input
    /// method to clear the preedit state.
    extern fn gtk_im_context_reset(p_context: *IMContext) void;
    pub const reset = gtk_im_context_reset;

    /// Set the client window for the input context; this is the
    /// `gdk.Window` in which the input appears. This window is
    /// used in order to correctly position status windows, and may
    /// also be used for purposes internal to the input method.
    extern fn gtk_im_context_set_client_window(p_context: *IMContext, p_window: ?*gdk.Window) void;
    pub const setClientWindow = gtk_im_context_set_client_window;

    /// Notify the input method that a change in cursor
    /// position has been made. The location is relative to the client
    /// window.
    extern fn gtk_im_context_set_cursor_location(p_context: *IMContext, p_area: *const gdk.Rectangle) void;
    pub const setCursorLocation = gtk_im_context_set_cursor_location;

    /// Sets surrounding context around the insertion point and preedit
    /// string. This function is expected to be called in response to the
    /// GtkIMContext::retrieve_surrounding signal, and will likely have no
    /// effect if called at other times.
    extern fn gtk_im_context_set_surrounding(p_context: *IMContext, p_text: [*:0]const u8, p_len: c_int, p_cursor_index: c_int) void;
    pub const setSurrounding = gtk_im_context_set_surrounding;

    /// Sets whether the IM context should use the preedit string
    /// to display feedback. If `use_preedit` is FALSE (default
    /// is TRUE), then the IM context may use some other method to display
    /// feedback, such as displaying it in a child of the root window.
    extern fn gtk_im_context_set_use_preedit(p_context: *IMContext, p_use_preedit: c_int) void;
    pub const setUsePreedit = gtk_im_context_set_use_preedit;

    extern fn gtk_im_context_get_type() usize;
    pub const getGObjectType = gtk_im_context_get_type;

    extern fn g_object_ref(p_self: *gtk.IMContext) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.IMContext) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *IMContext, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkIMContextSimple is a simple input method context supporting table-based
/// input methods. It has a built-in table of compose sequences that is derived
/// from the X11 Compose files.
///
/// GtkIMContextSimple reads additional compose sequences from the first of the
/// following files that is found: ~/.config/gtk-3.0/Compose, ~/.XCompose,
/// /usr/share/X11/locale/$locale/Compose (for locales that have a nontrivial
/// Compose file). The syntax of these files is described in the Compose(5)
/// manual page.
///
/// ## Unicode characters
///
/// GtkIMContextSimple also supports numeric entry of Unicode characters
/// by typing Ctrl-Shift-u, followed by a hexadecimal Unicode codepoint.
/// For example, Ctrl-Shift-u 1 2 3 Enter yields U+0123 LATIN SMALL LETTER
/// G WITH CEDILLA, i.e. ģ.
pub const IMContextSimple = extern struct {
    pub const Parent = gtk.IMContext;
    pub const Implements = [_]type{};
    pub const Class = gtk.IMContextSimpleClass;
    f_object: gtk.IMContext,
    f_priv: ?*gtk.IMContextSimplePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.IMContextSimple`.
    extern fn gtk_im_context_simple_new() *gtk.IMContextSimple;
    pub const new = gtk_im_context_simple_new;

    /// Adds an additional table from the X11 compose file.
    extern fn gtk_im_context_simple_add_compose_file(p_context_simple: *IMContextSimple, p_compose_file: [*:0]const u8) void;
    pub const addComposeFile = gtk_im_context_simple_add_compose_file;

    /// Adds an additional table to search to the input context.
    /// Each row of the table consists of `max_seq_len` key symbols
    /// followed by two `guint16` interpreted as the high and low
    /// words of a `gunicode` value. Tables are searched starting
    /// from the last added.
    ///
    /// The table must be sorted in dictionary order on the
    /// numeric value of the key symbol fields. (Values beyond
    /// the length of the sequence should be zero.)
    extern fn gtk_im_context_simple_add_table(p_context_simple: *IMContextSimple, p_data: [*]u16, p_max_seq_len: c_int, p_n_seqs: c_int) void;
    pub const addTable = gtk_im_context_simple_add_table;

    extern fn gtk_im_context_simple_get_type() usize;
    pub const getGObjectType = gtk_im_context_simple_get_type;

    extern fn g_object_ref(p_self: *gtk.IMContextSimple) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.IMContextSimple) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *IMContextSimple, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IMMulticontext = extern struct {
    pub const Parent = gtk.IMContext;
    pub const Implements = [_]type{};
    pub const Class = gtk.IMMulticontextClass;
    f_object: gtk.IMContext,
    f_priv: ?*gtk.IMMulticontextPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.IMMulticontext`.
    extern fn gtk_im_multicontext_new() *gtk.IMMulticontext;
    pub const new = gtk_im_multicontext_new;

    /// Add menuitems for various available input methods to a menu;
    /// the menuitems, when selected, will switch the input method
    /// for the context and the global default input method.
    extern fn gtk_im_multicontext_append_menuitems(p_context: *IMMulticontext, p_menushell: *gtk.MenuShell) void;
    pub const appendMenuitems = gtk_im_multicontext_append_menuitems;

    /// Gets the id of the currently active slave of the `context`.
    extern fn gtk_im_multicontext_get_context_id(p_context: *IMMulticontext) [*:0]const u8;
    pub const getContextId = gtk_im_multicontext_get_context_id;

    /// Sets the context id for `context`.
    ///
    /// This causes the currently active slave of `context` to be
    /// replaced by the slave corresponding to the new context id.
    extern fn gtk_im_multicontext_set_context_id(p_context: *IMMulticontext, p_context_id: [*:0]const u8) void;
    pub const setContextId = gtk_im_multicontext_set_context_id;

    extern fn gtk_im_multicontext_get_type() usize;
    pub const getGObjectType = gtk_im_multicontext_get_type;

    extern fn g_object_ref(p_self: *gtk.IMMulticontext) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.IMMulticontext) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *IMMulticontext, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// An icon factory manages a collection of `gtk.IconSet`; a `gtk.IconSet` manages a
/// set of variants of a particular icon (i.e. a `gtk.IconSet` contains variants for
/// different sizes and widget states). Icons in an icon factory are named by a
/// stock ID, which is a simple string identifying the icon. Each `gtk.Style` has a
/// list of `gtk.IconFactory` derived from the current theme; those icon factories
/// are consulted first when searching for an icon. If the theme doesn’t set a
/// particular icon, GTK+ looks for the icon in a list of default icon factories,
/// maintained by `gtk.IconFactory.addDefault` and
/// `gtk.IconFactory.removeDefault`. Applications with icons should add a default
/// icon factory with their icons, which will allow themes to override the icons
/// for the application.
///
/// To display an icon, always use `gtk.Style.lookupIconSet` on the widget that
/// will display the icon, or the convenience function
/// `gtk.Widget.renderIcon`. These functions take the theme into account when
/// looking up the icon to use for a given stock ID.
///
/// # GtkIconFactory as GtkBuildable
///
/// GtkIconFactory supports a custom `<sources>` element, which can contain
/// multiple `<source>` elements. The following attributes are allowed:
///
/// - stock-id
///
///     The stock id of the source, a string. This attribute is
///     mandatory
///
/// - filename
///
///     The filename of the source, a string.  This attribute is
///     optional
///
/// - icon-name
///
///     The icon name for the source, a string.  This attribute is
///     optional.
///
/// - size
///
///     Size of the icon, a `gtk.IconSize` enum value.  This attribute is
///     optional.
///
/// - direction
///
///     Direction of the source, a `gtk.TextDirection` enum value.  This
///     attribute is optional.
///
/// - state
///
///     State of the source, a `gtk.StateType` enum value.  This
///     attribute is optional.
///
///
/// ## A
///
/// ```
/// <object class="GtkIconFactory" id="iconfactory1">
///   <sources>
///     <source stock-id="apple-red" filename="apple-red.png"/>
///   </sources>
/// </object>
/// <object class="GtkWindow" id="window1">
///   <child>
///     <object class="GtkButton" id="apple_button">
///       <property name="label">apple-red</property>
///       <property name="use-stock">True</property>
///     </object>
///   </child>
/// </object>
/// ```
pub const IconFactory = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gtk.Buildable};
    pub const Class = gtk.IconFactoryClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.IconFactoryPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Looks for an icon in the list of default icon factories.  For
    /// display to the user, you should use `gtk.Style.lookupIconSet` on
    /// the `gtk.Style` for the widget that will display the icon, instead of
    /// using this function directly, so that themes are taken into
    /// account.
    extern fn gtk_icon_factory_lookup_default(p_stock_id: [*:0]const u8) *gtk.IconSet;
    pub const lookupDefault = gtk_icon_factory_lookup_default;

    /// Creates a new `gtk.IconFactory`. An icon factory manages a collection
    /// of `GtkIconSets`; a `gtk.IconSet` manages a set of variants of a
    /// particular icon (i.e. a `gtk.IconSet` contains variants for different
    /// sizes and widget states). Icons in an icon factory are named by a
    /// stock ID, which is a simple string identifying the icon. Each
    /// `gtk.Style` has a list of `GtkIconFactorys` derived from the current
    /// theme; those icon factories are consulted first when searching for
    /// an icon. If the theme doesn’t set a particular icon, GTK+ looks for
    /// the icon in a list of default icon factories, maintained by
    /// `gtk.IconFactory.addDefault` and
    /// `gtk.IconFactory.removeDefault`. Applications with icons should
    /// add a default icon factory with their icons, which will allow
    /// themes to override the icons for the application.
    extern fn gtk_icon_factory_new() *gtk.IconFactory;
    pub const new = gtk_icon_factory_new;

    /// Adds the given `icon_set` to the icon factory, under the name
    /// `stock_id`.  `stock_id` should be namespaced for your application,
    /// e.g. “myapp-whatever-icon”.  Normally applications create a
    /// `gtk.IconFactory`, then add it to the list of default factories with
    /// `gtk.IconFactory.addDefault`. Then they pass the `stock_id` to
    /// widgets such as `gtk.Image` to display the icon. Themes can provide
    /// an icon with the same name (such as "myapp-whatever-icon") to
    /// override your application’s default icons. If an icon already
    /// existed in `factory` for `stock_id`, it is unreferenced and replaced
    /// with the new `icon_set`.
    extern fn gtk_icon_factory_add(p_factory: *IconFactory, p_stock_id: [*:0]const u8, p_icon_set: *gtk.IconSet) void;
    pub const add = gtk_icon_factory_add;

    /// Adds an icon factory to the list of icon factories searched by
    /// `gtk.Style.lookupIconSet`. This means that, for example,
    /// `gtk.Image.newFromStock` will be able to find icons in `factory`.
    /// There will normally be an icon factory added for each library or
    /// application that comes with icons. The default icon factories
    /// can be overridden by themes.
    extern fn gtk_icon_factory_add_default(p_factory: *IconFactory) void;
    pub const addDefault = gtk_icon_factory_add_default;

    /// Looks up `stock_id` in the icon factory, returning an icon set
    /// if found, otherwise `NULL`. For display to the user, you should
    /// use `gtk.Style.lookupIconSet` on the `gtk.Style` for the
    /// widget that will display the icon, instead of using this
    /// function directly, so that themes are taken into account.
    extern fn gtk_icon_factory_lookup(p_factory: *IconFactory, p_stock_id: [*:0]const u8) *gtk.IconSet;
    pub const lookup = gtk_icon_factory_lookup;

    /// Removes an icon factory from the list of default icon
    /// factories. Not normally used; you might use it for a library that
    /// can be unloaded or shut down.
    extern fn gtk_icon_factory_remove_default(p_factory: *IconFactory) void;
    pub const removeDefault = gtk_icon_factory_remove_default;

    extern fn gtk_icon_factory_get_type() usize;
    pub const getGObjectType = gtk_icon_factory_get_type;

    extern fn g_object_ref(p_self: *gtk.IconFactory) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.IconFactory) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *IconFactory, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Contains information found when looking up an icon in
/// an icon theme.
pub const IconInfo = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.IconInfoClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a `gtk.IconInfo` for a `gdkpixbuf.Pixbuf`.
    extern fn gtk_icon_info_new_for_pixbuf(p_icon_theme: *gtk.IconTheme, p_pixbuf: *gdkpixbuf.Pixbuf) *gtk.IconInfo;
    pub const newForPixbuf = gtk_icon_info_new_for_pixbuf;

    /// Make a copy of a `gtk.IconInfo`.
    extern fn gtk_icon_info_copy(p_icon_info: *IconInfo) *gtk.IconInfo;
    pub const copy = gtk_icon_info_copy;

    /// Free a `gtk.IconInfo` and associated information
    extern fn gtk_icon_info_free(p_icon_info: *IconInfo) void;
    pub const free = gtk_icon_info_free;

    /// This function is deprecated and always returns `FALSE`.
    extern fn gtk_icon_info_get_attach_points(p_icon_info: *IconInfo, p_points: ?*[*]gdk.Point, p_n_points: ?*c_int) c_int;
    pub const getAttachPoints = gtk_icon_info_get_attach_points;

    /// Gets the base scale for the icon. The base scale is a scale
    /// for the icon that was specified by the icon theme creator.
    /// For instance an icon drawn for a high-dpi screen with window
    /// scale 2 for a base size of 32 will be 64 pixels tall and have
    /// a base scale of 2.
    extern fn gtk_icon_info_get_base_scale(p_icon_info: *IconInfo) c_int;
    pub const getBaseScale = gtk_icon_info_get_base_scale;

    /// Gets the base size for the icon. The base size
    /// is a size for the icon that was specified by
    /// the icon theme creator. This may be different
    /// than the actual size of image; an example of
    /// this is small emblem icons that can be attached
    /// to a larger icon. These icons will be given
    /// the same base size as the larger icons to which
    /// they are attached.
    ///
    /// Note that for scaled icons the base size does
    /// not include the base scale.
    extern fn gtk_icon_info_get_base_size(p_icon_info: *IconInfo) c_int;
    pub const getBaseSize = gtk_icon_info_get_base_size;

    /// Gets the built-in image for this icon, if any. To allow GTK+ to use
    /// built in icon images, you must pass the `GTK_ICON_LOOKUP_USE_BUILTIN`
    /// to `gtk.IconTheme.lookupIcon`.
    extern fn gtk_icon_info_get_builtin_pixbuf(p_icon_info: *IconInfo) ?*gdkpixbuf.Pixbuf;
    pub const getBuiltinPixbuf = gtk_icon_info_get_builtin_pixbuf;

    /// This function is deprecated and always returns `NULL`.
    extern fn gtk_icon_info_get_display_name(p_icon_info: *IconInfo) [*:0]const u8;
    pub const getDisplayName = gtk_icon_info_get_display_name;

    /// This function is deprecated and always returns `FALSE`.
    extern fn gtk_icon_info_get_embedded_rect(p_icon_info: *IconInfo, p_rectangle: *gdk.Rectangle) c_int;
    pub const getEmbeddedRect = gtk_icon_info_get_embedded_rect;

    /// Gets the filename for the icon. If the `GTK_ICON_LOOKUP_USE_BUILTIN`
    /// flag was passed to `gtk.IconTheme.lookupIcon`, there may be no
    /// filename if a builtin icon is returned; in this case, you should
    /// use `gtk.IconInfo.getBuiltinPixbuf`.
    extern fn gtk_icon_info_get_filename(p_icon_info: *IconInfo) ?[*:0]const u8;
    pub const getFilename = gtk_icon_info_get_filename;

    /// Checks if the icon is symbolic or not. This currently uses only
    /// the file name and not the file contents for determining this.
    /// This behaviour may change in the future.
    extern fn gtk_icon_info_is_symbolic(p_icon_info: *IconInfo) c_int;
    pub const isSymbolic = gtk_icon_info_is_symbolic;

    /// Renders an icon previously looked up in an icon theme using
    /// `gtk.IconTheme.lookupIcon`; the size will be based on the size
    /// passed to `gtk.IconTheme.lookupIcon`. Note that the resulting
    /// pixbuf may not be exactly this size; an icon theme may have icons
    /// that differ slightly from their nominal sizes, and in addition GTK+
    /// will avoid scaling icons that it considers sufficiently close to the
    /// requested size or for which the source image would have to be scaled
    /// up too far. (This maintains sharpness.). This behaviour can be changed
    /// by passing the `GTK_ICON_LOOKUP_FORCE_SIZE` flag when obtaining
    /// the `gtk.IconInfo`. If this flag has been specified, the pixbuf
    /// returned by this function will be scaled to the exact size.
    extern fn gtk_icon_info_load_icon(p_icon_info: *IconInfo, p_error: ?*?*glib.Error) ?*gdkpixbuf.Pixbuf;
    pub const loadIcon = gtk_icon_info_load_icon;

    /// Asynchronously load, render and scale an icon previously looked up
    /// from the icon theme using `gtk.IconTheme.lookupIcon`.
    ///
    /// For more details, see `gtk.IconInfo.loadIcon` which is the synchronous
    /// version of this call.
    extern fn gtk_icon_info_load_icon_async(p_icon_info: *IconInfo, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const loadIconAsync = gtk_icon_info_load_icon_async;

    /// Finishes an async icon load, see `gtk.IconInfo.loadIconAsync`.
    extern fn gtk_icon_info_load_icon_finish(p_icon_info: *IconInfo, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gdkpixbuf.Pixbuf;
    pub const loadIconFinish = gtk_icon_info_load_icon_finish;

    /// Renders an icon previously looked up in an icon theme using
    /// `gtk.IconTheme.lookupIcon`; the size will be based on the size
    /// passed to `gtk.IconTheme.lookupIcon`. Note that the resulting
    /// surface may not be exactly this size; an icon theme may have icons
    /// that differ slightly from their nominal sizes, and in addition GTK+
    /// will avoid scaling icons that it considers sufficiently close to the
    /// requested size or for which the source image would have to be scaled
    /// up too far. (This maintains sharpness.). This behaviour can be changed
    /// by passing the `GTK_ICON_LOOKUP_FORCE_SIZE` flag when obtaining
    /// the `gtk.IconInfo`. If this flag has been specified, the pixbuf
    /// returned by this function will be scaled to the exact size.
    extern fn gtk_icon_info_load_surface(p_icon_info: *IconInfo, p_for_window: ?*gdk.Window, p_error: ?*?*glib.Error) ?*cairo.Surface;
    pub const loadSurface = gtk_icon_info_load_surface;

    /// Loads an icon, modifying it to match the system colours for the foreground,
    /// success, warning and error colors provided. If the icon is not a symbolic
    /// one, the function will return the result from `gtk.IconInfo.loadIcon`.
    ///
    /// This allows loading symbolic icons that will match the system theme.
    ///
    /// Unless you are implementing a widget, you will want to use
    /// `gio.ThemedIcon.newWithDefaultFallbacks` to load the icon.
    ///
    /// As implementation details, the icon loaded needs to be of SVG type,
    /// contain the “symbolic” term as the last component of the icon name,
    /// and use the “fg”, “success”, “warning” and “error” CSS styles in the
    /// SVG file itself.
    ///
    /// See the [Symbolic Icons Specification](http://www.freedesktop.org/wiki/SymbolicIcons)
    /// for more information about symbolic icons.
    extern fn gtk_icon_info_load_symbolic(p_icon_info: *IconInfo, p_fg: *const gdk.RGBA, p_success_color: ?*const gdk.RGBA, p_warning_color: ?*const gdk.RGBA, p_error_color: ?*const gdk.RGBA, p_was_symbolic: ?*c_int, p_error: ?*?*glib.Error) ?*gdkpixbuf.Pixbuf;
    pub const loadSymbolic = gtk_icon_info_load_symbolic;

    /// Asynchronously load, render and scale a symbolic icon previously looked up
    /// from the icon theme using `gtk.IconTheme.lookupIcon`.
    ///
    /// For more details, see `gtk.IconInfo.loadSymbolic` which is the synchronous
    /// version of this call.
    extern fn gtk_icon_info_load_symbolic_async(p_icon_info: *IconInfo, p_fg: *const gdk.RGBA, p_success_color: ?*const gdk.RGBA, p_warning_color: ?*const gdk.RGBA, p_error_color: ?*const gdk.RGBA, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const loadSymbolicAsync = gtk_icon_info_load_symbolic_async;

    /// Finishes an async icon load, see `gtk.IconInfo.loadSymbolicAsync`.
    extern fn gtk_icon_info_load_symbolic_finish(p_icon_info: *IconInfo, p_res: *gio.AsyncResult, p_was_symbolic: ?*c_int, p_error: ?*?*glib.Error) ?*gdkpixbuf.Pixbuf;
    pub const loadSymbolicFinish = gtk_icon_info_load_symbolic_finish;

    /// Loads an icon, modifying it to match the system colors for the foreground,
    /// success, warning and error colors provided. If the icon is not a symbolic
    /// one, the function will return the result from `gtk.IconInfo.loadIcon`.
    /// This function uses the regular foreground color and the symbolic colors
    /// with the names “success_color”, “warning_color” and “error_color” from
    /// the context.
    ///
    /// This allows loading symbolic icons that will match the system theme.
    ///
    /// See `gtk.IconInfo.loadSymbolic` for more details.
    extern fn gtk_icon_info_load_symbolic_for_context(p_icon_info: *IconInfo, p_context: *gtk.StyleContext, p_was_symbolic: ?*c_int, p_error: ?*?*glib.Error) ?*gdkpixbuf.Pixbuf;
    pub const loadSymbolicForContext = gtk_icon_info_load_symbolic_for_context;

    /// Asynchronously load, render and scale a symbolic icon previously
    /// looked up from the icon theme using `gtk.IconTheme.lookupIcon`.
    ///
    /// For more details, see `gtk.IconInfo.loadSymbolicForContext`
    /// which is the synchronous version of this call.
    extern fn gtk_icon_info_load_symbolic_for_context_async(p_icon_info: *IconInfo, p_context: *gtk.StyleContext, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const loadSymbolicForContextAsync = gtk_icon_info_load_symbolic_for_context_async;

    /// Finishes an async icon load, see `gtk.IconInfo.loadSymbolicForContextAsync`.
    extern fn gtk_icon_info_load_symbolic_for_context_finish(p_icon_info: *IconInfo, p_res: *gio.AsyncResult, p_was_symbolic: ?*c_int, p_error: ?*?*glib.Error) ?*gdkpixbuf.Pixbuf;
    pub const loadSymbolicForContextFinish = gtk_icon_info_load_symbolic_for_context_finish;

    /// Loads an icon, modifying it to match the system colours for the foreground,
    /// success, warning and error colors provided. If the icon is not a symbolic
    /// one, the function will return the result from `gtk.IconInfo.loadIcon`.
    ///
    /// This allows loading symbolic icons that will match the system theme.
    ///
    /// See `gtk.IconInfo.loadSymbolic` for more details.
    extern fn gtk_icon_info_load_symbolic_for_style(p_icon_info: *IconInfo, p_style: *gtk.Style, p_state: gtk.StateType, p_was_symbolic: ?*c_int, p_error: ?*?*glib.Error) ?*gdkpixbuf.Pixbuf;
    pub const loadSymbolicForStyle = gtk_icon_info_load_symbolic_for_style;

    /// Sets whether the coordinates returned by `gtk.IconInfo.getEmbeddedRect`
    /// and `gtk.IconInfo.getAttachPoints` should be returned in their
    /// original form as specified in the icon theme, instead of scaled
    /// appropriately for the pixbuf returned by `gtk.IconInfo.loadIcon`.
    ///
    /// Raw coordinates are somewhat strange; they are specified to be with
    /// respect to the unscaled pixmap for PNG and XPM icons, but for SVG
    /// icons, they are in a 1000x1000 coordinate space that is scaled
    /// to the final size of the icon.  You can determine if the icon is an SVG
    /// icon by using `gtk.IconInfo.getFilename`, and seeing if it is non-`NULL`
    /// and ends in “.svg”.
    ///
    /// This function is provided primarily to allow compatibility wrappers
    /// for older API's, and is not expected to be useful for applications.
    extern fn gtk_icon_info_set_raw_coordinates(p_icon_info: *IconInfo, p_raw_coordinates: c_int) void;
    pub const setRawCoordinates = gtk_icon_info_set_raw_coordinates;

    extern fn gtk_icon_info_get_type() usize;
    pub const getGObjectType = gtk_icon_info_get_type;

    extern fn g_object_ref(p_self: *gtk.IconInfo) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.IconInfo) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *IconInfo, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.IconTheme` provides a facility for looking up icons by name
/// and size. The main reason for using a name rather than simply
/// providing a filename is to allow different icons to be used
/// depending on what “icon theme” is selected
/// by the user. The operation of icon themes on Linux and Unix
/// follows the [Icon Theme Specification](http://www.freedesktop.org/Standards/icon-theme-spec)
/// There is a fallback icon theme, named `hicolor`, where applications
/// should install their icons, but additional icon themes can be installed
/// as operating system vendors and users choose.
///
/// Named icons are similar to the deprecated [Stock Items][gtkstock],
/// and the distinction between the two may be a bit confusing.
/// A few things to keep in mind:
///
/// - Stock images usually are used in conjunction with
///   [Stock Items][gtkstock], such as `GTK_STOCK_OK` or
///   `GTK_STOCK_OPEN`. Named icons are easier to set up and therefore
///   are more useful for new icons that an application wants to
///   add, such as application icons or window icons.
///
/// - Stock images can only be loaded at the symbolic sizes defined
///   by the `gtk.IconSize` enumeration, or by custom sizes defined
///   by `gtk.iconSizeRegister`, while named icons are more flexible
///   and any pixel size can be specified.
///
/// - Because stock images are closely tied to stock items, and thus
///   to actions in the user interface, stock images may come in
///   multiple variants for different widget states or writing
///   directions.
///
/// A good rule of thumb is that if there is a stock image for what
/// you want to use, use it, otherwise use a named icon. It turns
/// out that internally stock images are generally defined in
/// terms of one or more named icons. (An example of the
/// more than one case is icons that depend on writing direction;
/// `GTK_STOCK_GO_FORWARD` uses the two themed icons
/// “gtk-stock-go-forward-ltr” and “gtk-stock-go-forward-rtl”.)
///
/// In many cases, named themes are used indirectly, via `gtk.Image`
/// or stock items, rather than directly, but looking up icons
/// directly is also simple. The `gtk.IconTheme` object acts
/// as a database of all the icons in the current theme. You
/// can create new `gtk.IconTheme` objects, but it’s much more
/// efficient to use the standard icon theme for the `gdk.Screen`
/// so that the icon information is shared with other people
/// looking up icons.
/// ```
/// GError *error = NULL;
/// GtkIconTheme *icon_theme;
/// GdkPixbuf *pixbuf;
///
/// icon_theme = gtk_icon_theme_get_default ();
/// pixbuf = gtk_icon_theme_load_icon (icon_theme,
///                                    "my-icon-name", // icon name
///                                    48, // icon size
///                                    0,  // flags
///                                    &error);
/// if (!pixbuf)
///   {
///     g_warning ("Couldn’t load icon: `s`", error->message);
///     g_error_free (error);
///   }
/// else
///   {
///     // Use the pixbuf
///     g_object_unref (pixbuf);
///   }
/// ```
pub const IconTheme = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.IconThemeClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.IconThemePrivate,

    pub const virtual_methods = struct {
        /// Signal emitted when the current icon theme is switched or
        ///    GTK+ detects that a change has occurred in the contents of the
        ///    current icon theme.
        pub const changed = struct {
            pub fn call(p_class: anytype, p_icon_theme: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(IconTheme.Class, p_class).f_changed.?(gobject.ext.as(IconTheme, p_icon_theme));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon_theme: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(IconTheme.Class, p_class).f_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// Emitted when the current icon theme is switched or GTK+ detects
        /// that a change has occurred in the contents of the current
        /// icon theme.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(IconTheme, p_instance))),
                    gobject.signalLookup("changed", IconTheme.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Registers a built-in icon for icon theme lookups. The idea
    /// of built-in icons is to allow an application or library
    /// that uses themed icons to function requiring files to
    /// be present in the file system. For instance, the default
    /// images for all of GTK+’s stock icons are registered
    /// as built-icons.
    ///
    /// In general, if you use `gtk.IconTheme.addBuiltinIcon`
    /// you should also install the icon in the icon theme, so
    /// that the icon is generally available.
    ///
    /// This function will generally be used with pixbufs loaded
    /// via `gdkpixbuf.Pixbuf.newFromInline`.
    extern fn gtk_icon_theme_add_builtin_icon(p_icon_name: [*:0]const u8, p_size: c_int, p_pixbuf: *gdkpixbuf.Pixbuf) void;
    pub const addBuiltinIcon = gtk_icon_theme_add_builtin_icon;

    /// Gets the icon theme for the default screen. See
    /// `gtk.IconTheme.getForScreen`.
    extern fn gtk_icon_theme_get_default() *gtk.IconTheme;
    pub const getDefault = gtk_icon_theme_get_default;

    /// Gets the icon theme object associated with `screen`; if this
    /// function has not previously been called for the given
    /// screen, a new icon theme object will be created and
    /// associated with the screen. Icon theme objects are
    /// fairly expensive to create, so using this function
    /// is usually a better choice than calling than `gtk.IconTheme.new`
    /// and setting the screen yourself; by using this function
    /// a single icon theme object will be shared between users.
    extern fn gtk_icon_theme_get_for_screen(p_screen: *gdk.Screen) *gtk.IconTheme;
    pub const getForScreen = gtk_icon_theme_get_for_screen;

    /// Creates a new icon theme object. Icon theme objects are used
    /// to lookup up an icon by name in a particular icon theme.
    /// Usually, you’ll want to use `gtk.IconTheme.getDefault`
    /// or `gtk.IconTheme.getForScreen` rather than creating
    /// a new icon theme object for scratch.
    extern fn gtk_icon_theme_new() *gtk.IconTheme;
    pub const new = gtk_icon_theme_new;

    /// Adds a resource path that will be looked at when looking
    /// for icons, similar to search paths.
    ///
    /// This function should be used to make application-specific icons
    /// available as part of the icon theme.
    ///
    /// The resources are considered as part of the hicolor icon theme
    /// and must be located in subdirectories that are defined in the
    /// hicolor icon theme, such as ``path`/16x16/actions/run.png`.
    /// Icons that are directly placed in the resource path instead
    /// of a subdirectory are also considered as ultimate fallback.
    extern fn gtk_icon_theme_add_resource_path(p_icon_theme: *IconTheme, p_path: [*:0]const u8) void;
    pub const addResourcePath = gtk_icon_theme_add_resource_path;

    /// Appends a directory to the search path.
    /// See `gtk.IconTheme.setSearchPath`.
    extern fn gtk_icon_theme_append_search_path(p_icon_theme: *IconTheme, p_path: [*:0]const u8) void;
    pub const appendSearchPath = gtk_icon_theme_append_search_path;

    /// Looks up a named icon and returns a `gtk.IconInfo` containing
    /// information such as the filename of the icon. The icon
    /// can then be rendered into a pixbuf using
    /// `gtk.IconInfo.loadIcon`. (`gtk.IconTheme.loadIcon`
    /// combines these two steps if all you need is the pixbuf.)
    ///
    /// If `icon_names` contains more than one name, this function
    /// tries them all in the given order before falling back to
    /// inherited icon themes.
    extern fn gtk_icon_theme_choose_icon(p_icon_theme: *IconTheme, p_icon_names: [*][*:0]const u8, p_size: c_int, p_flags: gtk.IconLookupFlags) ?*gtk.IconInfo;
    pub const chooseIcon = gtk_icon_theme_choose_icon;

    /// Looks up a named icon for a particular window scale and returns
    /// a `gtk.IconInfo` containing information such as the filename of the
    /// icon. The icon can then be rendered into a pixbuf using
    /// `gtk.IconInfo.loadIcon`. (`gtk.IconTheme.loadIcon`
    /// combines these two steps if all you need is the pixbuf.)
    ///
    /// If `icon_names` contains more than one name, this function
    /// tries them all in the given order before falling back to
    /// inherited icon themes.
    extern fn gtk_icon_theme_choose_icon_for_scale(p_icon_theme: *IconTheme, p_icon_names: [*][*:0]const u8, p_size: c_int, p_scale: c_int, p_flags: gtk.IconLookupFlags) ?*gtk.IconInfo;
    pub const chooseIconForScale = gtk_icon_theme_choose_icon_for_scale;

    /// Gets the name of an icon that is representative of the
    /// current theme (for instance, to use when presenting
    /// a list of themes to the user.)
    extern fn gtk_icon_theme_get_example_icon_name(p_icon_theme: *IconTheme) ?[*:0]u8;
    pub const getExampleIconName = gtk_icon_theme_get_example_icon_name;

    /// Returns an array of integers describing the sizes at which
    /// the icon is available without scaling. A size of -1 means
    /// that the icon is available in a scalable format. The array
    /// is zero-terminated.
    extern fn gtk_icon_theme_get_icon_sizes(p_icon_theme: *IconTheme, p_icon_name: [*:0]const u8) [*]c_int;
    pub const getIconSizes = gtk_icon_theme_get_icon_sizes;

    /// Gets the current search path. See `gtk.IconTheme.setSearchPath`.
    extern fn gtk_icon_theme_get_search_path(p_icon_theme: *IconTheme, p_path: ?*[*][*:0]u8, p_n_elements: *c_int) void;
    pub const getSearchPath = gtk_icon_theme_get_search_path;

    /// Checks whether an icon theme includes an icon
    /// for a particular name.
    extern fn gtk_icon_theme_has_icon(p_icon_theme: *IconTheme, p_icon_name: [*:0]const u8) c_int;
    pub const hasIcon = gtk_icon_theme_has_icon;

    /// Gets the list of contexts available within the current
    /// hierarchy of icon themes.
    /// See `gtk.IconTheme.listIcons` for details about contexts.
    extern fn gtk_icon_theme_list_contexts(p_icon_theme: *IconTheme) *glib.List;
    pub const listContexts = gtk_icon_theme_list_contexts;

    /// Lists the icons in the current icon theme. Only a subset
    /// of the icons can be listed by providing a context string.
    /// The set of values for the context string is system dependent,
    /// but will typically include such values as “Applications” and
    /// “MimeTypes”. Contexts are explained in the
    /// [Icon Theme Specification](http://www.freedesktop.org/wiki/Specifications/icon-theme-spec).
    /// The standard contexts are listed in the
    /// [Icon Naming Specification](http://www.freedesktop.org/wiki/Specifications/icon-naming-spec).
    /// Also see `gtk.IconTheme.listContexts`.
    extern fn gtk_icon_theme_list_icons(p_icon_theme: *IconTheme, p_context: ?[*:0]const u8) *glib.List;
    pub const listIcons = gtk_icon_theme_list_icons;

    /// Looks up an icon in an icon theme, scales it to the given size
    /// and renders it into a pixbuf. This is a convenience function;
    /// if more details about the icon are needed, use
    /// `gtk.IconTheme.lookupIcon` followed by `gtk.IconInfo.loadIcon`.
    ///
    /// Note that you probably want to listen for icon theme changes and
    /// update the icon. This is usually done by connecting to the
    /// GtkWidget::style-set signal. If for some reason you do not want to
    /// update the icon when the icon theme changes, you should consider
    /// using `gdkpixbuf.Pixbuf.copy` to make a private copy of the pixbuf
    /// returned by this function. Otherwise GTK+ may need to keep the old
    /// icon theme loaded, which would be a waste of memory.
    extern fn gtk_icon_theme_load_icon(p_icon_theme: *IconTheme, p_icon_name: [*:0]const u8, p_size: c_int, p_flags: gtk.IconLookupFlags, p_error: ?*?*glib.Error) ?*gdkpixbuf.Pixbuf;
    pub const loadIcon = gtk_icon_theme_load_icon;

    /// Looks up an icon in an icon theme for a particular window scale,
    /// scales it to the given size and renders it into a pixbuf. This is a
    /// convenience function; if more details about the icon are needed,
    /// use `gtk.IconTheme.lookupIcon` followed by
    /// `gtk.IconInfo.loadIcon`.
    ///
    /// Note that you probably want to listen for icon theme changes and
    /// update the icon. This is usually done by connecting to the
    /// GtkWidget::style-set signal. If for some reason you do not want to
    /// update the icon when the icon theme changes, you should consider
    /// using `gdkpixbuf.Pixbuf.copy` to make a private copy of the pixbuf
    /// returned by this function. Otherwise GTK+ may need to keep the old
    /// icon theme loaded, which would be a waste of memory.
    extern fn gtk_icon_theme_load_icon_for_scale(p_icon_theme: *IconTheme, p_icon_name: [*:0]const u8, p_size: c_int, p_scale: c_int, p_flags: gtk.IconLookupFlags, p_error: ?*?*glib.Error) ?*gdkpixbuf.Pixbuf;
    pub const loadIconForScale = gtk_icon_theme_load_icon_for_scale;

    /// Looks up an icon in an icon theme for a particular window scale,
    /// scales it to the given size and renders it into a cairo surface. This is a
    /// convenience function; if more details about the icon are needed,
    /// use `gtk.IconTheme.lookupIcon` followed by
    /// `gtk.IconInfo.loadSurface`.
    ///
    /// Note that you probably want to listen for icon theme changes and
    /// update the icon. This is usually done by connecting to the
    /// GtkWidget::style-set signal.
    extern fn gtk_icon_theme_load_surface(p_icon_theme: *IconTheme, p_icon_name: [*:0]const u8, p_size: c_int, p_scale: c_int, p_for_window: ?*gdk.Window, p_flags: gtk.IconLookupFlags, p_error: ?*?*glib.Error) ?*cairo.Surface;
    pub const loadSurface = gtk_icon_theme_load_surface;

    /// Looks up an icon and returns a `gtk.IconInfo` containing information
    /// such as the filename of the icon. The icon can then be rendered
    /// into a pixbuf using `gtk.IconInfo.loadIcon`.
    ///
    /// When rendering on displays with high pixel densities you should not
    /// use a `size` multiplied by the scaling factor returned by functions
    /// like `gdk.Window.getScaleFactor`. Instead, you should use
    /// `gtk.IconTheme.lookupByGiconForScale`, as the assets loaded
    /// for a given scaling factor may be different.
    extern fn gtk_icon_theme_lookup_by_gicon(p_icon_theme: *IconTheme, p_icon: *gio.Icon, p_size: c_int, p_flags: gtk.IconLookupFlags) ?*gtk.IconInfo;
    pub const lookupByGicon = gtk_icon_theme_lookup_by_gicon;

    /// Looks up an icon and returns a `gtk.IconInfo` containing information
    /// such as the filename of the icon. The icon can then be rendered into
    /// a pixbuf using `gtk.IconInfo.loadIcon`.
    extern fn gtk_icon_theme_lookup_by_gicon_for_scale(p_icon_theme: *IconTheme, p_icon: *gio.Icon, p_size: c_int, p_scale: c_int, p_flags: gtk.IconLookupFlags) ?*gtk.IconInfo;
    pub const lookupByGiconForScale = gtk_icon_theme_lookup_by_gicon_for_scale;

    /// Looks up a named icon and returns a `gtk.IconInfo` containing
    /// information such as the filename of the icon. The icon
    /// can then be rendered into a pixbuf using
    /// `gtk.IconInfo.loadIcon`. (`gtk.IconTheme.loadIcon`
    /// combines these two steps if all you need is the pixbuf.)
    ///
    /// When rendering on displays with high pixel densities you should not
    /// use a `size` multiplied by the scaling factor returned by functions
    /// like `gdk.Window.getScaleFactor`. Instead, you should use
    /// `gtk.IconTheme.lookupIconForScale`, as the assets loaded
    /// for a given scaling factor may be different.
    extern fn gtk_icon_theme_lookup_icon(p_icon_theme: *IconTheme, p_icon_name: [*:0]const u8, p_size: c_int, p_flags: gtk.IconLookupFlags) ?*gtk.IconInfo;
    pub const lookupIcon = gtk_icon_theme_lookup_icon;

    /// Looks up a named icon for a particular window scale and returns a
    /// `gtk.IconInfo` containing information such as the filename of the
    /// icon. The icon can then be rendered into a pixbuf using
    /// `gtk.IconInfo.loadIcon`. (`gtk.IconTheme.loadIcon` combines
    /// these two steps if all you need is the pixbuf.)
    extern fn gtk_icon_theme_lookup_icon_for_scale(p_icon_theme: *IconTheme, p_icon_name: [*:0]const u8, p_size: c_int, p_scale: c_int, p_flags: gtk.IconLookupFlags) ?*gtk.IconInfo;
    pub const lookupIconForScale = gtk_icon_theme_lookup_icon_for_scale;

    /// Prepends a directory to the search path.
    /// See `gtk.IconTheme.setSearchPath`.
    extern fn gtk_icon_theme_prepend_search_path(p_icon_theme: *IconTheme, p_path: [*:0]const u8) void;
    pub const prependSearchPath = gtk_icon_theme_prepend_search_path;

    /// Checks to see if the icon theme has changed; if it has, any
    /// currently cached information is discarded and will be reloaded
    /// next time `icon_theme` is accessed.
    extern fn gtk_icon_theme_rescan_if_needed(p_icon_theme: *IconTheme) c_int;
    pub const rescanIfNeeded = gtk_icon_theme_rescan_if_needed;

    /// Sets the name of the icon theme that the `gtk.IconTheme` object uses
    /// overriding system configuration. This function cannot be called
    /// on the icon theme objects returned from `gtk.IconTheme.getDefault`
    /// and `gtk.IconTheme.getForScreen`.
    extern fn gtk_icon_theme_set_custom_theme(p_icon_theme: *IconTheme, p_theme_name: ?[*:0]const u8) void;
    pub const setCustomTheme = gtk_icon_theme_set_custom_theme;

    /// Sets the screen for an icon theme; the screen is used
    /// to track the user’s currently configured icon theme,
    /// which might be different for different screens.
    extern fn gtk_icon_theme_set_screen(p_icon_theme: *IconTheme, p_screen: *gdk.Screen) void;
    pub const setScreen = gtk_icon_theme_set_screen;

    /// Sets the search path for the icon theme object. When looking
    /// for an icon theme, GTK+ will search for a subdirectory of
    /// one or more of the directories in `path` with the same name
    /// as the icon theme containing an index.theme file. (Themes from
    /// multiple of the path elements are combined to allow themes to be
    /// extended by adding icons in the user’s home directory.)
    ///
    /// In addition if an icon found isn’t found either in the current
    /// icon theme or the default icon theme, and an image file with
    /// the right name is found directly in one of the elements of
    /// `path`, then that image will be used for the icon name.
    /// (This is legacy feature, and new icons should be put
    /// into the fallback icon theme, which is called hicolor,
    /// rather than directly on the icon path.)
    extern fn gtk_icon_theme_set_search_path(p_icon_theme: *IconTheme, p_path: [*][*:0]const u8, p_n_elements: c_int) void;
    pub const setSearchPath = gtk_icon_theme_set_search_path;

    extern fn gtk_icon_theme_get_type() usize;
    pub const getGObjectType = gtk_icon_theme_get_type;

    extern fn g_object_ref(p_self: *gtk.IconTheme) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.IconTheme) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *IconTheme, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.IconView` provides an alternative view on a `gtk.TreeModel`.
/// It displays the model as a grid of icons with labels. Like
/// `gtk.TreeView`, it allows to select one or multiple items
/// (depending on the selection mode, see `gtk.IconView.setSelectionMode`).
/// In addition to selection with the arrow keys, `gtk.IconView` supports
/// rubberband selection, which is controlled by dragging the pointer.
///
/// Note that if the tree model is backed by an actual tree store (as
/// opposed to a flat list where the mapping to icons is obvious),
/// `gtk.IconView` will only display the first level of the tree and
/// ignore the tree’s branches.
///
/// # CSS nodes
///
/// ```
/// iconview.view
/// ╰── [rubberband]
/// ```
///
/// GtkIconView has a single CSS node with name iconview and style class .view.
/// For rubberband selection, a subnode with name rubberband is used.
pub const IconView = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.CellLayout, gtk.Scrollable };
    pub const Class = gtk.IconViewClass;
    f_parent: gtk.Container,
    f_priv: ?*gtk.IconViewPrivate,

    pub const virtual_methods = struct {
        pub const activate_cursor_item = struct {
            pub fn call(p_class: anytype, p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(IconView.Class, p_class).f_activate_cursor_item.?(gobject.ext.as(IconView, p_icon_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(IconView.Class, p_class).f_activate_cursor_item = @ptrCast(p_implementation);
            }
        };

        /// Activates the item determined by `path`.
        pub const item_activated = struct {
            pub fn call(p_class: anytype, p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath) void {
                return gobject.ext.as(IconView.Class, p_class).f_item_activated.?(gobject.ext.as(IconView, p_icon_view), p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath) callconv(.c) void) void {
                gobject.ext.as(IconView.Class, p_class).f_item_activated = @ptrCast(p_implementation);
            }
        };

        pub const move_cursor = struct {
            pub fn call(p_class: anytype, p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_step: gtk.MovementStep, p_count: c_int) c_int {
                return gobject.ext.as(IconView.Class, p_class).f_move_cursor.?(gobject.ext.as(IconView, p_icon_view), p_step, p_count);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_step: gtk.MovementStep, p_count: c_int) callconv(.c) c_int) void {
                gobject.ext.as(IconView.Class, p_class).f_move_cursor = @ptrCast(p_implementation);
            }
        };

        /// Selects all the icons. `icon_view` must has its selection mode set
        /// to `GTK_SELECTION_MULTIPLE`.
        pub const select_all = struct {
            pub fn call(p_class: anytype, p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(IconView.Class, p_class).f_select_all.?(gobject.ext.as(IconView, p_icon_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(IconView.Class, p_class).f_select_all = @ptrCast(p_implementation);
            }
        };

        pub const select_cursor_item = struct {
            pub fn call(p_class: anytype, p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(IconView.Class, p_class).f_select_cursor_item.?(gobject.ext.as(IconView, p_icon_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(IconView.Class, p_class).f_select_cursor_item = @ptrCast(p_implementation);
            }
        };

        pub const selection_changed = struct {
            pub fn call(p_class: anytype, p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(IconView.Class, p_class).f_selection_changed.?(gobject.ext.as(IconView, p_icon_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(IconView.Class, p_class).f_selection_changed = @ptrCast(p_implementation);
            }
        };

        pub const toggle_cursor_item = struct {
            pub fn call(p_class: anytype, p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(IconView.Class, p_class).f_toggle_cursor_item.?(gobject.ext.as(IconView, p_icon_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(IconView.Class, p_class).f_toggle_cursor_item = @ptrCast(p_implementation);
            }
        };

        /// Unselects all the icons.
        pub const unselect_all = struct {
            pub fn call(p_class: anytype, p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(IconView.Class, p_class).f_unselect_all.?(gobject.ext.as(IconView, p_icon_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(IconView.Class, p_class).f_unselect_all = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The activate-on-single-click property specifies whether the "item-activated" signal
        /// will be emitted after a single click.
        pub const activate_on_single_click = struct {
            pub const name = "activate-on-single-click";

            pub const Type = c_int;
        };

        /// The `gtk.CellArea` used to layout cell renderers for this view.
        ///
        /// If no area is specified when creating the icon view with `gtk.IconView.newWithArea`
        /// a `gtk.CellAreaBox` will be used.
        pub const cell_area = struct {
            pub const name = "cell-area";

            pub const Type = ?*gtk.CellArea;
        };

        /// The column-spacing property specifies the space which is inserted between
        /// the columns of the icon view.
        pub const column_spacing = struct {
            pub const name = "column-spacing";

            pub const Type = c_int;
        };

        /// The columns property contains the number of the columns in which the
        /// items should be displayed. If it is -1, the number of columns will
        /// be chosen automatically to fill the available area.
        pub const columns = struct {
            pub const name = "columns";

            pub const Type = c_int;
        };

        /// The item-orientation property specifies how the cells (i.e. the icon and
        /// the text) of the item are positioned relative to each other.
        pub const item_orientation = struct {
            pub const name = "item-orientation";

            pub const Type = gtk.Orientation;
        };

        /// The item-padding property specifies the padding around each
        /// of the icon view's item.
        pub const item_padding = struct {
            pub const name = "item-padding";

            pub const Type = c_int;
        };

        /// The item-width property specifies the width to use for each item.
        /// If it is set to -1, the icon view will automatically determine a
        /// suitable item size.
        pub const item_width = struct {
            pub const name = "item-width";

            pub const Type = c_int;
        };

        /// The margin property specifies the space which is inserted
        /// at the edges of the icon view.
        pub const margin = struct {
            pub const name = "margin";

            pub const Type = c_int;
        };

        /// The ::markup-column property contains the number of the model column
        /// containing markup information to be displayed. The markup column must be
        /// of type `G_TYPE_STRING`. If this property and the :text-column property
        /// are both set to column numbers, it overrides the text column.
        /// If both are set to -1, no texts are displayed.
        pub const markup_column = struct {
            pub const name = "markup-column";

            pub const Type = c_int;
        };

        pub const model = struct {
            pub const name = "model";

            pub const Type = ?*gtk.TreeModel;
        };

        /// The ::pixbuf-column property contains the number of the model column
        /// containing the pixbufs which are displayed. The pixbuf column must be
        /// of type `GDK_TYPE_PIXBUF`. Setting this property to -1 turns off the
        /// display of pixbufs.
        pub const pixbuf_column = struct {
            pub const name = "pixbuf-column";

            pub const Type = c_int;
        };

        /// The reorderable property specifies if the items can be reordered
        /// by DND.
        pub const reorderable = struct {
            pub const name = "reorderable";

            pub const Type = c_int;
        };

        /// The row-spacing property specifies the space which is inserted between
        /// the rows of the icon view.
        pub const row_spacing = struct {
            pub const name = "row-spacing";

            pub const Type = c_int;
        };

        /// The ::selection-mode property specifies the selection mode of
        /// icon view. If the mode is `GTK_SELECTION_MULTIPLE`, rubberband selection
        /// is enabled, for the other modes, only keyboard selection is possible.
        pub const selection_mode = struct {
            pub const name = "selection-mode";

            pub const Type = gtk.SelectionMode;
        };

        /// The spacing property specifies the space which is inserted between
        /// the cells (i.e. the icon and the text) of an item.
        pub const spacing = struct {
            pub const name = "spacing";

            pub const Type = c_int;
        };

        /// The ::text-column property contains the number of the model column
        /// containing the texts which are displayed. The text column must be
        /// of type `G_TYPE_STRING`. If this property and the :markup-column
        /// property are both set to -1, no texts are displayed.
        pub const text_column = struct {
            pub const name = "text-column";

            pub const Type = c_int;
        };

        pub const tooltip_column = struct {
            pub const name = "tooltip-column";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// A [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user activates the currently
        /// focused item.
        ///
        /// Applications should not connect to it, but may emit it with
        /// `gobject.signalEmitByName` if they need to control activation
        /// programmatically.
        ///
        /// The default bindings for this signal are Space, Return and Enter.
        pub const activate_cursor_item = struct {
            pub const name = "activate-cursor-item";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(IconView, p_instance))),
                    gobject.signalLookup("activate-cursor-item", IconView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::item-activated signal is emitted when the method
        /// `gtk.IconView.itemActivated` is called, when the user double
        /// clicks an item with the "activate-on-single-click" property set
        /// to `FALSE`, or when the user single clicks an item when the
        /// "activate-on-single-click" property set to `TRUE`. It is also
        /// emitted when a non-editable item is selected and one of the keys:
        /// Space, Return or Enter is pressed.
        pub const item_activated = struct {
            pub const name = "item-activated";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_path: *gtk.TreePath, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(IconView, p_instance))),
                    gobject.signalLookup("item-activated", IconView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::move-cursor signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user initiates a cursor movement.
        ///
        /// Applications should not connect to it, but may emit it with
        /// `gobject.signalEmitByName` if they need to control the cursor
        /// programmatically.
        ///
        /// The default bindings for this signal include
        /// - Arrow keys which move by individual steps
        /// - Home/End keys which move to the first/last item
        /// - PageUp/PageDown which move by "pages"
        /// All of these will extend the selection when combined with
        /// the Shift modifier.
        pub const move_cursor = struct {
            pub const name = "move-cursor";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_step: gtk.MovementStep, p_count: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(IconView, p_instance))),
                    gobject.signalLookup("move-cursor", IconView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// A [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user selects all items.
        ///
        /// Applications should not connect to it, but may emit it with
        /// `gobject.signalEmitByName` if they need to control selection
        /// programmatically.
        ///
        /// The default binding for this signal is Ctrl-a.
        pub const select_all = struct {
            pub const name = "select-all";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(IconView, p_instance))),
                    gobject.signalLookup("select-all", IconView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// A [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user selects the item that is currently
        /// focused.
        ///
        /// Applications should not connect to it, but may emit it with
        /// `gobject.signalEmitByName` if they need to control selection
        /// programmatically.
        ///
        /// There is no default binding for this signal.
        pub const select_cursor_item = struct {
            pub const name = "select-cursor-item";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(IconView, p_instance))),
                    gobject.signalLookup("select-cursor-item", IconView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::selection-changed signal is emitted when the selection
        /// (i.e. the set of selected items) changes.
        pub const selection_changed = struct {
            pub const name = "selection-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(IconView, p_instance))),
                    gobject.signalLookup("selection-changed", IconView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// A [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user toggles whether the currently
        /// focused item is selected or not. The exact effect of this
        /// depend on the selection mode.
        ///
        /// Applications should not connect to it, but may emit it with
        /// `gobject.signalEmitByName` if they need to control selection
        /// programmatically.
        ///
        /// There is no default binding for this signal is Ctrl-Space.
        pub const toggle_cursor_item = struct {
            pub const name = "toggle-cursor-item";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(IconView, p_instance))),
                    gobject.signalLookup("toggle-cursor-item", IconView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// A [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user unselects all items.
        ///
        /// Applications should not connect to it, but may emit it with
        /// `gobject.signalEmitByName` if they need to control selection
        /// programmatically.
        ///
        /// The default binding for this signal is Ctrl-Shift-a.
        pub const unselect_all = struct {
            pub const name = "unselect-all";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(IconView, p_instance))),
                    gobject.signalLookup("unselect-all", IconView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.IconView` widget
    extern fn gtk_icon_view_new() *gtk.IconView;
    pub const new = gtk_icon_view_new;

    /// Creates a new `gtk.IconView` widget using the
    /// specified `area` to layout cells inside the icons.
    extern fn gtk_icon_view_new_with_area(p_area: *gtk.CellArea) *gtk.IconView;
    pub const newWithArea = gtk_icon_view_new_with_area;

    /// Creates a new `gtk.IconView` widget with the model `model`.
    extern fn gtk_icon_view_new_with_model(p_model: *gtk.TreeModel) *gtk.IconView;
    pub const newWithModel = gtk_icon_view_new_with_model;

    /// Converts widget coordinates to coordinates for the bin_window,
    /// as expected by e.g. `gtk.IconView.getPathAtPos`.
    extern fn gtk_icon_view_convert_widget_to_bin_window_coords(p_icon_view: *IconView, p_wx: c_int, p_wy: c_int, p_bx: *c_int, p_by: *c_int) void;
    pub const convertWidgetToBinWindowCoords = gtk_icon_view_convert_widget_to_bin_window_coords;

    /// Creates a `cairo.Surface` representation of the item at `path`.
    /// This image is used for a drag icon.
    extern fn gtk_icon_view_create_drag_icon(p_icon_view: *IconView, p_path: *gtk.TreePath) *cairo.Surface;
    pub const createDragIcon = gtk_icon_view_create_drag_icon;

    /// Turns `icon_view` into a drop destination for automatic DND. Calling this
    /// method sets `gtk.IconView.properties.reorderable` to `FALSE`.
    extern fn gtk_icon_view_enable_model_drag_dest(p_icon_view: *IconView, p_targets: [*]const gtk.TargetEntry, p_n_targets: c_int, p_actions: gdk.DragAction) void;
    pub const enableModelDragDest = gtk_icon_view_enable_model_drag_dest;

    /// Turns `icon_view` into a drag source for automatic DND. Calling this
    /// method sets `gtk.IconView.properties.reorderable` to `FALSE`.
    extern fn gtk_icon_view_enable_model_drag_source(p_icon_view: *IconView, p_start_button_mask: gdk.ModifierType, p_targets: [*]const gtk.TargetEntry, p_n_targets: c_int, p_actions: gdk.DragAction) void;
    pub const enableModelDragSource = gtk_icon_view_enable_model_drag_source;

    /// Gets the setting set by `gtk.IconView.setActivateOnSingleClick`.
    extern fn gtk_icon_view_get_activate_on_single_click(p_icon_view: *IconView) c_int;
    pub const getActivateOnSingleClick = gtk_icon_view_get_activate_on_single_click;

    /// Fills the bounding rectangle in widget coordinates for the cell specified by
    /// `path` and `cell`. If `cell` is `NULL` the main cell area is used.
    ///
    /// This function is only valid if `icon_view` is realized.
    extern fn gtk_icon_view_get_cell_rect(p_icon_view: *IconView, p_path: *gtk.TreePath, p_cell: ?*gtk.CellRenderer, p_rect: *gdk.Rectangle) c_int;
    pub const getCellRect = gtk_icon_view_get_cell_rect;

    /// Returns the value of the ::column-spacing property.
    extern fn gtk_icon_view_get_column_spacing(p_icon_view: *IconView) c_int;
    pub const getColumnSpacing = gtk_icon_view_get_column_spacing;

    /// Returns the value of the ::columns property.
    extern fn gtk_icon_view_get_columns(p_icon_view: *IconView) c_int;
    pub const getColumns = gtk_icon_view_get_columns;

    /// Fills in `path` and `cell` with the current cursor path and cell.
    /// If the cursor isn’t currently set, then *`path` will be `NULL`.
    /// If no cell currently has focus, then *`cell` will be `NULL`.
    ///
    /// The returned `gtk.TreePath` must be freed with `gtk.TreePath.free`.
    extern fn gtk_icon_view_get_cursor(p_icon_view: *IconView, p_path: ?**gtk.TreePath, p_cell: ?**gtk.CellRenderer) c_int;
    pub const getCursor = gtk_icon_view_get_cursor;

    /// Determines the destination item for a given position.
    extern fn gtk_icon_view_get_dest_item_at_pos(p_icon_view: *IconView, p_drag_x: c_int, p_drag_y: c_int, p_path: ?**gtk.TreePath, p_pos: ?*gtk.IconViewDropPosition) c_int;
    pub const getDestItemAtPos = gtk_icon_view_get_dest_item_at_pos;

    /// Gets information about the item that is highlighted for feedback.
    extern fn gtk_icon_view_get_drag_dest_item(p_icon_view: *IconView, p_path: ?**gtk.TreePath, p_pos: ?*gtk.IconViewDropPosition) void;
    pub const getDragDestItem = gtk_icon_view_get_drag_dest_item;

    /// Finds the path at the point (`x`, `y`), relative to bin_window coordinates.
    /// In contrast to `gtk.IconView.getPathAtPos`, this function also
    /// obtains the cell at the specified position. The returned path should
    /// be freed with `gtk.TreePath.free`.
    /// See `gtk.IconView.convertWidgetToBinWindowCoords` for converting
    /// widget coordinates to bin_window coordinates.
    extern fn gtk_icon_view_get_item_at_pos(p_icon_view: *IconView, p_x: c_int, p_y: c_int, p_path: ?**gtk.TreePath, p_cell: ?**gtk.CellRenderer) c_int;
    pub const getItemAtPos = gtk_icon_view_get_item_at_pos;

    /// Gets the column in which the item `path` is currently
    /// displayed. Column numbers start at 0.
    extern fn gtk_icon_view_get_item_column(p_icon_view: *IconView, p_path: *gtk.TreePath) c_int;
    pub const getItemColumn = gtk_icon_view_get_item_column;

    /// Returns the value of the ::item-orientation property which determines
    /// whether the labels are drawn beside the icons instead of below.
    extern fn gtk_icon_view_get_item_orientation(p_icon_view: *IconView) gtk.Orientation;
    pub const getItemOrientation = gtk_icon_view_get_item_orientation;

    /// Returns the value of the ::item-padding property.
    extern fn gtk_icon_view_get_item_padding(p_icon_view: *IconView) c_int;
    pub const getItemPadding = gtk_icon_view_get_item_padding;

    /// Gets the row in which the item `path` is currently
    /// displayed. Row numbers start at 0.
    extern fn gtk_icon_view_get_item_row(p_icon_view: *IconView, p_path: *gtk.TreePath) c_int;
    pub const getItemRow = gtk_icon_view_get_item_row;

    /// Returns the value of the ::item-width property.
    extern fn gtk_icon_view_get_item_width(p_icon_view: *IconView) c_int;
    pub const getItemWidth = gtk_icon_view_get_item_width;

    /// Returns the value of the ::margin property.
    extern fn gtk_icon_view_get_margin(p_icon_view: *IconView) c_int;
    pub const getMargin = gtk_icon_view_get_margin;

    /// Returns the column with markup text for `icon_view`.
    extern fn gtk_icon_view_get_markup_column(p_icon_view: *IconView) c_int;
    pub const getMarkupColumn = gtk_icon_view_get_markup_column;

    /// Returns the model the `gtk.IconView` is based on.  Returns `NULL` if the
    /// model is unset.
    extern fn gtk_icon_view_get_model(p_icon_view: *IconView) ?*gtk.TreeModel;
    pub const getModel = gtk_icon_view_get_model;

    /// Finds the path at the point (`x`, `y`), relative to bin_window coordinates.
    /// See `gtk.IconView.getItemAtPos`, if you are also interested in
    /// the cell at the specified position.
    /// See `gtk.IconView.convertWidgetToBinWindowCoords` for converting
    /// widget coordinates to bin_window coordinates.
    extern fn gtk_icon_view_get_path_at_pos(p_icon_view: *IconView, p_x: c_int, p_y: c_int) ?*gtk.TreePath;
    pub const getPathAtPos = gtk_icon_view_get_path_at_pos;

    /// Returns the column with pixbufs for `icon_view`.
    extern fn gtk_icon_view_get_pixbuf_column(p_icon_view: *IconView) c_int;
    pub const getPixbufColumn = gtk_icon_view_get_pixbuf_column;

    /// Retrieves whether the user can reorder the list via drag-and-drop.
    /// See `gtk.IconView.setReorderable`.
    extern fn gtk_icon_view_get_reorderable(p_icon_view: *IconView) c_int;
    pub const getReorderable = gtk_icon_view_get_reorderable;

    /// Returns the value of the ::row-spacing property.
    extern fn gtk_icon_view_get_row_spacing(p_icon_view: *IconView) c_int;
    pub const getRowSpacing = gtk_icon_view_get_row_spacing;

    /// Creates a list of paths of all selected items. Additionally, if you are
    /// planning on modifying the model after calling this function, you may
    /// want to convert the returned list into a list of `GtkTreeRowReferences`.
    /// To do this, you can use `gtk.TreeRowReference.new`.
    ///
    /// To free the return value, use:
    /// ```
    /// g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
    /// ```
    extern fn gtk_icon_view_get_selected_items(p_icon_view: *IconView) *glib.List;
    pub const getSelectedItems = gtk_icon_view_get_selected_items;

    /// Gets the selection mode of the `icon_view`.
    extern fn gtk_icon_view_get_selection_mode(p_icon_view: *IconView) gtk.SelectionMode;
    pub const getSelectionMode = gtk_icon_view_get_selection_mode;

    /// Returns the value of the ::spacing property.
    extern fn gtk_icon_view_get_spacing(p_icon_view: *IconView) c_int;
    pub const getSpacing = gtk_icon_view_get_spacing;

    /// Returns the column with text for `icon_view`.
    extern fn gtk_icon_view_get_text_column(p_icon_view: *IconView) c_int;
    pub const getTextColumn = gtk_icon_view_get_text_column;

    /// Returns the column of `icon_view`’s model which is being used for
    /// displaying tooltips on `icon_view`’s rows.
    extern fn gtk_icon_view_get_tooltip_column(p_icon_view: *IconView) c_int;
    pub const getTooltipColumn = gtk_icon_view_get_tooltip_column;

    /// This function is supposed to be used in a `gtk.Widget.signals.query`-tooltip
    /// signal handler for `gtk.IconView`.  The `x`, `y` and `keyboard_tip` values
    /// which are received in the signal handler, should be passed to this
    /// function without modification.
    ///
    /// The return value indicates whether there is an icon view item at the given
    /// coordinates (`TRUE`) or not (`FALSE`) for mouse tooltips. For keyboard
    /// tooltips the item returned will be the cursor item. When `TRUE`, then any of
    /// `model`, `path` and `iter` which have been provided will be set to point to
    /// that row and the corresponding model. `x` and `y` will always be converted
    /// to be relative to `icon_view`’s bin_window if `keyboard_tooltip` is `FALSE`.
    extern fn gtk_icon_view_get_tooltip_context(p_icon_view: *IconView, p_x: *c_int, p_y: *c_int, p_keyboard_tip: c_int, p_model: ?**gtk.TreeModel, p_path: ?**gtk.TreePath, p_iter: ?*gtk.TreeIter) c_int;
    pub const getTooltipContext = gtk_icon_view_get_tooltip_context;

    /// Sets `start_path` and `end_path` to be the first and last visible path.
    /// Note that there may be invisible paths in between.
    ///
    /// Both paths should be freed with `gtk.TreePath.free` after use.
    extern fn gtk_icon_view_get_visible_range(p_icon_view: *IconView, p_start_path: ?**gtk.TreePath, p_end_path: ?**gtk.TreePath) c_int;
    pub const getVisibleRange = gtk_icon_view_get_visible_range;

    /// Activates the item determined by `path`.
    extern fn gtk_icon_view_item_activated(p_icon_view: *IconView, p_path: *gtk.TreePath) void;
    pub const itemActivated = gtk_icon_view_item_activated;

    /// Returns `TRUE` if the icon pointed to by `path` is currently
    /// selected. If `path` does not point to a valid location, `FALSE` is returned.
    extern fn gtk_icon_view_path_is_selected(p_icon_view: *IconView, p_path: *gtk.TreePath) c_int;
    pub const pathIsSelected = gtk_icon_view_path_is_selected;

    /// Moves the alignments of `icon_view` to the position specified by `path`.
    /// `row_align` determines where the row is placed, and `col_align` determines
    /// where `column` is placed.  Both are expected to be between 0.0 and 1.0.
    /// 0.0 means left/top alignment, 1.0 means right/bottom alignment, 0.5 means
    /// center.
    ///
    /// If `use_align` is `FALSE`, then the alignment arguments are ignored, and the
    /// tree does the minimum amount of work to scroll the item onto the screen.
    /// This means that the item will be scrolled to the edge closest to its current
    /// position.  If the item is currently visible on the screen, nothing is done.
    ///
    /// This function only works if the model is set, and `path` is a valid row on
    /// the model. If the model changes before the `icon_view` is realized, the
    /// centered path will be modified to reflect this change.
    extern fn gtk_icon_view_scroll_to_path(p_icon_view: *IconView, p_path: *gtk.TreePath, p_use_align: c_int, p_row_align: f32, p_col_align: f32) void;
    pub const scrollToPath = gtk_icon_view_scroll_to_path;

    /// Selects all the icons. `icon_view` must has its selection mode set
    /// to `GTK_SELECTION_MULTIPLE`.
    extern fn gtk_icon_view_select_all(p_icon_view: *IconView) void;
    pub const selectAll = gtk_icon_view_select_all;

    /// Selects the row at `path`.
    extern fn gtk_icon_view_select_path(p_icon_view: *IconView, p_path: *gtk.TreePath) void;
    pub const selectPath = gtk_icon_view_select_path;

    /// Calls a function for each selected icon. Note that the model or
    /// selection cannot be modified from within this function.
    extern fn gtk_icon_view_selected_foreach(p_icon_view: *IconView, p_func: gtk.IconViewForeachFunc, p_data: ?*anyopaque) void;
    pub const selectedForeach = gtk_icon_view_selected_foreach;

    /// Causes the `gtk.IconView.signals.item`-activated signal to be emitted on
    /// a single click instead of a double click.
    extern fn gtk_icon_view_set_activate_on_single_click(p_icon_view: *IconView, p_single: c_int) void;
    pub const setActivateOnSingleClick = gtk_icon_view_set_activate_on_single_click;

    /// Sets the ::column-spacing property which specifies the space
    /// which is inserted between the columns of the icon view.
    extern fn gtk_icon_view_set_column_spacing(p_icon_view: *IconView, p_column_spacing: c_int) void;
    pub const setColumnSpacing = gtk_icon_view_set_column_spacing;

    /// Sets the ::columns property which determines in how
    /// many columns the icons are arranged. If `columns` is
    /// -1, the number of columns will be chosen automatically
    /// to fill the available area.
    extern fn gtk_icon_view_set_columns(p_icon_view: *IconView, p_columns: c_int) void;
    pub const setColumns = gtk_icon_view_set_columns;

    /// Sets the current keyboard focus to be at `path`, and selects it.  This is
    /// useful when you want to focus the user’s attention on a particular item.
    /// If `cell` is not `NULL`, then focus is given to the cell specified by
    /// it. Additionally, if `start_editing` is `TRUE`, then editing should be
    /// started in the specified cell.
    ///
    /// This function is often followed by `gtk_widget_grab_focus
    /// (icon_view)` in order to give keyboard focus to the widget.
    /// Please note that editing can only happen when the widget is realized.
    extern fn gtk_icon_view_set_cursor(p_icon_view: *IconView, p_path: *gtk.TreePath, p_cell: ?*gtk.CellRenderer, p_start_editing: c_int) void;
    pub const setCursor = gtk_icon_view_set_cursor;

    /// Sets the item that is highlighted for feedback.
    extern fn gtk_icon_view_set_drag_dest_item(p_icon_view: *IconView, p_path: ?*gtk.TreePath, p_pos: gtk.IconViewDropPosition) void;
    pub const setDragDestItem = gtk_icon_view_set_drag_dest_item;

    /// Sets the ::item-orientation property which determines whether the labels
    /// are drawn beside the icons instead of below.
    extern fn gtk_icon_view_set_item_orientation(p_icon_view: *IconView, p_orientation: gtk.Orientation) void;
    pub const setItemOrientation = gtk_icon_view_set_item_orientation;

    /// Sets the `gtk.IconView.properties.item`-padding property which specifies the padding
    /// around each of the icon view’s items.
    extern fn gtk_icon_view_set_item_padding(p_icon_view: *IconView, p_item_padding: c_int) void;
    pub const setItemPadding = gtk_icon_view_set_item_padding;

    /// Sets the ::item-width property which specifies the width
    /// to use for each item. If it is set to -1, the icon view will
    /// automatically determine a suitable item size.
    extern fn gtk_icon_view_set_item_width(p_icon_view: *IconView, p_item_width: c_int) void;
    pub const setItemWidth = gtk_icon_view_set_item_width;

    /// Sets the ::margin property which specifies the space
    /// which is inserted at the top, bottom, left and right
    /// of the icon view.
    extern fn gtk_icon_view_set_margin(p_icon_view: *IconView, p_margin: c_int) void;
    pub const setMargin = gtk_icon_view_set_margin;

    /// Sets the column with markup information for `icon_view` to be
    /// `column`. The markup column must be of type `G_TYPE_STRING`.
    /// If the markup column is set to something, it overrides
    /// the text column set by `gtk.IconView.setTextColumn`.
    extern fn gtk_icon_view_set_markup_column(p_icon_view: *IconView, p_column: c_int) void;
    pub const setMarkupColumn = gtk_icon_view_set_markup_column;

    /// Sets the model for a `gtk.IconView`.
    /// If the `icon_view` already has a model set, it will remove
    /// it before setting the new model.  If `model` is `NULL`, then
    /// it will unset the old model.
    extern fn gtk_icon_view_set_model(p_icon_view: *IconView, p_model: ?*gtk.TreeModel) void;
    pub const setModel = gtk_icon_view_set_model;

    /// Sets the column with pixbufs for `icon_view` to be `column`. The pixbuf
    /// column must be of type `GDK_TYPE_PIXBUF`
    extern fn gtk_icon_view_set_pixbuf_column(p_icon_view: *IconView, p_column: c_int) void;
    pub const setPixbufColumn = gtk_icon_view_set_pixbuf_column;

    /// This function is a convenience function to allow you to reorder models that
    /// support the `gtk.TreeDragSourceIface` and the `gtk.TreeDragDestIface`.  Both
    /// `gtk.TreeStore` and `gtk.ListStore` support these.  If `reorderable` is `TRUE`, then
    /// the user can reorder the model by dragging and dropping rows.  The
    /// developer can listen to these changes by connecting to the model's
    /// row_inserted and row_deleted signals. The reordering is implemented by setting up
    /// the icon view as a drag source and destination. Therefore, drag and
    /// drop can not be used in a reorderable view for any other purpose.
    ///
    /// This function does not give you any degree of control over the order -- any
    /// reordering is allowed.  If more control is needed, you should probably
    /// handle drag and drop manually.
    extern fn gtk_icon_view_set_reorderable(p_icon_view: *IconView, p_reorderable: c_int) void;
    pub const setReorderable = gtk_icon_view_set_reorderable;

    /// Sets the ::row-spacing property which specifies the space
    /// which is inserted between the rows of the icon view.
    extern fn gtk_icon_view_set_row_spacing(p_icon_view: *IconView, p_row_spacing: c_int) void;
    pub const setRowSpacing = gtk_icon_view_set_row_spacing;

    /// Sets the selection mode of the `icon_view`.
    extern fn gtk_icon_view_set_selection_mode(p_icon_view: *IconView, p_mode: gtk.SelectionMode) void;
    pub const setSelectionMode = gtk_icon_view_set_selection_mode;

    /// Sets the ::spacing property which specifies the space
    /// which is inserted between the cells (i.e. the icon and
    /// the text) of an item.
    extern fn gtk_icon_view_set_spacing(p_icon_view: *IconView, p_spacing: c_int) void;
    pub const setSpacing = gtk_icon_view_set_spacing;

    /// Sets the column with text for `icon_view` to be `column`. The text
    /// column must be of type `G_TYPE_STRING`.
    extern fn gtk_icon_view_set_text_column(p_icon_view: *IconView, p_column: c_int) void;
    pub const setTextColumn = gtk_icon_view_set_text_column;

    /// Sets the tip area of `tooltip` to the area which `cell` occupies in
    /// the item pointed to by `path`. See also `gtk.Tooltip.setTipArea`.
    ///
    /// See also `gtk.IconView.setTooltipColumn` for a simpler alternative.
    extern fn gtk_icon_view_set_tooltip_cell(p_icon_view: *IconView, p_tooltip: *gtk.Tooltip, p_path: *gtk.TreePath, p_cell: ?*gtk.CellRenderer) void;
    pub const setTooltipCell = gtk_icon_view_set_tooltip_cell;

    /// If you only plan to have simple (text-only) tooltips on full items, you
    /// can use this function to have `gtk.IconView` handle these automatically
    /// for you. `column` should be set to the column in `icon_view`’s model
    /// containing the tooltip texts, or -1 to disable this feature.
    ///
    /// When enabled, `gtk.Widget.properties.has`-tooltip will be set to `TRUE` and
    /// `icon_view` will connect a `gtk.Widget.signals.query`-tooltip signal handler.
    ///
    /// Note that the signal handler sets the text with `gtk.Tooltip.setMarkup`,
    /// so &, <, etc have to be escaped in the text.
    extern fn gtk_icon_view_set_tooltip_column(p_icon_view: *IconView, p_column: c_int) void;
    pub const setTooltipColumn = gtk_icon_view_set_tooltip_column;

    /// Sets the tip area of `tooltip` to be the area covered by the item at `path`.
    /// See also `gtk.IconView.setTooltipColumn` for a simpler alternative.
    /// See also `gtk.Tooltip.setTipArea`.
    extern fn gtk_icon_view_set_tooltip_item(p_icon_view: *IconView, p_tooltip: *gtk.Tooltip, p_path: *gtk.TreePath) void;
    pub const setTooltipItem = gtk_icon_view_set_tooltip_item;

    /// Unselects all the icons.
    extern fn gtk_icon_view_unselect_all(p_icon_view: *IconView) void;
    pub const unselectAll = gtk_icon_view_unselect_all;

    /// Unselects the row at `path`.
    extern fn gtk_icon_view_unselect_path(p_icon_view: *IconView, p_path: *gtk.TreePath) void;
    pub const unselectPath = gtk_icon_view_unselect_path;

    /// Undoes the effect of `gtk.IconView.enableModelDragDest`. Calling this
    /// method sets `gtk.IconView.properties.reorderable` to `FALSE`.
    extern fn gtk_icon_view_unset_model_drag_dest(p_icon_view: *IconView) void;
    pub const unsetModelDragDest = gtk_icon_view_unset_model_drag_dest;

    /// Undoes the effect of `gtk.IconView.enableModelDragSource`. Calling this
    /// method sets `gtk.IconView.properties.reorderable` to `FALSE`.
    extern fn gtk_icon_view_unset_model_drag_source(p_icon_view: *IconView) void;
    pub const unsetModelDragSource = gtk_icon_view_unset_model_drag_source;

    extern fn gtk_icon_view_get_type() usize;
    pub const getGObjectType = gtk_icon_view_get_type;

    extern fn g_object_ref(p_self: *gtk.IconView) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.IconView) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *IconView, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IconViewAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Selection };
    pub const Class = gtk.IconViewAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.IconViewAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_icon_view_accessible_get_type() usize;
    pub const getGObjectType = gtk_icon_view_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.IconViewAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.IconViewAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *IconViewAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Image` widget displays an image. Various kinds of object
/// can be displayed as an image; most typically, you would load a
/// `gdkpixbuf.Pixbuf` ("pixel buffer") from a file, and then display that.
/// There’s a convenience function to do this, `gtk.Image.newFromFile`,
/// used as follows:
/// ```
///   GtkWidget *image;
///   image = gtk_image_new_from_file ("myfile.png");
/// ```
/// If the file isn’t loaded successfully, the image will contain a
/// “broken image” icon similar to that used in many web browsers.
/// If you want to handle errors in loading the file yourself,
/// for example by displaying an error message, then load the image with
/// `gdkpixbuf.Pixbuf.newFromFile`, then create the `gtk.Image` with
/// `gtk.Image.newFromPixbuf`.
///
/// The image file may contain an animation, if so the `gtk.Image` will
/// display an animation (`gdkpixbuf.PixbufAnimation`) instead of a static image.
///
/// `gtk.Image` is a subclass of `gtk.Misc`, which implies that you can
/// align it (center, left, right) and add padding to it, using
/// `gtk.Misc` methods.
///
/// `gtk.Image` is a “no window” widget (has no `gdk.Window` of its own),
/// so by default does not receive events. If you want to receive events
/// on the image, such as button clicks, place the image inside a
/// `gtk.EventBox`, then connect to the event signals on the event box.
///
/// ## Handling button press events on a
///
/// ```
///   static gboolean
///   button_press_callback (GtkWidget      *event_box,
///                          GdkEventButton *event,
///                          gpointer        data)
///   {
///     g_print ("Event box clicked at coordinates `f`,`f`\n",
///              event->x, event->y);
///
///     // Returning TRUE means we handled the event, so the signal
///     // emission should be stopped (don’t call any further callbacks
///     // that may be connected). Return FALSE to continue invoking callbacks.
///     return TRUE;
///   }
///
///   static GtkWidget*
///   create_image (void)
///   {
///     GtkWidget *image;
///     GtkWidget *event_box;
///
///     image = gtk_image_new_from_file ("myfile.png");
///
///     event_box = gtk_event_box_new ();
///
///     gtk_container_add (GTK_CONTAINER (event_box), image);
///
///     g_signal_connect (G_OBJECT (event_box),
///                       "button_press_event",
///                       G_CALLBACK (button_press_callback),
///                       image);
///
///     return image;
///   }
/// ```
///
/// When handling events on the event box, keep in mind that coordinates
/// in the image may be different from event box coordinates due to
/// the alignment and padding settings on the image (see `gtk.Misc`).
/// The simplest way to solve this is to set the alignment to 0.0
/// (left/top), and set the padding to zero. Then the origin of
/// the image will be the same as the origin of the event box.
///
/// Sometimes an application will want to avoid depending on external data
/// files, such as image files. GTK+ comes with a program to avoid this,
/// called “gdk-pixbuf-csource”. This library
/// allows you to convert an image into a C variable declaration, which
/// can then be loaded into a `gdkpixbuf.Pixbuf` using
/// `gdkpixbuf.Pixbuf.newFromInline`.
///
/// # CSS nodes
///
/// GtkImage has a single CSS node with the name image. The style classes
/// may appear on image CSS nodes: .icon-dropshadow, .lowres-icon.
pub const Image = extern struct {
    pub const Parent = gtk.Misc;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.ImageClass;
    f_misc: gtk.Misc,
    f_priv: ?*gtk.ImagePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const file = struct {
            pub const name = "file";

            pub const Type = ?[*:0]u8;
        };

        /// The GIcon displayed in the GtkImage. For themed icons,
        /// If the icon theme is changed, the image will be updated
        /// automatically.
        pub const gicon = struct {
            pub const name = "gicon";

            pub const Type = ?*gio.Icon;
        };

        /// The name of the icon in the icon theme. If the icon theme is
        /// changed, the image will be updated automatically.
        pub const icon_name = struct {
            pub const name = "icon-name";

            pub const Type = ?[*:0]u8;
        };

        pub const icon_set = struct {
            pub const name = "icon-set";

            pub const Type = ?*gtk.IconSet;
        };

        pub const icon_size = struct {
            pub const name = "icon-size";

            pub const Type = c_int;
        };

        pub const pixbuf = struct {
            pub const name = "pixbuf";

            pub const Type = ?*gdkpixbuf.Pixbuf;
        };

        pub const pixbuf_animation = struct {
            pub const name = "pixbuf-animation";

            pub const Type = ?*gdkpixbuf.PixbufAnimation;
        };

        /// The "pixel-size" property can be used to specify a fixed size
        /// overriding the `gtk.Image.properties.icon`-size property for images of type
        /// `GTK_IMAGE_ICON_NAME`.
        pub const pixel_size = struct {
            pub const name = "pixel-size";

            pub const Type = c_int;
        };

        /// A path to a resource file to display.
        pub const resource = struct {
            pub const name = "resource";

            pub const Type = ?[*:0]u8;
        };

        pub const stock = struct {
            pub const name = "stock";

            pub const Type = ?[*:0]u8;
        };

        pub const storage_type = struct {
            pub const name = "storage-type";

            pub const Type = gtk.ImageType;
        };

        pub const surface = struct {
            pub const name = "surface";

            pub const Type = ?*cairo.Surface;
        };

        /// Whether the icon displayed in the GtkImage will use
        /// standard icon names fallback. The value of this property
        /// is only relevant for images of type `GTK_IMAGE_ICON_NAME`
        /// and `GTK_IMAGE_GICON`.
        pub const use_fallback = struct {
            pub const name = "use-fallback";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new empty `gtk.Image` widget.
    extern fn gtk_image_new() *gtk.Image;
    pub const new = gtk_image_new;

    /// Creates a `gtk.Image` displaying the given animation.
    /// The `gtk.Image` does not assume a reference to the
    /// animation; you still need to unref it if you own references.
    /// `gtk.Image` will add its own reference rather than adopting yours.
    ///
    /// Note that the animation frames are shown using a timeout with
    /// `G_PRIORITY_DEFAULT`. When using animations to indicate busyness,
    /// keep in mind that the animation will only be shown if the main loop
    /// is not busy with something that has a higher priority.
    extern fn gtk_image_new_from_animation(p_animation: *gdkpixbuf.PixbufAnimation) *gtk.Image;
    pub const newFromAnimation = gtk_image_new_from_animation;

    /// Creates a new `gtk.Image` displaying the file `filename`. If the file
    /// isn’t found or can’t be loaded, the resulting `gtk.Image` will
    /// display a “broken image” icon. This function never returns `NULL`,
    /// it always returns a valid `gtk.Image` widget.
    ///
    /// If the file contains an animation, the image will contain an
    /// animation.
    ///
    /// If you need to detect failures to load the file, use
    /// `gdkpixbuf.Pixbuf.newFromFile` to load the file yourself, then create
    /// the `gtk.Image` from the pixbuf. (Or for animations, use
    /// `gdkpixbuf.PixbufAnimation.newFromFile`).
    ///
    /// The storage type (`gtk.Image.getStorageType`) of the returned
    /// image is not defined, it will be whatever is appropriate for
    /// displaying the file.
    extern fn gtk_image_new_from_file(p_filename: [*:0]const u8) *gtk.Image;
    pub const newFromFile = gtk_image_new_from_file;

    /// Creates a `gtk.Image` displaying an icon from the current icon theme.
    /// If the icon name isn’t known, a “broken image” icon will be
    /// displayed instead.  If the current icon theme is changed, the icon
    /// will be updated appropriately.
    extern fn gtk_image_new_from_gicon(p_icon: *gio.Icon, p_size: c_int) *gtk.Image;
    pub const newFromGicon = gtk_image_new_from_gicon;

    /// Creates a `gtk.Image` displaying an icon from the current icon theme.
    /// If the icon name isn’t known, a “broken image” icon will be
    /// displayed instead.  If the current icon theme is changed, the icon
    /// will be updated appropriately.
    extern fn gtk_image_new_from_icon_name(p_icon_name: ?[*:0]const u8, p_size: c_int) *gtk.Image;
    pub const newFromIconName = gtk_image_new_from_icon_name;

    /// Creates a `gtk.Image` displaying an icon set. Sample stock sizes are
    /// `GTK_ICON_SIZE_MENU`, `GTK_ICON_SIZE_SMALL_TOOLBAR`. Instead of using
    /// this function, usually it’s better to create a `gtk.IconFactory`, put
    /// your icon sets in the icon factory, add the icon factory to the
    /// list of default factories with `gtk.IconFactory.addDefault`, and
    /// then use `gtk.Image.newFromStock`. This will allow themes to
    /// override the icon you ship with your application.
    ///
    /// The `gtk.Image` does not assume a reference to the
    /// icon set; you still need to unref it if you own references.
    /// `gtk.Image` will add its own reference rather than adopting yours.
    extern fn gtk_image_new_from_icon_set(p_icon_set: *gtk.IconSet, p_size: c_int) *gtk.Image;
    pub const newFromIconSet = gtk_image_new_from_icon_set;

    /// Creates a new `gtk.Image` displaying `pixbuf`.
    /// The `gtk.Image` does not assume a reference to the
    /// pixbuf; you still need to unref it if you own references.
    /// `gtk.Image` will add its own reference rather than adopting yours.
    ///
    /// Note that this function just creates an `gtk.Image` from the pixbuf. The
    /// `gtk.Image` created will not react to state changes. Should you want that,
    /// you should use `gtk.Image.newFromIconName`.
    extern fn gtk_image_new_from_pixbuf(p_pixbuf: ?*gdkpixbuf.Pixbuf) *gtk.Image;
    pub const newFromPixbuf = gtk_image_new_from_pixbuf;

    /// Creates a new `gtk.Image` displaying the resource file `resource_path`. If the file
    /// isn’t found or can’t be loaded, the resulting `gtk.Image` will
    /// display a “broken image” icon. This function never returns `NULL`,
    /// it always returns a valid `gtk.Image` widget.
    ///
    /// If the file contains an animation, the image will contain an
    /// animation.
    ///
    /// If you need to detect failures to load the file, use
    /// `gdkpixbuf.Pixbuf.newFromFile` to load the file yourself, then create
    /// the `gtk.Image` from the pixbuf. (Or for animations, use
    /// `gdkpixbuf.PixbufAnimation.newFromFile`).
    ///
    /// The storage type (`gtk.Image.getStorageType`) of the returned
    /// image is not defined, it will be whatever is appropriate for
    /// displaying the file.
    extern fn gtk_image_new_from_resource(p_resource_path: [*:0]const u8) *gtk.Image;
    pub const newFromResource = gtk_image_new_from_resource;

    /// Creates a `gtk.Image` displaying a stock icon. Sample stock icon
    /// names are `GTK_STOCK_OPEN`, `GTK_STOCK_QUIT`. Sample stock sizes
    /// are `GTK_ICON_SIZE_MENU`, `GTK_ICON_SIZE_SMALL_TOOLBAR`. If the stock
    /// icon name isn’t known, the image will be empty.
    /// You can register your own stock icon names, see
    /// `gtk.IconFactory.addDefault` and `gtk.IconFactory.add`.
    extern fn gtk_image_new_from_stock(p_stock_id: [*:0]const u8, p_size: c_int) *gtk.Image;
    pub const newFromStock = gtk_image_new_from_stock;

    /// Creates a new `gtk.Image` displaying `surface`.
    /// The `gtk.Image` does not assume a reference to the
    /// surface; you still need to unref it if you own references.
    /// `gtk.Image` will add its own reference rather than adopting yours.
    extern fn gtk_image_new_from_surface(p_surface: ?*cairo.Surface) *gtk.Image;
    pub const newFromSurface = gtk_image_new_from_surface;

    /// Resets the image to be empty.
    extern fn gtk_image_clear(p_image: *Image) void;
    pub const clear = gtk_image_clear;

    /// Gets the `gdkpixbuf.PixbufAnimation` being displayed by the `gtk.Image`.
    /// The storage type of the image must be `GTK_IMAGE_EMPTY` or
    /// `GTK_IMAGE_ANIMATION` (see `gtk.Image.getStorageType`).
    /// The caller of this function does not own a reference to the
    /// returned animation.
    extern fn gtk_image_get_animation(p_image: *Image) ?*gdkpixbuf.PixbufAnimation;
    pub const getAnimation = gtk_image_get_animation;

    /// Gets the `gio.Icon` and size being displayed by the `gtk.Image`.
    /// The storage type of the image must be `GTK_IMAGE_EMPTY` or
    /// `GTK_IMAGE_GICON` (see `gtk.Image.getStorageType`).
    /// The caller of this function does not own a reference to the
    /// returned `gio.Icon`.
    extern fn gtk_image_get_gicon(p_image: *Image, p_gicon: ?**gio.Icon, p_size: ?*c_int) void;
    pub const getGicon = gtk_image_get_gicon;

    /// Gets the icon name and size being displayed by the `gtk.Image`.
    /// The storage type of the image must be `GTK_IMAGE_EMPTY` or
    /// `GTK_IMAGE_ICON_NAME` (see `gtk.Image.getStorageType`).
    /// The returned string is owned by the `gtk.Image` and should not
    /// be freed.
    extern fn gtk_image_get_icon_name(p_image: *Image, p_icon_name: ?*[*:0]const u8, p_size: ?*c_int) void;
    pub const getIconName = gtk_image_get_icon_name;

    /// Gets the icon set and size being displayed by the `gtk.Image`.
    /// The storage type of the image must be `GTK_IMAGE_EMPTY` or
    /// `GTK_IMAGE_ICON_SET` (see `gtk.Image.getStorageType`).
    extern fn gtk_image_get_icon_set(p_image: *Image, p_icon_set: ?**gtk.IconSet, p_size: ?*c_int) void;
    pub const getIconSet = gtk_image_get_icon_set;

    /// Gets the `gdkpixbuf.Pixbuf` being displayed by the `gtk.Image`.
    /// The storage type of the image must be `GTK_IMAGE_EMPTY` or
    /// `GTK_IMAGE_PIXBUF` (see `gtk.Image.getStorageType`).
    /// The caller of this function does not own a reference to the
    /// returned pixbuf.
    extern fn gtk_image_get_pixbuf(p_image: *Image) ?*gdkpixbuf.Pixbuf;
    pub const getPixbuf = gtk_image_get_pixbuf;

    /// Gets the pixel size used for named icons.
    extern fn gtk_image_get_pixel_size(p_image: *Image) c_int;
    pub const getPixelSize = gtk_image_get_pixel_size;

    /// Gets the stock icon name and size being displayed by the `gtk.Image`.
    /// The storage type of the image must be `GTK_IMAGE_EMPTY` or
    /// `GTK_IMAGE_STOCK` (see `gtk.Image.getStorageType`).
    /// The returned string is owned by the `gtk.Image` and should not
    /// be freed.
    extern fn gtk_image_get_stock(p_image: *Image, p_stock_id: ?*[*:0]u8, p_size: ?*c_int) void;
    pub const getStock = gtk_image_get_stock;

    /// Gets the type of representation being used by the `gtk.Image`
    /// to store image data. If the `gtk.Image` has no image data,
    /// the return value will be `GTK_IMAGE_EMPTY`.
    extern fn gtk_image_get_storage_type(p_image: *Image) gtk.ImageType;
    pub const getStorageType = gtk_image_get_storage_type;

    /// Causes the `gtk.Image` to display the given animation (or display
    /// nothing, if you set the animation to `NULL`).
    extern fn gtk_image_set_from_animation(p_image: *Image, p_animation: *gdkpixbuf.PixbufAnimation) void;
    pub const setFromAnimation = gtk_image_set_from_animation;

    /// See `gtk.Image.newFromFile` for details.
    extern fn gtk_image_set_from_file(p_image: *Image, p_filename: ?[*:0]const u8) void;
    pub const setFromFile = gtk_image_set_from_file;

    /// See `gtk.Image.newFromGicon` for details.
    extern fn gtk_image_set_from_gicon(p_image: *Image, p_icon: *gio.Icon, p_size: c_int) void;
    pub const setFromGicon = gtk_image_set_from_gicon;

    /// See `gtk.Image.newFromIconName` for details.
    extern fn gtk_image_set_from_icon_name(p_image: *Image, p_icon_name: ?[*:0]const u8, p_size: c_int) void;
    pub const setFromIconName = gtk_image_set_from_icon_name;

    /// See `gtk.Image.newFromIconSet` for details.
    extern fn gtk_image_set_from_icon_set(p_image: *Image, p_icon_set: *gtk.IconSet, p_size: c_int) void;
    pub const setFromIconSet = gtk_image_set_from_icon_set;

    /// See `gtk.Image.newFromPixbuf` for details.
    extern fn gtk_image_set_from_pixbuf(p_image: *Image, p_pixbuf: ?*gdkpixbuf.Pixbuf) void;
    pub const setFromPixbuf = gtk_image_set_from_pixbuf;

    /// See `gtk.Image.newFromResource` for details.
    extern fn gtk_image_set_from_resource(p_image: *Image, p_resource_path: ?[*:0]const u8) void;
    pub const setFromResource = gtk_image_set_from_resource;

    /// See `gtk.Image.newFromStock` for details.
    extern fn gtk_image_set_from_stock(p_image: *Image, p_stock_id: [*:0]const u8, p_size: c_int) void;
    pub const setFromStock = gtk_image_set_from_stock;

    /// See `gtk.Image.newFromSurface` for details.
    extern fn gtk_image_set_from_surface(p_image: *Image, p_surface: ?*cairo.Surface) void;
    pub const setFromSurface = gtk_image_set_from_surface;

    /// Sets the pixel size to use for named icons. If the pixel size is set
    /// to a value != -1, it is used instead of the icon size set by
    /// `gtk.Image.setFromIconName`.
    extern fn gtk_image_set_pixel_size(p_image: *Image, p_pixel_size: c_int) void;
    pub const setPixelSize = gtk_image_set_pixel_size;

    extern fn gtk_image_get_type() usize;
    pub const getGObjectType = gtk_image_get_type;

    extern fn g_object_ref(p_self: *gtk.Image) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Image) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Image, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ImageAccessible = extern struct {
    pub const Parent = gtk.WidgetAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Image };
    pub const Class = gtk.ImageAccessibleClass;
    f_parent: gtk.WidgetAccessible,
    f_priv: ?*gtk.ImageAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_image_accessible_get_type() usize;
    pub const getGObjectType = gtk_image_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ImageAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ImageAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ImageAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ImageCellAccessible = extern struct {
    pub const Parent = gtk.RendererCellAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.Image, atk.TableCell };
    pub const Class = gtk.ImageCellAccessibleClass;
    f_parent: gtk.RendererCellAccessible,
    f_priv: ?*gtk.ImageCellAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_image_cell_accessible_get_type() usize;
    pub const getGObjectType = gtk_image_cell_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ImageCellAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ImageCellAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ImageCellAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkImageMenuItem is a menu item which has an icon next to the text label.
///
/// This is functionally equivalent to:
///
/// ```
///   GtkWidget *box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
///   GtkWidget *icon = gtk_image_new_from_icon_name ("folder-music-symbolic", GTK_ICON_SIZE_MENU);
///   GtkWidget *label = gtk_label_new ("Music");
///   GtkWidget *menu_item = gtk_menu_item_new ();
///
///   gtk_container_add (GTK_CONTAINER (box), icon);
///   gtk_container_add (GTK_CONTAINER (box), label);
///
///   gtk_container_add (GTK_CONTAINER (menu_item), box);
///
///   gtk_widget_show_all (menu_item);
/// ```
///
/// Note that the user may disable display of menu icons using
/// the `gtk.Settings.properties.gtk`-menu-images setting, so make sure to still
/// fill in the text label. If you want to ensure that your menu items
/// show an icon you are strongly encouraged to use a `gtk.MenuItem`
/// with a `gtk.Image` instead.
///
/// `gtk.ImageMenuItem` has been deprecated since GTK+ 3.10. If you want to
/// display an icon in a menu item, you should use `gtk.MenuItem` and pack a
/// `gtk.Box` with a `gtk.Image` and a `gtk.Label` instead. You should also consider
/// using `gtk.Builder` and the XML `gio.Menu` description for creating menus, by
/// following the [GMenu guide][https://developer.gnome.org/GMenu/]. You should
/// consider using icons in menu items only sparingly, and for "objects" (or
/// "nouns") elements only, like bookmarks, files, and links; "actions" (or
/// "verbs") should not have icons.
///
/// Furthermore, if you would like to display keyboard accelerator, you must
/// pack the accel label into the box using `gtk.Box.packEnd` and align the
/// label, otherwise the accelerator will not display correctly. The following
/// code snippet adds a keyboard accelerator to the menu item, with a key
/// binding of Ctrl+M:
///
/// ```
///   GtkWidget *box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
///   GtkWidget *icon = gtk_image_new_from_icon_name ("folder-music-symbolic", GTK_ICON_SIZE_MENU);
///   GtkWidget *label = gtk_accel_label_new ("Music");
///   GtkWidget *menu_item = gtk_menu_item_new ();
///   GtkAccelGroup *accel_group = gtk_accel_group_new ();
///
///   gtk_container_add (GTK_CONTAINER (box), icon);
///
///   gtk_label_set_use_underline (GTK_LABEL (label), TRUE);
///   gtk_label_set_xalign (GTK_LABEL (label), 0.0);
///
///   gtk_widget_add_accelerator (menu_item, "activate", accel_group,
///                               GDK_KEY_m, GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
///   gtk_accel_label_set_accel_widget (GTK_ACCEL_LABEL (label), menu_item);
///
///   gtk_box_pack_end (GTK_BOX (box), label, TRUE, TRUE, 0);
///
///   gtk_container_add (GTK_CONTAINER (menu_item), box);
///
///   gtk_widget_show_all (menu_item);
/// ```
pub const ImageMenuItem = extern struct {
    pub const Parent = gtk.MenuItem;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.ImageMenuItemClass;
    f_menu_item: gtk.MenuItem,
    f_priv: ?*gtk.ImageMenuItemPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The Accel Group to use for stock accelerator keys
        pub const accel_group = struct {
            pub const name = "accel-group";

            pub const Type = ?*gtk.AccelGroup;
        };

        /// If `TRUE`, the menu item will always show the image, if available.
        ///
        /// Use this property only if the menuitem would be useless or hard to use
        /// without the image.
        pub const always_show_image = struct {
            pub const name = "always-show-image";

            pub const Type = c_int;
        };

        /// Child widget to appear next to the menu text.
        pub const image = struct {
            pub const name = "image";

            pub const Type = ?*gtk.Widget;
        };

        /// If `TRUE`, the label set in the menuitem is used as a
        /// stock id to select the stock item for the item.
        pub const use_stock = struct {
            pub const name = "use-stock";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.ImageMenuItem` with an empty label.
    extern fn gtk_image_menu_item_new() *gtk.ImageMenuItem;
    pub const new = gtk_image_menu_item_new;

    /// Creates a new `gtk.ImageMenuItem` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    ///
    /// If you want this menu item to have changeable accelerators, then pass in
    /// `NULL` for accel_group. Next call `gtk.MenuItem.setAccelPath` with an
    /// appropriate path for the menu item, use `gtk.stockLookup` to look up the
    /// standard accelerator for the stock item, and if one is found, call
    /// `gtk.AccelMap.addEntry` to register it.
    extern fn gtk_image_menu_item_new_from_stock(p_stock_id: [*:0]const u8, p_accel_group: ?*gtk.AccelGroup) *gtk.ImageMenuItem;
    pub const newFromStock = gtk_image_menu_item_new_from_stock;

    /// Creates a new `gtk.ImageMenuItem` containing a label.
    extern fn gtk_image_menu_item_new_with_label(p_label: [*:0]const u8) *gtk.ImageMenuItem;
    pub const newWithLabel = gtk_image_menu_item_new_with_label;

    /// Creates a new `gtk.ImageMenuItem` containing a label. The label
    /// will be created using `gtk.Label.newWithMnemonic`, so underscores
    /// in `label` indicate the mnemonic for the menu item.
    extern fn gtk_image_menu_item_new_with_mnemonic(p_label: [*:0]const u8) *gtk.ImageMenuItem;
    pub const newWithMnemonic = gtk_image_menu_item_new_with_mnemonic;

    /// Returns whether the menu item will ignore the `gtk.Settings.properties.gtk`-menu-images
    /// setting and always show the image, if available.
    extern fn gtk_image_menu_item_get_always_show_image(p_image_menu_item: *ImageMenuItem) c_int;
    pub const getAlwaysShowImage = gtk_image_menu_item_get_always_show_image;

    /// Gets the widget that is currently set as the image of `image_menu_item`.
    /// See `gtk.ImageMenuItem.setImage`.
    extern fn gtk_image_menu_item_get_image(p_image_menu_item: *ImageMenuItem) *gtk.Widget;
    pub const getImage = gtk_image_menu_item_get_image;

    /// Checks whether the label set in the menuitem is used as a
    /// stock id to select the stock item for the item.
    extern fn gtk_image_menu_item_get_use_stock(p_image_menu_item: *ImageMenuItem) c_int;
    pub const getUseStock = gtk_image_menu_item_get_use_stock;

    /// Specifies an `accel_group` to add the menu items accelerator to
    /// (this only applies to stock items so a stock item must already
    /// be set, make sure to call `gtk.ImageMenuItem.setUseStock`
    /// and `gtk.MenuItem.setLabel` with a valid stock item first).
    ///
    /// If you want this menu item to have changeable accelerators then
    /// you shouldnt need this (see `gtk.ImageMenuItem.newFromStock`).
    extern fn gtk_image_menu_item_set_accel_group(p_image_menu_item: *ImageMenuItem, p_accel_group: *gtk.AccelGroup) void;
    pub const setAccelGroup = gtk_image_menu_item_set_accel_group;

    /// If `TRUE`, the menu item will ignore the `gtk.Settings.properties.gtk`-menu-images
    /// setting and always show the image, if available.
    ///
    /// Use this property if the menuitem would be useless or hard to use
    /// without the image.
    extern fn gtk_image_menu_item_set_always_show_image(p_image_menu_item: *ImageMenuItem, p_always_show: c_int) void;
    pub const setAlwaysShowImage = gtk_image_menu_item_set_always_show_image;

    /// Sets the image of `image_menu_item` to the given widget.
    /// Note that it depends on the show-menu-images setting whether
    /// the image will be displayed or not.
    extern fn gtk_image_menu_item_set_image(p_image_menu_item: *ImageMenuItem, p_image: ?*gtk.Widget) void;
    pub const setImage = gtk_image_menu_item_set_image;

    /// If `TRUE`, the label set in the menuitem is used as a
    /// stock id to select the stock item for the item.
    extern fn gtk_image_menu_item_set_use_stock(p_image_menu_item: *ImageMenuItem, p_use_stock: c_int) void;
    pub const setUseStock = gtk_image_menu_item_set_use_stock;

    extern fn gtk_image_menu_item_get_type() usize;
    pub const getGObjectType = gtk_image_menu_item_get_type;

    extern fn g_object_ref(p_self: *gtk.ImageMenuItem) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ImageMenuItem) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ImageMenuItem, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.InfoBar` is a widget that can be used to show messages to
/// the user without showing a dialog. It is often temporarily shown
/// at the top or bottom of a document. In contrast to `gtk.Dialog`, which
/// has a action area at the bottom, `gtk.InfoBar` has an action area
/// at the side.
///
/// The API of `gtk.InfoBar` is very similar to `gtk.Dialog`, allowing you
/// to add buttons to the action area with `gtk.InfoBar.addButton` or
/// `gtk.InfoBar.newWithButtons`. The sensitivity of action widgets
/// can be controlled with `gtk.InfoBar.setResponseSensitive`.
/// To add widgets to the main content area of a `gtk.InfoBar`, use
/// `gtk.InfoBar.getContentArea` and add your widgets to the container.
///
/// Similar to `gtk.MessageDialog`, the contents of a `gtk.InfoBar` can by
/// classified as error message, warning, informational message, etc,
/// by using `gtk.InfoBar.setMessageType`. GTK+ may use the message type
/// to determine how the message is displayed.
///
/// A simple example for using a `gtk.InfoBar`:
/// ```
/// GtkWidget *widget, *message_label, *content_area;
/// GtkWidget *grid;
/// GtkInfoBar *bar;
///
/// // set up info bar
/// widget = gtk_info_bar_new ();
/// bar = GTK_INFO_BAR (widget);
/// grid = gtk_grid_new ();
///
/// gtk_widget_set_no_show_all (widget, TRUE);
/// message_label = gtk_label_new ("");
/// content_area = gtk_info_bar_get_content_area (bar);
/// gtk_container_add (GTK_CONTAINER (content_area),
///                    message_label);
/// gtk_info_bar_add_button (bar,
///                          _("_OK"),
///                          GTK_RESPONSE_OK);
/// g_signal_connect (bar,
///                   "response",
///                   G_CALLBACK (gtk_widget_hide),
///                   NULL);
/// gtk_grid_attach (GTK_GRID (grid),
///                  widget,
///                  0, 2, 1, 1);
///
/// // ...
///
/// // show an error message
/// gtk_label_set_text (GTK_LABEL (message_label), "An error occurred!");
/// gtk_info_bar_set_message_type (bar,
///                                GTK_MESSAGE_ERROR);
/// gtk_widget_show (bar);
/// ```
///
/// # GtkInfoBar as GtkBuildable
///
/// The GtkInfoBar implementation of the GtkBuildable interface exposes
/// the content area and action area as internal children with the names
/// “content_area” and “action_area”.
///
/// GtkInfoBar supports a custom `<action-widgets>` element, which can contain
/// multiple `<action-widget>` elements. The “response” attribute specifies a
/// numeric response, and the content of the element is the id of widget
/// (which should be a child of the dialogs `action_area`).
///
/// # CSS nodes
///
/// GtkInfoBar has a single CSS node with name infobar. The node may get
/// one of the style classes .info, .warning, .error or .question, depending
/// on the message type.
pub const InfoBar = extern struct {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.InfoBarClass;
    f_parent: gtk.Box,
    f_priv: ?*gtk.InfoBarPrivate,

    pub const virtual_methods = struct {
        pub const close = struct {
            pub fn call(p_class: anytype, p_info_bar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(InfoBar.Class, p_class).f_close.?(gobject.ext.as(InfoBar, p_info_bar));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_info_bar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(InfoBar.Class, p_class).f_close = @ptrCast(p_implementation);
            }
        };

        /// Emits the “response” signal with the given `response_id`.
        pub const response = struct {
            pub fn call(p_class: anytype, p_info_bar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_response_id: c_int) void {
                return gobject.ext.as(InfoBar.Class, p_class).f_response.?(gobject.ext.as(InfoBar, p_info_bar), p_response_id);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_info_bar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_response_id: c_int) callconv(.c) void) void {
                gobject.ext.as(InfoBar.Class, p_class).f_response = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The type of the message.
        ///
        /// The type may be used to determine the appearance of the info bar.
        pub const message_type = struct {
            pub const name = "message-type";

            pub const Type = gtk.MessageType;
        };

        pub const revealed = struct {
            pub const name = "revealed";

            pub const Type = c_int;
        };

        /// Whether to include a standard close button.
        pub const show_close_button = struct {
            pub const name = "show-close-button";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::close signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user uses a keybinding to dismiss
        /// the info bar.
        ///
        /// The default binding for this signal is the Escape key.
        pub const close = struct {
            pub const name = "close";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(InfoBar, p_instance))),
                    gobject.signalLookup("close", InfoBar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when an action widget is clicked or the application programmer
        /// calls `gtk.Dialog.response`. The `response_id` depends on which action
        /// widget was clicked.
        pub const response = struct {
            pub const name = "response";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_response_id: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(InfoBar, p_instance))),
                    gobject.signalLookup("response", InfoBar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.InfoBar` object.
    extern fn gtk_info_bar_new() *gtk.InfoBar;
    pub const new = gtk_info_bar_new;

    /// Creates a new `gtk.InfoBar` with buttons. Button text/response ID
    /// pairs should be listed, with a `NULL` pointer ending the list.
    /// Button text can be either a stock ID such as `GTK_STOCK_OK`, or
    /// some arbitrary text. A response ID can be any positive number,
    /// or one of the values in the `gtk.ResponseType` enumeration. If the
    /// user clicks one of these dialog buttons, GtkInfoBar will emit
    /// the “response” signal with the corresponding response ID.
    extern fn gtk_info_bar_new_with_buttons(p_first_button_text: ?[*:0]const u8, ...) *gtk.InfoBar;
    pub const newWithButtons = gtk_info_bar_new_with_buttons;

    /// Add an activatable widget to the action area of a `gtk.InfoBar`,
    /// connecting a signal handler that will emit the `gtk.InfoBar.signals.response`
    /// signal on the message area when the widget is activated. The widget
    /// is appended to the end of the message areas action area.
    extern fn gtk_info_bar_add_action_widget(p_info_bar: *InfoBar, p_child: *gtk.Widget, p_response_id: c_int) void;
    pub const addActionWidget = gtk_info_bar_add_action_widget;

    /// Adds a button with the given text and sets things up so that
    /// clicking the button will emit the “response” signal with the given
    /// response_id. The button is appended to the end of the info bars's
    /// action area. The button widget is returned, but usually you don't
    /// need it.
    extern fn gtk_info_bar_add_button(p_info_bar: *InfoBar, p_button_text: [*:0]const u8, p_response_id: c_int) *gtk.Button;
    pub const addButton = gtk_info_bar_add_button;

    /// Adds more buttons, same as calling `gtk.InfoBar.addButton`
    /// repeatedly. The variable argument list should be `NULL`-terminated
    /// as with `gtk.InfoBar.newWithButtons`. Each button must have both
    /// text and response ID.
    extern fn gtk_info_bar_add_buttons(p_info_bar: *InfoBar, p_first_button_text: [*:0]const u8, ...) void;
    pub const addButtons = gtk_info_bar_add_buttons;

    /// Returns the action area of `info_bar`.
    extern fn gtk_info_bar_get_action_area(p_info_bar: *InfoBar) *gtk.Box;
    pub const getActionArea = gtk_info_bar_get_action_area;

    /// Returns the content area of `info_bar`.
    extern fn gtk_info_bar_get_content_area(p_info_bar: *InfoBar) *gtk.Box;
    pub const getContentArea = gtk_info_bar_get_content_area;

    /// Returns the message type of the message area.
    extern fn gtk_info_bar_get_message_type(p_info_bar: *InfoBar) gtk.MessageType;
    pub const getMessageType = gtk_info_bar_get_message_type;

    extern fn gtk_info_bar_get_revealed(p_info_bar: *InfoBar) c_int;
    pub const getRevealed = gtk_info_bar_get_revealed;

    /// Returns whether the widget will display a standard close button.
    extern fn gtk_info_bar_get_show_close_button(p_info_bar: *InfoBar) c_int;
    pub const getShowCloseButton = gtk_info_bar_get_show_close_button;

    /// Emits the “response” signal with the given `response_id`.
    extern fn gtk_info_bar_response(p_info_bar: *InfoBar, p_response_id: c_int) void;
    pub const response = gtk_info_bar_response;

    /// Sets the last widget in the info bar’s action area with
    /// the given response_id as the default widget for the dialog.
    /// Pressing “Enter” normally activates the default widget.
    ///
    /// Note that this function currently requires `info_bar` to
    /// be added to a widget hierarchy.
    extern fn gtk_info_bar_set_default_response(p_info_bar: *InfoBar, p_response_id: c_int) void;
    pub const setDefaultResponse = gtk_info_bar_set_default_response;

    /// Sets the message type of the message area.
    ///
    /// GTK+ uses this type to determine how the message is displayed.
    extern fn gtk_info_bar_set_message_type(p_info_bar: *InfoBar, p_message_type: gtk.MessageType) void;
    pub const setMessageType = gtk_info_bar_set_message_type;

    /// Calls gtk_widget_set_sensitive (widget, setting) for each
    /// widget in the info bars’s action area with the given response_id.
    /// A convenient way to sensitize/desensitize dialog buttons.
    extern fn gtk_info_bar_set_response_sensitive(p_info_bar: *InfoBar, p_response_id: c_int, p_setting: c_int) void;
    pub const setResponseSensitive = gtk_info_bar_set_response_sensitive;

    /// Sets the GtkInfoBar:revealed property to `revealed`. This will cause
    /// `info_bar` to show up with a slide-in transition.
    ///
    /// Note that this property does not automatically show `info_bar` and thus won’t
    /// have any effect if it is invisible.
    extern fn gtk_info_bar_set_revealed(p_info_bar: *InfoBar, p_revealed: c_int) void;
    pub const setRevealed = gtk_info_bar_set_revealed;

    /// If true, a standard close button is shown. When clicked it emits
    /// the response `GTK_RESPONSE_CLOSE`.
    extern fn gtk_info_bar_set_show_close_button(p_info_bar: *InfoBar, p_setting: c_int) void;
    pub const setShowCloseButton = gtk_info_bar_set_show_close_button;

    extern fn gtk_info_bar_get_type() usize;
    pub const getGObjectType = gtk_info_bar_get_type;

    extern fn g_object_ref(p_self: *gtk.InfoBar) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.InfoBar) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *InfoBar, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Invisible` widget is used internally in GTK+, and is probably not
/// very useful for application developers.
///
/// It is used for reliable pointer grabs and selection handling in the code
/// for drag-and-drop.
pub const Invisible = extern struct {
    pub const Parent = gtk.Widget;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.InvisibleClass;
    f_widget: gtk.Widget,
    f_priv: ?*gtk.InvisiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const screen = struct {
            pub const name = "screen";

            pub const Type = ?*gdk.Screen;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.Invisible`.
    extern fn gtk_invisible_new() *gtk.Invisible;
    pub const new = gtk_invisible_new;

    /// Creates a new `gtk.Invisible` object for a specified screen
    extern fn gtk_invisible_new_for_screen(p_screen: *gdk.Screen) *gtk.Invisible;
    pub const newForScreen = gtk_invisible_new_for_screen;

    /// Returns the `gdk.Screen` object associated with `invisible`
    extern fn gtk_invisible_get_screen(p_invisible: *Invisible) *gdk.Screen;
    pub const getScreen = gtk_invisible_get_screen;

    /// Sets the `gdk.Screen` where the `gtk.Invisible` object will be displayed.
    extern fn gtk_invisible_set_screen(p_invisible: *Invisible, p_screen: *gdk.Screen) void;
    pub const setScreen = gtk_invisible_set_screen;

    extern fn gtk_invisible_get_type() usize;
    pub const getGObjectType = gtk_invisible_get_type;

    extern fn g_object_ref(p_self: *gtk.Invisible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Invisible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Invisible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Label` widget displays a small amount of text. As the name
/// implies, most labels are used to label another widget such as a
/// `gtk.Button`, a `gtk.MenuItem`, or a `gtk.ComboBox`.
///
/// # CSS nodes
///
/// ```
/// label
/// ├── [selection]
/// ├── [link]
/// ┊
/// ╰── [link]
/// ```
///
/// GtkLabel has a single CSS node with the name label. A wide variety
/// of style classes may be applied to labels, such as .title, .subtitle,
/// .dim-label, etc. In the `gtk.ShortcutsWindow`, labels are used wth the
/// .keycap style class.
///
/// If the label has a selection, it gets a subnode with name selection.
///
/// If the label has links, there is one subnode per link. These subnodes
/// carry the link or visited state depending on whether they have been
/// visited.
///
/// # GtkLabel as GtkBuildable
///
/// The GtkLabel implementation of the GtkBuildable interface supports a
/// custom `<attributes>` element, which supports any number of `<attribute>`
/// elements. The `<attribute>` element has attributes named “name“, “value“,
/// “start“ and “end“ and allows you to specify `pango.Attribute` values for
/// this label.
///
/// An example of a UI definition fragment specifying Pango attributes:
///
/// ```
/// <object class="GtkLabel">
///   <attributes>
///     <attribute name="weight" value="PANGO_WEIGHT_BOLD"/>
///     <attribute name="background" value="red" start="5" end="10"/>
///   </attributes>
/// </object>
/// ```
///
/// The start and end attributes specify the range of characters to which the
/// Pango attribute applies. If start and end are not specified, the attribute is
/// applied to the whole text. Note that specifying ranges does not make much
/// sense with translatable attributes. Use markup embedded in the translatable
/// content instead.
///
/// # Mnemonics
///
/// Labels may contain “mnemonics”. Mnemonics are
/// underlined characters in the label, used for keyboard navigation.
/// Mnemonics are created by providing a string with an underscore before
/// the mnemonic character, such as `"_File"`, to the
/// functions `gtk.Label.newWithMnemonic` or
/// `gtk.Label.setTextWithMnemonic`.
///
/// Mnemonics automatically activate any activatable widget the label is
/// inside, such as a `gtk.Button`; if the label is not inside the
/// mnemonic’s target widget, you have to tell the label about the target
/// using `gtk.Label.setMnemonicWidget`. Here’s a simple example where
/// the label is inside a button:
///
/// ```
///   // Pressing Alt+H will activate this button
///   GtkWidget *button = gtk_button_new ();
///   GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
///   gtk_container_add (GTK_CONTAINER (button), label);
/// ```
///
/// There’s a convenience function to create buttons with a mnemonic label
/// already inside:
///
/// ```
///   // Pressing Alt+H will activate this button
///   GtkWidget *button = gtk_button_new_with_mnemonic ("_Hello");
/// ```
///
/// To create a mnemonic for a widget alongside the label, such as a
/// `gtk.Entry`, you have to point the label at the entry with
/// `gtk.Label.setMnemonicWidget`:
///
/// ```
///   // Pressing Alt+H will focus the entry
///   GtkWidget *entry = gtk_entry_new ();
///   GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
///   gtk_label_set_mnemonic_widget (GTK_LABEL (label), entry);
/// ```
///
/// # Markup (styled text)
///
/// To make it easy to format text in a label (changing colors,
/// fonts, etc.), label text can be provided in a simple
/// [markup format][PangoMarkupFormat].
///
/// Here’s how to create a label with a small font:
/// ```
///   GtkWidget *label = gtk_label_new (NULL);
///   gtk_label_set_markup (GTK_LABEL (label), "<small>Small text</small>");
/// ```
///
/// (See [complete documentation][PangoMarkupFormat] of available
/// tags in the Pango manual.)
///
/// The markup passed to `gtk.Label.setMarkup` must be valid; for example,
/// literal <, > and & characters must be escaped as &lt;, &gt;, and &amp;.
/// If you pass text obtained from the user, file, or a network to
/// `gtk.Label.setMarkup`, you’ll want to escape it with
/// `glib.markupEscapeText` or `glib.markupPrintfEscaped`.
///
/// Markup strings are just a convenient way to set the `pango.AttrList` on
/// a label; `gtk.Label.setAttributes` may be a simpler way to set
/// attributes in some cases. Be careful though; `pango.AttrList` tends to
/// cause internationalization problems, unless you’re applying attributes
/// to the entire string (i.e. unless you set the range of each attribute
/// to [0, `G_MAXINT`)). The reason is that specifying the start_index and
/// end_index for a `pango.Attribute` requires knowledge of the exact string
/// being displayed, so translations will cause problems.
///
/// # Selectable labels
///
/// Labels can be made selectable with `gtk.Label.setSelectable`.
/// Selectable labels allow the user to copy the label contents to
/// the clipboard. Only labels that contain useful-to-copy information
/// — such as error messages — should be made selectable.
///
/// # Text layout
///
/// A label can contain any number of paragraphs, but will have
/// performance problems if it contains more than a small number.
/// Paragraphs are separated by newlines or other paragraph separators
/// understood by Pango.
///
/// Labels can automatically wrap text if you call
/// `gtk.Label.setLineWrap`.
///
/// `gtk.Label.setJustify` sets how the lines in a label align
/// with one another. If you want to set how the label as a whole
/// aligns in its available space, see the `gtk.Widget.properties.halign` and
/// `gtk.Widget.properties.valign` properties.
///
/// The `gtk.Label.properties.width`-chars and `gtk.Label.properties.max`-width-chars properties
/// can be used to control the size allocation of ellipsized or wrapped
/// labels. For ellipsizing labels, if either is specified (and less
/// than the actual text size), it is used as the minimum width, and the actual
/// text size is used as the natural width of the label. For wrapping labels,
/// width-chars is used as the minimum width, if specified, and max-width-chars
/// is used as the natural width. Even if max-width-chars specified, wrapping
/// labels will be rewrapped to use all of the available width.
///
/// Note that the interpretation of `gtk.Label.properties.width`-chars and
/// `gtk.Label.properties.max`-width-chars has changed a bit with the introduction of
/// [width-for-height geometry management.][geometry-management]
///
/// # Links
///
/// Since 2.18, GTK+ supports markup for clickable hyperlinks in addition
/// to regular Pango markup. The markup for links is borrowed from HTML,
/// using the `<a>` with “href“ and “title“ attributes. GTK+ renders links
/// similar to the way they appear in web browsers, with colored, underlined
/// text. The “title“ attribute is displayed as a tooltip on the link.
///
/// An example looks like this:
///
/// ```
/// const gchar *text =
/// "Go to the"
/// "<a href=\"http://www.gtk.org title=\"&lt;i&gt;Our&lt;/i&gt; website\">"
/// "GTK+ website</a> for more...";
/// GtkWidget *label = gtk_label_new (NULL);
/// gtk_label_set_markup (GTK_LABEL (label), text);
/// ```
///
/// It is possible to implement custom handling for links and their tooltips with
/// the `gtk.Label.signals.activate`-link signal and the `gtk.Label.getCurrentUri` function.
pub const Label = extern struct {
    pub const Parent = gtk.Misc;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.LabelClass;
    f_misc: gtk.Misc,
    f_priv: ?*gtk.LabelPrivate,

    pub const virtual_methods = struct {
        pub const activate_link = struct {
            pub fn call(p_class: anytype, p_label: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8) c_int {
                return gobject.ext.as(Label.Class, p_class).f_activate_link.?(gobject.ext.as(Label, p_label), p_uri);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_label: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8) callconv(.c) c_int) void {
                gobject.ext.as(Label.Class, p_class).f_activate_link = @ptrCast(p_implementation);
            }
        };

        pub const copy_clipboard = struct {
            pub fn call(p_class: anytype, p_label: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Label.Class, p_class).f_copy_clipboard.?(gobject.ext.as(Label, p_label));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_label: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Label.Class, p_class).f_copy_clipboard = @ptrCast(p_implementation);
            }
        };

        pub const move_cursor = struct {
            pub fn call(p_class: anytype, p_label: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_step: gtk.MovementStep, p_count: c_int, p_extend_selection: c_int) void {
                return gobject.ext.as(Label.Class, p_class).f_move_cursor.?(gobject.ext.as(Label, p_label), p_step, p_count, p_extend_selection);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_label: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_step: gtk.MovementStep, p_count: c_int, p_extend_selection: c_int) callconv(.c) void) void {
                gobject.ext.as(Label.Class, p_class).f_move_cursor = @ptrCast(p_implementation);
            }
        };

        pub const populate_popup = struct {
            pub fn call(p_class: anytype, p_label: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_menu: *gtk.Menu) void {
                return gobject.ext.as(Label.Class, p_class).f_populate_popup.?(gobject.ext.as(Label, p_label), p_menu);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_label: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_menu: *gtk.Menu) callconv(.c) void) void {
                gobject.ext.as(Label.Class, p_class).f_populate_popup = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The angle that the baseline of the label makes with the horizontal,
        /// in degrees, measured counterclockwise. An angle of 90 reads from
        /// from bottom to top, an angle of 270, from top to bottom. Ignored
        /// if the label is selectable.
        pub const angle = struct {
            pub const name = "angle";

            pub const Type = f64;
        };

        pub const attributes = struct {
            pub const name = "attributes";

            pub const Type = ?*pango.AttrList;
        };

        pub const cursor_position = struct {
            pub const name = "cursor-position";

            pub const Type = c_int;
        };

        /// The preferred place to ellipsize the string, if the label does
        /// not have enough room to display the entire string, specified as a
        /// `pango.EllipsizeMode`.
        ///
        /// Note that setting this property to a value other than
        /// `PANGO_ELLIPSIZE_NONE` has the side-effect that the label requests
        /// only enough space to display the ellipsis "...". In particular, this
        /// means that ellipsizing labels do not work well in notebook tabs, unless
        /// the `gtk.Notebook` tab-expand child property is set to `TRUE`. Other ways
        /// to set a label's width are `gtk.Widget.setSizeRequest` and
        /// `gtk.Label.setWidthChars`.
        pub const ellipsize = struct {
            pub const name = "ellipsize";

            pub const Type = pango.EllipsizeMode;
        };

        pub const justify = struct {
            pub const name = "justify";

            pub const Type = gtk.Justification;
        };

        /// The contents of the label.
        ///
        /// If the string contains [Pango XML markup][PangoMarkupFormat], you will
        /// have to set the `gtk.Label.properties.use`-markup property to `TRUE` in order for the
        /// label to display the markup attributes. See also `gtk.Label.setMarkup`
        /// for a convenience function that sets both this property and the
        /// `gtk.Label.properties.use`-markup property at the same time.
        ///
        /// If the string contains underlines acting as mnemonics, you will have to
        /// set the `gtk.Label.properties.use`-underline property to `TRUE` in order for the label
        /// to display them.
        pub const label = struct {
            pub const name = "label";

            pub const Type = ?[*:0]u8;
        };

        /// The number of lines to which an ellipsized, wrapping label
        /// should be limited. This property has no effect if the
        /// label is not wrapping or ellipsized. Set this property to
        /// -1 if you don't want to limit the number of lines.
        pub const lines = struct {
            pub const name = "lines";

            pub const Type = c_int;
        };

        /// The desired maximum width of the label, in characters. If this property
        /// is set to -1, the width will be calculated automatically.
        ///
        /// See the section on [text layout][label-text-layout]
        /// for details of how `gtk.Label.properties.width`-chars and `gtk.Label.properties.max`-width-chars
        /// determine the width of ellipsized and wrapped labels.
        pub const max_width_chars = struct {
            pub const name = "max-width-chars";

            pub const Type = c_int;
        };

        pub const mnemonic_keyval = struct {
            pub const name = "mnemonic-keyval";

            pub const Type = c_uint;
        };

        pub const mnemonic_widget = struct {
            pub const name = "mnemonic-widget";

            pub const Type = ?*gtk.Widget;
        };

        pub const pattern = struct {
            pub const name = "pattern";

            pub const Type = ?[*:0]u8;
        };

        pub const selectable = struct {
            pub const name = "selectable";

            pub const Type = c_int;
        };

        pub const selection_bound = struct {
            pub const name = "selection-bound";

            pub const Type = c_int;
        };

        /// Whether the label is in single line mode. In single line mode,
        /// the height of the label does not depend on the actual text, it
        /// is always set to ascent + descent of the font. This can be an
        /// advantage in situations where resizing the label because of text
        /// changes would be distracting, e.g. in a statusbar.
        pub const single_line_mode = struct {
            pub const name = "single-line-mode";

            pub const Type = c_int;
        };

        /// Set this property to `TRUE` to make the label track which links
        /// have been visited. It will then apply the `GTK_STATE_FLAG_VISITED`
        /// when rendering this link, in addition to `GTK_STATE_FLAG_LINK`.
        pub const track_visited_links = struct {
            pub const name = "track-visited-links";

            pub const Type = c_int;
        };

        pub const use_markup = struct {
            pub const name = "use-markup";

            pub const Type = c_int;
        };

        pub const use_underline = struct {
            pub const name = "use-underline";

            pub const Type = c_int;
        };

        /// The desired width of the label, in characters. If this property is set to
        /// -1, the width will be calculated automatically.
        ///
        /// See the section on [text layout][label-text-layout]
        /// for details of how `gtk.Label.properties.width`-chars and `gtk.Label.properties.max`-width-chars
        /// determine the width of ellipsized and wrapped labels.
        pub const width_chars = struct {
            pub const name = "width-chars";

            pub const Type = c_int;
        };

        pub const wrap = struct {
            pub const name = "wrap";

            pub const Type = c_int;
        };

        /// If line wrapping is on (see the `gtk.Label.properties.wrap` property) this controls
        /// how the line wrapping is done. The default is `PANGO_WRAP_WORD`, which
        /// means wrap on word boundaries.
        pub const wrap_mode = struct {
            pub const name = "wrap-mode";

            pub const Type = pango.WrapMode;
        };

        /// The xalign property determines the horizontal aligment of the label text
        /// inside the labels size allocation. Compare this to `gtk.Widget.properties.halign`,
        /// which determines how the labels size allocation is positioned in the
        /// space available for the label.
        pub const xalign = struct {
            pub const name = "xalign";

            pub const Type = f32;
        };

        /// The yalign property determines the vertical aligment of the label text
        /// inside the labels size allocation. Compare this to `gtk.Widget.properties.valign`,
        /// which determines how the labels size allocation is positioned in the
        /// space available for the label.
        pub const yalign = struct {
            pub const name = "yalign";

            pub const Type = f32;
        };
    };

    pub const signals = struct {
        /// A [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user activates a link in the label.
        ///
        /// Applications may also emit the signal with `gobject.signalEmitByName`
        /// if they need to control activation of URIs programmatically.
        ///
        /// The default bindings for this signal are all forms of the Enter key.
        pub const activate_current_link = struct {
            pub const name = "activate-current-link";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Label, p_instance))),
                    gobject.signalLookup("activate-current-link", Label.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The signal which gets emitted to activate a URI.
        /// Applications may connect to it to override the default behaviour,
        /// which is to call `gtk.showUriOnWindow`.
        pub const activate_link = struct {
            pub const name = "activate-link";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_uri: [*:0]u8, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Label, p_instance))),
                    gobject.signalLookup("activate-link", Label.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::copy-clipboard signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to copy the selection to the clipboard.
        ///
        /// The default binding for this signal is Ctrl-c.
        pub const copy_clipboard = struct {
            pub const name = "copy-clipboard";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Label, p_instance))),
                    gobject.signalLookup("copy-clipboard", Label.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::move-cursor signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user initiates a cursor movement.
        /// If the cursor is not visible in `entry`, this signal causes
        /// the viewport to be moved instead.
        ///
        /// Applications should not connect to it, but may emit it with
        /// `gobject.signalEmitByName` if they need to control the cursor
        /// programmatically.
        ///
        /// The default bindings for this signal come in two variants,
        /// the variant with the Shift modifier extends the selection,
        /// the variant without the Shift modifer does not.
        /// There are too many key combinations to list them all here.
        /// - Arrow keys move by individual characters/lines
        /// - Ctrl-arrow key combinations move by words/paragraphs
        /// - Home/End keys move to the ends of the buffer
        pub const move_cursor = struct {
            pub const name = "move-cursor";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_step: gtk.MovementStep, p_count: c_int, p_extend_selection: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Label, p_instance))),
                    gobject.signalLookup("move-cursor", Label.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::populate-popup signal gets emitted before showing the
        /// context menu of the label. Note that only selectable labels
        /// have context menus.
        ///
        /// If you need to add items to the context menu, connect
        /// to this signal and append your menuitems to the `menu`.
        pub const populate_popup = struct {
            pub const name = "populate-popup";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_menu: *gtk.Menu, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Label, p_instance))),
                    gobject.signalLookup("populate-popup", Label.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new label with the given text inside it. You can
    /// pass `NULL` to get an empty label widget.
    extern fn gtk_label_new(p_str: ?[*:0]const u8) *gtk.Label;
    pub const new = gtk_label_new;

    /// Creates a new `gtk.Label`, containing the text in `str`.
    ///
    /// If characters in `str` are preceded by an underscore, they are
    /// underlined. If you need a literal underscore character in a label, use
    /// '__' (two underscores). The first underlined character represents a
    /// keyboard accelerator called a mnemonic. The mnemonic key can be used
    /// to activate another widget, chosen automatically, or explicitly using
    /// `gtk.Label.setMnemonicWidget`.
    ///
    /// If `gtk.Label.setMnemonicWidget` is not called, then the first
    /// activatable ancestor of the `gtk.Label` will be chosen as the mnemonic
    /// widget. For instance, if the label is inside a button or menu item,
    /// the button or menu item will automatically become the mnemonic widget
    /// and be activated by the mnemonic.
    extern fn gtk_label_new_with_mnemonic(p_str: ?[*:0]const u8) *gtk.Label;
    pub const newWithMnemonic = gtk_label_new_with_mnemonic;

    /// Gets the angle of rotation for the label. See
    /// `gtk.Label.setAngle`.
    extern fn gtk_label_get_angle(p_label: *Label) f64;
    pub const getAngle = gtk_label_get_angle;

    /// Gets the attribute list that was set on the label using
    /// `gtk.Label.setAttributes`, if any. This function does
    /// not reflect attributes that come from the labels markup
    /// (see `gtk.Label.setMarkup`). If you want to get the
    /// effective attributes for the label, use
    /// pango_layout_get_attribute (gtk_label_get_layout (label)).
    extern fn gtk_label_get_attributes(p_label: *Label) ?*pango.AttrList;
    pub const getAttributes = gtk_label_get_attributes;

    /// Returns the URI for the currently active link in the label.
    /// The active link is the one under the mouse pointer or, in a
    /// selectable label, the link in which the text cursor is currently
    /// positioned.
    ///
    /// This function is intended for use in a `gtk.Label.signals.activate`-link handler
    /// or for use in a `gtk.Widget.signals.query`-tooltip handler.
    extern fn gtk_label_get_current_uri(p_label: *Label) [*:0]const u8;
    pub const getCurrentUri = gtk_label_get_current_uri;

    /// Returns the ellipsizing position of the label. See `gtk.Label.setEllipsize`.
    extern fn gtk_label_get_ellipsize(p_label: *Label) pango.EllipsizeMode;
    pub const getEllipsize = gtk_label_get_ellipsize;

    /// Returns the justification of the label. See `gtk.Label.setJustify`.
    extern fn gtk_label_get_justify(p_label: *Label) gtk.Justification;
    pub const getJustify = gtk_label_get_justify;

    /// Fetches the text from a label widget including any embedded
    /// underlines indicating mnemonics and Pango markup. (See
    /// `gtk.Label.getText`).
    extern fn gtk_label_get_label(p_label: *Label) [*:0]const u8;
    pub const getLabel = gtk_label_get_label;

    /// Gets the `pango.Layout` used to display the label.
    /// The layout is useful to e.g. convert text positions to
    /// pixel positions, in combination with `gtk.Label.getLayoutOffsets`.
    /// The returned layout is owned by the `label` so need not be
    /// freed by the caller. The `label` is free to recreate its layout at
    /// any time, so it should be considered read-only.
    extern fn gtk_label_get_layout(p_label: *Label) *pango.Layout;
    pub const getLayout = gtk_label_get_layout;

    /// Obtains the coordinates where the label will draw the `pango.Layout`
    /// representing the text in the label; useful to convert mouse events
    /// into coordinates inside the `pango.Layout`, e.g. to take some action
    /// if some part of the label is clicked. Of course you will need to
    /// create a `gtk.EventBox` to receive the events, and pack the label
    /// inside it, since labels are windowless (they return `FALSE` from
    /// `gtk.Widget.getHasWindow`). Remember
    /// when using the `pango.Layout` functions you need to convert to
    /// and from pixels using `PANGO_PIXELS` or `PANGO_SCALE`.
    extern fn gtk_label_get_layout_offsets(p_label: *Label, p_x: ?*c_int, p_y: ?*c_int) void;
    pub const getLayoutOffsets = gtk_label_get_layout_offsets;

    /// Returns whether lines in the label are automatically wrapped.
    /// See `gtk.Label.setLineWrap`.
    extern fn gtk_label_get_line_wrap(p_label: *Label) c_int;
    pub const getLineWrap = gtk_label_get_line_wrap;

    /// Returns line wrap mode used by the label. See `gtk.Label.setLineWrapMode`.
    extern fn gtk_label_get_line_wrap_mode(p_label: *Label) pango.WrapMode;
    pub const getLineWrapMode = gtk_label_get_line_wrap_mode;

    /// Gets the number of lines to which an ellipsized, wrapping
    /// label should be limited. See `gtk.Label.setLines`.
    extern fn gtk_label_get_lines(p_label: *Label) c_int;
    pub const getLines = gtk_label_get_lines;

    /// Retrieves the desired maximum width of `label`, in characters. See
    /// `gtk.Label.setWidthChars`.
    extern fn gtk_label_get_max_width_chars(p_label: *Label) c_int;
    pub const getMaxWidthChars = gtk_label_get_max_width_chars;

    /// If the label has been set so that it has an mnemonic key this function
    /// returns the keyval used for the mnemonic accelerator. If there is no
    /// mnemonic set up it returns `GDK_KEY_VoidSymbol`.
    extern fn gtk_label_get_mnemonic_keyval(p_label: *Label) c_uint;
    pub const getMnemonicKeyval = gtk_label_get_mnemonic_keyval;

    /// Retrieves the target of the mnemonic (keyboard shortcut) of this
    /// label. See `gtk.Label.setMnemonicWidget`.
    extern fn gtk_label_get_mnemonic_widget(p_label: *Label) ?*gtk.Widget;
    pub const getMnemonicWidget = gtk_label_get_mnemonic_widget;

    /// Gets the value set by `gtk.Label.setSelectable`.
    extern fn gtk_label_get_selectable(p_label: *Label) c_int;
    pub const getSelectable = gtk_label_get_selectable;

    /// Gets the selected range of characters in the label, returning `TRUE`
    /// if there’s a selection.
    extern fn gtk_label_get_selection_bounds(p_label: *Label, p_start: *c_int, p_end: *c_int) c_int;
    pub const getSelectionBounds = gtk_label_get_selection_bounds;

    /// Returns whether the label is in single line mode.
    extern fn gtk_label_get_single_line_mode(p_label: *Label) c_int;
    pub const getSingleLineMode = gtk_label_get_single_line_mode;

    /// Fetches the text from a label widget, as displayed on the
    /// screen. This does not include any embedded underlines
    /// indicating mnemonics or Pango markup. (See `gtk.Label.getLabel`)
    extern fn gtk_label_get_text(p_label: *Label) [*:0]const u8;
    pub const getText = gtk_label_get_text;

    /// Returns whether the label is currently keeping track
    /// of clicked links.
    extern fn gtk_label_get_track_visited_links(p_label: *Label) c_int;
    pub const getTrackVisitedLinks = gtk_label_get_track_visited_links;

    /// Returns whether the label’s text is interpreted as marked up with
    /// the [Pango text markup language][PangoMarkupFormat].
    /// See gtk_label_set_use_markup ().
    extern fn gtk_label_get_use_markup(p_label: *Label) c_int;
    pub const getUseMarkup = gtk_label_get_use_markup;

    /// Returns whether an embedded underline in the label indicates a
    /// mnemonic. See `gtk.Label.setUseUnderline`.
    extern fn gtk_label_get_use_underline(p_label: *Label) c_int;
    pub const getUseUnderline = gtk_label_get_use_underline;

    /// Retrieves the desired width of `label`, in characters. See
    /// `gtk.Label.setWidthChars`.
    extern fn gtk_label_get_width_chars(p_label: *Label) c_int;
    pub const getWidthChars = gtk_label_get_width_chars;

    /// Gets the `gtk.Label.properties.xalign` property for `label`.
    extern fn gtk_label_get_xalign(p_label: *Label) f32;
    pub const getXalign = gtk_label_get_xalign;

    /// Gets the `gtk.Label.properties.yalign` property for `label`.
    extern fn gtk_label_get_yalign(p_label: *Label) f32;
    pub const getYalign = gtk_label_get_yalign;

    /// Selects a range of characters in the label, if the label is selectable.
    /// See `gtk.Label.setSelectable`. If the label is not selectable,
    /// this function has no effect. If `start_offset` or
    /// `end_offset` are -1, then the end of the label will be substituted.
    extern fn gtk_label_select_region(p_label: *Label, p_start_offset: c_int, p_end_offset: c_int) void;
    pub const selectRegion = gtk_label_select_region;

    /// Sets the angle of rotation for the label. An angle of 90 reads from
    /// from bottom to top, an angle of 270, from top to bottom. The angle
    /// setting for the label is ignored if the label is selectable,
    /// wrapped, or ellipsized.
    extern fn gtk_label_set_angle(p_label: *Label, p_angle: f64) void;
    pub const setAngle = gtk_label_set_angle;

    /// Sets a `pango.AttrList`; the attributes in the list are applied to the
    /// label text.
    ///
    /// The attributes set with this function will be applied
    /// and merged with any other attributes previously effected by way
    /// of the `gtk.Label.properties.use`-underline or `gtk.Label.properties.use`-markup properties.
    /// While it is not recommended to mix markup strings with manually set
    /// attributes, if you must; know that the attributes will be applied
    /// to the label after the markup string is parsed.
    extern fn gtk_label_set_attributes(p_label: *Label, p_attrs: ?*pango.AttrList) void;
    pub const setAttributes = gtk_label_set_attributes;

    /// Sets the mode used to ellipsize (add an ellipsis: "...") to the text
    /// if there is not enough space to render the entire string.
    extern fn gtk_label_set_ellipsize(p_label: *Label, p_mode: pango.EllipsizeMode) void;
    pub const setEllipsize = gtk_label_set_ellipsize;

    /// Sets the alignment of the lines in the text of the label relative to
    /// each other. `GTK_JUSTIFY_LEFT` is the default value when the widget is
    /// first created with `gtk.Label.new`. If you instead want to set the
    /// alignment of the label as a whole, use `gtk.Widget.setHalign` instead.
    /// `gtk.Label.setJustify` has no effect on labels containing only a
    /// single line.
    extern fn gtk_label_set_justify(p_label: *Label, p_jtype: gtk.Justification) void;
    pub const setJustify = gtk_label_set_justify;

    /// Sets the text of the label. The label is interpreted as
    /// including embedded underlines and/or Pango markup depending
    /// on the values of the `gtk.Label.properties.use`-underline and
    /// `gtk.Label.properties.use`-markup properties.
    extern fn gtk_label_set_label(p_label: *Label, p_str: [*:0]const u8) void;
    pub const setLabel = gtk_label_set_label;

    /// Toggles line wrapping within the `gtk.Label` widget. `TRUE` makes it break
    /// lines if text exceeds the widget’s size. `FALSE` lets the text get cut off
    /// by the edge of the widget if it exceeds the widget size.
    ///
    /// Note that setting line wrapping to `TRUE` does not make the label
    /// wrap at its parent container’s width, because GTK+ widgets
    /// conceptually can’t make their requisition depend on the parent
    /// container’s size. For a label that wraps at a specific position,
    /// set the label’s width using `gtk.Widget.setSizeRequest`.
    extern fn gtk_label_set_line_wrap(p_label: *Label, p_wrap: c_int) void;
    pub const setLineWrap = gtk_label_set_line_wrap;

    /// If line wrapping is on (see `gtk.Label.setLineWrap`) this controls how
    /// the line wrapping is done. The default is `PANGO_WRAP_WORD` which means
    /// wrap on word boundaries.
    extern fn gtk_label_set_line_wrap_mode(p_label: *Label, p_wrap_mode: pango.WrapMode) void;
    pub const setLineWrapMode = gtk_label_set_line_wrap_mode;

    /// Sets the number of lines to which an ellipsized, wrapping label
    /// should be limited. This has no effect if the label is not wrapping
    /// or ellipsized. Set this to -1 if you don’t want to limit the
    /// number of lines.
    extern fn gtk_label_set_lines(p_label: *Label, p_lines: c_int) void;
    pub const setLines = gtk_label_set_lines;

    /// Parses `str` which is marked up with the
    /// [Pango text markup language][PangoMarkupFormat], setting the
    /// label’s text and attribute list based on the parse results.
    ///
    /// If the `str` is external data, you may need to escape it with
    /// `glib.markupEscapeText` or `glib.markupPrintfEscaped`:
    ///
    /// ```
    /// GtkWidget *label = gtk_label_new (NULL);
    /// const char *str = "some text";
    /// const char *format = "<span style=\"italic\">\%s</span>";
    /// char *markup;
    ///
    /// markup = g_markup_printf_escaped (format, str);
    /// gtk_label_set_markup (GTK_LABEL (label), markup);
    /// g_free (markup);
    /// ```
    ///
    /// This function will set the `gtk.Label.properties.use`-markup property to `TRUE` as
    /// a side effect.
    ///
    /// If you set the label contents using the `gtk.Label.properties.label` property you
    /// should also ensure that you set the `gtk.Label.properties.use`-markup property
    /// accordingly.
    ///
    /// See also: `gtk.Label.setText`
    extern fn gtk_label_set_markup(p_label: *Label, p_str: [*:0]const u8) void;
    pub const setMarkup = gtk_label_set_markup;

    /// Parses `str` which is marked up with the
    /// [Pango text markup language][PangoMarkupFormat],
    /// setting the label’s text and attribute list based on the parse results.
    /// If characters in `str` are preceded by an underscore, they are underlined
    /// indicating that they represent a keyboard accelerator called a mnemonic.
    ///
    /// The mnemonic key can be used to activate another widget, chosen
    /// automatically, or explicitly using `gtk.Label.setMnemonicWidget`.
    extern fn gtk_label_set_markup_with_mnemonic(p_label: *Label, p_str: [*:0]const u8) void;
    pub const setMarkupWithMnemonic = gtk_label_set_markup_with_mnemonic;

    /// Sets the desired maximum width in characters of `label` to `n_chars`.
    extern fn gtk_label_set_max_width_chars(p_label: *Label, p_n_chars: c_int) void;
    pub const setMaxWidthChars = gtk_label_set_max_width_chars;

    /// If the label has been set so that it has an mnemonic key (using
    /// i.e. `gtk.Label.setMarkupWithMnemonic`,
    /// `gtk.Label.setTextWithMnemonic`, `gtk.Label.newWithMnemonic`
    /// or the “use_underline” property) the label can be associated with a
    /// widget that is the target of the mnemonic. When the label is inside
    /// a widget (like a `gtk.Button` or a `gtk.Notebook` tab) it is
    /// automatically associated with the correct widget, but sometimes
    /// (i.e. when the target is a `gtk.Entry` next to the label) you need to
    /// set it explicitly using this function.
    ///
    /// The target widget will be accelerated by emitting the
    /// GtkWidget::mnemonic-activate signal on it. The default handler for
    /// this signal will activate the widget if there are no mnemonic collisions
    /// and toggle focus between the colliding widgets otherwise.
    extern fn gtk_label_set_mnemonic_widget(p_label: *Label, p_widget: ?*gtk.Widget) void;
    pub const setMnemonicWidget = gtk_label_set_mnemonic_widget;

    /// The pattern of underlines you want under the existing text within the
    /// `gtk.Label` widget.  For example if the current text of the label says
    /// “FooBarBaz” passing a pattern of “___   ___” will underline
    /// “Foo” and “Baz” but not “Bar”.
    extern fn gtk_label_set_pattern(p_label: *Label, p_pattern: [*:0]const u8) void;
    pub const setPattern = gtk_label_set_pattern;

    /// Selectable labels allow the user to select text from the label, for
    /// copy-and-paste.
    extern fn gtk_label_set_selectable(p_label: *Label, p_setting: c_int) void;
    pub const setSelectable = gtk_label_set_selectable;

    /// Sets whether the label is in single line mode.
    extern fn gtk_label_set_single_line_mode(p_label: *Label, p_single_line_mode: c_int) void;
    pub const setSingleLineMode = gtk_label_set_single_line_mode;

    /// Sets the text within the `gtk.Label` widget. It overwrites any text that
    /// was there before.
    ///
    /// This function will clear any previously set mnemonic accelerators, and
    /// set the `gtk.Label.properties.use`-underline property to `FALSE` as a side effect.
    ///
    /// This function will set the `gtk.Label.properties.use`-markup property to `FALSE`
    /// as a side effect.
    ///
    /// See also: `gtk.Label.setMarkup`
    extern fn gtk_label_set_text(p_label: *Label, p_str: [*:0]const u8) void;
    pub const setText = gtk_label_set_text;

    /// Sets the label’s text from the string `str`.
    /// If characters in `str` are preceded by an underscore, they are underlined
    /// indicating that they represent a keyboard accelerator called a mnemonic.
    /// The mnemonic key can be used to activate another widget, chosen
    /// automatically, or explicitly using `gtk.Label.setMnemonicWidget`.
    extern fn gtk_label_set_text_with_mnemonic(p_label: *Label, p_str: [*:0]const u8) void;
    pub const setTextWithMnemonic = gtk_label_set_text_with_mnemonic;

    /// Sets whether the label should keep track of clicked
    /// links (and use a different color for them).
    extern fn gtk_label_set_track_visited_links(p_label: *Label, p_track_links: c_int) void;
    pub const setTrackVisitedLinks = gtk_label_set_track_visited_links;

    /// Sets whether the text of the label contains markup in
    /// [Pango’s text markup language][PangoMarkupFormat].
    /// See `gtk.Label.setMarkup`.
    extern fn gtk_label_set_use_markup(p_label: *Label, p_setting: c_int) void;
    pub const setUseMarkup = gtk_label_set_use_markup;

    /// If true, an underline in the text indicates the next character should be
    /// used for the mnemonic accelerator key.
    extern fn gtk_label_set_use_underline(p_label: *Label, p_setting: c_int) void;
    pub const setUseUnderline = gtk_label_set_use_underline;

    /// Sets the desired width in characters of `label` to `n_chars`.
    extern fn gtk_label_set_width_chars(p_label: *Label, p_n_chars: c_int) void;
    pub const setWidthChars = gtk_label_set_width_chars;

    /// Sets the `gtk.Label.properties.xalign` property for `label`.
    extern fn gtk_label_set_xalign(p_label: *Label, p_xalign: f32) void;
    pub const setXalign = gtk_label_set_xalign;

    /// Sets the `gtk.Label.properties.yalign` property for `label`.
    extern fn gtk_label_set_yalign(p_label: *Label, p_yalign: f32) void;
    pub const setYalign = gtk_label_set_yalign;

    extern fn gtk_label_get_type() usize;
    pub const getGObjectType = gtk_label_get_type;

    extern fn g_object_ref(p_self: *gtk.Label) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Label) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Label, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LabelAccessible = extern struct {
    pub const Parent = gtk.WidgetAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Hypertext, atk.Text };
    pub const Class = gtk.LabelAccessibleClass;
    f_parent: gtk.WidgetAccessible,
    f_priv: ?*gtk.LabelAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_label_accessible_get_type() usize;
    pub const getGObjectType = gtk_label_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.LabelAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.LabelAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *LabelAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.Layout` is similar to `gtk.DrawingArea` in that it’s a “blank slate” and
/// doesn’t do anything except paint a blank background by default. It’s
/// different in that it supports scrolling natively due to implementing
/// `gtk.Scrollable`, and can contain child widgets since it’s a `gtk.Container`.
///
/// If you just want to draw, a `gtk.DrawingArea` is a better choice since it has
/// lower overhead. If you just need to position child widgets at specific
/// points, then `gtk.Fixed` provides that functionality on its own.
///
/// When handling expose events on a `gtk.Layout`, you must draw to the `gdk.Window`
/// returned by `gtk.Layout.getBinWindow`, rather than to the one returned by
/// `gtk.Widget.getWindow` as you would for a `gtk.DrawingArea`.
pub const Layout = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Scrollable };
    pub const Class = gtk.LayoutClass;
    f_container: gtk.Container,
    f_priv: ?*gtk.LayoutPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const height = struct {
            pub const name = "height";

            pub const Type = c_uint;
        };

        pub const width = struct {
            pub const name = "width";

            pub const Type = c_uint;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.Layout`. Unless you have a specific adjustment
    /// you’d like the layout to use for scrolling, pass `NULL` for
    /// `hadjustment` and `vadjustment`.
    extern fn gtk_layout_new(p_hadjustment: ?*gtk.Adjustment, p_vadjustment: ?*gtk.Adjustment) *gtk.Layout;
    pub const new = gtk_layout_new;

    /// Retrieve the bin window of the layout used for drawing operations.
    extern fn gtk_layout_get_bin_window(p_layout: *Layout) *gdk.Window;
    pub const getBinWindow = gtk_layout_get_bin_window;

    /// This function should only be called after the layout has been
    /// placed in a `gtk.ScrolledWindow` or otherwise configured for
    /// scrolling. It returns the `gtk.Adjustment` used for communication
    /// between the horizontal scrollbar and `layout`.
    ///
    /// See `gtk.ScrolledWindow`, `gtk.Scrollbar`, `gtk.Adjustment` for details.
    extern fn gtk_layout_get_hadjustment(p_layout: *Layout) *gtk.Adjustment;
    pub const getHadjustment = gtk_layout_get_hadjustment;

    /// Gets the size that has been set on the layout, and that determines
    /// the total extents of the layout’s scrollbar area. See
    /// gtk_layout_set_size ().
    extern fn gtk_layout_get_size(p_layout: *Layout, p_width: ?*c_uint, p_height: ?*c_uint) void;
    pub const getSize = gtk_layout_get_size;

    /// This function should only be called after the layout has been
    /// placed in a `gtk.ScrolledWindow` or otherwise configured for
    /// scrolling. It returns the `gtk.Adjustment` used for communication
    /// between the vertical scrollbar and `layout`.
    ///
    /// See `gtk.ScrolledWindow`, `gtk.Scrollbar`, `gtk.Adjustment` for details.
    extern fn gtk_layout_get_vadjustment(p_layout: *Layout) *gtk.Adjustment;
    pub const getVadjustment = gtk_layout_get_vadjustment;

    /// Moves a current child of `layout` to a new position.
    extern fn gtk_layout_move(p_layout: *Layout, p_child_widget: *gtk.Widget, p_x: c_int, p_y: c_int) void;
    pub const move = gtk_layout_move;

    /// Adds `child_widget` to `layout`, at position (`x`,`y`).
    /// `layout` becomes the new parent container of `child_widget`.
    extern fn gtk_layout_put(p_layout: *Layout, p_child_widget: *gtk.Widget, p_x: c_int, p_y: c_int) void;
    pub const put = gtk_layout_put;

    /// Sets the horizontal scroll adjustment for the layout.
    ///
    /// See `gtk.ScrolledWindow`, `gtk.Scrollbar`, `gtk.Adjustment` for details.
    extern fn gtk_layout_set_hadjustment(p_layout: *Layout, p_adjustment: ?*gtk.Adjustment) void;
    pub const setHadjustment = gtk_layout_set_hadjustment;

    /// Sets the size of the scrollable area of the layout.
    extern fn gtk_layout_set_size(p_layout: *Layout, p_width: c_uint, p_height: c_uint) void;
    pub const setSize = gtk_layout_set_size;

    /// Sets the vertical scroll adjustment for the layout.
    ///
    /// See `gtk.ScrolledWindow`, `gtk.Scrollbar`, `gtk.Adjustment` for details.
    extern fn gtk_layout_set_vadjustment(p_layout: *Layout, p_adjustment: ?*gtk.Adjustment) void;
    pub const setVadjustment = gtk_layout_set_vadjustment;

    extern fn gtk_layout_get_type() usize;
    pub const getGObjectType = gtk_layout_get_type;

    extern fn g_object_ref(p_self: *gtk.Layout) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Layout) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Layout, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.LevelBar` is a bar widget that can be used
/// as a level indicator. Typical use cases are displaying the strength
/// of a password, or showing the charge level of a battery.
///
/// Use `gtk.LevelBar.setValue` to set the current value, and
/// `gtk.LevelBar.addOffsetValue` to set the value offsets at which
/// the bar will be considered in a different state. GTK will add a few
/// offsets by default on the level bar: `GTK_LEVEL_BAR_OFFSET_LOW`,
/// `GTK_LEVEL_BAR_OFFSET_HIGH` and `GTK_LEVEL_BAR_OFFSET_FULL`, with
/// values 0.25, 0.75 and 1.0 respectively.
///
/// Note that it is your responsibility to update preexisting offsets
/// when changing the minimum or maximum value. GTK+ will simply clamp
/// them to the new range.
///
/// ## Adding a custom offset on the bar
///
/// ```
///
/// static GtkWidget *
/// create_level_bar (void)
/// {
///   GtkWidget *widget;
///   GtkLevelBar *bar;
///
///   widget = gtk_level_bar_new ();
///   bar = GTK_LEVEL_BAR (widget);
///
///   // This changes the value of the default low offset
///
///   gtk_level_bar_add_offset_value (bar,
///                                   GTK_LEVEL_BAR_OFFSET_LOW,
///                                   0.10);
///
///   // This adds a new offset to the bar; the application will
///   // be able to change its color CSS like this:
///   //
///   // levelbar block.my-offset {
///   //   background-color: magenta;
///   //   border-style: solid;
///   //   border-color: black;
///   //   border-style: 1px;
///   // }
///
///   gtk_level_bar_add_offset_value (bar, "my-offset", 0.60);
///
///   return widget;
/// }
/// ```
///
/// The default interval of values is between zero and one, but it’s possible to
/// modify the interval using `gtk.LevelBar.setMinValue` and
/// `gtk.LevelBar.setMaxValue`. The value will be always drawn in proportion to
/// the admissible interval, i.e. a value of 15 with a specified interval between
/// 10 and 20 is equivalent to a value of 0.5 with an interval between 0 and 1.
/// When `GTK_LEVEL_BAR_MODE_DISCRETE` is used, the bar level is rendered
/// as a finite number of separated blocks instead of a single one. The number
/// of blocks that will be rendered is equal to the number of units specified by
/// the admissible interval.
///
/// For instance, to build a bar rendered with five blocks, it’s sufficient to
/// set the minimum value to 0 and the maximum value to 5 after changing the indicator
/// mode to discrete.
///
/// GtkLevelBar was introduced in GTK+ 3.6.
///
/// # GtkLevelBar as GtkBuildable
///
/// The GtkLevelBar implementation of the GtkBuildable interface supports a
/// custom `<offsets>` element, which can contain any number of `<offset>` elements,
/// each of which must have "name" and "value" attributes.
///
/// # CSS nodes
///
/// ```
/// levelbar[.discrete]
/// ╰── trough
///     ├── block.filled.level-name
///     ┊
///     ├── block.empty
///     ┊
/// ```
///
/// GtkLevelBar has a main CSS node with name levelbar and one of the style
/// classes .discrete or .continuous and a subnode with name trough. Below the
/// trough node are a number of nodes with name block and style class .filled
/// or .empty. In continuous mode, there is exactly one node of each, in discrete
/// mode, the number of filled and unfilled nodes corresponds to blocks that are
/// drawn. The block.filled nodes also get a style class .level-name corresponding
/// to the level for the current value.
///
/// In horizontal orientation, the nodes are always arranged from left to right,
/// regardless of text direction.
pub const LevelBar = extern struct {
    pub const Parent = gtk.Widget;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.LevelBarClass;
    f_parent: gtk.Widget,
    f_priv: ?*gtk.LevelBarPrivate,

    pub const virtual_methods = struct {
        pub const offset_changed = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_name: [*:0]const u8) void {
                return gobject.ext.as(LevelBar.Class, p_class).f_offset_changed.?(gobject.ext.as(LevelBar, p_self), p_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_name: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(LevelBar.Class, p_class).f_offset_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Level bars normally grow from top to bottom or left to right.
        /// Inverted level bars grow in the opposite direction.
        pub const inverted = struct {
            pub const name = "inverted";

            pub const Type = c_int;
        };

        /// The `gtk.LevelBar.properties.max`-value property determaxes the maximum value of
        /// the interval that can be displayed by the bar.
        pub const max_value = struct {
            pub const name = "max-value";

            pub const Type = f64;
        };

        /// The `gtk.LevelBar.properties.min`-value property determines the minimum value of
        /// the interval that can be displayed by the bar.
        pub const min_value = struct {
            pub const name = "min-value";

            pub const Type = f64;
        };

        /// The `gtk.LevelBar.properties.mode` property determines the way `gtk.LevelBar`
        /// interprets the value properties to draw the level fill area.
        /// Specifically, when the value is `GTK_LEVEL_BAR_MODE_CONTINUOUS`,
        /// `gtk.LevelBar` will draw a single block representing the current value in
        /// that area; when the value is `GTK_LEVEL_BAR_MODE_DISCRETE`,
        /// the widget will draw a succession of separate blocks filling the
        /// draw area, with the number of blocks being equal to the units separating
        /// the integral roundings of `gtk.LevelBar.properties.min`-value and `gtk.LevelBar.properties.max`-value.
        pub const mode = struct {
            pub const name = "mode";

            pub const Type = gtk.LevelBarMode;
        };

        /// The `gtk.LevelBar.properties.value` property determines the currently
        /// filled value of the level bar.
        pub const value = struct {
            pub const name = "value";

            pub const Type = f64;
        };
    };

    pub const signals = struct {
        /// Emitted when an offset specified on the bar changes value as an
        /// effect to `gtk.LevelBar.addOffsetValue` being called.
        ///
        /// The signal supports detailed connections; you can connect to the
        /// detailed signal "changed::x" in order to only receive callbacks when
        /// the value of offset "x" changes.
        pub const offset_changed = struct {
            pub const name = "offset-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_name: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(LevelBar, p_instance))),
                    gobject.signalLookup("offset-changed", LevelBar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.LevelBar`.
    extern fn gtk_level_bar_new() *gtk.LevelBar;
    pub const new = gtk_level_bar_new;

    /// Utility constructor that creates a new `gtk.LevelBar` for the specified
    /// interval.
    extern fn gtk_level_bar_new_for_interval(p_min_value: f64, p_max_value: f64) *gtk.LevelBar;
    pub const newForInterval = gtk_level_bar_new_for_interval;

    /// Adds a new offset marker on `self` at the position specified by `value`.
    /// When the bar value is in the interval topped by `value` (or between `value`
    /// and `gtk.LevelBar.properties.max`-value in case the offset is the last one on the bar)
    /// a style class named `level-``name` will be applied
    /// when rendering the level bar fill.
    /// If another offset marker named `name` exists, its value will be
    /// replaced by `value`.
    extern fn gtk_level_bar_add_offset_value(p_self: *LevelBar, p_name: [*:0]const u8, p_value: f64) void;
    pub const addOffsetValue = gtk_level_bar_add_offset_value;

    /// Return the value of the `gtk.LevelBar.properties.inverted` property.
    extern fn gtk_level_bar_get_inverted(p_self: *LevelBar) c_int;
    pub const getInverted = gtk_level_bar_get_inverted;

    /// Returns the value of the `gtk.LevelBar.properties.max`-value property.
    extern fn gtk_level_bar_get_max_value(p_self: *LevelBar) f64;
    pub const getMaxValue = gtk_level_bar_get_max_value;

    /// Returns the value of the `gtk.LevelBar.properties.min`-value property.
    extern fn gtk_level_bar_get_min_value(p_self: *LevelBar) f64;
    pub const getMinValue = gtk_level_bar_get_min_value;

    /// Returns the value of the `gtk.LevelBar.properties.mode` property.
    extern fn gtk_level_bar_get_mode(p_self: *LevelBar) gtk.LevelBarMode;
    pub const getMode = gtk_level_bar_get_mode;

    /// Fetches the value specified for the offset marker `name` in `self`,
    /// returning `TRUE` in case an offset named `name` was found.
    extern fn gtk_level_bar_get_offset_value(p_self: *LevelBar, p_name: ?[*:0]const u8, p_value: *f64) c_int;
    pub const getOffsetValue = gtk_level_bar_get_offset_value;

    /// Returns the value of the `gtk.LevelBar.properties.value` property.
    extern fn gtk_level_bar_get_value(p_self: *LevelBar) f64;
    pub const getValue = gtk_level_bar_get_value;

    /// Removes an offset marker previously added with
    /// `gtk.LevelBar.addOffsetValue`.
    extern fn gtk_level_bar_remove_offset_value(p_self: *LevelBar, p_name: ?[*:0]const u8) void;
    pub const removeOffsetValue = gtk_level_bar_remove_offset_value;

    /// Sets the value of the `gtk.LevelBar.properties.inverted` property.
    extern fn gtk_level_bar_set_inverted(p_self: *LevelBar, p_inverted: c_int) void;
    pub const setInverted = gtk_level_bar_set_inverted;

    /// Sets the value of the `gtk.LevelBar.properties.max`-value property.
    ///
    /// You probably want to update preexisting level offsets after calling
    /// this function.
    extern fn gtk_level_bar_set_max_value(p_self: *LevelBar, p_value: f64) void;
    pub const setMaxValue = gtk_level_bar_set_max_value;

    /// Sets the value of the `gtk.LevelBar.properties.min`-value property.
    ///
    /// You probably want to update preexisting level offsets after calling
    /// this function.
    extern fn gtk_level_bar_set_min_value(p_self: *LevelBar, p_value: f64) void;
    pub const setMinValue = gtk_level_bar_set_min_value;

    /// Sets the value of the `gtk.LevelBar.properties.mode` property.
    extern fn gtk_level_bar_set_mode(p_self: *LevelBar, p_mode: gtk.LevelBarMode) void;
    pub const setMode = gtk_level_bar_set_mode;

    /// Sets the value of the `gtk.LevelBar.properties.value` property.
    extern fn gtk_level_bar_set_value(p_self: *LevelBar, p_value: f64) void;
    pub const setValue = gtk_level_bar_set_value;

    extern fn gtk_level_bar_get_type() usize;
    pub const getGObjectType = gtk_level_bar_get_type;

    extern fn g_object_ref(p_self: *gtk.LevelBar) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.LevelBar) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *LevelBar, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LevelBarAccessible = extern struct {
    pub const Parent = gtk.WidgetAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Value };
    pub const Class = gtk.LevelBarAccessibleClass;
    f_parent: gtk.WidgetAccessible,
    f_priv: ?*gtk.LevelBarAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_level_bar_accessible_get_type() usize;
    pub const getGObjectType = gtk_level_bar_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.LevelBarAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.LevelBarAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *LevelBarAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkLinkButton is a `gtk.Button` with a hyperlink, similar to the one
/// used by web browsers, which triggers an action when clicked. It is useful
/// to show quick links to resources.
///
/// A link button is created by calling either `gtk.LinkButton.new` or
/// `gtk.LinkButton.newWithLabel`. If using the former, the URI you pass
/// to the constructor is used as a label for the widget.
///
/// The URI bound to a GtkLinkButton can be set specifically using
/// `gtk.LinkButton.setUri`, and retrieved using `gtk.LinkButton.getUri`.
///
/// By default, GtkLinkButton calls `gtk.showUriOnWindow` when the button is
/// clicked. This behaviour can be overridden by connecting to the
/// `gtk.LinkButton.signals.activate`-link signal and returning `TRUE` from the
/// signal handler.
///
/// # CSS nodes
///
/// GtkLinkButton has a single CSS node with name button. To differentiate
/// it from a plain `gtk.Button`, it gets the .link style class.
pub const LinkButton = extern struct {
    pub const Parent = gtk.Button;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.LinkButtonClass;
    f_parent_instance: gtk.Button,
    f_priv: ?*gtk.LinkButtonPrivate,

    pub const virtual_methods = struct {
        /// class handler for the `gtk.LinkButton.signals.activate`-link signal
        pub const activate_link = struct {
            pub fn call(p_class: anytype, p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(LinkButton.Class, p_class).f_activate_link.?(gobject.ext.as(LinkButton, p_button));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(LinkButton.Class, p_class).f_activate_link = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The URI bound to this button.
        pub const uri = struct {
            pub const name = "uri";

            pub const Type = ?[*:0]u8;
        };

        /// The 'visited' state of this button. A visited link is drawn in a
        /// different color.
        pub const visited = struct {
            pub const name = "visited";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::activate-link signal is emitted each time the `gtk.LinkButton`
        /// has been clicked.
        ///
        /// The default handler will call `gtk.showUriOnWindow` with the URI stored inside
        /// the `gtk.LinkButton.properties.uri` property.
        ///
        /// To override the default behavior, you can connect to the ::activate-link
        /// signal and stop the propagation of the signal by returning `TRUE` from
        /// your handler.
        pub const activate_link = struct {
            pub const name = "activate-link";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(LinkButton, p_instance))),
                    gobject.signalLookup("activate-link", LinkButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.LinkButton` with the URI as its text.
    extern fn gtk_link_button_new(p_uri: [*:0]const u8) *gtk.LinkButton;
    pub const new = gtk_link_button_new;

    /// Creates a new `gtk.LinkButton` containing a label.
    extern fn gtk_link_button_new_with_label(p_uri: [*:0]const u8, p_label: ?[*:0]const u8) *gtk.LinkButton;
    pub const newWithLabel = gtk_link_button_new_with_label;

    /// Retrieves the URI set using `gtk.LinkButton.setUri`.
    extern fn gtk_link_button_get_uri(p_link_button: *LinkButton) [*:0]const u8;
    pub const getUri = gtk_link_button_get_uri;

    /// Retrieves the “visited” state of the URI where the `gtk.LinkButton`
    /// points. The button becomes visited when it is clicked. If the URI
    /// is changed on the button, the “visited” state is unset again.
    ///
    /// The state may also be changed using `gtk.LinkButton.setVisited`.
    extern fn gtk_link_button_get_visited(p_link_button: *LinkButton) c_int;
    pub const getVisited = gtk_link_button_get_visited;

    /// Sets `uri` as the URI where the `gtk.LinkButton` points. As a side-effect
    /// this unsets the “visited” state of the button.
    extern fn gtk_link_button_set_uri(p_link_button: *LinkButton, p_uri: [*:0]const u8) void;
    pub const setUri = gtk_link_button_set_uri;

    /// Sets the “visited” state of the URI where the `gtk.LinkButton`
    /// points.  See `gtk.LinkButton.getVisited` for more details.
    extern fn gtk_link_button_set_visited(p_link_button: *LinkButton, p_visited: c_int) void;
    pub const setVisited = gtk_link_button_set_visited;

    extern fn gtk_link_button_get_type() usize;
    pub const getGObjectType = gtk_link_button_get_type;

    extern fn g_object_ref(p_self: *gtk.LinkButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.LinkButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *LinkButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LinkButtonAccessible = extern struct {
    pub const Parent = gtk.ButtonAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.HyperlinkImpl, atk.Image };
    pub const Class = gtk.LinkButtonAccessibleClass;
    f_parent: gtk.ButtonAccessible,
    f_priv: ?*gtk.LinkButtonAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_link_button_accessible_get_type() usize;
    pub const getGObjectType = gtk_link_button_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.LinkButtonAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.LinkButtonAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *LinkButtonAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkListBox is a vertical container that contains GtkListBoxRow
/// children. These rows can be dynamically sorted and filtered, and
/// headers can be added dynamically depending on the row content.
/// It also allows keyboard and mouse navigation and selection like
/// a typical list.
///
/// Using GtkListBox is often an alternative to `gtk.TreeView`, especially
/// when the list contents has a more complicated layout than what is allowed
/// by a `gtk.CellRenderer`, or when the contents is interactive (i.e. has a
/// button in it).
///
/// Although a `gtk.ListBox` must have only `gtk.ListBoxRow` children you can
/// add any kind of widget to it via `gtk.Container.add`, and a `gtk.ListBoxRow`
/// widget will automatically be inserted between the list and the widget.
///
/// `GtkListBoxRows` can be marked as activatable or selectable. If a row
/// is activatable, `gtk.ListBox.signals.row`-activated will be emitted for it when
/// the user tries to activate it. If it is selectable, the row will be marked
/// as selected when the user tries to select it.
///
/// The GtkListBox widget was added in GTK+ 3.10.
///
/// # GtkListBox as GtkBuildable
///
/// The GtkListBox implementation of the `gtk.Buildable` interface supports
/// setting a child as the placeholder by specifying “placeholder” as the “type”
/// attribute of a `<child>` element. See `gtk.ListBox.setPlaceholder` for info.
///
/// # CSS nodes
///
/// ```
/// list
/// ╰── row[.activatable]
/// ```
///
/// GtkListBox uses a single CSS node named list. Each GtkListBoxRow uses
/// a single CSS node named row. The row nodes get the .activatable
/// style class added when appropriate.
pub const ListBox = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.ListBoxClass;
    f_parent_instance: gtk.Container,

    pub const virtual_methods = struct {
        /// Class handler for the `gtk.ListBox.signals.activate`-cursor-row signal
        pub const activate_cursor_row = struct {
            pub fn call(p_class: anytype, p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ListBox.Class, p_class).f_activate_cursor_row.?(gobject.ext.as(ListBox, p_box));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ListBox.Class, p_class).f_activate_cursor_row = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the `gtk.ListBox.signals.move`-cursor signal
        pub const move_cursor = struct {
            pub fn call(p_class: anytype, p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_step: gtk.MovementStep, p_count: c_int) void {
                return gobject.ext.as(ListBox.Class, p_class).f_move_cursor.?(gobject.ext.as(ListBox, p_box), p_step, p_count);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_step: gtk.MovementStep, p_count: c_int) callconv(.c) void) void {
                gobject.ext.as(ListBox.Class, p_class).f_move_cursor = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the `gtk.ListBox.signals.row`-activated signal
        pub const row_activated = struct {
            pub fn call(p_class: anytype, p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_row: *gtk.ListBoxRow) void {
                return gobject.ext.as(ListBox.Class, p_class).f_row_activated.?(gobject.ext.as(ListBox, p_box), p_row);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_row: *gtk.ListBoxRow) callconv(.c) void) void {
                gobject.ext.as(ListBox.Class, p_class).f_row_activated = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the `gtk.ListBox.signals.row`-selected signal
        pub const row_selected = struct {
            pub fn call(p_class: anytype, p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_row: *gtk.ListBoxRow) void {
                return gobject.ext.as(ListBox.Class, p_class).f_row_selected.?(gobject.ext.as(ListBox, p_box), p_row);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_row: *gtk.ListBoxRow) callconv(.c) void) void {
                gobject.ext.as(ListBox.Class, p_class).f_row_selected = @ptrCast(p_implementation);
            }
        };

        /// Select all children of `box`, if the selection mode allows it.
        pub const select_all = struct {
            pub fn call(p_class: anytype, p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ListBox.Class, p_class).f_select_all.?(gobject.ext.as(ListBox, p_box));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ListBox.Class, p_class).f_select_all = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the `gtk.ListBox.signals.selected`-rows-changed signal
        pub const selected_rows_changed = struct {
            pub fn call(p_class: anytype, p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ListBox.Class, p_class).f_selected_rows_changed.?(gobject.ext.as(ListBox, p_box));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ListBox.Class, p_class).f_selected_rows_changed = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the `gtk.ListBox.signals.toggle`-cursor-row signal
        pub const toggle_cursor_row = struct {
            pub fn call(p_class: anytype, p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ListBox.Class, p_class).f_toggle_cursor_row.?(gobject.ext.as(ListBox, p_box));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ListBox.Class, p_class).f_toggle_cursor_row = @ptrCast(p_implementation);
            }
        };

        /// Unselect all children of `box`, if the selection mode allows it.
        pub const unselect_all = struct {
            pub fn call(p_class: anytype, p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ListBox.Class, p_class).f_unselect_all.?(gobject.ext.as(ListBox, p_box));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_box: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ListBox.Class, p_class).f_unselect_all = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const activate_on_single_click = struct {
            pub const name = "activate-on-single-click";

            pub const Type = c_int;
        };

        pub const selection_mode = struct {
            pub const name = "selection-mode";

            pub const Type = gtk.SelectionMode;
        };
    };

    pub const signals = struct {
        pub const activate_cursor_row = struct {
            pub const name = "activate-cursor-row";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ListBox, p_instance))),
                    gobject.signalLookup("activate-cursor-row", ListBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const move_cursor = struct {
            pub const name = "move-cursor";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: gtk.MovementStep, p_p0: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ListBox, p_instance))),
                    gobject.signalLookup("move-cursor", ListBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::row-activated signal is emitted when a row has been activated by the user.
        pub const row_activated = struct {
            pub const name = "row-activated";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_row: *gtk.ListBoxRow, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ListBox, p_instance))),
                    gobject.signalLookup("row-activated", ListBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::row-selected signal is emitted when a new row is selected, or
        /// (with a `NULL` `row`) when the selection is cleared.
        ///
        /// When the `box` is using `GTK_SELECTION_MULTIPLE`, this signal will not
        /// give you the full picture of selection changes, and you should use
        /// the `gtk.ListBox.signals.selected`-rows-changed signal instead.
        pub const row_selected = struct {
            pub const name = "row-selected";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_row: ?*gtk.ListBoxRow, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ListBox, p_instance))),
                    gobject.signalLookup("row-selected", ListBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::select-all signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted to select all children of the box, if the selection
        /// mode permits it.
        ///
        /// The default bindings for this signal is Ctrl-a.
        pub const select_all = struct {
            pub const name = "select-all";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ListBox, p_instance))),
                    gobject.signalLookup("select-all", ListBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::selected-rows-changed signal is emitted when the
        /// set of selected rows changes.
        pub const selected_rows_changed = struct {
            pub const name = "selected-rows-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ListBox, p_instance))),
                    gobject.signalLookup("selected-rows-changed", ListBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const toggle_cursor_row = struct {
            pub const name = "toggle-cursor-row";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ListBox, p_instance))),
                    gobject.signalLookup("toggle-cursor-row", ListBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::unselect-all signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted to unselect all children of the box, if the selection
        /// mode permits it.
        ///
        /// The default bindings for this signal is Ctrl-Shift-a.
        pub const unselect_all = struct {
            pub const name = "unselect-all";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ListBox, p_instance))),
                    gobject.signalLookup("unselect-all", ListBox.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.ListBox` container.
    extern fn gtk_list_box_new() *gtk.ListBox;
    pub const new = gtk_list_box_new;

    /// Binds `model` to `box`.
    ///
    /// If `box` was already bound to a model, that previous binding is
    /// destroyed.
    ///
    /// The contents of `box` are cleared and then filled with widgets that
    /// represent items from `model`. `box` is updated whenever `model` changes.
    /// If `model` is `NULL`, `box` is left empty.
    ///
    /// It is undefined to add or remove widgets directly (for example, with
    /// `gtk.ListBox.insert` or `gtk.Container.add`) while `box` is bound to a
    /// model.
    ///
    /// Note that using a model is incompatible with the filtering and sorting
    /// functionality in GtkListBox. When using a model, filtering and sorting
    /// should be implemented by the model.
    extern fn gtk_list_box_bind_model(p_box: *ListBox, p_model: ?*gio.ListModel, p_create_widget_func: ?gtk.ListBoxCreateWidgetFunc, p_user_data: ?*anyopaque, p_user_data_free_func: ?glib.DestroyNotify) void;
    pub const bindModel = gtk_list_box_bind_model;

    /// This is a helper function for implementing DnD onto a `gtk.ListBox`.
    /// The passed in `row` will be highlighted via `gtk.Widget.dragHighlight`,
    /// and any previously highlighted row will be unhighlighted.
    ///
    /// The row will also be unhighlighted when the widget gets
    /// a drag leave event.
    extern fn gtk_list_box_drag_highlight_row(p_box: *ListBox, p_row: *gtk.ListBoxRow) void;
    pub const dragHighlightRow = gtk_list_box_drag_highlight_row;

    /// If a row has previously been highlighted via `gtk.ListBox.dragHighlightRow`
    /// it will have the highlight removed.
    extern fn gtk_list_box_drag_unhighlight_row(p_box: *ListBox) void;
    pub const dragUnhighlightRow = gtk_list_box_drag_unhighlight_row;

    /// Returns whether rows activate on single clicks.
    extern fn gtk_list_box_get_activate_on_single_click(p_box: *ListBox) c_int;
    pub const getActivateOnSingleClick = gtk_list_box_get_activate_on_single_click;

    /// Gets the adjustment (if any) that the widget uses to
    /// for vertical scrolling.
    extern fn gtk_list_box_get_adjustment(p_box: *ListBox) *gtk.Adjustment;
    pub const getAdjustment = gtk_list_box_get_adjustment;

    /// Gets the n-th child in the list (not counting headers).
    /// If `_index` is negative or larger than the number of items in the
    /// list, `NULL` is returned.
    extern fn gtk_list_box_get_row_at_index(p_box: *ListBox, p_index_: c_int) ?*gtk.ListBoxRow;
    pub const getRowAtIndex = gtk_list_box_get_row_at_index;

    /// Gets the row at the `y` position.
    extern fn gtk_list_box_get_row_at_y(p_box: *ListBox, p_y: c_int) ?*gtk.ListBoxRow;
    pub const getRowAtY = gtk_list_box_get_row_at_y;

    /// Gets the selected row.
    ///
    /// Note that the box may allow multiple selection, in which
    /// case you should use `gtk.ListBox.selectedForeach` to
    /// find all selected rows.
    extern fn gtk_list_box_get_selected_row(p_box: *ListBox) *gtk.ListBoxRow;
    pub const getSelectedRow = gtk_list_box_get_selected_row;

    /// Creates a list of all selected children.
    extern fn gtk_list_box_get_selected_rows(p_box: *ListBox) *glib.List;
    pub const getSelectedRows = gtk_list_box_get_selected_rows;

    /// Gets the selection mode of the listbox.
    extern fn gtk_list_box_get_selection_mode(p_box: *ListBox) gtk.SelectionMode;
    pub const getSelectionMode = gtk_list_box_get_selection_mode;

    /// Insert the `child` into the `box` at `position`. If a sort function is
    /// set, the widget will actually be inserted at the calculated position and
    /// this function has the same effect of `gtk.Container.add`.
    ///
    /// If `position` is -1, or larger than the total number of items in the
    /// `box`, then the `child` will be appended to the end.
    extern fn gtk_list_box_insert(p_box: *ListBox, p_child: *gtk.Widget, p_position: c_int) void;
    pub const insert = gtk_list_box_insert;

    /// Update the filtering for all rows. Call this when result
    /// of the filter function on the `box` is changed due
    /// to an external factor. For instance, this would be used
    /// if the filter function just looked for a specific search
    /// string and the entry with the search string has changed.
    extern fn gtk_list_box_invalidate_filter(p_box: *ListBox) void;
    pub const invalidateFilter = gtk_list_box_invalidate_filter;

    /// Update the separators for all rows. Call this when result
    /// of the header function on the `box` is changed due
    /// to an external factor.
    extern fn gtk_list_box_invalidate_headers(p_box: *ListBox) void;
    pub const invalidateHeaders = gtk_list_box_invalidate_headers;

    /// Update the sorting for all rows. Call this when result
    /// of the sort function on the `box` is changed due
    /// to an external factor.
    extern fn gtk_list_box_invalidate_sort(p_box: *ListBox) void;
    pub const invalidateSort = gtk_list_box_invalidate_sort;

    /// Prepend a widget to the list. If a sort function is set, the widget will
    /// actually be inserted at the calculated position and this function has the
    /// same effect of `gtk.Container.add`.
    extern fn gtk_list_box_prepend(p_box: *ListBox, p_child: *gtk.Widget) void;
    pub const prepend = gtk_list_box_prepend;

    /// Select all children of `box`, if the selection mode allows it.
    extern fn gtk_list_box_select_all(p_box: *ListBox) void;
    pub const selectAll = gtk_list_box_select_all;

    /// Make `row` the currently selected row.
    extern fn gtk_list_box_select_row(p_box: *ListBox, p_row: ?*gtk.ListBoxRow) void;
    pub const selectRow = gtk_list_box_select_row;

    /// Calls a function for each selected child.
    ///
    /// Note that the selection cannot be modified from within this function.
    extern fn gtk_list_box_selected_foreach(p_box: *ListBox, p_func: gtk.ListBoxForeachFunc, p_data: ?*anyopaque) void;
    pub const selectedForeach = gtk_list_box_selected_foreach;

    /// If `single` is `TRUE`, rows will be activated when you click on them,
    /// otherwise you need to double-click.
    extern fn gtk_list_box_set_activate_on_single_click(p_box: *ListBox, p_single: c_int) void;
    pub const setActivateOnSingleClick = gtk_list_box_set_activate_on_single_click;

    /// Sets the adjustment (if any) that the widget uses to
    /// for vertical scrolling. For instance, this is used
    /// to get the page size for PageUp/Down key handling.
    ///
    /// In the normal case when the `box` is packed inside
    /// a `gtk.ScrolledWindow` the adjustment from that will
    /// be picked up automatically, so there is no need
    /// to manually do that.
    extern fn gtk_list_box_set_adjustment(p_box: *ListBox, p_adjustment: ?*gtk.Adjustment) void;
    pub const setAdjustment = gtk_list_box_set_adjustment;

    /// By setting a filter function on the `box` one can decide dynamically which
    /// of the rows to show. For instance, to implement a search function on a list that
    /// filters the original list to only show the matching rows.
    ///
    /// The `filter_func` will be called for each row after the call, and it will
    /// continue to be called each time a row changes (via `gtk.ListBoxRow.changed`) or
    /// when `gtk.ListBox.invalidateFilter` is called.
    ///
    /// Note that using a filter function is incompatible with using a model
    /// (see `gtk.ListBox.bindModel`).
    extern fn gtk_list_box_set_filter_func(p_box: *ListBox, p_filter_func: ?gtk.ListBoxFilterFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setFilterFunc = gtk_list_box_set_filter_func;

    /// By setting a header function on the `box` one can dynamically add headers
    /// in front of rows, depending on the contents of the row and its position in the list.
    /// For instance, one could use it to add headers in front of the first item of a
    /// new kind, in a list sorted by the kind.
    ///
    /// The `update_header` can look at the current header widget using `gtk.ListBoxRow.getHeader`
    /// and either update the state of the widget as needed, or set a new one using
    /// `gtk.ListBoxRow.setHeader`. If no header is needed, set the header to `NULL`.
    ///
    /// Note that you may get many calls `update_header` to this for a particular row when e.g.
    /// changing things that don’t affect the header. In this case it is important for performance
    /// to not blindly replace an existing header with an identical one.
    ///
    /// The `update_header` function will be called for each row after the call, and it will
    /// continue to be called each time a row changes (via `gtk.ListBoxRow.changed`) and when
    /// the row before changes (either by `gtk.ListBoxRow.changed` on the previous row, or when
    /// the previous row becomes a different row). It is also called for all rows when
    /// `gtk.ListBox.invalidateHeaders` is called.
    extern fn gtk_list_box_set_header_func(p_box: *ListBox, p_update_header: ?gtk.ListBoxUpdateHeaderFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setHeaderFunc = gtk_list_box_set_header_func;

    /// Sets the placeholder widget that is shown in the list when
    /// it doesn't display any visible children.
    extern fn gtk_list_box_set_placeholder(p_box: *ListBox, p_placeholder: ?*gtk.Widget) void;
    pub const setPlaceholder = gtk_list_box_set_placeholder;

    /// Sets how selection works in the listbox.
    /// See `gtk.SelectionMode` for details.
    extern fn gtk_list_box_set_selection_mode(p_box: *ListBox, p_mode: gtk.SelectionMode) void;
    pub const setSelectionMode = gtk_list_box_set_selection_mode;

    /// By setting a sort function on the `box` one can dynamically reorder the rows
    /// of the list, based on the contents of the rows.
    ///
    /// The `sort_func` will be called for each row after the call, and will continue to
    /// be called each time a row changes (via `gtk.ListBoxRow.changed`) and when
    /// `gtk.ListBox.invalidateSort` is called.
    ///
    /// Note that using a sort function is incompatible with using a model
    /// (see `gtk.ListBox.bindModel`).
    extern fn gtk_list_box_set_sort_func(p_box: *ListBox, p_sort_func: ?gtk.ListBoxSortFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setSortFunc = gtk_list_box_set_sort_func;

    /// Unselect all children of `box`, if the selection mode allows it.
    extern fn gtk_list_box_unselect_all(p_box: *ListBox) void;
    pub const unselectAll = gtk_list_box_unselect_all;

    /// Unselects a single row of `box`, if the selection mode allows it.
    extern fn gtk_list_box_unselect_row(p_box: *ListBox, p_row: *gtk.ListBoxRow) void;
    pub const unselectRow = gtk_list_box_unselect_row;

    extern fn gtk_list_box_get_type() usize;
    pub const getGObjectType = gtk_list_box_get_type;

    extern fn g_object_ref(p_self: *gtk.ListBox) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ListBox) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ListBox, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ListBoxAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Selection };
    pub const Class = gtk.ListBoxAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.ListBoxAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_list_box_accessible_get_type() usize;
    pub const getGObjectType = gtk_list_box_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ListBoxAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ListBoxAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ListBoxAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ListBoxRow = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Buildable };
    pub const Class = gtk.ListBoxRowClass;
    f_parent_instance: gtk.Bin,

    pub const virtual_methods = struct {
        pub const activate = struct {
            pub fn call(p_class: anytype, p_row: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ListBoxRow.Class, p_class).f_activate.?(gobject.ext.as(ListBoxRow, p_row));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_row: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ListBoxRow.Class, p_class).f_activate = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The property determines whether the `gtk.ListBox.signals.row`-activated
        /// signal will be emitted for this row.
        pub const activatable = struct {
            pub const name = "activatable";

            pub const Type = c_int;
        };

        /// The property determines whether this row can be selected.
        pub const selectable = struct {
            pub const name = "selectable";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// This is a keybinding signal, which will cause this row to be activated.
        ///
        /// If you want to be notified when the user activates a row (by key or not),
        /// use the `gtk.ListBox.signals.row`-activated signal on the row’s parent `gtk.ListBox`.
        pub const activate = struct {
            pub const name = "activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ListBoxRow, p_instance))),
                    gobject.signalLookup("activate", ListBoxRow.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.ListBoxRow`, to be used as a child of a `gtk.ListBox`.
    extern fn gtk_list_box_row_new() *gtk.ListBoxRow;
    pub const new = gtk_list_box_row_new;

    /// Marks `row` as changed, causing any state that depends on this
    /// to be updated. This affects sorting, filtering and headers.
    ///
    /// Note that calls to this method must be in sync with the data
    /// used for the row functions. For instance, if the list is
    /// mirroring some external data set, and *two* rows changed in the
    /// external data set then when you call `gtk.ListBoxRow.changed`
    /// on the first row the sort function must only read the new data
    /// for the first of the two changed rows, otherwise the resorting
    /// of the rows will be wrong.
    ///
    /// This generally means that if you don’t fully control the data
    /// model you have to duplicate the data that affects the listbox
    /// row functions into the row widgets themselves. Another alternative
    /// is to call `gtk.ListBox.invalidateSort` on any model change,
    /// but that is more expensive.
    extern fn gtk_list_box_row_changed(p_row: *ListBoxRow) void;
    pub const changed = gtk_list_box_row_changed;

    /// Gets the value of the `gtk.ListBoxRow.properties.activatable` property
    /// for this row.
    extern fn gtk_list_box_row_get_activatable(p_row: *ListBoxRow) c_int;
    pub const getActivatable = gtk_list_box_row_get_activatable;

    /// Returns the current header of the `row`. This can be used
    /// in a `gtk.ListBoxUpdateHeaderFunc` to see if there is a header
    /// set already, and if so to update the state of it.
    extern fn gtk_list_box_row_get_header(p_row: *ListBoxRow) ?*gtk.Widget;
    pub const getHeader = gtk_list_box_row_get_header;

    /// Gets the current index of the `row` in its `gtk.ListBox` container.
    extern fn gtk_list_box_row_get_index(p_row: *ListBoxRow) c_int;
    pub const getIndex = gtk_list_box_row_get_index;

    /// Gets the value of the `gtk.ListBoxRow.properties.selectable` property
    /// for this row.
    extern fn gtk_list_box_row_get_selectable(p_row: *ListBoxRow) c_int;
    pub const getSelectable = gtk_list_box_row_get_selectable;

    /// Returns whether the child is currently selected in its
    /// `gtk.ListBox` container.
    extern fn gtk_list_box_row_is_selected(p_row: *ListBoxRow) c_int;
    pub const isSelected = gtk_list_box_row_is_selected;

    /// Set the `gtk.ListBoxRow.properties.activatable` property for this row.
    extern fn gtk_list_box_row_set_activatable(p_row: *ListBoxRow, p_activatable: c_int) void;
    pub const setActivatable = gtk_list_box_row_set_activatable;

    /// Sets the current header of the `row`. This is only allowed to be called
    /// from a `gtk.ListBoxUpdateHeaderFunc`. It will replace any existing
    /// header in the row, and be shown in front of the row in the listbox.
    extern fn gtk_list_box_row_set_header(p_row: *ListBoxRow, p_header: ?*gtk.Widget) void;
    pub const setHeader = gtk_list_box_row_set_header;

    /// Set the `gtk.ListBoxRow.properties.selectable` property for this row.
    extern fn gtk_list_box_row_set_selectable(p_row: *ListBoxRow, p_selectable: c_int) void;
    pub const setSelectable = gtk_list_box_row_set_selectable;

    extern fn gtk_list_box_row_get_type() usize;
    pub const getGObjectType = gtk_list_box_row_get_type;

    extern fn g_object_ref(p_self: *gtk.ListBoxRow) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ListBoxRow) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ListBoxRow, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ListBoxRowAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{atk.Component};
    pub const Class = gtk.ListBoxRowAccessibleClass;
    f_parent: gtk.ContainerAccessible,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_list_box_row_accessible_get_type() usize;
    pub const getGObjectType = gtk_list_box_row_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ListBoxRowAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ListBoxRowAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ListBoxRowAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.ListStore` object is a list model for use with a `gtk.TreeView`
/// widget.  It implements the `gtk.TreeModel` interface, and consequentialy,
/// can use all of the methods available there.  It also implements the
/// `gtk.TreeSortable` interface so it can be sorted by the view.
/// Finally, it also implements the tree
/// [drag and drop][gtk3-GtkTreeView-drag-and-drop]
/// interfaces.
///
/// The `gtk.ListStore` can accept most GObject types as a column type, though
/// it can’t accept all custom types.  Internally, it will keep a copy of
/// data passed in (such as a string or a boxed pointer).  Columns that
/// accept `GObjects` are handled a little differently.  The
/// `gtk.ListStore` will keep a reference to the object instead of copying the
/// value.  As a result, if the object is modified, it is up to the
/// application writer to call `gtk.TreeModel.rowChanged` to emit the
/// `gtk.TreeModel.signals.row_changed` signal.  This most commonly affects lists with
/// `GdkPixbufs` stored.
///
/// An example for creating a simple list store:
///
/// ```
/// enum {
///   COLUMN_STRING,
///   COLUMN_INT,
///   COLUMN_BOOLEAN,
///   N_COLUMNS
/// };
///
/// {
///   GtkListStore *list_store;
///   GtkTreePath *path;
///   GtkTreeIter iter;
///   gint i;
///
///   list_store = gtk_list_store_new (N_COLUMNS,
///                                    G_TYPE_STRING,
///                                    G_TYPE_INT,
///                                    G_TYPE_BOOLEAN);
///
///   for (i = 0; i < 10; i++)
///     {
///       gchar *some_data;
///
///       some_data = get_some_data (i);
///
///       // Add a new row to the model
///       gtk_list_store_append (list_store, &iter);
///       gtk_list_store_set (list_store, &iter,
///                           COLUMN_STRING, some_data,
///                           COLUMN_INT, i,
///                           COLUMN_BOOLEAN,  FALSE,
///                           -1);
///
///       // As the store will keep a copy of the string internally,
///       // we free some_data.
///       g_free (some_data);
///     }
///
///   // Modify a particular row
///   path = gtk_tree_path_new_from_string ("4");
///   gtk_tree_model_get_iter (GTK_TREE_MODEL (list_store),
///                            &iter,
///                            path);
///   gtk_tree_path_free (path);
///   gtk_list_store_set (list_store, &iter,
///                       COLUMN_BOOLEAN, TRUE,
///                       -1);
/// }
/// ```
///
/// # Performance Considerations
///
/// Internally, the `gtk.ListStore` was implemented with a linked list with
/// a tail pointer prior to GTK+ 2.6.  As a result, it was fast at data
/// insertion and deletion, and not fast at random data access.  The
/// `gtk.ListStore` sets the `GTK_TREE_MODEL_ITERS_PERSIST` flag, which means
/// that `GtkTreeIters` can be cached while the row exists.  Thus, if
/// access to a particular row is needed often and your code is expected to
/// run on older versions of GTK+, it is worth keeping the iter around.
///
/// # Atomic Operations
///
/// It is important to note that only the methods
/// `gtk.ListStore.insertWithValues` and `gtk.ListStore.insertWithValuesv`
/// are atomic, in the sense that the row is being appended to the store and the
/// values filled in in a single operation with regard to `gtk.TreeModel` signaling.
/// In contrast, using e.g. `gtk.ListStore.append` and then `gtk.ListStore.set`
/// will first create a row, which triggers the `gtk.TreeModel.signals.row`-inserted signal
/// on `gtk.ListStore`. The row, however, is still empty, and any signal handler
/// connecting to `gtk.TreeModel.signals.row`-inserted on this particular store should be prepared
/// for the situation that the row might be empty. This is especially important
/// if you are wrapping the `gtk.ListStore` inside a `gtk.TreeModelFilter` and are
/// using a `gtk.TreeModelFilterVisibleFunc`. Using any of the non-atomic operations
/// to append rows to the `gtk.ListStore` will cause the
/// `gtk.TreeModelFilterVisibleFunc` to be visited with an empty row first; the
/// function must be prepared for that.
///
/// # GtkListStore as GtkBuildable
///
/// The GtkListStore implementation of the GtkBuildable interface allows
/// to specify the model columns with a `<columns>` element that may contain
/// multiple `<column>` elements, each specifying one model column. The “type”
/// attribute specifies the data type for the column.
///
/// Additionally, it is possible to specify content for the list store
/// in the UI definition, with the `<data>` element. It can contain multiple
/// `<row>` elements, each specifying to content for one row of the list model.
/// Inside a `<row>`, the `<col>` elements specify the content for individual cells.
///
/// Note that it is probably more common to define your models in the code,
/// and one might consider it a layering violation to specify the content of
/// a list store in a UI definition, data, not presentation, and common wisdom
/// is to separate the two, as far as possible.
///
/// An example of a UI Definition fragment for a list store:
///
/// ```
/// <object class="GtkListStore">
///   <columns>
///     <column type="gchararray"/>
///     <column type="gchararray"/>
///     <column type="gint"/>
///   </columns>
///   <data>
///     <row>
///       <col id="0">John</col>
///       <col id="1">Doe</col>
///       <col id="2">25</col>
///     </row>
///     <row>
///       <col id="0">Johan</col>
///       <col id="1">Dahlin</col>
///       <col id="2">50</col>
///     </row>
///   </data>
/// </object>
/// ```
pub const ListStore = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gtk.Buildable, gtk.TreeDragDest, gtk.TreeDragSource, gtk.TreeModel, gtk.TreeSortable };
    pub const Class = gtk.ListStoreClass;
    f_parent: gobject.Object,
    f_priv: ?*gtk.ListStorePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new list store as with `n_columns` columns each of the types passed
    /// in.  Note that only types derived from standard GObject fundamental types
    /// are supported.
    ///
    /// As an example, `gtk_list_store_new (3, G_TYPE_INT, G_TYPE_STRING,
    /// GDK_TYPE_PIXBUF);` will create a new `gtk.ListStore` with three columns, of type
    /// int, string and `gdkpixbuf.Pixbuf` respectively.
    extern fn gtk_list_store_new(p_n_columns: c_int, ...) *gtk.ListStore;
    pub const new = gtk_list_store_new;

    /// Non-vararg creation function.  Used primarily by language bindings.
    extern fn gtk_list_store_newv(p_n_columns: c_int, p_types: [*]usize) *gtk.ListStore;
    pub const newv = gtk_list_store_newv;

    /// Appends a new row to `list_store`.  `iter` will be changed to point to this new
    /// row.  The row will be empty after this function is called.  To fill in
    /// values, you need to call `gtk.ListStore.set` or `gtk.ListStore.setValue`.
    extern fn gtk_list_store_append(p_list_store: *ListStore, p_iter: *gtk.TreeIter) void;
    pub const append = gtk_list_store_append;

    /// Removes all rows from the list store.
    extern fn gtk_list_store_clear(p_list_store: *ListStore) void;
    pub const clear = gtk_list_store_clear;

    /// Creates a new row at `position`.  `iter` will be changed to point to this new
    /// row.  If `position` is -1 or is larger than the number of rows on the list,
    /// then the new row will be appended to the list. The row will be empty after
    /// this function is called.  To fill in values, you need to call
    /// `gtk.ListStore.set` or `gtk.ListStore.setValue`.
    extern fn gtk_list_store_insert(p_list_store: *ListStore, p_iter: *gtk.TreeIter, p_position: c_int) void;
    pub const insert = gtk_list_store_insert;

    /// Inserts a new row after `sibling`. If `sibling` is `NULL`, then the row will be
    /// prepended to the beginning of the list. `iter` will be changed to point to
    /// this new row. The row will be empty after this function is called. To fill
    /// in values, you need to call `gtk.ListStore.set` or `gtk.ListStore.setValue`.
    extern fn gtk_list_store_insert_after(p_list_store: *ListStore, p_iter: *gtk.TreeIter, p_sibling: ?*gtk.TreeIter) void;
    pub const insertAfter = gtk_list_store_insert_after;

    /// Inserts a new row before `sibling`. If `sibling` is `NULL`, then the row will
    /// be appended to the end of the list. `iter` will be changed to point to this
    /// new row. The row will be empty after this function is called. To fill in
    /// values, you need to call `gtk.ListStore.set` or `gtk.ListStore.setValue`.
    extern fn gtk_list_store_insert_before(p_list_store: *ListStore, p_iter: *gtk.TreeIter, p_sibling: ?*gtk.TreeIter) void;
    pub const insertBefore = gtk_list_store_insert_before;

    /// Creates a new row at `position`. `iter` will be changed to point to this new
    /// row. If `position` is -1, or larger than the number of rows in the list, then
    /// the new row will be appended to the list. The row will be filled with the
    /// values given to this function.
    ///
    /// Calling
    /// `gtk_list_store_insert_with_values (list_store, iter, position...)`
    /// has the same effect as calling
    /// ```
    /// static void
    /// insert_value (GtkListStore *list_store,
    ///               GtkTreeIter  *iter,
    ///               int           position)
    /// {
    ///   gtk_list_store_insert (list_store, iter, position);
    ///   gtk_list_store_set (list_store,
    ///                       iter
    ///                       // ...
    ///                       );
    /// }
    /// ```
    /// with the difference that the former will only emit a row_inserted signal,
    /// while the latter will emit row_inserted, row_changed and, if the list store
    /// is sorted, rows_reordered. Since emitting the rows_reordered signal
    /// repeatedly can affect the performance of the program,
    /// `gtk.ListStore.insertWithValues` should generally be preferred when
    /// inserting rows in a sorted list store.
    extern fn gtk_list_store_insert_with_values(p_list_store: *ListStore, p_iter: ?*gtk.TreeIter, p_position: c_int, ...) void;
    pub const insertWithValues = gtk_list_store_insert_with_values;

    /// A variant of `gtk.ListStore.insertWithValues` which
    /// takes the columns and values as two arrays, instead of
    /// varargs. This function is mainly intended for
    /// language-bindings.
    extern fn gtk_list_store_insert_with_valuesv(p_list_store: *ListStore, p_iter: ?*gtk.TreeIter, p_position: c_int, p_columns: [*]c_int, p_values: [*]gobject.Value, p_n_values: c_int) void;
    pub const insertWithValuesv = gtk_list_store_insert_with_valuesv;

    /// > This function is slow. Only use it for debugging and/or testing
    /// > purposes.
    ///
    /// Checks if the given iter is a valid iter for this `gtk.ListStore`.
    extern fn gtk_list_store_iter_is_valid(p_list_store: *ListStore, p_iter: *gtk.TreeIter) c_int;
    pub const iterIsValid = gtk_list_store_iter_is_valid;

    /// Moves `iter` in `store` to the position after `position`. Note that this
    /// function only works with unsorted stores. If `position` is `NULL`, `iter`
    /// will be moved to the start of the list.
    extern fn gtk_list_store_move_after(p_store: *ListStore, p_iter: *gtk.TreeIter, p_position: ?*gtk.TreeIter) void;
    pub const moveAfter = gtk_list_store_move_after;

    /// Moves `iter` in `store` to the position before `position`. Note that this
    /// function only works with unsorted stores. If `position` is `NULL`, `iter`
    /// will be moved to the end of the list.
    extern fn gtk_list_store_move_before(p_store: *ListStore, p_iter: *gtk.TreeIter, p_position: ?*gtk.TreeIter) void;
    pub const moveBefore = gtk_list_store_move_before;

    /// Prepends a new row to `list_store`. `iter` will be changed to point to this new
    /// row. The row will be empty after this function is called. To fill in
    /// values, you need to call `gtk.ListStore.set` or `gtk.ListStore.setValue`.
    extern fn gtk_list_store_prepend(p_list_store: *ListStore, p_iter: *gtk.TreeIter) void;
    pub const prepend = gtk_list_store_prepend;

    /// Removes the given row from the list store.  After being removed,
    /// `iter` is set to be the next valid row, or invalidated if it pointed
    /// to the last row in `list_store`.
    extern fn gtk_list_store_remove(p_list_store: *ListStore, p_iter: *gtk.TreeIter) c_int;
    pub const remove = gtk_list_store_remove;

    /// Reorders `store` to follow the order indicated by `new_order`. Note that
    /// this function only works with unsorted stores.
    extern fn gtk_list_store_reorder(p_store: *ListStore, p_new_order: [*]c_int) void;
    pub const reorder = gtk_list_store_reorder;

    /// Sets the value of one or more cells in the row referenced by `iter`.
    /// The variable argument list should contain integer column numbers,
    /// each column number followed by the value to be set.
    /// The list is terminated by a -1. For example, to set column 0 with type
    /// `G_TYPE_STRING` to “Foo”, you would write `gtk_list_store_set (store, iter,
    /// 0, "Foo", -1)`.
    ///
    /// The value will be referenced by the store if it is a `G_TYPE_OBJECT`, and it
    /// will be copied if it is a `G_TYPE_STRING` or `G_TYPE_BOXED`.
    extern fn gtk_list_store_set(p_list_store: *ListStore, p_iter: *gtk.TreeIter, ...) void;
    pub const set = gtk_list_store_set;

    /// This function is meant primarily for `GObjects` that inherit from `gtk.ListStore`,
    /// and should only be used when constructing a new `gtk.ListStore`.  It will not
    /// function after a row has been added, or a method on the `gtk.TreeModel`
    /// interface is called.
    extern fn gtk_list_store_set_column_types(p_list_store: *ListStore, p_n_columns: c_int, p_types: [*]usize) void;
    pub const setColumnTypes = gtk_list_store_set_column_types;

    /// See `gtk.ListStore.set`; this version takes a va_list for use by language
    /// bindings.
    extern fn gtk_list_store_set_valist(p_list_store: *ListStore, p_iter: *gtk.TreeIter, p_var_args: std.builtin.VaList) void;
    pub const setValist = gtk_list_store_set_valist;

    /// Sets the data in the cell specified by `iter` and `column`.
    /// The type of `value` must be convertible to the type of the
    /// column.
    extern fn gtk_list_store_set_value(p_list_store: *ListStore, p_iter: *gtk.TreeIter, p_column: c_int, p_value: *gobject.Value) void;
    pub const setValue = gtk_list_store_set_value;

    /// A variant of `gtk.ListStore.setValist` which
    /// takes the columns and values as two arrays, instead of
    /// varargs. This function is mainly intended for
    /// language-bindings and in case the number of columns to
    /// change is not known until run-time.
    extern fn gtk_list_store_set_valuesv(p_list_store: *ListStore, p_iter: *gtk.TreeIter, p_columns: [*]c_int, p_values: [*]gobject.Value, p_n_values: c_int) void;
    pub const setValuesv = gtk_list_store_set_valuesv;

    /// Swaps `a` and `b` in `store`. Note that this function only works with
    /// unsorted stores.
    extern fn gtk_list_store_swap(p_store: *ListStore, p_a: *gtk.TreeIter, p_b: *gtk.TreeIter) void;
    pub const swap = gtk_list_store_swap;

    extern fn gtk_list_store_get_type() usize;
    pub const getGObjectType = gtk_list_store_get_type;

    extern fn g_object_ref(p_self: *gtk.ListStore) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ListStore) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ListStore, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkLockButton is a widget that can be used in control panels or
/// preference dialogs to allow users to obtain and revoke authorizations
/// needed to operate the controls. The required authorization is represented
/// by a `gio.Permission` object. Concrete implementations of `gio.Permission` may use
/// PolicyKit or some other authorization framework. To obtain a PolicyKit-based
/// `gio.Permission`, use `polkit_permission_new`.
///
/// If the user is not currently allowed to perform the action, but can obtain
/// the permission, the widget looks like this:
///
/// ![](lockbutton-locked.png)
///
/// and the user can click the button to request the permission. Depending
/// on the platform, this may pop up an authentication dialog or ask the user
/// to authenticate in some other way. Once the user has obtained the permission,
/// the widget changes to this:
///
/// ![](lockbutton-unlocked.png)
///
/// and the permission can be dropped again by clicking the button. If the user
/// is not able to obtain the permission at all, the widget looks like this:
///
/// ![](lockbutton-sorry.png)
///
/// If the user has the permission and cannot drop it, the button is hidden.
///
/// The text (and tooltips) that are shown in the various cases can be adjusted
/// with the `gtk.LockButton.properties.text`-lock, `gtk.LockButton.properties.text`-unlock,
/// `gtk.LockButton.properties.tooltip`-lock, `gtk.LockButton.properties.tooltip`-unlock and
/// `gtk.LockButton.properties.tooltip`-not-authorized properties.
pub const LockButton = extern struct {
    pub const Parent = gtk.Button;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.LockButtonClass;
    f_parent: gtk.Button,
    f_priv: ?*gtk.LockButtonPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const permission = struct {
            pub const name = "permission";

            pub const Type = ?*gio.Permission;
        };

        pub const text_lock = struct {
            pub const name = "text-lock";

            pub const Type = ?[*:0]u8;
        };

        pub const text_unlock = struct {
            pub const name = "text-unlock";

            pub const Type = ?[*:0]u8;
        };

        pub const tooltip_lock = struct {
            pub const name = "tooltip-lock";

            pub const Type = ?[*:0]u8;
        };

        pub const tooltip_not_authorized = struct {
            pub const name = "tooltip-not-authorized";

            pub const Type = ?[*:0]u8;
        };

        pub const tooltip_unlock = struct {
            pub const name = "tooltip-unlock";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new lock button which reflects the `permission`.
    extern fn gtk_lock_button_new(p_permission: ?*gio.Permission) *gtk.LockButton;
    pub const new = gtk_lock_button_new;

    /// Obtains the `gio.Permission` object that controls `button`.
    extern fn gtk_lock_button_get_permission(p_button: *LockButton) *gio.Permission;
    pub const getPermission = gtk_lock_button_get_permission;

    /// Sets the `gio.Permission` object that controls `button`.
    extern fn gtk_lock_button_set_permission(p_button: *LockButton, p_permission: ?*gio.Permission) void;
    pub const setPermission = gtk_lock_button_set_permission;

    extern fn gtk_lock_button_get_type() usize;
    pub const getGObjectType = gtk_lock_button_get_type;

    extern fn g_object_ref(p_self: *gtk.LockButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.LockButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *LockButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LockButtonAccessible = extern struct {
    pub const Parent = gtk.ButtonAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.Image };
    pub const Class = gtk.LockButtonAccessibleClass;
    f_parent: gtk.ButtonAccessible,
    f_priv: ?*gtk.LockButtonAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_lock_button_accessible_get_type() usize;
    pub const getGObjectType = gtk_lock_button_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.LockButtonAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.LockButtonAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *LockButtonAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.Menu` is a `gtk.MenuShell` that implements a drop down menu
/// consisting of a list of `gtk.MenuItem` objects which can be navigated
/// and activated by the user to perform application functions.
///
/// A `gtk.Menu` is most commonly dropped down by activating a
/// `gtk.MenuItem` in a `gtk.MenuBar` or popped up by activating a
/// `gtk.MenuItem` in another `gtk.Menu`.
///
/// A `gtk.Menu` can also be popped up by activating a `gtk.ComboBox`.
/// Other composite widgets such as the `gtk.Notebook` can pop up a
/// `gtk.Menu` as well.
///
/// Applications can display a `gtk.Menu` as a popup menu by calling the
/// `gtk.Menu.popup` function.  The example below shows how an application
/// can pop up a menu when the 3rd mouse button is pressed.
///
/// ## Connecting the popup signal handler.
///
/// ```
///   // connect our handler which will popup the menu
///   g_signal_connect_swapped (window, "button_press_event",
/// G_CALLBACK (my_popup_handler), menu);
/// ```
///
/// ## Signal handler which displays a popup menu.
///
/// ```
/// static gint
/// my_popup_handler (GtkWidget *widget, GdkEvent *event)
/// {
///   GtkMenu *menu;
///   GdkEventButton *event_button;
///
///   g_return_val_if_fail (widget != NULL, FALSE);
///   g_return_val_if_fail (GTK_IS_MENU (widget), FALSE);
///   g_return_val_if_fail (event != NULL, FALSE);
///
///   // The "widget" is the menu that was supplied when
///   // `g_signal_connect_swapped` was called.
///   menu = GTK_MENU (widget);
///
///   if (event->type == GDK_BUTTON_PRESS)
///     {
///       event_button = (GdkEventButton *) event;
///       if (event_button->button == GDK_BUTTON_SECONDARY)
///         {
///           gtk_menu_popup (menu, NULL, NULL, NULL, NULL,
///                           event_button->button, event_button->time);
///           return TRUE;
///         }
///     }
///
///   return FALSE;
/// }
/// ```
///
/// # CSS nodes
///
/// ```
/// menu
/// ├── arrow.top
/// ├── <child>
/// ┊
/// ├── <child>
/// ╰── arrow.bottom
/// ```
///
/// The main CSS node of GtkMenu has name menu, and there are two subnodes
/// with name arrow, for scrolling menu arrows. These subnodes get the
/// .top and .bottom style classes.
pub const Menu = extern struct {
    pub const Parent = gtk.MenuShell;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.MenuClass;
    f_menu_shell: gtk.MenuShell,
    f_priv: ?*gtk.MenuPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The accel group holding accelerators for the menu.
        pub const accel_group = struct {
            pub const name = "accel-group";

            pub const Type = ?*gtk.AccelGroup;
        };

        /// An accel path used to conveniently construct accel paths of child items.
        pub const accel_path = struct {
            pub const name = "accel-path";

            pub const Type = ?[*:0]u8;
        };

        /// The index of the currently selected menu item, or -1 if no
        /// menu item is selected.
        pub const active = struct {
            pub const name = "active";

            pub const Type = c_int;
        };

        /// Positioning hints for aligning the menu relative to a rectangle.
        ///
        /// These hints determine how the menu should be positioned in the case that
        /// the menu would fall off-screen if placed in its ideal position.
        ///
        /// ![](popup-flip.png)
        ///
        /// For example, `GDK_ANCHOR_FLIP_Y` will replace `GDK_GRAVITY_NORTH_WEST` with
        /// `GDK_GRAVITY_SOUTH_WEST` and vice versa if the menu extends beyond the
        /// bottom edge of the monitor.
        ///
        /// See gtk_menu_popup_at_rect (), gtk_menu_popup_at_widget (),
        /// gtk_menu_popup_at_pointer (), `gtk.Menu.properties.rect`-anchor-dx,
        /// `gtk.Menu.properties.rect`-anchor-dy, `gtk.Menu.properties.menu`-type-hint, and `gtk.Menu.signals.popped`-up.
        pub const anchor_hints = struct {
            pub const name = "anchor-hints";

            pub const Type = gdk.AnchorHints;
        };

        /// The widget the menu is attached to. Setting this property attaches
        /// the menu without a `gtk.MenuDetachFunc`. If you need to use a detacher,
        /// use `gtk.Menu.attachToWidget` directly.
        pub const attach_widget = struct {
            pub const name = "attach-widget";

            pub const Type = ?*gtk.Widget;
        };

        /// The `gdk.WindowTypeHint` to use for the menu's `gdk.Window`.
        ///
        /// See gtk_menu_popup_at_rect (), gtk_menu_popup_at_widget (),
        /// gtk_menu_popup_at_pointer (), `gtk.Menu.properties.anchor`-hints,
        /// `gtk.Menu.properties.rect`-anchor-dx, `gtk.Menu.properties.rect`-anchor-dy, and `gtk.Menu.signals.popped`-up.
        pub const menu_type_hint = struct {
            pub const name = "menu-type-hint";

            pub const Type = gdk.WindowTypeHint;
        };

        /// The monitor the menu will be popped up on.
        pub const monitor = struct {
            pub const name = "monitor";

            pub const Type = c_int;
        };

        /// Horizontal offset to apply to the menu, i.e. the rectangle or widget
        /// anchor.
        ///
        /// See gtk_menu_popup_at_rect (), gtk_menu_popup_at_widget (),
        /// gtk_menu_popup_at_pointer (), `gtk.Menu.properties.anchor`-hints,
        /// `gtk.Menu.properties.rect`-anchor-dy, `gtk.Menu.properties.menu`-type-hint, and `gtk.Menu.signals.popped`-up.
        pub const rect_anchor_dx = struct {
            pub const name = "rect-anchor-dx";

            pub const Type = c_int;
        };

        /// Vertical offset to apply to the menu, i.e. the rectangle or widget anchor.
        ///
        /// See gtk_menu_popup_at_rect (), gtk_menu_popup_at_widget (),
        /// gtk_menu_popup_at_pointer (), `gtk.Menu.properties.anchor`-hints,
        /// `gtk.Menu.properties.rect`-anchor-dx, `gtk.Menu.properties.menu`-type-hint, and `gtk.Menu.signals.popped`-up.
        pub const rect_anchor_dy = struct {
            pub const name = "rect-anchor-dy";

            pub const Type = c_int;
        };

        /// A boolean that indicates whether the menu reserves space for
        /// toggles and icons, regardless of their actual presence.
        ///
        /// This property should only be changed from its default value
        /// for special-purposes such as tabular menus. Regular menus that
        /// are connected to a menu bar or context menus should reserve
        /// toggle space for consistency.
        pub const reserve_toggle_size = struct {
            pub const name = "reserve-toggle-size";

            pub const Type = c_int;
        };

        /// A boolean that indicates whether the menu is torn-off.
        pub const tearoff_state = struct {
            pub const name = "tearoff-state";

            pub const Type = c_int;
        };

        /// A title that may be displayed by the window manager when this
        /// menu is torn-off.
        pub const tearoff_title = struct {
            pub const name = "tearoff-title";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {
        pub const move_scroll = struct {
            pub const name = "move-scroll";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_scroll_type: gtk.ScrollType, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Menu, p_instance))),
                    gobject.signalLookup("move-scroll", Menu.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the position of `menu` is finalized after being popped up
        /// using gtk_menu_popup_at_rect (), gtk_menu_popup_at_widget (), or
        /// gtk_menu_popup_at_pointer ().
        ///
        /// `menu` might be flipped over the anchor rectangle in order to keep it
        /// on-screen, in which case `flipped_x` and `flipped_y` will be set to `TRUE`
        /// accordingly.
        ///
        /// `flipped_rect` is the ideal position of `menu` after any possible flipping,
        /// but before any possible sliding. `final_rect` is `flipped_rect`, but possibly
        /// translated in the case that flipping is still ineffective in keeping `menu`
        /// on-screen.
        ///
        /// ![](popup-slide.png)
        ///
        /// The blue menu is `menu`'s ideal position, the green menu is `flipped_rect`,
        /// and the red menu is `final_rect`.
        ///
        /// See gtk_menu_popup_at_rect (), gtk_menu_popup_at_widget (),
        /// gtk_menu_popup_at_pointer (), `gtk.Menu.properties.anchor`-hints,
        /// `gtk.Menu.properties.rect`-anchor-dx, `gtk.Menu.properties.rect`-anchor-dy, and
        /// `gtk.Menu.properties.menu`-type-hint.
        pub const popped_up = struct {
            pub const name = "popped-up";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_flipped_rect: ?*anyopaque, p_final_rect: ?*anyopaque, p_flipped_x: c_int, p_flipped_y: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Menu, p_instance))),
                    gobject.signalLookup("popped-up", Menu.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Returns a list of the menus which are attached to this widget.
    /// This list is owned by GTK+ and must not be modified.
    extern fn gtk_menu_get_for_attach_widget(p_widget: *gtk.Widget) *glib.List;
    pub const getForAttachWidget = gtk_menu_get_for_attach_widget;

    /// Creates a new `gtk.Menu`
    extern fn gtk_menu_new() *gtk.Menu;
    pub const new = gtk_menu_new;

    /// Creates a `gtk.Menu` and populates it with menu items and
    /// submenus according to `model`.
    ///
    /// The created menu items are connected to actions found in the
    /// `gtk.ApplicationWindow` to which the menu belongs - typically
    /// by means of being attached to a widget (see `gtk.Menu.attachToWidget`)
    /// that is contained within the `GtkApplicationWindows` widget hierarchy.
    ///
    /// Actions can also be added using `gtk.Widget.insertActionGroup` on the menu's
    /// attach widget or on any of its parent widgets.
    extern fn gtk_menu_new_from_model(p_model: *gio.MenuModel) *gtk.Menu;
    pub const newFromModel = gtk_menu_new_from_model;

    /// Adds a new `gtk.MenuItem` to a (table) menu. The number of “cells” that
    /// an item will occupy is specified by `left_attach`, `right_attach`,
    /// `top_attach` and `bottom_attach`. These each represent the leftmost,
    /// rightmost, uppermost and lower column and row numbers of the table.
    /// (Columns and rows are indexed from zero).
    ///
    /// Note that this function is not related to `gtk.Menu.detach`.
    extern fn gtk_menu_attach(p_menu: *Menu, p_child: *gtk.Widget, p_left_attach: c_uint, p_right_attach: c_uint, p_top_attach: c_uint, p_bottom_attach: c_uint) void;
    pub const attach = gtk_menu_attach;

    /// Attaches the menu to the widget and provides a callback function
    /// that will be invoked when the menu calls `gtk.Menu.detach` during
    /// its destruction.
    ///
    /// If the menu is attached to the widget then it will be destroyed
    /// when the widget is destroyed, as if it was a child widget.
    /// An attached menu will also move between screens correctly if the
    /// widgets moves between screens.
    extern fn gtk_menu_attach_to_widget(p_menu: *Menu, p_attach_widget: *gtk.Widget, p_detacher: ?gtk.MenuDetachFunc) void;
    pub const attachToWidget = gtk_menu_attach_to_widget;

    /// Detaches the menu from the widget to which it had been attached.
    /// This function will call the callback function, `detacher`, provided
    /// when the `gtk.Menu.attachToWidget` function was called.
    extern fn gtk_menu_detach(p_menu: *Menu) void;
    pub const detach = gtk_menu_detach;

    /// Gets the `gtk.AccelGroup` which holds global accelerators for the
    /// menu. See `gtk.Menu.setAccelGroup`.
    extern fn gtk_menu_get_accel_group(p_menu: *Menu) *gtk.AccelGroup;
    pub const getAccelGroup = gtk_menu_get_accel_group;

    /// Retrieves the accelerator path set on the menu.
    extern fn gtk_menu_get_accel_path(p_menu: *Menu) [*:0]const u8;
    pub const getAccelPath = gtk_menu_get_accel_path;

    /// Returns the selected menu item from the menu.  This is used by the
    /// `gtk.ComboBox`.
    extern fn gtk_menu_get_active(p_menu: *Menu) *gtk.Widget;
    pub const getActive = gtk_menu_get_active;

    /// Returns the `gtk.Widget` that the menu is attached to.
    extern fn gtk_menu_get_attach_widget(p_menu: *Menu) *gtk.Widget;
    pub const getAttachWidget = gtk_menu_get_attach_widget;

    /// Retrieves the number of the monitor on which to show the menu.
    extern fn gtk_menu_get_monitor(p_menu: *Menu) c_int;
    pub const getMonitor = gtk_menu_get_monitor;

    /// Returns whether the menu reserves space for toggles and
    /// icons, regardless of their actual presence.
    extern fn gtk_menu_get_reserve_toggle_size(p_menu: *Menu) c_int;
    pub const getReserveToggleSize = gtk_menu_get_reserve_toggle_size;

    /// Returns whether the menu is torn off.
    /// See `gtk.Menu.setTearoffState`.
    extern fn gtk_menu_get_tearoff_state(p_menu: *Menu) c_int;
    pub const getTearoffState = gtk_menu_get_tearoff_state;

    /// Returns the title of the menu. See `gtk.Menu.setTitle`.
    extern fn gtk_menu_get_title(p_menu: *Menu) [*:0]const u8;
    pub const getTitle = gtk_menu_get_title;

    /// Places `menu` on the given monitor.
    extern fn gtk_menu_place_on_monitor(p_menu: *Menu, p_monitor: *gdk.Monitor) void;
    pub const placeOnMonitor = gtk_menu_place_on_monitor;

    /// Removes the menu from the screen.
    extern fn gtk_menu_popdown(p_menu: *Menu) void;
    pub const popdown = gtk_menu_popdown;

    /// Displays a menu and makes it available for selection.
    ///
    /// Applications can use this function to display context-sensitive
    /// menus, and will typically supply `NULL` for the `parent_menu_shell`,
    /// `parent_menu_item`, `func` and `data` parameters. The default menu
    /// positioning function will position the menu at the current mouse
    /// cursor position.
    ///
    /// The `button` parameter should be the mouse button pressed to initiate
    /// the menu popup. If the menu popup was initiated by something other
    /// than a mouse button press, such as a mouse button release or a keypress,
    /// `button` should be 0.
    ///
    /// The `activate_time` parameter is used to conflict-resolve initiation
    /// of concurrent requests for mouse/keyboard grab requests. To function
    /// properly, this needs to be the timestamp of the user event (such as
    /// a mouse click or key press) that caused the initiation of the popup.
    /// Only if no such event is available, `gtk.getCurrentEventTime` can
    /// be used instead.
    ///
    /// Note that this function does not work very well on GDK backends that
    /// do not have global coordinates, such as Wayland or Mir. You should
    /// probably use one of the gtk_menu_popup_at_ variants, which do not
    /// have this problem.
    extern fn gtk_menu_popup(p_menu: *Menu, p_parent_menu_shell: ?*gtk.Widget, p_parent_menu_item: ?*gtk.Widget, p_func: ?gtk.MenuPositionFunc, p_data: ?*anyopaque, p_button: c_uint, p_activate_time: u32) void;
    pub const popup = gtk_menu_popup;

    /// Displays `menu` and makes it available for selection.
    ///
    /// See gtk_menu_popup_at_widget () to pop up a menu at a widget.
    /// gtk_menu_popup_at_rect () also allows you to position a menu at an arbitrary
    /// rectangle.
    ///
    /// `menu` will be positioned at the pointer associated with `trigger_event`.
    ///
    /// Properties that influence the behaviour of this function are
    /// `gtk.Menu.properties.anchor`-hints, `gtk.Menu.properties.rect`-anchor-dx, `gtk.Menu.properties.rect`-anchor-dy, and
    /// `gtk.Menu.properties.menu`-type-hint. Connect to the `gtk.Menu.signals.popped`-up signal to find
    /// out how it was actually positioned.
    extern fn gtk_menu_popup_at_pointer(p_menu: *Menu, p_trigger_event: ?*const gdk.Event) void;
    pub const popupAtPointer = gtk_menu_popup_at_pointer;

    /// Displays `menu` and makes it available for selection.
    ///
    /// See gtk_menu_popup_at_widget () and gtk_menu_popup_at_pointer (), which
    /// handle more common cases for popping up menus.
    ///
    /// `menu` will be positioned at `rect`, aligning their anchor points. `rect` is
    /// relative to the top-left corner of `rect_window`. `rect_anchor` and
    /// `menu_anchor` determine anchor points on `rect` and `menu` to pin together.
    /// `menu` can optionally be offset by `gtk.Menu.properties.rect`-anchor-dx and
    /// `gtk.Menu.properties.rect`-anchor-dy.
    ///
    /// Anchors should be specified under the assumption that the text direction is
    /// left-to-right; they will be flipped horizontally automatically if the text
    /// direction is right-to-left.
    ///
    /// Other properties that influence the behaviour of this function are
    /// `gtk.Menu.properties.anchor`-hints and `gtk.Menu.properties.menu`-type-hint. Connect to the
    /// `gtk.Menu.signals.popped`-up signal to find out how it was actually positioned.
    extern fn gtk_menu_popup_at_rect(p_menu: *Menu, p_rect_window: *gdk.Window, p_rect: *const gdk.Rectangle, p_rect_anchor: gdk.Gravity, p_menu_anchor: gdk.Gravity, p_trigger_event: ?*const gdk.Event) void;
    pub const popupAtRect = gtk_menu_popup_at_rect;

    /// Displays `menu` and makes it available for selection.
    ///
    /// See gtk_menu_popup_at_pointer () to pop up a menu at the master pointer.
    /// gtk_menu_popup_at_rect () also allows you to position a menu at an arbitrary
    /// rectangle.
    ///
    /// ![](popup-anchors.png)
    ///
    /// `menu` will be positioned at `widget`, aligning their anchor points.
    /// `widget_anchor` and `menu_anchor` determine anchor points on `widget` and `menu`
    /// to pin together. `menu` can optionally be offset by `gtk.Menu.properties.rect`-anchor-dx
    /// and `gtk.Menu.properties.rect`-anchor-dy.
    ///
    /// Anchors should be specified under the assumption that the text direction is
    /// left-to-right; they will be flipped horizontally automatically if the text
    /// direction is right-to-left.
    ///
    /// Other properties that influence the behaviour of this function are
    /// `gtk.Menu.properties.anchor`-hints and `gtk.Menu.properties.menu`-type-hint. Connect to the
    /// `gtk.Menu.signals.popped`-up signal to find out how it was actually positioned.
    extern fn gtk_menu_popup_at_widget(p_menu: *Menu, p_widget: *gtk.Widget, p_widget_anchor: gdk.Gravity, p_menu_anchor: gdk.Gravity, p_trigger_event: ?*const gdk.Event) void;
    pub const popupAtWidget = gtk_menu_popup_at_widget;

    /// Displays a menu and makes it available for selection.
    ///
    /// Applications can use this function to display context-sensitive menus,
    /// and will typically supply `NULL` for the `parent_menu_shell`,
    /// `parent_menu_item`, `func`, `data` and `destroy` parameters. The default
    /// menu positioning function will position the menu at the current position
    /// of `device` (or its corresponding pointer).
    ///
    /// The `button` parameter should be the mouse button pressed to initiate
    /// the menu popup. If the menu popup was initiated by something other than
    /// a mouse button press, such as a mouse button release or a keypress,
    /// `button` should be 0.
    ///
    /// The `activate_time` parameter is used to conflict-resolve initiation of
    /// concurrent requests for mouse/keyboard grab requests. To function
    /// properly, this needs to be the time stamp of the user event (such as
    /// a mouse click or key press) that caused the initiation of the popup.
    /// Only if no such event is available, `gtk.getCurrentEventTime` can
    /// be used instead.
    ///
    /// Note that this function does not work very well on GDK backends that
    /// do not have global coordinates, such as Wayland or Mir. You should
    /// probably use one of the gtk_menu_popup_at_ variants, which do not
    /// have this problem.
    extern fn gtk_menu_popup_for_device(p_menu: *Menu, p_device: ?*gdk.Device, p_parent_menu_shell: ?*gtk.Widget, p_parent_menu_item: ?*gtk.Widget, p_func: ?gtk.MenuPositionFunc, p_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify, p_button: c_uint, p_activate_time: u32) void;
    pub const popupForDevice = gtk_menu_popup_for_device;

    /// Moves `child` to a new `position` in the list of `menu`
    /// children.
    extern fn gtk_menu_reorder_child(p_menu: *Menu, p_child: *gtk.Widget, p_position: c_int) void;
    pub const reorderChild = gtk_menu_reorder_child;

    /// Repositions the menu according to its position function.
    extern fn gtk_menu_reposition(p_menu: *Menu) void;
    pub const reposition = gtk_menu_reposition;

    /// Set the `gtk.AccelGroup` which holds global accelerators for the
    /// menu.  This accelerator group needs to also be added to all windows
    /// that this menu is being used in with `gtk.Window.addAccelGroup`,
    /// in order for those windows to support all the accelerators
    /// contained in this group.
    extern fn gtk_menu_set_accel_group(p_menu: *Menu, p_accel_group: ?*gtk.AccelGroup) void;
    pub const setAccelGroup = gtk_menu_set_accel_group;

    /// Sets an accelerator path for this menu from which accelerator paths
    /// for its immediate children, its menu items, can be constructed.
    /// The main purpose of this function is to spare the programmer the
    /// inconvenience of having to call `gtk.MenuItem.setAccelPath` on
    /// each menu item that should support runtime user changable accelerators.
    /// Instead, by just calling `gtk.Menu.setAccelPath` on their parent,
    /// each menu item of this menu, that contains a label describing its
    /// purpose, automatically gets an accel path assigned.
    ///
    /// For example, a menu containing menu items “New” and “Exit”, will, after
    /// `gtk_menu_set_accel_path (menu, "<Gnumeric-Sheet>/File");` has been
    /// called, assign its items the accel paths: `"<Gnumeric-Sheet>/File/New"`
    /// and `"<Gnumeric-Sheet>/File/Exit"`.
    ///
    /// Assigning accel paths to menu items then enables the user to change
    /// their accelerators at runtime. More details about accelerator paths
    /// and their default setups can be found at `gtk.AccelMap.addEntry`.
    ///
    /// Note that `accel_path` string will be stored in a `glib.Quark`. Therefore,
    /// if you pass a static string, you can save some memory by interning
    /// it first with `glib.internStaticString`.
    extern fn gtk_menu_set_accel_path(p_menu: *Menu, p_accel_path: ?[*:0]const u8) void;
    pub const setAccelPath = gtk_menu_set_accel_path;

    /// Selects the specified menu item within the menu.  This is used by
    /// the `gtk.ComboBox` and should not be used by anyone else.
    extern fn gtk_menu_set_active(p_menu: *Menu, p_index: c_uint) void;
    pub const setActive = gtk_menu_set_active;

    /// Informs GTK+ on which monitor a menu should be popped up.
    /// See `gdk.Monitor.getGeometry`.
    ///
    /// This function should be called from a `gtk.MenuPositionFunc`
    /// if the menu should not appear on the same monitor as the pointer.
    /// This information can’t be reliably inferred from the coordinates
    /// returned by a `gtk.MenuPositionFunc`, since, for very long menus,
    /// these coordinates may extend beyond the monitor boundaries or even
    /// the screen boundaries.
    extern fn gtk_menu_set_monitor(p_menu: *Menu, p_monitor_num: c_int) void;
    pub const setMonitor = gtk_menu_set_monitor;

    /// Sets whether the menu should reserve space for drawing toggles
    /// or icons, regardless of their actual presence.
    extern fn gtk_menu_set_reserve_toggle_size(p_menu: *Menu, p_reserve_toggle_size: c_int) void;
    pub const setReserveToggleSize = gtk_menu_set_reserve_toggle_size;

    /// Sets the `gdk.Screen` on which the menu will be displayed.
    extern fn gtk_menu_set_screen(p_menu: *Menu, p_screen: ?*gdk.Screen) void;
    pub const setScreen = gtk_menu_set_screen;

    /// Changes the tearoff state of the menu.  A menu is normally
    /// displayed as drop down menu which persists as long as the menu is
    /// active.  It can also be displayed as a tearoff menu which persists
    /// until it is closed or reattached.
    extern fn gtk_menu_set_tearoff_state(p_menu: *Menu, p_torn_off: c_int) void;
    pub const setTearoffState = gtk_menu_set_tearoff_state;

    /// Sets the title string for the menu.
    ///
    /// The title is displayed when the menu is shown as a tearoff
    /// menu. If `title` is `NULL`, the menu will see if it is attached
    /// to a parent menu item, and if so it will try to use the same
    /// text as that menu item’s label.
    extern fn gtk_menu_set_title(p_menu: *Menu, p_title: ?[*:0]const u8) void;
    pub const setTitle = gtk_menu_set_title;

    extern fn gtk_menu_get_type() usize;
    pub const getGObjectType = gtk_menu_get_type;

    extern fn g_object_ref(p_self: *gtk.Menu) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Menu) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Menu, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuAccessible = extern struct {
    pub const Parent = gtk.MenuShellAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Selection };
    pub const Class = gtk.MenuAccessibleClass;
    f_parent: gtk.MenuShellAccessible,
    f_priv: ?*gtk.MenuAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_menu_accessible_get_type() usize;
    pub const getGObjectType = gtk_menu_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.MenuAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.MenuAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MenuAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.MenuBar` is a subclass of `gtk.MenuShell` which contains one or
/// more `GtkMenuItems`. The result is a standard menu bar which can hold
/// many menu items.
///
/// # CSS nodes
///
/// GtkMenuBar has a single CSS node with name menubar.
pub const MenuBar = extern struct {
    pub const Parent = gtk.MenuShell;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.MenuBarClass;
    f_menu_shell: gtk.MenuShell,
    f_priv: ?*gtk.MenuBarPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The child pack direction of the menubar. It determines how
        /// the widgets contained in child menuitems are arranged.
        pub const child_pack_direction = struct {
            pub const name = "child-pack-direction";

            pub const Type = gtk.PackDirection;
        };

        /// The pack direction of the menubar. It determines how
        /// menuitems are arranged in the menubar.
        pub const pack_direction = struct {
            pub const name = "pack-direction";

            pub const Type = gtk.PackDirection;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.MenuBar`
    extern fn gtk_menu_bar_new() *gtk.MenuBar;
    pub const new = gtk_menu_bar_new;

    /// Creates a new `gtk.MenuBar` and populates it with menu items
    /// and submenus according to `model`.
    ///
    /// The created menu items are connected to actions found in the
    /// `gtk.ApplicationWindow` to which the menu bar belongs - typically
    /// by means of being contained within the `GtkApplicationWindows`
    /// widget hierarchy.
    extern fn gtk_menu_bar_new_from_model(p_model: *gio.MenuModel) *gtk.MenuBar;
    pub const newFromModel = gtk_menu_bar_new_from_model;

    /// Retrieves the current child pack direction of the menubar.
    /// See `gtk.MenuBar.setChildPackDirection`.
    extern fn gtk_menu_bar_get_child_pack_direction(p_menubar: *MenuBar) gtk.PackDirection;
    pub const getChildPackDirection = gtk_menu_bar_get_child_pack_direction;

    /// Retrieves the current pack direction of the menubar.
    /// See `gtk.MenuBar.setPackDirection`.
    extern fn gtk_menu_bar_get_pack_direction(p_menubar: *MenuBar) gtk.PackDirection;
    pub const getPackDirection = gtk_menu_bar_get_pack_direction;

    /// Sets how widgets should be packed inside the children of a menubar.
    extern fn gtk_menu_bar_set_child_pack_direction(p_menubar: *MenuBar, p_child_pack_dir: gtk.PackDirection) void;
    pub const setChildPackDirection = gtk_menu_bar_set_child_pack_direction;

    /// Sets how items should be packed inside a menubar.
    extern fn gtk_menu_bar_set_pack_direction(p_menubar: *MenuBar, p_pack_dir: gtk.PackDirection) void;
    pub const setPackDirection = gtk_menu_bar_set_pack_direction;

    extern fn gtk_menu_bar_get_type() usize;
    pub const getGObjectType = gtk_menu_bar_get_type;

    extern fn g_object_ref(p_self: *gtk.MenuBar) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.MenuBar) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MenuBar, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.MenuButton` widget is used to display a popup when clicked on.
/// This popup can be provided either as a `gtk.Menu`, a `gtk.Popover` or an
/// abstract `gio.MenuModel`.
///
/// The `gtk.MenuButton` widget can hold any valid child widget. That is, it
/// can hold almost any other standard `gtk.Widget`. The most commonly used
/// child is `gtk.Image`. If no widget is explicitely added to the `gtk.MenuButton`,
/// a `gtk.Image` is automatically created, using an arrow image oriented
/// according to `gtk.MenuButton.properties.direction` or the generic “open-menu-symbolic”
/// icon if the direction is not set.
///
/// The positioning of the popup is determined by the `gtk.MenuButton.properties.direction`
/// property of the menu button.
///
/// For menus, the `gtk.Widget.properties.halign` and `gtk.Widget.properties.valign` properties of the
/// menu are also taken into account. For example, when the direction is
/// `GTK_ARROW_DOWN` and the horizontal alignment is `GTK_ALIGN_START`, the
/// menu will be positioned below the button, with the starting edge
/// (depending on the text direction) of the menu aligned with the starting
/// edge of the button. If there is not enough space below the button, the
/// menu is popped up above the button instead. If the alignment would move
/// part of the menu offscreen, it is “pushed in”.
///
/// ## Direction = Down
///
/// - halign = start
///
///     ![](down-start.png)
///
/// - halign = center
///
///     ![](down-center.png)
///
/// - halign = end
///
///     ![](down-end.png)
///
/// ## Direction = Up
///
/// - halign = start
///
///     ![](up-start.png)
///
/// - halign = center
///
///     ![](up-center.png)
///
/// - halign = end
///
///     ![](up-end.png)
///
/// ## Direction = Left
///
/// - valign = start
///
///     ![](left-start.png)
///
/// - valign = center
///
///     ![](left-center.png)
///
/// - valign = end
///
///     ![](left-end.png)
///
/// ## Direction = Right
///
/// - valign = start
///
///     ![](right-start.png)
///
/// - valign = center
///
///     ![](right-center.png)
///
/// - valign = end
///
///     ![](right-end.png)
///
/// # CSS nodes
///
/// GtkMenuButton has a single CSS node with name button. To differentiate
/// it from a plain `gtk.Button`, it gets the .popup style class.
pub const MenuButton = extern struct {
    pub const Parent = gtk.ToggleButton;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.MenuButtonClass;
    f_parent: gtk.ToggleButton,
    f_priv: ?*gtk.MenuButtonPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The `gtk.Widget` to use to align the menu with.
        pub const align_widget = struct {
            pub const name = "align-widget";

            pub const Type = ?*gtk.Container;
        };

        /// The `gtk.ArrowType` representing the direction in which the
        /// menu or popover will be popped out.
        pub const direction = struct {
            pub const name = "direction";

            pub const Type = gtk.ArrowType;
        };

        /// The `gio.MenuModel` from which the popup will be created.
        /// Depending on the `gtk.MenuButton.properties.use`-popover property, that may
        /// be a menu or a popover.
        ///
        /// See `gtk.MenuButton.setMenuModel` for the interaction with the
        /// `gtk.MenuButton.properties.popup` property.
        pub const menu_model = struct {
            pub const name = "menu-model";

            pub const Type = ?*gio.MenuModel;
        };

        /// The `gtk.Popover` that will be popped up when the button is clicked.
        pub const popover = struct {
            pub const name = "popover";

            pub const Type = ?*gtk.Popover;
        };

        /// The `gtk.Menu` that will be popped up when the button is clicked.
        pub const popup = struct {
            pub const name = "popup";

            pub const Type = ?*gtk.Menu;
        };

        /// Whether to construct a `gtk.Popover` from the menu model,
        /// or a `gtk.Menu`.
        pub const use_popover = struct {
            pub const name = "use-popover";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.MenuButton` widget with downwards-pointing
    /// arrow as the only child. You can replace the child widget
    /// with another `gtk.Widget` should you wish to.
    extern fn gtk_menu_button_new() *gtk.MenuButton;
    pub const new = gtk_menu_button_new;

    /// Returns the parent `gtk.Widget` to use to line up with menu.
    extern fn gtk_menu_button_get_align_widget(p_menu_button: *MenuButton) ?*gtk.Widget;
    pub const getAlignWidget = gtk_menu_button_get_align_widget;

    /// Returns the direction the popup will be pointing at when popped up.
    extern fn gtk_menu_button_get_direction(p_menu_button: *MenuButton) gtk.ArrowType;
    pub const getDirection = gtk_menu_button_get_direction;

    /// Returns the `gio.MenuModel` used to generate the popup.
    extern fn gtk_menu_button_get_menu_model(p_menu_button: *MenuButton) ?*gio.MenuModel;
    pub const getMenuModel = gtk_menu_button_get_menu_model;

    /// Returns the `gtk.Popover` that pops out of the button.
    /// If the button is not using a `gtk.Popover`, this function
    /// returns `NULL`.
    extern fn gtk_menu_button_get_popover(p_menu_button: *MenuButton) ?*gtk.Popover;
    pub const getPopover = gtk_menu_button_get_popover;

    /// Returns the `gtk.Menu` that pops out of the button.
    /// If the button does not use a `gtk.Menu`, this function
    /// returns `NULL`.
    extern fn gtk_menu_button_get_popup(p_menu_button: *MenuButton) ?*gtk.Menu;
    pub const getPopup = gtk_menu_button_get_popup;

    /// Returns whether a `gtk.Popover` or a `gtk.Menu` will be constructed
    /// from the menu model.
    extern fn gtk_menu_button_get_use_popover(p_menu_button: *MenuButton) c_int;
    pub const getUsePopover = gtk_menu_button_get_use_popover;

    /// Sets the `gtk.Widget` to use to line the menu with when popped up.
    /// Note that the `align_widget` must contain the `gtk.MenuButton` itself.
    ///
    /// Setting it to `NULL` means that the menu will be aligned with the
    /// button itself.
    ///
    /// Note that this property is only used with menus currently,
    /// and not for popovers.
    extern fn gtk_menu_button_set_align_widget(p_menu_button: *MenuButton, p_align_widget: ?*gtk.Widget) void;
    pub const setAlignWidget = gtk_menu_button_set_align_widget;

    /// Sets the direction in which the popup will be popped up, as
    /// well as changing the arrow’s direction. The child will not
    /// be changed to an arrow if it was customized.
    ///
    /// If the does not fit in the available space in the given direction,
    /// GTK+ will its best to keep it inside the screen and fully visible.
    ///
    /// If you pass `GTK_ARROW_NONE` for a `direction`, the popup will behave
    /// as if you passed `GTK_ARROW_DOWN` (although you won’t see any arrows).
    extern fn gtk_menu_button_set_direction(p_menu_button: *MenuButton, p_direction: gtk.ArrowType) void;
    pub const setDirection = gtk_menu_button_set_direction;

    /// Sets the `gio.MenuModel` from which the popup will be constructed,
    /// or `NULL` to dissociate any existing menu model and disable the button.
    ///
    /// Depending on the value of `gtk.MenuButton.properties.use`-popover, either a
    /// `gtk.Menu` will be created with `gtk.Menu.newFromModel`, or a
    /// `gtk.Popover` with `gtk.Popover.newFromModel`. In either case,
    /// actions will be connected as documented for these functions.
    ///
    /// If `gtk.MenuButton.properties.popup` or `gtk.MenuButton.properties.popover` are already set, those
    /// widgets are dissociated from the `menu_button`, and those properties are set
    /// to `NULL`.
    extern fn gtk_menu_button_set_menu_model(p_menu_button: *MenuButton, p_menu_model: ?*gio.MenuModel) void;
    pub const setMenuModel = gtk_menu_button_set_menu_model;

    /// Sets the `gtk.Popover` that will be popped up when the `menu_button` is clicked,
    /// or `NULL` to dissociate any existing popover and disable the button.
    ///
    /// If `gtk.MenuButton.properties.menu`-model or `gtk.MenuButton.properties.popup` are set, those objects
    /// are dissociated from the `menu_button`, and those properties are set to `NULL`.
    extern fn gtk_menu_button_set_popover(p_menu_button: *MenuButton, p_popover: ?*gtk.Widget) void;
    pub const setPopover = gtk_menu_button_set_popover;

    /// Sets the `gtk.Menu` that will be popped up when the `menu_button` is clicked, or
    /// `NULL` to dissociate any existing menu and disable the button.
    ///
    /// If `gtk.MenuButton.properties.menu`-model or `gtk.MenuButton.properties.popover` are set, those objects
    /// are dissociated from the `menu_button`, and those properties are set to `NULL`.
    extern fn gtk_menu_button_set_popup(p_menu_button: *MenuButton, p_menu: ?*gtk.Widget) void;
    pub const setPopup = gtk_menu_button_set_popup;

    /// Sets whether to construct a `gtk.Popover` instead of `gtk.Menu`
    /// when `gtk.MenuButton.setMenuModel` is called. Note that
    /// this property is only consulted when a new menu model is set.
    extern fn gtk_menu_button_set_use_popover(p_menu_button: *MenuButton, p_use_popover: c_int) void;
    pub const setUsePopover = gtk_menu_button_set_use_popover;

    extern fn gtk_menu_button_get_type() usize;
    pub const getGObjectType = gtk_menu_button_get_type;

    extern fn g_object_ref(p_self: *gtk.MenuButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.MenuButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MenuButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuButtonAccessible = extern struct {
    pub const Parent = gtk.ToggleButtonAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.Image };
    pub const Class = gtk.MenuButtonAccessibleClass;
    f_parent: gtk.ToggleButtonAccessible,
    f_priv: ?*gtk.MenuButtonAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_menu_button_accessible_get_type() usize;
    pub const getGObjectType = gtk_menu_button_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.MenuButtonAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.MenuButtonAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MenuButtonAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.MenuItem` widget and the derived widgets are the only valid
/// children for menus. Their function is to correctly handle highlighting,
/// alignment, events and submenus.
///
/// As a GtkMenuItem derives from `gtk.Bin` it can hold any valid child widget,
/// although only a few are really useful.
///
/// By default, a GtkMenuItem sets a `gtk.AccelLabel` as its child.
/// GtkMenuItem has direct functions to set the label and its mnemonic.
/// For more advanced label settings, you can fetch the child widget from the GtkBin.
///
/// An example for setting markup and accelerator on a MenuItem:
///
/// ```
/// GtkWidget *menu_item = gtk_menu_item_new_with_label ("Example Menu Item");
///
/// GtkWidget *child = gtk_bin_get_child (GTK_BIN (menu_item));
/// gtk_label_set_markup (GTK_LABEL (child), "<i>new label</i> with <b>markup</b>");
/// gtk_accel_label_set_accel (GTK_ACCEL_LABEL (child), GDK_KEY_1, 0);
/// ```
///
/// # GtkMenuItem as GtkBuildable
///
/// The GtkMenuItem implementation of the `gtk.Buildable` interface supports
/// adding a submenu by specifying “submenu” as the “type” attribute of
/// a `<child>` element.
///
/// An example of UI definition fragment with submenus:
///
/// ```
/// <object class="GtkMenuItem">
///   <child type="submenu">
///     <object class="GtkMenu"/>
///   </child>
/// </object>
/// ```
///
/// # CSS nodes
///
/// ```
/// menuitem
/// ├── <child>
/// ╰── [arrow.right]
/// ```
///
/// GtkMenuItem has a single CSS node with name menuitem. If the menuitem
/// has a submenu, it gets another CSS node with name arrow, which has
/// the .left or .right style class.
pub const MenuItem = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.MenuItemClass;
    f_bin: gtk.Bin,
    f_priv: ?*gtk.MenuItemPrivate,

    pub const virtual_methods = struct {
        /// Emits the `gtk.MenuItem.signals.activate` signal on the given item
        pub const activate = struct {
            pub fn call(p_class: anytype, p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(MenuItem.Class, p_class).f_activate.?(gobject.ext.as(MenuItem, p_menu_item));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(MenuItem.Class, p_class).f_activate = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the item is activated, but also
        ///    if the menu item has a submenu.
        pub const activate_item = struct {
            pub fn call(p_class: anytype, p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(MenuItem.Class, p_class).f_activate_item.?(gobject.ext.as(MenuItem, p_menu_item));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(MenuItem.Class, p_class).f_activate_item = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gtk.MenuItem.signals.deselect` signal on the given item.
        pub const deselect = struct {
            pub fn call(p_class: anytype, p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(MenuItem.Class, p_class).f_deselect.?(gobject.ext.as(MenuItem, p_menu_item));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(MenuItem.Class, p_class).f_deselect = @ptrCast(p_implementation);
            }
        };

        /// Sets `text` on the `menu_item` label
        pub const get_label = struct {
            pub fn call(p_class: anytype, p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]const u8 {
                return gobject.ext.as(MenuItem.Class, p_class).f_get_label.?(gobject.ext.as(MenuItem, p_menu_item));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]const u8) void {
                gobject.ext.as(MenuItem.Class, p_class).f_get_label = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gtk.MenuItem.signals.select` signal on the given item.
        pub const select = struct {
            pub fn call(p_class: anytype, p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(MenuItem.Class, p_class).f_select.?(gobject.ext.as(MenuItem, p_menu_item));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(MenuItem.Class, p_class).f_select = @ptrCast(p_implementation);
            }
        };

        /// Sets `text` on the `menu_item` label
        pub const set_label = struct {
            pub fn call(p_class: anytype, p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_label: [*:0]const u8) void {
                return gobject.ext.as(MenuItem.Class, p_class).f_set_label.?(gobject.ext.as(MenuItem, p_menu_item), p_label);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_label: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(MenuItem.Class, p_class).f_set_label = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gtk.MenuItem.signals.toggle`-size-allocate signal on the given item.
        pub const toggle_size_allocate = struct {
            pub fn call(p_class: anytype, p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_allocation: c_int) void {
                return gobject.ext.as(MenuItem.Class, p_class).f_toggle_size_allocate.?(gobject.ext.as(MenuItem, p_menu_item), p_allocation);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_allocation: c_int) callconv(.c) void) void {
                gobject.ext.as(MenuItem.Class, p_class).f_toggle_size_allocate = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gtk.MenuItem.signals.toggle`-size-request signal on the given item.
        pub const toggle_size_request = struct {
            pub fn call(p_class: anytype, p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_requisition: *c_int) void {
                return gobject.ext.as(MenuItem.Class, p_class).f_toggle_size_request.?(gobject.ext.as(MenuItem, p_menu_item), p_requisition);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_requisition: *c_int) callconv(.c) void) void {
                gobject.ext.as(MenuItem.Class, p_class).f_toggle_size_request = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Sets the accelerator path of the menu item, through which runtime
        /// changes of the menu item's accelerator caused by the user can be
        /// identified and saved to persistant storage.
        pub const accel_path = struct {
            pub const name = "accel-path";

            pub const Type = ?[*:0]u8;
        };

        /// The text for the child label.
        pub const label = struct {
            pub const name = "label";

            pub const Type = ?[*:0]u8;
        };

        /// Sets whether the menu item appears justified
        /// at the right side of a menu bar.
        pub const right_justified = struct {
            pub const name = "right-justified";

            pub const Type = c_int;
        };

        /// The submenu attached to the menu item, or `NULL` if it has none.
        pub const submenu = struct {
            pub const name = "submenu";

            pub const Type = ?*gtk.Menu;
        };

        /// `TRUE` if underlines in the text indicate mnemonics.
        pub const use_underline = struct {
            pub const name = "use-underline";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted when the item is activated.
        pub const activate = struct {
            pub const name = "activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuItem, p_instance))),
                    gobject.signalLookup("activate", MenuItem.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the item is activated, but also if the menu item has a
        /// submenu. For normal applications, the relevant signal is
        /// `gtk.MenuItem.signals.activate`.
        pub const activate_item = struct {
            pub const name = "activate-item";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuItem, p_instance))),
                    gobject.signalLookup("activate-item", MenuItem.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const deselect = struct {
            pub const name = "deselect";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuItem, p_instance))),
                    gobject.signalLookup("deselect", MenuItem.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const select = struct {
            pub const name = "select";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuItem, p_instance))),
                    gobject.signalLookup("select", MenuItem.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const toggle_size_allocate = struct {
            pub const name = "toggle-size-allocate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuItem, p_instance))),
                    gobject.signalLookup("toggle-size-allocate", MenuItem.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const toggle_size_request = struct {
            pub const name = "toggle-size-request";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: ?*anyopaque, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuItem, p_instance))),
                    gobject.signalLookup("toggle-size-request", MenuItem.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.MenuItem`.
    extern fn gtk_menu_item_new() *gtk.MenuItem;
    pub const new = gtk_menu_item_new;

    /// Creates a new `gtk.MenuItem` whose child is a `gtk.Label`.
    extern fn gtk_menu_item_new_with_label(p_label: [*:0]const u8) *gtk.MenuItem;
    pub const newWithLabel = gtk_menu_item_new_with_label;

    /// Creates a new `gtk.MenuItem` containing a label.
    ///
    /// The label will be created using `gtk.Label.newWithMnemonic`,
    /// so underscores in `label` indicate the mnemonic for the menu item.
    extern fn gtk_menu_item_new_with_mnemonic(p_label: [*:0]const u8) *gtk.MenuItem;
    pub const newWithMnemonic = gtk_menu_item_new_with_mnemonic;

    /// Emits the `gtk.MenuItem.signals.activate` signal on the given item
    extern fn gtk_menu_item_activate(p_menu_item: *MenuItem) void;
    pub const activate = gtk_menu_item_activate;

    /// Emits the `gtk.MenuItem.signals.deselect` signal on the given item.
    extern fn gtk_menu_item_deselect(p_menu_item: *MenuItem) void;
    pub const deselect = gtk_menu_item_deselect;

    /// Retrieve the accelerator path that was previously set on `menu_item`.
    ///
    /// See `gtk.MenuItem.setAccelPath` for details.
    extern fn gtk_menu_item_get_accel_path(p_menu_item: *MenuItem) ?[*:0]const u8;
    pub const getAccelPath = gtk_menu_item_get_accel_path;

    /// Sets `text` on the `menu_item` label
    extern fn gtk_menu_item_get_label(p_menu_item: *MenuItem) [*:0]const u8;
    pub const getLabel = gtk_menu_item_get_label;

    /// Returns whether the `menu_item` reserves space for
    /// the submenu indicator, regardless if it has a submenu
    /// or not.
    extern fn gtk_menu_item_get_reserve_indicator(p_menu_item: *MenuItem) c_int;
    pub const getReserveIndicator = gtk_menu_item_get_reserve_indicator;

    /// Gets whether the menu item appears justified at the right
    /// side of the menu bar.
    extern fn gtk_menu_item_get_right_justified(p_menu_item: *MenuItem) c_int;
    pub const getRightJustified = gtk_menu_item_get_right_justified;

    /// Gets the submenu underneath this menu item, if any.
    /// See `gtk.MenuItem.setSubmenu`.
    extern fn gtk_menu_item_get_submenu(p_menu_item: *MenuItem) ?*gtk.Widget;
    pub const getSubmenu = gtk_menu_item_get_submenu;

    /// Checks if an underline in the text indicates the next character
    /// should be used for the mnemonic accelerator key.
    extern fn gtk_menu_item_get_use_underline(p_menu_item: *MenuItem) c_int;
    pub const getUseUnderline = gtk_menu_item_get_use_underline;

    /// Emits the `gtk.MenuItem.signals.select` signal on the given item.
    extern fn gtk_menu_item_select(p_menu_item: *MenuItem) void;
    pub const select = gtk_menu_item_select;

    /// Set the accelerator path on `menu_item`, through which runtime
    /// changes of the menu item’s accelerator caused by the user can be
    /// identified and saved to persistent storage (see `gtk.AccelMap.save`
    /// on this). To set up a default accelerator for this menu item, call
    /// `gtk.AccelMap.addEntry` with the same `accel_path`. See also
    /// `gtk.AccelMap.addEntry` on the specifics of accelerator paths,
    /// and `gtk.Menu.setAccelPath` for a more convenient variant of
    /// this function.
    ///
    /// This function is basically a convenience wrapper that handles
    /// calling `gtk.Widget.setAccelPath` with the appropriate accelerator
    /// group for the menu item.
    ///
    /// Note that you do need to set an accelerator on the parent menu with
    /// `gtk.Menu.setAccelGroup` for this to work.
    ///
    /// Note that `accel_path` string will be stored in a `glib.Quark`.
    /// Therefore, if you pass a static string, you can save some memory
    /// by interning it first with `glib.internStaticString`.
    extern fn gtk_menu_item_set_accel_path(p_menu_item: *MenuItem, p_accel_path: ?[*:0]const u8) void;
    pub const setAccelPath = gtk_menu_item_set_accel_path;

    /// Sets `text` on the `menu_item` label
    extern fn gtk_menu_item_set_label(p_menu_item: *MenuItem, p_label: [*:0]const u8) void;
    pub const setLabel = gtk_menu_item_set_label;

    /// Sets whether the `menu_item` should reserve space for
    /// the submenu indicator, regardless if it actually has
    /// a submenu or not.
    ///
    /// There should be little need for applications to call
    /// this functions.
    extern fn gtk_menu_item_set_reserve_indicator(p_menu_item: *MenuItem, p_reserve: c_int) void;
    pub const setReserveIndicator = gtk_menu_item_set_reserve_indicator;

    /// Sets whether the menu item appears justified at the right
    /// side of a menu bar. This was traditionally done for “Help”
    /// menu items, but is now considered a bad idea. (If the widget
    /// layout is reversed for a right-to-left language like Hebrew
    /// or Arabic, right-justified-menu-items appear at the left.)
    extern fn gtk_menu_item_set_right_justified(p_menu_item: *MenuItem, p_right_justified: c_int) void;
    pub const setRightJustified = gtk_menu_item_set_right_justified;

    /// Sets or replaces the menu item’s submenu, or removes it when a `NULL`
    /// submenu is passed.
    extern fn gtk_menu_item_set_submenu(p_menu_item: *MenuItem, p_submenu: ?*gtk.Menu) void;
    pub const setSubmenu = gtk_menu_item_set_submenu;

    /// If true, an underline in the text indicates the next character
    /// should be used for the mnemonic accelerator key.
    extern fn gtk_menu_item_set_use_underline(p_menu_item: *MenuItem, p_setting: c_int) void;
    pub const setUseUnderline = gtk_menu_item_set_use_underline;

    /// Emits the `gtk.MenuItem.signals.toggle`-size-allocate signal on the given item.
    extern fn gtk_menu_item_toggle_size_allocate(p_menu_item: *MenuItem, p_allocation: c_int) void;
    pub const toggleSizeAllocate = gtk_menu_item_toggle_size_allocate;

    /// Emits the `gtk.MenuItem.signals.toggle`-size-request signal on the given item.
    extern fn gtk_menu_item_toggle_size_request(p_menu_item: *MenuItem, p_requisition: *c_int) void;
    pub const toggleSizeRequest = gtk_menu_item_toggle_size_request;

    extern fn gtk_menu_item_get_type() usize;
    pub const getGObjectType = gtk_menu_item_get_type;

    extern fn g_object_ref(p_self: *gtk.MenuItem) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.MenuItem) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MenuItem, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuItemAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.Selection };
    pub const Class = gtk.MenuItemAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.MenuItemAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_menu_item_accessible_get_type() usize;
    pub const getGObjectType = gtk_menu_item_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.MenuItemAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.MenuItemAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MenuItemAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.MenuShell` is the abstract base class used to derive the
/// `gtk.Menu` and `gtk.MenuBar` subclasses.
///
/// A `gtk.MenuShell` is a container of `gtk.MenuItem` objects arranged
/// in a list which can be navigated, selected, and activated by the
/// user to perform application functions. A `gtk.MenuItem` can have a
/// submenu associated with it, allowing for nested hierarchical menus.
///
/// # Terminology
///
/// A menu item can be “selected”, this means that it is displayed
/// in the prelight state, and if it has a submenu, that submenu
/// will be popped up.
///
/// A menu is “active” when it is visible onscreen and the user
/// is selecting from it. A menubar is not active until the user
/// clicks on one of its menuitems. When a menu is active,
/// passing the mouse over a submenu will pop it up.
///
/// There is also is a concept of the current menu and a current
/// menu item. The current menu item is the selected menu item
/// that is furthest down in the hierarchy. (Every active menu shell
/// does not necessarily contain a selected menu item, but if
/// it does, then the parent menu shell must also contain
/// a selected menu item.) The current menu is the menu that
/// contains the current menu item. It will always have a GTK
/// grab and receive all key presses.
pub const MenuShell = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.MenuShellClass;
    f_container: gtk.Container,
    f_priv: ?*gtk.MenuShellPrivate,

    pub const virtual_methods = struct {
        pub const activate_current = struct {
            pub fn call(p_class: anytype, p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_force_hide: c_int) void {
                return gobject.ext.as(MenuShell.Class, p_class).f_activate_current.?(gobject.ext.as(MenuShell, p_menu_shell), p_force_hide);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_force_hide: c_int) callconv(.c) void) void {
                gobject.ext.as(MenuShell.Class, p_class).f_activate_current = @ptrCast(p_implementation);
            }
        };

        /// Cancels the selection within the menu shell.
        pub const cancel = struct {
            pub fn call(p_class: anytype, p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(MenuShell.Class, p_class).f_cancel.?(gobject.ext.as(MenuShell, p_menu_shell));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(MenuShell.Class, p_class).f_cancel = @ptrCast(p_implementation);
            }
        };

        /// Deactivates the menu shell.
        ///
        /// Typically this results in the menu shell being erased
        /// from the screen.
        pub const deactivate = struct {
            pub fn call(p_class: anytype, p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(MenuShell.Class, p_class).f_deactivate.?(gobject.ext.as(MenuShell, p_menu_shell));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(MenuShell.Class, p_class).f_deactivate = @ptrCast(p_implementation);
            }
        };

        pub const get_popup_delay = struct {
            pub fn call(p_class: anytype, p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(MenuShell.Class, p_class).f_get_popup_delay.?(gobject.ext.as(MenuShell, p_menu_shell));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(MenuShell.Class, p_class).f_get_popup_delay = @ptrCast(p_implementation);
            }
        };

        /// Adds a new `gtk.MenuItem` to the menu shell’s item list
        /// at the position indicated by `position`.
        pub const insert = struct {
            pub fn call(p_class: anytype, p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget, p_position: c_int) void {
                return gobject.ext.as(MenuShell.Class, p_class).f_insert.?(gobject.ext.as(MenuShell, p_menu_shell), p_child, p_position);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget, p_position: c_int) callconv(.c) void) void {
                gobject.ext.as(MenuShell.Class, p_class).f_insert = @ptrCast(p_implementation);
            }
        };

        pub const move_current = struct {
            pub fn call(p_class: anytype, p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.MenuDirectionType) void {
                return gobject.ext.as(MenuShell.Class, p_class).f_move_current.?(gobject.ext.as(MenuShell, p_menu_shell), p_direction);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.MenuDirectionType) callconv(.c) void) void {
                gobject.ext.as(MenuShell.Class, p_class).f_move_current = @ptrCast(p_implementation);
            }
        };

        pub const move_selected = struct {
            pub fn call(p_class: anytype, p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_distance: c_int) c_int {
                return gobject.ext.as(MenuShell.Class, p_class).f_move_selected.?(gobject.ext.as(MenuShell, p_menu_shell), p_distance);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_distance: c_int) callconv(.c) c_int) void {
                gobject.ext.as(MenuShell.Class, p_class).f_move_selected = @ptrCast(p_implementation);
            }
        };

        /// Selects the menu item from the menu shell.
        pub const select_item = struct {
            pub fn call(p_class: anytype, p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_menu_item: *gtk.Widget) void {
                return gobject.ext.as(MenuShell.Class, p_class).f_select_item.?(gobject.ext.as(MenuShell, p_menu_shell), p_menu_item);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_menu_item: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(MenuShell.Class, p_class).f_select_item = @ptrCast(p_implementation);
            }
        };

        pub const selection_done = struct {
            pub fn call(p_class: anytype, p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(MenuShell.Class, p_class).f_selection_done.?(gobject.ext.as(MenuShell, p_menu_shell));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_menu_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(MenuShell.Class, p_class).f_selection_done = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// A boolean that determines whether the menu and its submenus grab the
        /// keyboard focus. See `gtk.MenuShell.setTakeFocus` and
        /// `gtk.MenuShell.getTakeFocus`.
        pub const take_focus = struct {
            pub const name = "take-focus";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// An action signal that activates the current menu item within
        /// the menu shell.
        pub const activate_current = struct {
            pub const name = "activate-current";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_force_hide: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuShell, p_instance))),
                    gobject.signalLookup("activate-current", MenuShell.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// An action signal which cancels the selection within the menu shell.
        /// Causes the `gtk.MenuShell.signals.selection`-done signal to be emitted.
        pub const cancel = struct {
            pub const name = "cancel";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuShell, p_instance))),
                    gobject.signalLookup("cancel", MenuShell.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// A keybinding signal which moves the focus in the
        /// given `direction`.
        pub const cycle_focus = struct {
            pub const name = "cycle-focus";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_direction: gtk.DirectionType, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuShell, p_instance))),
                    gobject.signalLookup("cycle-focus", MenuShell.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when a menu shell is deactivated.
        pub const deactivate = struct {
            pub const name = "deactivate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuShell, p_instance))),
                    gobject.signalLookup("deactivate", MenuShell.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::insert signal is emitted when a new `gtk.MenuItem` is added to
        /// a `gtk.MenuShell`.  A separate signal is used instead of
        /// GtkContainer::add because of the need for an additional position
        /// parameter.
        ///
        /// The inverse of this signal is the GtkContainer::removed signal.
        pub const insert = struct {
            pub const name = "insert";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_child: *gtk.Widget, p_position: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuShell, p_instance))),
                    gobject.signalLookup("insert", MenuShell.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// An keybinding signal which moves the current menu item
        /// in the direction specified by `direction`.
        pub const move_current = struct {
            pub const name = "move-current";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_direction: gtk.MenuDirectionType, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuShell, p_instance))),
                    gobject.signalLookup("move-current", MenuShell.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::move-selected signal is emitted to move the selection to
        /// another item.
        pub const move_selected = struct {
            pub const name = "move-selected";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_distance: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuShell, p_instance))),
                    gobject.signalLookup("move-selected", MenuShell.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when a selection has been
        /// completed within a menu shell.
        pub const selection_done = struct {
            pub const name = "selection-done";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuShell, p_instance))),
                    gobject.signalLookup("selection-done", MenuShell.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Activates the menu item within the menu shell.
    extern fn gtk_menu_shell_activate_item(p_menu_shell: *MenuShell, p_menu_item: *gtk.Widget, p_force_deactivate: c_int) void;
    pub const activateItem = gtk_menu_shell_activate_item;

    /// Adds a new `gtk.MenuItem` to the end of the menu shell's
    /// item list.
    extern fn gtk_menu_shell_append(p_menu_shell: *MenuShell, p_child: *gtk.MenuItem) void;
    pub const append = gtk_menu_shell_append;

    /// Establishes a binding between a `gtk.MenuShell` and a `gio.MenuModel`.
    ///
    /// The contents of `shell` are removed and then refilled with menu items
    /// according to `model`.  When `model` changes, `shell` is updated.
    /// Calling this function twice on `shell` with different `model` will
    /// cause the first binding to be replaced with a binding to the new
    /// model. If `model` is `NULL` then any previous binding is undone and
    /// all children are removed.
    ///
    /// `with_separators` determines if toplevel items (eg: sections) have
    /// separators inserted between them.  This is typically desired for
    /// menus but doesn’t make sense for menubars.
    ///
    /// If `action_namespace` is non-`NULL` then the effect is as if all
    /// actions mentioned in the `model` have their names prefixed with the
    /// namespace, plus a dot.  For example, if the action “quit” is
    /// mentioned and `action_namespace` is “app” then the effective action
    /// name is “app.quit”.
    ///
    /// This function uses `gtk.Actionable` to define the action name and
    /// target values on the created menu items.  If you want to use an
    /// action group other than “app” and “win”, or if you want to use a
    /// `gtk.MenuShell` outside of a `gtk.ApplicationWindow`, then you will need
    /// to attach your own action group to the widget hierarchy using
    /// `gtk.Widget.insertActionGroup`.  As an example, if you created a
    /// group with a “quit” action and inserted it with the name “mygroup”
    /// then you would use the action name “mygroup.quit” in your
    /// `gio.MenuModel`.
    ///
    /// For most cases you are probably better off using
    /// `gtk.Menu.newFromModel` or `gtk.MenuBar.newFromModel` or just
    /// directly passing the `gio.MenuModel` to `gtk.Application.setAppMenu` or
    /// `gtk.Application.setMenubar`.
    extern fn gtk_menu_shell_bind_model(p_menu_shell: *MenuShell, p_model: ?*gio.MenuModel, p_action_namespace: ?[*:0]const u8, p_with_separators: c_int) void;
    pub const bindModel = gtk_menu_shell_bind_model;

    /// Cancels the selection within the menu shell.
    extern fn gtk_menu_shell_cancel(p_menu_shell: *MenuShell) void;
    pub const cancel = gtk_menu_shell_cancel;

    /// Deactivates the menu shell.
    ///
    /// Typically this results in the menu shell being erased
    /// from the screen.
    extern fn gtk_menu_shell_deactivate(p_menu_shell: *MenuShell) void;
    pub const deactivate = gtk_menu_shell_deactivate;

    /// Deselects the currently selected item from the menu shell,
    /// if any.
    extern fn gtk_menu_shell_deselect(p_menu_shell: *MenuShell) void;
    pub const deselect = gtk_menu_shell_deselect;

    /// Gets the parent menu shell.
    ///
    /// The parent menu shell of a submenu is the `gtk.Menu` or `gtk.MenuBar`
    /// from which it was opened up.
    extern fn gtk_menu_shell_get_parent_shell(p_menu_shell: *MenuShell) *gtk.Widget;
    pub const getParentShell = gtk_menu_shell_get_parent_shell;

    /// Gets the currently selected item.
    extern fn gtk_menu_shell_get_selected_item(p_menu_shell: *MenuShell) *gtk.Widget;
    pub const getSelectedItem = gtk_menu_shell_get_selected_item;

    /// Returns `TRUE` if the menu shell will take the keyboard focus on popup.
    extern fn gtk_menu_shell_get_take_focus(p_menu_shell: *MenuShell) c_int;
    pub const getTakeFocus = gtk_menu_shell_get_take_focus;

    /// Adds a new `gtk.MenuItem` to the menu shell’s item list
    /// at the position indicated by `position`.
    extern fn gtk_menu_shell_insert(p_menu_shell: *MenuShell, p_child: *gtk.Widget, p_position: c_int) void;
    pub const insert = gtk_menu_shell_insert;

    /// Adds a new `gtk.MenuItem` to the beginning of the menu shell's
    /// item list.
    extern fn gtk_menu_shell_prepend(p_menu_shell: *MenuShell, p_child: *gtk.Widget) void;
    pub const prepend = gtk_menu_shell_prepend;

    /// Select the first visible or selectable child of the menu shell;
    /// don’t select tearoff items unless the only item is a tearoff
    /// item.
    extern fn gtk_menu_shell_select_first(p_menu_shell: *MenuShell, p_search_sensitive: c_int) void;
    pub const selectFirst = gtk_menu_shell_select_first;

    /// Selects the menu item from the menu shell.
    extern fn gtk_menu_shell_select_item(p_menu_shell: *MenuShell, p_menu_item: *gtk.Widget) void;
    pub const selectItem = gtk_menu_shell_select_item;

    /// If `take_focus` is `TRUE` (the default) the menu shell will take
    /// the keyboard focus so that it will receive all keyboard events
    /// which is needed to enable keyboard navigation in menus.
    ///
    /// Setting `take_focus` to `FALSE` is useful only for special applications
    /// like virtual keyboard implementations which should not take keyboard
    /// focus.
    ///
    /// The `take_focus` state of a menu or menu bar is automatically
    /// propagated to submenus whenever a submenu is popped up, so you
    /// don’t have to worry about recursively setting it for your entire
    /// menu hierarchy. Only when programmatically picking a submenu and
    /// popping it up manually, the `take_focus` property of the submenu
    /// needs to be set explicitly.
    ///
    /// Note that setting it to `FALSE` has side-effects:
    ///
    /// If the focus is in some other app, it keeps the focus and keynav in
    /// the menu doesn’t work. Consequently, keynav on the menu will only
    /// work if the focus is on some toplevel owned by the onscreen keyboard.
    ///
    /// To avoid confusing the user, menus with `take_focus` set to `FALSE`
    /// should not display mnemonics or accelerators, since it cannot be
    /// guaranteed that they will work.
    ///
    /// See also `gdk.keyboardGrab`
    extern fn gtk_menu_shell_set_take_focus(p_menu_shell: *MenuShell, p_take_focus: c_int) void;
    pub const setTakeFocus = gtk_menu_shell_set_take_focus;

    extern fn gtk_menu_shell_get_type() usize;
    pub const getGObjectType = gtk_menu_shell_get_type;

    extern fn g_object_ref(p_self: *gtk.MenuShell) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.MenuShell) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MenuShell, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuShellAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Selection };
    pub const Class = gtk.MenuShellAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.MenuShellAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_menu_shell_accessible_get_type() usize;
    pub const getGObjectType = gtk_menu_shell_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.MenuShellAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.MenuShellAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MenuShellAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.MenuToolButton` is a `gtk.ToolItem` that contains a button and
/// a small additional button with an arrow. When clicked, the arrow
/// button pops up a dropdown menu.
///
/// Use `gtk.MenuToolButton.new` to create a new
/// `gtk.MenuToolButton`.
///
/// # GtkMenuToolButton as GtkBuildable
///
/// The GtkMenuToolButton implementation of the GtkBuildable interface
/// supports adding a menu by specifying “menu” as the “type” attribute
/// of a `<child>` element.
///
/// An example for a UI definition fragment with menus:
///
/// ```
/// <object class="GtkMenuToolButton">
///   <child type="menu">
///     <object class="GtkMenu"/>
///   </child>
/// </object>
/// ```
pub const MenuToolButton = extern struct {
    pub const Parent = gtk.ToolButton;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.MenuToolButtonClass;
    f_parent: gtk.ToolButton,
    f_priv: ?*gtk.MenuToolButtonPrivate,

    pub const virtual_methods = struct {
        /// Signal emitted before the menu is shown.
        pub const show_menu = struct {
            pub fn call(p_class: anytype, p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(MenuToolButton.Class, p_class).f_show_menu.?(gobject.ext.as(MenuToolButton, p_button));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(MenuToolButton.Class, p_class).f_show_menu = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const menu = struct {
            pub const name = "menu";

            pub const Type = ?*gtk.Menu;
        };
    };

    pub const signals = struct {
        /// The ::show-menu signal is emitted before the menu is shown.
        ///
        /// It can be used to populate the menu on demand, using
        /// `gtk.MenuToolButton.setMenu`.
        ///
        /// Note that even if you populate the menu dynamically in this way,
        /// you must set an empty menu on the `gtk.MenuToolButton` beforehand,
        /// since the arrow is made insensitive if the menu is not set.
        pub const show_menu = struct {
            pub const name = "show-menu";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuToolButton, p_instance))),
                    gobject.signalLookup("show-menu", MenuToolButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.MenuToolButton` using `icon_widget` as icon and
    /// `label` as label.
    extern fn gtk_menu_tool_button_new(p_icon_widget: ?*gtk.Widget, p_label: ?[*:0]const u8) *gtk.MenuToolButton;
    pub const new = gtk_menu_tool_button_new;

    /// Creates a new `gtk.MenuToolButton`.
    /// The new `gtk.MenuToolButton` will contain an icon and label from
    /// the stock item indicated by `stock_id`.
    extern fn gtk_menu_tool_button_new_from_stock(p_stock_id: [*:0]const u8) *gtk.MenuToolButton;
    pub const newFromStock = gtk_menu_tool_button_new_from_stock;

    /// Gets the `gtk.Menu` associated with `gtk.MenuToolButton`.
    extern fn gtk_menu_tool_button_get_menu(p_button: *MenuToolButton) *gtk.Widget;
    pub const getMenu = gtk_menu_tool_button_get_menu;

    /// Sets the tooltip markup text to be used as tooltip for the arrow button
    /// which pops up the menu.  See `gtk.ToolItem.setTooltipText` for setting
    /// a tooltip on the whole `gtk.MenuToolButton`.
    extern fn gtk_menu_tool_button_set_arrow_tooltip_markup(p_button: *MenuToolButton, p_markup: [*:0]const u8) void;
    pub const setArrowTooltipMarkup = gtk_menu_tool_button_set_arrow_tooltip_markup;

    /// Sets the tooltip text to be used as tooltip for the arrow button which
    /// pops up the menu.  See `gtk.ToolItem.setTooltipText` for setting a tooltip
    /// on the whole `gtk.MenuToolButton`.
    extern fn gtk_menu_tool_button_set_arrow_tooltip_text(p_button: *MenuToolButton, p_text: [*:0]const u8) void;
    pub const setArrowTooltipText = gtk_menu_tool_button_set_arrow_tooltip_text;

    /// Sets the `gtk.Menu` that is popped up when the user clicks on the arrow.
    /// If `menu` is NULL, the arrow button becomes insensitive.
    extern fn gtk_menu_tool_button_set_menu(p_button: *MenuToolButton, p_menu: *gtk.Widget) void;
    pub const setMenu = gtk_menu_tool_button_set_menu;

    extern fn gtk_menu_tool_button_get_type() usize;
    pub const getGObjectType = gtk_menu_tool_button_get_type;

    extern fn g_object_ref(p_self: *gtk.MenuToolButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.MenuToolButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MenuToolButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.MessageDialog` presents a dialog with some message text. It’s simply a
/// convenience widget; you could construct the equivalent of `gtk.MessageDialog`
/// from `gtk.Dialog` without too much effort, but `gtk.MessageDialog` saves typing.
///
/// One difference from `gtk.Dialog` is that `gtk.MessageDialog` sets the
/// `gtk.Window.properties.skip`-taskbar-hint property to `TRUE`, so that the dialog is hidden
/// from the taskbar by default.
///
/// The easiest way to do a modal message dialog is to use `gtk.Dialog.run`, though
/// you can also pass in the `GTK_DIALOG_MODAL` flag, `gtk.Dialog.run` automatically
/// makes the dialog modal and waits for the user to respond to it. `gtk.Dialog.run`
/// returns when any dialog button is clicked.
///
/// An example for using a modal dialog:
/// ```
///  GtkDialogFlags flags = GTK_DIALOG_DESTROY_WITH_PARENT;
///  dialog = gtk_message_dialog_new (parent_window,
///                                   flags,
///                                   GTK_MESSAGE_ERROR,
///                                   GTK_BUTTONS_CLOSE,
///                                   "Error reading “`s`”: `s`",
///                                   filename,
///                                   g_strerror (errno));
///  gtk_dialog_run (GTK_DIALOG (dialog));
///  gtk_widget_destroy (dialog);
/// ```
///
/// You might do a non-modal `gtk.MessageDialog` as follows:
///
/// An example for a non-modal dialog:
/// ```
///  GtkDialogFlags flags = GTK_DIALOG_DESTROY_WITH_PARENT;
///  dialog = gtk_message_dialog_new (parent_window,
///                                   flags,
///                                   GTK_MESSAGE_ERROR,
///                                   GTK_BUTTONS_CLOSE,
///                                   "Error reading “`s`”: `s`",
///                                   filename,
///                                   g_strerror (errno));
///
///  // Destroy the dialog when the user responds to it
///  // (e.g. clicks a button)
///
///  g_signal_connect_swapped (dialog, "response",
///                            G_CALLBACK (gtk_widget_destroy),
///                            dialog);
/// ```
///
/// # GtkMessageDialog as GtkBuildable
///
/// The GtkMessageDialog implementation of the GtkBuildable interface exposes
/// the message area as an internal child with the name “message_area”.
pub const MessageDialog = extern struct {
    pub const Parent = gtk.Dialog;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.MessageDialogClass;
    f_parent_instance: gtk.Dialog,
    f_priv: ?*gtk.MessageDialogPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const buttons = struct {
            pub const name = "buttons";

            pub const Type = gtk.ButtonsType;
        };

        /// The image for this dialog.
        pub const image = struct {
            pub const name = "image";

            pub const Type = ?*gtk.Widget;
        };

        /// The `gtk.Box` that corresponds to the message area of this dialog.  See
        /// `gtk.MessageDialog.getMessageArea` for a detailed description of this
        /// area.
        pub const message_area = struct {
            pub const name = "message-area";

            pub const Type = ?*gtk.Widget;
        };

        /// The type of the message.
        pub const message_type = struct {
            pub const name = "message-type";

            pub const Type = gtk.MessageType;
        };

        /// The secondary text of the message dialog.
        pub const secondary_text = struct {
            pub const name = "secondary-text";

            pub const Type = ?[*:0]u8;
        };

        /// `TRUE` if the secondary text of the dialog includes Pango markup.
        /// See `pango.parseMarkup`.
        pub const secondary_use_markup = struct {
            pub const name = "secondary-use-markup";

            pub const Type = c_int;
        };

        /// The primary text of the message dialog. If the dialog has
        /// a secondary text, this will appear as the title.
        pub const text = struct {
            pub const name = "text";

            pub const Type = ?[*:0]u8;
        };

        /// `TRUE` if the primary text of the dialog includes Pango markup.
        /// See `pango.parseMarkup`.
        pub const use_markup = struct {
            pub const name = "use-markup";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new message dialog, which is a simple dialog with some text
    /// the user may want to see. When the user clicks a button a “response”
    /// signal is emitted with response IDs from `gtk.ResponseType`. See
    /// `gtk.Dialog` for more details.
    extern fn gtk_message_dialog_new(p_parent: ?*gtk.Window, p_flags: gtk.DialogFlags, p_type: gtk.MessageType, p_buttons: gtk.ButtonsType, p_message_format: ?[*:0]const u8, ...) *gtk.MessageDialog;
    pub const new = gtk_message_dialog_new;

    /// Creates a new message dialog, which is a simple dialog with some text that
    /// is marked up with the [Pango text markup language][PangoMarkupFormat].
    /// When the user clicks a button a “response” signal is emitted with
    /// response IDs from `gtk.ResponseType`. See `gtk.Dialog` for more details.
    ///
    /// Special XML characters in the `printf` arguments passed to this
    /// function will automatically be escaped as necessary.
    /// (See `glib.markupPrintfEscaped` for how this is implemented.)
    /// Usually this is what you want, but if you have an existing
    /// Pango markup string that you want to use literally as the
    /// label, then you need to use `gtk.MessageDialog.setMarkup`
    /// instead, since you can’t pass the markup string either
    /// as the format (it might contain “%” characters) or as a string
    /// argument.
    /// ```
    ///  GtkWidget *dialog;
    ///  GtkDialogFlags flags = GTK_DIALOG_DESTROY_WITH_PARENT;
    ///  dialog = gtk_message_dialog_new (parent_window,
    ///                                   flags,
    ///                                   GTK_MESSAGE_ERROR,
    ///                                   GTK_BUTTONS_CLOSE,
    ///                                   NULL);
    ///  gtk_message_dialog_set_markup (GTK_MESSAGE_DIALOG (dialog),
    ///                                 markup);
    /// ```
    extern fn gtk_message_dialog_new_with_markup(p_parent: ?*gtk.Window, p_flags: gtk.DialogFlags, p_type: gtk.MessageType, p_buttons: gtk.ButtonsType, p_message_format: ?[*:0]const u8, ...) *gtk.MessageDialog;
    pub const newWithMarkup = gtk_message_dialog_new_with_markup;

    /// Sets the secondary text of the message dialog to be `message_format` (with
    /// `printf`-style), which is marked up with the
    /// [Pango text markup language][PangoMarkupFormat].
    ///
    /// Due to an oversight, this function does not escape special XML characters
    /// like `gtk.MessageDialog.newWithMarkup` does. Thus, if the arguments
    /// may contain special XML characters, you should use `glib.markupPrintfEscaped`
    /// to escape it.
    ///
    /// ```
    /// gchar *msg;
    ///
    /// msg = g_markup_printf_escaped (message_format, ...);
    /// gtk_message_dialog_format_secondary_markup (message_dialog,
    ///                                             "`s`", msg);
    /// g_free (msg);
    /// ```
    extern fn gtk_message_dialog_format_secondary_markup(p_message_dialog: *MessageDialog, p_message_format: [*:0]const u8, ...) void;
    pub const formatSecondaryMarkup = gtk_message_dialog_format_secondary_markup;

    /// Sets the secondary text of the message dialog to be `message_format`
    /// (with `printf`-style).
    extern fn gtk_message_dialog_format_secondary_text(p_message_dialog: *MessageDialog, p_message_format: ?[*:0]const u8, ...) void;
    pub const formatSecondaryText = gtk_message_dialog_format_secondary_text;

    /// Gets the dialog’s image.
    extern fn gtk_message_dialog_get_image(p_dialog: *MessageDialog) *gtk.Widget;
    pub const getImage = gtk_message_dialog_get_image;

    /// Returns the message area of the dialog. This is the box where the
    /// dialog’s primary and secondary labels are packed. You can add your
    /// own extra content to that box and it will appear below those labels.
    /// See `gtk.Dialog.getContentArea` for the corresponding
    /// function in the parent `gtk.Dialog`.
    extern fn gtk_message_dialog_get_message_area(p_message_dialog: *MessageDialog) *gtk.Widget;
    pub const getMessageArea = gtk_message_dialog_get_message_area;

    /// Sets the dialog’s image to `image`.
    extern fn gtk_message_dialog_set_image(p_dialog: *MessageDialog, p_image: *gtk.Widget) void;
    pub const setImage = gtk_message_dialog_set_image;

    /// Sets the text of the message dialog to be `str`, which is marked
    /// up with the [Pango text markup language][PangoMarkupFormat].
    extern fn gtk_message_dialog_set_markup(p_message_dialog: *MessageDialog, p_str: [*:0]const u8) void;
    pub const setMarkup = gtk_message_dialog_set_markup;

    extern fn gtk_message_dialog_get_type() usize;
    pub const getGObjectType = gtk_message_dialog_get_type;

    extern fn g_object_ref(p_self: *gtk.MessageDialog) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.MessageDialog) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MessageDialog, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Misc` widget is an abstract widget which is not useful itself, but
/// is used to derive subclasses which have alignment and padding attributes.
///
/// The horizontal and vertical padding attributes allows extra space to be
/// added around the widget.
///
/// The horizontal and vertical alignment attributes enable the widget to be
/// positioned within its allocated area. Note that if the widget is added to
/// a container in such a way that it expands automatically to fill its
/// allocated area, the alignment settings will not alter the widget's position.
///
/// Note that the desired effect can in most cases be achieved by using the
/// `gtk.Widget.properties.halign`, `gtk.Widget.properties.valign` and `gtk.Widget.properties.margin` properties
/// on the child widget, so GtkMisc should not be used in new code. To reflect
/// this fact, all `gtk.Misc` API has been deprecated.
pub const Misc = extern struct {
    pub const Parent = gtk.Widget;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.MiscClass;
    f_widget: gtk.Widget,
    f_priv: ?*gtk.MiscPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The horizontal alignment. A value of 0.0 means left alignment (or right
        /// on RTL locales); a value of 1.0 means right alignment (or left on RTL
        /// locales).
        pub const xalign = struct {
            pub const name = "xalign";

            pub const Type = f32;
        };

        /// The amount of space to add on the left and right of the widget, in
        /// pixels.
        pub const xpad = struct {
            pub const name = "xpad";

            pub const Type = c_int;
        };

        /// The vertical alignment. A value of 0.0 means top alignment;
        /// a value of 1.0 means bottom alignment.
        pub const yalign = struct {
            pub const name = "yalign";

            pub const Type = f32;
        };

        /// The amount of space to add on the top and bottom of the widget, in
        /// pixels.
        pub const ypad = struct {
            pub const name = "ypad";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Gets the X and Y alignment of the widget within its allocation.
    /// See `gtk.Misc.setAlignment`.
    extern fn gtk_misc_get_alignment(p_misc: *Misc, p_xalign: ?*f32, p_yalign: ?*f32) void;
    pub const getAlignment = gtk_misc_get_alignment;

    /// Gets the padding in the X and Y directions of the widget.
    /// See `gtk.Misc.setPadding`.
    extern fn gtk_misc_get_padding(p_misc: *Misc, p_xpad: ?*c_int, p_ypad: ?*c_int) void;
    pub const getPadding = gtk_misc_get_padding;

    /// Sets the alignment of the widget.
    extern fn gtk_misc_set_alignment(p_misc: *Misc, p_xalign: f32, p_yalign: f32) void;
    pub const setAlignment = gtk_misc_set_alignment;

    /// Sets the amount of space to add around the widget.
    extern fn gtk_misc_set_padding(p_misc: *Misc, p_xpad: c_int, p_ypad: c_int) void;
    pub const setPadding = gtk_misc_set_padding;

    extern fn gtk_misc_get_type() usize;
    pub const getGObjectType = gtk_misc_get_type;

    extern fn g_object_ref(p_self: *gtk.Misc) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Misc) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Misc, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkModelButton is a button class that can use a `gio.Action` as its model.
/// In contrast to `gtk.ToggleButton` or `gtk.RadioButton`, which can also
/// be backed by a `gio.Action` via the `gtk.Actionable.properties.action`-name property,
/// GtkModelButton will adapt its appearance according to the kind of
/// action it is backed by, and appear either as a plain, check or
/// radio button.
///
/// Model buttons are used when popovers from a menu model with
/// `gtk.Popover.newFromModel`; they can also be used manually in
/// a `gtk.PopoverMenu`.
///
/// When the action is specified via the `gtk.Actionable.properties.action`-name
/// and `gtk.Actionable.properties.action`-target properties, the role of the button
/// (i.e. whether it is a plain, check or radio button) is determined by
/// the type of the action and doesn't have to be explicitly specified
/// with the `gtk.ModelButton.properties.role` property.
///
/// The content of the button is specified by the `gtk.ModelButton.properties.text`
/// and `gtk.ModelButton.properties.icon` properties.
///
/// The appearance of model buttons can be influenced with the
/// `gtk.ModelButton.properties.centered` and `gtk.ModelButton.properties.iconic` properties.
///
/// Model buttons have built-in support for submenus in `gtk.PopoverMenu`.
/// To make a GtkModelButton that opens a submenu when activated, set
/// the `gtk.ModelButton.properties.menu`-name property. To make a button that goes
/// back to the parent menu, you should set the `gtk.ModelButton.properties.inverted`
/// property to place the submenu indicator at the opposite side.
///
/// # Example
///
/// ```
/// <object class="GtkPopoverMenu">
///   <child>
///     <object class="GtkBox">
///       <property name="visible">True</property>
///       <property name="margin">10</property>
///       <child>
///         <object class="GtkModelButton">
///           <property name="visible">True</property>
///           <property name="action-name">view.cut</property>
///           <property name="text" translatable="yes">Cut</property>
///         </object>
///       </child>
///       <child>
///         <object class="GtkModelButton">
///           <property name="visible">True</property>
///           <property name="action-name">view.copy</property>
///           <property name="text" translatable="yes">Copy</property>
///         </object>
///       </child>
///       <child>
///         <object class="GtkModelButton">
///           <property name="visible">True</property>
///           <property name="action-name">view.paste</property>
///           <property name="text" translatable="yes">Paste</property>
///         </object>
///       </child>
///     </object>
///   </child>
/// </object>
/// ```
///
/// # CSS nodes
///
/// ```
/// modelbutton
/// ├── <child>
/// ╰── check
/// ```
///
/// ```
/// modelbutton
/// ├── <child>
/// ╰── radio
/// ```
///
/// ```
/// modelbutton
/// ├── <child>
/// ╰── arrow
/// ```
///
/// GtkModelButton has a main CSS node with name modelbutton, and a subnode,
/// which will have the name check, radio or arrow, depending on the role
/// of the button and whether it has a menu name set.
///
/// The subnode is positioned before or after the content nodes and gets the
/// .left or .right style class, depending on where it is located.
///
/// ```
/// button.model
/// ├── <child>
/// ╰── check
/// ```
///
/// Iconic model buttons (see `gtk.ModelButton.properties.iconic`) change the name of
/// their main node to button and add a .model style class to it. The indicator
/// subnode is invisible in this case.
pub const ModelButton = opaque {
    pub const Parent = gtk.Button;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = opaque {
        pub const Instance = ModelButton;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The state of the button. This is reflecting the state of the associated
        /// `gio.Action`.
        pub const active = struct {
            pub const name = "active";

            pub const Type = c_int;
        };

        /// Whether to render the button contents centered instead of left-aligned.
        /// This property should be set for title-like items.
        pub const centered = struct {
            pub const name = "centered";

            pub const Type = c_int;
        };

        /// A `gio.Icon` that will be used if iconic appearance for the button is
        /// desired.
        pub const icon = struct {
            pub const name = "icon";

            pub const Type = ?*gio.Icon;
        };

        /// If this property is set, the button will show an icon if one is set.
        /// If no icon is set, the text will be used. This is typically used for
        /// horizontal sections of linked buttons.
        pub const iconic = struct {
            pub const name = "iconic";

            pub const Type = c_int;
        };

        /// Whether to show the submenu indicator at the opposite side than normal.
        /// This property should be set for model buttons that 'go back' to a parent
        /// menu.
        pub const inverted = struct {
            pub const name = "inverted";

            pub const Type = c_int;
        };

        /// The name of a submenu to open when the button is activated.
        /// If this is set, the button should not have an action associated with it.
        pub const menu_name = struct {
            pub const name = "menu-name";

            pub const Type = ?[*:0]u8;
        };

        /// Specifies whether the button is a plain, check or radio button.
        /// When `gtk.Actionable.properties.action`-name is set, the role will be determined
        /// from the action and does not have to be set explicitly.
        pub const role = struct {
            pub const name = "role";

            pub const Type = gtk.ButtonRole;
        };

        /// The label for the button.
        pub const text = struct {
            pub const name = "text";

            pub const Type = ?[*:0]u8;
        };

        /// If `TRUE`, XML tags in the text of the button are interpreted as by
        /// `pango.parseMarkup` to format the enclosed spans of text. If `FALSE`, the
        /// text will be displayed verbatim.
        pub const use_markup = struct {
            pub const name = "use-markup";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new GtkModelButton.
    extern fn gtk_model_button_new() *gtk.ModelButton;
    pub const new = gtk_model_button_new;

    extern fn gtk_model_button_get_type() usize;
    pub const getGObjectType = gtk_model_button_get_type;

    extern fn g_object_ref(p_self: *gtk.ModelButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ModelButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ModelButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// This should not be accessed directly. Use the accessor functions below.
pub const MountOperation = extern struct {
    pub const Parent = gio.MountOperation;
    pub const Implements = [_]type{};
    pub const Class = gtk.MountOperationClass;
    f_parent_instance: gio.MountOperation,
    f_priv: ?*gtk.MountOperationPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const is_showing = struct {
            pub const name = "is-showing";

            pub const Type = c_int;
        };

        pub const parent = struct {
            pub const name = "parent";

            pub const Type = ?*gtk.Window;
        };

        pub const screen = struct {
            pub const name = "screen";

            pub const Type = ?*gdk.Screen;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.MountOperation`
    extern fn gtk_mount_operation_new(p_parent: ?*gtk.Window) *gtk.MountOperation;
    pub const new = gtk_mount_operation_new;

    /// Gets the transient parent used by the `gtk.MountOperation`
    extern fn gtk_mount_operation_get_parent(p_op: *MountOperation) *gtk.Window;
    pub const getParent = gtk_mount_operation_get_parent;

    /// Gets the screen on which windows of the `gtk.MountOperation`
    /// will be shown.
    extern fn gtk_mount_operation_get_screen(p_op: *MountOperation) *gdk.Screen;
    pub const getScreen = gtk_mount_operation_get_screen;

    /// Returns whether the `gtk.MountOperation` is currently displaying
    /// a window.
    extern fn gtk_mount_operation_is_showing(p_op: *MountOperation) c_int;
    pub const isShowing = gtk_mount_operation_is_showing;

    /// Sets the transient parent for windows shown by the
    /// `gtk.MountOperation`.
    extern fn gtk_mount_operation_set_parent(p_op: *MountOperation, p_parent: ?*gtk.Window) void;
    pub const setParent = gtk_mount_operation_set_parent;

    /// Sets the screen to show windows of the `gtk.MountOperation` on.
    extern fn gtk_mount_operation_set_screen(p_op: *MountOperation, p_screen: *gdk.Screen) void;
    pub const setScreen = gtk_mount_operation_set_screen;

    extern fn gtk_mount_operation_get_type() usize;
    pub const getGObjectType = gtk_mount_operation_get_type;

    extern fn g_object_ref(p_self: *gtk.MountOperation) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.MountOperation) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MountOperation, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Native dialogs are platform dialogs that don't use `gtk.Dialog` or
/// `gtk.Window`. They are used in order to integrate better with a
/// platform, by looking the same as other native applications and
/// supporting platform specific features.
///
/// The `gtk.Dialog` functions cannot be used on such objects, but we
/// need a similar API in order to drive them. The `gtk.NativeDialog`
/// object is an API that allows you to do this. It allows you to set
/// various common properties on the dialog, as well as show and hide
/// it and get a `gtk.NativeDialog.signals.response` signal when the user finished
/// with the dialog.
///
/// There is also a `gtk.NativeDialog.run` helper that makes it easy
/// to run any native dialog in a modal way with a recursive mainloop,
/// similar to `gtk.Dialog.run`.
pub const NativeDialog = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.NativeDialogClass;
    f_parent_instance: gobject.Object,

    pub const virtual_methods = struct {
        /// Hides the dialog if it is visilbe, aborting any interaction. Once this
        /// is called the  `gtk.NativeDialog.signals.response` signal will not be emitted
        /// until after the next call to `gtk.NativeDialog.show`.
        ///
        /// If the dialog is not visible this does nothing.
        pub const hide = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(NativeDialog.Class, p_class).f_hide.?(gobject.ext.as(NativeDialog, p_self));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(NativeDialog.Class, p_class).f_hide = @ptrCast(p_implementation);
            }
        };

        pub const response = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_response_id: c_int) void {
                return gobject.ext.as(NativeDialog.Class, p_class).f_response.?(gobject.ext.as(NativeDialog, p_self), p_response_id);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_response_id: c_int) callconv(.c) void) void {
                gobject.ext.as(NativeDialog.Class, p_class).f_response = @ptrCast(p_implementation);
            }
        };

        /// Shows the dialog on the display, allowing the user to interact with
        /// it. When the user accepts the state of the dialog the dialog will
        /// be automatically hidden and the `gtk.NativeDialog.signals.response` signal
        /// will be emitted.
        ///
        /// Multiple calls while the dialog is visible will be ignored.
        pub const show = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(NativeDialog.Class, p_class).f_show.?(gobject.ext.as(NativeDialog, p_self));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(NativeDialog.Class, p_class).f_show = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Whether the window should be modal with respect to its transient parent.
        pub const modal = struct {
            pub const name = "modal";

            pub const Type = c_int;
        };

        /// The title of the dialog window
        pub const title = struct {
            pub const name = "title";

            pub const Type = ?[*:0]u8;
        };

        /// The transient parent of the dialog, or `NULL` for none.
        pub const transient_for = struct {
            pub const name = "transient-for";

            pub const Type = ?*gtk.Window;
        };

        /// Whether the window is currenlty visible.
        pub const visible = struct {
            pub const name = "visible";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted when the user responds to the dialog.
        ///
        /// When this is called the dialog has been hidden.
        ///
        /// If you call `gtk.NativeDialog.hide` before the user responds to
        /// the dialog this signal will not be emitted.
        pub const response = struct {
            pub const name = "response";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_response_id: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(NativeDialog, p_instance))),
                    gobject.signalLookup("response", NativeDialog.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Destroys a dialog.
    ///
    /// When a dialog is destroyed, it will break any references it holds
    /// to other objects. If it is visible it will be hidden and any underlying
    /// window system resources will be destroyed.
    ///
    /// Note that this does not release any reference to the object (as opposed to
    /// destroying a GtkWindow) because there is no reference from the windowing
    /// system to the `gtk.NativeDialog`.
    extern fn gtk_native_dialog_destroy(p_self: *NativeDialog) void;
    pub const destroy = gtk_native_dialog_destroy;

    /// Returns whether the dialog is modal. See `gtk.NativeDialog.setModal`.
    extern fn gtk_native_dialog_get_modal(p_self: *NativeDialog) c_int;
    pub const getModal = gtk_native_dialog_get_modal;

    /// Gets the title of the `gtk.NativeDialog`.
    extern fn gtk_native_dialog_get_title(p_self: *NativeDialog) ?[*:0]const u8;
    pub const getTitle = gtk_native_dialog_get_title;

    /// Fetches the transient parent for this window. See
    /// `gtk.NativeDialog.setTransientFor`.
    extern fn gtk_native_dialog_get_transient_for(p_self: *NativeDialog) ?*gtk.Window;
    pub const getTransientFor = gtk_native_dialog_get_transient_for;

    /// Determines whether the dialog is visible.
    extern fn gtk_native_dialog_get_visible(p_self: *NativeDialog) c_int;
    pub const getVisible = gtk_native_dialog_get_visible;

    /// Hides the dialog if it is visilbe, aborting any interaction. Once this
    /// is called the  `gtk.NativeDialog.signals.response` signal will not be emitted
    /// until after the next call to `gtk.NativeDialog.show`.
    ///
    /// If the dialog is not visible this does nothing.
    extern fn gtk_native_dialog_hide(p_self: *NativeDialog) void;
    pub const hide = gtk_native_dialog_hide;

    /// Blocks in a recursive main loop until `self` emits the
    /// `gtk.NativeDialog.signals.response` signal. It then returns the response ID
    /// from the ::response signal emission.
    ///
    /// Before entering the recursive main loop, `gtk.NativeDialog.run`
    /// calls `gtk.NativeDialog.show` on the dialog for you.
    ///
    /// After `gtk.NativeDialog.run` returns, then dialog will be hidden.
    ///
    /// Typical usage of this function might be:
    /// ```
    ///   gint result = gtk_native_dialog_run (GTK_NATIVE_DIALOG (dialog));
    ///   switch (result)
    ///     {
    ///       case GTK_RESPONSE_ACCEPT:
    ///          do_application_specific_something ();
    ///          break;
    ///       default:
    ///          do_nothing_since_dialog_was_cancelled ();
    ///          break;
    ///     }
    ///   g_object_unref (dialog);
    /// ```
    ///
    /// Note that even though the recursive main loop gives the effect of a
    /// modal dialog (it prevents the user from interacting with other
    /// windows in the same window group while the dialog is run), callbacks
    /// such as timeouts, IO channel watches, DND drops, etc, will
    /// be triggered during a `gtk.NativeDialog.run` call.
    extern fn gtk_native_dialog_run(p_self: *NativeDialog) c_int;
    pub const run = gtk_native_dialog_run;

    /// Sets a dialog modal or non-modal. Modal dialogs prevent interaction
    /// with other windows in the same application. To keep modal dialogs
    /// on top of main application windows, use
    /// `gtk.NativeDialog.setTransientFor` to make the dialog transient for the
    /// parent; most [window managers][gtk-X11-arch]
    /// will then disallow lowering the dialog below the parent.
    extern fn gtk_native_dialog_set_modal(p_self: *NativeDialog, p_modal: c_int) void;
    pub const setModal = gtk_native_dialog_set_modal;

    /// Sets the title of the `gtk.NativeDialog`.
    extern fn gtk_native_dialog_set_title(p_self: *NativeDialog, p_title: [*:0]const u8) void;
    pub const setTitle = gtk_native_dialog_set_title;

    /// Dialog windows should be set transient for the main application
    /// window they were spawned from. This allows
    /// [window managers][gtk-X11-arch] to e.g. keep the
    /// dialog on top of the main window, or center the dialog over the
    /// main window.
    ///
    /// Passing `NULL` for `parent` unsets the current transient window.
    extern fn gtk_native_dialog_set_transient_for(p_self: *NativeDialog, p_parent: ?*gtk.Window) void;
    pub const setTransientFor = gtk_native_dialog_set_transient_for;

    /// Shows the dialog on the display, allowing the user to interact with
    /// it. When the user accepts the state of the dialog the dialog will
    /// be automatically hidden and the `gtk.NativeDialog.signals.response` signal
    /// will be emitted.
    ///
    /// Multiple calls while the dialog is visible will be ignored.
    extern fn gtk_native_dialog_show(p_self: *NativeDialog) void;
    pub const show = gtk_native_dialog_show;

    extern fn gtk_native_dialog_get_type() usize;
    pub const getGObjectType = gtk_native_dialog_get_type;

    extern fn g_object_ref(p_self: *gtk.NativeDialog) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.NativeDialog) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *NativeDialog, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Notebook` widget is a `gtk.Container` whose children are pages that
/// can be switched between using tab labels along one edge.
///
/// There are many configuration options for GtkNotebook. Among other
/// things, you can choose on which edge the tabs appear
/// (see `gtk.Notebook.setTabPos`), whether, if there are too many
/// tabs to fit the notebook should be made bigger or scrolling
/// arrows added (see `gtk.Notebook.setScrollable`), and whether there
/// will be a popup menu allowing the users to switch pages.
/// (see `gtk.Notebook.popupEnable`, `gtk.Notebook.popupDisable`)
///
/// # GtkNotebook as GtkBuildable
///
/// The GtkNotebook implementation of the `gtk.Buildable` interface
/// supports placing children into tabs by specifying “tab” as the
/// “type” attribute of a `<child>` element. Note that the content
/// of the tab must be created before the tab can be filled.
/// A tab child can be specified without specifying a `<child>`
/// type attribute.
///
/// To add a child widget in the notebooks action area, specify
/// "action-start" or “action-end” as the “type” attribute of the
/// `<child>` element.
///
/// An example of a UI definition fragment with GtkNotebook:
///
/// ```
/// <object class="GtkNotebook">
///   <child>
///     <object class="GtkLabel" id="notebook-content">
///       <property name="label">Content</property>
///     </object>
///   </child>
///   <child type="tab">
///     <object class="GtkLabel" id="notebook-tab">
///       <property name="label">Tab</property>
///     </object>
///   </child>
/// </object>
/// ```
///
/// # CSS nodes
///
/// ```
/// notebook
/// ├── header.top
/// │   ├── [<action widget>]
/// │   ├── tabs
/// │   │   ├── [arrow]
/// │   │   ├── tab
/// │   │   │   ╰── <tab label>
/// ┊   ┊   ┊
/// │   │   ├── tab[.reorderable-page]
/// │   │   │   ╰── <tab label>
/// │   │   ╰── [arrow]
/// │   ╰── [<action widget>]
/// │
/// ╰── stack
///     ├── <child>
///     ┊
///     ╰── <child>
/// ```
///
/// GtkNotebook has a main CSS node with name notebook, a subnode
/// with name header and below that a subnode with name tabs which
/// contains one subnode per tab with name tab.
///
/// If action widgets are present, their CSS nodes are placed next
/// to the tabs node. If the notebook is scrollable, CSS nodes with
/// name arrow are placed as first and last child of the tabs node.
///
/// The main node gets the .frame style class when the notebook
/// has a border (see `gtk.Notebook.setShowBorder`).
///
/// The header node gets one of the style class .top, .bottom,
/// .left or .right, depending on where the tabs are placed. For
/// reorderable pages, the tab node gets the .reorderable-page class.
///
/// A tab node gets the .dnd style class while it is moved with drag-and-drop.
///
/// The nodes are always arranged from left-to-right, regarldess of text direction.
pub const Notebook = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.NotebookClass;
    f_container: gtk.Container,
    f_priv: ?*gtk.NotebookPrivate,

    pub const virtual_methods = struct {
        pub const change_current_page = struct {
            pub fn call(p_class: anytype, p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_offset: c_int) c_int {
                return gobject.ext.as(Notebook.Class, p_class).f_change_current_page.?(gobject.ext.as(Notebook, p_notebook), p_offset);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_offset: c_int) callconv(.c) c_int) void {
                gobject.ext.as(Notebook.Class, p_class).f_change_current_page = @ptrCast(p_implementation);
            }
        };

        pub const create_window = struct {
            pub fn call(p_class: anytype, p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_page: *gtk.Widget, p_x: c_int, p_y: c_int) *gtk.Notebook {
                return gobject.ext.as(Notebook.Class, p_class).f_create_window.?(gobject.ext.as(Notebook, p_notebook), p_page, p_x, p_y);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_page: *gtk.Widget, p_x: c_int, p_y: c_int) callconv(.c) *gtk.Notebook) void {
                gobject.ext.as(Notebook.Class, p_class).f_create_window = @ptrCast(p_implementation);
            }
        };

        pub const focus_tab = struct {
            pub fn call(p_class: anytype, p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_type: gtk.NotebookTab) c_int {
                return gobject.ext.as(Notebook.Class, p_class).f_focus_tab.?(gobject.ext.as(Notebook, p_notebook), p_type);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_type: gtk.NotebookTab) callconv(.c) c_int) void {
                gobject.ext.as(Notebook.Class, p_class).f_focus_tab = @ptrCast(p_implementation);
            }
        };

        pub const insert_page = struct {
            pub fn call(p_class: anytype, p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget, p_tab_label: *gtk.Widget, p_menu_label: *gtk.Widget, p_position: c_int) c_int {
                return gobject.ext.as(Notebook.Class, p_class).f_insert_page.?(gobject.ext.as(Notebook, p_notebook), p_child, p_tab_label, p_menu_label, p_position);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget, p_tab_label: *gtk.Widget, p_menu_label: *gtk.Widget, p_position: c_int) callconv(.c) c_int) void {
                gobject.ext.as(Notebook.Class, p_class).f_insert_page = @ptrCast(p_implementation);
            }
        };

        pub const move_focus_out = struct {
            pub fn call(p_class: anytype, p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.DirectionType) void {
                return gobject.ext.as(Notebook.Class, p_class).f_move_focus_out.?(gobject.ext.as(Notebook, p_notebook), p_direction);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.DirectionType) callconv(.c) void) void {
                gobject.ext.as(Notebook.Class, p_class).f_move_focus_out = @ptrCast(p_implementation);
            }
        };

        pub const page_added = struct {
            pub fn call(p_class: anytype, p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget, p_page_num: c_uint) void {
                return gobject.ext.as(Notebook.Class, p_class).f_page_added.?(gobject.ext.as(Notebook, p_notebook), p_child, p_page_num);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget, p_page_num: c_uint) callconv(.c) void) void {
                gobject.ext.as(Notebook.Class, p_class).f_page_added = @ptrCast(p_implementation);
            }
        };

        pub const page_removed = struct {
            pub fn call(p_class: anytype, p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget, p_page_num: c_uint) void {
                return gobject.ext.as(Notebook.Class, p_class).f_page_removed.?(gobject.ext.as(Notebook, p_notebook), p_child, p_page_num);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget, p_page_num: c_uint) callconv(.c) void) void {
                gobject.ext.as(Notebook.Class, p_class).f_page_removed = @ptrCast(p_implementation);
            }
        };

        pub const page_reordered = struct {
            pub fn call(p_class: anytype, p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget, p_page_num: c_uint) void {
                return gobject.ext.as(Notebook.Class, p_class).f_page_reordered.?(gobject.ext.as(Notebook, p_notebook), p_child, p_page_num);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child: *gtk.Widget, p_page_num: c_uint) callconv(.c) void) void {
                gobject.ext.as(Notebook.Class, p_class).f_page_reordered = @ptrCast(p_implementation);
            }
        };

        pub const reorder_tab = struct {
            pub fn call(p_class: anytype, p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.DirectionType, p_move_to_last: c_int) c_int {
                return gobject.ext.as(Notebook.Class, p_class).f_reorder_tab.?(gobject.ext.as(Notebook, p_notebook), p_direction, p_move_to_last);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.DirectionType, p_move_to_last: c_int) callconv(.c) c_int) void {
                gobject.ext.as(Notebook.Class, p_class).f_reorder_tab = @ptrCast(p_implementation);
            }
        };

        pub const select_page = struct {
            pub fn call(p_class: anytype, p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_move_focus: c_int) c_int {
                return gobject.ext.as(Notebook.Class, p_class).f_select_page.?(gobject.ext.as(Notebook, p_notebook), p_move_focus);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_move_focus: c_int) callconv(.c) c_int) void {
                gobject.ext.as(Notebook.Class, p_class).f_select_page = @ptrCast(p_implementation);
            }
        };

        pub const switch_page = struct {
            pub fn call(p_class: anytype, p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_page: *gtk.Widget, p_page_num: c_uint) void {
                return gobject.ext.as(Notebook.Class, p_class).f_switch_page.?(gobject.ext.as(Notebook, p_notebook), p_page, p_page_num);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_notebook: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_page: *gtk.Widget, p_page_num: c_uint) callconv(.c) void) void {
                gobject.ext.as(Notebook.Class, p_class).f_switch_page = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const enable_popup = struct {
            pub const name = "enable-popup";

            pub const Type = c_int;
        };

        /// Group name for tab drag and drop.
        pub const group_name = struct {
            pub const name = "group-name";

            pub const Type = ?[*:0]u8;
        };

        pub const page = struct {
            pub const name = "page";

            pub const Type = c_int;
        };

        pub const scrollable = struct {
            pub const name = "scrollable";

            pub const Type = c_int;
        };

        pub const show_border = struct {
            pub const name = "show-border";

            pub const Type = c_int;
        };

        pub const show_tabs = struct {
            pub const name = "show-tabs";

            pub const Type = c_int;
        };

        pub const tab_pos = struct {
            pub const name = "tab-pos";

            pub const Type = gtk.PositionType;
        };
    };

    pub const signals = struct {
        pub const change_current_page = struct {
            pub const name = "change-current-page";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Notebook, p_instance))),
                    gobject.signalLookup("change-current-page", Notebook.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::create-window signal is emitted when a detachable
        /// tab is dropped on the root window.
        ///
        /// A handler for this signal can create a window containing
        /// a notebook where the tab will be attached. It is also
        /// responsible for moving/resizing the window and adding the
        /// necessary properties to the notebook (e.g. the
        /// `gtk.Notebook.properties.group`-name ).
        pub const create_window = struct {
            pub const name = "create-window";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_page: *gtk.Widget, p_x: c_int, p_y: c_int, P_Data) callconv(.c) *gtk.Notebook, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Notebook, p_instance))),
                    gobject.signalLookup("create-window", Notebook.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const focus_tab = struct {
            pub const name = "focus-tab";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: gtk.NotebookTab, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Notebook, p_instance))),
                    gobject.signalLookup("focus-tab", Notebook.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const move_focus_out = struct {
            pub const name = "move-focus-out";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: gtk.DirectionType, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Notebook, p_instance))),
                    gobject.signalLookup("move-focus-out", Notebook.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// the ::page-added signal is emitted in the notebook
        /// right after a page is added to the notebook.
        pub const page_added = struct {
            pub const name = "page-added";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_child: *gtk.Widget, p_page_num: c_uint, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Notebook, p_instance))),
                    gobject.signalLookup("page-added", Notebook.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// the ::page-removed signal is emitted in the notebook
        /// right after a page is removed from the notebook.
        pub const page_removed = struct {
            pub const name = "page-removed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_child: *gtk.Widget, p_page_num: c_uint, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Notebook, p_instance))),
                    gobject.signalLookup("page-removed", Notebook.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// the ::page-reordered signal is emitted in the notebook
        /// right after a page has been reordered.
        pub const page_reordered = struct {
            pub const name = "page-reordered";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_child: *gtk.Widget, p_page_num: c_uint, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Notebook, p_instance))),
                    gobject.signalLookup("page-reordered", Notebook.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const reorder_tab = struct {
            pub const name = "reorder-tab";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: gtk.DirectionType, p_p0: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Notebook, p_instance))),
                    gobject.signalLookup("reorder-tab", Notebook.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const select_page = struct {
            pub const name = "select-page";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Notebook, p_instance))),
                    gobject.signalLookup("select-page", Notebook.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the user or a function changes the current page.
        pub const switch_page = struct {
            pub const name = "switch-page";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_page: *gtk.Widget, p_page_num: c_uint, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Notebook, p_instance))),
                    gobject.signalLookup("switch-page", Notebook.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.Notebook` widget with no pages.
    extern fn gtk_notebook_new() *gtk.Notebook;
    pub const new = gtk_notebook_new;

    /// Appends a page to `notebook`.
    extern fn gtk_notebook_append_page(p_notebook: *Notebook, p_child: *gtk.Widget, p_tab_label: ?*gtk.Widget) c_int;
    pub const appendPage = gtk_notebook_append_page;

    /// Appends a page to `notebook`, specifying the widget to use as the
    /// label in the popup menu.
    extern fn gtk_notebook_append_page_menu(p_notebook: *Notebook, p_child: *gtk.Widget, p_tab_label: ?*gtk.Widget, p_menu_label: ?*gtk.Widget) c_int;
    pub const appendPageMenu = gtk_notebook_append_page_menu;

    /// Removes the child from the notebook.
    ///
    /// This function is very similar to `gtk.Container.remove`,
    /// but additionally informs the notebook that the removal
    /// is happening as part of a tab DND operation, which should
    /// not be cancelled.
    extern fn gtk_notebook_detach_tab(p_notebook: *Notebook, p_child: *gtk.Widget) void;
    pub const detachTab = gtk_notebook_detach_tab;

    /// Gets one of the action widgets. See `gtk.Notebook.setActionWidget`.
    extern fn gtk_notebook_get_action_widget(p_notebook: *Notebook, p_pack_type: gtk.PackType) ?*gtk.Widget;
    pub const getActionWidget = gtk_notebook_get_action_widget;

    /// Returns the page number of the current page.
    extern fn gtk_notebook_get_current_page(p_notebook: *Notebook) c_int;
    pub const getCurrentPage = gtk_notebook_get_current_page;

    /// Gets the current group name for `notebook`.
    extern fn gtk_notebook_get_group_name(p_notebook: *Notebook) ?[*:0]const u8;
    pub const getGroupName = gtk_notebook_get_group_name;

    /// Retrieves the menu label widget of the page containing `child`.
    extern fn gtk_notebook_get_menu_label(p_notebook: *Notebook, p_child: *gtk.Widget) ?*gtk.Widget;
    pub const getMenuLabel = gtk_notebook_get_menu_label;

    /// Retrieves the text of the menu label for the page containing
    /// `child`.
    extern fn gtk_notebook_get_menu_label_text(p_notebook: *Notebook, p_child: *gtk.Widget) ?[*:0]const u8;
    pub const getMenuLabelText = gtk_notebook_get_menu_label_text;

    /// Gets the number of pages in a notebook.
    extern fn gtk_notebook_get_n_pages(p_notebook: *Notebook) c_int;
    pub const getNPages = gtk_notebook_get_n_pages;

    /// Returns the child widget contained in page number `page_num`.
    extern fn gtk_notebook_get_nth_page(p_notebook: *Notebook, p_page_num: c_int) ?*gtk.Widget;
    pub const getNthPage = gtk_notebook_get_nth_page;

    /// Returns whether the tab label area has arrows for scrolling.
    /// See `gtk.Notebook.setScrollable`.
    extern fn gtk_notebook_get_scrollable(p_notebook: *Notebook) c_int;
    pub const getScrollable = gtk_notebook_get_scrollable;

    /// Returns whether a bevel will be drawn around the notebook pages.
    /// See `gtk.Notebook.setShowBorder`.
    extern fn gtk_notebook_get_show_border(p_notebook: *Notebook) c_int;
    pub const getShowBorder = gtk_notebook_get_show_border;

    /// Returns whether the tabs of the notebook are shown.
    /// See `gtk.Notebook.setShowTabs`.
    extern fn gtk_notebook_get_show_tabs(p_notebook: *Notebook) c_int;
    pub const getShowTabs = gtk_notebook_get_show_tabs;

    /// Returns whether the tab contents can be detached from `notebook`.
    extern fn gtk_notebook_get_tab_detachable(p_notebook: *Notebook, p_child: *gtk.Widget) c_int;
    pub const getTabDetachable = gtk_notebook_get_tab_detachable;

    /// Returns the horizontal width of a tab border.
    extern fn gtk_notebook_get_tab_hborder(p_notebook: *Notebook) u16;
    pub const getTabHborder = gtk_notebook_get_tab_hborder;

    /// Returns the tab label widget for the page `child`.
    /// `NULL` is returned if `child` is not in `notebook` or
    /// if no tab label has specifically been set for `child`.
    extern fn gtk_notebook_get_tab_label(p_notebook: *Notebook, p_child: *gtk.Widget) ?*gtk.Widget;
    pub const getTabLabel = gtk_notebook_get_tab_label;

    /// Retrieves the text of the tab label for the page containing
    /// `child`.
    extern fn gtk_notebook_get_tab_label_text(p_notebook: *Notebook, p_child: *gtk.Widget) ?[*:0]const u8;
    pub const getTabLabelText = gtk_notebook_get_tab_label_text;

    /// Gets the edge at which the tabs for switching pages in the
    /// notebook are drawn.
    extern fn gtk_notebook_get_tab_pos(p_notebook: *Notebook) gtk.PositionType;
    pub const getTabPos = gtk_notebook_get_tab_pos;

    /// Gets whether the tab can be reordered via drag and drop or not.
    extern fn gtk_notebook_get_tab_reorderable(p_notebook: *Notebook, p_child: *gtk.Widget) c_int;
    pub const getTabReorderable = gtk_notebook_get_tab_reorderable;

    /// Returns the vertical width of a tab border.
    extern fn gtk_notebook_get_tab_vborder(p_notebook: *Notebook) u16;
    pub const getTabVborder = gtk_notebook_get_tab_vborder;

    /// Insert a page into `notebook` at the given position.
    extern fn gtk_notebook_insert_page(p_notebook: *Notebook, p_child: *gtk.Widget, p_tab_label: ?*gtk.Widget, p_position: c_int) c_int;
    pub const insertPage = gtk_notebook_insert_page;

    /// Insert a page into `notebook` at the given position, specifying
    /// the widget to use as the label in the popup menu.
    extern fn gtk_notebook_insert_page_menu(p_notebook: *Notebook, p_child: *gtk.Widget, p_tab_label: ?*gtk.Widget, p_menu_label: ?*gtk.Widget, p_position: c_int) c_int;
    pub const insertPageMenu = gtk_notebook_insert_page_menu;

    /// Switches to the next page. Nothing happens if the current page is
    /// the last page.
    extern fn gtk_notebook_next_page(p_notebook: *Notebook) void;
    pub const nextPage = gtk_notebook_next_page;

    /// Finds the index of the page which contains the given child
    /// widget.
    extern fn gtk_notebook_page_num(p_notebook: *Notebook, p_child: *gtk.Widget) c_int;
    pub const pageNum = gtk_notebook_page_num;

    /// Disables the popup menu.
    extern fn gtk_notebook_popup_disable(p_notebook: *Notebook) void;
    pub const popupDisable = gtk_notebook_popup_disable;

    /// Enables the popup menu: if the user clicks with the right
    /// mouse button on the tab labels, a menu with all the pages
    /// will be popped up.
    extern fn gtk_notebook_popup_enable(p_notebook: *Notebook) void;
    pub const popupEnable = gtk_notebook_popup_enable;

    /// Prepends a page to `notebook`.
    extern fn gtk_notebook_prepend_page(p_notebook: *Notebook, p_child: *gtk.Widget, p_tab_label: ?*gtk.Widget) c_int;
    pub const prependPage = gtk_notebook_prepend_page;

    /// Prepends a page to `notebook`, specifying the widget to use as the
    /// label in the popup menu.
    extern fn gtk_notebook_prepend_page_menu(p_notebook: *Notebook, p_child: *gtk.Widget, p_tab_label: ?*gtk.Widget, p_menu_label: ?*gtk.Widget) c_int;
    pub const prependPageMenu = gtk_notebook_prepend_page_menu;

    /// Switches to the previous page. Nothing happens if the current page
    /// is the first page.
    extern fn gtk_notebook_prev_page(p_notebook: *Notebook) void;
    pub const prevPage = gtk_notebook_prev_page;

    /// Removes a page from the notebook given its index
    /// in the notebook.
    extern fn gtk_notebook_remove_page(p_notebook: *Notebook, p_page_num: c_int) void;
    pub const removePage = gtk_notebook_remove_page;

    /// Reorders the page containing `child`, so that it appears in position
    /// `position`. If `position` is greater than or equal to the number of
    /// children in the list or negative, `child` will be moved to the end
    /// of the list.
    extern fn gtk_notebook_reorder_child(p_notebook: *Notebook, p_child: *gtk.Widget, p_position: c_int) void;
    pub const reorderChild = gtk_notebook_reorder_child;

    /// Sets `widget` as one of the action widgets. Depending on the pack type
    /// the widget will be placed before or after the tabs. You can use
    /// a `gtk.Box` if you need to pack more than one widget on the same side.
    ///
    /// Note that action widgets are “internal” children of the notebook and thus
    /// not included in the list returned from `gtk.Container.foreach`.
    extern fn gtk_notebook_set_action_widget(p_notebook: *Notebook, p_widget: *gtk.Widget, p_pack_type: gtk.PackType) void;
    pub const setActionWidget = gtk_notebook_set_action_widget;

    /// Switches to the page number `page_num`.
    ///
    /// Note that due to historical reasons, GtkNotebook refuses
    /// to switch to a page unless the child widget is visible.
    /// Therefore, it is recommended to show child widgets before
    /// adding them to a notebook.
    extern fn gtk_notebook_set_current_page(p_notebook: *Notebook, p_page_num: c_int) void;
    pub const setCurrentPage = gtk_notebook_set_current_page;

    /// Sets a group name for `notebook`.
    ///
    /// Notebooks with the same name will be able to exchange tabs
    /// via drag and drop. A notebook with a `NULL` group name will
    /// not be able to exchange tabs with any other notebook.
    extern fn gtk_notebook_set_group_name(p_notebook: *Notebook, p_group_name: ?[*:0]const u8) void;
    pub const setGroupName = gtk_notebook_set_group_name;

    /// Changes the menu label for the page containing `child`.
    extern fn gtk_notebook_set_menu_label(p_notebook: *Notebook, p_child: *gtk.Widget, p_menu_label: ?*gtk.Widget) void;
    pub const setMenuLabel = gtk_notebook_set_menu_label;

    /// Creates a new label and sets it as the menu label of `child`.
    extern fn gtk_notebook_set_menu_label_text(p_notebook: *Notebook, p_child: *gtk.Widget, p_menu_text: [*:0]const u8) void;
    pub const setMenuLabelText = gtk_notebook_set_menu_label_text;

    /// Sets whether the tab label area will have arrows for
    /// scrolling if there are too many tabs to fit in the area.
    extern fn gtk_notebook_set_scrollable(p_notebook: *Notebook, p_scrollable: c_int) void;
    pub const setScrollable = gtk_notebook_set_scrollable;

    /// Sets whether a bevel will be drawn around the notebook pages.
    /// This only has a visual effect when the tabs are not shown.
    /// See `gtk.Notebook.setShowTabs`.
    extern fn gtk_notebook_set_show_border(p_notebook: *Notebook, p_show_border: c_int) void;
    pub const setShowBorder = gtk_notebook_set_show_border;

    /// Sets whether to show the tabs for the notebook or not.
    extern fn gtk_notebook_set_show_tabs(p_notebook: *Notebook, p_show_tabs: c_int) void;
    pub const setShowTabs = gtk_notebook_set_show_tabs;

    /// Sets whether the tab can be detached from `notebook` to another
    /// notebook or widget.
    ///
    /// Note that 2 notebooks must share a common group identificator
    /// (see `gtk.Notebook.setGroupName`) to allow automatic tabs
    /// interchange between them.
    ///
    /// If you want a widget to interact with a notebook through DnD
    /// (i.e.: accept dragged tabs from it) it must be set as a drop
    /// destination and accept the target “GTK_NOTEBOOK_TAB”. The notebook
    /// will fill the selection with a GtkWidget** pointing to the child
    /// widget that corresponds to the dropped tab.
    ///
    /// Note that you should use `gtk.Notebook.detachTab` instead
    /// of `gtk.Container.remove` if you want to remove the tab from
    /// the source notebook as part of accepting a drop. Otherwise,
    /// the source notebook will think that the dragged tab was
    /// removed from underneath the ongoing drag operation, and
    /// will initiate a drag cancel animation.
    ///
    /// ```
    ///  static void
    ///  on_drag_data_received (GtkWidget        *widget,
    ///                         GdkDragContext   *context,
    ///                         gint              x,
    ///                         gint              y,
    ///                         GtkSelectionData *data,
    ///                         guint             info,
    ///                         guint             time,
    ///                         gpointer          user_data)
    ///  {
    ///    GtkWidget *notebook;
    ///    GtkWidget **child;
    ///
    ///    notebook = gtk_drag_get_source_widget (context);
    ///    child = (void*) gtk_selection_data_get_data (data);
    ///
    ///    // process_widget (*child);
    ///
    ///    gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
    ///  }
    /// ```
    ///
    /// If you want a notebook to accept drags from other widgets,
    /// you will have to set your own DnD code to do it.
    extern fn gtk_notebook_set_tab_detachable(p_notebook: *Notebook, p_child: *gtk.Widget, p_detachable: c_int) void;
    pub const setTabDetachable = gtk_notebook_set_tab_detachable;

    /// Changes the tab label for `child`.
    /// If `NULL` is specified for `tab_label`, then the page will
    /// have the label “page N”.
    extern fn gtk_notebook_set_tab_label(p_notebook: *Notebook, p_child: *gtk.Widget, p_tab_label: ?*gtk.Widget) void;
    pub const setTabLabel = gtk_notebook_set_tab_label;

    /// Creates a new label and sets it as the tab label for the page
    /// containing `child`.
    extern fn gtk_notebook_set_tab_label_text(p_notebook: *Notebook, p_child: *gtk.Widget, p_tab_text: [*:0]const u8) void;
    pub const setTabLabelText = gtk_notebook_set_tab_label_text;

    /// Sets the edge at which the tabs for switching pages in the
    /// notebook are drawn.
    extern fn gtk_notebook_set_tab_pos(p_notebook: *Notebook, p_pos: gtk.PositionType) void;
    pub const setTabPos = gtk_notebook_set_tab_pos;

    /// Sets whether the notebook tab can be reordered
    /// via drag and drop or not.
    extern fn gtk_notebook_set_tab_reorderable(p_notebook: *Notebook, p_child: *gtk.Widget, p_reorderable: c_int) void;
    pub const setTabReorderable = gtk_notebook_set_tab_reorderable;

    extern fn gtk_notebook_get_type() usize;
    pub const getGObjectType = gtk_notebook_get_type;

    extern fn g_object_ref(p_self: *gtk.Notebook) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Notebook) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Notebook, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NotebookAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Selection };
    pub const Class = gtk.NotebookAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.NotebookAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_notebook_accessible_get_type() usize;
    pub const getGObjectType = gtk_notebook_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.NotebookAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.NotebookAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *NotebookAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NotebookPageAccessible = extern struct {
    pub const Parent = atk.Object;
    pub const Implements = [_]type{atk.Component};
    pub const Class = gtk.NotebookPageAccessibleClass;
    f_parent: atk.Object,
    f_priv: ?*gtk.NotebookPageAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_notebook_page_accessible_new(p_notebook: *gtk.NotebookAccessible, p_child: *gtk.Widget) *gtk.NotebookPageAccessible;
    pub const new = gtk_notebook_page_accessible_new;

    extern fn gtk_notebook_page_accessible_invalidate(p_page: *NotebookPageAccessible) void;
    pub const invalidate = gtk_notebook_page_accessible_invalidate;

    extern fn gtk_notebook_page_accessible_get_type() usize;
    pub const getGObjectType = gtk_notebook_page_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.NotebookPageAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.NotebookPageAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *NotebookPageAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkNumerableIcon is a subclass of `gio.EmblemedIcon` that can
/// show a number or short string as an emblem. The number can
/// be overlayed on top of another emblem, if desired.
///
/// It supports theming by taking font and color information
/// from a provided `gtk.StyleContext`; see
/// `gtk.NumerableIcon.setStyleContext`.
///
/// Typical numerable icons:
/// ![](numerableicon.png)
/// ![](numerableicon2.png)
pub const NumerableIcon = extern struct {
    pub const Parent = gio.EmblemedIcon;
    pub const Implements = [_]type{gio.Icon};
    pub const Class = gtk.NumerableIconClass;
    f_parent: gio.EmblemedIcon,
    f_priv: ?*gtk.NumerableIconPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const background_icon = struct {
            pub const name = "background-icon";

            pub const Type = ?*gio.Icon;
        };

        pub const background_icon_name = struct {
            pub const name = "background-icon-name";

            pub const Type = ?[*:0]u8;
        };

        pub const count = struct {
            pub const name = "count";

            pub const Type = c_int;
        };

        pub const label = struct {
            pub const name = "label";

            pub const Type = ?[*:0]u8;
        };

        pub const style_context = struct {
            pub const name = "style-context";

            pub const Type = ?*gtk.StyleContext;
        };
    };

    pub const signals = struct {};

    /// Creates a new unthemed `gtk.NumerableIcon`.
    extern fn gtk_numerable_icon_new(p_base_icon: *gio.Icon) *gio.Icon;
    pub const new = gtk_numerable_icon_new;

    /// Creates a new `gtk.NumerableIcon` which will themed according
    /// to the passed `gtk.StyleContext`. This is a convenience constructor
    /// that calls `gtk.NumerableIcon.setStyleContext` internally.
    extern fn gtk_numerable_icon_new_with_style_context(p_base_icon: *gio.Icon, p_context: *gtk.StyleContext) *gio.Icon;
    pub const newWithStyleContext = gtk_numerable_icon_new_with_style_context;

    /// Returns the `gio.Icon` that was set as the base background image, or
    /// `NULL` if there’s none. The caller of this function does not own
    /// a reference to the returned `gio.Icon`.
    extern fn gtk_numerable_icon_get_background_gicon(p_self: *NumerableIcon) ?*gio.Icon;
    pub const getBackgroundGicon = gtk_numerable_icon_get_background_gicon;

    /// Returns the icon name used as the base background image,
    /// or `NULL` if there’s none.
    extern fn gtk_numerable_icon_get_background_icon_name(p_self: *NumerableIcon) ?[*:0]const u8;
    pub const getBackgroundIconName = gtk_numerable_icon_get_background_icon_name;

    /// Returns the value currently displayed by `self`.
    extern fn gtk_numerable_icon_get_count(p_self: *NumerableIcon) c_int;
    pub const getCount = gtk_numerable_icon_get_count;

    /// Returns the currently displayed label of the icon, or `NULL`.
    extern fn gtk_numerable_icon_get_label(p_self: *NumerableIcon) ?[*:0]const u8;
    pub const getLabel = gtk_numerable_icon_get_label;

    /// Returns the `gtk.StyleContext` used by the icon for theming,
    /// or `NULL` if there’s none.
    extern fn gtk_numerable_icon_get_style_context(p_self: *NumerableIcon) ?*gtk.StyleContext;
    pub const getStyleContext = gtk_numerable_icon_get_style_context;

    /// Updates the icon to use `icon` as the base background image.
    /// If `icon` is `NULL`, `self` will go back using style information
    /// or default theming for its background image.
    ///
    /// If this method is called and an icon name was already set as
    /// background for the icon, `icon` will be used, i.e. the last method
    /// called between `gtk.NumerableIcon.setBackgroundGicon` and
    /// `gtk.NumerableIcon.setBackgroundIconName` has always priority.
    extern fn gtk_numerable_icon_set_background_gicon(p_self: *NumerableIcon, p_icon: ?*gio.Icon) void;
    pub const setBackgroundGicon = gtk_numerable_icon_set_background_gicon;

    /// Updates the icon to use the icon named `icon_name` from the
    /// current icon theme as the base background image. If `icon_name`
    /// is `NULL`, `self` will go back using style information or default
    /// theming for its background image.
    ///
    /// If this method is called and a `gio.Icon` was already set as
    /// background for the icon, `icon_name` will be used, i.e. the
    /// last method called between `gtk.NumerableIcon.setBackgroundIconName`
    /// and `gtk.NumerableIcon.setBackgroundGicon` has always priority.
    extern fn gtk_numerable_icon_set_background_icon_name(p_self: *NumerableIcon, p_icon_name: ?[*:0]const u8) void;
    pub const setBackgroundIconName = gtk_numerable_icon_set_background_icon_name;

    /// Sets the currently displayed value of `self` to `count`.
    ///
    /// The numeric value is always clamped to make it two digits, i.e.
    /// between -99 and 99. Setting a count of zero removes the emblem.
    /// If this method is called, and a label was already set on the icon,
    /// it will automatically be reset to `NULL` before rendering the number,
    /// i.e. the last method called between `gtk.NumerableIcon.setCount`
    /// and `gtk.NumerableIcon.setLabel` has always priority.
    extern fn gtk_numerable_icon_set_count(p_self: *NumerableIcon, p_count: c_int) void;
    pub const setCount = gtk_numerable_icon_set_count;

    /// Sets the currently displayed value of `self` to the string
    /// in `label`. Setting an empty label removes the emblem.
    ///
    /// Note that this is meant for displaying short labels, such as
    /// roman numbers, or single letters. For roman numbers, consider
    /// using the Unicode characters U+2160 - U+217F. Strings longer
    /// than two characters will likely not be rendered very well.
    ///
    /// If this method is called, and a number was already set on the
    /// icon, it will automatically be reset to zero before rendering
    /// the label, i.e. the last method called between
    /// `gtk.NumerableIcon.setLabel` and `gtk.NumerableIcon.setCount`
    /// has always priority.
    extern fn gtk_numerable_icon_set_label(p_self: *NumerableIcon, p_label: ?[*:0]const u8) void;
    pub const setLabel = gtk_numerable_icon_set_label;

    /// Updates the icon to fetch theme information from the
    /// given `gtk.StyleContext`.
    extern fn gtk_numerable_icon_set_style_context(p_self: *NumerableIcon, p_style: *gtk.StyleContext) void;
    pub const setStyleContext = gtk_numerable_icon_set_style_context;

    extern fn gtk_numerable_icon_get_type() usize;
    pub const getGObjectType = gtk_numerable_icon_get_type;

    extern fn g_object_ref(p_self: *gtk.NumerableIcon) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.NumerableIcon) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *NumerableIcon, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkOffscreenWindow is strictly intended to be used for obtaining
/// snapshots of widgets that are not part of a normal widget hierarchy.
/// Since `gtk.OffscreenWindow` is a toplevel widget you cannot obtain
/// snapshots of a full window with it since you cannot pack a toplevel
/// widget in another toplevel.
///
/// The idea is to take a widget and manually set the state of it,
/// add it to a GtkOffscreenWindow and then retrieve the snapshot
/// as a `cairo.Surface` or `gdkpixbuf.Pixbuf`.
///
/// GtkOffscreenWindow derives from `gtk.Window` only as an implementation
/// detail.  Applications should not use any API specific to `gtk.Window`
/// to operate on this object.  It should be treated as a `gtk.Bin` that
/// has no parent widget.
///
/// When contained offscreen widgets are redrawn, GtkOffscreenWindow
/// will emit a `gtk.Widget.signals.damage`-event signal.
pub const OffscreenWindow = extern struct {
    pub const Parent = gtk.Window;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.OffscreenWindowClass;
    f_parent_object: gtk.Window,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a toplevel container widget that is used to retrieve
    /// snapshots of widgets without showing them on the screen.
    extern fn gtk_offscreen_window_new() *gtk.OffscreenWindow;
    pub const new = gtk_offscreen_window_new;

    /// Retrieves a snapshot of the contained widget in the form of
    /// a `gdkpixbuf.Pixbuf`.  This is a new pixbuf with a reference count of 1,
    /// and the application should unreference it once it is no longer
    /// needed.
    extern fn gtk_offscreen_window_get_pixbuf(p_offscreen: *OffscreenWindow) ?*gdkpixbuf.Pixbuf;
    pub const getPixbuf = gtk_offscreen_window_get_pixbuf;

    /// Retrieves a snapshot of the contained widget in the form of
    /// a `cairo.Surface`.  If you need to keep this around over window
    /// resizes then you should add a reference to it.
    extern fn gtk_offscreen_window_get_surface(p_offscreen: *OffscreenWindow) ?*cairo.Surface;
    pub const getSurface = gtk_offscreen_window_get_surface;

    extern fn gtk_offscreen_window_get_type() usize;
    pub const getGObjectType = gtk_offscreen_window_get_type;

    extern fn g_object_ref(p_self: *gtk.OffscreenWindow) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.OffscreenWindow) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *OffscreenWindow, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkOverlay is a container which contains a single main child, on top
/// of which it can place “overlay” widgets. The position of each overlay
/// widget is determined by its `gtk.Widget.properties.halign` and `gtk.Widget.properties.valign`
/// properties. E.g. a widget with both alignments set to `GTK_ALIGN_START`
/// will be placed at the top left corner of the GtkOverlay container,
/// whereas an overlay with halign set to `GTK_ALIGN_CENTER` and valign set
/// to `GTK_ALIGN_END` will be placed a the bottom edge of the GtkOverlay,
/// horizontally centered. The position can be adjusted by setting the margin
/// properties of the child to non-zero values.
///
/// More complicated placement of overlays is possible by connecting
/// to the `gtk.Overlay.signals.get`-child-position signal.
///
/// An overlay’s minimum and natural sizes are those of its main child. The sizes
/// of overlay children are not considered when measuring these preferred sizes.
///
/// # GtkOverlay as GtkBuildable
///
/// The GtkOverlay implementation of the GtkBuildable interface
/// supports placing a child as an overlay by specifying “overlay” as
/// the “type” attribute of a `<child>` element.
///
/// # CSS nodes
///
/// GtkOverlay has a single CSS node with the name “overlay”. Overlay children
/// whose alignments cause them to be positioned at an edge get the style classes
/// “.left”, “.right”, “.top”, and/or “.bottom” according to their position.
pub const Overlay = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.OverlayClass;
    f_parent: gtk.Bin,
    f_priv: ?*gtk.OverlayPrivate,

    pub const virtual_methods = struct {
        /// Signal emitted to determine the position and
        ///    size of any overlay child widgets.
        pub const get_child_position = struct {
            pub fn call(p_class: anytype, p_overlay: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_allocation: *gtk.Allocation) c_int {
                return gobject.ext.as(Overlay.Class, p_class).f_get_child_position.?(gobject.ext.as(Overlay, p_overlay), p_widget, p_allocation);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_overlay: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_allocation: *gtk.Allocation) callconv(.c) c_int) void {
                gobject.ext.as(Overlay.Class, p_class).f_get_child_position = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// The ::get-child-position signal is emitted to determine
        /// the position and size of any overlay child widgets. A
        /// handler for this signal should fill `allocation` with
        /// the desired position and size for `widget`, relative to
        /// the 'main' child of `overlay`.
        ///
        /// The default handler for this signal uses the `widget`'s
        /// halign and valign properties to determine the position
        /// and gives the widget its natural size (except that an
        /// alignment of `GTK_ALIGN_FILL` will cause the overlay to
        /// be full-width/height). If the main child is a
        /// `gtk.ScrolledWindow`, the overlays are placed relative
        /// to its contents.
        pub const get_child_position = struct {
            pub const name = "get-child-position";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_widget: *gtk.Widget, p_allocation: *gdk.Rectangle, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Overlay, p_instance))),
                    gobject.signalLookup("get-child-position", Overlay.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.Overlay`.
    extern fn gtk_overlay_new() *gtk.Overlay;
    pub const new = gtk_overlay_new;

    /// Adds `widget` to `overlay`.
    ///
    /// The widget will be stacked on top of the main widget
    /// added with `gtk.Container.add`.
    ///
    /// The position at which `widget` is placed is determined
    /// from its `gtk.Widget.properties.halign` and `gtk.Widget.properties.valign` properties.
    extern fn gtk_overlay_add_overlay(p_overlay: *Overlay, p_widget: *gtk.Widget) void;
    pub const addOverlay = gtk_overlay_add_overlay;

    /// Convenience function to get the value of the `gtk.Overlay.properties.pass`-through
    /// child property for `widget`.
    extern fn gtk_overlay_get_overlay_pass_through(p_overlay: *Overlay, p_widget: *gtk.Widget) c_int;
    pub const getOverlayPassThrough = gtk_overlay_get_overlay_pass_through;

    /// Moves `child` to a new `index` in the list of `overlay` children.
    /// The list contains overlays in the order that these were
    /// added to `overlay` by default. See also `gtk.Overlay.properties.index`.
    ///
    /// A widget’s index in the `overlay` children list determines which order
    /// the children are drawn if they overlap. The first child is drawn at
    /// the bottom. It also affects the default focus chain order.
    extern fn gtk_overlay_reorder_overlay(p_overlay: *Overlay, p_child: *gtk.Widget, p_index_: c_int) void;
    pub const reorderOverlay = gtk_overlay_reorder_overlay;

    /// Convenience function to set the value of the `gtk.Overlay.properties.pass`-through
    /// child property for `widget`.
    extern fn gtk_overlay_set_overlay_pass_through(p_overlay: *Overlay, p_widget: *gtk.Widget, p_pass_through: c_int) void;
    pub const setOverlayPassThrough = gtk_overlay_set_overlay_pass_through;

    extern fn gtk_overlay_get_type() usize;
    pub const getGObjectType = gtk_overlay_get_type;

    extern fn g_object_ref(p_self: *gtk.Overlay) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Overlay) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Overlay, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.PadController` is an event controller for the pads found in drawing
/// tablets (The collection of buttons and tactile sensors often found around
/// the stylus-sensitive area).
///
/// These buttons and sensors have no implicit meaning, and by default they
/// perform no action, this event controller is provided to map those to
/// `gio.Action` objects, thus letting the application give those a more semantic
/// meaning.
///
/// Buttons and sensors are not constrained to triggering a single action, some
/// `GDK_SOURCE_TABLET_PAD` devices feature multiple "modes", all these input
/// elements have one current mode, which may determine the final action
/// being triggered. Pad devices often divide buttons and sensors into groups,
/// all elements in a group share the same current mode, but different groups
/// may have different modes. See `gdk.DevicePad.getNGroups` and
/// `gdk.DevicePad.getGroupNModes`.
///
/// Each of the actions that a given button/strip/ring performs for a given
/// mode is defined by `gtk.PadActionEntry`, it contains an action name that
/// will be looked up in the given `gio.ActionGroup` and activated whenever the
/// specified input element and mode are triggered.
///
/// A simple example of `gtk.PadController` usage, assigning button 1 in all
/// modes and pad devices to an "invert-selection" action:
/// ```
///   GtkPadActionEntry *pad_actions[] = {
///     { GTK_PAD_ACTION_BUTTON, 1, -1, "Invert selection", "pad-actions.invert-selection" },
///     …
///   };
///
///   …
///   action_group = g_simple_action_group_new ();
///   action = g_simple_action_new ("pad-actions.invert-selection", NULL);
///   g_signal_connect (action, "activate", on_invert_selection_activated, NULL);
///   g_action_map_add_action (G_ACTION_MAP (action_group), action);
///   …
///   pad_controller = gtk_pad_controller_new (window, action_group, NULL);
/// ```
///
/// The actions belonging to rings/strips will be activated with a parameter
/// of type `G_VARIANT_TYPE_DOUBLE` bearing the value of the given axis, it
/// is required that those are made stateful and accepting this `glib.VariantType`.
pub const PadController = opaque {
    pub const Parent = gtk.EventController;
    pub const Implements = [_]type{};
    pub const Class = gtk.PadControllerClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const action_group = struct {
            pub const name = "action-group";

            pub const Type = ?*gio.ActionGroup;
        };

        pub const pad = struct {
            pub const name = "pad";

            pub const Type = ?*gdk.Device;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.PadController` that will associate events from `pad` to
    /// actions. A `NULL` pad may be provided so the controller manages all pad devices
    /// generically, it is discouraged to mix `gtk.PadController` objects with `NULL`
    /// and non-`NULL` `pad` argument on the same `window`, as execution order is not
    /// guaranteed.
    ///
    /// The `gtk.PadController` is created with no mapped actions. In order to map pad
    /// events to actions, use `gtk.PadController.setActionEntries` or
    /// `gtk.PadController.setAction`.
    extern fn gtk_pad_controller_new(p_window: *gtk.Window, p_group: *gio.ActionGroup, p_pad: ?*gdk.Device) *gtk.PadController;
    pub const new = gtk_pad_controller_new;

    /// Adds an individual action to `controller`. This action will only be activated
    /// if the given button/ring/strip number in `index` is interacted while
    /// the current mode is `mode`. -1 may be used for simple cases, so the action
    /// is triggered on all modes.
    ///
    /// The given `label` should be considered user-visible, so internationalization
    /// rules apply. Some windowing systems may be able to use those for user
    /// feedback.
    extern fn gtk_pad_controller_set_action(p_controller: *PadController, p_type: gtk.PadActionType, p_index: c_int, p_mode: c_int, p_label: [*:0]const u8, p_action_name: [*:0]const u8) void;
    pub const setAction = gtk_pad_controller_set_action;

    /// This is a convenience function to add a group of action entries on
    /// `controller`. See `gtk.PadActionEntry` and `gtk.PadController.setAction`.
    extern fn gtk_pad_controller_set_action_entries(p_controller: *PadController, p_entries: [*]const gtk.PadActionEntry, p_n_entries: c_int) void;
    pub const setActionEntries = gtk_pad_controller_set_action_entries;

    extern fn gtk_pad_controller_get_type() usize;
    pub const getGObjectType = gtk_pad_controller_get_type;

    extern fn g_object_ref(p_self: *gtk.PadController) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.PadController) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *PadController, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkPageSetup object stores the page size, orientation and margins.
/// The idea is that you can get one of these from the page setup dialog
/// and then pass it to the `gtk.PrintOperation` when printing.
/// The benefit of splitting this out of the `gtk.PrintSettings` is that
/// these affect the actual layout of the page, and thus need to be set
/// long before user prints.
///
/// ## Margins
/// The margins specified in this object are the “print margins”, i.e. the
/// parts of the page that the printer cannot print on. These are different
/// from the layout margins that a word processor uses; they are typically
/// used to determine the minimal size for the layout
/// margins.
///
/// To obtain a `gtk.PageSetup` use `gtk.PageSetup.new` to get the defaults,
/// or use `gtk.printRunPageSetupDialog` to show the page setup dialog
/// and receive the resulting page setup.
///
/// ## A page setup dialog
///
/// ```
/// static GtkPrintSettings *settings = NULL;
/// static GtkPageSetup *page_setup = NULL;
///
/// static void
/// do_page_setup (void)
/// {
///   GtkPageSetup *new_page_setup;
///
///   if (settings == NULL)
///     settings = gtk_print_settings_new ();
///
///   new_page_setup = gtk_print_run_page_setup_dialog (GTK_WINDOW (main_window),
///                                                     page_setup, settings);
///
///   if (page_setup)
///     g_object_unref (page_setup);
///
///   page_setup = new_page_setup;
/// }
/// ```
///
/// Printing support was added in GTK+ 2.10.
pub const PageSetup = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = PageSetup;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.PageSetup`.
    extern fn gtk_page_setup_new() *gtk.PageSetup;
    pub const new = gtk_page_setup_new;

    /// Reads the page setup from the file `file_name`. Returns a
    /// new `gtk.PageSetup` object with the restored page setup,
    /// or `NULL` if an error occurred. See `gtk.PageSetup.toFile`.
    extern fn gtk_page_setup_new_from_file(p_file_name: [*:0]const u8, p_error: ?*?*glib.Error) ?*gtk.PageSetup;
    pub const newFromFile = gtk_page_setup_new_from_file;

    /// Desrialize a page setup from an a{sv} variant in
    /// the format produced by `gtk.PageSetup.toGvariant`.
    extern fn gtk_page_setup_new_from_gvariant(p_variant: *glib.Variant) *gtk.PageSetup;
    pub const newFromGvariant = gtk_page_setup_new_from_gvariant;

    /// Reads the page setup from the group `group_name` in the key file
    /// `key_file`. Returns a new `gtk.PageSetup` object with the restored
    /// page setup, or `NULL` if an error occurred.
    extern fn gtk_page_setup_new_from_key_file(p_key_file: *glib.KeyFile, p_group_name: ?[*:0]const u8, p_error: ?*?*glib.Error) ?*gtk.PageSetup;
    pub const newFromKeyFile = gtk_page_setup_new_from_key_file;

    /// Copies a `gtk.PageSetup`.
    extern fn gtk_page_setup_copy(p_other: *PageSetup) *gtk.PageSetup;
    pub const copy = gtk_page_setup_copy;

    /// Gets the bottom margin in units of `unit`.
    extern fn gtk_page_setup_get_bottom_margin(p_setup: *PageSetup, p_unit: gtk.Unit) f64;
    pub const getBottomMargin = gtk_page_setup_get_bottom_margin;

    /// Gets the left margin in units of `unit`.
    extern fn gtk_page_setup_get_left_margin(p_setup: *PageSetup, p_unit: gtk.Unit) f64;
    pub const getLeftMargin = gtk_page_setup_get_left_margin;

    /// Gets the page orientation of the `gtk.PageSetup`.
    extern fn gtk_page_setup_get_orientation(p_setup: *PageSetup) gtk.PageOrientation;
    pub const getOrientation = gtk_page_setup_get_orientation;

    /// Returns the page height in units of `unit`.
    ///
    /// Note that this function takes orientation and
    /// margins into consideration.
    /// See `gtk.PageSetup.getPaperHeight`.
    extern fn gtk_page_setup_get_page_height(p_setup: *PageSetup, p_unit: gtk.Unit) f64;
    pub const getPageHeight = gtk_page_setup_get_page_height;

    /// Returns the page width in units of `unit`.
    ///
    /// Note that this function takes orientation and
    /// margins into consideration.
    /// See `gtk.PageSetup.getPaperWidth`.
    extern fn gtk_page_setup_get_page_width(p_setup: *PageSetup, p_unit: gtk.Unit) f64;
    pub const getPageWidth = gtk_page_setup_get_page_width;

    /// Returns the paper height in units of `unit`.
    ///
    /// Note that this function takes orientation, but
    /// not margins into consideration.
    /// See `gtk.PageSetup.getPageHeight`.
    extern fn gtk_page_setup_get_paper_height(p_setup: *PageSetup, p_unit: gtk.Unit) f64;
    pub const getPaperHeight = gtk_page_setup_get_paper_height;

    /// Gets the paper size of the `gtk.PageSetup`.
    extern fn gtk_page_setup_get_paper_size(p_setup: *PageSetup) *gtk.PaperSize;
    pub const getPaperSize = gtk_page_setup_get_paper_size;

    /// Returns the paper width in units of `unit`.
    ///
    /// Note that this function takes orientation, but
    /// not margins into consideration.
    /// See `gtk.PageSetup.getPageWidth`.
    extern fn gtk_page_setup_get_paper_width(p_setup: *PageSetup, p_unit: gtk.Unit) f64;
    pub const getPaperWidth = gtk_page_setup_get_paper_width;

    /// Gets the right margin in units of `unit`.
    extern fn gtk_page_setup_get_right_margin(p_setup: *PageSetup, p_unit: gtk.Unit) f64;
    pub const getRightMargin = gtk_page_setup_get_right_margin;

    /// Gets the top margin in units of `unit`.
    extern fn gtk_page_setup_get_top_margin(p_setup: *PageSetup, p_unit: gtk.Unit) f64;
    pub const getTopMargin = gtk_page_setup_get_top_margin;

    /// Reads the page setup from the file `file_name`.
    /// See `gtk.PageSetup.toFile`.
    extern fn gtk_page_setup_load_file(p_setup: *PageSetup, p_file_name: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const loadFile = gtk_page_setup_load_file;

    /// Reads the page setup from the group `group_name` in the key file
    /// `key_file`.
    extern fn gtk_page_setup_load_key_file(p_setup: *PageSetup, p_key_file: *glib.KeyFile, p_group_name: ?[*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const loadKeyFile = gtk_page_setup_load_key_file;

    /// Sets the bottom margin of the `gtk.PageSetup`.
    extern fn gtk_page_setup_set_bottom_margin(p_setup: *PageSetup, p_margin: f64, p_unit: gtk.Unit) void;
    pub const setBottomMargin = gtk_page_setup_set_bottom_margin;

    /// Sets the left margin of the `gtk.PageSetup`.
    extern fn gtk_page_setup_set_left_margin(p_setup: *PageSetup, p_margin: f64, p_unit: gtk.Unit) void;
    pub const setLeftMargin = gtk_page_setup_set_left_margin;

    /// Sets the page orientation of the `gtk.PageSetup`.
    extern fn gtk_page_setup_set_orientation(p_setup: *PageSetup, p_orientation: gtk.PageOrientation) void;
    pub const setOrientation = gtk_page_setup_set_orientation;

    /// Sets the paper size of the `gtk.PageSetup` without
    /// changing the margins. See
    /// `gtk.PageSetup.setPaperSizeAndDefaultMargins`.
    extern fn gtk_page_setup_set_paper_size(p_setup: *PageSetup, p_size: *gtk.PaperSize) void;
    pub const setPaperSize = gtk_page_setup_set_paper_size;

    /// Sets the paper size of the `gtk.PageSetup` and modifies
    /// the margins according to the new paper size.
    extern fn gtk_page_setup_set_paper_size_and_default_margins(p_setup: *PageSetup, p_size: *gtk.PaperSize) void;
    pub const setPaperSizeAndDefaultMargins = gtk_page_setup_set_paper_size_and_default_margins;

    /// Sets the right margin of the `gtk.PageSetup`.
    extern fn gtk_page_setup_set_right_margin(p_setup: *PageSetup, p_margin: f64, p_unit: gtk.Unit) void;
    pub const setRightMargin = gtk_page_setup_set_right_margin;

    /// Sets the top margin of the `gtk.PageSetup`.
    extern fn gtk_page_setup_set_top_margin(p_setup: *PageSetup, p_margin: f64, p_unit: gtk.Unit) void;
    pub const setTopMargin = gtk_page_setup_set_top_margin;

    /// This function saves the information from `setup` to `file_name`.
    extern fn gtk_page_setup_to_file(p_setup: *PageSetup, p_file_name: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const toFile = gtk_page_setup_to_file;

    /// Serialize page setup to an a{sv} variant.
    extern fn gtk_page_setup_to_gvariant(p_setup: *PageSetup) *glib.Variant;
    pub const toGvariant = gtk_page_setup_to_gvariant;

    /// This function adds the page setup from `setup` to `key_file`.
    extern fn gtk_page_setup_to_key_file(p_setup: *PageSetup, p_key_file: *glib.KeyFile, p_group_name: ?[*:0]const u8) void;
    pub const toKeyFile = gtk_page_setup_to_key_file;

    extern fn gtk_page_setup_get_type() usize;
    pub const getGObjectType = gtk_page_setup_get_type;

    extern fn g_object_ref(p_self: *gtk.PageSetup) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.PageSetup) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *PageSetup, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.Paned` has two panes, arranged either
/// horizontally or vertically. The division between
/// the two panes is adjustable by the user by dragging
/// a handle.
///
/// Child widgets are
/// added to the panes of the widget with `gtk.Paned.pack1` and
/// `gtk.Paned.pack2`. The division between the two children is set by default
/// from the size requests of the children, but it can be adjusted by the
/// user.
///
/// A paned widget draws a separator between the two child widgets and a
/// small handle that the user can drag to adjust the division. It does not
/// draw any relief around the children or around the separator. (The space
/// in which the separator is called the gutter.) Often, it is useful to put
/// each child inside a `gtk.Frame` with the shadow type set to `GTK_SHADOW_IN`
/// so that the gutter appears as a ridge. No separator is drawn if one of
/// the children is missing.
///
/// Each child has two options that can be set, `resize` and `shrink`. If
/// `resize` is true, then when the `gtk.Paned` is resized, that child will
/// expand or shrink along with the paned widget. If `shrink` is true, then
/// that child can be made smaller than its requisition by the user.
/// Setting `shrink` to `FALSE` allows the application to set a minimum size.
/// If `resize` is false for both children, then this is treated as if
/// `resize` is true for both children.
///
/// The application can set the position of the slider as if it were set
/// by the user, by calling `gtk.Paned.setPosition`.
///
/// # CSS nodes
///
/// ```
/// paned
/// ├── <child>
/// ├── separator[.wide]
/// ╰── <child>
/// ```
///
/// GtkPaned has a main CSS node with name paned, and a subnode for
/// the separator with name separator. The subnode gets a .wide style
/// class when the paned is supposed to be wide.
///
/// In horizontal orientation, the nodes of the children are always arranged
/// from left to right. So :first-child will always select the leftmost child,
/// regardless of text direction.
///
/// ## Creating a paned widget with minimum sizes.
///
/// ```
/// GtkWidget *hpaned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL);
/// GtkWidget *frame1 = gtk_frame_new (NULL);
/// GtkWidget *frame2 = gtk_frame_new (NULL);
/// gtk_frame_set_shadow_type (GTK_FRAME (frame1), GTK_SHADOW_IN);
/// gtk_frame_set_shadow_type (GTK_FRAME (frame2), GTK_SHADOW_IN);
///
/// gtk_widget_set_size_request (hpaned, 200, -1);
///
/// gtk_paned_pack1 (GTK_PANED (hpaned), frame1, TRUE, FALSE);
/// gtk_widget_set_size_request (frame1, 50, -1);
///
/// gtk_paned_pack2 (GTK_PANED (hpaned), frame2, FALSE, FALSE);
/// gtk_widget_set_size_request (frame2, 50, -1);
/// ```
pub const Paned = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.PanedClass;
    f_container: gtk.Container,
    f_priv: ?*gtk.PanedPrivate,

    pub const virtual_methods = struct {
        pub const accept_position = struct {
            pub fn call(p_class: anytype, p_paned: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Paned.Class, p_class).f_accept_position.?(gobject.ext.as(Paned, p_paned));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_paned: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Paned.Class, p_class).f_accept_position = @ptrCast(p_implementation);
            }
        };

        pub const cancel_position = struct {
            pub fn call(p_class: anytype, p_paned: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Paned.Class, p_class).f_cancel_position.?(gobject.ext.as(Paned, p_paned));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_paned: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Paned.Class, p_class).f_cancel_position = @ptrCast(p_implementation);
            }
        };

        pub const cycle_child_focus = struct {
            pub fn call(p_class: anytype, p_paned: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_reverse: c_int) c_int {
                return gobject.ext.as(Paned.Class, p_class).f_cycle_child_focus.?(gobject.ext.as(Paned, p_paned), p_reverse);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_paned: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_reverse: c_int) callconv(.c) c_int) void {
                gobject.ext.as(Paned.Class, p_class).f_cycle_child_focus = @ptrCast(p_implementation);
            }
        };

        pub const cycle_handle_focus = struct {
            pub fn call(p_class: anytype, p_paned: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_reverse: c_int) c_int {
                return gobject.ext.as(Paned.Class, p_class).f_cycle_handle_focus.?(gobject.ext.as(Paned, p_paned), p_reverse);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_paned: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_reverse: c_int) callconv(.c) c_int) void {
                gobject.ext.as(Paned.Class, p_class).f_cycle_handle_focus = @ptrCast(p_implementation);
            }
        };

        pub const move_handle = struct {
            pub fn call(p_class: anytype, p_paned: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_scroll: gtk.ScrollType) c_int {
                return gobject.ext.as(Paned.Class, p_class).f_move_handle.?(gobject.ext.as(Paned, p_paned), p_scroll);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_paned: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_scroll: gtk.ScrollType) callconv(.c) c_int) void {
                gobject.ext.as(Paned.Class, p_class).f_move_handle = @ptrCast(p_implementation);
            }
        };

        pub const toggle_handle_focus = struct {
            pub fn call(p_class: anytype, p_paned: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Paned.Class, p_class).f_toggle_handle_focus.?(gobject.ext.as(Paned, p_paned));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_paned: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Paned.Class, p_class).f_toggle_handle_focus = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The largest possible value for the position property.
        /// This property is derived from the size and shrinkability
        /// of the widget's children.
        pub const max_position = struct {
            pub const name = "max-position";

            pub const Type = c_int;
        };

        /// The smallest possible value for the position property.
        /// This property is derived from the size and shrinkability
        /// of the widget's children.
        pub const min_position = struct {
            pub const name = "min-position";

            pub const Type = c_int;
        };

        pub const position = struct {
            pub const name = "position";

            pub const Type = c_int;
        };

        pub const position_set = struct {
            pub const name = "position-set";

            pub const Type = c_int;
        };

        /// Setting this property to `TRUE` indicates that the paned needs
        /// to provide stronger visual separation (e.g. because it separates
        /// between two notebooks, whose tab rows would otherwise merge visually).
        pub const wide_handle = struct {
            pub const name = "wide-handle";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::accept-position signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to accept the current position of the handle when
        /// moving it using key bindings.
        ///
        /// The default binding for this signal is Return or Space.
        pub const accept_position = struct {
            pub const name = "accept-position";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Paned, p_instance))),
                    gobject.signalLookup("accept-position", Paned.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::cancel-position signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to cancel moving the position of the handle using key
        /// bindings. The position of the handle will be reset to the value prior to
        /// moving it.
        ///
        /// The default binding for this signal is Escape.
        pub const cancel_position = struct {
            pub const name = "cancel-position";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Paned, p_instance))),
                    gobject.signalLookup("cancel-position", Paned.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::cycle-child-focus signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to cycle the focus between the children of the paned.
        ///
        /// The default binding is f6.
        pub const cycle_child_focus = struct {
            pub const name = "cycle-child-focus";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_reversed: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Paned, p_instance))),
                    gobject.signalLookup("cycle-child-focus", Paned.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::cycle-handle-focus signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to cycle whether the paned should grab focus to allow
        /// the user to change position of the handle by using key bindings.
        ///
        /// The default binding for this signal is f8.
        pub const cycle_handle_focus = struct {
            pub const name = "cycle-handle-focus";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_reversed: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Paned, p_instance))),
                    gobject.signalLookup("cycle-handle-focus", Paned.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::move-handle signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to move the handle when the user is using key bindings
        /// to move it.
        pub const move_handle = struct {
            pub const name = "move-handle";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_scroll_type: gtk.ScrollType, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Paned, p_instance))),
                    gobject.signalLookup("move-handle", Paned.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::toggle-handle-focus is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to accept the current position of the handle and then
        /// move focus to the next widget in the focus chain.
        ///
        /// The default binding is Tab.
        pub const toggle_handle_focus = struct {
            pub const name = "toggle-handle-focus";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Paned, p_instance))),
                    gobject.signalLookup("toggle-handle-focus", Paned.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.Paned` widget.
    extern fn gtk_paned_new(p_orientation: gtk.Orientation) *gtk.Paned;
    pub const new = gtk_paned_new;

    /// Adds a child to the top or left pane with default parameters. This is
    /// equivalent to
    /// `gtk_paned_pack1 (paned, child, FALSE, TRUE)`.
    extern fn gtk_paned_add1(p_paned: *Paned, p_child: *gtk.Widget) void;
    pub const add1 = gtk_paned_add1;

    /// Adds a child to the bottom or right pane with default parameters. This
    /// is equivalent to
    /// `gtk_paned_pack2 (paned, child, TRUE, TRUE)`.
    extern fn gtk_paned_add2(p_paned: *Paned, p_child: *gtk.Widget) void;
    pub const add2 = gtk_paned_add2;

    /// Obtains the first child of the paned widget.
    extern fn gtk_paned_get_child1(p_paned: *Paned) ?*gtk.Widget;
    pub const getChild1 = gtk_paned_get_child1;

    /// Obtains the second child of the paned widget.
    extern fn gtk_paned_get_child2(p_paned: *Paned) ?*gtk.Widget;
    pub const getChild2 = gtk_paned_get_child2;

    /// Returns the `gdk.Window` of the handle. This function is
    /// useful when handling button or motion events because it
    /// enables the callback to distinguish between the window
    /// of the paned, a child and the handle.
    extern fn gtk_paned_get_handle_window(p_paned: *Paned) *gdk.Window;
    pub const getHandleWindow = gtk_paned_get_handle_window;

    /// Obtains the position of the divider between the two panes.
    extern fn gtk_paned_get_position(p_paned: *Paned) c_int;
    pub const getPosition = gtk_paned_get_position;

    /// Gets the `gtk.Paned.properties.wide`-handle property.
    extern fn gtk_paned_get_wide_handle(p_paned: *Paned) c_int;
    pub const getWideHandle = gtk_paned_get_wide_handle;

    /// Adds a child to the top or left pane.
    extern fn gtk_paned_pack1(p_paned: *Paned, p_child: *gtk.Widget, p_resize: c_int, p_shrink: c_int) void;
    pub const pack1 = gtk_paned_pack1;

    /// Adds a child to the bottom or right pane.
    extern fn gtk_paned_pack2(p_paned: *Paned, p_child: *gtk.Widget, p_resize: c_int, p_shrink: c_int) void;
    pub const pack2 = gtk_paned_pack2;

    /// Sets the position of the divider between the two panes.
    extern fn gtk_paned_set_position(p_paned: *Paned, p_position: c_int) void;
    pub const setPosition = gtk_paned_set_position;

    /// Sets the `gtk.Paned.properties.wide`-handle property.
    extern fn gtk_paned_set_wide_handle(p_paned: *Paned, p_wide: c_int) void;
    pub const setWideHandle = gtk_paned_set_wide_handle;

    extern fn gtk_paned_get_type() usize;
    pub const getGObjectType = gtk_paned_get_type;

    extern fn g_object_ref(p_self: *gtk.Paned) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Paned) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Paned, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PanedAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Value };
    pub const Class = gtk.PanedAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.PanedAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_paned_accessible_get_type() usize;
    pub const getGObjectType = gtk_paned_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.PanedAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.PanedAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *PanedAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.PlacesSidebar` is a widget that displays a list of frequently-used places in the
/// file system:  the user’s home directory, the user’s bookmarks, and volumes and drives.
/// This widget is used as a sidebar in `gtk.FileChooser` and may be used by file managers
/// and similar programs.
///
/// The places sidebar displays drives and volumes, and will automatically mount
/// or unmount them when the user selects them.
///
/// Applications can hook to various signals in the places sidebar to customize
/// its behavior.  For example, they can add extra commands to the context menu
/// of the sidebar.
///
/// While bookmarks are completely in control of the user, the places sidebar also
/// allows individual applications to provide extra shortcut folders that are unique
/// to each application.  For example, a Paint program may want to add a shortcut
/// for a Clipart folder.  You can do this with `gtk.PlacesSidebar.addShortcut`.
///
/// To make use of the places sidebar, an application at least needs to connect
/// to the `gtk.PlacesSidebar.signals.open`-location signal.  This is emitted when the
/// user selects in the sidebar a location to open.  The application should also
/// call `gtk.PlacesSidebar.setLocation` when it changes the currently-viewed
/// location.
///
/// # CSS nodes
///
/// GtkPlacesSidebar uses a single CSS node with name placessidebar and style
/// class .sidebar.
///
/// Among the children of the places sidebar, the following style classes can
/// be used:
/// - .sidebar-new-bookmark-row for the 'Add new bookmark' row
/// - .sidebar-placeholder-row for a row that is a placeholder
/// - .has-open-popup when a popup is open for a row
pub const PlacesSidebar = opaque {
    pub const Parent = gtk.ScrolledWindow;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.PlacesSidebarClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const local_only = struct {
            pub const name = "local-only";

            pub const Type = c_int;
        };

        pub const location = struct {
            pub const name = "location";

            pub const Type = ?*gio.File;
        };

        pub const open_flags = struct {
            pub const name = "open-flags";

            pub const Type = gtk.PlacesOpenFlags;
        };

        /// If :populate-all is `TRUE`, the `gtk.PlacesSidebar.signals.populate`-popup signal
        /// is also emitted for popovers.
        pub const populate_all = struct {
            pub const name = "populate-all";

            pub const Type = c_int;
        };

        pub const show_connect_to_server = struct {
            pub const name = "show-connect-to-server";

            pub const Type = c_int;
        };

        pub const show_desktop = struct {
            pub const name = "show-desktop";

            pub const Type = c_int;
        };

        pub const show_enter_location = struct {
            pub const name = "show-enter-location";

            pub const Type = c_int;
        };

        pub const show_other_locations = struct {
            pub const name = "show-other-locations";

            pub const Type = c_int;
        };

        pub const show_recent = struct {
            pub const name = "show-recent";

            pub const Type = c_int;
        };

        pub const show_starred_location = struct {
            pub const name = "show-starred-location";

            pub const Type = c_int;
        };

        pub const show_trash = struct {
            pub const name = "show-trash";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The places sidebar emits this signal when it needs to ask the application
        /// to pop up a menu to ask the user for which drag action to perform.
        pub const drag_action_ask = struct {
            pub const name = "drag-action-ask";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_actions: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PlacesSidebar, p_instance))),
                    gobject.signalLookup("drag-action-ask", PlacesSidebar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// When the user starts a drag-and-drop operation and the sidebar needs
        /// to ask the application for which drag action to perform, then the
        /// sidebar will emit this signal.
        ///
        /// The application can evaluate the `context` for customary actions, or
        /// it can check the type of the files indicated by `source_file_list` against the
        /// possible actions for the destination `dest_file`.
        ///
        /// The drag action to use must be the return value of the signal handler.
        pub const drag_action_requested = struct {
            pub const name = "drag-action-requested";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gdk.DragContext, p_dest_file: *gio.File, p_source_file_list: **glib.List, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PlacesSidebar, p_instance))),
                    gobject.signalLookup("drag-action-requested", PlacesSidebar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The places sidebar emits this signal when the user completes a
        /// drag-and-drop operation and one of the sidebar's items is the
        /// destination.  This item is in the `dest_file`, and the
        /// `source_file_list` has the list of files that are dropped into it and
        /// which should be copied/moved/etc. based on the specified `action`.
        pub const drag_perform_drop = struct {
            pub const name = "drag-perform-drop";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_dest_file: *gio.File, p_source_file_list: **glib.List, p_action: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PlacesSidebar, p_instance))),
                    gobject.signalLookup("drag-perform-drop", PlacesSidebar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The places sidebar emits this signal when it starts a new operation
        /// because the user clicked on some location that needs mounting.
        /// In this way the application using the `gtk.PlacesSidebar` can track the
        /// progress of the operation and, for example, show a notification.
        pub const mount = struct {
            pub const name = "mount";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_mount_operation: *gio.MountOperation, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PlacesSidebar, p_instance))),
                    gobject.signalLookup("mount", PlacesSidebar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The places sidebar emits this signal when the user selects a location
        /// in it.  The calling application should display the contents of that
        /// location; for example, a file manager should show a list of files in
        /// the specified location.
        pub const open_location = struct {
            pub const name = "open-location";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_location: *gio.File, p_open_flags: gtk.PlacesOpenFlags, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PlacesSidebar, p_instance))),
                    gobject.signalLookup("open-location", PlacesSidebar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The places sidebar emits this signal when the user invokes a contextual
        /// popup on one of its items. In the signal handler, the application may
        /// add extra items to the menu as appropriate. For example, a file manager
        /// may want to add a "Properties" command to the menu.
        ///
        /// It is not necessary to store the `selected_item` for each menu item;
        /// during their callbacks, the application can use `gtk.PlacesSidebar.getLocation`
        /// to get the file to which the item refers.
        ///
        /// The `selected_item` argument may be `NULL` in case the selection refers to
        /// a volume. In this case, `selected_volume` will be non-`NULL`. In this case,
        /// the calling application will have to `gobject.Object.ref` the `selected_volume` and
        /// keep it around to use it in the callback.
        ///
        /// The `container` and all its contents are destroyed after the user
        /// dismisses the popup. The popup is re-created (and thus, this signal is
        /// emitted) every time the user activates the contextual menu.
        ///
        /// Before 3.18, the `container` always was a `gtk.Menu`, and you were expected
        /// to add your items as `GtkMenuItems`. Since 3.18, the popup may be implemented
        /// as a `gtk.Popover`, in which case `container` will be something else, e.g. a
        /// `gtk.Box`, to which you may add `GtkModelButtons` or other widgets, such as
        /// `GtkEntries`, `GtkSpinButtons`, etc. If your application can deal with this
        /// situation, you can set `gtk.PlacesSidebar.signals.populate`-all to `TRUE` to request
        /// that this signal is emitted for populating popovers as well.
        pub const populate_popup = struct {
            pub const name = "populate-popup";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_container: *gtk.Widget, p_selected_item: ?*gio.File, p_selected_volume: ?*gio.Volume, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PlacesSidebar, p_instance))),
                    gobject.signalLookup("populate-popup", PlacesSidebar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The places sidebar emits this signal when it needs the calling
        /// application to present an way to connect directly to a network server.
        /// For example, the application may bring up a dialog box asking for
        /// a URL like "sftp://ftp.example.com".  It is up to the application to create
        /// the corresponding mount by using, for example, `gio.File.mountEnclosingVolume`.
        pub const show_connect_to_server = struct {
            pub const name = "show-connect-to-server";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PlacesSidebar, p_instance))),
                    gobject.signalLookup("show-connect-to-server", PlacesSidebar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The places sidebar emits this signal when it needs the calling
        /// application to present an way to directly enter a location.
        /// For example, the application may bring up a dialog box asking for
        /// a URL like "http://http.example.com".
        pub const show_enter_location = struct {
            pub const name = "show-enter-location";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PlacesSidebar, p_instance))),
                    gobject.signalLookup("show-enter-location", PlacesSidebar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The places sidebar emits this signal when it needs the calling
        /// application to present an error message.  Most of these messages
        /// refer to mounting or unmounting media, for example, when a drive
        /// cannot be started for some reason.
        pub const show_error_message = struct {
            pub const name = "show-error-message";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_primary: [*:0]u8, p_secondary: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PlacesSidebar, p_instance))),
                    gobject.signalLookup("show-error-message", PlacesSidebar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The places sidebar emits this signal when it needs the calling
        /// application to present a way to show other locations e.g. drives
        /// and network access points.
        /// For example, the application may bring up a page showing persistent
        /// volumes and discovered network addresses.
        pub const show_other_locations = struct {
            pub const name = "show-other-locations";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PlacesSidebar, p_instance))),
                    gobject.signalLookup("show-other-locations", PlacesSidebar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The places sidebar emits this signal when it needs the calling
        /// application to present a way to show other locations e.g. drives
        /// and network access points.
        /// For example, the application may bring up a page showing persistent
        /// volumes and discovered network addresses.
        pub const show_other_locations_with_flags = struct {
            pub const name = "show-other-locations-with-flags";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_open_flags: gtk.PlacesOpenFlags, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PlacesSidebar, p_instance))),
                    gobject.signalLookup("show-other-locations-with-flags", PlacesSidebar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The places sidebar emits this signal when it needs the calling
        /// application to present a way to show the starred files. In GNOME,
        /// starred files are implemented by setting the nao:predefined-tag-favorite
        /// tag in the tracker database.
        pub const show_starred_location = struct {
            pub const name = "show-starred-location";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_open_flags: gtk.PlacesOpenFlags, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PlacesSidebar, p_instance))),
                    gobject.signalLookup("show-starred-location", PlacesSidebar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The places sidebar emits this signal when it starts a new operation
        /// because the user for example ejected some drive or unmounted a mount.
        /// In this way the application using the `gtk.PlacesSidebar` can track the
        /// progress of the operation and, for example, show a notification.
        pub const unmount = struct {
            pub const name = "unmount";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_mount_operation: *gio.MountOperation, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PlacesSidebar, p_instance))),
                    gobject.signalLookup("unmount", PlacesSidebar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.PlacesSidebar` widget.
    ///
    /// The application should connect to at least the
    /// `gtk.PlacesSidebar.signals.open`-location signal to be notified
    /// when the user makes a selection in the sidebar.
    extern fn gtk_places_sidebar_new() *gtk.PlacesSidebar;
    pub const new = gtk_places_sidebar_new;

    /// Applications may want to present some folders in the places sidebar if
    /// they could be immediately useful to users.  For example, a drawing
    /// program could add a “/usr/share/clipart” location when the sidebar is
    /// being used in an “Insert Clipart” dialog box.
    ///
    /// This function adds the specified `location` to a special place for immutable
    /// shortcuts.  The shortcuts are application-specific; they are not shared
    /// across applications, and they are not persistent.  If this function
    /// is called multiple times with different locations, then they are added
    /// to the sidebar’s list in the same order as the function is called.
    extern fn gtk_places_sidebar_add_shortcut(p_sidebar: *PlacesSidebar, p_location: *gio.File) void;
    pub const addShortcut = gtk_places_sidebar_add_shortcut;

    /// Returns the value previously set with `gtk.PlacesSidebar.setLocalOnly`.
    extern fn gtk_places_sidebar_get_local_only(p_sidebar: *PlacesSidebar) c_int;
    pub const getLocalOnly = gtk_places_sidebar_get_local_only;

    /// Gets the currently selected location in the `sidebar`. This can be `NULL` when
    /// nothing is selected, for example, when `gtk.PlacesSidebar.setLocation` has
    /// been called with a location that is not among the sidebar’s list of places to
    /// show.
    ///
    /// You can use this function to get the selection in the `sidebar`.  Also, if you
    /// connect to the `gtk.PlacesSidebar.signals.populate`-popup signal, you can use this
    /// function to get the location that is being referred to during the callbacks
    /// for your menu items.
    extern fn gtk_places_sidebar_get_location(p_sidebar: *PlacesSidebar) ?*gio.File;
    pub const getLocation = gtk_places_sidebar_get_location;

    /// This function queries the bookmarks added by the user to the places sidebar,
    /// and returns one of them.  This function is used by `gtk.FileChooser` to implement
    /// the “Alt-1”, “Alt-2”, etc. shortcuts, which activate the cooresponding bookmark.
    extern fn gtk_places_sidebar_get_nth_bookmark(p_sidebar: *PlacesSidebar, p_n: c_int) ?*gio.File;
    pub const getNthBookmark = gtk_places_sidebar_get_nth_bookmark;

    /// Gets the open flags.
    extern fn gtk_places_sidebar_get_open_flags(p_sidebar: *PlacesSidebar) gtk.PlacesOpenFlags;
    pub const getOpenFlags = gtk_places_sidebar_get_open_flags;

    /// Returns the value previously set with `gtk.PlacesSidebar.setShowConnectToServer`
    extern fn gtk_places_sidebar_get_show_connect_to_server(p_sidebar: *PlacesSidebar) c_int;
    pub const getShowConnectToServer = gtk_places_sidebar_get_show_connect_to_server;

    /// Returns the value previously set with `gtk.PlacesSidebar.setShowDesktop`
    extern fn gtk_places_sidebar_get_show_desktop(p_sidebar: *PlacesSidebar) c_int;
    pub const getShowDesktop = gtk_places_sidebar_get_show_desktop;

    /// Returns the value previously set with `gtk.PlacesSidebar.setShowEnterLocation`
    extern fn gtk_places_sidebar_get_show_enter_location(p_sidebar: *PlacesSidebar) c_int;
    pub const getShowEnterLocation = gtk_places_sidebar_get_show_enter_location;

    /// Returns the value previously set with `gtk.PlacesSidebar.setShowOtherLocations`
    extern fn gtk_places_sidebar_get_show_other_locations(p_sidebar: *PlacesSidebar) c_int;
    pub const getShowOtherLocations = gtk_places_sidebar_get_show_other_locations;

    /// Returns the value previously set with `gtk.PlacesSidebar.setShowRecent`
    extern fn gtk_places_sidebar_get_show_recent(p_sidebar: *PlacesSidebar) c_int;
    pub const getShowRecent = gtk_places_sidebar_get_show_recent;

    /// Returns the value previously set with `gtk.PlacesSidebar.setShowStarredLocation`
    extern fn gtk_places_sidebar_get_show_starred_location(p_sidebar: *PlacesSidebar) c_int;
    pub const getShowStarredLocation = gtk_places_sidebar_get_show_starred_location;

    /// Returns the value previously set with `gtk.PlacesSidebar.setShowTrash`
    extern fn gtk_places_sidebar_get_show_trash(p_sidebar: *PlacesSidebar) c_int;
    pub const getShowTrash = gtk_places_sidebar_get_show_trash;

    /// Gets the list of shortcuts.
    extern fn gtk_places_sidebar_list_shortcuts(p_sidebar: *PlacesSidebar) *glib.SList;
    pub const listShortcuts = gtk_places_sidebar_list_shortcuts;

    /// Removes an application-specific shortcut that has been previously been
    /// inserted with `gtk.PlacesSidebar.addShortcut`.  If the `location` is not a
    /// shortcut in the sidebar, then nothing is done.
    extern fn gtk_places_sidebar_remove_shortcut(p_sidebar: *PlacesSidebar, p_location: *gio.File) void;
    pub const removeShortcut = gtk_places_sidebar_remove_shortcut;

    /// Make the GtkPlacesSidebar show drop targets, so it can show the available
    /// drop targets and a "new bookmark" row. This improves the Drag-and-Drop
    /// experience of the user and allows applications to show all available
    /// drop targets at once.
    ///
    /// This needs to be called when the application is aware of an ongoing drag
    /// that might target the sidebar. The drop-targets-visible state will be unset
    /// automatically if the drag finishes in the GtkPlacesSidebar. You only need
    /// to unset the state when the drag ends on some other widget on your application.
    extern fn gtk_places_sidebar_set_drop_targets_visible(p_sidebar: *PlacesSidebar, p_visible: c_int, p_context: *gdk.DragContext) void;
    pub const setDropTargetsVisible = gtk_places_sidebar_set_drop_targets_visible;

    /// Sets whether the `sidebar` should only show local files.
    extern fn gtk_places_sidebar_set_local_only(p_sidebar: *PlacesSidebar, p_local_only: c_int) void;
    pub const setLocalOnly = gtk_places_sidebar_set_local_only;

    /// Sets the location that is being shown in the widgets surrounding the
    /// `sidebar`, for example, in a folder view in a file manager.  In turn, the
    /// `sidebar` will highlight that location if it is being shown in the list of
    /// places, or it will unhighlight everything if the `location` is not among the
    /// places in the list.
    extern fn gtk_places_sidebar_set_location(p_sidebar: *PlacesSidebar, p_location: ?*gio.File) void;
    pub const setLocation = gtk_places_sidebar_set_location;

    /// Sets the way in which the calling application can open new locations from
    /// the places sidebar.  For example, some applications only open locations
    /// “directly” into their main view, while others may support opening locations
    /// in a new notebook tab or a new window.
    ///
    /// This function is used to tell the places `sidebar` about the ways in which the
    /// application can open new locations, so that the sidebar can display (or not)
    /// the “Open in new tab” and “Open in new window” menu items as appropriate.
    ///
    /// When the `gtk.PlacesSidebar.signals.open`-location signal is emitted, its flags
    /// argument will be set to one of the `flags` that was passed in
    /// `gtk.PlacesSidebar.setOpenFlags`.
    ///
    /// Passing 0 for `flags` will cause `GTK_PLACES_OPEN_NORMAL` to always be sent
    /// to callbacks for the “open-location” signal.
    extern fn gtk_places_sidebar_set_open_flags(p_sidebar: *PlacesSidebar, p_flags: gtk.PlacesOpenFlags) void;
    pub const setOpenFlags = gtk_places_sidebar_set_open_flags;

    /// Sets whether the `sidebar` should show an item for connecting to a network server;
    /// this is off by default. An application may want to turn this on if it implements
    /// a way for the user to connect to network servers directly.
    ///
    /// If you enable this, you should connect to the
    /// `gtk.PlacesSidebar.signals.show`-connect-to-server signal.
    extern fn gtk_places_sidebar_set_show_connect_to_server(p_sidebar: *PlacesSidebar, p_show_connect_to_server: c_int) void;
    pub const setShowConnectToServer = gtk_places_sidebar_set_show_connect_to_server;

    /// Sets whether the `sidebar` should show an item for the Desktop folder.
    /// The default value for this option is determined by the desktop
    /// environment and the user’s configuration, but this function can be
    /// used to override it on a per-application basis.
    extern fn gtk_places_sidebar_set_show_desktop(p_sidebar: *PlacesSidebar, p_show_desktop: c_int) void;
    pub const setShowDesktop = gtk_places_sidebar_set_show_desktop;

    /// Sets whether the `sidebar` should show an item for entering a location;
    /// this is off by default. An application may want to turn this on if manually
    /// entering URLs is an expected user action.
    ///
    /// If you enable this, you should connect to the
    /// `gtk.PlacesSidebar.signals.show`-enter-location signal.
    extern fn gtk_places_sidebar_set_show_enter_location(p_sidebar: *PlacesSidebar, p_show_enter_location: c_int) void;
    pub const setShowEnterLocation = gtk_places_sidebar_set_show_enter_location;

    /// Sets whether the `sidebar` should show an item for the application to show
    /// an Other Locations view; this is off by default. When set to `TRUE`, persistent
    /// devices such as hard drives are hidden, otherwise they are shown in the sidebar.
    /// An application may want to turn this on if it implements a way for the user to
    /// see and interact with drives and network servers directly.
    ///
    /// If you enable this, you should connect to the
    /// `gtk.PlacesSidebar.signals.show`-other-locations signal.
    extern fn gtk_places_sidebar_set_show_other_locations(p_sidebar: *PlacesSidebar, p_show_other_locations: c_int) void;
    pub const setShowOtherLocations = gtk_places_sidebar_set_show_other_locations;

    /// Sets whether the `sidebar` should show an item for recent files.
    /// The default value for this option is determined by the desktop
    /// environment, but this function can be used to override it on a
    /// per-application basis.
    extern fn gtk_places_sidebar_set_show_recent(p_sidebar: *PlacesSidebar, p_show_recent: c_int) void;
    pub const setShowRecent = gtk_places_sidebar_set_show_recent;

    /// If you enable this, you should connect to the
    /// `gtk.PlacesSidebar.signals.show`-starred-location signal.
    extern fn gtk_places_sidebar_set_show_starred_location(p_sidebar: *PlacesSidebar, p_show_starred_location: c_int) void;
    pub const setShowStarredLocation = gtk_places_sidebar_set_show_starred_location;

    /// Sets whether the `sidebar` should show an item for the Trash location.
    extern fn gtk_places_sidebar_set_show_trash(p_sidebar: *PlacesSidebar, p_show_trash: c_int) void;
    pub const setShowTrash = gtk_places_sidebar_set_show_trash;

    extern fn gtk_places_sidebar_get_type() usize;
    pub const getGObjectType = gtk_places_sidebar_get_type;

    extern fn g_object_ref(p_self: *gtk.PlacesSidebar) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.PlacesSidebar) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *PlacesSidebar, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Together with `gtk.Socket`, `gtk.Plug` provides the ability to embed
/// widgets from one process into another process in a fashion that is
/// transparent to the user. One process creates a `gtk.Socket` widget
/// and passes the ID of that widget’s window to the other process,
/// which then creates a `gtk.Plug` with that window ID. Any widgets
/// contained in the `gtk.Plug` then will appear inside the first
/// application’s window.
///
/// The communication between a `gtk.Socket` and a `gtk.Plug` follows the
/// [XEmbed Protocol](http://www.freedesktop.org/Standards/xembed-spec).
/// This protocol has also been implemented in other toolkits, e.g. Qt,
/// allowing the same level of integration when embedding a Qt widget
/// in GTK+ or vice versa.
///
/// The `gtk.Plug` and `gtk.Socket` widgets are only available when GTK+
/// is compiled for the X11 platform and `GDK_WINDOWING_X11` is defined.
/// They can only be used on a `GdkX11Display`. To use `gtk.Plug` and
/// `gtk.Socket`, you need to include the `gtk/gtkx.h` header.
pub const Plug = extern struct {
    pub const Parent = gtk.Window;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.PlugClass;
    f_window: gtk.Window,
    f_priv: ?*gtk.PlugPrivate,

    pub const virtual_methods = struct {
        pub const embedded = struct {
            pub fn call(p_class: anytype, p_plug: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Plug.Class, p_class).f_embedded.?(gobject.ext.as(Plug, p_plug));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_plug: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Plug.Class, p_class).f_embedded = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// `TRUE` if the plug is embedded in a socket.
        pub const embedded = struct {
            pub const name = "embedded";

            pub const Type = c_int;
        };

        /// The window of the socket the plug is embedded in.
        pub const socket_window = struct {
            pub const name = "socket-window";

            pub const Type = ?*gdk.Window;
        };
    };

    pub const signals = struct {
        /// Gets emitted when the plug becomes embedded in a socket.
        pub const embedded = struct {
            pub const name = "embedded";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Plug, p_instance))),
                    gobject.signalLookup("embedded", Plug.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new plug widget inside the `gtk.Socket` identified
    /// by `socket_id`. If `socket_id` is 0, the plug is left “unplugged” and
    /// can later be plugged into a `gtk.Socket` by  `gtk.Socket.addId`.
    extern fn gtk_plug_new(p_socket_id: xlib.Window) *gtk.Plug;
    pub const new = gtk_plug_new;

    /// Create a new plug widget inside the `gtk.Socket` identified by socket_id.
    extern fn gtk_plug_new_for_display(p_display: *gdk.Display, p_socket_id: xlib.Window) *gtk.Plug;
    pub const newForDisplay = gtk_plug_new_for_display;

    /// Finish the initialization of `plug` for a given `gtk.Socket` identified by
    /// `socket_id`. This function will generally only be used by classes deriving from `gtk.Plug`.
    extern fn gtk_plug_construct(p_plug: *Plug, p_socket_id: xlib.Window) void;
    pub const construct = gtk_plug_construct;

    /// Finish the initialization of `plug` for a given `gtk.Socket` identified by
    /// `socket_id` which is currently displayed on `display`.
    /// This function will generally only be used by classes deriving from `gtk.Plug`.
    extern fn gtk_plug_construct_for_display(p_plug: *Plug, p_display: *gdk.Display, p_socket_id: xlib.Window) void;
    pub const constructForDisplay = gtk_plug_construct_for_display;

    /// Determines whether the plug is embedded in a socket.
    extern fn gtk_plug_get_embedded(p_plug: *Plug) c_int;
    pub const getEmbedded = gtk_plug_get_embedded;

    /// Gets the window ID of a `gtk.Plug` widget, which can then
    /// be used to embed this window inside another window, for
    /// instance with `gtk.Socket.addId`.
    extern fn gtk_plug_get_id(p_plug: *Plug) xlib.Window;
    pub const getId = gtk_plug_get_id;

    /// Retrieves the socket the plug is embedded in.
    extern fn gtk_plug_get_socket_window(p_plug: *Plug) ?*gdk.Window;
    pub const getSocketWindow = gtk_plug_get_socket_window;

    extern fn gtk_plug_get_type() usize;
    pub const getGObjectType = gtk_plug_get_type;

    extern fn g_object_ref(p_self: *gtk.Plug) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Plug) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Plug, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PlugAccessible = extern struct {
    pub const Parent = gtk.WindowAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Window };
    pub const Class = gtk.PlugAccessibleClass;
    f_parent: gtk.WindowAccessible,
    f_priv: ?*gtk.PlugAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_plug_accessible_get_id(p_plug: *PlugAccessible) [*:0]u8;
    pub const getId = gtk_plug_accessible_get_id;

    extern fn gtk_plug_accessible_get_type() usize;
    pub const getGObjectType = gtk_plug_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.PlugAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.PlugAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *PlugAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkPopover is a bubble-like context window, primarily meant to
/// provide context-dependent information or options. Popovers are
/// attached to a widget, passed at construction time on `gtk.Popover.new`,
/// or updated afterwards through `gtk.Popover.setRelativeTo`, by
/// default they will point to the whole widget area, although this
/// behavior can be changed through `gtk.Popover.setPointingTo`.
///
/// The position of a popover relative to the widget it is attached to
/// can also be changed through `gtk.Popover.setPosition`.
///
/// By default, `gtk.Popover` performs a GTK+ grab, in order to ensure
/// input events get redirected to it while it is shown, and also so
/// the popover is dismissed in the expected situations (clicks outside
/// the popover, or the Esc key being pressed). If no such modal behavior
/// is desired on a popover, `gtk.Popover.setModal` may be called on it
/// to tweak its behavior.
///
/// ## GtkPopover as menu replacement
///
/// GtkPopover is often used to replace menus. To facilitate this, it
/// supports being populated from a `gio.MenuModel`, using
/// `gtk.Popover.newFromModel`. In addition to all the regular menu
/// model features, this function supports rendering sections in the
/// model in a more compact form, as a row of icon buttons instead of
/// menu items.
///
/// To use this rendering, set the ”display-hint” attribute of the
/// section to ”horizontal-buttons” and set the icons of your items
/// with the ”verb-icon” attribute.
///
/// ```
/// <section>
///   <attribute name="display-hint">horizontal-buttons</attribute>
///   <item>
///     <attribute name="label">Cut</attribute>
///     <attribute name="action">app.cut</attribute>
///     <attribute name="verb-icon">edit-cut-symbolic</attribute>
///   </item>
///   <item>
///     <attribute name="label">Copy</attribute>
///     <attribute name="action">app.copy</attribute>
///     <attribute name="verb-icon">edit-copy-symbolic</attribute>
///   </item>
///   <item>
///     <attribute name="label">Paste</attribute>
///     <attribute name="action">app.paste</attribute>
///     <attribute name="verb-icon">edit-paste-symbolic</attribute>
///   </item>
/// </section>
/// ```
///
/// # CSS nodes
///
/// GtkPopover has a single css node called popover. It always gets the
/// .background style class and it gets the .menu style class if it is
/// menu-like (e.g. `gtk.PopoverMenu` or created using `gtk.Popover.newFromModel`.
///
/// Particular uses of GtkPopover, such as touch selection popups
/// or magnifiers in `gtk.Entry` or `gtk.TextView` get style classes
/// like .touch-selection or .magnifier to differentiate from
/// plain popovers.
pub const Popover = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.PopoverClass;
    f_parent_instance: gtk.Bin,
    f_priv: ?*gtk.PopoverPrivate,

    pub const virtual_methods = struct {
        pub const closed = struct {
            pub fn call(p_class: anytype, p_popover: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Popover.Class, p_class).f_closed.?(gobject.ext.as(Popover, p_popover));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_popover: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Popover.Class, p_class).f_closed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Sets a constraint for the popover position.
        pub const constrain_to = struct {
            pub const name = "constrain-to";

            pub const Type = gtk.PopoverConstraint;
        };

        /// Sets whether the popover is modal (so other elements in the window do not
        /// receive input while the popover is visible).
        pub const modal = struct {
            pub const name = "modal";

            pub const Type = c_int;
        };

        /// Marks a specific rectangle to be pointed.
        pub const pointing_to = struct {
            pub const name = "pointing-to";

            pub const Type = ?*gdk.Rectangle;
        };

        /// Sets the preferred position of the popover.
        pub const position = struct {
            pub const name = "position";

            pub const Type = gtk.PositionType;
        };

        /// Sets the attached widget.
        pub const relative_to = struct {
            pub const name = "relative-to";

            pub const Type = ?*gtk.Widget;
        };

        /// Whether show/hide transitions are enabled for this popover.
        pub const transitions_enabled = struct {
            pub const name = "transitions-enabled";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// This signal is emitted when the popover is dismissed either through
        /// API or user interaction.
        pub const closed = struct {
            pub const name = "closed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Popover, p_instance))),
                    gobject.signalLookup("closed", Popover.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new popover to point to `relative_to`
    extern fn gtk_popover_new(p_relative_to: ?*gtk.Widget) *gtk.Popover;
    pub const new = gtk_popover_new;

    /// Creates a `gtk.Popover` and populates it according to
    /// `model`. The popover is pointed to the `relative_to` widget.
    ///
    /// The created buttons are connected to actions found in the
    /// `gtk.ApplicationWindow` to which the popover belongs - typically
    /// by means of being attached to a widget that is contained within
    /// the `GtkApplicationWindows` widget hierarchy.
    ///
    /// Actions can also be added using `gtk.Widget.insertActionGroup`
    /// on the menus attach widget or on any of its parent widgets.
    extern fn gtk_popover_new_from_model(p_relative_to: ?*gtk.Widget, p_model: *gio.MenuModel) *gtk.Popover;
    pub const newFromModel = gtk_popover_new_from_model;

    /// Establishes a binding between a `gtk.Popover` and a `gio.MenuModel`.
    ///
    /// The contents of `popover` are removed and then refilled with menu items
    /// according to `model`.  When `model` changes, `popover` is updated.
    /// Calling this function twice on `popover` with different `model` will
    /// cause the first binding to be replaced with a binding to the new
    /// model. If `model` is `NULL` then any previous binding is undone and
    /// all children are removed.
    ///
    /// If `action_namespace` is non-`NULL` then the effect is as if all
    /// actions mentioned in the `model` have their names prefixed with the
    /// namespace, plus a dot.  For example, if the action “quit” is
    /// mentioned and `action_namespace` is “app” then the effective action
    /// name is “app.quit”.
    ///
    /// This function uses `gtk.Actionable` to define the action name and
    /// target values on the created menu items.  If you want to use an
    /// action group other than “app” and “win”, or if you want to use a
    /// `gtk.MenuShell` outside of a `gtk.ApplicationWindow`, then you will need
    /// to attach your own action group to the widget hierarchy using
    /// `gtk.Widget.insertActionGroup`.  As an example, if you created a
    /// group with a “quit” action and inserted it with the name “mygroup”
    /// then you would use the action name “mygroup.quit” in your
    /// `gio.MenuModel`.
    extern fn gtk_popover_bind_model(p_popover: *Popover, p_model: ?*gio.MenuModel, p_action_namespace: ?[*:0]const u8) void;
    pub const bindModel = gtk_popover_bind_model;

    /// Returns the constraint for placing this popover.
    /// See `gtk.Popover.setConstrainTo`.
    extern fn gtk_popover_get_constrain_to(p_popover: *Popover) gtk.PopoverConstraint;
    pub const getConstrainTo = gtk_popover_get_constrain_to;

    /// Gets the widget that should be set as the default while
    /// the popover is shown.
    extern fn gtk_popover_get_default_widget(p_popover: *Popover) ?*gtk.Widget;
    pub const getDefaultWidget = gtk_popover_get_default_widget;

    /// Returns whether the popover is modal, see gtk_popover_set_modal to
    /// see the implications of this.
    extern fn gtk_popover_get_modal(p_popover: *Popover) c_int;
    pub const getModal = gtk_popover_get_modal;

    /// If a rectangle to point to has been set, this function will
    /// return `TRUE` and fill in `rect` with such rectangle, otherwise
    /// it will return `FALSE` and fill in `rect` with the attached
    /// widget width and height if a widget exists, otherwise it will zero-out `rect`.
    extern fn gtk_popover_get_pointing_to(p_popover: *Popover, p_rect: *gdk.Rectangle) c_int;
    pub const getPointingTo = gtk_popover_get_pointing_to;

    /// Returns the preferred position of `popover`.
    extern fn gtk_popover_get_position(p_popover: *Popover) gtk.PositionType;
    pub const getPosition = gtk_popover_get_position;

    /// Returns the widget `popover` is currently attached to
    extern fn gtk_popover_get_relative_to(p_popover: *Popover) *gtk.Widget;
    pub const getRelativeTo = gtk_popover_get_relative_to;

    /// Returns whether show/hide transitions are enabled on this popover.
    extern fn gtk_popover_get_transitions_enabled(p_popover: *Popover) c_int;
    pub const getTransitionsEnabled = gtk_popover_get_transitions_enabled;

    /// Pops `popover` down.This is different than a `gtk.Widget.hide` call
    /// in that it shows the popover with a transition. If you want to hide
    /// the popover without a transition, use `gtk.Widget.hide`.
    extern fn gtk_popover_popdown(p_popover: *Popover) void;
    pub const popdown = gtk_popover_popdown;

    /// Pops `popover` up. This is different than a `gtk.Widget.show` call
    /// in that it shows the popover with a transition. If you want to show
    /// the popover without a transition, use `gtk.Widget.show`.
    extern fn gtk_popover_popup(p_popover: *Popover) void;
    pub const popup = gtk_popover_popup;

    /// Sets a constraint for positioning this popover.
    ///
    /// Note that not all platforms support placing popovers freely,
    /// and may already impose constraints.
    extern fn gtk_popover_set_constrain_to(p_popover: *Popover, p_constraint: gtk.PopoverConstraint) void;
    pub const setConstrainTo = gtk_popover_set_constrain_to;

    /// Sets the widget that should be set as default widget while
    /// the popover is shown (see `gtk.Window.setDefault`). `gtk.Popover`
    /// remembers the previous default widget and reestablishes it
    /// when the popover is dismissed.
    extern fn gtk_popover_set_default_widget(p_popover: *Popover, p_widget: ?*gtk.Widget) void;
    pub const setDefaultWidget = gtk_popover_set_default_widget;

    /// Sets whether `popover` is modal, a modal popover will grab all input
    /// within the toplevel and grab the keyboard focus on it when being
    /// displayed. Clicking outside the popover area or pressing Esc will
    /// dismiss the popover and ungrab input.
    extern fn gtk_popover_set_modal(p_popover: *Popover, p_modal: c_int) void;
    pub const setModal = gtk_popover_set_modal;

    /// Sets the rectangle that `popover` will point to, in the
    /// coordinate space of the widget `popover` is attached to,
    /// see `gtk.Popover.setRelativeTo`.
    extern fn gtk_popover_set_pointing_to(p_popover: *Popover, p_rect: *const gdk.Rectangle) void;
    pub const setPointingTo = gtk_popover_set_pointing_to;

    /// Sets the preferred position for `popover` to appear. If the `popover`
    /// is currently visible, it will be immediately updated.
    ///
    /// This preference will be respected where possible, although
    /// on lack of space (eg. if close to the window edges), the
    /// `gtk.Popover` may choose to appear on the opposite side
    extern fn gtk_popover_set_position(p_popover: *Popover, p_position: gtk.PositionType) void;
    pub const setPosition = gtk_popover_set_position;

    /// Sets a new widget to be attached to `popover`. If `popover` is
    /// visible, the position will be updated.
    ///
    /// Note: the ownership of popovers is always given to their `relative_to`
    /// widget, so if `relative_to` is set to `NULL` on an attached `popover`, it
    /// will be detached from its previous widget, and consequently destroyed
    /// unless extra references are kept.
    extern fn gtk_popover_set_relative_to(p_popover: *Popover, p_relative_to: ?*gtk.Widget) void;
    pub const setRelativeTo = gtk_popover_set_relative_to;

    /// Sets whether show/hide transitions are enabled on this popover
    extern fn gtk_popover_set_transitions_enabled(p_popover: *Popover, p_transitions_enabled: c_int) void;
    pub const setTransitionsEnabled = gtk_popover_set_transitions_enabled;

    extern fn gtk_popover_get_type() usize;
    pub const getGObjectType = gtk_popover_get_type;

    extern fn g_object_ref(p_self: *gtk.Popover) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Popover) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Popover, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PopoverAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{atk.Component};
    pub const Class = gtk.PopoverAccessibleClass;
    f_parent: gtk.ContainerAccessible,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_popover_accessible_get_type() usize;
    pub const getGObjectType = gtk_popover_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.PopoverAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.PopoverAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *PopoverAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkPopoverMenu is a subclass of `gtk.Popover` that treats its
/// children like menus and allows switching between them. It is
/// meant to be used primarily together with `gtk.ModelButton`, but
/// any widget can be used, such as `gtk.SpinButton` or `gtk.Scale`.
/// In this respect, GtkPopoverMenu is more flexible than popovers
/// that are created from a `gio.MenuModel` with `gtk.Popover.newFromModel`.
///
/// To add a child as a submenu, set the `gtk.PopoverMenu.properties.submenu`
/// child property to the name of the submenu. To let the user open
/// this submenu, add a `gtk.ModelButton` whose `gtk.ModelButton.properties.menu`-name
/// property is set to the name you've given to the submenu.
///
/// By convention, the first child of a submenu should be a `gtk.ModelButton`
/// to switch back to the parent menu. Such a button should use the
/// `gtk.ModelButton.properties.inverted` and `gtk.ModelButton.properties.centered` properties
/// to achieve a title-like appearance and place the submenu indicator
/// at the opposite side. To switch back to the main menu, use "main"
/// as the menu name.
///
/// # Example
///
/// ```
/// <object class="GtkPopoverMenu">
///   <child>
///     <object class="GtkBox">
///       <property name="visible">True</property>
///       <property name="margin">10</property>
///       <child>
///         <object class="GtkModelButton">
///           <property name="visible">True</property>
///           <property name="action-name">win.frob</property>
///           <property name="text" translatable="yes">Frob</property>
///         </object>
///       </child>
///       <child>
///         <object class="GtkModelButton">
///           <property name="visible">True</property>
///           <property name="menu-name">more</property>
///           <property name="text" translatable="yes">More</property>
///         </object>
///       </child>
///     </object>
///   </child>
///   <child>
///     <object class="GtkBox">
///       <property name="visible">True</property>
///       <property name="margin">10</property>
///       <child>
///         <object class="GtkModelButton">
///           <property name="visible">True</property>
///           <property name="action-name">win.foo</property>
///           <property name="text" translatable="yes">Foo</property>
///         </object>
///       </child>
///       <child>
///         <object class="GtkModelButton">
///           <property name="visible">True</property>
///           <property name="action-name">win.bar</property>
///           <property name="text" translatable="yes">Bar</property>
///         </object>
///       </child>
///     </object>
///     <packing>
///       <property name="submenu">more</property>
///     </packing>
///   </child>
/// </object>
/// ```
///
/// Just like normal popovers created using gtk_popover_new_from_model,
/// `gtk.PopoverMenu` instances have a single css node called "popover"
/// and get the .menu style class.
pub const PopoverMenu = opaque {
    pub const Parent = gtk.Popover;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.PopoverMenuClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const visible_submenu = struct {
            pub const name = "visible-submenu";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new popover menu.
    extern fn gtk_popover_menu_new() *gtk.PopoverMenu;
    pub const new = gtk_popover_menu_new;

    /// Opens a submenu of the `popover`. The `name`
    /// must be one of the names given to the submenus
    /// of `popover` with `gtk.PopoverMenu.properties.submenu`, or
    /// "main" to switch back to the main menu.
    ///
    /// `gtk.ModelButton` will open submenus automatically
    /// when the `gtk.ModelButton.properties.menu`-name property is set,
    /// so this function is only needed when you are using
    /// other kinds of widgets to initiate menu changes.
    extern fn gtk_popover_menu_open_submenu(p_popover: *PopoverMenu, p_name: [*:0]const u8) void;
    pub const openSubmenu = gtk_popover_menu_open_submenu;

    extern fn gtk_popover_menu_get_type() usize;
    pub const getGObjectType = gtk_popover_menu_get_type;

    extern fn g_object_ref(p_self: *gtk.PopoverMenu) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.PopoverMenu) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *PopoverMenu, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkPrintContext encapsulates context information that is required when
/// drawing pages for printing, such as the cairo context and important
/// parameters like page size and resolution. It also lets you easily
/// create `pango.Layout` and `pango.Context` objects that match the font metrics
/// of the cairo surface.
///
/// GtkPrintContext objects gets passed to the `gtk.PrintOperation.signals.begin`-print,
/// `gtk.PrintOperation.signals.end`-print, `gtk.PrintOperation.signals.request`-page-setup and
/// `gtk.PrintOperation.signals.draw`-page signals on the `gtk.PrintOperation`.
///
/// ## Using GtkPrintContext in a
///
/// ```
/// static void
/// draw_page (GtkPrintOperation *operation,
///        GtkPrintContext   *context,
///        int                page_nr)
/// {
///   cairo_t *cr;
///   PangoLayout *layout;
///   PangoFontDescription *desc;
///
///   cr = gtk_print_context_get_cairo_context (context);
///
///   // Draw a red rectangle, as wide as the paper (inside the margins)
///   cairo_set_source_rgb (cr, 1.0, 0, 0);
///   cairo_rectangle (cr, 0, 0, gtk_print_context_get_width (context), 50);
///
///   cairo_fill (cr);
///
///   // Draw some lines
///   cairo_move_to (cr, 20, 10);
///   cairo_line_to (cr, 40, 20);
///   cairo_arc (cr, 60, 60, 20, 0, M_PI);
///   cairo_line_to (cr, 80, 20);
///
///   cairo_set_source_rgb (cr, 0, 0, 0);
///   cairo_set_line_width (cr, 5);
///   cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
///   cairo_set_line_join (cr, CAIRO_LINE_JOIN_ROUND);
///
///   cairo_stroke (cr);
///
///   // Draw some text
///   layout = gtk_print_context_create_pango_layout (context);
///   pango_layout_set_text (layout, "Hello World! Printing is easy", -1);
///   desc = pango_font_description_from_string ("sans 28");
///   pango_layout_set_font_description (layout, desc);
///   pango_font_description_free (desc);
///
///   cairo_move_to (cr, 30, 20);
///   pango_cairo_layout_path (cr, layout);
///
///   // Font Outline
///   cairo_set_source_rgb (cr, 0.93, 1.0, 0.47);
///   cairo_set_line_width (cr, 0.5);
///   cairo_stroke_preserve (cr);
///
///   // Font Fill
///   cairo_set_source_rgb (cr, 0, 0.0, 1.0);
///   cairo_fill (cr);
///
///   g_object_unref (layout);
/// }
/// ```
///
/// Printing support was added in GTK+ 2.10.
pub const PrintContext = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = PrintContext;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `pango.Context` that can be used with the
    /// `gtk.PrintContext`.
    extern fn gtk_print_context_create_pango_context(p_context: *PrintContext) *pango.Context;
    pub const createPangoContext = gtk_print_context_create_pango_context;

    /// Creates a new `pango.Layout` that is suitable for use
    /// with the `gtk.PrintContext`.
    extern fn gtk_print_context_create_pango_layout(p_context: *PrintContext) *pango.Layout;
    pub const createPangoLayout = gtk_print_context_create_pango_layout;

    /// Obtains the cairo context that is associated with the
    /// `gtk.PrintContext`.
    extern fn gtk_print_context_get_cairo_context(p_context: *PrintContext) *cairo.Context;
    pub const getCairoContext = gtk_print_context_get_cairo_context;

    /// Obtains the horizontal resolution of the `gtk.PrintContext`,
    /// in dots per inch.
    extern fn gtk_print_context_get_dpi_x(p_context: *PrintContext) f64;
    pub const getDpiX = gtk_print_context_get_dpi_x;

    /// Obtains the vertical resolution of the `gtk.PrintContext`,
    /// in dots per inch.
    extern fn gtk_print_context_get_dpi_y(p_context: *PrintContext) f64;
    pub const getDpiY = gtk_print_context_get_dpi_y;

    /// Obtains the hardware printer margins of the `gtk.PrintContext`, in units.
    extern fn gtk_print_context_get_hard_margins(p_context: *PrintContext, p_top: *f64, p_bottom: *f64, p_left: *f64, p_right: *f64) c_int;
    pub const getHardMargins = gtk_print_context_get_hard_margins;

    /// Obtains the height of the `gtk.PrintContext`, in pixels.
    extern fn gtk_print_context_get_height(p_context: *PrintContext) f64;
    pub const getHeight = gtk_print_context_get_height;

    /// Obtains the `gtk.PageSetup` that determines the page
    /// dimensions of the `gtk.PrintContext`.
    extern fn gtk_print_context_get_page_setup(p_context: *PrintContext) *gtk.PageSetup;
    pub const getPageSetup = gtk_print_context_get_page_setup;

    /// Returns a `pango.FontMap` that is suitable for use
    /// with the `gtk.PrintContext`.
    extern fn gtk_print_context_get_pango_fontmap(p_context: *PrintContext) *pango.FontMap;
    pub const getPangoFontmap = gtk_print_context_get_pango_fontmap;

    /// Obtains the width of the `gtk.PrintContext`, in pixels.
    extern fn gtk_print_context_get_width(p_context: *PrintContext) f64;
    pub const getWidth = gtk_print_context_get_width;

    /// Sets a new cairo context on a print context.
    ///
    /// This function is intended to be used when implementing
    /// an internal print preview, it is not needed for printing,
    /// since GTK+ itself creates a suitable cairo context in that
    /// case.
    extern fn gtk_print_context_set_cairo_context(p_context: *PrintContext, p_cr: *cairo.Context, p_dpi_x: f64, p_dpi_y: f64) void;
    pub const setCairoContext = gtk_print_context_set_cairo_context;

    extern fn gtk_print_context_get_type() usize;
    pub const getGObjectType = gtk_print_context_get_type;

    extern fn g_object_ref(p_self: *gtk.PrintContext) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.PrintContext) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *PrintContext, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkPrintOperation is the high-level, portable printing API.
/// It looks a bit different than other GTK+ dialogs such as the
/// `gtk.FileChooser`, since some platforms don’t expose enough
/// infrastructure to implement a good print dialog. On such
/// platforms, GtkPrintOperation uses the native print dialog.
/// On platforms which do not provide a native print dialog, GTK+
/// uses its own, see `GtkPrintUnixDialog`.
///
/// The typical way to use the high-level printing API is to create
/// a GtkPrintOperation object with `gtk.PrintOperation.new` when
/// the user selects to print. Then you set some properties on it,
/// e.g. the page size, any `gtk.PrintSettings` from previous print
/// operations, the number of pages, the current page, etc.
///
/// Then you start the print operation by calling `gtk.PrintOperation.run`.
/// It will then show a dialog, let the user select a printer and
/// options. When the user finished the dialog various signals will
/// be emitted on the `gtk.PrintOperation`, the main one being
/// `gtk.PrintOperation.signals.draw`-page, which you are supposed to catch
/// and render the page on the provided `gtk.PrintContext` using Cairo.
///
/// # The high-level printing API
///
/// ```
/// static GtkPrintSettings *settings = NULL;
///
/// static void
/// do_print (void)
/// {
///   GtkPrintOperation *print;
///   GtkPrintOperationResult res;
///
///   print = gtk_print_operation_new ();
///
///   if (settings != NULL)
///     gtk_print_operation_set_print_settings (print, settings);
///
///   g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), NULL);
///   g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), NULL);
///
///   res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
///                                  GTK_WINDOW (main_window), NULL);
///
///   if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
///     {
///       if (settings != NULL)
///         g_object_unref (settings);
///       settings = g_object_ref (gtk_print_operation_get_print_settings (print));
///     }
///
///   g_object_unref (print);
/// }
/// ```
///
/// By default GtkPrintOperation uses an external application to do
/// print preview. To implement a custom print preview, an application
/// must connect to the preview signal. The functions
/// `gtk.PrintOperationPreview.renderPage`,
/// `gtk.PrintOperationPreview.endPreview` and
/// `gtk.PrintOperationPreview.isSelected`
/// are useful when implementing a print preview.
pub const PrintOperation = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gtk.PrintOperationPreview};
    pub const Class = gtk.PrintOperationClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.PrintOperationPrivate,

    pub const virtual_methods = struct {
        /// Signal emitted after the user has finished changing
        ///    print settings in the dialog, before the actual rendering starts.
        pub const begin_print = struct {
            pub fn call(p_class: anytype, p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.PrintContext) void {
                return gobject.ext.as(PrintOperation.Class, p_class).f_begin_print.?(gobject.ext.as(PrintOperation, p_operation), p_context);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.PrintContext) callconv(.c) void) void {
                gobject.ext.as(PrintOperation.Class, p_class).f_begin_print = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when displaying the print dialog.
        pub const create_custom_widget = struct {
            pub fn call(p_class: anytype, p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gtk.Widget {
                return gobject.ext.as(PrintOperation.Class, p_class).f_create_custom_widget.?(gobject.ext.as(PrintOperation, p_operation));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gtk.Widget) void {
                gobject.ext.as(PrintOperation.Class, p_class).f_create_custom_widget = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted right before “begin-print” if
        ///    you added a custom widget in the “create-custom-widget” handler.
        pub const custom_widget_apply = struct {
            pub fn call(p_class: anytype, p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget) void {
                return gobject.ext.as(PrintOperation.Class, p_class).f_custom_widget_apply.?(gobject.ext.as(PrintOperation, p_operation), p_widget);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(PrintOperation.Class, p_class).f_custom_widget_apply = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the print operation run has finished
        ///    doing everything required for printing.
        pub const done = struct {
            pub fn call(p_class: anytype, p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: gtk.PrintOperationResult) void {
                return gobject.ext.as(PrintOperation.Class, p_class).f_done.?(gobject.ext.as(PrintOperation, p_operation), p_result);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: gtk.PrintOperationResult) callconv(.c) void) void {
                gobject.ext.as(PrintOperation.Class, p_class).f_done = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted for every page that is printed.
        pub const draw_page = struct {
            pub fn call(p_class: anytype, p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.PrintContext, p_page_nr: c_int) void {
                return gobject.ext.as(PrintOperation.Class, p_class).f_draw_page.?(gobject.ext.as(PrintOperation, p_operation), p_context, p_page_nr);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.PrintContext, p_page_nr: c_int) callconv(.c) void) void {
                gobject.ext.as(PrintOperation.Class, p_class).f_draw_page = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted after all pages have been rendered.
        pub const end_print = struct {
            pub fn call(p_class: anytype, p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.PrintContext) void {
                return gobject.ext.as(PrintOperation.Class, p_class).f_end_print.?(gobject.ext.as(PrintOperation, p_operation), p_context);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.PrintContext) callconv(.c) void) void {
                gobject.ext.as(PrintOperation.Class, p_class).f_end_print = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted after the “begin-print” signal, but
        ///    before the actual rendering starts.
        pub const paginate = struct {
            pub fn call(p_class: anytype, p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.PrintContext) c_int {
                return gobject.ext.as(PrintOperation.Class, p_class).f_paginate.?(gobject.ext.as(PrintOperation, p_operation), p_context);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.PrintContext) callconv(.c) c_int) void {
                gobject.ext.as(PrintOperation.Class, p_class).f_paginate = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when a preview is requested from the
        ///    native dialog.
        pub const preview = struct {
            pub fn call(p_class: anytype, p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_preview: *gtk.PrintOperationPreview, p_context: *gtk.PrintContext, p_parent: *gtk.Window) c_int {
                return gobject.ext.as(PrintOperation.Class, p_class).f_preview.?(gobject.ext.as(PrintOperation, p_operation), p_preview, p_context, p_parent);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_preview: *gtk.PrintOperationPreview, p_context: *gtk.PrintContext, p_parent: *gtk.Window) callconv(.c) c_int) void {
                gobject.ext.as(PrintOperation.Class, p_class).f_preview = @ptrCast(p_implementation);
            }
        };

        /// Emitted once for every page that is printed,
        ///    to give the application a chance to modify the page setup.
        pub const request_page_setup = struct {
            pub fn call(p_class: anytype, p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.PrintContext, p_page_nr: c_int, p_setup: *gtk.PageSetup) void {
                return gobject.ext.as(PrintOperation.Class, p_class).f_request_page_setup.?(gobject.ext.as(PrintOperation, p_operation), p_context, p_page_nr, p_setup);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.PrintContext, p_page_nr: c_int, p_setup: *gtk.PageSetup) callconv(.c) void) void {
                gobject.ext.as(PrintOperation.Class, p_class).f_request_page_setup = @ptrCast(p_implementation);
            }
        };

        /// Emitted at between the various phases of the print
        ///    operation.
        pub const status_changed = struct {
            pub fn call(p_class: anytype, p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(PrintOperation.Class, p_class).f_status_changed.?(gobject.ext.as(PrintOperation, p_operation));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(PrintOperation.Class, p_class).f_status_changed = @ptrCast(p_implementation);
            }
        };

        /// Emitted after change of selected printer.
        pub const update_custom_widget = struct {
            pub fn call(p_class: anytype, p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_setup: *gtk.PageSetup, p_settings: *gtk.PrintSettings) void {
                return gobject.ext.as(PrintOperation.Class, p_class).f_update_custom_widget.?(gobject.ext.as(PrintOperation, p_operation), p_widget, p_setup, p_settings);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_operation: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget, p_setup: *gtk.PageSetup, p_settings: *gtk.PrintSettings) callconv(.c) void) void {
                gobject.ext.as(PrintOperation.Class, p_class).f_update_custom_widget = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Determines whether the print operation may run asynchronously or not.
        ///
        /// Some systems don't support asynchronous printing, but those that do
        /// will return `GTK_PRINT_OPERATION_RESULT_IN_PROGRESS` as the status, and
        /// emit the `gtk.PrintOperation.signals.done` signal when the operation is actually
        /// done.
        ///
        /// The Windows port does not support asynchronous operation at all (this
        /// is unlikely to change). On other platforms, all actions except for
        /// `GTK_PRINT_OPERATION_ACTION_EXPORT` support asynchronous operation.
        pub const allow_async = struct {
            pub const name = "allow-async";

            pub const Type = c_int;
        };

        /// The current page in the document.
        ///
        /// If this is set before `gtk.PrintOperation.run`,
        /// the user will be able to select to print only the current page.
        ///
        /// Note that this only makes sense for pre-paginated documents.
        pub const current_page = struct {
            pub const name = "current-page";

            pub const Type = c_int;
        };

        /// Used as the label of the tab containing custom widgets.
        /// Note that this property may be ignored on some platforms.
        ///
        /// If this is `NULL`, GTK+ uses a default label.
        pub const custom_tab_label = struct {
            pub const name = "custom-tab-label";

            pub const Type = ?[*:0]u8;
        };

        /// The `gtk.PageSetup` used by default.
        ///
        /// This page setup will be used by `gtk.PrintOperation.run`,
        /// but it can be overridden on a per-page basis by connecting
        /// to the `gtk.PrintOperation.signals.request`-page-setup signal.
        pub const default_page_setup = struct {
            pub const name = "default-page-setup";

            pub const Type = ?*gtk.PageSetup;
        };

        /// If `TRUE`, page size combo box and orientation combo box are embedded into page setup page.
        pub const embed_page_setup = struct {
            pub const name = "embed-page-setup";

            pub const Type = c_int;
        };

        /// The name of a file to generate instead of showing the print dialog.
        /// Currently, PDF is the only supported format.
        ///
        /// The intended use of this property is for implementing
        /// “Export to PDF” actions.
        ///
        /// “Print to PDF” support is independent of this and is done
        /// by letting the user pick the “Print to PDF” item from the
        /// list of printers in the print dialog.
        pub const export_filename = struct {
            pub const name = "export-filename";

            pub const Type = ?[*:0]u8;
        };

        /// Determines whether there is a selection in your application.
        /// This can allow your application to print the selection.
        /// This is typically used to make a "Selection" button sensitive.
        pub const has_selection = struct {
            pub const name = "has-selection";

            pub const Type = c_int;
        };

        /// A string used to identify the job (e.g. in monitoring
        /// applications like eggcups).
        ///
        /// If you don't set a job name, GTK+ picks a default one
        /// by numbering successive print jobs.
        pub const job_name = struct {
            pub const name = "job-name";

            pub const Type = ?[*:0]u8;
        };

        /// The number of pages in the document.
        ///
        /// This must be set to a positive number
        /// before the rendering starts. It may be set in a
        /// `gtk.PrintOperation.signals.begin`-print signal hander.
        ///
        /// Note that the page numbers passed to the
        /// `gtk.PrintOperation.signals.request`-page-setup and
        /// `gtk.PrintOperation.signals.draw`-page signals are 0-based, i.e. if
        /// the user chooses to print all pages, the last ::draw-page signal
        /// will be for page `n_pages` - 1.
        pub const n_pages = struct {
            pub const name = "n-pages";

            pub const Type = c_int;
        };

        /// The number of pages that will be printed.
        ///
        /// Note that this value is set during print preparation phase
        /// (`GTK_PRINT_STATUS_PREPARING`), so this value should never be
        /// get before the data generation phase (`GTK_PRINT_STATUS_GENERATING_DATA`).
        /// You can connect to the `gtk.PrintOperation.signals.status`-changed signal
        /// and call `gtk.PrintOperation.getNPagesToPrint` when
        /// print status is `GTK_PRINT_STATUS_GENERATING_DATA`.
        /// This is typically used to track the progress of print operation.
        pub const n_pages_to_print = struct {
            pub const name = "n-pages-to-print";

            pub const Type = c_int;
        };

        /// The `gtk.PrintSettings` used for initializing the dialog.
        ///
        /// Setting this property is typically used to re-establish
        /// print settings from a previous print operation, see
        /// `gtk.PrintOperation.run`.
        pub const print_settings = struct {
            pub const name = "print-settings";

            pub const Type = ?*gtk.PrintSettings;
        };

        /// Determines whether to show a progress dialog during the
        /// print operation.
        pub const show_progress = struct {
            pub const name = "show-progress";

            pub const Type = c_int;
        };

        /// The status of the print operation.
        pub const status = struct {
            pub const name = "status";

            pub const Type = gtk.PrintStatus;
        };

        /// A string representation of the status of the print operation.
        /// The string is translated and suitable for displaying the print
        /// status e.g. in a `gtk.Statusbar`.
        ///
        /// See the `gtk.PrintOperation.properties.status` property for a status value that
        /// is suitable for programmatic use.
        pub const status_string = struct {
            pub const name = "status-string";

            pub const Type = ?[*:0]u8;
        };

        /// If `TRUE`, the print operation will support print of selection.
        /// This allows the print dialog to show a "Selection" button.
        pub const support_selection = struct {
            pub const name = "support-selection";

            pub const Type = c_int;
        };

        /// If `TRUE`, the print operation will try to continue report on
        /// the status of the print job in the printer queues and printer.
        /// This can allow your application to show things like “out of paper”
        /// issues, and when the print job actually reaches the printer.
        /// However, this is often implemented using polling, and should
        /// not be enabled unless needed.
        pub const track_print_status = struct {
            pub const name = "track-print-status";

            pub const Type = c_int;
        };

        /// The transformation for the cairo context obtained from
        /// `gtk.PrintContext` is set up in such a way that distances
        /// are measured in units of `unit`.
        pub const unit = struct {
            pub const name = "unit";

            pub const Type = gtk.Unit;
        };

        /// If `TRUE`, the transformation for the cairo context obtained
        /// from `gtk.PrintContext` puts the origin at the top left corner
        /// of the page (which may not be the top left corner of the sheet,
        /// depending on page orientation and the number of pages per sheet).
        /// Otherwise, the origin is at the top left corner of the imageable
        /// area (i.e. inside the margins).
        pub const use_full_page = struct {
            pub const name = "use-full-page";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted after the user has finished changing print settings
        /// in the dialog, before the actual rendering starts.
        ///
        /// A typical use for ::begin-print is to use the parameters from the
        /// `gtk.PrintContext` and paginate the document accordingly, and then
        /// set the number of pages with `gtk.PrintOperation.setNPages`.
        pub const begin_print = struct {
            pub const name = "begin-print";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gtk.PrintContext, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PrintOperation, p_instance))),
                    gobject.signalLookup("begin-print", PrintOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when displaying the print dialog. If you return a
        /// widget in a handler for this signal it will be added to a custom
        /// tab in the print dialog. You typically return a container widget
        /// with multiple widgets in it.
        ///
        /// The print dialog owns the returned widget, and its lifetime is not
        /// controlled by the application. However, the widget is guaranteed
        /// to stay around until the `gtk.PrintOperation.signals.custom`-widget-apply
        /// signal is emitted on the operation. Then you can read out any
        /// information you need from the widgets.
        pub const create_custom_widget = struct {
            pub const name = "create-custom-widget";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) *gobject.Object, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PrintOperation, p_instance))),
                    gobject.signalLookup("create-custom-widget", PrintOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted right before `gtk.PrintOperation.signals.begin`-print if you added
        /// a custom widget in the `gtk.PrintOperation.signals.create`-custom-widget handler.
        /// When you get this signal you should read the information from the
        /// custom widgets, as the widgets are not guaraneed to be around at a
        /// later time.
        pub const custom_widget_apply = struct {
            pub const name = "custom-widget-apply";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_widget: *gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PrintOperation, p_instance))),
                    gobject.signalLookup("custom-widget-apply", PrintOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the print operation run has finished doing
        /// everything required for printing.
        ///
        /// `result` gives you information about what happened during the run.
        /// If `result` is `GTK_PRINT_OPERATION_RESULT_ERROR` then you can call
        /// `gtk.PrintOperation.getError` for more information.
        ///
        /// If you enabled print status tracking then
        /// `gtk.PrintOperation.isFinished` may still return `FALSE`
        /// after `gtk.PrintOperation.signals.done` was emitted.
        pub const done = struct {
            pub const name = "done";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_result: gtk.PrintOperationResult, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PrintOperation, p_instance))),
                    gobject.signalLookup("done", PrintOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted for every page that is printed. The signal handler
        /// must render the `page_nr`'s page onto the cairo context obtained
        /// from `context` using `gtk.PrintContext.getCairoContext`.
        /// ```
        /// static void
        /// draw_page (GtkPrintOperation *operation,
        ///            GtkPrintContext   *context,
        ///            gint               page_nr,
        ///            gpointer           user_data)
        /// {
        ///   cairo_t *cr;
        ///   PangoLayout *layout;
        ///   gdouble width, text_height;
        ///   gint layout_height;
        ///   PangoFontDescription *desc;
        ///
        ///   cr = gtk_print_context_get_cairo_context (context);
        ///   width = gtk_print_context_get_width (context);
        ///
        ///   cairo_rectangle (cr, 0, 0, width, HEADER_HEIGHT);
        ///
        ///   cairo_set_source_rgb (cr, 0.8, 0.8, 0.8);
        ///   cairo_fill (cr);
        ///
        ///   layout = gtk_print_context_create_pango_layout (context);
        ///
        ///   desc = pango_font_description_from_string ("sans 14");
        ///   pango_layout_set_font_description (layout, desc);
        ///   pango_font_description_free (desc);
        ///
        ///   pango_layout_set_text (layout, "some text", -1);
        ///   pango_layout_set_width (layout, width * PANGO_SCALE);
        ///   pango_layout_set_alignment (layout, PANGO_ALIGN_CENTER);
        ///
        ///   pango_layout_get_size (layout, NULL, &layout_height);
        ///   text_height = (gdouble)layout_height / PANGO_SCALE;
        ///
        ///   cairo_move_to (cr, width / 2,  (HEADER_HEIGHT - text_height) / 2);
        ///   pango_cairo_show_layout (cr, layout);
        ///
        ///   g_object_unref (layout);
        /// }
        /// ```
        ///
        /// Use `gtk.PrintOperation.setUseFullPage` and
        /// `gtk.PrintOperation.setUnit` before starting the print operation
        /// to set up the transformation of the cairo context according to your
        /// needs.
        pub const draw_page = struct {
            pub const name = "draw-page";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gtk.PrintContext, p_page_nr: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PrintOperation, p_instance))),
                    gobject.signalLookup("draw-page", PrintOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted after all pages have been rendered.
        /// A handler for this signal can clean up any resources that have
        /// been allocated in the `gtk.PrintOperation.signals.begin`-print handler.
        pub const end_print = struct {
            pub const name = "end-print";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gtk.PrintContext, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PrintOperation, p_instance))),
                    gobject.signalLookup("end-print", PrintOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted after the `gtk.PrintOperation.signals.begin`-print signal, but before
        /// the actual rendering starts. It keeps getting emitted until a connected
        /// signal handler returns `TRUE`.
        ///
        /// The ::paginate signal is intended to be used for paginating a document
        /// in small chunks, to avoid blocking the user interface for a long
        /// time. The signal handler should update the number of pages using
        /// `gtk.PrintOperation.setNPages`, and return `TRUE` if the document
        /// has been completely paginated.
        ///
        /// If you don't need to do pagination in chunks, you can simply do
        /// it all in the ::begin-print handler, and set the number of pages
        /// from there.
        pub const paginate = struct {
            pub const name = "paginate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gtk.PrintContext, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PrintOperation, p_instance))),
                    gobject.signalLookup("paginate", PrintOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Gets emitted when a preview is requested from the native dialog.
        ///
        /// The default handler for this signal uses an external viewer
        /// application to preview.
        ///
        /// To implement a custom print preview, an application must return
        /// `TRUE` from its handler for this signal. In order to use the
        /// provided `context` for the preview implementation, it must be
        /// given a suitable cairo context with `gtk.PrintContext.setCairoContext`.
        ///
        /// The custom preview implementation can use
        /// `gtk.PrintOperationPreview.isSelected` and
        /// `gtk.PrintOperationPreview.renderPage` to find pages which
        /// are selected for print and render them. The preview must be
        /// finished by calling `gtk.PrintOperationPreview.endPreview`
        /// (typically in response to the user clicking a close button).
        pub const preview = struct {
            pub const name = "preview";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_preview: *gtk.PrintOperationPreview, p_context: *gtk.PrintContext, p_parent: ?*gtk.Window, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PrintOperation, p_instance))),
                    gobject.signalLookup("preview", PrintOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted once for every page that is printed, to give
        /// the application a chance to modify the page setup. Any changes
        /// done to `setup` will be in force only for printing this page.
        pub const request_page_setup = struct {
            pub const name = "request-page-setup";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gtk.PrintContext, p_page_nr: c_int, p_setup: *gtk.PageSetup, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PrintOperation, p_instance))),
                    gobject.signalLookup("request-page-setup", PrintOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted at between the various phases of the print operation.
        /// See `gtk.PrintStatus` for the phases that are being discriminated.
        /// Use `gtk.PrintOperation.getStatus` to find out the current
        /// status.
        pub const status_changed = struct {
            pub const name = "status-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PrintOperation, p_instance))),
                    gobject.signalLookup("status-changed", PrintOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted after change of selected printer. The actual page setup and
        /// print settings are passed to the custom widget, which can actualize
        /// itself according to this change.
        pub const update_custom_widget = struct {
            pub const name = "update-custom-widget";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_widget: *gtk.Widget, p_setup: *gtk.PageSetup, p_settings: *gtk.PrintSettings, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PrintOperation, p_instance))),
                    gobject.signalLookup("update-custom-widget", PrintOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.PrintOperation`.
    extern fn gtk_print_operation_new() *gtk.PrintOperation;
    pub const new = gtk_print_operation_new;

    /// Cancels a running print operation. This function may
    /// be called from a `gtk.PrintOperation.signals.begin`-print,
    /// `gtk.PrintOperation.signals.paginate` or `gtk.PrintOperation.signals.draw`-page
    /// signal handler to stop the currently running print
    /// operation.
    extern fn gtk_print_operation_cancel(p_op: *PrintOperation) void;
    pub const cancel = gtk_print_operation_cancel;

    /// Signalize that drawing of particular page is complete.
    ///
    /// It is called after completion of page drawing (e.g. drawing in another
    /// thread).
    /// If `gtk.PrintOperation.setDeferDrawing` was called before, then this function
    /// has to be called by application. In another case it is called by the library
    /// itself.
    extern fn gtk_print_operation_draw_page_finish(p_op: *PrintOperation) void;
    pub const drawPageFinish = gtk_print_operation_draw_page_finish;

    /// Returns the default page setup, see
    /// `gtk.PrintOperation.setDefaultPageSetup`.
    extern fn gtk_print_operation_get_default_page_setup(p_op: *PrintOperation) *gtk.PageSetup;
    pub const getDefaultPageSetup = gtk_print_operation_get_default_page_setup;

    /// Gets the value of `gtk.PrintOperation.properties.embed`-page-setup property.
    extern fn gtk_print_operation_get_embed_page_setup(p_op: *PrintOperation) c_int;
    pub const getEmbedPageSetup = gtk_print_operation_get_embed_page_setup;

    /// Call this when the result of a print operation is
    /// `GTK_PRINT_OPERATION_RESULT_ERROR`, either as returned by
    /// `gtk.PrintOperation.run`, or in the `gtk.PrintOperation.signals.done` signal
    /// handler. The returned `glib.Error` will contain more details on what went wrong.
    extern fn gtk_print_operation_get_error(p_op: *PrintOperation, p_error: ?*?*glib.Error) void;
    pub const getError = gtk_print_operation_get_error;

    /// Gets the value of `gtk.PrintOperation.properties.has`-selection property.
    extern fn gtk_print_operation_get_has_selection(p_op: *PrintOperation) c_int;
    pub const getHasSelection = gtk_print_operation_get_has_selection;

    /// Returns the number of pages that will be printed.
    ///
    /// Note that this value is set during print preparation phase
    /// (`GTK_PRINT_STATUS_PREPARING`), so this function should never be
    /// called before the data generation phase (`GTK_PRINT_STATUS_GENERATING_DATA`).
    /// You can connect to the `gtk.PrintOperation.signals.status`-changed signal
    /// and call `gtk.PrintOperation.getNPagesToPrint` when
    /// print status is `GTK_PRINT_STATUS_GENERATING_DATA`.
    /// This is typically used to track the progress of print operation.
    extern fn gtk_print_operation_get_n_pages_to_print(p_op: *PrintOperation) c_int;
    pub const getNPagesToPrint = gtk_print_operation_get_n_pages_to_print;

    /// Returns the current print settings.
    ///
    /// Note that the return value is `NULL` until either
    /// `gtk.PrintOperation.setPrintSettings` or
    /// `gtk.PrintOperation.run` have been called.
    extern fn gtk_print_operation_get_print_settings(p_op: *PrintOperation) *gtk.PrintSettings;
    pub const getPrintSettings = gtk_print_operation_get_print_settings;

    /// Returns the status of the print operation.
    /// Also see `gtk.PrintOperation.getStatusString`.
    extern fn gtk_print_operation_get_status(p_op: *PrintOperation) gtk.PrintStatus;
    pub const getStatus = gtk_print_operation_get_status;

    /// Returns a string representation of the status of the
    /// print operation. The string is translated and suitable
    /// for displaying the print status e.g. in a `gtk.Statusbar`.
    ///
    /// Use `gtk.PrintOperation.getStatus` to obtain a status
    /// value that is suitable for programmatic use.
    extern fn gtk_print_operation_get_status_string(p_op: *PrintOperation) [*:0]const u8;
    pub const getStatusString = gtk_print_operation_get_status_string;

    /// Gets the value of `gtk.PrintOperation.properties.support`-selection property.
    extern fn gtk_print_operation_get_support_selection(p_op: *PrintOperation) c_int;
    pub const getSupportSelection = gtk_print_operation_get_support_selection;

    /// A convenience function to find out if the print operation
    /// is finished, either successfully (`GTK_PRINT_STATUS_FINISHED`)
    /// or unsuccessfully (`GTK_PRINT_STATUS_FINISHED_ABORTED`).
    ///
    /// Note: when you enable print status tracking the print operation
    /// can be in a non-finished state even after done has been called, as
    /// the operation status then tracks the print job status on the printer.
    extern fn gtk_print_operation_is_finished(p_op: *PrintOperation) c_int;
    pub const isFinished = gtk_print_operation_is_finished;

    /// Runs the print operation, by first letting the user modify
    /// print settings in the print dialog, and then print the document.
    ///
    /// Normally that this function does not return until the rendering of all
    /// pages is complete. You can connect to the
    /// `gtk.PrintOperation.signals.status`-changed signal on `op` to obtain some
    /// information about the progress of the print operation.
    /// Furthermore, it may use a recursive mainloop to show the print dialog.
    ///
    /// If you call `gtk.PrintOperation.setAllowAsync` or set the
    /// `gtk.PrintOperation.properties.allow`-async property the operation will run
    /// asynchronously if this is supported on the platform. The
    /// `gtk.PrintOperation.signals.done` signal will be emitted with the result of the
    /// operation when the it is done (i.e. when the dialog is canceled, or when
    /// the print succeeds or fails).
    /// ```
    /// if (settings != NULL)
    ///   gtk_print_operation_set_print_settings (print, settings);
    ///
    /// if (page_setup != NULL)
    ///   gtk_print_operation_set_default_page_setup (print, page_setup);
    ///
    /// g_signal_connect (print, "begin-print",
    ///                   G_CALLBACK (begin_print), &data);
    /// g_signal_connect (print, "draw-page",
    ///                   G_CALLBACK (draw_page), &data);
    ///
    /// res = gtk_print_operation_run (print,
    ///                                GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
    ///                                parent,
    ///                                &error);
    ///
    /// if (res == GTK_PRINT_OPERATION_RESULT_ERROR)
    ///  {
    ///    error_dialog = gtk_message_dialog_new (GTK_WINDOW (parent),
    ///                                    GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                          GTK_MESSAGE_ERROR,
    ///                          GTK_BUTTONS_CLOSE,
    ///                          "Error printing file:\n`s`",
    ///                          error->message);
    ///    g_signal_connect (error_dialog, "response",
    ///                      G_CALLBACK (gtk_widget_destroy), NULL);
    ///    gtk_widget_show (error_dialog);
    ///    g_error_free (error);
    ///  }
    /// else if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
    ///  {
    ///    if (settings != NULL)
    /// g_object_unref (settings);
    ///    settings = g_object_ref (gtk_print_operation_get_print_settings (print));
    ///  }
    /// ```
    ///
    /// Note that `gtk.PrintOperation.run` can only be called once on a
    /// given `gtk.PrintOperation`.
    extern fn gtk_print_operation_run(p_op: *PrintOperation, p_action: gtk.PrintOperationAction, p_parent: ?*gtk.Window, p_error: ?*?*glib.Error) gtk.PrintOperationResult;
    pub const run = gtk_print_operation_run;

    /// Sets whether the `gtk.PrintOperation.run` may return
    /// before the print operation is completed. Note that
    /// some platforms may not allow asynchronous operation.
    extern fn gtk_print_operation_set_allow_async(p_op: *PrintOperation, p_allow_async: c_int) void;
    pub const setAllowAsync = gtk_print_operation_set_allow_async;

    /// Sets the current page.
    ///
    /// If this is called before `gtk.PrintOperation.run`,
    /// the user will be able to select to print only the current page.
    ///
    /// Note that this only makes sense for pre-paginated documents.
    extern fn gtk_print_operation_set_current_page(p_op: *PrintOperation, p_current_page: c_int) void;
    pub const setCurrentPage = gtk_print_operation_set_current_page;

    /// Sets the label for the tab holding custom widgets.
    extern fn gtk_print_operation_set_custom_tab_label(p_op: *PrintOperation, p_label: ?[*:0]const u8) void;
    pub const setCustomTabLabel = gtk_print_operation_set_custom_tab_label;

    /// Makes `default_page_setup` the default page setup for `op`.
    ///
    /// This page setup will be used by `gtk.PrintOperation.run`,
    /// but it can be overridden on a per-page basis by connecting
    /// to the `gtk.PrintOperation.signals.request`-page-setup signal.
    extern fn gtk_print_operation_set_default_page_setup(p_op: *PrintOperation, p_default_page_setup: ?*gtk.PageSetup) void;
    pub const setDefaultPageSetup = gtk_print_operation_set_default_page_setup;

    /// Sets up the `gtk.PrintOperation` to wait for calling of
    /// `gtk.PrintOperation.drawPageFinish` from application. It can
    /// be used for drawing page in another thread.
    ///
    /// This function must be called in the callback of “draw-page” signal.
    extern fn gtk_print_operation_set_defer_drawing(p_op: *PrintOperation) void;
    pub const setDeferDrawing = gtk_print_operation_set_defer_drawing;

    /// Embed page size combo box and orientation combo box into page setup page.
    /// Selected page setup is stored as default page setup in `gtk.PrintOperation`.
    extern fn gtk_print_operation_set_embed_page_setup(p_op: *PrintOperation, p_embed: c_int) void;
    pub const setEmbedPageSetup = gtk_print_operation_set_embed_page_setup;

    /// Sets up the `gtk.PrintOperation` to generate a file instead
    /// of showing the print dialog. The indended use of this function
    /// is for implementing “Export to PDF” actions. Currently, PDF
    /// is the only supported format.
    ///
    /// “Print to PDF” support is independent of this and is done
    /// by letting the user pick the “Print to PDF” item from the list
    /// of printers in the print dialog.
    extern fn gtk_print_operation_set_export_filename(p_op: *PrintOperation, p_filename: [*:0]const u8) void;
    pub const setExportFilename = gtk_print_operation_set_export_filename;

    /// Sets whether there is a selection to print.
    ///
    /// Application has to set number of pages to which the selection
    /// will draw by `gtk.PrintOperation.setNPages` in a callback of
    /// `gtk.PrintOperation.signals.begin`-print.
    extern fn gtk_print_operation_set_has_selection(p_op: *PrintOperation, p_has_selection: c_int) void;
    pub const setHasSelection = gtk_print_operation_set_has_selection;

    /// Sets the name of the print job. The name is used to identify
    /// the job (e.g. in monitoring applications like eggcups).
    ///
    /// If you don’t set a job name, GTK+ picks a default one by
    /// numbering successive print jobs.
    extern fn gtk_print_operation_set_job_name(p_op: *PrintOperation, p_job_name: [*:0]const u8) void;
    pub const setJobName = gtk_print_operation_set_job_name;

    /// Sets the number of pages in the document.
    ///
    /// This must be set to a positive number
    /// before the rendering starts. It may be set in a
    /// `gtk.PrintOperation.signals.begin`-print signal hander.
    ///
    /// Note that the page numbers passed to the
    /// `gtk.PrintOperation.signals.request`-page-setup
    /// and `gtk.PrintOperation.signals.draw`-page signals are 0-based, i.e. if
    /// the user chooses to print all pages, the last ::draw-page signal
    /// will be for page `n_pages` - 1.
    extern fn gtk_print_operation_set_n_pages(p_op: *PrintOperation, p_n_pages: c_int) void;
    pub const setNPages = gtk_print_operation_set_n_pages;

    /// Sets the print settings for `op`. This is typically used to
    /// re-establish print settings from a previous print operation,
    /// see `gtk.PrintOperation.run`.
    extern fn gtk_print_operation_set_print_settings(p_op: *PrintOperation, p_print_settings: ?*gtk.PrintSettings) void;
    pub const setPrintSettings = gtk_print_operation_set_print_settings;

    /// If `show_progress` is `TRUE`, the print operation will show a
    /// progress dialog during the print operation.
    extern fn gtk_print_operation_set_show_progress(p_op: *PrintOperation, p_show_progress: c_int) void;
    pub const setShowProgress = gtk_print_operation_set_show_progress;

    /// Sets whether selection is supported by `gtk.PrintOperation`.
    extern fn gtk_print_operation_set_support_selection(p_op: *PrintOperation, p_support_selection: c_int) void;
    pub const setSupportSelection = gtk_print_operation_set_support_selection;

    /// If track_status is `TRUE`, the print operation will try to continue report
    /// on the status of the print job in the printer queues and printer. This
    /// can allow your application to show things like “out of paper” issues,
    /// and when the print job actually reaches the printer.
    ///
    /// This function is often implemented using some form of polling, so it should
    /// not be enabled unless needed.
    extern fn gtk_print_operation_set_track_print_status(p_op: *PrintOperation, p_track_status: c_int) void;
    pub const setTrackPrintStatus = gtk_print_operation_set_track_print_status;

    /// Sets up the transformation for the cairo context obtained from
    /// `gtk.PrintContext` in such a way that distances are measured in
    /// units of `unit`.
    extern fn gtk_print_operation_set_unit(p_op: *PrintOperation, p_unit: gtk.Unit) void;
    pub const setUnit = gtk_print_operation_set_unit;

    /// If `full_page` is `TRUE`, the transformation for the cairo context
    /// obtained from `gtk.PrintContext` puts the origin at the top left
    /// corner of the page (which may not be the top left corner of the
    /// sheet, depending on page orientation and the number of pages per
    /// sheet). Otherwise, the origin is at the top left corner of the
    /// imageable area (i.e. inside the margins).
    extern fn gtk_print_operation_set_use_full_page(p_op: *PrintOperation, p_full_page: c_int) void;
    pub const setUseFullPage = gtk_print_operation_set_use_full_page;

    extern fn gtk_print_operation_get_type() usize;
    pub const getGObjectType = gtk_print_operation_get_type;

    extern fn g_object_ref(p_self: *gtk.PrintOperation) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.PrintOperation) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *PrintOperation, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkPrintSettings object represents the settings of a print dialog in
/// a system-independent way. The main use for this object is that once
/// you’ve printed you can get a settings object that represents the settings
/// the user chose, and the next time you print you can pass that object in so
/// that the user doesn’t have to re-set all his settings.
///
/// Its also possible to enumerate the settings so that you can easily save
/// the settings for the next time your app runs, or even store them in a
/// document. The predefined keys try to use shared values as much as possible
/// so that moving such a document between systems still works.
///
/// Printing support was added in GTK+ 2.10.
pub const PrintSettings = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = PrintSettings;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.PrintSettings` object.
    extern fn gtk_print_settings_new() *gtk.PrintSettings;
    pub const new = gtk_print_settings_new;

    /// Reads the print settings from `file_name`. Returns a new `gtk.PrintSettings`
    /// object with the restored settings, or `NULL` if an error occurred. If the
    /// file could not be loaded then error is set to either a `glib.FileError` or
    /// `glib.KeyFileError`.  See `gtk.PrintSettings.toFile`.
    extern fn gtk_print_settings_new_from_file(p_file_name: [*:0]const u8, p_error: ?*?*glib.Error) ?*gtk.PrintSettings;
    pub const newFromFile = gtk_print_settings_new_from_file;

    /// Deserialize print settings from an a{sv} variant in
    /// the format produced by `gtk.PrintSettings.toGvariant`.
    extern fn gtk_print_settings_new_from_gvariant(p_variant: *glib.Variant) *gtk.PrintSettings;
    pub const newFromGvariant = gtk_print_settings_new_from_gvariant;

    /// Reads the print settings from the group `group_name` in `key_file`.  Returns a
    /// new `gtk.PrintSettings` object with the restored settings, or `NULL` if an
    /// error occurred. If the file could not be loaded then error is set to either
    /// a `glib.FileError` or `glib.KeyFileError`.
    extern fn gtk_print_settings_new_from_key_file(p_key_file: *glib.KeyFile, p_group_name: ?[*:0]const u8, p_error: ?*?*glib.Error) ?*gtk.PrintSettings;
    pub const newFromKeyFile = gtk_print_settings_new_from_key_file;

    /// Copies a `gtk.PrintSettings` object.
    extern fn gtk_print_settings_copy(p_other: *PrintSettings) *gtk.PrintSettings;
    pub const copy = gtk_print_settings_copy;

    /// Calls `func` for each key-value pair of `settings`.
    extern fn gtk_print_settings_foreach(p_settings: *PrintSettings, p_func: gtk.PrintSettingsFunc, p_user_data: ?*anyopaque) void;
    pub const foreach = gtk_print_settings_foreach;

    /// Looks up the string value associated with `key`.
    extern fn gtk_print_settings_get(p_settings: *PrintSettings, p_key: [*:0]const u8) [*:0]const u8;
    pub const get = gtk_print_settings_get;

    /// Returns the boolean represented by the value
    /// that is associated with `key`.
    ///
    /// The string “true” represents `TRUE`, any other
    /// string `FALSE`.
    extern fn gtk_print_settings_get_bool(p_settings: *PrintSettings, p_key: [*:0]const u8) c_int;
    pub const getBool = gtk_print_settings_get_bool;

    /// Gets the value of `GTK_PRINT_SETTINGS_COLLATE`.
    extern fn gtk_print_settings_get_collate(p_settings: *PrintSettings) c_int;
    pub const getCollate = gtk_print_settings_get_collate;

    /// Gets the value of `GTK_PRINT_SETTINGS_DEFAULT_SOURCE`.
    extern fn gtk_print_settings_get_default_source(p_settings: *PrintSettings) [*:0]const u8;
    pub const getDefaultSource = gtk_print_settings_get_default_source;

    /// Gets the value of `GTK_PRINT_SETTINGS_DITHER`.
    extern fn gtk_print_settings_get_dither(p_settings: *PrintSettings) [*:0]const u8;
    pub const getDither = gtk_print_settings_get_dither;

    /// Returns the double value associated with `key`, or 0.
    extern fn gtk_print_settings_get_double(p_settings: *PrintSettings, p_key: [*:0]const u8) f64;
    pub const getDouble = gtk_print_settings_get_double;

    /// Returns the floating point number represented by
    /// the value that is associated with `key`, or `default_val`
    /// if the value does not represent a floating point number.
    ///
    /// Floating point numbers are parsed with `glib.asciiStrtod`.
    extern fn gtk_print_settings_get_double_with_default(p_settings: *PrintSettings, p_key: [*:0]const u8, p_def: f64) f64;
    pub const getDoubleWithDefault = gtk_print_settings_get_double_with_default;

    /// Gets the value of `GTK_PRINT_SETTINGS_DUPLEX`.
    extern fn gtk_print_settings_get_duplex(p_settings: *PrintSettings) gtk.PrintDuplex;
    pub const getDuplex = gtk_print_settings_get_duplex;

    /// Gets the value of `GTK_PRINT_SETTINGS_FINISHINGS`.
    extern fn gtk_print_settings_get_finishings(p_settings: *PrintSettings) [*:0]const u8;
    pub const getFinishings = gtk_print_settings_get_finishings;

    /// Returns the integer value of `key`, or 0.
    extern fn gtk_print_settings_get_int(p_settings: *PrintSettings, p_key: [*:0]const u8) c_int;
    pub const getInt = gtk_print_settings_get_int;

    /// Returns the value of `key`, interpreted as
    /// an integer, or the default value.
    extern fn gtk_print_settings_get_int_with_default(p_settings: *PrintSettings, p_key: [*:0]const u8, p_def: c_int) c_int;
    pub const getIntWithDefault = gtk_print_settings_get_int_with_default;

    /// Returns the value associated with `key`, interpreted
    /// as a length. The returned value is converted to `units`.
    extern fn gtk_print_settings_get_length(p_settings: *PrintSettings, p_key: [*:0]const u8, p_unit: gtk.Unit) f64;
    pub const getLength = gtk_print_settings_get_length;

    /// Gets the value of `GTK_PRINT_SETTINGS_MEDIA_TYPE`.
    ///
    /// The set of media types is defined in PWG 5101.1-2002 PWG.
    extern fn gtk_print_settings_get_media_type(p_settings: *PrintSettings) [*:0]const u8;
    pub const getMediaType = gtk_print_settings_get_media_type;

    /// Gets the value of `GTK_PRINT_SETTINGS_N_COPIES`.
    extern fn gtk_print_settings_get_n_copies(p_settings: *PrintSettings) c_int;
    pub const getNCopies = gtk_print_settings_get_n_copies;

    /// Gets the value of `GTK_PRINT_SETTINGS_NUMBER_UP`.
    extern fn gtk_print_settings_get_number_up(p_settings: *PrintSettings) c_int;
    pub const getNumberUp = gtk_print_settings_get_number_up;

    /// Gets the value of `GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT`.
    extern fn gtk_print_settings_get_number_up_layout(p_settings: *PrintSettings) gtk.NumberUpLayout;
    pub const getNumberUpLayout = gtk_print_settings_get_number_up_layout;

    /// Get the value of `GTK_PRINT_SETTINGS_ORIENTATION`,
    /// converted to a `gtk.PageOrientation`.
    extern fn gtk_print_settings_get_orientation(p_settings: *PrintSettings) gtk.PageOrientation;
    pub const getOrientation = gtk_print_settings_get_orientation;

    /// Gets the value of `GTK_PRINT_SETTINGS_OUTPUT_BIN`.
    extern fn gtk_print_settings_get_output_bin(p_settings: *PrintSettings) [*:0]const u8;
    pub const getOutputBin = gtk_print_settings_get_output_bin;

    /// Gets the value of `GTK_PRINT_SETTINGS_PAGE_RANGES`.
    extern fn gtk_print_settings_get_page_ranges(p_settings: *PrintSettings, p_num_ranges: *c_int) [*]gtk.PageRange;
    pub const getPageRanges = gtk_print_settings_get_page_ranges;

    /// Gets the value of `GTK_PRINT_SETTINGS_PAGE_SET`.
    extern fn gtk_print_settings_get_page_set(p_settings: *PrintSettings) gtk.PageSet;
    pub const getPageSet = gtk_print_settings_get_page_set;

    /// Gets the value of `GTK_PRINT_SETTINGS_PAPER_HEIGHT`,
    /// converted to `unit`.
    extern fn gtk_print_settings_get_paper_height(p_settings: *PrintSettings, p_unit: gtk.Unit) f64;
    pub const getPaperHeight = gtk_print_settings_get_paper_height;

    /// Gets the value of `GTK_PRINT_SETTINGS_PAPER_FORMAT`,
    /// converted to a `gtk.PaperSize`.
    extern fn gtk_print_settings_get_paper_size(p_settings: *PrintSettings) *gtk.PaperSize;
    pub const getPaperSize = gtk_print_settings_get_paper_size;

    /// Gets the value of `GTK_PRINT_SETTINGS_PAPER_WIDTH`,
    /// converted to `unit`.
    extern fn gtk_print_settings_get_paper_width(p_settings: *PrintSettings, p_unit: gtk.Unit) f64;
    pub const getPaperWidth = gtk_print_settings_get_paper_width;

    /// Gets the value of `GTK_PRINT_SETTINGS_PRINT_PAGES`.
    extern fn gtk_print_settings_get_print_pages(p_settings: *PrintSettings) gtk.PrintPages;
    pub const getPrintPages = gtk_print_settings_get_print_pages;

    /// Convenience function to obtain the value of
    /// `GTK_PRINT_SETTINGS_PRINTER`.
    extern fn gtk_print_settings_get_printer(p_settings: *PrintSettings) [*:0]const u8;
    pub const getPrinter = gtk_print_settings_get_printer;

    /// Gets the value of `GTK_PRINT_SETTINGS_PRINTER_LPI`.
    extern fn gtk_print_settings_get_printer_lpi(p_settings: *PrintSettings) f64;
    pub const getPrinterLpi = gtk_print_settings_get_printer_lpi;

    /// Gets the value of `GTK_PRINT_SETTINGS_QUALITY`.
    extern fn gtk_print_settings_get_quality(p_settings: *PrintSettings) gtk.PrintQuality;
    pub const getQuality = gtk_print_settings_get_quality;

    /// Gets the value of `GTK_PRINT_SETTINGS_RESOLUTION`.
    extern fn gtk_print_settings_get_resolution(p_settings: *PrintSettings) c_int;
    pub const getResolution = gtk_print_settings_get_resolution;

    /// Gets the value of `GTK_PRINT_SETTINGS_RESOLUTION_X`.
    extern fn gtk_print_settings_get_resolution_x(p_settings: *PrintSettings) c_int;
    pub const getResolutionX = gtk_print_settings_get_resolution_x;

    /// Gets the value of `GTK_PRINT_SETTINGS_RESOLUTION_Y`.
    extern fn gtk_print_settings_get_resolution_y(p_settings: *PrintSettings) c_int;
    pub const getResolutionY = gtk_print_settings_get_resolution_y;

    /// Gets the value of `GTK_PRINT_SETTINGS_REVERSE`.
    extern fn gtk_print_settings_get_reverse(p_settings: *PrintSettings) c_int;
    pub const getReverse = gtk_print_settings_get_reverse;

    /// Gets the value of `GTK_PRINT_SETTINGS_SCALE`.
    extern fn gtk_print_settings_get_scale(p_settings: *PrintSettings) f64;
    pub const getScale = gtk_print_settings_get_scale;

    /// Gets the value of `GTK_PRINT_SETTINGS_USE_COLOR`.
    extern fn gtk_print_settings_get_use_color(p_settings: *PrintSettings) c_int;
    pub const getUseColor = gtk_print_settings_get_use_color;

    /// Returns `TRUE`, if a value is associated with `key`.
    extern fn gtk_print_settings_has_key(p_settings: *PrintSettings, p_key: [*:0]const u8) c_int;
    pub const hasKey = gtk_print_settings_has_key;

    /// Reads the print settings from `file_name`. If the file could not be loaded
    /// then error is set to either a `glib.FileError` or `glib.KeyFileError`.
    /// See `gtk.PrintSettings.toFile`.
    extern fn gtk_print_settings_load_file(p_settings: *PrintSettings, p_file_name: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const loadFile = gtk_print_settings_load_file;

    /// Reads the print settings from the group `group_name` in `key_file`. If the
    /// file could not be loaded then error is set to either a `glib.FileError` or
    /// `glib.KeyFileError`.
    extern fn gtk_print_settings_load_key_file(p_settings: *PrintSettings, p_key_file: *glib.KeyFile, p_group_name: ?[*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const loadKeyFile = gtk_print_settings_load_key_file;

    /// Associates `value` with `key`.
    extern fn gtk_print_settings_set(p_settings: *PrintSettings, p_key: [*:0]const u8, p_value: ?[*:0]const u8) void;
    pub const set = gtk_print_settings_set;

    /// Sets `key` to a boolean value.
    extern fn gtk_print_settings_set_bool(p_settings: *PrintSettings, p_key: [*:0]const u8, p_value: c_int) void;
    pub const setBool = gtk_print_settings_set_bool;

    /// Sets the value of `GTK_PRINT_SETTINGS_COLLATE`.
    extern fn gtk_print_settings_set_collate(p_settings: *PrintSettings, p_collate: c_int) void;
    pub const setCollate = gtk_print_settings_set_collate;

    /// Sets the value of `GTK_PRINT_SETTINGS_DEFAULT_SOURCE`.
    extern fn gtk_print_settings_set_default_source(p_settings: *PrintSettings, p_default_source: [*:0]const u8) void;
    pub const setDefaultSource = gtk_print_settings_set_default_source;

    /// Sets the value of `GTK_PRINT_SETTINGS_DITHER`.
    extern fn gtk_print_settings_set_dither(p_settings: *PrintSettings, p_dither: [*:0]const u8) void;
    pub const setDither = gtk_print_settings_set_dither;

    /// Sets `key` to a double value.
    extern fn gtk_print_settings_set_double(p_settings: *PrintSettings, p_key: [*:0]const u8, p_value: f64) void;
    pub const setDouble = gtk_print_settings_set_double;

    /// Sets the value of `GTK_PRINT_SETTINGS_DUPLEX`.
    extern fn gtk_print_settings_set_duplex(p_settings: *PrintSettings, p_duplex: gtk.PrintDuplex) void;
    pub const setDuplex = gtk_print_settings_set_duplex;

    /// Sets the value of `GTK_PRINT_SETTINGS_FINISHINGS`.
    extern fn gtk_print_settings_set_finishings(p_settings: *PrintSettings, p_finishings: [*:0]const u8) void;
    pub const setFinishings = gtk_print_settings_set_finishings;

    /// Sets `key` to an integer value.
    extern fn gtk_print_settings_set_int(p_settings: *PrintSettings, p_key: [*:0]const u8, p_value: c_int) void;
    pub const setInt = gtk_print_settings_set_int;

    /// Associates a length in units of `unit` with `key`.
    extern fn gtk_print_settings_set_length(p_settings: *PrintSettings, p_key: [*:0]const u8, p_value: f64, p_unit: gtk.Unit) void;
    pub const setLength = gtk_print_settings_set_length;

    /// Sets the value of `GTK_PRINT_SETTINGS_MEDIA_TYPE`.
    ///
    /// The set of media types is defined in PWG 5101.1-2002 PWG.
    extern fn gtk_print_settings_set_media_type(p_settings: *PrintSettings, p_media_type: [*:0]const u8) void;
    pub const setMediaType = gtk_print_settings_set_media_type;

    /// Sets the value of `GTK_PRINT_SETTINGS_N_COPIES`.
    extern fn gtk_print_settings_set_n_copies(p_settings: *PrintSettings, p_num_copies: c_int) void;
    pub const setNCopies = gtk_print_settings_set_n_copies;

    /// Sets the value of `GTK_PRINT_SETTINGS_NUMBER_UP`.
    extern fn gtk_print_settings_set_number_up(p_settings: *PrintSettings, p_number_up: c_int) void;
    pub const setNumberUp = gtk_print_settings_set_number_up;

    /// Sets the value of `GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT`.
    extern fn gtk_print_settings_set_number_up_layout(p_settings: *PrintSettings, p_number_up_layout: gtk.NumberUpLayout) void;
    pub const setNumberUpLayout = gtk_print_settings_set_number_up_layout;

    /// Sets the value of `GTK_PRINT_SETTINGS_ORIENTATION`.
    extern fn gtk_print_settings_set_orientation(p_settings: *PrintSettings, p_orientation: gtk.PageOrientation) void;
    pub const setOrientation = gtk_print_settings_set_orientation;

    /// Sets the value of `GTK_PRINT_SETTINGS_OUTPUT_BIN`.
    extern fn gtk_print_settings_set_output_bin(p_settings: *PrintSettings, p_output_bin: [*:0]const u8) void;
    pub const setOutputBin = gtk_print_settings_set_output_bin;

    /// Sets the value of `GTK_PRINT_SETTINGS_PAGE_RANGES`.
    extern fn gtk_print_settings_set_page_ranges(p_settings: *PrintSettings, p_page_ranges: [*]gtk.PageRange, p_num_ranges: c_int) void;
    pub const setPageRanges = gtk_print_settings_set_page_ranges;

    /// Sets the value of `GTK_PRINT_SETTINGS_PAGE_SET`.
    extern fn gtk_print_settings_set_page_set(p_settings: *PrintSettings, p_page_set: gtk.PageSet) void;
    pub const setPageSet = gtk_print_settings_set_page_set;

    /// Sets the value of `GTK_PRINT_SETTINGS_PAPER_HEIGHT`.
    extern fn gtk_print_settings_set_paper_height(p_settings: *PrintSettings, p_height: f64, p_unit: gtk.Unit) void;
    pub const setPaperHeight = gtk_print_settings_set_paper_height;

    /// Sets the value of `GTK_PRINT_SETTINGS_PAPER_FORMAT`,
    /// `GTK_PRINT_SETTINGS_PAPER_WIDTH` and
    /// `GTK_PRINT_SETTINGS_PAPER_HEIGHT`.
    extern fn gtk_print_settings_set_paper_size(p_settings: *PrintSettings, p_paper_size: *gtk.PaperSize) void;
    pub const setPaperSize = gtk_print_settings_set_paper_size;

    /// Sets the value of `GTK_PRINT_SETTINGS_PAPER_WIDTH`.
    extern fn gtk_print_settings_set_paper_width(p_settings: *PrintSettings, p_width: f64, p_unit: gtk.Unit) void;
    pub const setPaperWidth = gtk_print_settings_set_paper_width;

    /// Sets the value of `GTK_PRINT_SETTINGS_PRINT_PAGES`.
    extern fn gtk_print_settings_set_print_pages(p_settings: *PrintSettings, p_pages: gtk.PrintPages) void;
    pub const setPrintPages = gtk_print_settings_set_print_pages;

    /// Convenience function to set `GTK_PRINT_SETTINGS_PRINTER`
    /// to `printer`.
    extern fn gtk_print_settings_set_printer(p_settings: *PrintSettings, p_printer: [*:0]const u8) void;
    pub const setPrinter = gtk_print_settings_set_printer;

    /// Sets the value of `GTK_PRINT_SETTINGS_PRINTER_LPI`.
    extern fn gtk_print_settings_set_printer_lpi(p_settings: *PrintSettings, p_lpi: f64) void;
    pub const setPrinterLpi = gtk_print_settings_set_printer_lpi;

    /// Sets the value of `GTK_PRINT_SETTINGS_QUALITY`.
    extern fn gtk_print_settings_set_quality(p_settings: *PrintSettings, p_quality: gtk.PrintQuality) void;
    pub const setQuality = gtk_print_settings_set_quality;

    /// Sets the values of `GTK_PRINT_SETTINGS_RESOLUTION`,
    /// `GTK_PRINT_SETTINGS_RESOLUTION_X` and
    /// `GTK_PRINT_SETTINGS_RESOLUTION_Y`.
    extern fn gtk_print_settings_set_resolution(p_settings: *PrintSettings, p_resolution: c_int) void;
    pub const setResolution = gtk_print_settings_set_resolution;

    /// Sets the values of `GTK_PRINT_SETTINGS_RESOLUTION`,
    /// `GTK_PRINT_SETTINGS_RESOLUTION_X` and
    /// `GTK_PRINT_SETTINGS_RESOLUTION_Y`.
    extern fn gtk_print_settings_set_resolution_xy(p_settings: *PrintSettings, p_resolution_x: c_int, p_resolution_y: c_int) void;
    pub const setResolutionXy = gtk_print_settings_set_resolution_xy;

    /// Sets the value of `GTK_PRINT_SETTINGS_REVERSE`.
    extern fn gtk_print_settings_set_reverse(p_settings: *PrintSettings, p_reverse: c_int) void;
    pub const setReverse = gtk_print_settings_set_reverse;

    /// Sets the value of `GTK_PRINT_SETTINGS_SCALE`.
    extern fn gtk_print_settings_set_scale(p_settings: *PrintSettings, p_scale: f64) void;
    pub const setScale = gtk_print_settings_set_scale;

    /// Sets the value of `GTK_PRINT_SETTINGS_USE_COLOR`.
    extern fn gtk_print_settings_set_use_color(p_settings: *PrintSettings, p_use_color: c_int) void;
    pub const setUseColor = gtk_print_settings_set_use_color;

    /// This function saves the print settings from `settings` to `file_name`. If the
    /// file could not be loaded then error is set to either a `glib.FileError` or
    /// `glib.KeyFileError`.
    extern fn gtk_print_settings_to_file(p_settings: *PrintSettings, p_file_name: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const toFile = gtk_print_settings_to_file;

    /// Serialize print settings to an a{sv} variant.
    extern fn gtk_print_settings_to_gvariant(p_settings: *PrintSettings) *glib.Variant;
    pub const toGvariant = gtk_print_settings_to_gvariant;

    /// This function adds the print settings from `settings` to `key_file`.
    extern fn gtk_print_settings_to_key_file(p_settings: *PrintSettings, p_key_file: *glib.KeyFile, p_group_name: ?[*:0]const u8) void;
    pub const toKeyFile = gtk_print_settings_to_key_file;

    /// Removes any value associated with `key`.
    /// This has the same effect as setting the value to `NULL`.
    extern fn gtk_print_settings_unset(p_settings: *PrintSettings, p_key: [*:0]const u8) void;
    pub const unset = gtk_print_settings_unset;

    extern fn gtk_print_settings_get_type() usize;
    pub const getGObjectType = gtk_print_settings_get_type;

    extern fn g_object_ref(p_self: *gtk.PrintSettings) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.PrintSettings) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *PrintSettings, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.ProgressBar` is typically used to display the progress of a long
/// running operation. It provides a visual clue that processing is underway.
/// The GtkProgressBar can be used in two different modes: percentage mode
/// and activity mode.
///
/// When an application can determine how much work needs to take place
/// (e.g. read a fixed number of bytes from a file) and can monitor its
/// progress, it can use the GtkProgressBar in percentage mode and the
/// user sees a growing bar indicating the percentage of the work that
/// has been completed. In this mode, the application is required to call
/// `gtk.ProgressBar.setFraction` periodically to update the progress bar.
///
/// When an application has no accurate way of knowing the amount of work
/// to do, it can use the `gtk.ProgressBar` in activity mode, which shows
/// activity by a block moving back and forth within the progress area. In
/// this mode, the application is required to call `gtk.ProgressBar.pulse`
/// periodically to update the progress bar.
///
/// There is quite a bit of flexibility provided to control the appearance
/// of the `gtk.ProgressBar`. Functions are provided to control the orientation
/// of the bar, optional text can be displayed along with the bar, and the
/// step size used in activity mode can be set.
///
/// # CSS nodes
///
/// ```
/// progressbar[.osd]
/// ├── [text]
/// ╰── trough[.empty][.full]
///     ╰── progress[.pulse]
/// ```
///
/// GtkProgressBar has a main CSS node with name progressbar and subnodes with
/// names text and trough, of which the latter has a subnode named progress. The
/// text subnode is only present if text is shown. The progress subnode has the
/// style class .pulse when in activity mode. It gets the style classes .left,
/// .right, .top or .bottom added when the progress 'touches' the corresponding
/// end of the GtkProgressBar. The .osd class on the progressbar node is for use
/// in overlays like the one Epiphany has for page loading progress.
pub const ProgressBar = extern struct {
    pub const Parent = gtk.Widget;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.ProgressBarClass;
    f_parent: gtk.Widget,
    f_priv: ?*gtk.ProgressBarPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The preferred place to ellipsize the string, if the progress bar does
        /// not have enough room to display the entire string, specified as a
        /// `pango.EllipsizeMode`.
        ///
        /// Note that setting this property to a value other than
        /// `PANGO_ELLIPSIZE_NONE` has the side-effect that the progress bar requests
        /// only enough space to display the ellipsis ("..."). Another means to set a
        /// progress bar's width is `gtk.Widget.setSizeRequest`.
        pub const ellipsize = struct {
            pub const name = "ellipsize";

            pub const Type = pango.EllipsizeMode;
        };

        pub const fraction = struct {
            pub const name = "fraction";

            pub const Type = f64;
        };

        pub const inverted = struct {
            pub const name = "inverted";

            pub const Type = c_int;
        };

        pub const pulse_step = struct {
            pub const name = "pulse-step";

            pub const Type = f64;
        };

        /// Sets whether the progress bar will show a text in addition
        /// to the bar itself. The shown text is either the value of
        /// the `gtk.ProgressBar.properties.text` property or, if that is `NULL`,
        /// the `gtk.ProgressBar.properties.fraction` value, as a percentage.
        ///
        /// To make a progress bar that is styled and sized suitably for
        /// showing text (even if the actual text is blank), set
        /// `gtk.ProgressBar.properties.show`-text to `TRUE` and `gtk.ProgressBar.properties.text`
        /// to the empty string (not `NULL`).
        pub const show_text = struct {
            pub const name = "show-text";

            pub const Type = c_int;
        };

        pub const text = struct {
            pub const name = "text";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.ProgressBar`.
    extern fn gtk_progress_bar_new() *gtk.ProgressBar;
    pub const new = gtk_progress_bar_new;

    /// Returns the ellipsizing position of the progress bar.
    /// See `gtk.ProgressBar.setEllipsize`.
    extern fn gtk_progress_bar_get_ellipsize(p_pbar: *ProgressBar) pango.EllipsizeMode;
    pub const getEllipsize = gtk_progress_bar_get_ellipsize;

    /// Returns the current fraction of the task that’s been completed.
    extern fn gtk_progress_bar_get_fraction(p_pbar: *ProgressBar) f64;
    pub const getFraction = gtk_progress_bar_get_fraction;

    /// Gets the value set by `gtk.ProgressBar.setInverted`.
    extern fn gtk_progress_bar_get_inverted(p_pbar: *ProgressBar) c_int;
    pub const getInverted = gtk_progress_bar_get_inverted;

    /// Retrieves the pulse step set with `gtk.ProgressBar.setPulseStep`.
    extern fn gtk_progress_bar_get_pulse_step(p_pbar: *ProgressBar) f64;
    pub const getPulseStep = gtk_progress_bar_get_pulse_step;

    /// Gets the value of the `gtk.ProgressBar.properties.show`-text property.
    /// See `gtk.ProgressBar.setShowText`.
    extern fn gtk_progress_bar_get_show_text(p_pbar: *ProgressBar) c_int;
    pub const getShowText = gtk_progress_bar_get_show_text;

    /// Retrieves the text that is displayed with the progress bar,
    /// if any, otherwise `NULL`. The return value is a reference
    /// to the text, not a copy of it, so will become invalid
    /// if you change the text in the progress bar.
    extern fn gtk_progress_bar_get_text(p_pbar: *ProgressBar) ?[*:0]const u8;
    pub const getText = gtk_progress_bar_get_text;

    /// Indicates that some progress has been made, but you don’t know how much.
    /// Causes the progress bar to enter “activity mode,” where a block
    /// bounces back and forth. Each call to `gtk.ProgressBar.pulse`
    /// causes the block to move by a little bit (the amount of movement
    /// per pulse is determined by `gtk.ProgressBar.setPulseStep`).
    extern fn gtk_progress_bar_pulse(p_pbar: *ProgressBar) void;
    pub const pulse = gtk_progress_bar_pulse;

    /// Sets the mode used to ellipsize (add an ellipsis: "...") the
    /// text if there is not enough space to render the entire string.
    extern fn gtk_progress_bar_set_ellipsize(p_pbar: *ProgressBar, p_mode: pango.EllipsizeMode) void;
    pub const setEllipsize = gtk_progress_bar_set_ellipsize;

    /// Causes the progress bar to “fill in” the given fraction
    /// of the bar. The fraction should be between 0.0 and 1.0,
    /// inclusive.
    extern fn gtk_progress_bar_set_fraction(p_pbar: *ProgressBar, p_fraction: f64) void;
    pub const setFraction = gtk_progress_bar_set_fraction;

    /// Progress bars normally grow from top to bottom or left to right.
    /// Inverted progress bars grow in the opposite direction.
    extern fn gtk_progress_bar_set_inverted(p_pbar: *ProgressBar, p_inverted: c_int) void;
    pub const setInverted = gtk_progress_bar_set_inverted;

    /// Sets the fraction of total progress bar length to move the
    /// bouncing block for each call to `gtk.ProgressBar.pulse`.
    extern fn gtk_progress_bar_set_pulse_step(p_pbar: *ProgressBar, p_fraction: f64) void;
    pub const setPulseStep = gtk_progress_bar_set_pulse_step;

    /// Sets whether the progress bar will show text next to the bar.
    /// The shown text is either the value of the `gtk.ProgressBar.properties.text`
    /// property or, if that is `NULL`, the `gtk.ProgressBar.properties.fraction` value,
    /// as a percentage.
    ///
    /// To make a progress bar that is styled and sized suitably for containing
    /// text (even if the actual text is blank), set `gtk.ProgressBar.properties.show`-text to
    /// `TRUE` and `gtk.ProgressBar.properties.text` to the empty string (not `NULL`).
    extern fn gtk_progress_bar_set_show_text(p_pbar: *ProgressBar, p_show_text: c_int) void;
    pub const setShowText = gtk_progress_bar_set_show_text;

    /// Causes the given `text` to appear next to the progress bar.
    ///
    /// If `text` is `NULL` and `gtk.ProgressBar.properties.show`-text is `TRUE`, the current
    /// value of `gtk.ProgressBar.properties.fraction` will be displayed as a percentage.
    ///
    /// If `text` is non-`NULL` and `gtk.ProgressBar.properties.show`-text is `TRUE`, the text
    /// will be displayed. In this case, it will not display the progress
    /// percentage. If `text` is the empty string, the progress bar will still
    /// be styled and sized suitably for containing text, as long as
    /// `gtk.ProgressBar.properties.show`-text is `TRUE`.
    extern fn gtk_progress_bar_set_text(p_pbar: *ProgressBar, p_text: ?[*:0]const u8) void;
    pub const setText = gtk_progress_bar_set_text;

    extern fn gtk_progress_bar_get_type() usize;
    pub const getGObjectType = gtk_progress_bar_get_type;

    extern fn g_object_ref(p_self: *gtk.ProgressBar) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ProgressBar) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ProgressBar, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ProgressBarAccessible = extern struct {
    pub const Parent = gtk.WidgetAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Value };
    pub const Class = gtk.ProgressBarAccessibleClass;
    f_parent: gtk.WidgetAccessible,
    f_priv: ?*gtk.ProgressBarAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_progress_bar_accessible_get_type() usize;
    pub const getGObjectType = gtk_progress_bar_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ProgressBarAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ProgressBarAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ProgressBarAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.RadioAction` is similar to `gtk.RadioMenuItem`. A number of radio
/// actions can be linked together so that only one may be active at any
/// one time.
pub const RadioAction = extern struct {
    pub const Parent = gtk.ToggleAction;
    pub const Implements = [_]type{gtk.Buildable};
    pub const Class = gtk.RadioActionClass;
    f_parent: gtk.ToggleAction,
    f_private_data: ?*gtk.RadioActionPrivate,

    pub const virtual_methods = struct {
        pub const changed = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_current: *gtk.RadioAction) void {
                return gobject.ext.as(RadioAction.Class, p_class).f_changed.?(gobject.ext.as(RadioAction, p_action), p_current);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_current: *gtk.RadioAction) callconv(.c) void) void {
                gobject.ext.as(RadioAction.Class, p_class).f_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The value property of the currently active member of the group to which
        /// this action belongs.
        pub const current_value = struct {
            pub const name = "current-value";

            pub const Type = c_int;
        };

        /// Sets a new group for a radio action.
        pub const group = struct {
            pub const name = "group";

            pub const Type = ?*gtk.RadioAction;
        };

        /// The value is an arbitrary integer which can be used as a
        /// convenient way to determine which action in the group is
        /// currently active in an ::activate or ::changed signal handler.
        /// See `gtk.RadioAction.getCurrentValue` and `gtk.RadioActionEntry`
        /// for convenient ways to get and set this property.
        pub const value = struct {
            pub const name = "value";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::changed signal is emitted on every member of a radio group when the
        /// active member is changed. The signal gets emitted after the ::activate signals
        /// for the previous and current active members.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_current: *gtk.RadioAction, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(RadioAction, p_instance))),
                    gobject.signalLookup("changed", RadioAction.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.RadioAction` object. To add the action to
    /// a `gtk.ActionGroup` and set the accelerator for the action,
    /// call `gtk.ActionGroup.addActionWithAccel`.
    extern fn gtk_radio_action_new(p_name: [*:0]const u8, p_label: ?[*:0]const u8, p_tooltip: ?[*:0]const u8, p_stock_id: ?[*:0]const u8, p_value: c_int) *gtk.RadioAction;
    pub const new = gtk_radio_action_new;

    /// Obtains the value property of the currently active member of
    /// the group to which `action` belongs.
    extern fn gtk_radio_action_get_current_value(p_action: *RadioAction) c_int;
    pub const getCurrentValue = gtk_radio_action_get_current_value;

    /// Returns the list representing the radio group for this object.
    /// Note that the returned list is only valid until the next change
    /// to the group.
    ///
    /// A common way to set up a group of radio group is the following:
    /// ```
    ///   GSList *group = NULL;
    ///   GtkRadioAction *action;
    ///
    ///   while ( ...more actions to add... /)
    ///     {
    ///        action = gtk_radio_action_new (...);
    ///
    ///        gtk_radio_action_set_group (action, group);
    ///        group = gtk_radio_action_get_group (action);
    ///     }
    /// ```
    extern fn gtk_radio_action_get_group(p_action: *RadioAction) *glib.SList;
    pub const getGroup = gtk_radio_action_get_group;

    /// Joins a radio action object to the group of another radio action object.
    ///
    /// Use this in language bindings instead of the `gtk.RadioAction.getGroup`
    /// and `gtk.RadioAction.setGroup` methods
    ///
    /// A common way to set up a group of radio actions is the following:
    /// ```
    ///   GtkRadioAction *action;
    ///   GtkRadioAction *last_action;
    ///
    ///   while ( ...more actions to add... /)
    ///     {
    ///        action = gtk_radio_action_new (...);
    ///
    ///        gtk_radio_action_join_group (action, last_action);
    ///        last_action = action;
    ///     }
    /// ```
    extern fn gtk_radio_action_join_group(p_action: *RadioAction, p_group_source: ?*gtk.RadioAction) void;
    pub const joinGroup = gtk_radio_action_join_group;

    /// Sets the currently active group member to the member with value
    /// property `current_value`.
    extern fn gtk_radio_action_set_current_value(p_action: *RadioAction, p_current_value: c_int) void;
    pub const setCurrentValue = gtk_radio_action_set_current_value;

    /// Sets the radio group for the radio action object.
    extern fn gtk_radio_action_set_group(p_action: *RadioAction, p_group: ?*glib.SList) void;
    pub const setGroup = gtk_radio_action_set_group;

    extern fn gtk_radio_action_get_type() usize;
    pub const getGObjectType = gtk_radio_action_get_type;

    extern fn g_object_ref(p_self: *gtk.RadioAction) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RadioAction) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RadioAction, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A single radio button performs the same basic function as a `gtk.CheckButton`,
/// as its position in the object hierarchy reflects. It is only when multiple
/// radio buttons are grouped together that they become a different user
/// interface component in their own right.
///
/// Every radio button is a member of some group of radio buttons. When one is
/// selected, all other radio buttons in the same group are deselected. A
/// `gtk.RadioButton` is one way of giving the user a choice from many options.
///
/// Radio button widgets are created with `gtk.RadioButton.new`, passing `NULL`
/// as the argument if this is the first radio button in a group. In subsequent
/// calls, the group you wish to add this button to should be passed as an
/// argument. Optionally, `gtk.RadioButton.newWithLabel` can be used if you
/// want a text label on the radio button.
///
/// Alternatively, when adding widgets to an existing group of radio buttons,
/// use `gtk.RadioButton.newFromWidget` with a `gtk.RadioButton` that already
/// has a group assigned to it. The convenience function
/// `gtk.RadioButton.newWithLabelFromWidget` is also provided.
///
/// To retrieve the group a `gtk.RadioButton` is assigned to, use
/// `gtk.RadioButton.getGroup`.
///
/// To remove a `gtk.RadioButton` from one group and make it part of a new one,
/// use `gtk.RadioButton.setGroup`.
///
/// The group list does not need to be freed, as each `gtk.RadioButton` will remove
/// itself and its list item when it is destroyed.
///
/// # CSS nodes
///
/// ```
/// radiobutton
/// ├── radio
/// ╰── <child>
/// ```
///
/// A GtkRadioButton with indicator (see `gtk.ToggleButton.setMode`) has a
/// main CSS node with name radiobutton and a subnode with name radio.
///
/// ```
/// button.radio
/// ├── radio
/// ╰── <child>
/// ```
///
/// A GtkRadioButton without indicator changes the name of its main node
/// to button and adds a .radio style class to it. The subnode is invisible
/// in this case.
///
/// ## How to create a group of two radio buttons.
///
/// ```
/// void create_radio_buttons (void) {
///
///    GtkWidget *window, *radio1, *radio2, *box, *entry;
///    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
///    box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
///    gtk_box_set_homogeneous (GTK_BOX (box), TRUE);
///
///    // Create a radio button with a GtkEntry widget
///    radio1 = gtk_radio_button_new (NULL);
///    entry = gtk_entry_new ();
///    gtk_container_add (GTK_CONTAINER (radio1), entry);
///
///
///    // Create a radio button with a label
///    radio2 = gtk_radio_button_new_with_label_from_widget (GTK_RADIO_BUTTON (radio1),
///                                                          "I’m the second radio button.");
///
///    // Pack them into a box, then show all the widgets
///    gtk_box_pack_start (GTK_BOX (box), radio1);
///    gtk_box_pack_start (GTK_BOX (box), radio2);
///    gtk_container_add (GTK_CONTAINER (window), box);
///    gtk_widget_show_all (window);
///    return;
/// }
/// ```
///
/// When an unselected button in the group is clicked the clicked button
/// receives the `gtk.ToggleButton.signals.toggled` signal, as does the previously
/// selected button.
/// Inside the `gtk.ToggleButton.signals.toggled` handler, `gtk.ToggleButton.getActive`
/// can be used to determine if the button has been selected or deselected.
pub const RadioButton = extern struct {
    pub const Parent = gtk.CheckButton;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.RadioButtonClass;
    f_check_button: gtk.CheckButton,
    f_priv: ?*gtk.RadioButtonPrivate,

    pub const virtual_methods = struct {
        pub const group_changed = struct {
            pub fn call(p_class: anytype, p_radio_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(RadioButton.Class, p_class).f_group_changed.?(gobject.ext.as(RadioButton, p_radio_button));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_radio_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(RadioButton.Class, p_class).f_group_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Sets a new group for a radio button.
        pub const group = struct {
            pub const name = "group";

            pub const Type = ?*gtk.RadioButton;
        };
    };

    pub const signals = struct {
        /// Emitted when the group of radio buttons that a radio button belongs
        /// to changes. This is emitted when a radio button switches from
        /// being alone to being part of a group of 2 or more buttons, or
        /// vice-versa, and when a button is moved from one group of 2 or
        /// more buttons to a different one, but not when the composition
        /// of the group that a button belongs to changes.
        pub const group_changed = struct {
            pub const name = "group-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(RadioButton, p_instance))),
                    gobject.signalLookup("group-changed", RadioButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.RadioButton`. To be of any practical value, a widget should
    /// then be packed into the radio button.
    extern fn gtk_radio_button_new(p_group: ?*glib.SList) *gtk.RadioButton;
    pub const new = gtk_radio_button_new;

    /// Creates a new `gtk.RadioButton`, adding it to the same group as
    /// `radio_group_member`. As with `gtk.RadioButton.new`, a widget
    /// should be packed into the radio button.
    extern fn gtk_radio_button_new_from_widget(p_radio_group_member: ?*gtk.RadioButton) *gtk.RadioButton;
    pub const newFromWidget = gtk_radio_button_new_from_widget;

    /// Creates a new `gtk.RadioButton` with a text label.
    extern fn gtk_radio_button_new_with_label(p_group: ?*glib.SList, p_label: [*:0]const u8) *gtk.RadioButton;
    pub const newWithLabel = gtk_radio_button_new_with_label;

    /// Creates a new `gtk.RadioButton` with a text label, adding it to
    /// the same group as `radio_group_member`.
    extern fn gtk_radio_button_new_with_label_from_widget(p_radio_group_member: ?*gtk.RadioButton, p_label: [*:0]const u8) *gtk.RadioButton;
    pub const newWithLabelFromWidget = gtk_radio_button_new_with_label_from_widget;

    /// Creates a new `gtk.RadioButton` containing a label, adding it to the same
    /// group as `group`. The label will be created using
    /// `gtk.Label.newWithMnemonic`, so underscores in `label` indicate the
    /// mnemonic for the button.
    extern fn gtk_radio_button_new_with_mnemonic(p_group: ?*glib.SList, p_label: [*:0]const u8) *gtk.RadioButton;
    pub const newWithMnemonic = gtk_radio_button_new_with_mnemonic;

    /// Creates a new `gtk.RadioButton` containing a label. The label
    /// will be created using `gtk.Label.newWithMnemonic`, so underscores
    /// in `label` indicate the mnemonic for the button.
    extern fn gtk_radio_button_new_with_mnemonic_from_widget(p_radio_group_member: ?*gtk.RadioButton, p_label: [*:0]const u8) *gtk.RadioButton;
    pub const newWithMnemonicFromWidget = gtk_radio_button_new_with_mnemonic_from_widget;

    /// Retrieves the group assigned to a radio button.
    extern fn gtk_radio_button_get_group(p_radio_button: *RadioButton) *glib.SList;
    pub const getGroup = gtk_radio_button_get_group;

    /// Joins a `gtk.RadioButton` object to the group of another `gtk.RadioButton` object
    ///
    /// Use this in language bindings instead of the `gtk.RadioButton.getGroup`
    /// and `gtk.RadioButton.setGroup` methods
    ///
    /// A common way to set up a group of radio buttons is the following:
    /// ```
    ///   GtkRadioButton *radio_button;
    ///   GtkRadioButton *last_button;
    ///
    ///   while (some_condition)
    ///     {
    ///        radio_button = gtk_radio_button_new (NULL);
    ///
    ///        gtk_radio_button_join_group (radio_button, last_button);
    ///        last_button = radio_button;
    ///     }
    /// ```
    extern fn gtk_radio_button_join_group(p_radio_button: *RadioButton, p_group_source: ?*gtk.RadioButton) void;
    pub const joinGroup = gtk_radio_button_join_group;

    /// Sets a `gtk.RadioButton`’s group. It should be noted that this does not change
    /// the layout of your interface in any way, so if you are changing the group,
    /// it is likely you will need to re-arrange the user interface to reflect these
    /// changes.
    extern fn gtk_radio_button_set_group(p_radio_button: *RadioButton, p_group: ?*glib.SList) void;
    pub const setGroup = gtk_radio_button_set_group;

    extern fn gtk_radio_button_get_type() usize;
    pub const getGObjectType = gtk_radio_button_get_type;

    extern fn g_object_ref(p_self: *gtk.RadioButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RadioButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RadioButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RadioButtonAccessible = extern struct {
    pub const Parent = gtk.ToggleButtonAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.Image };
    pub const Class = gtk.RadioButtonAccessibleClass;
    f_parent: gtk.ToggleButtonAccessible,
    f_priv: ?*gtk.RadioButtonAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_radio_button_accessible_get_type() usize;
    pub const getGObjectType = gtk_radio_button_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.RadioButtonAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RadioButtonAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RadioButtonAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A radio menu item is a check menu item that belongs to a group. At each
/// instant exactly one of the radio menu items from a group is selected.
///
/// The group list does not need to be freed, as each `gtk.RadioMenuItem` will
/// remove itself and its list item when it is destroyed.
///
/// The correct way to create a group of radio menu items is approximatively
/// this:
///
/// ## How to create a group of radio menu items.
///
/// ```
/// GSList *group = NULL;
/// GtkWidget *item;
/// gint i;
///
/// for (i = 0; i < 5; i++)
/// {
///   item = gtk_radio_menu_item_new_with_label (group, "This is an example");
///   group = gtk_radio_menu_item_get_group (GTK_RADIO_MENU_ITEM (item));
///   if (i == 1)
///     gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (item), TRUE);
/// }
/// ```
///
/// # CSS nodes
///
/// ```
/// menuitem
/// ├── radio.left
/// ╰── <child>
/// ```
///
/// GtkRadioMenuItem has a main CSS node with name menuitem, and a subnode
/// with name radio, which gets the .left or .right style class.
pub const RadioMenuItem = extern struct {
    pub const Parent = gtk.CheckMenuItem;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.RadioMenuItemClass;
    f_check_menu_item: gtk.CheckMenuItem,
    f_priv: ?*gtk.RadioMenuItemPrivate,

    pub const virtual_methods = struct {
        pub const group_changed = struct {
            pub fn call(p_class: anytype, p_radio_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(RadioMenuItem.Class, p_class).f_group_changed.?(gobject.ext.as(RadioMenuItem, p_radio_menu_item));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_radio_menu_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(RadioMenuItem.Class, p_class).f_group_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The radio menu item whose group this widget belongs to.
        pub const group = struct {
            pub const name = "group";

            pub const Type = ?*gtk.RadioMenuItem;
        };
    };

    pub const signals = struct {
        pub const group_changed = struct {
            pub const name = "group-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(RadioMenuItem, p_instance))),
                    gobject.signalLookup("group-changed", RadioMenuItem.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.RadioMenuItem`.
    extern fn gtk_radio_menu_item_new(p_group: ?*glib.SList) *gtk.RadioMenuItem;
    pub const new = gtk_radio_menu_item_new;

    /// Creates a new `gtk.RadioMenuItem` adding it to the same group as `group`.
    extern fn gtk_radio_menu_item_new_from_widget(p_group: ?*gtk.RadioMenuItem) *gtk.RadioMenuItem;
    pub const newFromWidget = gtk_radio_menu_item_new_from_widget;

    /// Creates a new `gtk.RadioMenuItem` whose child is a simple `gtk.Label`.
    extern fn gtk_radio_menu_item_new_with_label(p_group: ?*glib.SList, p_label: [*:0]const u8) *gtk.RadioMenuItem;
    pub const newWithLabel = gtk_radio_menu_item_new_with_label;

    /// Creates a new GtkRadioMenuItem whose child is a simple GtkLabel.
    /// The new `gtk.RadioMenuItem` is added to the same group as `group`.
    extern fn gtk_radio_menu_item_new_with_label_from_widget(p_group: ?*gtk.RadioMenuItem, p_label: ?[*:0]const u8) *gtk.RadioMenuItem;
    pub const newWithLabelFromWidget = gtk_radio_menu_item_new_with_label_from_widget;

    /// Creates a new `gtk.RadioMenuItem` containing a label. The label
    /// will be created using `gtk.Label.newWithMnemonic`, so underscores
    /// in `label` indicate the mnemonic for the menu item.
    extern fn gtk_radio_menu_item_new_with_mnemonic(p_group: ?*glib.SList, p_label: [*:0]const u8) *gtk.RadioMenuItem;
    pub const newWithMnemonic = gtk_radio_menu_item_new_with_mnemonic;

    /// Creates a new GtkRadioMenuItem containing a label. The label will be
    /// created using `gtk.Label.newWithMnemonic`, so underscores in label
    /// indicate the mnemonic for the menu item.
    ///
    /// The new `gtk.RadioMenuItem` is added to the same group as `group`.
    extern fn gtk_radio_menu_item_new_with_mnemonic_from_widget(p_group: ?*gtk.RadioMenuItem, p_label: ?[*:0]const u8) *gtk.RadioMenuItem;
    pub const newWithMnemonicFromWidget = gtk_radio_menu_item_new_with_mnemonic_from_widget;

    /// Returns the group to which the radio menu item belongs, as a `glib.List` of
    /// `gtk.RadioMenuItem`. The list belongs to GTK+ and should not be freed.
    extern fn gtk_radio_menu_item_get_group(p_radio_menu_item: *RadioMenuItem) *glib.SList;
    pub const getGroup = gtk_radio_menu_item_get_group;

    /// Joins a `gtk.RadioMenuItem` object to the group of another `gtk.RadioMenuItem`
    /// object.
    ///
    /// This function should be used by language bindings to avoid the memory
    /// manangement of the opaque `glib.SList` of `gtk.RadioMenuItem.getGroup`
    /// and `gtk.RadioMenuItem.setGroup`.
    ///
    /// A common way to set up a group of `gtk.RadioMenuItem` instances is:
    ///
    /// ```
    ///   GtkRadioMenuItem *last_item = NULL;
    ///
    ///   while ( ...more items to add... )
    ///     {
    ///       GtkRadioMenuItem *radio_item;
    ///
    ///       radio_item = gtk_radio_menu_item_new (...);
    ///
    ///       gtk_radio_menu_item_join_group (radio_item, last_item);
    ///       last_item = radio_item;
    ///     }
    /// ```
    extern fn gtk_radio_menu_item_join_group(p_radio_menu_item: *RadioMenuItem, p_group_source: ?*gtk.RadioMenuItem) void;
    pub const joinGroup = gtk_radio_menu_item_join_group;

    /// Sets the group of a radio menu item, or changes it.
    extern fn gtk_radio_menu_item_set_group(p_radio_menu_item: *RadioMenuItem, p_group: ?*glib.SList) void;
    pub const setGroup = gtk_radio_menu_item_set_group;

    extern fn gtk_radio_menu_item_get_type() usize;
    pub const getGObjectType = gtk_radio_menu_item_get_type;

    extern fn g_object_ref(p_self: *gtk.RadioMenuItem) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RadioMenuItem) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RadioMenuItem, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RadioMenuItemAccessible = extern struct {
    pub const Parent = gtk.CheckMenuItemAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.Selection };
    pub const Class = gtk.RadioMenuItemAccessibleClass;
    f_parent: gtk.CheckMenuItemAccessible,
    f_priv: ?*gtk.RadioMenuItemAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_radio_menu_item_accessible_get_type() usize;
    pub const getGObjectType = gtk_radio_menu_item_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.RadioMenuItemAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RadioMenuItemAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RadioMenuItemAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.RadioToolButton` is a `gtk.ToolItem` that contains a radio button,
/// that is, a button that is part of a group of toggle buttons where only
/// one button can be active at a time.
///
/// Use `gtk.RadioToolButton.new` to create a new GtkRadioToolButton. Use
/// `gtk.RadioToolButton.newFromWidget` to create a new GtkRadioToolButton
/// that is part of the same group as an existing GtkRadioToolButton.
///
/// # CSS nodes
///
/// GtkRadioToolButton has a single CSS node with name toolbutton.
pub const RadioToolButton = extern struct {
    pub const Parent = gtk.ToggleToolButton;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.RadioToolButtonClass;
    f_parent: gtk.ToggleToolButton,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Sets a new group for a radio tool button.
        pub const group = struct {
            pub const name = "group";

            pub const Type = ?*gtk.RadioToolButton;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.RadioToolButton`, adding it to `group`.
    extern fn gtk_radio_tool_button_new(p_group: ?*glib.SList) *gtk.RadioToolButton;
    pub const new = gtk_radio_tool_button_new;

    /// Creates a new `gtk.RadioToolButton`, adding it to `group`.
    /// The new `gtk.RadioToolButton` will contain an icon and label from the
    /// stock item indicated by `stock_id`.
    extern fn gtk_radio_tool_button_new_from_stock(p_group: ?*glib.SList, p_stock_id: [*:0]const u8) *gtk.RadioToolButton;
    pub const newFromStock = gtk_radio_tool_button_new_from_stock;

    /// Creates a new `gtk.RadioToolButton` adding it to the same group as `gruup`
    extern fn gtk_radio_tool_button_new_from_widget(p_group: ?*gtk.RadioToolButton) *gtk.RadioToolButton;
    pub const newFromWidget = gtk_radio_tool_button_new_from_widget;

    /// Creates a new `gtk.RadioToolButton` adding it to the same group as `group`.
    /// The new `gtk.RadioToolButton` will contain an icon and label from the
    /// stock item indicated by `stock_id`.
    extern fn gtk_radio_tool_button_new_with_stock_from_widget(p_group: ?*gtk.RadioToolButton, p_stock_id: [*:0]const u8) *gtk.RadioToolButton;
    pub const newWithStockFromWidget = gtk_radio_tool_button_new_with_stock_from_widget;

    /// Returns the radio button group `button` belongs to.
    extern fn gtk_radio_tool_button_get_group(p_button: *RadioToolButton) *glib.SList;
    pub const getGroup = gtk_radio_tool_button_get_group;

    /// Adds `button` to `group`, removing it from the group it belonged to before.
    extern fn gtk_radio_tool_button_set_group(p_button: *RadioToolButton, p_group: ?*glib.SList) void;
    pub const setGroup = gtk_radio_tool_button_set_group;

    extern fn gtk_radio_tool_button_get_type() usize;
    pub const getGObjectType = gtk_radio_tool_button_get_type;

    extern fn g_object_ref(p_self: *gtk.RadioToolButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RadioToolButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RadioToolButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.Range` is the common base class for widgets which visualize an
/// adjustment, e.g `gtk.Scale` or `gtk.Scrollbar`.
///
/// Apart from signals for monitoring the parameters of the adjustment,
/// `gtk.Range` provides properties and methods for influencing the sensitivity
/// of the “steppers”. It also provides properties and methods for setting a
/// “fill level” on range widgets. See `gtk.Range.setFillLevel`.
pub const Range = extern struct {
    pub const Parent = gtk.Widget;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.RangeClass;
    f_widget: gtk.Widget,
    f_priv: ?*gtk.RangePrivate,

    pub const virtual_methods = struct {
        pub const adjust_bounds = struct {
            pub fn call(p_class: anytype, p_range: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_new_value: f64) void {
                return gobject.ext.as(Range.Class, p_class).f_adjust_bounds.?(gobject.ext.as(Range, p_range), p_new_value);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_range: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_new_value: f64) callconv(.c) void) void {
                gobject.ext.as(Range.Class, p_class).f_adjust_bounds = @ptrCast(p_implementation);
            }
        };

        pub const change_value = struct {
            pub fn call(p_class: anytype, p_range: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_scroll: gtk.ScrollType, p_new_value: f64) c_int {
                return gobject.ext.as(Range.Class, p_class).f_change_value.?(gobject.ext.as(Range, p_range), p_scroll, p_new_value);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_range: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_scroll: gtk.ScrollType, p_new_value: f64) callconv(.c) c_int) void {
                gobject.ext.as(Range.Class, p_class).f_change_value = @ptrCast(p_implementation);
            }
        };

        pub const get_range_border = struct {
            pub fn call(p_class: anytype, p_range: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_border_: *gtk.Border) void {
                return gobject.ext.as(Range.Class, p_class).f_get_range_border.?(gobject.ext.as(Range, p_range), p_border_);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_range: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_border_: *gtk.Border) callconv(.c) void) void {
                gobject.ext.as(Range.Class, p_class).f_get_range_border = @ptrCast(p_implementation);
            }
        };

        pub const get_range_size_request = struct {
            pub fn call(p_class: anytype, p_range: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_orientation: gtk.Orientation, p_minimum: *c_int, p_natural: *c_int) void {
                return gobject.ext.as(Range.Class, p_class).f_get_range_size_request.?(gobject.ext.as(Range, p_range), p_orientation, p_minimum, p_natural);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_range: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_orientation: gtk.Orientation, p_minimum: *c_int, p_natural: *c_int) callconv(.c) void) void {
                gobject.ext.as(Range.Class, p_class).f_get_range_size_request = @ptrCast(p_implementation);
            }
        };

        pub const move_slider = struct {
            pub fn call(p_class: anytype, p_range: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_scroll: gtk.ScrollType) void {
                return gobject.ext.as(Range.Class, p_class).f_move_slider.?(gobject.ext.as(Range, p_range), p_scroll);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_range: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_scroll: gtk.ScrollType) callconv(.c) void) void {
                gobject.ext.as(Range.Class, p_class).f_move_slider = @ptrCast(p_implementation);
            }
        };

        pub const value_changed = struct {
            pub fn call(p_class: anytype, p_range: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Range.Class, p_class).f_value_changed.?(gobject.ext.as(Range, p_range));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_range: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Range.Class, p_class).f_value_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const adjustment = struct {
            pub const name = "adjustment";

            pub const Type = ?*gtk.Adjustment;
        };

        /// The fill level (e.g. prebuffering of a network stream).
        /// See `gtk.Range.setFillLevel`.
        pub const fill_level = struct {
            pub const name = "fill-level";

            pub const Type = f64;
        };

        pub const inverted = struct {
            pub const name = "inverted";

            pub const Type = c_int;
        };

        pub const lower_stepper_sensitivity = struct {
            pub const name = "lower-stepper-sensitivity";

            pub const Type = gtk.SensitivityType;
        };

        /// The restrict-to-fill-level property controls whether slider
        /// movement is restricted to an upper boundary set by the
        /// fill level. See `gtk.Range.setRestrictToFillLevel`.
        pub const restrict_to_fill_level = struct {
            pub const name = "restrict-to-fill-level";

            pub const Type = c_int;
        };

        /// The number of digits to round the value to when
        /// it changes, or -1. See `gtk.Range.signals.change`-value.
        pub const round_digits = struct {
            pub const name = "round-digits";

            pub const Type = c_int;
        };

        /// The show-fill-level property controls whether fill level indicator
        /// graphics are displayed on the trough. See
        /// `gtk.Range.setShowFillLevel`.
        pub const show_fill_level = struct {
            pub const name = "show-fill-level";

            pub const Type = c_int;
        };

        pub const upper_stepper_sensitivity = struct {
            pub const name = "upper-stepper-sensitivity";

            pub const Type = gtk.SensitivityType;
        };
    };

    pub const signals = struct {
        /// Emitted before clamping a value, to give the application a
        /// chance to adjust the bounds.
        pub const adjust_bounds = struct {
            pub const name = "adjust-bounds";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_value: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Range, p_instance))),
                    gobject.signalLookup("adjust-bounds", Range.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The `gtk.Range.signals.change`-value signal is emitted when a scroll action is
        /// performed on a range.  It allows an application to determine the
        /// type of scroll event that occurred and the resultant new value.
        /// The application can handle the event itself and return `TRUE` to
        /// prevent further processing.  Or, by returning `FALSE`, it can pass
        /// the event to other handlers until the default GTK+ handler is
        /// reached.
        ///
        /// The value parameter is unrounded.  An application that overrides
        /// the GtkRange::change-value signal is responsible for clamping the
        /// value to the desired number of decimal digits; the default GTK+
        /// handler clamps the value based on `gtk.Range.properties.round`-digits.
        pub const change_value = struct {
            pub const name = "change-value";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_scroll: gtk.ScrollType, p_value: f64, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Range, p_instance))),
                    gobject.signalLookup("change-value", Range.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Virtual function that moves the slider. Used for keybindings.
        pub const move_slider = struct {
            pub const name = "move-slider";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_step: gtk.ScrollType, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Range, p_instance))),
                    gobject.signalLookup("move-slider", Range.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the range value changes.
        pub const value_changed = struct {
            pub const name = "value-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Range, p_instance))),
                    gobject.signalLookup("value-changed", Range.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Get the `gtk.Adjustment` which is the “model” object for `gtk.Range`.
    /// See `gtk.Range.setAdjustment` for details.
    /// The return value does not have a reference added, so should not
    /// be unreferenced.
    extern fn gtk_range_get_adjustment(p_range: *Range) *gtk.Adjustment;
    pub const getAdjustment = gtk_range_get_adjustment;

    /// Gets the current position of the fill level indicator.
    extern fn gtk_range_get_fill_level(p_range: *Range) f64;
    pub const getFillLevel = gtk_range_get_fill_level;

    /// Gets the value set by `gtk.Range.setFlippable`.
    extern fn gtk_range_get_flippable(p_range: *Range) c_int;
    pub const getFlippable = gtk_range_get_flippable;

    /// Gets the value set by `gtk.Range.setInverted`.
    extern fn gtk_range_get_inverted(p_range: *Range) c_int;
    pub const getInverted = gtk_range_get_inverted;

    /// Gets the sensitivity policy for the stepper that points to the
    /// 'lower' end of the GtkRange’s adjustment.
    extern fn gtk_range_get_lower_stepper_sensitivity(p_range: *Range) gtk.SensitivityType;
    pub const getLowerStepperSensitivity = gtk_range_get_lower_stepper_sensitivity;

    /// This function is useful mainly for `gtk.Range` subclasses.
    ///
    /// See `gtk.Range.setMinSliderSize`.
    extern fn gtk_range_get_min_slider_size(p_range: *Range) c_int;
    pub const getMinSliderSize = gtk_range_get_min_slider_size;

    /// This function returns the area that contains the range’s trough
    /// and its steppers, in widget->window coordinates.
    ///
    /// This function is useful mainly for `gtk.Range` subclasses.
    extern fn gtk_range_get_range_rect(p_range: *Range, p_range_rect: *gdk.Rectangle) void;
    pub const getRangeRect = gtk_range_get_range_rect;

    /// Gets whether the range is restricted to the fill level.
    extern fn gtk_range_get_restrict_to_fill_level(p_range: *Range) c_int;
    pub const getRestrictToFillLevel = gtk_range_get_restrict_to_fill_level;

    /// Gets the number of digits to round the value to when
    /// it changes. See `gtk.Range.signals.change`-value.
    extern fn gtk_range_get_round_digits(p_range: *Range) c_int;
    pub const getRoundDigits = gtk_range_get_round_digits;

    /// Gets whether the range displays the fill level graphically.
    extern fn gtk_range_get_show_fill_level(p_range: *Range) c_int;
    pub const getShowFillLevel = gtk_range_get_show_fill_level;

    /// This function returns sliders range along the long dimension,
    /// in widget->window coordinates.
    ///
    /// This function is useful mainly for `gtk.Range` subclasses.
    extern fn gtk_range_get_slider_range(p_range: *Range, p_slider_start: ?*c_int, p_slider_end: ?*c_int) void;
    pub const getSliderRange = gtk_range_get_slider_range;

    /// This function is useful mainly for `gtk.Range` subclasses.
    ///
    /// See `gtk.Range.setSliderSizeFixed`.
    extern fn gtk_range_get_slider_size_fixed(p_range: *Range) c_int;
    pub const getSliderSizeFixed = gtk_range_get_slider_size_fixed;

    /// Gets the sensitivity policy for the stepper that points to the
    /// 'upper' end of the GtkRange’s adjustment.
    extern fn gtk_range_get_upper_stepper_sensitivity(p_range: *Range) gtk.SensitivityType;
    pub const getUpperStepperSensitivity = gtk_range_get_upper_stepper_sensitivity;

    /// Gets the current value of the range.
    extern fn gtk_range_get_value(p_range: *Range) f64;
    pub const getValue = gtk_range_get_value;

    /// Sets the adjustment to be used as the “model” object for this range
    /// widget. The adjustment indicates the current range value, the
    /// minimum and maximum range values, the step/page increments used
    /// for keybindings and scrolling, and the page size. The page size
    /// is normally 0 for `gtk.Scale` and nonzero for `gtk.Scrollbar`, and
    /// indicates the size of the visible area of the widget being scrolled.
    /// The page size affects the size of the scrollbar slider.
    extern fn gtk_range_set_adjustment(p_range: *Range, p_adjustment: *gtk.Adjustment) void;
    pub const setAdjustment = gtk_range_set_adjustment;

    /// Set the new position of the fill level indicator.
    ///
    /// The “fill level” is probably best described by its most prominent
    /// use case, which is an indicator for the amount of pre-buffering in
    /// a streaming media player. In that use case, the value of the range
    /// would indicate the current play position, and the fill level would
    /// be the position up to which the file/stream has been downloaded.
    ///
    /// This amount of prebuffering can be displayed on the range’s trough
    /// and is themeable separately from the trough. To enable fill level
    /// display, use `gtk.Range.setShowFillLevel`. The range defaults
    /// to not showing the fill level.
    ///
    /// Additionally, it’s possible to restrict the range’s slider position
    /// to values which are smaller than the fill level. This is controller
    /// by `gtk.Range.setRestrictToFillLevel` and is by default
    /// enabled.
    extern fn gtk_range_set_fill_level(p_range: *Range, p_fill_level: f64) void;
    pub const setFillLevel = gtk_range_set_fill_level;

    /// If a range is flippable, it will switch its direction if it is
    /// horizontal and its direction is `GTK_TEXT_DIR_RTL`.
    ///
    /// See `gtk.Widget.getDirection`.
    extern fn gtk_range_set_flippable(p_range: *Range, p_flippable: c_int) void;
    pub const setFlippable = gtk_range_set_flippable;

    /// Sets the step and page sizes for the range.
    /// The step size is used when the user clicks the `gtk.Scrollbar`
    /// arrows or moves `gtk.Scale` via arrow keys. The page size
    /// is used for example when moving via Page Up or Page Down keys.
    extern fn gtk_range_set_increments(p_range: *Range, p_step: f64, p_page: f64) void;
    pub const setIncrements = gtk_range_set_increments;

    /// Ranges normally move from lower to higher values as the
    /// slider moves from top to bottom or left to right. Inverted
    /// ranges have higher values at the top or on the right rather than
    /// on the bottom or left.
    extern fn gtk_range_set_inverted(p_range: *Range, p_setting: c_int) void;
    pub const setInverted = gtk_range_set_inverted;

    /// Sets the sensitivity policy for the stepper that points to the
    /// 'lower' end of the GtkRange’s adjustment.
    extern fn gtk_range_set_lower_stepper_sensitivity(p_range: *Range, p_sensitivity: gtk.SensitivityType) void;
    pub const setLowerStepperSensitivity = gtk_range_set_lower_stepper_sensitivity;

    /// Sets the minimum size of the range’s slider.
    ///
    /// This function is useful mainly for `gtk.Range` subclasses.
    extern fn gtk_range_set_min_slider_size(p_range: *Range, p_min_size: c_int) void;
    pub const setMinSliderSize = gtk_range_set_min_slider_size;

    /// Sets the allowable values in the `gtk.Range`, and clamps the range
    /// value to be between `min` and `max`. (If the range has a non-zero
    /// page size, it is clamped between `min` and `max` - page-size.)
    extern fn gtk_range_set_range(p_range: *Range, p_min: f64, p_max: f64) void;
    pub const setRange = gtk_range_set_range;

    /// Sets whether the slider is restricted to the fill level. See
    /// `gtk.Range.setFillLevel` for a general description of the fill
    /// level concept.
    extern fn gtk_range_set_restrict_to_fill_level(p_range: *Range, p_restrict_to_fill_level: c_int) void;
    pub const setRestrictToFillLevel = gtk_range_set_restrict_to_fill_level;

    /// Sets the number of digits to round the value to when
    /// it changes. See `gtk.Range.signals.change`-value.
    extern fn gtk_range_set_round_digits(p_range: *Range, p_round_digits: c_int) void;
    pub const setRoundDigits = gtk_range_set_round_digits;

    /// Sets whether a graphical fill level is show on the trough. See
    /// `gtk.Range.setFillLevel` for a general description of the fill
    /// level concept.
    extern fn gtk_range_set_show_fill_level(p_range: *Range, p_show_fill_level: c_int) void;
    pub const setShowFillLevel = gtk_range_set_show_fill_level;

    /// Sets whether the range’s slider has a fixed size, or a size that
    /// depends on its adjustment’s page size.
    ///
    /// This function is useful mainly for `gtk.Range` subclasses.
    extern fn gtk_range_set_slider_size_fixed(p_range: *Range, p_size_fixed: c_int) void;
    pub const setSliderSizeFixed = gtk_range_set_slider_size_fixed;

    /// Sets the sensitivity policy for the stepper that points to the
    /// 'upper' end of the GtkRange’s adjustment.
    extern fn gtk_range_set_upper_stepper_sensitivity(p_range: *Range, p_sensitivity: gtk.SensitivityType) void;
    pub const setUpperStepperSensitivity = gtk_range_set_upper_stepper_sensitivity;

    /// Sets the current value of the range; if the value is outside the
    /// minimum or maximum range values, it will be clamped to fit inside
    /// them. The range emits the `gtk.Range.signals.value`-changed signal if the
    /// value changes.
    extern fn gtk_range_set_value(p_range: *Range, p_value: f64) void;
    pub const setValue = gtk_range_set_value;

    extern fn gtk_range_get_type() usize;
    pub const getGObjectType = gtk_range_get_type;

    extern fn g_object_ref(p_self: *gtk.Range) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Range) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Range, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RangeAccessible = extern struct {
    pub const Parent = gtk.WidgetAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Value };
    pub const Class = gtk.RangeAccessibleClass;
    f_parent: gtk.WidgetAccessible,
    f_priv: ?*gtk.RangeAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_range_accessible_get_type() usize;
    pub const getGObjectType = gtk_range_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.RangeAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RangeAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RangeAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.RcStyle`-struct is used to represent a set
/// of information about the appearance of a widget.
/// This can later be composited together with other
/// `gtk.RcStyle`-struct<!-- -->s to form a `gtk.Style`.
pub const RcStyle = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.RcStyleClass;
    f_parent_instance: gobject.Object,
    /// Name
    f_name: ?[*:0]u8,
    /// Pixmap name
    f_bg_pixmap_name: [5][*:0]u8,
    /// A `pango.FontDescription`
    f_font_desc: ?*pango.FontDescription,
    /// `gtk.RcFlags`
    f_color_flags: [5]gtk.RcFlags,
    /// Foreground colors
    f_fg: [5]gdk.Color,
    /// Background colors
    f_bg: [5]gdk.Color,
    /// Text colors
    f_text: [5]gdk.Color,
    /// Base colors
    f_base: [5]gdk.Color,
    /// X thickness
    f_xthickness: c_int,
    /// Y thickness
    f_ythickness: c_int,
    f_rc_properties: ?*glib.Array,
    f_rc_style_lists: ?*glib.SList,
    f_icon_factories: ?*glib.SList,
    bitfields0: packed struct(c_uint) {
        f_engine_specified: u1,
        _: u31,
    },

    pub const virtual_methods = struct {
        pub const create_rc_style = struct {
            pub fn call(p_class: anytype, p_rc_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gtk.RcStyle {
                return gobject.ext.as(RcStyle.Class, p_class).f_create_rc_style.?(gobject.ext.as(RcStyle, p_rc_style));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_rc_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gtk.RcStyle) void {
                gobject.ext.as(RcStyle.Class, p_class).f_create_rc_style = @ptrCast(p_implementation);
            }
        };

        pub const create_style = struct {
            pub fn call(p_class: anytype, p_rc_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gtk.Style {
                return gobject.ext.as(RcStyle.Class, p_class).f_create_style.?(gobject.ext.as(RcStyle, p_rc_style));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_rc_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gtk.Style) void {
                gobject.ext.as(RcStyle.Class, p_class).f_create_style = @ptrCast(p_implementation);
            }
        };

        pub const merge = struct {
            pub fn call(p_class: anytype, p_dest: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_src: *gtk.RcStyle) void {
                return gobject.ext.as(RcStyle.Class, p_class).f_merge.?(gobject.ext.as(RcStyle, p_dest), p_src);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_dest: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_src: *gtk.RcStyle) callconv(.c) void) void {
                gobject.ext.as(RcStyle.Class, p_class).f_merge = @ptrCast(p_implementation);
            }
        };

        pub const parse = struct {
            pub fn call(p_class: anytype, p_rc_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_settings: *gtk.Settings, p_scanner: *glib.Scanner) c_uint {
                return gobject.ext.as(RcStyle.Class, p_class).f_parse.?(gobject.ext.as(RcStyle, p_rc_style), p_settings, p_scanner);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_rc_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_settings: *gtk.Settings, p_scanner: *glib.Scanner) callconv(.c) c_uint) void {
                gobject.ext.as(RcStyle.Class, p_class).f_parse = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.RcStyle` with no fields set and
    /// a reference count of 1.
    extern fn gtk_rc_style_new() *gtk.RcStyle;
    pub const new = gtk_rc_style_new;

    /// Makes a copy of the specified `gtk.RcStyle`. This function
    /// will correctly copy an RC style that is a member of a class
    /// derived from `gtk.RcStyle`.
    extern fn gtk_rc_style_copy(p_orig: *RcStyle) *gtk.RcStyle;
    pub const copy = gtk_rc_style_copy;

    extern fn gtk_rc_style_get_type() usize;
    pub const getGObjectType = gtk_rc_style_get_type;

    extern fn g_object_ref(p_self: *gtk.RcStyle) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RcStyle) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RcStyle, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.RecentAction` represents a list of recently used files, which
/// can be shown by widgets such as `gtk.RecentChooserDialog` or
/// `gtk.RecentChooserMenu`.
///
/// To construct a submenu showing recently used files, use a `gtk.RecentAction`
/// as the action for a `<menuitem>`. To construct a menu toolbutton showing
/// the recently used files in the popup menu, use a `gtk.RecentAction` as the
/// action for a `<toolitem>` element.
pub const RecentAction = extern struct {
    pub const Parent = gtk.Action;
    pub const Implements = [_]type{ gtk.Buildable, gtk.RecentChooser };
    pub const Class = gtk.RecentActionClass;
    f_parent_instance: gtk.Action,
    f_priv: ?*gtk.RecentActionPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Whether the items should be displayed with a number.
        pub const show_numbers = struct {
            pub const name = "show-numbers";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.RecentAction` object. To add the action to
    /// a `gtk.ActionGroup` and set the accelerator for the action,
    /// call `gtk.ActionGroup.addActionWithAccel`.
    extern fn gtk_recent_action_new(p_name: [*:0]const u8, p_label: ?[*:0]const u8, p_tooltip: ?[*:0]const u8, p_stock_id: ?[*:0]const u8) *gtk.RecentAction;
    pub const new = gtk_recent_action_new;

    /// Creates a new `gtk.RecentAction` object. To add the action to
    /// a `gtk.ActionGroup` and set the accelerator for the action,
    /// call `gtk.ActionGroup.addActionWithAccel`.
    extern fn gtk_recent_action_new_for_manager(p_name: [*:0]const u8, p_label: ?[*:0]const u8, p_tooltip: ?[*:0]const u8, p_stock_id: ?[*:0]const u8, p_manager: ?*gtk.RecentManager) *gtk.RecentAction;
    pub const newForManager = gtk_recent_action_new_for_manager;

    /// Returns the value set by `gtk.RecentChooserMenu.setShowNumbers`.
    extern fn gtk_recent_action_get_show_numbers(p_action: *RecentAction) c_int;
    pub const getShowNumbers = gtk_recent_action_get_show_numbers;

    /// Sets whether a number should be added to the items shown by the
    /// widgets representing `action`. The numbers are shown to provide
    /// a unique character for a mnemonic to be used inside the menu item's
    /// label. Only the first ten items get a number to avoid clashes.
    extern fn gtk_recent_action_set_show_numbers(p_action: *RecentAction, p_show_numbers: c_int) void;
    pub const setShowNumbers = gtk_recent_action_set_show_numbers;

    extern fn gtk_recent_action_get_type() usize;
    pub const getGObjectType = gtk_recent_action_get_type;

    extern fn g_object_ref(p_self: *gtk.RecentAction) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RecentAction) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RecentAction, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.RecentChooserDialog` is a dialog box suitable for displaying the recently
/// used documents.  This widgets works by putting a `gtk.RecentChooserWidget` inside
/// a `gtk.Dialog`.  It exposes the `gtk.RecentChooserIface` interface, so you can use
/// all the `gtk.RecentChooser` functions on the recent chooser dialog as well as
/// those for `gtk.Dialog`.
///
/// Note that `gtk.RecentChooserDialog` does not have any methods of its own.
/// Instead, you should use the functions that work on a `gtk.RecentChooser`.
///
/// ## Typical usage
///
/// In the simplest of cases, you can use the following code to use
/// a `gtk.RecentChooserDialog` to select a recently used file:
///
/// ```
/// GtkWidget *dialog;
/// gint res;
///
/// dialog = gtk_recent_chooser_dialog_new ("Recent Documents",
///                                         parent_window,
///                                         _("_Cancel"),
///                                         GTK_RESPONSE_CANCEL,
///                                         _("_Open"),
///                                         GTK_RESPONSE_ACCEPT,
///                                         NULL);
///
/// res = gtk_dialog_run (GTK_DIALOG (dialog));
/// if (res == GTK_RESPONSE_ACCEPT)
///   {
///     GtkRecentInfo *info;
///     GtkRecentChooser *chooser = GTK_RECENT_CHOOSER (dialog);
///
///     info = gtk_recent_chooser_get_current_item (chooser);
///     open_file (gtk_recent_info_get_uri (info));
///     gtk_recent_info_unref (info);
///   }
///
/// gtk_widget_destroy (dialog);
/// ```
///
/// Recently used files are supported since GTK+ 2.10.
pub const RecentChooserDialog = extern struct {
    pub const Parent = gtk.Dialog;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.RecentChooser };
    pub const Class = gtk.RecentChooserDialogClass;
    f_parent_instance: gtk.Dialog,
    f_priv: ?*gtk.RecentChooserDialogPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.RecentChooserDialog`.  This function is analogous to
    /// `gtk.Dialog.newWithButtons`.
    extern fn gtk_recent_chooser_dialog_new(p_title: ?[*:0]const u8, p_parent: ?*gtk.Window, p_first_button_text: ?[*:0]const u8, ...) *gtk.RecentChooserDialog;
    pub const new = gtk_recent_chooser_dialog_new;

    /// Creates a new `gtk.RecentChooserDialog` with a specified recent manager.
    ///
    /// This is useful if you have implemented your own recent manager, or if you
    /// have a customized instance of a `gtk.RecentManager` object.
    extern fn gtk_recent_chooser_dialog_new_for_manager(p_title: ?[*:0]const u8, p_parent: ?*gtk.Window, p_manager: *gtk.RecentManager, p_first_button_text: ?[*:0]const u8, ...) *gtk.RecentChooserDialog;
    pub const newForManager = gtk_recent_chooser_dialog_new_for_manager;

    extern fn gtk_recent_chooser_dialog_get_type() usize;
    pub const getGObjectType = gtk_recent_chooser_dialog_get_type;

    extern fn g_object_ref(p_self: *gtk.RecentChooserDialog) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RecentChooserDialog) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RecentChooserDialog, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.RecentChooserMenu` is a widget suitable for displaying recently used files
/// inside a menu.  It can be used to set a sub-menu of a `gtk.MenuItem` using
/// `gtk.MenuItem.setSubmenu`, or as the menu of a `gtk.MenuToolButton`.
///
/// Note that `gtk.RecentChooserMenu` does not have any methods of its own. Instead,
/// you should use the functions that work on a `gtk.RecentChooser`.
///
/// Note also that `gtk.RecentChooserMenu` does not support multiple filters, as it
/// has no way to let the user choose between them as the `gtk.RecentChooserWidget`
/// and `gtk.RecentChooserDialog` widgets do. Thus using `gtk.RecentChooser.addFilter`
/// on a `gtk.RecentChooserMenu` widget will yield the same effects as using
/// `gtk.RecentChooser.setFilter`, replacing any currently set filter
/// with the supplied filter; `gtk.RecentChooser.removeFilter` will remove
/// any currently set `gtk.RecentFilter` object and will unset the current filter;
/// `gtk.RecentChooser.listFilters` will return a list containing a single
/// `gtk.RecentFilter` object.
///
/// Recently used files are supported since GTK+ 2.10.
pub const RecentChooserMenu = extern struct {
    pub const Parent = gtk.Menu;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Activatable, gtk.Buildable, gtk.RecentChooser };
    pub const Class = gtk.RecentChooserMenuClass;
    f_parent_instance: gtk.Menu,
    f_priv: ?*gtk.RecentChooserMenuPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Whether the first ten items in the menu should be prepended by
        /// a number acting as a unique mnemonic.
        pub const show_numbers = struct {
            pub const name = "show-numbers";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.RecentChooserMenu` widget.
    ///
    /// This kind of widget shows the list of recently used resources as
    /// a menu, each item as a menu item.  Each item inside the menu might
    /// have an icon, representing its MIME type, and a number, for mnemonic
    /// access.
    ///
    /// This widget implements the `gtk.RecentChooser` interface.
    ///
    /// This widget creates its own `gtk.RecentManager` object.  See the
    /// `gtk.RecentChooserMenu.newForManager` function to know how to create
    /// a `gtk.RecentChooserMenu` widget bound to another `gtk.RecentManager` object.
    extern fn gtk_recent_chooser_menu_new() *gtk.RecentChooserMenu;
    pub const new = gtk_recent_chooser_menu_new;

    /// Creates a new `gtk.RecentChooserMenu` widget using `manager` as
    /// the underlying recently used resources manager.
    ///
    /// This is useful if you have implemented your own recent manager,
    /// or if you have a customized instance of a `gtk.RecentManager`
    /// object or if you wish to share a common `gtk.RecentManager` object
    /// among multiple `gtk.RecentChooser` widgets.
    extern fn gtk_recent_chooser_menu_new_for_manager(p_manager: *gtk.RecentManager) *gtk.RecentChooserMenu;
    pub const newForManager = gtk_recent_chooser_menu_new_for_manager;

    /// Returns the value set by `gtk.RecentChooserMenu.setShowNumbers`.
    extern fn gtk_recent_chooser_menu_get_show_numbers(p_menu: *RecentChooserMenu) c_int;
    pub const getShowNumbers = gtk_recent_chooser_menu_get_show_numbers;

    /// Sets whether a number should be added to the items of `menu`.  The
    /// numbers are shown to provide a unique character for a mnemonic to
    /// be used inside ten menu item’s label.  Only the first the items
    /// get a number to avoid clashes.
    extern fn gtk_recent_chooser_menu_set_show_numbers(p_menu: *RecentChooserMenu, p_show_numbers: c_int) void;
    pub const setShowNumbers = gtk_recent_chooser_menu_set_show_numbers;

    extern fn gtk_recent_chooser_menu_get_type() usize;
    pub const getGObjectType = gtk_recent_chooser_menu_get_type;

    extern fn g_object_ref(p_self: *gtk.RecentChooserMenu) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RecentChooserMenu) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RecentChooserMenu, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.RecentChooserWidget` is a widget suitable for selecting recently used
/// files.  It is the main building block of a `gtk.RecentChooserDialog`.  Most
/// applications will only need to use the latter; you can use
/// `gtk.RecentChooserWidget` as part of a larger window if you have special needs.
///
/// Note that `gtk.RecentChooserWidget` does not have any methods of its own.
/// Instead, you should use the functions that work on a `gtk.RecentChooser`.
///
/// Recently used files are supported since GTK+ 2.10.
pub const RecentChooserWidget = extern struct {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable, gtk.RecentChooser };
    pub const Class = gtk.RecentChooserWidgetClass;
    f_parent_instance: gtk.Box,
    f_priv: ?*gtk.RecentChooserWidgetPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.RecentChooserWidget` object.  This is an embeddable widget
    /// used to access the recently used resources list.
    extern fn gtk_recent_chooser_widget_new() *gtk.RecentChooserWidget;
    pub const new = gtk_recent_chooser_widget_new;

    /// Creates a new `gtk.RecentChooserWidget` with a specified recent manager.
    ///
    /// This is useful if you have implemented your own recent manager, or if you
    /// have a customized instance of a `gtk.RecentManager` object.
    extern fn gtk_recent_chooser_widget_new_for_manager(p_manager: *gtk.RecentManager) *gtk.RecentChooserWidget;
    pub const newForManager = gtk_recent_chooser_widget_new_for_manager;

    extern fn gtk_recent_chooser_widget_get_type() usize;
    pub const getGObjectType = gtk_recent_chooser_widget_get_type;

    extern fn g_object_ref(p_self: *gtk.RecentChooserWidget) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RecentChooserWidget) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RecentChooserWidget, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.RecentFilter` can be used to restrict the files being shown
/// in a `gtk.RecentChooser`.  Files can be filtered based on their name
/// (with `gtk.RecentFilter.addPattern`), on their mime type (with
/// `gtk.FileFilter.addMimeType`), on the application that has
/// registered them (with `gtk.RecentFilter.addApplication`), or by
/// a custom filter function (with `gtk.RecentFilter.addCustom`).
///
/// Filtering by mime type handles aliasing and subclassing of mime
/// types; e.g. a filter for text/plain also matches a file with mime
/// type application/rtf, since application/rtf is a subclass of text/plain.
/// Note that `gtk.RecentFilter` allows wildcards for the subtype of a
/// mime type, so you can e.g. filter for image/\*.
///
/// Normally, filters are used by adding them to a `gtk.RecentChooser`,
/// see `gtk.RecentChooser.addFilter`, but it is also possible to
/// manually use a filter on a file with `gtk.RecentFilter.filter`.
///
/// Recently used files are supported since GTK+ 2.10.
///
/// ## GtkRecentFilter as GtkBuildable
///
/// The GtkRecentFilter implementation of the GtkBuildable interface
/// supports adding rules using the `<mime-types>`, `<patterns>` and
/// `<applications>` elements and listing the rules within. Specifying
/// a `<mime-type>`, `<pattern>` or `<application>` has the same effect as
/// calling `gtk.RecentFilter.addMimeType`,
/// `gtk.RecentFilter.addPattern` or `gtk.RecentFilter.addApplication`.
///
/// An example of a UI definition fragment specifying `GtkRecentFilter`
/// rules:
///
/// ```
/// <object class="GtkRecentFilter">
///   <mime-types>
///     <mime-type>text/plain</mime-type>
///     <mime-type>image/png</mime-type>
///   </mime-types>
///   <patterns>
///     <pattern>*.txt</pattern>
///     <pattern>*.png</pattern>
///   </patterns>
///   <applications>
///     <application>gimp</application>
///     <application>gedit</application>
///     <application>glade</application>
///   </applications>
/// </object>
/// ```
pub const RecentFilter = opaque {
    pub const Parent = gobject.InitiallyUnowned;
    pub const Implements = [_]type{gtk.Buildable};
    pub const Class = opaque {
        pub const Instance = RecentFilter;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.RecentFilter` with no rules added to it.
    /// Such filter does not accept any recently used resources, so is not
    /// particularly useful until you add rules with
    /// `gtk.RecentFilter.addPattern`, `gtk.RecentFilter.addMimeType`,
    /// `gtk.RecentFilter.addApplication`, `gtk.RecentFilter.addAge`.
    /// To create a filter that accepts any recently used resource, use:
    /// ```
    /// GtkRecentFilter *filter = gtk_recent_filter_new ();
    /// gtk_recent_filter_add_pattern (filter, "*");
    /// ```
    extern fn gtk_recent_filter_new() *gtk.RecentFilter;
    pub const new = gtk_recent_filter_new;

    /// Adds a rule that allows resources based on their age - that is, the number
    /// of days elapsed since they were last modified.
    extern fn gtk_recent_filter_add_age(p_filter: *RecentFilter, p_days: c_int) void;
    pub const addAge = gtk_recent_filter_add_age;

    /// Adds a rule that allows resources based on the name of the application
    /// that has registered them.
    extern fn gtk_recent_filter_add_application(p_filter: *RecentFilter, p_application: [*:0]const u8) void;
    pub const addApplication = gtk_recent_filter_add_application;

    /// Adds a rule to a filter that allows resources based on a custom callback
    /// function. The bitfield `needed` which is passed in provides information
    /// about what sorts of information that the filter function needs;
    /// this allows GTK+ to avoid retrieving expensive information when
    /// it isn’t needed by the filter.
    extern fn gtk_recent_filter_add_custom(p_filter: *RecentFilter, p_needed: gtk.RecentFilterFlags, p_func: gtk.RecentFilterFunc, p_data: ?*anyopaque, p_data_destroy: ?glib.DestroyNotify) void;
    pub const addCustom = gtk_recent_filter_add_custom;

    /// Adds a rule that allows resources based on the name of the group
    /// to which they belong
    extern fn gtk_recent_filter_add_group(p_filter: *RecentFilter, p_group: [*:0]const u8) void;
    pub const addGroup = gtk_recent_filter_add_group;

    /// Adds a rule that allows resources based on their registered MIME type.
    extern fn gtk_recent_filter_add_mime_type(p_filter: *RecentFilter, p_mime_type: [*:0]const u8) void;
    pub const addMimeType = gtk_recent_filter_add_mime_type;

    /// Adds a rule that allows resources based on a pattern matching their
    /// display name.
    extern fn gtk_recent_filter_add_pattern(p_filter: *RecentFilter, p_pattern: [*:0]const u8) void;
    pub const addPattern = gtk_recent_filter_add_pattern;

    /// Adds a rule allowing image files in the formats supported
    /// by GdkPixbuf.
    extern fn gtk_recent_filter_add_pixbuf_formats(p_filter: *RecentFilter) void;
    pub const addPixbufFormats = gtk_recent_filter_add_pixbuf_formats;

    /// Tests whether a file should be displayed according to `filter`.
    /// The `gtk.RecentFilterInfo` `filter_info` should include
    /// the fields returned from `gtk.RecentFilter.getNeeded`, and
    /// must set the `gtk.RecentFilterInfo.contains` field of `filter_info`
    /// to indicate which fields have been set.
    ///
    /// This function will not typically be used by applications; it
    /// is intended principally for use in the implementation of
    /// `gtk.RecentChooser`.
    extern fn gtk_recent_filter_filter(p_filter: *RecentFilter, p_filter_info: *const gtk.RecentFilterInfo) c_int;
    pub const filter = gtk_recent_filter_filter;

    /// Gets the human-readable name for the filter.
    /// See `gtk.RecentFilter.setName`.
    extern fn gtk_recent_filter_get_name(p_filter: *RecentFilter) ?[*:0]const u8;
    pub const getName = gtk_recent_filter_get_name;

    /// Gets the fields that need to be filled in for the `gtk.RecentFilterInfo`
    /// passed to `gtk.RecentFilter.filter`
    ///
    /// This function will not typically be used by applications; it
    /// is intended principally for use in the implementation of
    /// `gtk.RecentChooser`.
    extern fn gtk_recent_filter_get_needed(p_filter: *RecentFilter) gtk.RecentFilterFlags;
    pub const getNeeded = gtk_recent_filter_get_needed;

    /// Sets the human-readable name of the filter; this is the string
    /// that will be displayed in the recently used resources selector
    /// user interface if there is a selectable list of filters.
    extern fn gtk_recent_filter_set_name(p_filter: *RecentFilter, p_name: [*:0]const u8) void;
    pub const setName = gtk_recent_filter_set_name;

    extern fn gtk_recent_filter_get_type() usize;
    pub const getGObjectType = gtk_recent_filter_get_type;

    extern fn g_object_ref(p_self: *gtk.RecentFilter) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RecentFilter) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RecentFilter, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.RecentManager` provides a facility for adding, removing and
/// looking up recently used files. Each recently used file is
/// identified by its URI, and has meta-data associated to it, like
/// the names and command lines of the applications that have
/// registered it, the number of time each application has registered
/// the same file, the mime type of the file and whether the file
/// should be displayed only by the applications that have
/// registered it.
///
/// The recently used files list is per user.
///
/// The `gtk.RecentManager` acts like a database of all the recently
/// used files. You can create new `gtk.RecentManager` objects, but
/// it is more efficient to use the default manager created by GTK+.
///
/// Adding a new recently used file is as simple as:
///
/// ```
/// GtkRecentManager *manager;
///
/// manager = gtk_recent_manager_get_default ();
/// gtk_recent_manager_add_item (manager, file_uri);
/// ```
///
/// The `gtk.RecentManager` will try to gather all the needed information
/// from the file itself through GIO.
///
/// Looking up the meta-data associated with a recently used file
/// given its URI requires calling `gtk.RecentManager.lookupItem`:
///
/// ```
/// GtkRecentManager *manager;
/// GtkRecentInfo *info;
/// GError *error = NULL;
///
/// manager = gtk_recent_manager_get_default ();
/// info = gtk_recent_manager_lookup_item (manager, file_uri, &error);
/// if (error)
///   {
///     g_warning ("Could not find the file: `s`", error->message);
///     g_error_free (error);
///   }
/// else
///  {
///    // Use the info object
///    gtk_recent_info_unref (info);
///  }
/// ```
///
/// In order to retrieve the list of recently used files, you can use
/// `gtk.RecentManager.getItems`, which returns a list of `gtk.RecentInfo`-structs.
///
/// A `gtk.RecentManager` is the model used to populate the contents of
/// one, or more `gtk.RecentChooser` implementations.
///
/// Note that the maximum age of the recently used files list is
/// controllable through the `gtk.Settings.properties.gtk`-recent-files-max-age
/// property.
///
/// Recently used files are supported since GTK+ 2.10.
pub const RecentManager = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.RecentManagerClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.RecentManagerPrivate,

    pub const virtual_methods = struct {
        pub const changed = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(RecentManager.Class, p_class).f_changed.?(gobject.ext.as(RecentManager, p_manager));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(RecentManager.Class, p_class).f_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The full path to the file to be used to store and read the
        /// recently used resources list
        pub const filename = struct {
            pub const name = "filename";

            pub const Type = ?[*:0]u8;
        };

        /// The size of the recently used resources list.
        pub const size = struct {
            pub const name = "size";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted when the current recently used resources manager changes
        /// its contents, either by calling `gtk.RecentManager.addItem` or
        /// by another application.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(RecentManager, p_instance))),
                    gobject.signalLookup("changed", RecentManager.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Gets a unique instance of `gtk.RecentManager`, that you can share
    /// in your application without caring about memory management.
    extern fn gtk_recent_manager_get_default() *gtk.RecentManager;
    pub const getDefault = gtk_recent_manager_get_default;

    /// Creates a new recent manager object. Recent manager objects are used to
    /// handle the list of recently used resources. A `gtk.RecentManager` object
    /// monitors the recently used resources list, and emits the “changed” signal
    /// each time something inside the list changes.
    ///
    /// `gtk.RecentManager` objects are expensive: be sure to create them only when
    /// needed. You should use `gtk.RecentManager.getDefault` instead.
    extern fn gtk_recent_manager_new() *gtk.RecentManager;
    pub const new = gtk_recent_manager_new;

    /// Adds a new resource, pointed by `uri`, into the recently used
    /// resources list, using the metadata specified inside the
    /// `gtk.RecentData`-struct passed in `recent_data`.
    ///
    /// The passed URI will be used to identify this resource inside the
    /// list.
    ///
    /// In order to register the new recently used resource, metadata about
    /// the resource must be passed as well as the URI; the metadata is
    /// stored in a `gtk.RecentData`-struct, which must contain the MIME
    /// type of the resource pointed by the URI; the name of the application
    /// that is registering the item, and a command line to be used when
    /// launching the item.
    ///
    /// Optionally, a `gtk.RecentData`-struct might contain a UTF-8 string
    /// to be used when viewing the item instead of the last component of
    /// the URI; a short description of the item; whether the item should
    /// be considered private - that is, should be displayed only by the
    /// applications that have registered it.
    extern fn gtk_recent_manager_add_full(p_manager: *RecentManager, p_uri: [*:0]const u8, p_recent_data: *const gtk.RecentData) c_int;
    pub const addFull = gtk_recent_manager_add_full;

    /// Adds a new resource, pointed by `uri`, into the recently used
    /// resources list.
    ///
    /// This function automatically retrieves some of the needed
    /// metadata and setting other metadata to common default values;
    /// it then feeds the data to `gtk.RecentManager.addFull`.
    ///
    /// See `gtk.RecentManager.addFull` if you want to explicitly
    /// define the metadata for the resource pointed by `uri`.
    extern fn gtk_recent_manager_add_item(p_manager: *RecentManager, p_uri: [*:0]const u8) c_int;
    pub const addItem = gtk_recent_manager_add_item;

    /// Gets the list of recently used resources.
    extern fn gtk_recent_manager_get_items(p_manager: *RecentManager) *glib.List;
    pub const getItems = gtk_recent_manager_get_items;

    /// Checks whether there is a recently used resource registered
    /// with `uri` inside the recent manager.
    extern fn gtk_recent_manager_has_item(p_manager: *RecentManager, p_uri: [*:0]const u8) c_int;
    pub const hasItem = gtk_recent_manager_has_item;

    /// Searches for a URI inside the recently used resources list, and
    /// returns a `gtk.RecentInfo`-struct containing informations about the resource
    /// like its MIME type, or its display name.
    extern fn gtk_recent_manager_lookup_item(p_manager: *RecentManager, p_uri: [*:0]const u8, p_error: ?*?*glib.Error) ?*gtk.RecentInfo;
    pub const lookupItem = gtk_recent_manager_lookup_item;

    /// Changes the location of a recently used resource from `uri` to `new_uri`.
    ///
    /// Please note that this function will not affect the resource pointed
    /// by the URIs, but only the URI used in the recently used resources list.
    extern fn gtk_recent_manager_move_item(p_manager: *RecentManager, p_uri: [*:0]const u8, p_new_uri: ?[*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const moveItem = gtk_recent_manager_move_item;

    /// Purges every item from the recently used resources list.
    extern fn gtk_recent_manager_purge_items(p_manager: *RecentManager, p_error: ?*?*glib.Error) c_int;
    pub const purgeItems = gtk_recent_manager_purge_items;

    /// Removes a resource pointed by `uri` from the recently used resources
    /// list handled by a recent manager.
    extern fn gtk_recent_manager_remove_item(p_manager: *RecentManager, p_uri: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const removeItem = gtk_recent_manager_remove_item;

    extern fn gtk_recent_manager_get_type() usize;
    pub const getGObjectType = gtk_recent_manager_get_type;

    extern fn g_object_ref(p_self: *gtk.RecentManager) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RecentManager) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RecentManager, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RendererCellAccessible = extern struct {
    pub const Parent = gtk.CellAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.TableCell };
    pub const Class = gtk.RendererCellAccessibleClass;
    f_parent: gtk.CellAccessible,
    f_priv: ?*gtk.RendererCellAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const renderer = struct {
            pub const name = "renderer";

            pub const Type = ?*gtk.CellRenderer;
        };
    };

    pub const signals = struct {};

    extern fn gtk_renderer_cell_accessible_new(p_renderer: *gtk.CellRenderer) *gtk.RendererCellAccessible;
    pub const new = gtk_renderer_cell_accessible_new;

    extern fn gtk_renderer_cell_accessible_get_type() usize;
    pub const getGObjectType = gtk_renderer_cell_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.RendererCellAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RendererCellAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RendererCellAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The GtkRevealer widget is a container which animates
/// the transition of its child from invisible to visible.
///
/// The style of transition can be controlled with
/// `gtk.Revealer.setTransitionType`.
///
/// These animations respect the `gtk.Settings.properties.gtk`-enable-animations
/// setting.
///
/// # CSS nodes
///
/// GtkRevealer has a single CSS node with name revealer.
///
/// The GtkRevealer widget was added in GTK+ 3.10.
pub const Revealer = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.RevealerClass;
    f_parent_instance: gtk.Bin,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const child_revealed = struct {
            pub const name = "child-revealed";

            pub const Type = c_int;
        };

        pub const reveal_child = struct {
            pub const name = "reveal-child";

            pub const Type = c_int;
        };

        pub const transition_duration = struct {
            pub const name = "transition-duration";

            pub const Type = c_uint;
        };

        pub const transition_type = struct {
            pub const name = "transition-type";

            pub const Type = gtk.RevealerTransitionType;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.Revealer`.
    extern fn gtk_revealer_new() *gtk.Revealer;
    pub const new = gtk_revealer_new;

    /// Returns whether the child is fully revealed, in other words whether
    /// the transition to the revealed state is completed.
    extern fn gtk_revealer_get_child_revealed(p_revealer: *Revealer) c_int;
    pub const getChildRevealed = gtk_revealer_get_child_revealed;

    /// Returns whether the child is currently
    /// revealed. See `gtk.Revealer.setRevealChild`.
    ///
    /// This function returns `TRUE` as soon as the transition
    /// is to the revealed state is started. To learn whether
    /// the child is fully revealed (ie the transition is completed),
    /// use `gtk.Revealer.getChildRevealed`.
    extern fn gtk_revealer_get_reveal_child(p_revealer: *Revealer) c_int;
    pub const getRevealChild = gtk_revealer_get_reveal_child;

    /// Returns the amount of time (in milliseconds) that
    /// transitions will take.
    extern fn gtk_revealer_get_transition_duration(p_revealer: *Revealer) c_uint;
    pub const getTransitionDuration = gtk_revealer_get_transition_duration;

    /// Gets the type of animation that will be used
    /// for transitions in `revealer`.
    extern fn gtk_revealer_get_transition_type(p_revealer: *Revealer) gtk.RevealerTransitionType;
    pub const getTransitionType = gtk_revealer_get_transition_type;

    /// Tells the `gtk.Revealer` to reveal or conceal its child.
    ///
    /// The transition will be animated with the current
    /// transition type of `revealer`.
    extern fn gtk_revealer_set_reveal_child(p_revealer: *Revealer, p_reveal_child: c_int) void;
    pub const setRevealChild = gtk_revealer_set_reveal_child;

    /// Sets the duration that transitions will take.
    extern fn gtk_revealer_set_transition_duration(p_revealer: *Revealer, p_duration: c_uint) void;
    pub const setTransitionDuration = gtk_revealer_set_transition_duration;

    /// Sets the type of animation that will be used for
    /// transitions in `revealer`. Available types include
    /// various kinds of fades and slides.
    extern fn gtk_revealer_set_transition_type(p_revealer: *Revealer, p_transition: gtk.RevealerTransitionType) void;
    pub const setTransitionType = gtk_revealer_set_transition_type;

    extern fn gtk_revealer_get_type() usize;
    pub const getGObjectType = gtk_revealer_get_type;

    extern fn g_object_ref(p_self: *gtk.Revealer) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Revealer) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Revealer, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkScale is a slider control used to select a numeric value.
/// To use it, you’ll probably want to investigate the methods on
/// its base class, `gtk.Range`, in addition to the methods for GtkScale itself.
/// To set the value of a scale, you would normally use `gtk.Range.setValue`.
/// To detect changes to the value, you would normally use the
/// `gtk.Range.signals.value`-changed signal.
///
/// Note that using the same upper and lower bounds for the `gtk.Scale` (through
/// the `gtk.Range` methods) will hide the slider itself. This is useful for
/// applications that want to show an undeterminate value on the scale, without
/// changing the layout of the application (such as movie or music players).
///
/// # GtkScale as GtkBuildable
///
/// GtkScale supports a custom `<marks>` element, which can contain multiple
/// `<mark>` elements. The “value” and “position” attributes have the same
/// meaning as `gtk.Scale.addMark` parameters of the same name. If the
/// element is not empty, its content is taken as the markup to show at
/// the mark. It can be translated with the usual ”translatable” and
/// “context” attributes.
///
/// # CSS nodes
///
/// ```
/// scale[.fine-tune][.marks-before][.marks-after]
/// ├── marks.top
/// │   ├── mark
/// │   ┊    ├── [label]
/// │   ┊    ╰── indicator
/// ┊   ┊
/// │   ╰── mark
/// ├── [value]
/// ├── contents
/// │   ╰── trough
/// │       ├── slider
/// │       ├── [highlight]
/// │       ╰── [fill]
/// ╰── marks.bottom
///     ├── mark
///     ┊    ├── indicator
///     ┊    ╰── [label]
///     ╰── mark
/// ```
///
/// GtkScale has a main CSS node with name scale and a subnode for its contents,
/// with subnodes named trough and slider.
///
/// The main node gets the style class .fine-tune added when the scale is in
/// 'fine-tuning' mode.
///
/// If the scale has an origin (see `gtk.Scale.setHasOrigin`), there is a
/// subnode with name highlight below the trough node that is used for rendering
/// the highlighted part of the trough.
///
/// If the scale is showing a fill level (see `gtk.Range.setShowFillLevel`),
/// there is a subnode with name fill below the trough node that is used for
/// rendering the filled in part of the trough.
///
/// If marks are present, there is a marks subnode before or after the contents
/// node, below which each mark gets a node with name mark. The marks nodes get
/// either the .top or .bottom style class.
///
/// The mark node has a subnode named indicator. If the mark has text, it also
/// has a subnode named label. When the mark is either above or left of the
/// scale, the label subnode is the first when present. Otherwise, the indicator
/// subnode is the first.
///
/// The main CSS node gets the 'marks-before' and/or 'marks-after' style classes
/// added depending on what marks are present.
///
/// If the scale is displaying the value (see `gtk.Scale.properties.draw`-value), there is
/// subnode with name value.
pub const Scale = extern struct {
    pub const Parent = gtk.Range;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.ScaleClass;
    f_range: gtk.Range,
    f_priv: ?*gtk.ScalePrivate,

    pub const virtual_methods = struct {
        pub const draw_value = struct {
            pub fn call(p_class: anytype, p_scale: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Scale.Class, p_class).f_draw_value.?(gobject.ext.as(Scale, p_scale));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_scale: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Scale.Class, p_class).f_draw_value = @ptrCast(p_implementation);
            }
        };

        pub const format_value = struct {
            pub fn call(p_class: anytype, p_scale: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_value: f64) [*:0]u8 {
                return gobject.ext.as(Scale.Class, p_class).f_format_value.?(gobject.ext.as(Scale, p_scale), p_value);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_scale: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_value: f64) callconv(.c) [*:0]u8) void {
                gobject.ext.as(Scale.Class, p_class).f_format_value = @ptrCast(p_implementation);
            }
        };

        /// Obtains the coordinates where the scale will draw the
        /// `pango.Layout` representing the text in the scale. Remember
        /// when using the `pango.Layout` function you need to convert to
        /// and from pixels using `PANGO_PIXELS` or `PANGO_SCALE`.
        ///
        /// If the `gtk.Scale.properties.draw`-value property is `FALSE`, the return
        /// values are undefined.
        pub const get_layout_offsets = struct {
            pub fn call(p_class: anytype, p_scale: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_x: ?*c_int, p_y: ?*c_int) void {
                return gobject.ext.as(Scale.Class, p_class).f_get_layout_offsets.?(gobject.ext.as(Scale, p_scale), p_x, p_y);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_scale: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_x: ?*c_int, p_y: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(Scale.Class, p_class).f_get_layout_offsets = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const digits = struct {
            pub const name = "digits";

            pub const Type = c_int;
        };

        pub const draw_value = struct {
            pub const name = "draw-value";

            pub const Type = c_int;
        };

        pub const has_origin = struct {
            pub const name = "has-origin";

            pub const Type = c_int;
        };

        pub const value_pos = struct {
            pub const name = "value-pos";

            pub const Type = gtk.PositionType;
        };
    };

    pub const signals = struct {
        /// Signal which allows you to change how the scale value is displayed.
        /// Connect a signal handler which returns an allocated string representing
        /// `value`. That string will then be used to display the scale's value.
        ///
        /// If no user-provided handlers are installed, the value will be displayed on
        /// its own, rounded according to the value of the `gtk.Scale.properties.digits` property.
        ///
        /// Here's an example signal handler which displays a value 1.0 as
        /// with "-->1.0<--".
        /// ```
        /// static gchar*
        /// format_value_callback (GtkScale *scale,
        ///                        gdouble   value)
        /// {
        ///   return g_strdup_printf ("-->\%0.*g<--",
        ///                           gtk_scale_get_digits (scale), value);
        ///  }
        /// ```
        pub const format_value = struct {
            pub const name = "format-value";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_value: f64, P_Data) callconv(.c) [*:0]u8, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Scale, p_instance))),
                    gobject.signalLookup("format-value", Scale.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.Scale`.
    extern fn gtk_scale_new(p_orientation: gtk.Orientation, p_adjustment: ?*gtk.Adjustment) *gtk.Scale;
    pub const new = gtk_scale_new;

    /// Creates a new scale widget with the given orientation that lets the
    /// user input a number between `min` and `max` (including `min` and `max`)
    /// with the increment `step`.  `step` must be nonzero; it’s the distance
    /// the slider moves when using the arrow keys to adjust the scale
    /// value.
    ///
    /// Note that the way in which the precision is derived works best if `step`
    /// is a power of ten. If the resulting precision is not suitable for your
    /// needs, use `gtk.Scale.setDigits` to correct it.
    extern fn gtk_scale_new_with_range(p_orientation: gtk.Orientation, p_min: f64, p_max: f64, p_step: f64) *gtk.Scale;
    pub const newWithRange = gtk_scale_new_with_range;

    /// Adds a mark at `value`.
    ///
    /// A mark is indicated visually by drawing a tick mark next to the scale,
    /// and GTK+ makes it easy for the user to position the scale exactly at the
    /// marks value.
    ///
    /// If `markup` is not `NULL`, text is shown next to the tick mark.
    ///
    /// To remove marks from a scale, use `gtk.Scale.clearMarks`.
    extern fn gtk_scale_add_mark(p_scale: *Scale, p_value: f64, p_position: gtk.PositionType, p_markup: ?[*:0]const u8) void;
    pub const addMark = gtk_scale_add_mark;

    /// Removes any marks that have been added with `gtk.Scale.addMark`.
    extern fn gtk_scale_clear_marks(p_scale: *Scale) void;
    pub const clearMarks = gtk_scale_clear_marks;

    /// Gets the number of decimal places that are displayed in the value.
    extern fn gtk_scale_get_digits(p_scale: *Scale) c_int;
    pub const getDigits = gtk_scale_get_digits;

    /// Returns whether the current value is displayed as a string
    /// next to the slider.
    extern fn gtk_scale_get_draw_value(p_scale: *Scale) c_int;
    pub const getDrawValue = gtk_scale_get_draw_value;

    /// Returns whether the scale has an origin.
    extern fn gtk_scale_get_has_origin(p_scale: *Scale) c_int;
    pub const getHasOrigin = gtk_scale_get_has_origin;

    /// Gets the `pango.Layout` used to display the scale. The returned
    /// object is owned by the scale so does not need to be freed by
    /// the caller.
    extern fn gtk_scale_get_layout(p_scale: *Scale) ?*pango.Layout;
    pub const getLayout = gtk_scale_get_layout;

    /// Obtains the coordinates where the scale will draw the
    /// `pango.Layout` representing the text in the scale. Remember
    /// when using the `pango.Layout` function you need to convert to
    /// and from pixels using `PANGO_PIXELS` or `PANGO_SCALE`.
    ///
    /// If the `gtk.Scale.properties.draw`-value property is `FALSE`, the return
    /// values are undefined.
    extern fn gtk_scale_get_layout_offsets(p_scale: *Scale, p_x: ?*c_int, p_y: ?*c_int) void;
    pub const getLayoutOffsets = gtk_scale_get_layout_offsets;

    /// Gets the position in which the current value is displayed.
    extern fn gtk_scale_get_value_pos(p_scale: *Scale) gtk.PositionType;
    pub const getValuePos = gtk_scale_get_value_pos;

    /// Sets the number of decimal places that are displayed in the value. Also
    /// causes the value of the adjustment to be rounded to this number of digits,
    /// so the retrieved value matches the displayed one, if `gtk.Scale.properties.draw`-value is
    /// `TRUE` when the value changes. If you want to enforce rounding the value when
    /// `gtk.Scale.properties.draw`-value is `FALSE`, you can set `gtk.Range.properties.round`-digits instead.
    ///
    /// Note that rounding to a small number of digits can interfere with
    /// the smooth autoscrolling that is built into `gtk.Scale`. As an alternative,
    /// you can use the `gtk.Scale.signals.format`-value signal to format the displayed
    /// value yourself.
    extern fn gtk_scale_set_digits(p_scale: *Scale, p_digits: c_int) void;
    pub const setDigits = gtk_scale_set_digits;

    /// Specifies whether the current value is displayed as a string next
    /// to the slider.
    extern fn gtk_scale_set_draw_value(p_scale: *Scale, p_draw_value: c_int) void;
    pub const setDrawValue = gtk_scale_set_draw_value;

    /// If `gtk.Scale.properties.has`-origin is set to `TRUE` (the default), the scale will
    /// highlight the part of the trough between the origin (bottom or left side)
    /// and the current value.
    extern fn gtk_scale_set_has_origin(p_scale: *Scale, p_has_origin: c_int) void;
    pub const setHasOrigin = gtk_scale_set_has_origin;

    /// Sets the position in which the current value is displayed.
    extern fn gtk_scale_set_value_pos(p_scale: *Scale, p_pos: gtk.PositionType) void;
    pub const setValuePos = gtk_scale_set_value_pos;

    extern fn gtk_scale_get_type() usize;
    pub const getGObjectType = gtk_scale_get_type;

    extern fn g_object_ref(p_self: *gtk.Scale) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Scale) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Scale, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScaleAccessible = extern struct {
    pub const Parent = gtk.RangeAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Value };
    pub const Class = gtk.ScaleAccessibleClass;
    f_parent: gtk.RangeAccessible,
    f_priv: ?*gtk.ScaleAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_scale_accessible_get_type() usize;
    pub const getGObjectType = gtk_scale_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ScaleAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ScaleAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ScaleAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.ScaleButton` provides a button which pops up a scale widget.
/// This kind of widget is commonly used for volume controls in multimedia
/// applications, and GTK+ provides a `gtk.VolumeButton` subclass that
/// is tailored for this use case.
///
/// # CSS nodes
///
/// GtkScaleButton has a single CSS node with name button. To differentiate
/// it from a plain `gtk.Button`, it gets the .scale style class.
///
/// The popup widget that contains the scale has a .scale-popup style class.
pub const ScaleButton = extern struct {
    pub const Parent = gtk.Button;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.ScaleButtonClass;
    f_parent: gtk.Button,
    f_priv: ?*gtk.ScaleButtonPrivate,

    pub const virtual_methods = struct {
        pub const value_changed = struct {
            pub fn call(p_class: anytype, p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_value: f64) void {
                return gobject.ext.as(ScaleButton.Class, p_class).f_value_changed.?(gobject.ext.as(ScaleButton, p_button), p_value);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_value: f64) callconv(.c) void) void {
                gobject.ext.as(ScaleButton.Class, p_class).f_value_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const adjustment = struct {
            pub const name = "adjustment";

            pub const Type = ?*gtk.Adjustment;
        };

        /// The names of the icons to be used by the scale button.
        /// The first item in the array will be used in the button
        /// when the current value is the lowest value, the second
        /// item for the highest value. All the subsequent icons will
        /// be used for all the other values, spread evenly over the
        /// range of values.
        ///
        /// If there's only one icon name in the `icons` array, it will
        /// be used for all the values. If only two icon names are in
        /// the `icons` array, the first one will be used for the bottom
        /// 50% of the scale, and the second one for the top 50%.
        ///
        /// It is recommended to use at least 3 icons so that the
        /// `gtk.ScaleButton` reflects the current value of the scale
        /// better for the users.
        pub const icons = struct {
            pub const name = "icons";

            pub const Type = ?[*][*:0]u8;
        };

        pub const size = struct {
            pub const name = "size";

            pub const Type = gtk.IconSize;
        };

        pub const value = struct {
            pub const name = "value";

            pub const Type = f64;
        };
    };

    pub const signals = struct {
        /// The ::popdown signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to popdown the scale widget.
        ///
        /// The default binding for this signal is Escape.
        pub const popdown = struct {
            pub const name = "popdown";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ScaleButton, p_instance))),
                    gobject.signalLookup("popdown", ScaleButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::popup signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to popup the scale widget.
        ///
        /// The default bindings for this signal are Space, Enter and Return.
        pub const popup = struct {
            pub const name = "popup";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ScaleButton, p_instance))),
                    gobject.signalLookup("popup", ScaleButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::value-changed signal is emitted when the value field has
        /// changed.
        pub const value_changed = struct {
            pub const name = "value-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_value: f64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ScaleButton, p_instance))),
                    gobject.signalLookup("value-changed", ScaleButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a `gtk.ScaleButton`, with a range between `min` and `max`, with
    /// a stepping of `step`.
    extern fn gtk_scale_button_new(p_size: c_int, p_min: f64, p_max: f64, p_step: f64, p_icons: ?[*][*:0]const u8) *gtk.ScaleButton;
    pub const new = gtk_scale_button_new;

    /// Gets the `gtk.Adjustment` associated with the `gtk.ScaleButton`’s scale.
    /// See `gtk.Range.getAdjustment` for details.
    extern fn gtk_scale_button_get_adjustment(p_button: *ScaleButton) *gtk.Adjustment;
    pub const getAdjustment = gtk_scale_button_get_adjustment;

    /// Retrieves the minus button of the `gtk.ScaleButton`.
    extern fn gtk_scale_button_get_minus_button(p_button: *ScaleButton) *gtk.Button;
    pub const getMinusButton = gtk_scale_button_get_minus_button;

    /// Retrieves the plus button of the `gtk.ScaleButton`.
    extern fn gtk_scale_button_get_plus_button(p_button: *ScaleButton) *gtk.Button;
    pub const getPlusButton = gtk_scale_button_get_plus_button;

    /// Retrieves the popup of the `gtk.ScaleButton`.
    extern fn gtk_scale_button_get_popup(p_button: *ScaleButton) *gtk.Widget;
    pub const getPopup = gtk_scale_button_get_popup;

    /// Gets the current value of the scale button.
    extern fn gtk_scale_button_get_value(p_button: *ScaleButton) f64;
    pub const getValue = gtk_scale_button_get_value;

    /// Sets the `gtk.Adjustment` to be used as a model
    /// for the `gtk.ScaleButton`’s scale.
    /// See `gtk.Range.setAdjustment` for details.
    extern fn gtk_scale_button_set_adjustment(p_button: *ScaleButton, p_adjustment: *gtk.Adjustment) void;
    pub const setAdjustment = gtk_scale_button_set_adjustment;

    /// Sets the icons to be used by the scale button.
    /// For details, see the `gtk.ScaleButton.properties.icons` property.
    extern fn gtk_scale_button_set_icons(p_button: *ScaleButton, p_icons: [*][*:0]const u8) void;
    pub const setIcons = gtk_scale_button_set_icons;

    /// Sets the current value of the scale; if the value is outside
    /// the minimum or maximum range values, it will be clamped to fit
    /// inside them. The scale button emits the `gtk.ScaleButton.signals.value`-changed
    /// signal if the value changes.
    extern fn gtk_scale_button_set_value(p_button: *ScaleButton, p_value: f64) void;
    pub const setValue = gtk_scale_button_set_value;

    extern fn gtk_scale_button_get_type() usize;
    pub const getGObjectType = gtk_scale_button_get_type;

    extern fn g_object_ref(p_self: *gtk.ScaleButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ScaleButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ScaleButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScaleButtonAccessible = extern struct {
    pub const Parent = gtk.ButtonAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.Image, atk.Value };
    pub const Class = gtk.ScaleButtonAccessibleClass;
    f_parent: gtk.ButtonAccessible,
    f_priv: ?*gtk.ScaleButtonAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_scale_button_accessible_get_type() usize;
    pub const getGObjectType = gtk_scale_button_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ScaleButtonAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ScaleButtonAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ScaleButtonAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Scrollbar` widget is a horizontal or vertical scrollbar,
/// depending on the value of the `gtk.Orientable.properties.orientation` property.
///
/// Its position and movement are controlled by the adjustment that is passed to
/// or created by `gtk.Scrollbar.new`. See `gtk.Adjustment` for more details. The
/// `gtk.Adjustment.properties.value` field sets the position of the thumb and must be between
/// `gtk.Adjustment.properties.lower` and `gtk.Adjustment.properties.upper` - `gtk.Adjustment.properties.page`-size. The
/// `gtk.Adjustment.properties.page`-size represents the size of the visible scrollable area.
/// The fields `gtk.Adjustment.properties.step`-increment and `gtk.Adjustment.properties.page`-increment
/// fields are added to or subtracted from the `gtk.Adjustment.properties.value` when the user
/// asks to move by a step (using e.g. the cursor arrow keys or, if present, the
/// stepper buttons) or by a page (using e.g. the Page Down/Up keys).
///
/// # CSS nodes
///
/// ```
/// scrollbar[.fine-tune]
/// ╰── contents
///     ├── [button.up]
///     ├── [button.down]
///     ├── trough
///     │   ╰── slider
///     ├── [button.up]
///     ╰── [button.down]
/// ```
///
/// GtkScrollbar has a main CSS node with name scrollbar and a subnode for its
/// contents, with subnodes named trough and slider.
///
/// The main node gets the style class .fine-tune added when the scrollbar is
/// in 'fine-tuning' mode.
///
/// If steppers are enabled, they are represented by up to four additional
/// subnodes with name button. These get the style classes .up and .down to
/// indicate in which direction they are moving.
///
/// Other style classes that may be added to scrollbars inside `gtk.ScrolledWindow`
/// include the positional classes (.left, .right, .top, .bottom) and style
/// classes related to overlay scrolling (.overlay-indicator, .dragging, .hovering).
pub const Scrollbar = extern struct {
    pub const Parent = gtk.Range;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.ScrollbarClass;
    f_range: gtk.Range,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new scrollbar with the given orientation.
    extern fn gtk_scrollbar_new(p_orientation: gtk.Orientation, p_adjustment: ?*gtk.Adjustment) *gtk.Scrollbar;
    pub const new = gtk_scrollbar_new;

    extern fn gtk_scrollbar_get_type() usize;
    pub const getGObjectType = gtk_scrollbar_get_type;

    extern fn g_object_ref(p_self: *gtk.Scrollbar) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Scrollbar) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Scrollbar, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkScrolledWindow is a container that accepts a single child widget and makes
/// that child scrollable using either internally added scrollbars or externally
/// associated adjustments.
///
/// Widgets with native scrolling support, i.e. those whose classes implement the
/// `gtk.Scrollable` interface, are added directly. For other types of widget, the
/// class `gtk.Viewport` acts as an adaptor, giving scrollability to other widgets.
/// GtkScrolledWindow’s implementation of `gtk.Container.add` intelligently
/// accounts for whether or not the added child is a `gtk.Scrollable`. If it isn’t,
/// `gtk.ScrolledWindow` wraps the child in a `gtk.Viewport` and adds that for you.
/// Therefore, you can just add any child widget and not worry about the details.
///
/// If `gtk.Container.add` has added a `gtk.Viewport` for you, you can remove
/// both your added child widget from the `gtk.Viewport`, and the `gtk.Viewport`
/// from the GtkScrolledWindow, like this:
///
/// ```
/// GtkWidget *scrolled_window = gtk_scrolled_window_new (NULL, NULL);
/// GtkWidget *child_widget = gtk_button_new ();
///
/// // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
/// // add a GtkViewport.
/// gtk_container_add (GTK_CONTAINER (scrolled_window),
///                    child_widget);
///
/// // Either of these will result in child_widget being unparented:
/// gtk_container_remove (GTK_CONTAINER (scrolled_window),
///                       child_widget);
/// // or
/// gtk_container_remove (GTK_CONTAINER (scrolled_window),
///                       gtk_bin_get_child (GTK_BIN (scrolled_window)));
/// ```
///
/// Unless `gtk.ScrolledWindow.properties.policy` is GTK_POLICY_NEVER or GTK_POLICY_EXTERNAL,
/// GtkScrolledWindow adds internal `gtk.Scrollbar` widgets around its child. The
/// scroll position of the child, and if applicable the scrollbars, is controlled
/// by the `gtk.ScrolledWindow.properties.hadjustment` and `gtk.ScrolledWindow.properties.vadjustment`
/// that are associated with the GtkScrolledWindow. See the docs on `gtk.Scrollbar`
/// for the details, but note that the “step_increment” and “page_increment”
/// fields are only effective if the policy causes scrollbars to be present.
///
/// If a GtkScrolledWindow doesn’t behave quite as you would like, or
/// doesn’t have exactly the right layout, it’s very possible to set up
/// your own scrolling with `gtk.Scrollbar` and for example a `gtk.Grid`.
///
/// # Touch support
///
/// GtkScrolledWindow has built-in support for touch devices. When a
/// touchscreen is used, swiping will move the scrolled window, and will
/// expose 'kinetic' behavior. This can be turned off with the
/// `gtk.ScrolledWindow.properties.kinetic`-scrolling property if it is undesired.
///
/// GtkScrolledWindow also displays visual 'overshoot' indication when
/// the content is pulled beyond the end, and this situation can be
/// captured with the `gtk.ScrolledWindow.signals.edge`-overshot signal.
///
/// If no mouse device is present, the scrollbars will overlayed as
/// narrow, auto-hiding indicators over the content. If traditional
/// scrollbars are desired although no mouse is present, this behaviour
/// can be turned off with the `gtk.ScrolledWindow.properties.overlay`-scrolling
/// property.
///
/// # CSS nodes
///
/// GtkScrolledWindow has a main CSS node with name scrolledwindow.
///
/// It uses subnodes with names overshoot and undershoot to
/// draw the overflow and underflow indications. These nodes get
/// the .left, .right, .top or .bottom style class added depending
/// on where the indication is drawn.
///
/// GtkScrolledWindow also sets the positional style classes (.left,
/// .right, .top, .bottom) and style classes related to overlay
/// scrolling (.overlay-indicator, .dragging, .hovering) on its scrollbars.
///
/// If both scrollbars are visible, the area where they meet is drawn
/// with a subnode named junction.
pub const ScrolledWindow = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.ScrolledWindowClass;
    f_container: gtk.Bin,
    f_priv: ?*gtk.ScrolledWindowPrivate,

    pub const virtual_methods = struct {
        /// Keybinding signal which gets emitted when focus is
        ///    moved away from the scrolled window by a keybinding.
        pub const move_focus_out = struct {
            pub fn call(p_class: anytype, p_scrolled_window: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.DirectionType) void {
                return gobject.ext.as(ScrolledWindow.Class, p_class).f_move_focus_out.?(gobject.ext.as(ScrolledWindow, p_scrolled_window), p_direction);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_scrolled_window: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.DirectionType) callconv(.c) void) void {
                gobject.ext.as(ScrolledWindow.Class, p_class).f_move_focus_out = @ptrCast(p_implementation);
            }
        };

        /// Keybinding signal which gets emitted when a
        ///    keybinding that scrolls is pressed.
        pub const scroll_child = struct {
            pub fn call(p_class: anytype, p_scrolled_window: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_scroll: gtk.ScrollType, p_horizontal: c_int) c_int {
                return gobject.ext.as(ScrolledWindow.Class, p_class).f_scroll_child.?(gobject.ext.as(ScrolledWindow, p_scrolled_window), p_scroll, p_horizontal);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_scrolled_window: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_scroll: gtk.ScrollType, p_horizontal: c_int) callconv(.c) c_int) void {
                gobject.ext.as(ScrolledWindow.Class, p_class).f_scroll_child = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const hadjustment = struct {
            pub const name = "hadjustment";

            pub const Type = ?*gtk.Adjustment;
        };

        pub const hscrollbar_policy = struct {
            pub const name = "hscrollbar-policy";

            pub const Type = gtk.PolicyType;
        };

        /// Whether kinetic scrolling is enabled or not. Kinetic scrolling
        /// only applies to devices with source `GDK_SOURCE_TOUCHSCREEN`.
        pub const kinetic_scrolling = struct {
            pub const name = "kinetic-scrolling";

            pub const Type = c_int;
        };

        /// The maximum content height of `scrolled_window`, or -1 if not set.
        pub const max_content_height = struct {
            pub const name = "max-content-height";

            pub const Type = c_int;
        };

        /// The maximum content width of `scrolled_window`, or -1 if not set.
        pub const max_content_width = struct {
            pub const name = "max-content-width";

            pub const Type = c_int;
        };

        /// The minimum content height of `scrolled_window`, or -1 if not set.
        pub const min_content_height = struct {
            pub const name = "min-content-height";

            pub const Type = c_int;
        };

        /// The minimum content width of `scrolled_window`, or -1 if not set.
        pub const min_content_width = struct {
            pub const name = "min-content-width";

            pub const Type = c_int;
        };

        /// Whether overlay scrolling is enabled or not. If it is, the
        /// scrollbars are only added as traditional widgets when a mouse
        /// is present. Otherwise, they are overlayed on top of the content,
        /// as narrow indicators.
        ///
        /// Note that overlay scrolling can also be globally disabled, with
        /// the `gtk.Settings.signals.gtk`-overlay-scrolling setting.
        pub const overlay_scrolling = struct {
            pub const name = "overlay-scrolling";

            pub const Type = c_int;
        };

        /// Whether the natural height of the child should be calculated and propagated
        /// through the scrolled window’s requested natural height.
        ///
        /// This is useful in cases where an attempt should be made to allocate exactly
        /// enough space for the natural size of the child.
        pub const propagate_natural_height = struct {
            pub const name = "propagate-natural-height";

            pub const Type = c_int;
        };

        /// Whether the natural width of the child should be calculated and propagated
        /// through the scrolled window’s requested natural width.
        ///
        /// This is useful in cases where an attempt should be made to allocate exactly
        /// enough space for the natural size of the child.
        pub const propagate_natural_width = struct {
            pub const name = "propagate-natural-width";

            pub const Type = c_int;
        };

        pub const shadow_type = struct {
            pub const name = "shadow-type";

            pub const Type = gtk.ShadowType;
        };

        pub const vadjustment = struct {
            pub const name = "vadjustment";

            pub const Type = ?*gtk.Adjustment;
        };

        pub const vscrollbar_policy = struct {
            pub const name = "vscrollbar-policy";

            pub const Type = gtk.PolicyType;
        };

        pub const window_placement = struct {
            pub const name = "window-placement";

            pub const Type = gtk.CornerType;
        };

        /// Whether "window-placement" should be used to determine the location
        /// of the contents with respect to the scrollbars.
        pub const window_placement_set = struct {
            pub const name = "window-placement-set";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::edge-overshot signal is emitted whenever user initiated scrolling
        /// makes the scrolled window firmly surpass (i.e. with some edge resistance)
        /// the lower or upper limits defined by the adjustment in that orientation.
        ///
        /// A similar behavior without edge resistance is provided by the
        /// `gtk.ScrolledWindow.signals.edge`-reached signal.
        ///
        /// Note: The `pos` argument is LTR/RTL aware, so callers should be aware too
        /// if intending to provide behavior on horizontal edges.
        pub const edge_overshot = struct {
            pub const name = "edge-overshot";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_pos: gtk.PositionType, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ScrolledWindow, p_instance))),
                    gobject.signalLookup("edge-overshot", ScrolledWindow.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::edge-reached signal is emitted whenever user-initiated scrolling
        /// makes the scrolled window exactly reach the lower or upper limits
        /// defined by the adjustment in that orientation.
        ///
        /// A similar behavior with edge resistance is provided by the
        /// `gtk.ScrolledWindow.signals.edge`-overshot signal.
        ///
        /// Note: The `pos` argument is LTR/RTL aware, so callers should be aware too
        /// if intending to provide behavior on horizontal edges.
        pub const edge_reached = struct {
            pub const name = "edge-reached";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_pos: gtk.PositionType, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ScrolledWindow, p_instance))),
                    gobject.signalLookup("edge-reached", ScrolledWindow.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::move-focus-out signal is a
        /// [keybinding signal][GtkBindingSignal] which gets
        /// emitted when focus is moved away from the scrolled window by a
        /// keybinding. The `gtk.Widget.signals.move`-focus signal is emitted with
        /// `direction_type` on this scrolled window’s toplevel parent in the
        /// container hierarchy. The default bindings for this signal are
        /// `Ctrl + Tab` to move forward and `Ctrl + Shift + Tab` to move backward.
        pub const move_focus_out = struct {
            pub const name = "move-focus-out";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_direction_type: gtk.DirectionType, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ScrolledWindow, p_instance))),
                    gobject.signalLookup("move-focus-out", ScrolledWindow.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::scroll-child signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when a keybinding that scrolls is pressed.
        /// The horizontal or vertical adjustment is updated which triggers a
        /// signal that the scrolled window’s child may listen to and scroll itself.
        pub const scroll_child = struct {
            pub const name = "scroll-child";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_scroll: gtk.ScrollType, p_horizontal: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ScrolledWindow, p_instance))),
                    gobject.signalLookup("scroll-child", ScrolledWindow.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new scrolled window.
    ///
    /// The two arguments are the scrolled window’s adjustments; these will be
    /// shared with the scrollbars and the child widget to keep the bars in sync
    /// with the child. Usually you want to pass `NULL` for the adjustments, which
    /// will cause the scrolled window to create them for you.
    extern fn gtk_scrolled_window_new(p_hadjustment: ?*gtk.Adjustment, p_vadjustment: ?*gtk.Adjustment) *gtk.ScrolledWindow;
    pub const new = gtk_scrolled_window_new;

    /// Used to add children without native scrolling capabilities. This
    /// is simply a convenience function; it is equivalent to adding the
    /// unscrollable child to a viewport, then adding the viewport to the
    /// scrolled window. If a child has native scrolling, use
    /// `gtk.Container.add` instead of this function.
    ///
    /// The viewport scrolls the child by moving its `gdk.Window`, and takes
    /// the size of the child to be the size of its toplevel `gdk.Window`.
    /// This will be very wrong for most widgets that support native scrolling;
    /// for example, if you add a widget such as `gtk.TreeView` with a viewport,
    /// the whole widget will scroll, including the column headings. Thus,
    /// widgets with native scrolling support should not be used with the
    /// `gtk.Viewport` proxy.
    ///
    /// A widget supports scrolling natively if it implements the
    /// `gtk.Scrollable` interface.
    extern fn gtk_scrolled_window_add_with_viewport(p_scrolled_window: *ScrolledWindow, p_child: *gtk.Widget) void;
    pub const addWithViewport = gtk_scrolled_window_add_with_viewport;

    /// Return whether button presses are captured during kinetic
    /// scrolling. See `gtk.ScrolledWindow.setCaptureButtonPress`.
    extern fn gtk_scrolled_window_get_capture_button_press(p_scrolled_window: *ScrolledWindow) c_int;
    pub const getCaptureButtonPress = gtk_scrolled_window_get_capture_button_press;

    /// Returns the horizontal scrollbar’s adjustment, used to connect the
    /// horizontal scrollbar to the child widget’s horizontal scroll
    /// functionality.
    extern fn gtk_scrolled_window_get_hadjustment(p_scrolled_window: *ScrolledWindow) *gtk.Adjustment;
    pub const getHadjustment = gtk_scrolled_window_get_hadjustment;

    /// Returns the horizontal scrollbar of `scrolled_window`.
    extern fn gtk_scrolled_window_get_hscrollbar(p_scrolled_window: *ScrolledWindow) *gtk.Widget;
    pub const getHscrollbar = gtk_scrolled_window_get_hscrollbar;

    /// Returns the specified kinetic scrolling behavior.
    extern fn gtk_scrolled_window_get_kinetic_scrolling(p_scrolled_window: *ScrolledWindow) c_int;
    pub const getKineticScrolling = gtk_scrolled_window_get_kinetic_scrolling;

    /// Returns the maximum content height set.
    extern fn gtk_scrolled_window_get_max_content_height(p_scrolled_window: *ScrolledWindow) c_int;
    pub const getMaxContentHeight = gtk_scrolled_window_get_max_content_height;

    /// Returns the maximum content width set.
    extern fn gtk_scrolled_window_get_max_content_width(p_scrolled_window: *ScrolledWindow) c_int;
    pub const getMaxContentWidth = gtk_scrolled_window_get_max_content_width;

    /// Gets the minimal content height of `scrolled_window`, or -1 if not set.
    extern fn gtk_scrolled_window_get_min_content_height(p_scrolled_window: *ScrolledWindow) c_int;
    pub const getMinContentHeight = gtk_scrolled_window_get_min_content_height;

    /// Gets the minimum content width of `scrolled_window`, or -1 if not set.
    extern fn gtk_scrolled_window_get_min_content_width(p_scrolled_window: *ScrolledWindow) c_int;
    pub const getMinContentWidth = gtk_scrolled_window_get_min_content_width;

    /// Returns whether overlay scrolling is enabled for this scrolled window.
    extern fn gtk_scrolled_window_get_overlay_scrolling(p_scrolled_window: *ScrolledWindow) c_int;
    pub const getOverlayScrolling = gtk_scrolled_window_get_overlay_scrolling;

    /// Gets the placement of the contents with respect to the scrollbars
    /// for the scrolled window. See `gtk.ScrolledWindow.setPlacement`.
    extern fn gtk_scrolled_window_get_placement(p_scrolled_window: *ScrolledWindow) gtk.CornerType;
    pub const getPlacement = gtk_scrolled_window_get_placement;

    /// Retrieves the current policy values for the horizontal and vertical
    /// scrollbars. See `gtk.ScrolledWindow.setPolicy`.
    extern fn gtk_scrolled_window_get_policy(p_scrolled_window: *ScrolledWindow, p_hscrollbar_policy: ?*gtk.PolicyType, p_vscrollbar_policy: ?*gtk.PolicyType) void;
    pub const getPolicy = gtk_scrolled_window_get_policy;

    /// Reports whether the natural height of the child will be calculated and propagated
    /// through the scrolled window’s requested natural height.
    extern fn gtk_scrolled_window_get_propagate_natural_height(p_scrolled_window: *ScrolledWindow) c_int;
    pub const getPropagateNaturalHeight = gtk_scrolled_window_get_propagate_natural_height;

    /// Reports whether the natural width of the child will be calculated and propagated
    /// through the scrolled window’s requested natural width.
    extern fn gtk_scrolled_window_get_propagate_natural_width(p_scrolled_window: *ScrolledWindow) c_int;
    pub const getPropagateNaturalWidth = gtk_scrolled_window_get_propagate_natural_width;

    /// Gets the shadow type of the scrolled window. See
    /// `gtk.ScrolledWindow.setShadowType`.
    extern fn gtk_scrolled_window_get_shadow_type(p_scrolled_window: *ScrolledWindow) gtk.ShadowType;
    pub const getShadowType = gtk_scrolled_window_get_shadow_type;

    /// Returns the vertical scrollbar’s adjustment, used to connect the
    /// vertical scrollbar to the child widget’s vertical scroll functionality.
    extern fn gtk_scrolled_window_get_vadjustment(p_scrolled_window: *ScrolledWindow) *gtk.Adjustment;
    pub const getVadjustment = gtk_scrolled_window_get_vadjustment;

    /// Returns the vertical scrollbar of `scrolled_window`.
    extern fn gtk_scrolled_window_get_vscrollbar(p_scrolled_window: *ScrolledWindow) *gtk.Widget;
    pub const getVscrollbar = gtk_scrolled_window_get_vscrollbar;

    /// Changes the behaviour of `scrolled_window` with regard to the initial
    /// event that possibly starts kinetic scrolling. When `capture_button_press`
    /// is set to `TRUE`, the event is captured by the scrolled window, and
    /// then later replayed if it is meant to go to the child widget.
    ///
    /// This should be enabled if any child widgets perform non-reversible
    /// actions on `gtk.Widget.signals.button`-press-event. If they don't, and handle
    /// additionally handle `gtk.Widget.signals.grab`-broken-event, it might be better
    /// to set `capture_button_press` to `FALSE`.
    ///
    /// This setting only has an effect if kinetic scrolling is enabled.
    extern fn gtk_scrolled_window_set_capture_button_press(p_scrolled_window: *ScrolledWindow, p_capture_button_press: c_int) void;
    pub const setCaptureButtonPress = gtk_scrolled_window_set_capture_button_press;

    /// Sets the `gtk.Adjustment` for the horizontal scrollbar.
    extern fn gtk_scrolled_window_set_hadjustment(p_scrolled_window: *ScrolledWindow, p_hadjustment: ?*gtk.Adjustment) void;
    pub const setHadjustment = gtk_scrolled_window_set_hadjustment;

    /// Turns kinetic scrolling on or off.
    /// Kinetic scrolling only applies to devices with source
    /// `GDK_SOURCE_TOUCHSCREEN`.
    extern fn gtk_scrolled_window_set_kinetic_scrolling(p_scrolled_window: *ScrolledWindow, p_kinetic_scrolling: c_int) void;
    pub const setKineticScrolling = gtk_scrolled_window_set_kinetic_scrolling;

    /// Sets the maximum height that `scrolled_window` should keep visible. The
    /// `scrolled_window` will grow up to this height before it starts scrolling
    /// the content.
    ///
    /// It is a programming error to set the maximum content height to a value
    /// smaller than `gtk.ScrolledWindow.properties.min`-content-height.
    extern fn gtk_scrolled_window_set_max_content_height(p_scrolled_window: *ScrolledWindow, p_height: c_int) void;
    pub const setMaxContentHeight = gtk_scrolled_window_set_max_content_height;

    /// Sets the maximum width that `scrolled_window` should keep visible. The
    /// `scrolled_window` will grow up to this width before it starts scrolling
    /// the content.
    ///
    /// It is a programming error to set the maximum content width to a value
    /// smaller than `gtk.ScrolledWindow.properties.min`-content-width.
    extern fn gtk_scrolled_window_set_max_content_width(p_scrolled_window: *ScrolledWindow, p_width: c_int) void;
    pub const setMaxContentWidth = gtk_scrolled_window_set_max_content_width;

    /// Sets the minimum height that `scrolled_window` should keep visible.
    /// Note that this can and (usually will) be smaller than the minimum
    /// size of the content.
    ///
    /// It is a programming error to set the minimum content height to a
    /// value greater than `gtk.ScrolledWindow.properties.max`-content-height.
    extern fn gtk_scrolled_window_set_min_content_height(p_scrolled_window: *ScrolledWindow, p_height: c_int) void;
    pub const setMinContentHeight = gtk_scrolled_window_set_min_content_height;

    /// Sets the minimum width that `scrolled_window` should keep visible.
    /// Note that this can and (usually will) be smaller than the minimum
    /// size of the content.
    ///
    /// It is a programming error to set the minimum content width to a
    /// value greater than `gtk.ScrolledWindow.properties.max`-content-width.
    extern fn gtk_scrolled_window_set_min_content_width(p_scrolled_window: *ScrolledWindow, p_width: c_int) void;
    pub const setMinContentWidth = gtk_scrolled_window_set_min_content_width;

    /// Enables or disables overlay scrolling for this scrolled window.
    extern fn gtk_scrolled_window_set_overlay_scrolling(p_scrolled_window: *ScrolledWindow, p_overlay_scrolling: c_int) void;
    pub const setOverlayScrolling = gtk_scrolled_window_set_overlay_scrolling;

    /// Sets the placement of the contents with respect to the scrollbars
    /// for the scrolled window.
    ///
    /// The default is `GTK_CORNER_TOP_LEFT`, meaning the child is
    /// in the top left, with the scrollbars underneath and to the right.
    /// Other values in `gtk.CornerType` are `GTK_CORNER_TOP_RIGHT`,
    /// `GTK_CORNER_BOTTOM_LEFT`, and `GTK_CORNER_BOTTOM_RIGHT`.
    ///
    /// See also `gtk.ScrolledWindow.getPlacement` and
    /// `gtk.ScrolledWindow.unsetPlacement`.
    extern fn gtk_scrolled_window_set_placement(p_scrolled_window: *ScrolledWindow, p_window_placement: gtk.CornerType) void;
    pub const setPlacement = gtk_scrolled_window_set_placement;

    /// Sets the scrollbar policy for the horizontal and vertical scrollbars.
    ///
    /// The policy determines when the scrollbar should appear; it is a value
    /// from the `gtk.PolicyType` enumeration. If `GTK_POLICY_ALWAYS`, the
    /// scrollbar is always present; if `GTK_POLICY_NEVER`, the scrollbar is
    /// never present; if `GTK_POLICY_AUTOMATIC`, the scrollbar is present only
    /// if needed (that is, if the slider part of the bar would be smaller
    /// than the trough — the display is larger than the page size).
    extern fn gtk_scrolled_window_set_policy(p_scrolled_window: *ScrolledWindow, p_hscrollbar_policy: gtk.PolicyType, p_vscrollbar_policy: gtk.PolicyType) void;
    pub const setPolicy = gtk_scrolled_window_set_policy;

    /// Sets whether the natural height of the child should be calculated and propagated
    /// through the scrolled window’s requested natural height.
    extern fn gtk_scrolled_window_set_propagate_natural_height(p_scrolled_window: *ScrolledWindow, p_propagate: c_int) void;
    pub const setPropagateNaturalHeight = gtk_scrolled_window_set_propagate_natural_height;

    /// Sets whether the natural width of the child should be calculated and propagated
    /// through the scrolled window’s requested natural width.
    extern fn gtk_scrolled_window_set_propagate_natural_width(p_scrolled_window: *ScrolledWindow, p_propagate: c_int) void;
    pub const setPropagateNaturalWidth = gtk_scrolled_window_set_propagate_natural_width;

    /// Changes the type of shadow drawn around the contents of
    /// `scrolled_window`.
    extern fn gtk_scrolled_window_set_shadow_type(p_scrolled_window: *ScrolledWindow, p_type: gtk.ShadowType) void;
    pub const setShadowType = gtk_scrolled_window_set_shadow_type;

    /// Sets the `gtk.Adjustment` for the vertical scrollbar.
    extern fn gtk_scrolled_window_set_vadjustment(p_scrolled_window: *ScrolledWindow, p_vadjustment: ?*gtk.Adjustment) void;
    pub const setVadjustment = gtk_scrolled_window_set_vadjustment;

    /// Unsets the placement of the contents with respect to the scrollbars
    /// for the scrolled window. If no window placement is set for a scrolled
    /// window, it defaults to `GTK_CORNER_TOP_LEFT`.
    ///
    /// See also `gtk.ScrolledWindow.setPlacement` and
    /// `gtk.ScrolledWindow.getPlacement`.
    extern fn gtk_scrolled_window_unset_placement(p_scrolled_window: *ScrolledWindow) void;
    pub const unsetPlacement = gtk_scrolled_window_unset_placement;

    extern fn gtk_scrolled_window_get_type() usize;
    pub const getGObjectType = gtk_scrolled_window_get_type;

    extern fn g_object_ref(p_self: *gtk.ScrolledWindow) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ScrolledWindow) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ScrolledWindow, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScrolledWindowAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{atk.Component};
    pub const Class = gtk.ScrolledWindowAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.ScrolledWindowAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_scrolled_window_accessible_get_type() usize;
    pub const getGObjectType = gtk_scrolled_window_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ScrolledWindowAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ScrolledWindowAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ScrolledWindowAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.SearchBar` is a container made to have a search entry (possibly
/// with additional connex widgets, such as drop-down menus, or buttons)
/// built-in. The search bar would appear when a search is started through
/// typing on the keyboard, or the application’s search mode is toggled on.
///
/// For keyboard presses to start a search, events will need to be
/// forwarded from the top-level window that contains the search bar.
/// See `gtk.SearchBar.handleEvent` for example code. Common shortcuts
/// such as Ctrl+F should be handled as an application action, or through
/// the menu items.
///
/// You will also need to tell the search bar about which entry you
/// are using as your search entry using `gtk.SearchBar.connectEntry`.
/// The following example shows you how to create a more complex search
/// entry.
///
/// # CSS nodes
///
/// GtkSearchBar has a single CSS node with name searchbar.
///
/// ## Creating a search bar
///
/// [A simple example](https://gitlab.gnome.org/GNOME/gtk/blob/gtk-3-24/examples/search-bar.c)
pub const SearchBar = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.SearchBarClass;
    f_parent: gtk.Bin,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const search_mode_enabled = struct {
            pub const name = "search-mode-enabled";

            pub const Type = c_int;
        };

        pub const show_close_button = struct {
            pub const name = "show-close-button";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a `gtk.SearchBar`. You will need to tell it about
    /// which widget is going to be your text entry using
    /// `gtk.SearchBar.connectEntry`.
    extern fn gtk_search_bar_new() *gtk.SearchBar;
    pub const new = gtk_search_bar_new;

    /// Connects the `gtk.Entry` widget passed as the one to be used in
    /// this search bar. The entry should be a descendant of the search bar.
    /// This is only required if the entry isn’t the direct child of the
    /// search bar (as in our main example).
    extern fn gtk_search_bar_connect_entry(p_bar: *SearchBar, p_entry: *gtk.Entry) void;
    pub const connectEntry = gtk_search_bar_connect_entry;

    /// Returns whether the search mode is on or off.
    extern fn gtk_search_bar_get_search_mode(p_bar: *SearchBar) c_int;
    pub const getSearchMode = gtk_search_bar_get_search_mode;

    /// Returns whether the close button is shown.
    extern fn gtk_search_bar_get_show_close_button(p_bar: *SearchBar) c_int;
    pub const getShowCloseButton = gtk_search_bar_get_show_close_button;

    /// This function should be called when the top-level
    /// window which contains the search bar received a key event.
    ///
    /// If the key event is handled by the search bar, the bar will
    /// be shown, the entry populated with the entered text and `GDK_EVENT_STOP`
    /// will be returned. The caller should ensure that events are
    /// not propagated further.
    ///
    /// If no entry has been connected to the search bar, using
    /// `gtk.SearchBar.connectEntry`, this function will return
    /// immediately with a warning.
    ///
    /// ## Showing the search bar on key presses
    ///
    /// ```
    /// static gboolean
    /// on_key_press_event (GtkWidget *widget,
    ///                     GdkEvent  *event,
    ///                     gpointer   user_data)
    /// {
    ///   GtkSearchBar *bar = GTK_SEARCH_BAR (user_data);
    ///   return gtk_search_bar_handle_event (bar, event);
    /// }
    ///
    /// static void
    /// create_toplevel (void)
    /// {
    ///   GtkWidget *window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    ///   GtkWindow *search_bar = gtk_search_bar_new ();
    ///
    ///  // Add more widgets to the window...
    ///
    ///   g_signal_connect (window,
    ///                    "key-press-event",
    ///                     G_CALLBACK (on_key_press_event),
    ///                     search_bar);
    /// }
    /// ```
    extern fn gtk_search_bar_handle_event(p_bar: *SearchBar, p_event: *gdk.Event) c_int;
    pub const handleEvent = gtk_search_bar_handle_event;

    /// Switches the search mode on or off.
    extern fn gtk_search_bar_set_search_mode(p_bar: *SearchBar, p_search_mode: c_int) void;
    pub const setSearchMode = gtk_search_bar_set_search_mode;

    /// Shows or hides the close button. Applications that
    /// already have a “search” toggle button should not show a close
    /// button in their search bar, as it duplicates the role of the
    /// toggle button.
    extern fn gtk_search_bar_set_show_close_button(p_bar: *SearchBar, p_visible: c_int) void;
    pub const setShowCloseButton = gtk_search_bar_set_show_close_button;

    extern fn gtk_search_bar_get_type() usize;
    pub const getGObjectType = gtk_search_bar_get_type;

    extern fn g_object_ref(p_self: *gtk.SearchBar) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.SearchBar) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SearchBar, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.SearchEntry` is a subclass of `gtk.Entry` that has been
/// tailored for use as a search entry.
///
/// It will show an inactive symbolic “find” icon when the search
/// entry is empty, and a symbolic “clear” icon when there is text.
/// Clicking on the “clear” icon will empty the search entry.
///
/// Note that the search/clear icon is shown using a secondary
/// icon, and thus does not work if you are using the secondary
/// icon position for some other purpose.
///
/// To make filtering appear more reactive, it is a good idea to
/// not react to every change in the entry text immediately, but
/// only after a short delay. To support this, `gtk.SearchEntry`
/// emits the `gtk.SearchEntry.signals.search`-changed signal which can
/// be used instead of the `gtk.Editable.signals.changed` signal.
///
/// The `gtk.SearchEntry.signals.previous`-match, `gtk.SearchEntry.signals.next`-match
/// and `gtk.SearchEntry.signals.stop`-search signals can be used to implement
/// moving between search results and ending the search.
///
/// Often, GtkSearchEntry will be fed events by means of being
/// placed inside a `gtk.SearchBar`. If that is not the case,
/// you can use `gtk.SearchEntry.handleEvent` to pass events.
pub const SearchEntry = extern struct {
    pub const Parent = gtk.Entry;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.CellEditable, gtk.Editable };
    pub const Class = gtk.SearchEntryClass;
    f_parent: gtk.Entry,

    pub const virtual_methods = struct {
        pub const next_match = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(SearchEntry.Class, p_class).f_next_match.?(gobject.ext.as(SearchEntry, p_entry));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(SearchEntry.Class, p_class).f_next_match = @ptrCast(p_implementation);
            }
        };

        pub const previous_match = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(SearchEntry.Class, p_class).f_previous_match.?(gobject.ext.as(SearchEntry, p_entry));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(SearchEntry.Class, p_class).f_previous_match = @ptrCast(p_implementation);
            }
        };

        pub const search_changed = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(SearchEntry.Class, p_class).f_search_changed.?(gobject.ext.as(SearchEntry, p_entry));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(SearchEntry.Class, p_class).f_search_changed = @ptrCast(p_implementation);
            }
        };

        pub const stop_search = struct {
            pub fn call(p_class: anytype, p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(SearchEntry.Class, p_class).f_stop_search.?(gobject.ext.as(SearchEntry, p_entry));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_entry: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(SearchEntry.Class, p_class).f_stop_search = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// The ::next-match signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user initiates a move to the next match
        /// for the current search string.
        ///
        /// Applications should connect to it, to implement moving between
        /// matches.
        ///
        /// The default bindings for this signal is Ctrl-g.
        pub const next_match = struct {
            pub const name = "next-match";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(SearchEntry, p_instance))),
                    gobject.signalLookup("next-match", SearchEntry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::previous-match signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user initiates a move to the previous match
        /// for the current search string.
        ///
        /// Applications should connect to it, to implement moving between
        /// matches.
        ///
        /// The default bindings for this signal is Ctrl-Shift-g.
        pub const previous_match = struct {
            pub const name = "previous-match";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(SearchEntry, p_instance))),
                    gobject.signalLookup("previous-match", SearchEntry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The `gtk.SearchEntry.signals.search`-changed signal is emitted with a short
        /// delay of 150 milliseconds after the last change to the entry text.
        pub const search_changed = struct {
            pub const name = "search-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(SearchEntry, p_instance))),
                    gobject.signalLookup("search-changed", SearchEntry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::stop-search signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user stops a search via keyboard input.
        ///
        /// Applications should connect to it, to implement hiding the search
        /// entry in this case.
        ///
        /// The default bindings for this signal is Escape.
        pub const stop_search = struct {
            pub const name = "stop-search";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(SearchEntry, p_instance))),
                    gobject.signalLookup("stop-search", SearchEntry.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a `gtk.SearchEntry`, with a find icon when the search field is
    /// empty, and a clear icon when it isn't.
    extern fn gtk_search_entry_new() *gtk.SearchEntry;
    pub const new = gtk_search_entry_new;

    /// This function should be called when the top-level window
    /// which contains the search entry received a key event. If
    /// the entry is part of a `gtk.SearchBar`, it is preferable
    /// to call `gtk.SearchBar.handleEvent` instead, which will
    /// reveal the entry in addition to passing the event to this
    /// function.
    ///
    /// If the key event is handled by the search entry and starts
    /// or continues a search, `GDK_EVENT_STOP` will be returned.
    /// The caller should ensure that the entry is shown in this
    /// case, and not propagate the event further.
    extern fn gtk_search_entry_handle_event(p_entry: *SearchEntry, p_event: *gdk.Event) c_int;
    pub const handleEvent = gtk_search_entry_handle_event;

    extern fn gtk_search_entry_get_type() usize;
    pub const getGObjectType = gtk_search_entry_get_type;

    extern fn g_object_ref(p_self: *gtk.SearchEntry) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.SearchEntry) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SearchEntry, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkSeparator is a horizontal or vertical separator widget, depending on the
/// value of the `gtk.Orientable.properties.orientation` property, used to group the widgets
/// within a window. It displays a line with a shadow to make it appear sunken
/// into the interface.
///
/// # CSS nodes
///
/// GtkSeparator has a single CSS node with name separator. The node
/// gets one of the .horizontal or .vertical style classes.
pub const Separator = extern struct {
    pub const Parent = gtk.Widget;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.SeparatorClass;
    f_widget: gtk.Widget,
    f_priv: ?*gtk.SeparatorPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.Separator` with the given orientation.
    extern fn gtk_separator_new(p_orientation: gtk.Orientation) *gtk.Separator;
    pub const new = gtk_separator_new;

    extern fn gtk_separator_get_type() usize;
    pub const getGObjectType = gtk_separator_get_type;

    extern fn g_object_ref(p_self: *gtk.Separator) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Separator) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Separator, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.SeparatorMenuItem` is a separator used to group
/// items within a menu. It displays a horizontal line with a shadow to
/// make it appear sunken into the interface.
///
/// # CSS nodes
///
/// GtkSeparatorMenuItem has a single CSS node with name separator.
pub const SeparatorMenuItem = extern struct {
    pub const Parent = gtk.MenuItem;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.SeparatorMenuItemClass;
    f_menu_item: gtk.MenuItem,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.SeparatorMenuItem`.
    extern fn gtk_separator_menu_item_new() *gtk.SeparatorMenuItem;
    pub const new = gtk_separator_menu_item_new;

    extern fn gtk_separator_menu_item_get_type() usize;
    pub const getGObjectType = gtk_separator_menu_item_get_type;

    extern fn g_object_ref(p_self: *gtk.SeparatorMenuItem) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.SeparatorMenuItem) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SeparatorMenuItem, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.SeparatorToolItem` is a `gtk.ToolItem` that separates groups of other
/// `GtkToolItems`. Depending on the theme, a `gtk.SeparatorToolItem` will
/// often look like a vertical line on horizontally docked toolbars.
///
/// If the `gtk.Toolbar` child property “expand” is `TRUE` and the property
/// `gtk.SeparatorToolItem.properties.draw` is `FALSE`, a `gtk.SeparatorToolItem` will act as
/// a “spring” that forces other items to the ends of the toolbar.
///
/// Use `gtk.SeparatorToolItem.new` to create a new `gtk.SeparatorToolItem`.
///
/// # CSS nodes
///
/// GtkSeparatorToolItem has a single CSS node with name separator.
pub const SeparatorToolItem = extern struct {
    pub const Parent = gtk.ToolItem;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.SeparatorToolItemClass;
    f_parent: gtk.ToolItem,
    f_priv: ?*gtk.SeparatorToolItemPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const draw = struct {
            pub const name = "draw";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Create a new `gtk.SeparatorToolItem`
    extern fn gtk_separator_tool_item_new() *gtk.SeparatorToolItem;
    pub const new = gtk_separator_tool_item_new;

    /// Returns whether `item` is drawn as a line, or just blank.
    /// See `gtk.SeparatorToolItem.setDraw`.
    extern fn gtk_separator_tool_item_get_draw(p_item: *SeparatorToolItem) c_int;
    pub const getDraw = gtk_separator_tool_item_get_draw;

    /// Whether `item` is drawn as a vertical line, or just blank.
    /// Setting this to `FALSE` along with `gtk.ToolItem.setExpand` is useful
    /// to create an item that forces following items to the end of the toolbar.
    extern fn gtk_separator_tool_item_set_draw(p_item: *SeparatorToolItem, p_draw: c_int) void;
    pub const setDraw = gtk_separator_tool_item_set_draw;

    extern fn gtk_separator_tool_item_get_type() usize;
    pub const getGObjectType = gtk_separator_tool_item_get_type;

    extern fn g_object_ref(p_self: *gtk.SeparatorToolItem) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.SeparatorToolItem) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SeparatorToolItem, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkSettings provide a mechanism to share global settings between
/// applications.
///
/// On the X window system, this sharing is realized by an
/// [XSettings](http://www.freedesktop.org/wiki/Specifications/xsettings-spec)
/// manager that is usually part of the desktop environment, along with
/// utilities that let the user change these settings. In the absence of
/// an Xsettings manager, GTK+ reads default values for settings from
/// `settings.ini` files in
/// `/etc/gtk-3.0`, `$XDG_CONFIG_DIRS/gtk-3.0`
/// and `$XDG_CONFIG_HOME/gtk-3.0`.
/// These files must be valid key files (see `glib.KeyFile`), and have
/// a section called Settings. Themes can also provide default values
/// for settings by installing a `settings.ini` file
/// next to their `gtk.css` file.
///
/// Applications can override system-wide settings by setting the property
/// of the GtkSettings object with `gobject.Object.set`. This should be restricted
/// to special cases though; GtkSettings are not meant as an application
/// configuration facility. When doing so, you need to be aware that settings
/// that are specific to individual widgets may not be available before the
/// widget type has been realized at least once. The following example
/// demonstrates a way to do this:
/// ```
///   gtk_init (&argc, &argv);
///
///   // make sure the type is realized
///   g_type_class_unref (g_type_class_ref (GTK_TYPE_IMAGE_MENU_ITEM));
///
///   g_object_set (gtk_settings_get_default (), "gtk-enable-animations", FALSE, NULL);
/// ```
///
/// There is one GtkSettings instance per screen. It can be obtained with
/// `gtk.Settings.getForScreen`, but in many cases, it is more convenient
/// to use `gtk.Widget.getSettings`. `gtk.Settings.getDefault` returns the
/// GtkSettings instance for the default screen.
pub const Settings = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gtk.StyleProvider};
    pub const Class = gtk.SettingsClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.SettingsPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Holds a hash table representation of the `gtk.Settings.properties.gtk`-color-scheme
        /// setting, mapping color names to `GdkColors`.
        pub const color_hash = struct {
            pub const name = "color-hash";

            pub const Type = ?*glib.HashTable;
        };

        pub const gtk_alternative_button_order = struct {
            pub const name = "gtk-alternative-button-order";

            pub const Type = c_int;
        };

        /// Controls the direction of the sort indicators in sorted list and tree
        /// views. By default an arrow pointing down means the column is sorted
        /// in ascending order. When set to `TRUE`, this order will be inverted.
        pub const gtk_alternative_sort_arrows = struct {
            pub const name = "gtk-alternative-sort-arrows";

            pub const Type = c_int;
        };

        /// Whether the application prefers to use a dark theme. If a GTK+ theme
        /// includes a dark variant, it will be used instead of the configured
        /// theme.
        ///
        /// Some applications benefit from minimizing the amount of light pollution that
        /// interferes with the content. Good candidates for dark themes are photo and
        /// video editors that make the actual content get all the attention and minimize
        /// the distraction of the chrome.
        ///
        /// Dark themes should not be used for documents, where large spaces are white/light
        /// and the dark chrome creates too much contrast (web browser, text editor...).
        pub const gtk_application_prefer_dark_theme = struct {
            pub const name = "gtk-application-prefer-dark-theme";

            pub const Type = c_int;
        };

        /// Whether mnemonics should be automatically shown and hidden when the user
        /// presses the mnemonic activator.
        pub const gtk_auto_mnemonics = struct {
            pub const name = "gtk-auto-mnemonics";

            pub const Type = c_int;
        };

        /// Whether images should be shown on buttons
        pub const gtk_button_images = struct {
            pub const name = "gtk-button-images";

            pub const Type = c_int;
        };

        /// Whether menu accelerators can be changed by pressing a key over the menu item.
        pub const gtk_can_change_accels = struct {
            pub const name = "gtk-can-change-accels";

            pub const Type = c_int;
        };

        /// Palette to use in the deprecated color selector.
        pub const gtk_color_palette = struct {
            pub const name = "gtk-color-palette";

            pub const Type = ?[*:0]u8;
        };

        /// A palette of named colors for use in themes. The format of the string is
        /// ```
        /// name1: color1
        /// name2: color2
        /// ...
        /// ```
        /// Color names must be acceptable as identifiers in the
        /// [gtkrc][gtk3-Resource-Files] syntax, and
        /// color specifications must be in the format accepted by
        /// `gdk.colorParse`.
        ///
        /// Note that due to the way the color tables from different sources are
        /// merged, color specifications will be converted to hexadecimal form
        /// when getting this property.
        ///
        /// Starting with GTK+ 2.12, the entries can alternatively be separated
        /// by ';' instead of newlines:
        /// ```
        /// name1: color1; name2: color2; ...
        /// ```
        pub const gtk_color_scheme = struct {
            pub const name = "gtk-color-scheme";

            pub const Type = ?[*:0]u8;
        };

        pub const gtk_cursor_aspect_ratio = struct {
            pub const name = "gtk-cursor-aspect-ratio";

            pub const Type = f32;
        };

        /// Whether the cursor should blink.
        ///
        /// Also see the `gtk.Settings.properties.gtk`-cursor-blink-timeout setting,
        /// which allows more flexible control over cursor blinking.
        pub const gtk_cursor_blink = struct {
            pub const name = "gtk-cursor-blink";

            pub const Type = c_int;
        };

        pub const gtk_cursor_blink_time = struct {
            pub const name = "gtk-cursor-blink-time";

            pub const Type = c_int;
        };

        /// Time after which the cursor stops blinking, in seconds.
        /// The timer is reset after each user interaction.
        ///
        /// Setting this to zero has the same effect as setting
        /// `gtk.Settings.properties.gtk`-cursor-blink to `FALSE`.
        pub const gtk_cursor_blink_timeout = struct {
            pub const name = "gtk-cursor-blink-timeout";

            pub const Type = c_int;
        };

        pub const gtk_cursor_theme_name = struct {
            pub const name = "gtk-cursor-theme-name";

            pub const Type = ?[*:0]u8;
        };

        pub const gtk_cursor_theme_size = struct {
            pub const name = "gtk-cursor-theme-size";

            pub const Type = c_int;
        };

        /// This setting determines which buttons should be put in the
        /// titlebar of client-side decorated windows, and whether they
        /// should be placed at the left of right.
        ///
        /// The format of the string is button names, separated by commas.
        /// A colon separates the buttons that should appear on the left
        /// from those on the right. Recognized button names are minimize,
        /// maximize, close, icon (the window icon) and menu (a menu button
        /// for the fallback app menu).
        ///
        /// For example, "menu:minimize,maximize,close" specifies a menu
        /// on the left, and minimize, maximize and close buttons on the right.
        ///
        /// Note that buttons will only be shown when they are meaningful.
        /// E.g. a menu button only appears when the desktop shell does not
        /// show the app menu, and a close button only appears on a window
        /// that can be closed.
        ///
        /// Also note that the setting can be overridden with the
        /// `gtk.HeaderBar.properties.decoration`-layout property.
        pub const gtk_decoration_layout = struct {
            pub const name = "gtk-decoration-layout";

            pub const Type = ?[*:0]u8;
        };

        /// Whether builtin GTK+ dialogs such as the file chooser, the
        /// color chooser or the font chooser will use a header bar at
        /// the top to show action widgets, or an action area at the bottom.
        ///
        /// This setting does not affect custom dialogs using GtkDialog
        /// directly, or message dialogs.
        pub const gtk_dialogs_use_header = struct {
            pub const name = "gtk-dialogs-use-header";

            pub const Type = c_int;
        };

        pub const gtk_dnd_drag_threshold = struct {
            pub const name = "gtk-dnd-drag-threshold";

            pub const Type = c_int;
        };

        pub const gtk_double_click_distance = struct {
            pub const name = "gtk-double-click-distance";

            pub const Type = c_int;
        };

        pub const gtk_double_click_time = struct {
            pub const name = "gtk-double-click-time";

            pub const Type = c_int;
        };

        /// Whether menu items should have visible accelerators which can be
        /// activated.
        pub const gtk_enable_accels = struct {
            pub const name = "gtk-enable-accels";

            pub const Type = c_int;
        };

        pub const gtk_enable_animations = struct {
            pub const name = "gtk-enable-animations";

            pub const Type = c_int;
        };

        /// Whether to play any event sounds at all.
        ///
        /// See the [Sound Theme Specifications](http://www.freedesktop.org/wiki/Specifications/sound-theme-spec)
        /// for more information on event sounds and sound themes.
        ///
        /// GTK+ itself does not support event sounds, you have to use a loadable
        /// module like the one that comes with libcanberra.
        pub const gtk_enable_event_sounds = struct {
            pub const name = "gtk-enable-event-sounds";

            pub const Type = c_int;
        };

        /// Whether to play event sounds as feedback to user input.
        ///
        /// See the [Sound Theme Specifications](http://www.freedesktop.org/wiki/Specifications/sound-theme-spec)
        /// for more information on event sounds and sound themes.
        ///
        /// GTK+ itself does not support event sounds, you have to use a loadable
        /// module like the one that comes with libcanberra.
        pub const gtk_enable_input_feedback_sounds = struct {
            pub const name = "gtk-enable-input-feedback-sounds";

            pub const Type = c_int;
        };

        /// Whether labels and menu items should have visible mnemonics which
        /// can be activated.
        pub const gtk_enable_mnemonics = struct {
            pub const name = "gtk-enable-mnemonics";

            pub const Type = c_int;
        };

        /// Whether a middle click on a mouse should paste the
        /// 'PRIMARY' clipboard content at the cursor location.
        pub const gtk_enable_primary_paste = struct {
            pub const name = "gtk-enable-primary-paste";

            pub const Type = c_int;
        };

        /// Whether tooltips should be shown on widgets.
        pub const gtk_enable_tooltips = struct {
            pub const name = "gtk-enable-tooltips";

            pub const Type = c_int;
        };

        /// How long to show the last input character in hidden
        /// entries. This value is in milliseconds. 0 disables showing the
        /// last char. 600 is a good value for enabling it.
        pub const gtk_entry_password_hint_timeout = struct {
            pub const name = "gtk-entry-password-hint-timeout";

            pub const Type = c_uint;
        };

        pub const gtk_entry_select_on_focus = struct {
            pub const name = "gtk-entry-select-on-focus";

            pub const Type = c_int;
        };

        /// When `TRUE`, keyboard navigation and other input-related errors
        /// will cause a beep. Since the error bell is implemented using
        /// `gdk.Window.beep`, the windowing system may offer ways to
        /// configure the error bell in many ways, such as flashing the
        /// window or similar visual effects.
        pub const gtk_error_bell = struct {
            pub const name = "gtk-error-bell";

            pub const Type = c_int;
        };

        /// Name of a icon theme to fall back to.
        pub const gtk_fallback_icon_theme = struct {
            pub const name = "gtk-fallback-icon-theme";

            pub const Type = ?[*:0]u8;
        };

        /// Name of the GtkFileChooser backend to use by default.
        pub const gtk_file_chooser_backend = struct {
            pub const name = "gtk-file-chooser-backend";

            pub const Type = ?[*:0]u8;
        };

        /// The default font to use. GTK+ uses the family name and size from this string.
        pub const gtk_font_name = struct {
            pub const name = "gtk-font-name";

            pub const Type = ?[*:0]u8;
        };

        pub const gtk_fontconfig_timestamp = struct {
            pub const name = "gtk-fontconfig-timestamp";

            pub const Type = c_uint;
        };

        /// A list of icon sizes. The list is separated by colons, and
        /// item has the form:
        ///
        /// `size-name` = `width` , `height`
        ///
        /// E.g. "gtk-menu=16,16:gtk-button=20,20:gtk-dialog=48,48".
        /// GTK+ itself use the following named icon sizes: gtk-menu,
        /// gtk-button, gtk-small-toolbar, gtk-large-toolbar, gtk-dnd,
        /// gtk-dialog. Applications can register their own named icon
        /// sizes with `gtk.iconSizeRegister`.
        pub const gtk_icon_sizes = struct {
            pub const name = "gtk-icon-sizes";

            pub const Type = ?[*:0]u8;
        };

        pub const gtk_icon_theme_name = struct {
            pub const name = "gtk-icon-theme-name";

            pub const Type = ?[*:0]u8;
        };

        /// Which IM (input method) module should be used by default. This is the
        /// input method that will be used if the user has not explicitly chosen
        /// another input method from the IM context menu.
        /// This also can be a colon-separated list of input methods, which GTK+
        /// will try in turn until it finds one available on the system.
        ///
        /// See `gtk.IMContext`.
        pub const gtk_im_module = struct {
            pub const name = "gtk-im-module";

            pub const Type = ?[*:0]u8;
        };

        /// How to draw the input method preedit string.
        pub const gtk_im_preedit_style = struct {
            pub const name = "gtk-im-preedit-style";

            pub const Type = gtk.IMPreeditStyle;
        };

        /// How to draw the input method statusbar.
        pub const gtk_im_status_style = struct {
            pub const name = "gtk-im-status-style";

            pub const Type = gtk.IMStatusStyle;
        };

        pub const gtk_key_theme_name = struct {
            pub const name = "gtk-key-theme-name";

            pub const Type = ?[*:0]u8;
        };

        /// When `TRUE`, keyboard navigation should be able to reach all widgets
        /// by using the cursor keys only. Tab, Shift etc. keys can't be expected
        /// to be present on the used input device.
        pub const gtk_keynav_cursor_only = struct {
            pub const name = "gtk-keynav-cursor-only";

            pub const Type = c_int;
        };

        /// Whether GTK+ should make sure that text can be navigated with
        /// a caret, even if it is not editable. This is useful when using
        /// a screen reader.
        pub const gtk_keynav_use_caret = struct {
            pub const name = "gtk-keynav-use-caret";

            pub const Type = c_int;
        };

        /// When `TRUE`, some widgets will wrap around when doing keyboard
        /// navigation, such as menus, menubars and notebooks.
        pub const gtk_keynav_wrap_around = struct {
            pub const name = "gtk-keynav-wrap-around";

            pub const Type = c_int;
        };

        pub const gtk_label_select_on_focus = struct {
            pub const name = "gtk-label-select-on-focus";

            pub const Type = c_int;
        };

        /// The time for a button or touch press to be considered a "long press".
        pub const gtk_long_press_time = struct {
            pub const name = "gtk-long-press-time";

            pub const Type = c_uint;
        };

        /// Keybinding to activate the menu bar.
        pub const gtk_menu_bar_accel = struct {
            pub const name = "gtk-menu-bar-accel";

            pub const Type = ?[*:0]u8;
        };

        /// Delay before the submenus of a menu bar appear.
        pub const gtk_menu_bar_popup_delay = struct {
            pub const name = "gtk-menu-bar-popup-delay";

            pub const Type = c_int;
        };

        /// Whether images should be shown in menu items
        pub const gtk_menu_images = struct {
            pub const name = "gtk-menu-images";

            pub const Type = c_int;
        };

        /// The time before hiding a submenu when the pointer is moving towards the submenu.
        pub const gtk_menu_popdown_delay = struct {
            pub const name = "gtk-menu-popdown-delay";

            pub const Type = c_int;
        };

        /// Minimum time the pointer must stay over a menu item before the submenu appear.
        pub const gtk_menu_popup_delay = struct {
            pub const name = "gtk-menu-popup-delay";

            pub const Type = c_int;
        };

        pub const gtk_modules = struct {
            pub const name = "gtk-modules";

            pub const Type = ?[*:0]u8;
        };

        /// Whether scrolled windows may use overlayed scrolling indicators.
        /// If this is set to `FALSE`, scrolled windows will have permanent
        /// scrollbars.
        pub const gtk_overlay_scrolling = struct {
            pub const name = "gtk-overlay-scrolling";

            pub const Type = c_int;
        };

        /// If the value of this setting is `TRUE`, clicking the primary button in a
        /// `gtk.Range` trough will move the slider, and hence set the range’s value, to
        /// the point that you clicked. If it is `FALSE`, a primary click will cause the
        /// slider/value to move by the range’s page-size towards the point clicked.
        ///
        /// Whichever action you choose for the primary button, the other action will
        /// be available by holding Shift and primary-clicking, or (since GTK+ 3.22.25)
        /// clicking the middle mouse button.
        pub const gtk_primary_button_warps_slider = struct {
            pub const name = "gtk-primary-button-warps-slider";

            pub const Type = c_int;
        };

        /// A comma-separated list of print backends to use in the print
        /// dialog. Available print backends depend on the GTK+ installation,
        /// and may include "file", "cups", "lpr" or "papi".
        pub const gtk_print_backends = struct {
            pub const name = "gtk-print-backends";

            pub const Type = ?[*:0]u8;
        };

        /// A command to run for displaying the print preview. The command
        /// should contain a ``f`` placeholder, which will get replaced by
        /// the path to the pdf file. The command may also contain a ``s``
        /// placeholder, which will get replaced by the path to a file
        /// containing the print settings in the format produced by
        /// `gtk.PrintSettings.toFile`.
        ///
        /// The preview application is responsible for removing the pdf file
        /// and the print settings file when it is done.
        pub const gtk_print_preview_command = struct {
            pub const name = "gtk-print-preview-command";

            pub const Type = ?[*:0]u8;
        };

        /// Whether GTK+ should keep track of items inside the recently used
        /// resources list. If set to `FALSE`, the list will always be empty.
        pub const gtk_recent_files_enabled = struct {
            pub const name = "gtk-recent-files-enabled";

            pub const Type = c_int;
        };

        /// The number of recently used files that should be displayed by default by
        /// `gtk.RecentChooser` implementations and by the `gtk.FileChooser`. A value of
        /// -1 means every recently used file stored.
        pub const gtk_recent_files_limit = struct {
            pub const name = "gtk-recent-files-limit";

            pub const Type = c_int;
        };

        /// The maximum age, in days, of the items inside the recently used
        /// resources list. Items older than this setting will be excised
        /// from the list. If set to 0, the list will always be empty; if
        /// set to -1, no item will be removed.
        pub const gtk_recent_files_max_age = struct {
            pub const name = "gtk-recent-files-max-age";

            pub const Type = c_int;
        };

        /// Where the contents of scrolled windows are located with respect to the
        /// scrollbars, if not overridden by the scrolled window's own placement.
        pub const gtk_scrolled_window_placement = struct {
            pub const name = "gtk-scrolled-window-placement";

            pub const Type = gtk.CornerType;
        };

        pub const gtk_shell_shows_app_menu = struct {
            pub const name = "gtk-shell-shows-app-menu";

            pub const Type = c_int;
        };

        pub const gtk_shell_shows_desktop = struct {
            pub const name = "gtk-shell-shows-desktop";

            pub const Type = c_int;
        };

        pub const gtk_shell_shows_menubar = struct {
            pub const name = "gtk-shell-shows-menubar";

            pub const Type = c_int;
        };

        pub const gtk_show_input_method_menu = struct {
            pub const name = "gtk-show-input-method-menu";

            pub const Type = c_int;
        };

        pub const gtk_show_unicode_menu = struct {
            pub const name = "gtk-show-unicode-menu";

            pub const Type = c_int;
        };

        /// The XDG sound theme to use for event sounds.
        ///
        /// See the [Sound Theme Specifications](http://www.freedesktop.org/wiki/Specifications/sound-theme-spec)
        /// for more information on event sounds and sound themes.
        ///
        /// GTK+ itself does not support event sounds, you have to use a loadable
        /// module like the one that comes with libcanberra.
        pub const gtk_sound_theme_name = struct {
            pub const name = "gtk-sound-theme-name";

            pub const Type = ?[*:0]u8;
        };

        pub const gtk_split_cursor = struct {
            pub const name = "gtk-split-cursor";

            pub const Type = c_int;
        };

        pub const gtk_theme_name = struct {
            pub const name = "gtk-theme-name";

            pub const Type = ?[*:0]u8;
        };

        pub const gtk_timeout_expand = struct {
            pub const name = "gtk-timeout-expand";

            pub const Type = c_int;
        };

        pub const gtk_timeout_initial = struct {
            pub const name = "gtk-timeout-initial";

            pub const Type = c_int;
        };

        pub const gtk_timeout_repeat = struct {
            pub const name = "gtk-timeout-repeat";

            pub const Type = c_int;
        };

        /// This setting determines the action to take when a double-click
        /// occurs on the titlebar of client-side decorated windows.
        ///
        /// Recognized actions are minimize, toggle-maximize, menu, lower
        /// or none.
        pub const gtk_titlebar_double_click = struct {
            pub const name = "gtk-titlebar-double-click";

            pub const Type = ?[*:0]u8;
        };

        /// This setting determines the action to take when a middle-click
        /// occurs on the titlebar of client-side decorated windows.
        ///
        /// Recognized actions are minimize, toggle-maximize, menu, lower
        /// or none.
        pub const gtk_titlebar_middle_click = struct {
            pub const name = "gtk-titlebar-middle-click";

            pub const Type = ?[*:0]u8;
        };

        /// This setting determines the action to take when a right-click
        /// occurs on the titlebar of client-side decorated windows.
        ///
        /// Recognized actions are minimize, toggle-maximize, menu, lower
        /// or none.
        pub const gtk_titlebar_right_click = struct {
            pub const name = "gtk-titlebar-right-click";

            pub const Type = ?[*:0]u8;
        };

        /// The size of icons in default toolbars.
        pub const gtk_toolbar_icon_size = struct {
            pub const name = "gtk-toolbar-icon-size";

            pub const Type = gtk.IconSize;
        };

        /// The size of icons in default toolbars.
        pub const gtk_toolbar_style = struct {
            pub const name = "gtk-toolbar-style";

            pub const Type = gtk.ToolbarStyle;
        };

        /// Amount of time, in milliseconds, after which the browse mode
        /// will be disabled.
        ///
        /// See `gtk.Settings.properties.gtk`-tooltip-browse-timeout for more information
        /// about browse mode.
        pub const gtk_tooltip_browse_mode_timeout = struct {
            pub const name = "gtk-tooltip-browse-mode-timeout";

            pub const Type = c_int;
        };

        /// Controls the time after which tooltips will appear when
        /// browse mode is enabled, in milliseconds.
        ///
        /// Browse mode is enabled when the mouse pointer moves off an object
        /// where a tooltip was currently being displayed. If the mouse pointer
        /// hits another object before the browse mode timeout expires (see
        /// `gtk.Settings.properties.gtk`-tooltip-browse-mode-timeout), it will take the
        /// amount of milliseconds specified by this setting to popup the tooltip
        /// for the new object.
        pub const gtk_tooltip_browse_timeout = struct {
            pub const name = "gtk-tooltip-browse-timeout";

            pub const Type = c_int;
        };

        /// Time, in milliseconds, after which a tooltip could appear if the
        /// cursor is hovering on top of a widget.
        pub const gtk_tooltip_timeout = struct {
            pub const name = "gtk-tooltip-timeout";

            pub const Type = c_int;
        };

        /// When `TRUE`, there are no motion notify events delivered on this screen,
        /// and widgets can't use the pointer hovering them for any essential
        /// functionality.
        pub const gtk_touchscreen_mode = struct {
            pub const name = "gtk-touchscreen-mode";

            pub const Type = c_int;
        };

        /// Whether 'focus rectangles' should be always visible, never visible,
        /// or hidden until the user starts to use the keyboard.
        pub const gtk_visible_focus = struct {
            pub const name = "gtk-visible-focus";

            pub const Type = gtk.PolicyType;
        };

        pub const gtk_xft_antialias = struct {
            pub const name = "gtk-xft-antialias";

            pub const Type = c_int;
        };

        pub const gtk_xft_dpi = struct {
            pub const name = "gtk-xft-dpi";

            pub const Type = c_int;
        };

        pub const gtk_xft_hinting = struct {
            pub const name = "gtk-xft-hinting";

            pub const Type = c_int;
        };

        pub const gtk_xft_hintstyle = struct {
            pub const name = "gtk-xft-hintstyle";

            pub const Type = ?[*:0]u8;
        };

        pub const gtk_xft_rgba = struct {
            pub const name = "gtk-xft-rgba";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Gets the `gtk.Settings` object for the default GDK screen, creating
    /// it if necessary. See `gtk.Settings.getForScreen`.
    extern fn gtk_settings_get_default() ?*gtk.Settings;
    pub const getDefault = gtk_settings_get_default;

    /// Gets the `gtk.Settings` object for `screen`, creating it if necessary.
    extern fn gtk_settings_get_for_screen(p_screen: *gdk.Screen) *gtk.Settings;
    pub const getForScreen = gtk_settings_get_for_screen;

    extern fn gtk_settings_install_property(p_pspec: *gobject.ParamSpec) void;
    pub const installProperty = gtk_settings_install_property;

    extern fn gtk_settings_install_property_parser(p_pspec: *gobject.ParamSpec, p_parser: gtk.RcPropertyParser) void;
    pub const installPropertyParser = gtk_settings_install_property_parser;

    /// Undoes the effect of calling `gobject.Object.set` to install an
    /// application-specific value for a setting. After this call,
    /// the setting will again follow the session-wide value for
    /// this setting.
    extern fn gtk_settings_reset_property(p_settings: *Settings, p_name: [*:0]const u8) void;
    pub const resetProperty = gtk_settings_reset_property;

    extern fn gtk_settings_set_double_property(p_settings: *Settings, p_name: [*:0]const u8, p_v_double: f64, p_origin: [*:0]const u8) void;
    pub const setDoubleProperty = gtk_settings_set_double_property;

    extern fn gtk_settings_set_long_property(p_settings: *Settings, p_name: [*:0]const u8, p_v_long: c_long, p_origin: [*:0]const u8) void;
    pub const setLongProperty = gtk_settings_set_long_property;

    extern fn gtk_settings_set_property_value(p_settings: *Settings, p_name: [*:0]const u8, p_svalue: *const gtk.SettingsValue) void;
    pub const setPropertyValue = gtk_settings_set_property_value;

    extern fn gtk_settings_set_string_property(p_settings: *Settings, p_name: [*:0]const u8, p_v_string: [*:0]const u8, p_origin: [*:0]const u8) void;
    pub const setStringProperty = gtk_settings_set_string_property;

    extern fn gtk_settings_get_type() usize;
    pub const getGObjectType = gtk_settings_get_type;

    extern fn g_object_ref(p_self: *gtk.Settings) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Settings) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Settings, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.ShortcutLabel` is a widget that represents a single keyboard shortcut or gesture
/// in the user interface.
pub const ShortcutLabel = opaque {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.ShortcutLabelClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The accelerator that `self` displays. See `gtk.ShortcutsShortcut.properties.accelerator`
        /// for the accepted syntax.
        pub const accelerator = struct {
            pub const name = "accelerator";

            pub const Type = ?[*:0]u8;
        };

        /// The text that is displayed when no accelerator is set.
        pub const disabled_text = struct {
            pub const name = "disabled-text";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.ShortcutLabel` with `accelerator` set.
    extern fn gtk_shortcut_label_new(p_accelerator: [*:0]const u8) *gtk.ShortcutLabel;
    pub const new = gtk_shortcut_label_new;

    /// Retrieves the current accelerator of `self`.
    extern fn gtk_shortcut_label_get_accelerator(p_self: *ShortcutLabel) ?[*:0]const u8;
    pub const getAccelerator = gtk_shortcut_label_get_accelerator;

    /// Retrieves the text that is displayed when no accelerator is set.
    extern fn gtk_shortcut_label_get_disabled_text(p_self: *ShortcutLabel) ?[*:0]const u8;
    pub const getDisabledText = gtk_shortcut_label_get_disabled_text;

    /// Sets the accelerator to be displayed by `self`.
    extern fn gtk_shortcut_label_set_accelerator(p_self: *ShortcutLabel, p_accelerator: [*:0]const u8) void;
    pub const setAccelerator = gtk_shortcut_label_set_accelerator;

    /// Sets the text to be displayed by `self` when no accelerator is set.
    extern fn gtk_shortcut_label_set_disabled_text(p_self: *ShortcutLabel, p_disabled_text: [*:0]const u8) void;
    pub const setDisabledText = gtk_shortcut_label_set_disabled_text;

    extern fn gtk_shortcut_label_get_type() usize;
    pub const getGObjectType = gtk_shortcut_label_get_type;

    extern fn g_object_ref(p_self: *gtk.ShortcutLabel) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ShortcutLabel) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ShortcutLabel, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkShortcutsGroup represents a group of related keyboard shortcuts
/// or gestures. The group has a title. It may optionally be associated with
/// a view of the application, which can be used to show only relevant shortcuts
/// depending on the application context.
///
/// This widget is only meant to be used with `gtk.ShortcutsWindow`.
pub const ShortcutsGroup = opaque {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.ShortcutsGroupClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The size group for the accelerator portion of shortcuts in this group.
        ///
        /// This is used internally by GTK+, and must not be modified by applications.
        pub const accel_size_group = struct {
            pub const name = "accel-size-group";

            pub const Type = ?*gtk.SizeGroup;
        };

        /// A rough measure for the number of lines in this group.
        ///
        /// This is used internally by GTK+, and is not useful for applications.
        pub const height = struct {
            pub const name = "height";

            pub const Type = c_uint;
        };

        /// The title for this group of shortcuts.
        pub const title = struct {
            pub const name = "title";

            pub const Type = ?[*:0]u8;
        };

        /// The size group for the textual portion of shortcuts in this group.
        ///
        /// This is used internally by GTK+, and must not be modified by applications.
        pub const title_size_group = struct {
            pub const name = "title-size-group";

            pub const Type = ?*gtk.SizeGroup;
        };

        /// An optional view that the shortcuts in this group are relevant for.
        /// The group will be hidden if the `gtk.ShortcutsWindow.properties.view`-name property
        /// does not match the view of this group.
        ///
        /// Set this to `NULL` to make the group always visible.
        pub const view = struct {
            pub const name = "view";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    extern fn gtk_shortcuts_group_get_type() usize;
    pub const getGObjectType = gtk_shortcuts_group_get_type;

    extern fn g_object_ref(p_self: *gtk.ShortcutsGroup) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ShortcutsGroup) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ShortcutsGroup, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkShortcutsSection collects all the keyboard shortcuts and gestures
/// for a major application mode. If your application needs multiple sections,
/// you should give each section a unique `gtk.ShortcutsSection.properties.section`-name and
/// a `gtk.ShortcutsSection.properties.title` that can be shown in the section selector of
/// the GtkShortcutsWindow.
///
/// The `gtk.ShortcutsSection.properties.max`-height property can be used to influence how
/// the groups in the section are distributed over pages and columns.
///
/// This widget is only meant to be used with `gtk.ShortcutsWindow`.
pub const ShortcutsSection = opaque {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.ShortcutsSectionClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The maximum number of lines to allow per column. This property can
        /// be used to influence how the groups in this section are distributed
        /// across pages and columns. The default value of 15 should work in
        /// most cases.
        pub const max_height = struct {
            pub const name = "max-height";

            pub const Type = c_uint;
        };

        /// A unique name to identify this section among the sections
        /// added to the GtkShortcutsWindow. Setting the `gtk.ShortcutsWindow.properties.section`-name
        /// property to this string will make this section shown in the
        /// GtkShortcutsWindow.
        pub const section_name = struct {
            pub const name = "section-name";

            pub const Type = ?[*:0]u8;
        };

        /// The string to show in the section selector of the GtkShortcutsWindow
        /// for this section. If there is only one section, you don't need to
        /// set a title, since the section selector will not be shown in this case.
        pub const title = struct {
            pub const name = "title";

            pub const Type = ?[*:0]u8;
        };

        /// A view name to filter the groups in this section by.
        /// See `gtk.ShortcutsGroup.properties.view`.
        ///
        /// Applications are expected to use the `gtk.ShortcutsWindow.properties.view`-name
        /// property for this purpose.
        pub const view_name = struct {
            pub const name = "view-name";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {
        pub const change_current_page = struct {
            pub const name = "change-current-page";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ShortcutsSection, p_instance))),
                    gobject.signalLookup("change-current-page", ShortcutsSection.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    extern fn gtk_shortcuts_section_get_type() usize;
    pub const getGObjectType = gtk_shortcuts_section_get_type;

    extern fn g_object_ref(p_self: *gtk.ShortcutsSection) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ShortcutsSection) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ShortcutsSection, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkShortcutsShortcut represents a single keyboard shortcut or gesture
/// with a short text. This widget is only meant to be used with `gtk.ShortcutsWindow`.
pub const ShortcutsShortcut = opaque {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.ShortcutsShortcutClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The size group for the accelerator portion of this shortcut.
        ///
        /// This is used internally by GTK+, and must not be modified by applications.
        pub const accel_size_group = struct {
            pub const name = "accel-size-group";

            pub const Type = ?*gtk.SizeGroup;
        };

        /// The accelerator(s) represented by this object. This property is used
        /// if `gtk.ShortcutsShortcut.properties.shortcut`-type is set to `GTK_SHORTCUT_ACCELERATOR`.
        ///
        /// The syntax of this property is (an extension of) the syntax understood by
        /// `gtk.acceleratorParse`. Multiple accelerators can be specified by separating
        /// them with a space, but keep in mind that the available width is limited.
        /// It is also possible to specify ranges of shortcuts, using `...` between the keys.
        /// Sequences of keys can be specified using a `+` or `&` between the keys.
        ///
        /// Examples:
        ///
        /// - A single shortcut: `<ctl><alt>delete`
        /// - Two alternative shortcuts: `<shift>a Home`
        /// - A range of shortcuts: `<alt>1...<alt>9`
        /// - Several keys pressed together: `Control_L&Control_R`
        /// - A sequence of shortcuts or keys: `<ctl>c+<ctl>x`
        ///
        /// Use + instead of & when the keys may (or have to be) pressed sequentially (e.g
        /// use t+t for 'press the t key twice').
        ///
        /// Note that `<`, `>` and `&` need to be escaped as &lt;, &gt; and &amp; when used
        /// in .ui files.
        pub const accelerator = struct {
            pub const name = "accelerator";

            pub const Type = ?[*:0]u8;
        };

        /// A detailed action name. If this is set for a shortcut
        /// of type `GTK_SHORTCUT_ACCELERATOR`, then GTK+ will use
        /// the accelerators that are associated with the action
        /// via `gtk.Application.setAccelsForAction`, and setting
        /// `gtk.ShortcutsShortcut.signals.accelerator` is not necessary.
        pub const action_name = struct {
            pub const name = "action-name";

            pub const Type = ?[*:0]u8;
        };

        /// The text direction for which this shortcut is active. If the shortcut
        /// is used regardless of the text direction, set this property to
        /// `GTK_TEXT_DIR_NONE`.
        pub const direction = struct {
            pub const name = "direction";

            pub const Type = gtk.TextDirection;
        };

        /// An icon to represent the shortcut or gesture. This property is used if
        /// `gtk.ShortcutsShortcut.properties.shortcut`-type is set to `GTK_SHORTCUT_GESTURE`.
        /// For the other predefined gesture types, GTK+ provides an icon on its own.
        pub const icon = struct {
            pub const name = "icon";

            pub const Type = ?*gio.Icon;
        };

        /// `TRUE` if an icon has been set.
        pub const icon_set = struct {
            pub const name = "icon-set";

            pub const Type = c_int;
        };

        /// The type of shortcut that is represented.
        pub const shortcut_type = struct {
            pub const name = "shortcut-type";

            pub const Type = gtk.ShortcutType;
        };

        /// The subtitle for the shortcut or gesture.
        ///
        /// This is typically used for gestures and should be a short, one-line
        /// text that describes the gesture itself. For the predefined gesture
        /// types, GTK+ provides a subtitle on its own.
        pub const subtitle = struct {
            pub const name = "subtitle";

            pub const Type = ?[*:0]u8;
        };

        /// `TRUE` if a subtitle has been set.
        pub const subtitle_set = struct {
            pub const name = "subtitle-set";

            pub const Type = c_int;
        };

        /// The textual description for the shortcut or gesture represented by
        /// this object. This should be a short string that can fit in a single line.
        pub const title = struct {
            pub const name = "title";

            pub const Type = ?[*:0]u8;
        };

        /// The size group for the textual portion of this shortcut.
        ///
        /// This is used internally by GTK+, and must not be modified by applications.
        pub const title_size_group = struct {
            pub const name = "title-size-group";

            pub const Type = ?*gtk.SizeGroup;
        };
    };

    pub const signals = struct {};

    extern fn gtk_shortcuts_shortcut_get_type() usize;
    pub const getGObjectType = gtk_shortcuts_shortcut_get_type;

    extern fn g_object_ref(p_self: *gtk.ShortcutsShortcut) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ShortcutsShortcut) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ShortcutsShortcut, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkShortcutsWindow shows brief information about the keyboard shortcuts
/// and gestures of an application. The shortcuts can be grouped, and you can
/// have multiple sections in this window, corresponding to the major modes of
/// your application.
///
/// Additionally, the shortcuts can be filtered by the current view, to avoid
/// showing information that is not relevant in the current application context.
///
/// The recommended way to construct a GtkShortcutsWindow is with GtkBuilder,
/// by populating a `gtk.ShortcutsWindow` with one or more `gtk.ShortcutsSection`
/// objects, which contain `GtkShortcutsGroups` that in turn contain objects of
/// class `gtk.ShortcutsShortcut`.
///
/// # A simple example:
///
/// ![](gedit-shortcuts.png)
///
/// This example has as single section. As you can see, the shortcut groups
/// are arranged in columns, and spread across several pages if there are too
/// many to find on a single page.
///
/// The .ui file for this example can be found [here](https://git.gnome.org/browse/gtk+/tree/demos/gtk-demo/shortcuts-gedit.ui).
///
/// # An example with multiple views:
///
/// ![](clocks-shortcuts.png)
///
/// This example shows a `gtk.ShortcutsWindow` that has been configured to show only
/// the shortcuts relevant to the "stopwatch" view.
///
/// The .ui file for this example can be found [here](https://git.gnome.org/browse/gtk+/tree/demos/gtk-demo/shortcuts-clocks.ui).
///
/// # An example with multiple sections:
///
/// ![](builder-shortcuts.png)
///
/// This example shows a `gtk.ShortcutsWindow` with two sections, "Editor Shortcuts"
/// and "Terminal Shortcuts".
///
/// The .ui file for this example can be found [here](https://git.gnome.org/browse/gtk+/tree/demos/gtk-demo/shortcuts-builder.ui).
pub const ShortcutsWindow = extern struct {
    pub const Parent = gtk.Window;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.ShortcutsWindowClass;
    f_window: gtk.Window,

    pub const virtual_methods = struct {
        pub const close = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ShortcutsWindow.Class, p_class).f_close.?(gobject.ext.as(ShortcutsWindow, p_self));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ShortcutsWindow.Class, p_class).f_close = @ptrCast(p_implementation);
            }
        };

        pub const search = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ShortcutsWindow.Class, p_class).f_search.?(gobject.ext.as(ShortcutsWindow, p_self));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ShortcutsWindow.Class, p_class).f_search = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The name of the section to show.
        ///
        /// This should be the section-name of one of the `gtk.ShortcutsSection`
        /// objects that are in this shortcuts window.
        pub const section_name = struct {
            pub const name = "section-name";

            pub const Type = ?[*:0]u8;
        };

        /// The view name by which to filter the contents.
        ///
        /// This should correspond to the `gtk.ShortcutsGroup.properties.view` property of some of
        /// the `gtk.ShortcutsGroup` objects that are inside this shortcuts window.
        ///
        /// Set this to `NULL` to show all groups.
        pub const view_name = struct {
            pub const name = "view-name";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {
        /// The ::close signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user uses a keybinding to close
        /// the window.
        ///
        /// The default binding for this signal is the Escape key.
        pub const close = struct {
            pub const name = "close";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ShortcutsWindow, p_instance))),
                    gobject.signalLookup("close", ShortcutsWindow.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::search signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user uses a keybinding to start a search.
        ///
        /// The default binding for this signal is Control-F.
        pub const search = struct {
            pub const name = "search";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ShortcutsWindow, p_instance))),
                    gobject.signalLookup("search", ShortcutsWindow.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    extern fn gtk_shortcuts_window_get_type() usize;
    pub const getGObjectType = gtk_shortcuts_window_get_type;

    extern fn g_object_ref(p_self: *gtk.ShortcutsWindow) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ShortcutsWindow) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ShortcutsWindow, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.SizeGroup` provides a mechanism for grouping a number of widgets
/// together so they all request the same amount of space.  This is
/// typically useful when you want a column of widgets to have the same
/// size, but you can’t use a `gtk.Grid` widget.
///
/// In detail, the size requested for each widget in a `gtk.SizeGroup` is
/// the maximum of the sizes that would have been requested for each
/// widget in the size group if they were not in the size group. The mode
/// of the size group (see `gtk.SizeGroup.setMode`) determines whether
/// this applies to the horizontal size, the vertical size, or both sizes.
///
/// Note that size groups only affect the amount of space requested, not
/// the size that the widgets finally receive. If you want the widgets in
/// a `gtk.SizeGroup` to actually be the same size, you need to pack them in
/// such a way that they get the size they request and not more. For
/// example, if you are packing your widgets into a table, you would not
/// include the `GTK_FILL` flag.
///
/// `gtk.SizeGroup` objects are referenced by each widget in the size group,
/// so once you have added all widgets to a `gtk.SizeGroup`, you can drop
/// the initial reference to the size group with `gobject.Object.unref`. If the
/// widgets in the size group are subsequently destroyed, then they will
/// be removed from the size group and drop their references on the size
/// group; when all widgets have been removed, the size group will be
/// freed.
///
/// Widgets can be part of multiple size groups; GTK+ will compute the
/// horizontal size of a widget from the horizontal requisition of all
/// widgets that can be reached from the widget by a chain of size groups
/// of type `GTK_SIZE_GROUP_HORIZONTAL` or `GTK_SIZE_GROUP_BOTH`, and the
/// vertical size from the vertical requisition of all widgets that can be
/// reached from the widget by a chain of size groups of type
/// `GTK_SIZE_GROUP_VERTICAL` or `GTK_SIZE_GROUP_BOTH`.
///
/// Note that only non-contextual sizes of every widget are ever consulted
/// by size groups (since size groups have no knowledge of what size a widget
/// will be allocated in one dimension, it cannot derive how much height
/// a widget will receive for a given width). When grouping widgets that
/// trade height for width in mode `GTK_SIZE_GROUP_VERTICAL` or `GTK_SIZE_GROUP_BOTH`:
/// the height for the minimum width will be the requested height for all
/// widgets in the group. The same is of course true when horizontally grouping
/// width for height widgets.
///
/// Widgets that trade height-for-width should set a reasonably large minimum width
/// by way of `gtk.Label.properties.width`-chars for instance. Widgets with static sizes as well
/// as widgets that grow (such as ellipsizing text) need no such considerations.
///
/// # GtkSizeGroup as GtkBuildable
///
/// Size groups can be specified in a UI definition by placing an `<object>`
/// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
/// widgets that belong to the size group are specified by a `<widgets>` element
/// that may contain multiple `<widget>` elements, one for each member of the
/// size group. The ”name” attribute gives the id of the widget.
///
/// An example of a UI definition fragment with GtkSizeGroup:
///
/// ```
/// <object class="GtkSizeGroup">
///   <property name="mode">GTK_SIZE_GROUP_HORIZONTAL</property>
///   <widgets>
///     <widget name="radio1"/>
///     <widget name="radio2"/>
///   </widgets>
/// </object>
/// ```
pub const SizeGroup = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gtk.Buildable};
    pub const Class = gtk.SizeGroupClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.SizeGroupPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// If `TRUE`, unmapped widgets are ignored when determining
        /// the size of the group.
        pub const ignore_hidden = struct {
            pub const name = "ignore-hidden";

            pub const Type = c_int;
        };

        pub const mode = struct {
            pub const name = "mode";

            pub const Type = gtk.SizeGroupMode;
        };
    };

    pub const signals = struct {};

    /// Create a new `gtk.SizeGroup`.
    extern fn gtk_size_group_new(p_mode: gtk.SizeGroupMode) *gtk.SizeGroup;
    pub const new = gtk_size_group_new;

    /// Adds a widget to a `gtk.SizeGroup`. In the future, the requisition
    /// of the widget will be determined as the maximum of its requisition
    /// and the requisition of the other widgets in the size group.
    /// Whether this applies horizontally, vertically, or in both directions
    /// depends on the mode of the size group. See `gtk.SizeGroup.setMode`.
    ///
    /// When the widget is destroyed or no longer referenced elsewhere, it will
    /// be removed from the size group.
    extern fn gtk_size_group_add_widget(p_size_group: *SizeGroup, p_widget: *gtk.Widget) void;
    pub const addWidget = gtk_size_group_add_widget;

    /// Returns if invisible widgets are ignored when calculating the size.
    extern fn gtk_size_group_get_ignore_hidden(p_size_group: *SizeGroup) c_int;
    pub const getIgnoreHidden = gtk_size_group_get_ignore_hidden;

    /// Gets the current mode of the size group. See `gtk.SizeGroup.setMode`.
    extern fn gtk_size_group_get_mode(p_size_group: *SizeGroup) gtk.SizeGroupMode;
    pub const getMode = gtk_size_group_get_mode;

    /// Returns the list of widgets associated with `size_group`.
    extern fn gtk_size_group_get_widgets(p_size_group: *SizeGroup) *glib.SList;
    pub const getWidgets = gtk_size_group_get_widgets;

    /// Removes a widget from a `gtk.SizeGroup`.
    extern fn gtk_size_group_remove_widget(p_size_group: *SizeGroup, p_widget: *gtk.Widget) void;
    pub const removeWidget = gtk_size_group_remove_widget;

    /// Sets whether unmapped widgets should be ignored when
    /// calculating the size.
    extern fn gtk_size_group_set_ignore_hidden(p_size_group: *SizeGroup, p_ignore_hidden: c_int) void;
    pub const setIgnoreHidden = gtk_size_group_set_ignore_hidden;

    /// Sets the `gtk.SizeGroupMode` of the size group. The mode of the size
    /// group determines whether the widgets in the size group should
    /// all have the same horizontal requisition (`GTK_SIZE_GROUP_HORIZONTAL`)
    /// all have the same vertical requisition (`GTK_SIZE_GROUP_VERTICAL`),
    /// or should all have the same requisition in both directions
    /// (`GTK_SIZE_GROUP_BOTH`).
    extern fn gtk_size_group_set_mode(p_size_group: *SizeGroup, p_mode: gtk.SizeGroupMode) void;
    pub const setMode = gtk_size_group_set_mode;

    extern fn gtk_size_group_get_type() usize;
    pub const getGObjectType = gtk_size_group_get_type;

    extern fn g_object_ref(p_self: *gtk.SizeGroup) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.SizeGroup) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SizeGroup, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Together with `gtk.Plug`, `gtk.Socket` provides the ability to embed
/// widgets from one process into another process in a fashion that
/// is transparent to the user. One process creates a `gtk.Socket` widget
/// and passes that widget’s window ID to the other process, which then
/// creates a `gtk.Plug` with that window ID. Any widgets contained in the
/// `gtk.Plug` then will appear inside the first application’s window.
///
/// The socket’s window ID is obtained by using `gtk.Socket.getId`.
/// Before using this function, the socket must have been realized,
/// and for hence, have been added to its parent.
///
/// ## Obtaining the window ID of a socket.
///
/// ```
/// GtkWidget *socket = gtk_socket_new ();
/// gtk_widget_show (socket);
/// gtk_container_add (GTK_CONTAINER (parent), socket);
///
/// // The following call is only necessary if one of
/// // the ancestors of the socket is not yet visible.
/// gtk_widget_realize (socket);
/// g_print ("The ID of the sockets window is %`x`\n",
///          gtk_socket_get_id (socket));
/// ```
///
/// Note that if you pass the window ID of the socket to another
/// process that will create a plug in the socket, you must make
/// sure that the socket widget is not destroyed until that plug
/// is created. Violating this rule will cause unpredictable
/// consequences, the most likely consequence being that the plug
/// will appear as a separate toplevel window. You can check if
/// the plug has been created by using `gtk.Socket.getPlugWindow`.
/// If it returns a non-`NULL` value, then the plug has been
/// successfully created inside of the socket.
///
/// When GTK+ is notified that the embedded window has been destroyed,
/// then it will destroy the socket as well. You should always,
/// therefore, be prepared for your sockets to be destroyed at any
/// time when the main event loop is running. To prevent this from
/// happening, you can connect to the `gtk.Socket.signals.plug`-removed signal.
///
/// The communication between a `gtk.Socket` and a `gtk.Plug` follows the
/// [XEmbed Protocol](http://www.freedesktop.org/Standards/xembed-spec).
/// This protocol has also been implemented in other toolkits, e.g. Qt,
/// allowing the same level of integration when embedding a Qt widget
/// in GTK or vice versa.
///
/// The `gtk.Plug` and `gtk.Socket` widgets are only available when GTK+
/// is compiled for the X11 platform and `GDK_WINDOWING_X11` is defined.
/// They can only be used on a `GdkX11Display`. To use `gtk.Plug` and
/// `gtk.Socket`, you need to include the `gtk/gtkx.h` header.
pub const Socket = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.SocketClass;
    f_container: gtk.Container,
    f_priv: ?*gtk.SocketPrivate,

    pub const virtual_methods = struct {
        pub const plug_added = struct {
            pub fn call(p_class: anytype, p_socket_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Socket.Class, p_class).f_plug_added.?(gobject.ext.as(Socket, p_socket_));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_socket_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Socket.Class, p_class).f_plug_added = @ptrCast(p_implementation);
            }
        };

        pub const plug_removed = struct {
            pub fn call(p_class: anytype, p_socket_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Socket.Class, p_class).f_plug_removed.?(gobject.ext.as(Socket, p_socket_));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_socket_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Socket.Class, p_class).f_plug_removed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// This signal is emitted when a client is successfully
        /// added to the socket.
        pub const plug_added = struct {
            pub const name = "plug-added";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Socket, p_instance))),
                    gobject.signalLookup("plug-added", Socket.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when a client is removed from the socket.
        /// The default action is to destroy the `gtk.Socket` widget, so if you
        /// want to reuse it you must add a signal handler that returns `TRUE`.
        pub const plug_removed = struct {
            pub const name = "plug-removed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Socket, p_instance))),
                    gobject.signalLookup("plug-removed", Socket.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Create a new empty `gtk.Socket`.
    extern fn gtk_socket_new() *gtk.Socket;
    pub const new = gtk_socket_new;

    /// Adds an XEMBED client, such as a `gtk.Plug`, to the `gtk.Socket`.  The
    /// client may be in the same process or in a different process.
    ///
    /// To embed a `gtk.Plug` in a `gtk.Socket`, you can either create the
    /// `gtk.Plug` with `gtk_plug_new (0)`, call
    /// `gtk.Plug.getId` to get the window ID of the plug, and then pass that to the
    /// `gtk.Socket.addId`, or you can call `gtk.Socket.getId` to get the
    /// window ID for the socket, and call `gtk.Plug.new` passing in that
    /// ID.
    ///
    /// The `gtk.Socket` must have already be added into a toplevel window
    ///  before you can make this call.
    extern fn gtk_socket_add_id(p_socket_: *Socket, p_window: xlib.Window) void;
    pub const addId = gtk_socket_add_id;

    /// Gets the window ID of a `gtk.Socket` widget, which can then
    /// be used to create a client embedded inside the socket, for
    /// instance with `gtk.Plug.new`.
    ///
    /// The `gtk.Socket` must have already be added into a toplevel window
    /// before you can make this call.
    extern fn gtk_socket_get_id(p_socket_: *Socket) xlib.Window;
    pub const getId = gtk_socket_get_id;

    /// Retrieves the window of the plug. Use this to check if the plug has
    /// been created inside of the socket.
    extern fn gtk_socket_get_plug_window(p_socket_: *Socket) ?*gdk.Window;
    pub const getPlugWindow = gtk_socket_get_plug_window;

    extern fn gtk_socket_get_type() usize;
    pub const getGObjectType = gtk_socket_get_type;

    extern fn g_object_ref(p_self: *gtk.Socket) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Socket) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Socket, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SocketAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{atk.Component};
    pub const Class = gtk.SocketAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.SocketAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_socket_accessible_embed(p_socket: *SocketAccessible, p_path: [*:0]u8) void;
    pub const embed = gtk_socket_accessible_embed;

    extern fn gtk_socket_accessible_get_type() usize;
    pub const getGObjectType = gtk_socket_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.SocketAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.SocketAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SocketAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.SpinButton` is an ideal way to allow the user to set the value of
/// some attribute. Rather than having to directly type a number into a
/// `gtk.Entry`, GtkSpinButton allows the user to click on one of two arrows
/// to increment or decrement the displayed value. A value can still be
/// typed in, with the bonus that it can be checked to ensure it is in a
/// given range.
///
/// The main properties of a GtkSpinButton are through an adjustment.
/// See the `gtk.Adjustment` section for more details about an adjustment's
/// properties. Note that GtkSpinButton will by default make its entry
/// large enough to accomodate the lower and upper bounds of the adjustment,
/// which can lead to surprising results. Best practice is to set both
/// the `gtk.Entry.properties.width`-chars and `gtk.Entry.properties.max`-width-chars poperties
/// to the desired number of characters to display in the entry.
///
/// # CSS nodes
///
/// ```
/// spinbutton.horizontal
/// ├── undershoot.left
/// ├── undershoot.right
/// ├── entry
/// │   ╰── ...
/// ├── button.down
/// ╰── button.up
/// ```
///
/// ```
/// spinbutton.vertical
/// ├── undershoot.left
/// ├── undershoot.right
/// ├── button.up
/// ├── entry
/// │   ╰── ...
/// ╰── button.down
/// ```
///
/// GtkSpinButtons main CSS node has the name spinbutton. It creates subnodes
/// for the entry and the two buttons, with these names. The button nodes have
/// the style classes .up and .down. The GtkEntry subnodes (if present) are put
/// below the entry node. The orientation of the spin button is reflected in
/// the .vertical or .horizontal style class on the main node.
///
/// ## Using a GtkSpinButton to get an integer
///
/// ```
/// // Provides a function to retrieve an integer value from a GtkSpinButton
/// // and creates a spin button to model percentage values.
///
/// gint
/// grab_int_value (GtkSpinButton *button,
///                 gpointer       user_data)
/// {
///   return gtk_spin_button_get_value_as_int (button);
/// }
///
/// void
/// create_integer_spin_button (void)
/// {
///
///   GtkWidget *window, *button;
///   GtkAdjustment *adjustment;
///
///   adjustment = gtk_adjustment_new (50.0, 0.0, 100.0, 1.0, 5.0, 0.0);
///
///   window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
///   gtk_container_set_border_width (GTK_CONTAINER (window), 5);
///
///   // creates the spinbutton, with no decimal places
///   button = gtk_spin_button_new (adjustment, 1.0, 0);
///   gtk_container_add (GTK_CONTAINER (window), button);
///
///   gtk_widget_show_all (window);
/// }
/// ```
///
/// ## Using a GtkSpinButton to get a floating point value
///
/// ```
/// // Provides a function to retrieve a floating point value from a
/// // GtkSpinButton, and creates a high precision spin button.
///
/// gfloat
/// grab_float_value (GtkSpinButton *button,
///                   gpointer       user_data)
/// {
///   return gtk_spin_button_get_value (button);
/// }
///
/// void
/// create_floating_spin_button (void)
/// {
///   GtkWidget *window, *button;
///   GtkAdjustment *adjustment;
///
///   adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);
///
///   window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
///   gtk_container_set_border_width (GTK_CONTAINER (window), 5);
///
///   // creates the spinbutton, with three decimal places
///   button = gtk_spin_button_new (adjustment, 0.001, 3);
///   gtk_container_add (GTK_CONTAINER (window), button);
///
///   gtk_widget_show_all (window);
/// }
/// ```
pub const SpinButton = extern struct {
    pub const Parent = gtk.Entry;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.CellEditable, gtk.Editable, gtk.Orientable };
    pub const Class = gtk.SpinButtonClass;
    f_entry: gtk.Entry,
    f_priv: ?*gtk.SpinButtonPrivate,

    pub const virtual_methods = struct {
        pub const change_value = struct {
            pub fn call(p_class: anytype, p_spin_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_scroll: gtk.ScrollType) void {
                return gobject.ext.as(SpinButton.Class, p_class).f_change_value.?(gobject.ext.as(SpinButton, p_spin_button), p_scroll);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_spin_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_scroll: gtk.ScrollType) callconv(.c) void) void {
                gobject.ext.as(SpinButton.Class, p_class).f_change_value = @ptrCast(p_implementation);
            }
        };

        pub const input = struct {
            pub fn call(p_class: anytype, p_spin_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_new_value: *f64) c_int {
                return gobject.ext.as(SpinButton.Class, p_class).f_input.?(gobject.ext.as(SpinButton, p_spin_button), p_new_value);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_spin_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_new_value: *f64) callconv(.c) c_int) void {
                gobject.ext.as(SpinButton.Class, p_class).f_input = @ptrCast(p_implementation);
            }
        };

        pub const output = struct {
            pub fn call(p_class: anytype, p_spin_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(SpinButton.Class, p_class).f_output.?(gobject.ext.as(SpinButton, p_spin_button));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_spin_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(SpinButton.Class, p_class).f_output = @ptrCast(p_implementation);
            }
        };

        pub const value_changed = struct {
            pub fn call(p_class: anytype, p_spin_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(SpinButton.Class, p_class).f_value_changed.?(gobject.ext.as(SpinButton, p_spin_button));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_spin_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(SpinButton.Class, p_class).f_value_changed = @ptrCast(p_implementation);
            }
        };

        pub const wrapped = struct {
            pub fn call(p_class: anytype, p_spin_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(SpinButton.Class, p_class).f_wrapped.?(gobject.ext.as(SpinButton, p_spin_button));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_spin_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(SpinButton.Class, p_class).f_wrapped = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const adjustment = struct {
            pub const name = "adjustment";

            pub const Type = ?*gtk.Adjustment;
        };

        pub const climb_rate = struct {
            pub const name = "climb-rate";

            pub const Type = f64;
        };

        pub const digits = struct {
            pub const name = "digits";

            pub const Type = c_uint;
        };

        pub const numeric = struct {
            pub const name = "numeric";

            pub const Type = c_int;
        };

        pub const snap_to_ticks = struct {
            pub const name = "snap-to-ticks";

            pub const Type = c_int;
        };

        pub const update_policy = struct {
            pub const name = "update-policy";

            pub const Type = gtk.SpinButtonUpdatePolicy;
        };

        pub const value = struct {
            pub const name = "value";

            pub const Type = f64;
        };

        pub const wrap = struct {
            pub const name = "wrap";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::change-value signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user initiates a value change.
        ///
        /// Applications should not connect to it, but may emit it with
        /// `gobject.signalEmitByName` if they need to control the cursor
        /// programmatically.
        ///
        /// The default bindings for this signal are Up/Down and PageUp and/PageDown.
        pub const change_value = struct {
            pub const name = "change-value";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_scroll: gtk.ScrollType, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(SpinButton, p_instance))),
                    gobject.signalLookup("change-value", SpinButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::input signal can be used to influence the conversion of
        /// the users input into a double value. The signal handler is
        /// expected to use `gtk.Entry.getText` to retrieve the text of
        /// the entry and set `new_value` to the new value.
        ///
        /// The default conversion uses `glib.strtod`.
        pub const input = struct {
            pub const name = "input";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_new_value: *f64, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(SpinButton, p_instance))),
                    gobject.signalLookup("input", SpinButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::output signal can be used to change to formatting
        /// of the value that is displayed in the spin buttons entry.
        /// ```
        /// // show leading zeros
        /// static gboolean
        /// on_output (GtkSpinButton *spin,
        ///            gpointer       data)
        /// {
        ///    GtkAdjustment *adjustment;
        ///    gchar *text;
        ///    int value;
        ///
        ///    adjustment = gtk_spin_button_get_adjustment (spin);
        ///    value = (int)gtk_adjustment_get_value (adjustment);
        ///    text = g_strdup_printf ("`@"02d"`", value);
        ///    gtk_entry_set_text (GTK_ENTRY (spin), text);
        ///    g_free (text);
        ///
        ///    return TRUE;
        /// }
        /// ```
        pub const output = struct {
            pub const name = "output";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(SpinButton, p_instance))),
                    gobject.signalLookup("output", SpinButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::value-changed signal is emitted when the value represented by
        /// `spinbutton` changes. Also see the `gtk.SpinButton.signals.output` signal.
        pub const value_changed = struct {
            pub const name = "value-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(SpinButton, p_instance))),
                    gobject.signalLookup("value-changed", SpinButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::wrapped signal is emitted right after the spinbutton wraps
        /// from its maximum to minimum value or vice-versa.
        pub const wrapped = struct {
            pub const name = "wrapped";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(SpinButton, p_instance))),
                    gobject.signalLookup("wrapped", SpinButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.SpinButton`.
    extern fn gtk_spin_button_new(p_adjustment: ?*gtk.Adjustment, p_climb_rate: f64, p_digits: c_uint) *gtk.SpinButton;
    pub const new = gtk_spin_button_new;

    /// This is a convenience constructor that allows creation of a numeric
    /// `gtk.SpinButton` without manually creating an adjustment. The value is
    /// initially set to the minimum value and a page increment of 10 * `step`
    /// is the default. The precision of the spin button is equivalent to the
    /// precision of `step`.
    ///
    /// Note that the way in which the precision is derived works best if `step`
    /// is a power of ten. If the resulting precision is not suitable for your
    /// needs, use `gtk.SpinButton.setDigits` to correct it.
    extern fn gtk_spin_button_new_with_range(p_min: f64, p_max: f64, p_step: f64) *gtk.SpinButton;
    pub const newWithRange = gtk_spin_button_new_with_range;

    /// Changes the properties of an existing spin button. The adjustment,
    /// climb rate, and number of decimal places are updated accordingly.
    extern fn gtk_spin_button_configure(p_spin_button: *SpinButton, p_adjustment: ?*gtk.Adjustment, p_climb_rate: f64, p_digits: c_uint) void;
    pub const configure = gtk_spin_button_configure;

    /// Get the adjustment associated with a `gtk.SpinButton`
    extern fn gtk_spin_button_get_adjustment(p_spin_button: *SpinButton) *gtk.Adjustment;
    pub const getAdjustment = gtk_spin_button_get_adjustment;

    /// Fetches the precision of `spin_button`. See `gtk.SpinButton.setDigits`.
    extern fn gtk_spin_button_get_digits(p_spin_button: *SpinButton) c_uint;
    pub const getDigits = gtk_spin_button_get_digits;

    /// Gets the current step and page the increments used by `spin_button`. See
    /// `gtk.SpinButton.setIncrements`.
    extern fn gtk_spin_button_get_increments(p_spin_button: *SpinButton, p_step: ?*f64, p_page: ?*f64) void;
    pub const getIncrements = gtk_spin_button_get_increments;

    /// Returns whether non-numeric text can be typed into the spin button.
    /// See `gtk.SpinButton.setNumeric`.
    extern fn gtk_spin_button_get_numeric(p_spin_button: *SpinButton) c_int;
    pub const getNumeric = gtk_spin_button_get_numeric;

    /// Gets the range allowed for `spin_button`.
    /// See `gtk.SpinButton.setRange`.
    extern fn gtk_spin_button_get_range(p_spin_button: *SpinButton, p_min: ?*f64, p_max: ?*f64) void;
    pub const getRange = gtk_spin_button_get_range;

    /// Returns whether the values are corrected to the nearest step.
    /// See `gtk.SpinButton.setSnapToTicks`.
    extern fn gtk_spin_button_get_snap_to_ticks(p_spin_button: *SpinButton) c_int;
    pub const getSnapToTicks = gtk_spin_button_get_snap_to_ticks;

    /// Gets the update behavior of a spin button.
    /// See `gtk.SpinButton.setUpdatePolicy`.
    extern fn gtk_spin_button_get_update_policy(p_spin_button: *SpinButton) gtk.SpinButtonUpdatePolicy;
    pub const getUpdatePolicy = gtk_spin_button_get_update_policy;

    /// Get the value in the `spin_button`.
    extern fn gtk_spin_button_get_value(p_spin_button: *SpinButton) f64;
    pub const getValue = gtk_spin_button_get_value;

    /// Get the value `spin_button` represented as an integer.
    extern fn gtk_spin_button_get_value_as_int(p_spin_button: *SpinButton) c_int;
    pub const getValueAsInt = gtk_spin_button_get_value_as_int;

    /// Returns whether the spin button’s value wraps around to the
    /// opposite limit when the upper or lower limit of the range is
    /// exceeded. See `gtk.SpinButton.setWrap`.
    extern fn gtk_spin_button_get_wrap(p_spin_button: *SpinButton) c_int;
    pub const getWrap = gtk_spin_button_get_wrap;

    /// Replaces the `gtk.Adjustment` associated with `spin_button`.
    extern fn gtk_spin_button_set_adjustment(p_spin_button: *SpinButton, p_adjustment: *gtk.Adjustment) void;
    pub const setAdjustment = gtk_spin_button_set_adjustment;

    /// Set the precision to be displayed by `spin_button`. Up to 20 digit precision
    /// is allowed.
    extern fn gtk_spin_button_set_digits(p_spin_button: *SpinButton, p_digits: c_uint) void;
    pub const setDigits = gtk_spin_button_set_digits;

    /// Sets the step and page increments for spin_button.  This affects how
    /// quickly the value changes when the spin button’s arrows are activated.
    extern fn gtk_spin_button_set_increments(p_spin_button: *SpinButton, p_step: f64, p_page: f64) void;
    pub const setIncrements = gtk_spin_button_set_increments;

    /// Sets the flag that determines if non-numeric text can be typed
    /// into the spin button.
    extern fn gtk_spin_button_set_numeric(p_spin_button: *SpinButton, p_numeric: c_int) void;
    pub const setNumeric = gtk_spin_button_set_numeric;

    /// Sets the minimum and maximum allowable values for `spin_button`.
    ///
    /// If the current value is outside this range, it will be adjusted
    /// to fit within the range, otherwise it will remain unchanged.
    extern fn gtk_spin_button_set_range(p_spin_button: *SpinButton, p_min: f64, p_max: f64) void;
    pub const setRange = gtk_spin_button_set_range;

    /// Sets the policy as to whether values are corrected to the
    /// nearest step increment when a spin button is activated after
    /// providing an invalid value.
    extern fn gtk_spin_button_set_snap_to_ticks(p_spin_button: *SpinButton, p_snap_to_ticks: c_int) void;
    pub const setSnapToTicks = gtk_spin_button_set_snap_to_ticks;

    /// Sets the update behavior of a spin button.
    /// This determines whether the spin button is always updated
    /// or only when a valid value is set.
    extern fn gtk_spin_button_set_update_policy(p_spin_button: *SpinButton, p_policy: gtk.SpinButtonUpdatePolicy) void;
    pub const setUpdatePolicy = gtk_spin_button_set_update_policy;

    /// Sets the value of `spin_button`.
    extern fn gtk_spin_button_set_value(p_spin_button: *SpinButton, p_value: f64) void;
    pub const setValue = gtk_spin_button_set_value;

    /// Sets the flag that determines if a spin button value wraps
    /// around to the opposite limit when the upper or lower limit
    /// of the range is exceeded.
    extern fn gtk_spin_button_set_wrap(p_spin_button: *SpinButton, p_wrap: c_int) void;
    pub const setWrap = gtk_spin_button_set_wrap;

    /// Increment or decrement a spin button’s value in a specified
    /// direction by a specified amount.
    extern fn gtk_spin_button_spin(p_spin_button: *SpinButton, p_direction: gtk.SpinType, p_increment: f64) void;
    pub const spin = gtk_spin_button_spin;

    /// Manually force an update of the spin button.
    extern fn gtk_spin_button_update(p_spin_button: *SpinButton) void;
    pub const update = gtk_spin_button_update;

    extern fn gtk_spin_button_get_type() usize;
    pub const getGObjectType = gtk_spin_button_get_type;

    extern fn g_object_ref(p_self: *gtk.SpinButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.SpinButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SpinButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SpinButtonAccessible = extern struct {
    pub const Parent = gtk.EntryAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.EditableText, atk.Text, atk.Value };
    pub const Class = gtk.SpinButtonAccessibleClass;
    f_parent: gtk.EntryAccessible,
    f_priv: ?*gtk.SpinButtonAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_spin_button_accessible_get_type() usize;
    pub const getGObjectType = gtk_spin_button_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.SpinButtonAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.SpinButtonAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SpinButtonAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkSpinner widget displays an icon-size spinning animation.
/// It is often used as an alternative to a `gtk.ProgressBar` for
/// displaying indefinite activity, instead of actual progress.
///
/// To start the animation, use `gtk.Spinner.start`, to stop it
/// use `gtk.Spinner.stop`.
///
/// # CSS nodes
///
/// GtkSpinner has a single CSS node with the name spinner. When the animation is
/// active, the :checked pseudoclass is added to this node.
pub const Spinner = extern struct {
    pub const Parent = gtk.Widget;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.SpinnerClass;
    f_parent: gtk.Widget,
    f_priv: ?*gtk.SpinnerPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const active = struct {
            pub const name = "active";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Returns a new spinner widget. Not yet started.
    extern fn gtk_spinner_new() *gtk.Spinner;
    pub const new = gtk_spinner_new;

    /// Starts the animation of the spinner.
    extern fn gtk_spinner_start(p_spinner: *Spinner) void;
    pub const start = gtk_spinner_start;

    /// Stops the animation of the spinner.
    extern fn gtk_spinner_stop(p_spinner: *Spinner) void;
    pub const stop = gtk_spinner_stop;

    extern fn gtk_spinner_get_type() usize;
    pub const getGObjectType = gtk_spinner_get_type;

    extern fn g_object_ref(p_self: *gtk.Spinner) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Spinner) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Spinner, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SpinnerAccessible = extern struct {
    pub const Parent = gtk.WidgetAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Image };
    pub const Class = gtk.SpinnerAccessibleClass;
    f_parent: gtk.WidgetAccessible,
    f_priv: ?*gtk.SpinnerAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_spinner_accessible_get_type() usize;
    pub const getGObjectType = gtk_spinner_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.SpinnerAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.SpinnerAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SpinnerAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The GtkStack widget is a container which only shows
/// one of its children at a time. In contrast to GtkNotebook,
/// GtkStack does not provide a means for users to change the
/// visible child. Instead, the `gtk.StackSwitcher` widget can be
/// used with GtkStack to provide this functionality.
///
/// Transitions between pages can be animated as slides or
/// fades. This can be controlled with `gtk.Stack.setTransitionType`.
/// These animations respect the `gtk.Settings.properties.gtk`-enable-animations
/// setting.
///
/// The GtkStack widget was added in GTK+ 3.10.
///
/// # CSS nodes
///
/// GtkStack has a single CSS node named stack.
pub const Stack = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.StackClass;
    f_parent_instance: gtk.Container,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// `TRUE` if the stack allocates the same width for all children.
        pub const hhomogeneous = struct {
            pub const name = "hhomogeneous";

            pub const Type = c_int;
        };

        pub const homogeneous = struct {
            pub const name = "homogeneous";

            pub const Type = c_int;
        };

        pub const interpolate_size = struct {
            pub const name = "interpolate-size";

            pub const Type = c_int;
        };

        pub const transition_duration = struct {
            pub const name = "transition-duration";

            pub const Type = c_uint;
        };

        pub const transition_running = struct {
            pub const name = "transition-running";

            pub const Type = c_int;
        };

        pub const transition_type = struct {
            pub const name = "transition-type";

            pub const Type = gtk.StackTransitionType;
        };

        /// `TRUE` if the stack allocates the same height for all children.
        pub const vhomogeneous = struct {
            pub const name = "vhomogeneous";

            pub const Type = c_int;
        };

        pub const visible_child = struct {
            pub const name = "visible-child";

            pub const Type = ?*gtk.Widget;
        };

        pub const visible_child_name = struct {
            pub const name = "visible-child-name";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.Stack` container.
    extern fn gtk_stack_new() *gtk.Stack;
    pub const new = gtk_stack_new;

    /// Adds a child to `stack`.
    /// The child is identified by the `name`.
    extern fn gtk_stack_add_named(p_stack: *Stack, p_child: *gtk.Widget, p_name: [*:0]const u8) void;
    pub const addNamed = gtk_stack_add_named;

    /// Adds a child to `stack`.
    /// The child is identified by the `name`. The `title`
    /// will be used by `gtk.StackSwitcher` to represent
    /// `child` in a tab bar, so it should be short.
    extern fn gtk_stack_add_titled(p_stack: *Stack, p_child: *gtk.Widget, p_name: [*:0]const u8, p_title: [*:0]const u8) void;
    pub const addTitled = gtk_stack_add_titled;

    /// Finds the child of the `gtk.Stack` with the name given as
    /// the argument. Returns `NULL` if there is no child with this
    /// name.
    extern fn gtk_stack_get_child_by_name(p_stack: *Stack, p_name: [*:0]const u8) ?*gtk.Widget;
    pub const getChildByName = gtk_stack_get_child_by_name;

    /// Gets whether `stack` is horizontally homogeneous.
    /// See `gtk.Stack.setHhomogeneous`.
    extern fn gtk_stack_get_hhomogeneous(p_stack: *Stack) c_int;
    pub const getHhomogeneous = gtk_stack_get_hhomogeneous;

    /// Gets whether `stack` is homogeneous.
    /// See `gtk.Stack.setHomogeneous`.
    extern fn gtk_stack_get_homogeneous(p_stack: *Stack) c_int;
    pub const getHomogeneous = gtk_stack_get_homogeneous;

    /// Returns wether the `gtk.Stack` is set up to interpolate between
    /// the sizes of children on page switch.
    extern fn gtk_stack_get_interpolate_size(p_stack: *Stack) c_int;
    pub const getInterpolateSize = gtk_stack_get_interpolate_size;

    /// Returns the amount of time (in milliseconds) that
    /// transitions between pages in `stack` will take.
    extern fn gtk_stack_get_transition_duration(p_stack: *Stack) c_uint;
    pub const getTransitionDuration = gtk_stack_get_transition_duration;

    /// Returns whether the `stack` is currently in a transition from one page to
    /// another.
    extern fn gtk_stack_get_transition_running(p_stack: *Stack) c_int;
    pub const getTransitionRunning = gtk_stack_get_transition_running;

    /// Gets the type of animation that will be used
    /// for transitions between pages in `stack`.
    extern fn gtk_stack_get_transition_type(p_stack: *Stack) gtk.StackTransitionType;
    pub const getTransitionType = gtk_stack_get_transition_type;

    /// Gets whether `stack` is vertically homogeneous.
    /// See `gtk.Stack.setVhomogeneous`.
    extern fn gtk_stack_get_vhomogeneous(p_stack: *Stack) c_int;
    pub const getVhomogeneous = gtk_stack_get_vhomogeneous;

    /// Gets the currently visible child of `stack`, or `NULL` if
    /// there are no visible children.
    extern fn gtk_stack_get_visible_child(p_stack: *Stack) ?*gtk.Widget;
    pub const getVisibleChild = gtk_stack_get_visible_child;

    /// Returns the name of the currently visible child of `stack`, or
    /// `NULL` if there is no visible child.
    extern fn gtk_stack_get_visible_child_name(p_stack: *Stack) ?[*:0]const u8;
    pub const getVisibleChildName = gtk_stack_get_visible_child_name;

    /// Sets the `gtk.Stack` to be horizontally homogeneous or not.
    /// If it is homogeneous, the `gtk.Stack` will request the same
    /// width for all its children. If it isn't, the stack
    /// may change width when a different child becomes visible.
    extern fn gtk_stack_set_hhomogeneous(p_stack: *Stack, p_hhomogeneous: c_int) void;
    pub const setHhomogeneous = gtk_stack_set_hhomogeneous;

    /// Sets the `gtk.Stack` to be homogeneous or not. If it
    /// is homogeneous, the `gtk.Stack` will request the same
    /// size for all its children. If it isn't, the stack
    /// may change size when a different child becomes visible.
    ///
    /// Since 3.16, homogeneity can be controlled separately
    /// for horizontal and vertical size, with the
    /// `gtk.Stack.properties.hhomogeneous` and `gtk.Stack.properties.vhomogeneous`.
    extern fn gtk_stack_set_homogeneous(p_stack: *Stack, p_homogeneous: c_int) void;
    pub const setHomogeneous = gtk_stack_set_homogeneous;

    /// Sets whether or not `stack` will interpolate its size when
    /// changing the visible child. If the `gtk.Stack.properties.interpolate`-size
    /// property is set to `TRUE`, `stack` will interpolate its size between
    /// the current one and the one it'll take after changing the
    /// visible child, according to the set transition duration.
    extern fn gtk_stack_set_interpolate_size(p_stack: *Stack, p_interpolate_size: c_int) void;
    pub const setInterpolateSize = gtk_stack_set_interpolate_size;

    /// Sets the duration that transitions between pages in `stack`
    /// will take.
    extern fn gtk_stack_set_transition_duration(p_stack: *Stack, p_duration: c_uint) void;
    pub const setTransitionDuration = gtk_stack_set_transition_duration;

    /// Sets the type of animation that will be used for
    /// transitions between pages in `stack`. Available
    /// types include various kinds of fades and slides.
    ///
    /// The transition type can be changed without problems
    /// at runtime, so it is possible to change the animation
    /// based on the page that is about to become current.
    extern fn gtk_stack_set_transition_type(p_stack: *Stack, p_transition: gtk.StackTransitionType) void;
    pub const setTransitionType = gtk_stack_set_transition_type;

    /// Sets the `gtk.Stack` to be vertically homogeneous or not.
    /// If it is homogeneous, the `gtk.Stack` will request the same
    /// height for all its children. If it isn't, the stack
    /// may change height when a different child becomes visible.
    extern fn gtk_stack_set_vhomogeneous(p_stack: *Stack, p_vhomogeneous: c_int) void;
    pub const setVhomogeneous = gtk_stack_set_vhomogeneous;

    /// Makes `child` the visible child of `stack`.
    ///
    /// If `child` is different from the currently
    /// visible child, the transition between the
    /// two will be animated with the current
    /// transition type of `stack`.
    ///
    /// Note that the `child` widget has to be visible itself
    /// (see `gtk.Widget.show`) in order to become the visible
    /// child of `stack`.
    extern fn gtk_stack_set_visible_child(p_stack: *Stack, p_child: *gtk.Widget) void;
    pub const setVisibleChild = gtk_stack_set_visible_child;

    /// Makes the child with the given name visible.
    ///
    /// Note that the child widget has to be visible itself
    /// (see `gtk.Widget.show`) in order to become the visible
    /// child of `stack`.
    extern fn gtk_stack_set_visible_child_full(p_stack: *Stack, p_name: [*:0]const u8, p_transition: gtk.StackTransitionType) void;
    pub const setVisibleChildFull = gtk_stack_set_visible_child_full;

    /// Makes the child with the given name visible.
    ///
    /// If `child` is different from the currently
    /// visible child, the transition between the
    /// two will be animated with the current
    /// transition type of `stack`.
    ///
    /// Note that the child widget has to be visible itself
    /// (see `gtk.Widget.show`) in order to become the visible
    /// child of `stack`.
    extern fn gtk_stack_set_visible_child_name(p_stack: *Stack, p_name: [*:0]const u8) void;
    pub const setVisibleChildName = gtk_stack_set_visible_child_name;

    extern fn gtk_stack_get_type() usize;
    pub const getGObjectType = gtk_stack_get_type;

    extern fn g_object_ref(p_self: *gtk.Stack) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Stack) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Stack, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StackAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{atk.Component};
    pub const Class = gtk.StackAccessibleClass;
    f_parent: gtk.ContainerAccessible,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_stack_accessible_get_type() usize;
    pub const getGObjectType = gtk_stack_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.StackAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.StackAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *StackAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkStackSidebar enables you to quickly and easily provide a
/// consistent "sidebar" object for your user interface.
///
/// In order to use a GtkStackSidebar, you simply use a GtkStack to
/// organize your UI flow, and add the sidebar to your sidebar area. You
/// can use `gtk.StackSidebar.setStack` to connect the `gtk.StackSidebar`
/// to the `gtk.Stack`.
///
/// # CSS nodes
///
/// GtkStackSidebar has a single CSS node with name stacksidebar and
/// style class .sidebar.
///
/// When circumstances require it, GtkStackSidebar adds the
/// .needs-attention style class to the widgets representing the stack
/// pages.
pub const StackSidebar = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.StackSidebarClass;
    f_parent: gtk.Bin,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const stack = struct {
            pub const name = "stack";

            pub const Type = ?*gtk.Stack;
        };
    };

    pub const signals = struct {};

    /// Creates a new sidebar.
    extern fn gtk_stack_sidebar_new() *gtk.StackSidebar;
    pub const new = gtk_stack_sidebar_new;

    /// Retrieves the stack.
    /// See `gtk.StackSidebar.setStack`.
    extern fn gtk_stack_sidebar_get_stack(p_sidebar: *StackSidebar) ?*gtk.Stack;
    pub const getStack = gtk_stack_sidebar_get_stack;

    /// Set the `gtk.Stack` associated with this `gtk.StackSidebar`.
    ///
    /// The sidebar widget will automatically update according to the order
    /// (packing) and items within the given `gtk.Stack`.
    extern fn gtk_stack_sidebar_set_stack(p_sidebar: *StackSidebar, p_stack: *gtk.Stack) void;
    pub const setStack = gtk_stack_sidebar_set_stack;

    extern fn gtk_stack_sidebar_get_type() usize;
    pub const getGObjectType = gtk_stack_sidebar_get_type;

    extern fn g_object_ref(p_self: *gtk.StackSidebar) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.StackSidebar) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *StackSidebar, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The GtkStackSwitcher widget acts as a controller for a
/// `gtk.Stack`; it shows a row of buttons to switch between
/// the various pages of the associated stack widget.
///
/// All the content for the buttons comes from the child properties
/// of the `gtk.Stack`; the button visibility in a `gtk.StackSwitcher`
/// widget is controlled by the visibility of the child in the
/// `gtk.Stack`.
///
/// It is possible to associate multiple `gtk.StackSwitcher` widgets
/// with the same `gtk.Stack` widget.
///
/// The GtkStackSwitcher widget was added in 3.10.
///
/// # CSS nodes
///
/// GtkStackSwitcher has a single CSS node named stackswitcher and
/// style class .stack-switcher.
///
/// When circumstances require it, GtkStackSwitcher adds the
/// .needs-attention style class to the widgets representing the
/// stack pages.
pub const StackSwitcher = extern struct {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.StackSwitcherClass;
    f_widget: gtk.Box,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Use the "icon-size" property to change the size of the image displayed
        /// when a `gtk.StackSwitcher` is displaying icons.
        pub const icon_size = struct {
            pub const name = "icon-size";

            pub const Type = c_int;
        };

        pub const stack = struct {
            pub const name = "stack";

            pub const Type = ?*gtk.Stack;
        };
    };

    pub const signals = struct {};

    /// Create a new `gtk.StackSwitcher`.
    extern fn gtk_stack_switcher_new() *gtk.StackSwitcher;
    pub const new = gtk_stack_switcher_new;

    /// Retrieves the stack.
    /// See `gtk.StackSwitcher.setStack`.
    extern fn gtk_stack_switcher_get_stack(p_switcher: *StackSwitcher) ?*gtk.Stack;
    pub const getStack = gtk_stack_switcher_get_stack;

    /// Sets the stack to control.
    extern fn gtk_stack_switcher_set_stack(p_switcher: *StackSwitcher, p_stack: ?*gtk.Stack) void;
    pub const setStack = gtk_stack_switcher_set_stack;

    extern fn gtk_stack_switcher_get_type() usize;
    pub const getGObjectType = gtk_stack_switcher_get_type;

    extern fn g_object_ref(p_self: *gtk.StackSwitcher) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.StackSwitcher) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *StackSwitcher, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The “system tray” or notification area is normally used for transient icons
/// that indicate some special state. For example, a system tray icon might
/// appear to tell the user that they have new mail, or have an incoming instant
/// message, or something along those lines. The basic idea is that creating an
/// icon in the notification area is less annoying than popping up a dialog.
///
/// A `gtk.StatusIcon` object can be used to display an icon in a “system tray”.
/// The icon can have a tooltip, and the user can interact with it by
/// activating it or popping up a context menu.
///
/// It is very important to notice that status icons depend on the existence
/// of a notification area being available to the user; you should not use status
/// icons as the only way to convey critical information regarding your application,
/// as the notification area may not exist on the user's environment, or may have
/// been removed. You should always check that a status icon has been embedded into
/// a notification area by using `gtk.StatusIcon.isEmbedded`, and gracefully
/// recover if the function returns `FALSE`.
///
/// On X11, the implementation follows the
/// [FreeDesktop System Tray Specification](http://www.freedesktop.org/wiki/Specifications/systemtray-spec).
/// Implementations of the “tray” side of this specification can
/// be found e.g. in the GNOME 2 and KDE panel applications.
///
/// Note that a GtkStatusIcon is not a widget, but just a `gobject.Object`. Making it a
/// widget would be impractical, since the system tray on Windows doesn’t allow
/// to embed arbitrary widgets.
///
/// GtkStatusIcon has been deprecated in 3.14. You should consider using
/// notifications or more modern platform-specific APIs instead. GLib provides
/// the `gio.Notification` API which works well with `gtk.Application` on multiple
/// platforms and environments, and should be the preferred mechanism to notify
/// the users of transient status updates. See this [HowDoI](https://wiki.gnome.org/HowDoI/GNotification)
/// for code examples.
pub const StatusIcon = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.StatusIconClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.StatusIconPrivate,

    pub const virtual_methods = struct {
        pub const activate = struct {
            pub fn call(p_class: anytype, p_status_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(StatusIcon.Class, p_class).f_activate.?(gobject.ext.as(StatusIcon, p_status_icon));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_status_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(StatusIcon.Class, p_class).f_activate = @ptrCast(p_implementation);
            }
        };

        pub const button_press_event = struct {
            pub fn call(p_class: anytype, p_status_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventButton) c_int {
                return gobject.ext.as(StatusIcon.Class, p_class).f_button_press_event.?(gobject.ext.as(StatusIcon, p_status_icon), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_status_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventButton) callconv(.c) c_int) void {
                gobject.ext.as(StatusIcon.Class, p_class).f_button_press_event = @ptrCast(p_implementation);
            }
        };

        pub const button_release_event = struct {
            pub fn call(p_class: anytype, p_status_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventButton) c_int {
                return gobject.ext.as(StatusIcon.Class, p_class).f_button_release_event.?(gobject.ext.as(StatusIcon, p_status_icon), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_status_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventButton) callconv(.c) c_int) void {
                gobject.ext.as(StatusIcon.Class, p_class).f_button_release_event = @ptrCast(p_implementation);
            }
        };

        pub const popup_menu = struct {
            pub fn call(p_class: anytype, p_status_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_button: c_uint, p_activate_time: u32) void {
                return gobject.ext.as(StatusIcon.Class, p_class).f_popup_menu.?(gobject.ext.as(StatusIcon, p_status_icon), p_button, p_activate_time);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_status_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_button: c_uint, p_activate_time: u32) callconv(.c) void) void {
                gobject.ext.as(StatusIcon.Class, p_class).f_popup_menu = @ptrCast(p_implementation);
            }
        };

        pub const query_tooltip = struct {
            pub fn call(p_class: anytype, p_status_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_x: c_int, p_y: c_int, p_keyboard_mode: c_int, p_tooltip: *gtk.Tooltip) c_int {
                return gobject.ext.as(StatusIcon.Class, p_class).f_query_tooltip.?(gobject.ext.as(StatusIcon, p_status_icon), p_x, p_y, p_keyboard_mode, p_tooltip);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_status_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_x: c_int, p_y: c_int, p_keyboard_mode: c_int, p_tooltip: *gtk.Tooltip) callconv(.c) c_int) void {
                gobject.ext.as(StatusIcon.Class, p_class).f_query_tooltip = @ptrCast(p_implementation);
            }
        };

        pub const scroll_event = struct {
            pub fn call(p_class: anytype, p_status_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventScroll) c_int {
                return gobject.ext.as(StatusIcon.Class, p_class).f_scroll_event.?(gobject.ext.as(StatusIcon, p_status_icon), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_status_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventScroll) callconv(.c) c_int) void {
                gobject.ext.as(StatusIcon.Class, p_class).f_scroll_event = @ptrCast(p_implementation);
            }
        };

        pub const size_changed = struct {
            pub fn call(p_class: anytype, p_status_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_size: c_int) c_int {
                return gobject.ext.as(StatusIcon.Class, p_class).f_size_changed.?(gobject.ext.as(StatusIcon, p_status_icon), p_size);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_status_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_size: c_int) callconv(.c) c_int) void {
                gobject.ext.as(StatusIcon.Class, p_class).f_size_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// `TRUE` if the statusicon is embedded in a notification area.
        pub const embedded = struct {
            pub const name = "embedded";

            pub const Type = c_int;
        };

        pub const file = struct {
            pub const name = "file";

            pub const Type = ?[*:0]u8;
        };

        /// The `gio.Icon` displayed in the `gtk.StatusIcon`. For themed icons,
        /// the image will be updated automatically if the theme changes.
        pub const gicon = struct {
            pub const name = "gicon";

            pub const Type = ?*gio.Icon;
        };

        /// Enables or disables the emission of `gtk.StatusIcon.signals.query`-tooltip on
        /// `status_icon`.  A value of `TRUE` indicates that `status_icon` can have a
        /// tooltip, in this case the status icon will be queried using
        /// `gtk.StatusIcon.signals.query`-tooltip to determine whether it will provide a
        /// tooltip or not.
        ///
        /// Note that setting this property to `TRUE` for the first time will change
        /// the event masks of the windows of this status icon to include leave-notify
        /// and motion-notify events. This will not be undone when the property is set
        /// to `FALSE` again.
        ///
        /// Whether this property is respected is platform dependent.
        /// For plain text tooltips, use `gtk.StatusIcon.properties.tooltip`-text in preference.
        pub const has_tooltip = struct {
            pub const name = "has-tooltip";

            pub const Type = c_int;
        };

        pub const icon_name = struct {
            pub const name = "icon-name";

            pub const Type = ?[*:0]u8;
        };

        /// The orientation of the tray in which the statusicon
        /// is embedded.
        pub const orientation = struct {
            pub const name = "orientation";

            pub const Type = gtk.Orientation;
        };

        pub const pixbuf = struct {
            pub const name = "pixbuf";

            pub const Type = ?*gdkpixbuf.Pixbuf;
        };

        pub const screen = struct {
            pub const name = "screen";

            pub const Type = ?*gdk.Screen;
        };

        pub const size = struct {
            pub const name = "size";

            pub const Type = c_int;
        };

        pub const stock = struct {
            pub const name = "stock";

            pub const Type = ?[*:0]u8;
        };

        pub const storage_type = struct {
            pub const name = "storage-type";

            pub const Type = gtk.ImageType;
        };

        /// The title of this tray icon. This should be a short, human-readable,
        /// localized string describing the tray icon. It may be used by tools
        /// like screen readers to render the tray icon.
        pub const title = struct {
            pub const name = "title";

            pub const Type = ?[*:0]u8;
        };

        /// Sets the text of tooltip to be the given string, which is marked up
        /// with the [Pango text markup language][PangoMarkupFormat].
        /// Also see `gtk.Tooltip.setMarkup`.
        ///
        /// This is a convenience property which will take care of getting the
        /// tooltip shown if the given string is not `NULL`.
        /// `gtk.StatusIcon.properties.has`-tooltip will automatically be set to `TRUE` and
        /// the default handler for the `gtk.StatusIcon.signals.query`-tooltip signal
        /// will take care of displaying the tooltip.
        ///
        /// On some platforms, embedded markup will be ignored.
        pub const tooltip_markup = struct {
            pub const name = "tooltip-markup";

            pub const Type = ?[*:0]u8;
        };

        /// Sets the text of tooltip to be the given string.
        ///
        /// Also see `gtk.Tooltip.setText`.
        ///
        /// This is a convenience property which will take care of getting the
        /// tooltip shown if the given string is not `NULL`.
        /// `gtk.StatusIcon.properties.has`-tooltip will automatically be set to `TRUE` and
        /// the default handler for the `gtk.StatusIcon.signals.query`-tooltip signal
        /// will take care of displaying the tooltip.
        ///
        /// Note that some platforms have limitations on the length of tooltips
        /// that they allow on status icons, e.g. Windows only shows the first
        /// 64 characters.
        pub const tooltip_text = struct {
            pub const name = "tooltip-text";

            pub const Type = ?[*:0]u8;
        };

        pub const visible = struct {
            pub const name = "visible";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Gets emitted when the user activates the status icon.
        /// If and how status icons can activated is platform-dependent.
        ///
        /// Unlike most G_SIGNAL_ACTION signals, this signal is meant to
        /// be used by applications and should be wrapped by language bindings.
        pub const activate = struct {
            pub const name = "activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(StatusIcon, p_instance))),
                    gobject.signalLookup("activate", StatusIcon.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::button-press-event signal will be emitted when a button
        /// (typically from a mouse) is pressed.
        ///
        /// Whether this event is emitted is platform-dependent.  Use the ::activate
        /// and ::popup-menu signals in preference.
        pub const button_press_event = struct {
            pub const name = "button-press-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventButton, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(StatusIcon, p_instance))),
                    gobject.signalLookup("button-press-event", StatusIcon.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::button-release-event signal will be emitted when a button
        /// (typically from a mouse) is released.
        ///
        /// Whether this event is emitted is platform-dependent.  Use the ::activate
        /// and ::popup-menu signals in preference.
        pub const button_release_event = struct {
            pub const name = "button-release-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventButton, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(StatusIcon, p_instance))),
                    gobject.signalLookup("button-release-event", StatusIcon.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Gets emitted when the user brings up the context menu
        /// of the status icon. Whether status icons can have context
        /// menus and how these are activated is platform-dependent.
        ///
        /// The `button` and `activate_time` parameters should be
        /// passed as the last to arguments to `gtk.Menu.popup`.
        ///
        /// Unlike most G_SIGNAL_ACTION signals, this signal is meant to
        /// be used by applications and should be wrapped by language bindings.
        pub const popup_menu = struct {
            pub const name = "popup-menu";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_button: c_uint, p_activate_time: c_uint, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(StatusIcon, p_instance))),
                    gobject.signalLookup("popup-menu", StatusIcon.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the hover timeout has expired with the
        /// cursor hovering above `status_icon`; or emitted when `status_icon` got
        /// focus in keyboard mode.
        ///
        /// Using the given coordinates, the signal handler should determine
        /// whether a tooltip should be shown for `status_icon`. If this is
        /// the case `TRUE` should be returned, `FALSE` otherwise. Note that if
        /// `keyboard_mode` is `TRUE`, the values of `x` and `y` are undefined and
        /// should not be used.
        ///
        /// The signal handler is free to manipulate `tooltip` with the therefore
        /// destined function calls.
        ///
        /// Whether this signal is emitted is platform-dependent.
        /// For plain text tooltips, use `gtk.StatusIcon.properties.tooltip`-text in preference.
        pub const query_tooltip = struct {
            pub const name = "query-tooltip";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_x: c_int, p_y: c_int, p_keyboard_mode: c_int, p_tooltip: *gtk.Tooltip, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(StatusIcon, p_instance))),
                    gobject.signalLookup("query-tooltip", StatusIcon.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::scroll-event signal is emitted when a button in the 4 to 7
        /// range is pressed. Wheel mice are usually configured to generate
        /// button press events for buttons 4 and 5 when the wheel is turned.
        ///
        /// Whether this event is emitted is platform-dependent.
        pub const scroll_event = struct {
            pub const name = "scroll-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventScroll, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(StatusIcon, p_instance))),
                    gobject.signalLookup("scroll-event", StatusIcon.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Gets emitted when the size available for the image
        /// changes, e.g. because the notification area got resized.
        pub const size_changed = struct {
            pub const name = "size-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_size: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(StatusIcon, p_instance))),
                    gobject.signalLookup("size-changed", StatusIcon.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Menu positioning function to use with `gtk.Menu.popup`
    /// to position `menu` aligned to the status icon `user_data`.
    extern fn gtk_status_icon_position_menu(p_menu: *gtk.Menu, p_x: *c_int, p_y: *c_int, p_push_in: *c_int, p_user_data: *gtk.StatusIcon) void;
    pub const positionMenu = gtk_status_icon_position_menu;

    /// Creates an empty status icon object.
    extern fn gtk_status_icon_new() *gtk.StatusIcon;
    pub const new = gtk_status_icon_new;

    /// Creates a status icon displaying the file `filename`.
    ///
    /// The image will be scaled down to fit in the available
    /// space in the notification area, if necessary.
    extern fn gtk_status_icon_new_from_file(p_filename: [*:0]const u8) *gtk.StatusIcon;
    pub const newFromFile = gtk_status_icon_new_from_file;

    /// Creates a status icon displaying a `gio.Icon`. If the icon is a
    /// themed icon, it will be updated when the theme changes.
    extern fn gtk_status_icon_new_from_gicon(p_icon: *gio.Icon) *gtk.StatusIcon;
    pub const newFromGicon = gtk_status_icon_new_from_gicon;

    /// Creates a status icon displaying an icon from the current icon theme.
    /// If the current icon theme is changed, the icon will be updated
    /// appropriately.
    extern fn gtk_status_icon_new_from_icon_name(p_icon_name: [*:0]const u8) *gtk.StatusIcon;
    pub const newFromIconName = gtk_status_icon_new_from_icon_name;

    /// Creates a status icon displaying `pixbuf`.
    ///
    /// The image will be scaled down to fit in the available
    /// space in the notification area, if necessary.
    extern fn gtk_status_icon_new_from_pixbuf(p_pixbuf: *gdkpixbuf.Pixbuf) *gtk.StatusIcon;
    pub const newFromPixbuf = gtk_status_icon_new_from_pixbuf;

    /// Creates a status icon displaying a stock icon. Sample stock icon
    /// names are `GTK_STOCK_OPEN`, `GTK_STOCK_QUIT`. You can register your
    /// own stock icon names, see `gtk.IconFactory.addDefault` and
    /// `gtk.IconFactory.add`.
    extern fn gtk_status_icon_new_from_stock(p_stock_id: [*:0]const u8) *gtk.StatusIcon;
    pub const newFromStock = gtk_status_icon_new_from_stock;

    /// Obtains information about the location of the status icon
    /// on screen. This information can be used to e.g. position
    /// popups like notification bubbles.
    ///
    /// See `gtk.StatusIcon.positionMenu` for a more convenient
    /// alternative for positioning menus.
    ///
    /// Note that some platforms do not allow GTK+ to provide
    /// this information, and even on platforms that do allow it,
    /// the information is not reliable unless the status icon
    /// is embedded in a notification area, see
    /// `gtk.StatusIcon.isEmbedded`.
    extern fn gtk_status_icon_get_geometry(p_status_icon: *StatusIcon, p_screen: ?**gdk.Screen, p_area: ?*gdk.Rectangle, p_orientation: ?*gtk.Orientation) c_int;
    pub const getGeometry = gtk_status_icon_get_geometry;

    /// Retrieves the `gio.Icon` being displayed by the `gtk.StatusIcon`.
    /// The storage type of the status icon must be `GTK_IMAGE_EMPTY` or
    /// `GTK_IMAGE_GICON` (see `gtk.StatusIcon.getStorageType`).
    /// The caller of this function does not own a reference to the
    /// returned `gio.Icon`.
    ///
    /// If this function fails, `icon` is left unchanged;
    extern fn gtk_status_icon_get_gicon(p_status_icon: *StatusIcon) ?*gio.Icon;
    pub const getGicon = gtk_status_icon_get_gicon;

    /// Returns the current value of the has-tooltip property.
    /// See `gtk.StatusIcon.properties.has`-tooltip for more information.
    extern fn gtk_status_icon_get_has_tooltip(p_status_icon: *StatusIcon) c_int;
    pub const getHasTooltip = gtk_status_icon_get_has_tooltip;

    /// Gets the name of the icon being displayed by the `gtk.StatusIcon`.
    /// The storage type of the status icon must be `GTK_IMAGE_EMPTY` or
    /// `GTK_IMAGE_ICON_NAME` (see `gtk.StatusIcon.getStorageType`).
    /// The returned string is owned by the `gtk.StatusIcon` and should not
    /// be freed or modified.
    extern fn gtk_status_icon_get_icon_name(p_status_icon: *StatusIcon) ?[*:0]const u8;
    pub const getIconName = gtk_status_icon_get_icon_name;

    /// Gets the `gdkpixbuf.Pixbuf` being displayed by the `gtk.StatusIcon`.
    /// The storage type of the status icon must be `GTK_IMAGE_EMPTY` or
    /// `GTK_IMAGE_PIXBUF` (see `gtk.StatusIcon.getStorageType`).
    /// The caller of this function does not own a reference to the
    /// returned pixbuf.
    extern fn gtk_status_icon_get_pixbuf(p_status_icon: *StatusIcon) ?*gdkpixbuf.Pixbuf;
    pub const getPixbuf = gtk_status_icon_get_pixbuf;

    /// Returns the `gdk.Screen` associated with `status_icon`.
    extern fn gtk_status_icon_get_screen(p_status_icon: *StatusIcon) *gdk.Screen;
    pub const getScreen = gtk_status_icon_get_screen;

    /// Gets the size in pixels that is available for the image.
    /// Stock icons and named icons adapt their size automatically
    /// if the size of the notification area changes. For other
    /// storage types, the size-changed signal can be used to
    /// react to size changes.
    ///
    /// Note that the returned size is only meaningful while the
    /// status icon is embedded (see `gtk.StatusIcon.isEmbedded`).
    extern fn gtk_status_icon_get_size(p_status_icon: *StatusIcon) c_int;
    pub const getSize = gtk_status_icon_get_size;

    /// Gets the id of the stock icon being displayed by the `gtk.StatusIcon`.
    /// The storage type of the status icon must be `GTK_IMAGE_EMPTY` or
    /// `GTK_IMAGE_STOCK` (see `gtk.StatusIcon.getStorageType`).
    /// The returned string is owned by the `gtk.StatusIcon` and should not
    /// be freed or modified.
    extern fn gtk_status_icon_get_stock(p_status_icon: *StatusIcon) ?[*:0]const u8;
    pub const getStock = gtk_status_icon_get_stock;

    /// Gets the type of representation being used by the `gtk.StatusIcon`
    /// to store image data. If the `gtk.StatusIcon` has no image data,
    /// the return value will be `GTK_IMAGE_EMPTY`.
    extern fn gtk_status_icon_get_storage_type(p_status_icon: *StatusIcon) gtk.ImageType;
    pub const getStorageType = gtk_status_icon_get_storage_type;

    /// Gets the title of this tray icon. See `gtk.StatusIcon.setTitle`.
    extern fn gtk_status_icon_get_title(p_status_icon: *StatusIcon) [*:0]const u8;
    pub const getTitle = gtk_status_icon_get_title;

    /// Gets the contents of the tooltip for `status_icon`.
    extern fn gtk_status_icon_get_tooltip_markup(p_status_icon: *StatusIcon) ?[*:0]u8;
    pub const getTooltipMarkup = gtk_status_icon_get_tooltip_markup;

    /// Gets the contents of the tooltip for `status_icon`.
    extern fn gtk_status_icon_get_tooltip_text(p_status_icon: *StatusIcon) ?[*:0]u8;
    pub const getTooltipText = gtk_status_icon_get_tooltip_text;

    /// Returns whether the status icon is visible or not.
    /// Note that being visible does not guarantee that
    /// the user can actually see the icon, see also
    /// `gtk.StatusIcon.isEmbedded`.
    extern fn gtk_status_icon_get_visible(p_status_icon: *StatusIcon) c_int;
    pub const getVisible = gtk_status_icon_get_visible;

    /// This function is only useful on the X11/freedesktop.org platform.
    ///
    /// It returns a window ID for the widget in the underlying
    /// status icon implementation.  This is useful for the Galago
    /// notification service, which can send a window ID in the protocol
    /// in order for the server to position notification windows
    /// pointing to a status icon reliably.
    ///
    /// This function is not intended for other use cases which are
    /// more likely to be met by one of the non-X11 specific methods, such
    /// as `gtk.StatusIcon.positionMenu`.
    extern fn gtk_status_icon_get_x11_window_id(p_status_icon: *StatusIcon) u32;
    pub const getX11WindowId = gtk_status_icon_get_x11_window_id;

    /// Returns whether the status icon is embedded in a notification
    /// area.
    extern fn gtk_status_icon_is_embedded(p_status_icon: *StatusIcon) c_int;
    pub const isEmbedded = gtk_status_icon_is_embedded;

    /// Makes `status_icon` display the file `filename`.
    /// See `gtk.StatusIcon.newFromFile` for details.
    extern fn gtk_status_icon_set_from_file(p_status_icon: *StatusIcon, p_filename: [*:0]const u8) void;
    pub const setFromFile = gtk_status_icon_set_from_file;

    /// Makes `status_icon` display the `gio.Icon`.
    /// See `gtk.StatusIcon.newFromGicon` for details.
    extern fn gtk_status_icon_set_from_gicon(p_status_icon: *StatusIcon, p_icon: *gio.Icon) void;
    pub const setFromGicon = gtk_status_icon_set_from_gicon;

    /// Makes `status_icon` display the icon named `icon_name` from the
    /// current icon theme.
    /// See `gtk.StatusIcon.newFromIconName` for details.
    extern fn gtk_status_icon_set_from_icon_name(p_status_icon: *StatusIcon, p_icon_name: [*:0]const u8) void;
    pub const setFromIconName = gtk_status_icon_set_from_icon_name;

    /// Makes `status_icon` display `pixbuf`.
    /// See `gtk.StatusIcon.newFromPixbuf` for details.
    extern fn gtk_status_icon_set_from_pixbuf(p_status_icon: *StatusIcon, p_pixbuf: ?*gdkpixbuf.Pixbuf) void;
    pub const setFromPixbuf = gtk_status_icon_set_from_pixbuf;

    /// Makes `status_icon` display the stock icon with the id `stock_id`.
    /// See `gtk.StatusIcon.newFromStock` for details.
    extern fn gtk_status_icon_set_from_stock(p_status_icon: *StatusIcon, p_stock_id: [*:0]const u8) void;
    pub const setFromStock = gtk_status_icon_set_from_stock;

    /// Sets the has-tooltip property on `status_icon` to `has_tooltip`.
    /// See `gtk.StatusIcon.properties.has`-tooltip for more information.
    extern fn gtk_status_icon_set_has_tooltip(p_status_icon: *StatusIcon, p_has_tooltip: c_int) void;
    pub const setHasTooltip = gtk_status_icon_set_has_tooltip;

    /// Sets the name of this tray icon.
    /// This should be a string identifying this icon. It is may be
    /// used for sorting the icons in the tray and will not be shown to
    /// the user.
    extern fn gtk_status_icon_set_name(p_status_icon: *StatusIcon, p_name: [*:0]const u8) void;
    pub const setName = gtk_status_icon_set_name;

    /// Sets the `gdk.Screen` where `status_icon` is displayed; if
    /// the icon is already mapped, it will be unmapped, and
    /// then remapped on the new screen.
    extern fn gtk_status_icon_set_screen(p_status_icon: *StatusIcon, p_screen: *gdk.Screen) void;
    pub const setScreen = gtk_status_icon_set_screen;

    /// Sets the title of this tray icon.
    /// This should be a short, human-readable, localized string
    /// describing the tray icon. It may be used by tools like screen
    /// readers to render the tray icon.
    extern fn gtk_status_icon_set_title(p_status_icon: *StatusIcon, p_title: [*:0]const u8) void;
    pub const setTitle = gtk_status_icon_set_title;

    /// Sets `markup` as the contents of the tooltip, which is marked up with
    ///  the [Pango text markup language][PangoMarkupFormat].
    ///
    /// This function will take care of setting `gtk.StatusIcon.properties.has`-tooltip to `TRUE`
    /// and of the default handler for the `gtk.StatusIcon.signals.query`-tooltip signal.
    ///
    /// See also the `gtk.StatusIcon.properties.tooltip`-markup property and
    /// `gtk.Tooltip.setMarkup`.
    extern fn gtk_status_icon_set_tooltip_markup(p_status_icon: *StatusIcon, p_markup: ?[*:0]const u8) void;
    pub const setTooltipMarkup = gtk_status_icon_set_tooltip_markup;

    /// Sets `text` as the contents of the tooltip.
    ///
    /// This function will take care of setting `gtk.StatusIcon.properties.has`-tooltip to
    /// `TRUE` and of the default handler for the `gtk.StatusIcon.signals.query`-tooltip
    /// signal.
    ///
    /// See also the `gtk.StatusIcon.properties.tooltip`-text property and
    /// `gtk.Tooltip.setText`.
    extern fn gtk_status_icon_set_tooltip_text(p_status_icon: *StatusIcon, p_text: [*:0]const u8) void;
    pub const setTooltipText = gtk_status_icon_set_tooltip_text;

    /// Shows or hides a status icon.
    extern fn gtk_status_icon_set_visible(p_status_icon: *StatusIcon, p_visible: c_int) void;
    pub const setVisible = gtk_status_icon_set_visible;

    extern fn gtk_status_icon_get_type() usize;
    pub const getGObjectType = gtk_status_icon_get_type;

    extern fn g_object_ref(p_self: *gtk.StatusIcon) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.StatusIcon) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *StatusIcon, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.Statusbar` is usually placed along the bottom of an application's
/// main `gtk.Window`. It may provide a regular commentary of the application's
/// status (as is usually the case in a web browser, for example), or may be
/// used to simply output a message when the status changes, (when an upload
/// is complete in an FTP client, for example).
///
/// Status bars in GTK+ maintain a stack of messages. The message at
/// the top of the each bar’s stack is the one that will currently be displayed.
///
/// Any messages added to a statusbar’s stack must specify a
/// context id that is used to uniquely identify
/// the source of a message. This context id can be generated by
/// `gtk.Statusbar.getContextId`, given a message and the statusbar that
/// it will be added to. Note that messages are stored in a stack, and when
/// choosing which message to display, the stack structure is adhered to,
/// regardless of the context identifier of a message.
///
/// One could say that a statusbar maintains one stack of messages for
/// display purposes, but allows multiple message producers to maintain
/// sub-stacks of the messages they produced (via context ids).
///
/// Status bars are created using `gtk.Statusbar.new`.
///
/// Messages are added to the bar’s stack with `gtk.Statusbar.push`.
///
/// The message at the top of the stack can be removed using
/// `gtk.Statusbar.pop`. A message can be removed from anywhere in the
/// stack if its message id was recorded at the time it was added. This
/// is done using `gtk.Statusbar.remove`.
///
/// # CSS node
///
/// GtkStatusbar has a single CSS node with name statusbar.
pub const Statusbar = extern struct {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.StatusbarClass;
    f_parent_widget: gtk.Box,
    f_priv: ?*gtk.StatusbarPrivate,

    pub const virtual_methods = struct {
        pub const text_popped = struct {
            pub fn call(p_class: anytype, p_statusbar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context_id: c_uint, p_text: [*:0]const u8) void {
                return gobject.ext.as(Statusbar.Class, p_class).f_text_popped.?(gobject.ext.as(Statusbar, p_statusbar), p_context_id, p_text);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_statusbar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context_id: c_uint, p_text: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(Statusbar.Class, p_class).f_text_popped = @ptrCast(p_implementation);
            }
        };

        pub const text_pushed = struct {
            pub fn call(p_class: anytype, p_statusbar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context_id: c_uint, p_text: [*:0]const u8) void {
                return gobject.ext.as(Statusbar.Class, p_class).f_text_pushed.?(gobject.ext.as(Statusbar, p_statusbar), p_context_id, p_text);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_statusbar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context_id: c_uint, p_text: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(Statusbar.Class, p_class).f_text_pushed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// Is emitted whenever a new message is popped off a statusbar's stack.
        pub const text_popped = struct {
            pub const name = "text-popped";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context_id: c_uint, p_text: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Statusbar, p_instance))),
                    gobject.signalLookup("text-popped", Statusbar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Is emitted whenever a new message gets pushed onto a statusbar's stack.
        pub const text_pushed = struct {
            pub const name = "text-pushed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context_id: c_uint, p_text: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Statusbar, p_instance))),
                    gobject.signalLookup("text-pushed", Statusbar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.Statusbar` ready for messages.
    extern fn gtk_statusbar_new() *gtk.Statusbar;
    pub const new = gtk_statusbar_new;

    /// Returns a new context identifier, given a description
    /// of the actual context. Note that the description is
    /// not shown in the UI.
    extern fn gtk_statusbar_get_context_id(p_statusbar: *Statusbar, p_context_description: [*:0]const u8) c_uint;
    pub const getContextId = gtk_statusbar_get_context_id;

    /// Retrieves the box containing the label widget.
    extern fn gtk_statusbar_get_message_area(p_statusbar: *Statusbar) *gtk.Box;
    pub const getMessageArea = gtk_statusbar_get_message_area;

    /// Removes the first message in the `gtk.Statusbar`’s stack
    /// with the given context id.
    ///
    /// Note that this may not change the displayed message, if
    /// the message at the top of the stack has a different
    /// context id.
    extern fn gtk_statusbar_pop(p_statusbar: *Statusbar, p_context_id: c_uint) void;
    pub const pop = gtk_statusbar_pop;

    /// Pushes a new message onto a statusbar’s stack.
    extern fn gtk_statusbar_push(p_statusbar: *Statusbar, p_context_id: c_uint, p_text: [*:0]const u8) c_uint;
    pub const push = gtk_statusbar_push;

    /// Forces the removal of a message from a statusbar’s stack.
    /// The exact `context_id` and `message_id` must be specified.
    extern fn gtk_statusbar_remove(p_statusbar: *Statusbar, p_context_id: c_uint, p_message_id: c_uint) void;
    pub const remove = gtk_statusbar_remove;

    /// Forces the removal of all messages from a statusbar's
    /// stack with the exact `context_id`.
    extern fn gtk_statusbar_remove_all(p_statusbar: *Statusbar, p_context_id: c_uint) void;
    pub const removeAll = gtk_statusbar_remove_all;

    extern fn gtk_statusbar_get_type() usize;
    pub const getGObjectType = gtk_statusbar_get_type;

    extern fn g_object_ref(p_self: *gtk.Statusbar) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Statusbar) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Statusbar, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StatusbarAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{atk.Component};
    pub const Class = gtk.StatusbarAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.StatusbarAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_statusbar_accessible_get_type() usize;
    pub const getGObjectType = gtk_statusbar_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.StatusbarAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.StatusbarAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *StatusbarAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.Style` object encapsulates the information that provides the look and
/// feel for a widget.
///
/// > In GTK+ 3.0, GtkStyle has been deprecated and replaced by
/// > `gtk.StyleContext`.
///
/// Each `gtk.Widget` has an associated `gtk.Style` object that is used when
/// rendering that widget. Also, a `gtk.Style` holds information for the five
/// possible widget states though not every widget supports all five
/// states; see `gtk.StateType`.
///
/// Usually the `gtk.Style` for a widget is the same as the default style that
/// is set by GTK+ and modified the theme engine.
///
/// Usually applications should not need to use or modify the `gtk.Style` of
/// their widgets.
pub const Style = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.StyleClass;
    f_parent_instance: gobject.Object,
    /// Set of foreground `gdk.Color`
    f_fg: [5]gdk.Color,
    /// Set of background `gdk.Color`
    f_bg: [5]gdk.Color,
    /// Set of light `gdk.Color`
    f_light: [5]gdk.Color,
    /// Set of dark `gdk.Color`
    f_dark: [5]gdk.Color,
    /// Set of mid `gdk.Color`
    f_mid: [5]gdk.Color,
    /// Set of text `gdk.Color`
    f_text: [5]gdk.Color,
    /// Set of base `gdk.Color`
    f_base: [5]gdk.Color,
    /// Color halfway between text/base
    f_text_aa: [5]gdk.Color,
    /// `gdk.Color` to use for black
    f_black: gdk.Color,
    /// `gdk.Color` to use for white
    f_white: gdk.Color,
    /// `pango.FontDescription`
    f_font_desc: ?*pango.FontDescription,
    /// Thickness in X direction
    f_xthickness: c_int,
    /// Thickness in Y direction
    f_ythickness: c_int,
    /// Set of background `cairo.Pattern`
    f_background: [5]*cairo.Pattern,
    f_attach_count: c_int,
    f_visual: ?*gdk.Visual,
    f_private_font_desc: ?*pango.FontDescription,
    f_rc_style: ?*gtk.RcStyle,
    f_styles: ?*glib.SList,
    f_property_cache: ?*glib.Array,
    f_icon_factories: ?*glib.SList,

    pub const virtual_methods = struct {
        pub const clone = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gtk.Style {
                return gobject.ext.as(Style.Class, p_class).f_clone.?(gobject.ext.as(Style, p_style));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gtk.Style) void {
                gobject.ext.as(Style.Class, p_class).f_clone = @ptrCast(p_implementation);
            }
        };

        pub const copy = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_src: *gtk.Style) void {
                return gobject.ext.as(Style.Class, p_class).f_copy.?(gobject.ext.as(Style, p_style), p_src);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_src: *gtk.Style) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_copy = @ptrCast(p_implementation);
            }
        };

        pub const draw_arrow = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_arrow_type: gtk.ArrowType, p_fill: c_int, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_arrow.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_shadow_type, p_widget, p_detail, p_arrow_type, p_fill, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_arrow_type: gtk.ArrowType, p_fill: c_int, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_arrow = @ptrCast(p_implementation);
            }
        };

        pub const draw_box = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_box.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_shadow_type, p_widget, p_detail, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_box = @ptrCast(p_implementation);
            }
        };

        pub const draw_box_gap = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_gap_side: gtk.PositionType, p_gap_x: c_int, p_gap_width: c_int) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_box_gap.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_shadow_type, p_widget, p_detail, p_x, p_y, p_width, p_height, p_gap_side, p_gap_x, p_gap_width);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_gap_side: gtk.PositionType, p_gap_x: c_int, p_gap_width: c_int) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_box_gap = @ptrCast(p_implementation);
            }
        };

        pub const draw_check = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_check.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_shadow_type, p_widget, p_detail, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_check = @ptrCast(p_implementation);
            }
        };

        pub const draw_diamond = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_diamond.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_shadow_type, p_widget, p_detail, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_diamond = @ptrCast(p_implementation);
            }
        };

        pub const draw_expander = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_expander_style: gtk.ExpanderStyle) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_expander.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_widget, p_detail, p_x, p_y, p_expander_style);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_expander_style: gtk.ExpanderStyle) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_expander = @ptrCast(p_implementation);
            }
        };

        pub const draw_extension = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_gap_side: gtk.PositionType) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_extension.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_shadow_type, p_widget, p_detail, p_x, p_y, p_width, p_height, p_gap_side);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_gap_side: gtk.PositionType) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_extension = @ptrCast(p_implementation);
            }
        };

        pub const draw_flat_box = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_flat_box.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_shadow_type, p_widget, p_detail, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_flat_box = @ptrCast(p_implementation);
            }
        };

        pub const draw_focus = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_focus.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_widget, p_detail, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_focus = @ptrCast(p_implementation);
            }
        };

        pub const draw_handle = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_orientation: gtk.Orientation) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_handle.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_shadow_type, p_widget, p_detail, p_x, p_y, p_width, p_height, p_orientation);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_orientation: gtk.Orientation) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_handle = @ptrCast(p_implementation);
            }
        };

        pub const draw_hline = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x1: c_int, p_x2: c_int, p_y: c_int) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_hline.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_widget, p_detail, p_x1, p_x2, p_y);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x1: c_int, p_x2: c_int, p_y: c_int) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_hline = @ptrCast(p_implementation);
            }
        };

        pub const draw_layout = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_use_text: c_int, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_layout: *pango.Layout) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_layout.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_use_text, p_widget, p_detail, p_x, p_y, p_layout);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_use_text: c_int, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_layout: *pango.Layout) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_layout = @ptrCast(p_implementation);
            }
        };

        pub const draw_option = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_option.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_shadow_type, p_widget, p_detail, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_option = @ptrCast(p_implementation);
            }
        };

        pub const draw_resize_grip = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_edge: gdk.WindowEdge, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_resize_grip.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_widget, p_detail, p_edge, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_edge: gdk.WindowEdge, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_resize_grip = @ptrCast(p_implementation);
            }
        };

        pub const draw_shadow = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_shadow.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_shadow_type, p_widget, p_detail, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_shadow = @ptrCast(p_implementation);
            }
        };

        pub const draw_shadow_gap = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_gap_side: gtk.PositionType, p_gap_x: c_int, p_gap_width: c_int) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_shadow_gap.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_shadow_type, p_widget, p_detail, p_x, p_y, p_width, p_height, p_gap_side, p_gap_x, p_gap_width);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_gap_side: gtk.PositionType, p_gap_x: c_int, p_gap_width: c_int) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_shadow_gap = @ptrCast(p_implementation);
            }
        };

        pub const draw_slider = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_orientation: gtk.Orientation) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_slider.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_shadow_type, p_widget, p_detail, p_x, p_y, p_width, p_height, p_orientation);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_orientation: gtk.Orientation) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_slider = @ptrCast(p_implementation);
            }
        };

        pub const draw_spinner = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_step: c_uint, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_spinner.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_widget, p_detail, p_step, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_step: c_uint, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_spinner = @ptrCast(p_implementation);
            }
        };

        pub const draw_tab = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_tab.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_shadow_type, p_widget, p_detail, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_tab = @ptrCast(p_implementation);
            }
        };

        pub const draw_vline = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_y1_: c_int, p_y2_: c_int, p_x: c_int) void {
                return gobject.ext.as(Style.Class, p_class).f_draw_vline.?(gobject.ext.as(Style, p_style), p_cr, p_state_type, p_widget, p_detail, p_y1_, p_y2_, p_x);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_y1_: c_int, p_y2_: c_int, p_x: c_int) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_draw_vline = @ptrCast(p_implementation);
            }
        };

        pub const init_from_rc = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_rc_style: *gtk.RcStyle) void {
                return gobject.ext.as(Style.Class, p_class).f_init_from_rc.?(gobject.ext.as(Style, p_style), p_rc_style);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_rc_style: *gtk.RcStyle) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_init_from_rc = @ptrCast(p_implementation);
            }
        };

        pub const realize = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Style.Class, p_class).f_realize.?(gobject.ext.as(Style, p_style));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_realize = @ptrCast(p_implementation);
            }
        };

        /// Renders the icon specified by `source` at the given `size`
        /// according to the given parameters and returns the result in a
        /// pixbuf.
        pub const render_icon = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_source: *const gtk.IconSource, p_direction: gtk.TextDirection, p_state: gtk.StateType, p_size: c_int, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8) *gdkpixbuf.Pixbuf {
                return gobject.ext.as(Style.Class, p_class).f_render_icon.?(gobject.ext.as(Style, p_style), p_source, p_direction, p_state, p_size, p_widget, p_detail);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_source: *const gtk.IconSource, p_direction: gtk.TextDirection, p_state: gtk.StateType, p_size: c_int, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8) callconv(.c) *gdkpixbuf.Pixbuf) void {
                gobject.ext.as(Style.Class, p_class).f_render_icon = @ptrCast(p_implementation);
            }
        };

        /// Sets the background of `window` to the background color or pixmap
        /// specified by `style` for the given state.
        pub const set_background = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_window: *gdk.Window, p_state_type: gtk.StateType) void {
                return gobject.ext.as(Style.Class, p_class).f_set_background.?(gobject.ext.as(Style, p_style), p_window, p_state_type);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_window: *gdk.Window, p_state_type: gtk.StateType) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_set_background = @ptrCast(p_implementation);
            }
        };

        pub const unrealize = struct {
            pub fn call(p_class: anytype, p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Style.Class, p_class).f_unrealize.?(gobject.ext.as(Style, p_style));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_style: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Style.Class, p_class).f_unrealize = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const context = struct {
            pub const name = "context";

            pub const Type = ?*gtk.StyleContext;
        };
    };

    pub const signals = struct {
        /// Emitted when the style has been initialized for a particular
        /// visual. Connecting to this signal is probably seldom
        /// useful since most of the time applications and widgets only
        /// deal with styles that have been already realized.
        pub const realize = struct {
            pub const name = "realize";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Style, p_instance))),
                    gobject.signalLookup("realize", Style.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the aspects of the style specific to a particular visual
        /// is being cleaned up. A connection to this signal can be useful
        /// if a widget wants to cache objects as object data on `gtk.Style`.
        /// This signal provides a convenient place to free such cached objects.
        pub const unrealize = struct {
            pub const name = "unrealize";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Style, p_instance))),
                    gobject.signalLookup("unrealize", Style.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.Style`.
    extern fn gtk_style_new() *gtk.Style;
    pub const new = gtk_style_new;

    extern fn gtk_style_apply_default_background(p_style: *Style, p_cr: *cairo.Context, p_window: *gdk.Window, p_state_type: gtk.StateType, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void;
    pub const applyDefaultBackground = gtk_style_apply_default_background;

    /// Attaches a style to a window; this process allocates the
    /// colors and creates the GC’s for the style - it specializes
    /// it to a particular visual. The process may involve the creation
    /// of a new style if the style has already been attached to a
    /// window with a different style and visual.
    ///
    /// Since this function may return a new object, you have to use it
    /// in the following way:
    /// `style = gtk_style_attach (style, window)`
    extern fn gtk_style_attach(p_style: *Style, p_window: *gdk.Window) *gtk.Style;
    pub const attach = gtk_style_attach;

    /// Creates a copy of the passed in `gtk.Style` object.
    extern fn gtk_style_copy(p_style: *Style) *gtk.Style;
    pub const copy = gtk_style_copy;

    /// Detaches a style from a window. If the style is not attached
    /// to any windows anymore, it is unrealized. See `gtk.Style.attach`.
    extern fn gtk_style_detach(p_style: *Style) void;
    pub const detach = gtk_style_detach;

    /// Gets the values of a multiple style properties for `widget_type`
    /// from `style`.
    extern fn gtk_style_get(p_style: *Style, p_widget_type: usize, p_first_property_name: [*:0]const u8, ...) void;
    pub const get = gtk_style_get;

    /// Queries the value of a style property corresponding to a
    /// widget class is in the given style.
    extern fn gtk_style_get_style_property(p_style: *Style, p_widget_type: usize, p_property_name: [*:0]const u8, p_value: *gobject.Value) void;
    pub const getStyleProperty = gtk_style_get_style_property;

    /// Non-vararg variant of `gtk.Style.get`.
    /// Used primarily by language bindings.
    extern fn gtk_style_get_valist(p_style: *Style, p_widget_type: usize, p_first_property_name: [*:0]const u8, p_var_args: std.builtin.VaList) void;
    pub const getValist = gtk_style_get_valist;

    /// Returns whether `style` has an associated `gtk.StyleContext`.
    extern fn gtk_style_has_context(p_style: *Style) c_int;
    pub const hasContext = gtk_style_has_context;

    /// Looks up `color_name` in the style’s logical color mappings,
    /// filling in `color` and returning `TRUE` if found, otherwise
    /// returning `FALSE`. Do not cache the found mapping, because
    /// it depends on the `gtk.Style` and might change when a theme
    /// switch occurs.
    extern fn gtk_style_lookup_color(p_style: *Style, p_color_name: [*:0]const u8, p_color: *gdk.Color) c_int;
    pub const lookupColor = gtk_style_lookup_color;

    /// Looks up `stock_id` in the icon factories associated with `style`
    /// and the default icon factory, returning an icon set if found,
    /// otherwise `NULL`.
    extern fn gtk_style_lookup_icon_set(p_style: *Style, p_stock_id: [*:0]const u8) *gtk.IconSet;
    pub const lookupIconSet = gtk_style_lookup_icon_set;

    /// Renders the icon specified by `source` at the given `size`
    /// according to the given parameters and returns the result in a
    /// pixbuf.
    extern fn gtk_style_render_icon(p_style: *Style, p_source: *const gtk.IconSource, p_direction: gtk.TextDirection, p_state: gtk.StateType, p_size: c_int, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8) *gdkpixbuf.Pixbuf;
    pub const renderIcon = gtk_style_render_icon;

    /// Sets the background of `window` to the background color or pixmap
    /// specified by `style` for the given state.
    extern fn gtk_style_set_background(p_style: *Style, p_window: *gdk.Window, p_state_type: gtk.StateType) void;
    pub const setBackground = gtk_style_set_background;

    extern fn gtk_style_get_type() usize;
    pub const getGObjectType = gtk_style_get_type;

    extern fn g_object_ref(p_self: *gtk.Style) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Style) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Style, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.StyleContext` is an object that stores styling information affecting
/// a widget defined by `gtk.WidgetPath`.
///
/// In order to construct the final style information, `gtk.StyleContext`
/// queries information from all attached `GtkStyleProviders`. Style providers
/// can be either attached explicitly to the context through
/// `gtk.StyleContext.addProvider`, or to the screen through
/// `gtk.StyleContext.addProviderForScreen`. The resulting style is a
/// combination of all providers’ information in priority order.
///
/// For GTK+ widgets, any `gtk.StyleContext` returned by
/// `gtk.Widget.getStyleContext` will already have a `gtk.WidgetPath`, a
/// `gdk.Screen` and RTL/LTR information set. The style context will also be
/// updated automatically if any of these settings change on the widget.
///
/// If you are using the theming layer standalone, you will need to set a
/// widget path and a screen yourself to the created style context through
/// `gtk.StyleContext.setPath` and possibly `gtk.StyleContext.setScreen`. See
/// the “Foreign drawing“ example in gtk3-demo.
///
/// # Style Classes
///
/// Widgets can add style classes to their context, which can be used to associate
/// different styles by class. The documentation for individual widgets lists
/// which style classes it uses itself, and which style classes may be added by
/// applications to affect their appearance.
///
/// GTK+ defines macros for a number of style classes.
///
/// # Style Regions
///
/// Widgets can also add regions with flags to their context. This feature is
/// deprecated and will be removed in a future GTK+ update. Please use style
/// classes instead.
///
/// GTK+ defines macros for a number of style regions.
///
/// # Custom styling in UI libraries and applications
///
/// If you are developing a library with custom `GtkWidgets` that
/// render differently than standard components, you may need to add a
/// `gtk.StyleProvider` yourself with the `GTK_STYLE_PROVIDER_PRIORITY_FALLBACK`
/// priority, either a `gtk.CssProvider` or a custom object implementing the
/// `gtk.StyleProvider` interface. This way themes may still attempt
/// to style your UI elements in a different way if needed so.
///
/// If you are using custom styling on an applications, you probably want then
/// to make your style information prevail to the theme’s, so you must use
/// a `gtk.StyleProvider` with the `GTK_STYLE_PROVIDER_PRIORITY_APPLICATION`
/// priority, keep in mind that the user settings in
/// `XDG_CONFIG_HOME/gtk-3.0/gtk.css` will
/// still take precedence over your changes, as it uses the
/// `GTK_STYLE_PROVIDER_PRIORITY_USER` priority.
pub const StyleContext = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.StyleContextClass;
    f_parent_object: gobject.Object,
    f_priv: ?*gtk.StyleContextPrivate,

    pub const virtual_methods = struct {
        pub const changed = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(StyleContext.Class, p_class).f_changed.?(gobject.ext.as(StyleContext, p_context));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(StyleContext.Class, p_class).f_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const direction = struct {
            pub const name = "direction";

            pub const Type = gtk.TextDirection;
        };

        pub const paint_clock = struct {
            pub const name = "paint-clock";

            pub const Type = ?*gdk.FrameClock;
        };

        /// Sets or gets the style context’s parent. See `gtk.StyleContext.setParent`
        /// for details.
        pub const parent = struct {
            pub const name = "parent";

            pub const Type = ?*gtk.StyleContext;
        };

        pub const screen = struct {
            pub const name = "screen";

            pub const Type = ?*gdk.Screen;
        };
    };

    pub const signals = struct {
        /// The ::changed signal is emitted when there is a change in the
        /// `gtk.StyleContext`.
        ///
        /// For a `gtk.StyleContext` returned by `gtk.Widget.getStyleContext`, the
        /// `gtk.Widget.signals.style`-updated signal/vfunc might be more convenient to use.
        ///
        /// This signal is useful when using the theming layer standalone.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(StyleContext, p_instance))),
                    gobject.signalLookup("changed", StyleContext.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Adds a global style provider to `screen`, which will be used
    /// in style construction for all `GtkStyleContexts` under `screen`.
    ///
    /// GTK+ uses this to make styling information from `gtk.Settings`
    /// available.
    ///
    /// Note: If both priorities are the same, A `gtk.StyleProvider`
    /// added through `gtk.StyleContext.addProvider` takes precedence
    /// over another added through this function.
    extern fn gtk_style_context_add_provider_for_screen(p_screen: *gdk.Screen, p_provider: *gtk.StyleProvider, p_priority: c_uint) void;
    pub const addProviderForScreen = gtk_style_context_add_provider_for_screen;

    /// Removes `provider` from the global style providers list in `screen`.
    extern fn gtk_style_context_remove_provider_for_screen(p_screen: *gdk.Screen, p_provider: *gtk.StyleProvider) void;
    pub const removeProviderForScreen = gtk_style_context_remove_provider_for_screen;

    /// This function recomputes the styles for all widgets under a particular
    /// `gdk.Screen`. This is useful when some global parameter has changed that
    /// affects the appearance of all widgets, because when a widget gets a new
    /// style, it will both redraw and recompute any cached information about
    /// its appearance. As an example, it is used when the color scheme changes
    /// in the related `gtk.Settings` object.
    extern fn gtk_style_context_reset_widgets(p_screen: *gdk.Screen) void;
    pub const resetWidgets = gtk_style_context_reset_widgets;

    /// Creates a standalone `gtk.StyleContext`, this style context
    /// won’t be attached to any widget, so you may want
    /// to call `gtk.StyleContext.setPath` yourself.
    ///
    /// This function is only useful when using the theming layer
    /// separated from GTK+, if you are using `gtk.StyleContext` to
    /// theme `GtkWidgets`, use `gtk.Widget.getStyleContext`
    /// in order to get a style context ready to theme the widget.
    extern fn gtk_style_context_new() *gtk.StyleContext;
    pub const new = gtk_style_context_new;

    /// Adds a style class to `context`, so posterior calls to
    /// `gtk.StyleContext.get` or any of the gtk_render_*()
    /// functions will make use of this new class for styling.
    ///
    /// In the CSS file format, a `gtk.Entry` defining a “search”
    /// class, would be matched by:
    ///
    /// ```
    /// entry.search { ... }
    /// ```
    ///
    /// While any widget defining a “search” class would be
    /// matched by:
    /// ```
    /// .search { ... }
    /// ```
    extern fn gtk_style_context_add_class(p_context: *StyleContext, p_class_name: [*:0]const u8) void;
    pub const addClass = gtk_style_context_add_class;

    /// Adds a style provider to `context`, to be used in style construction.
    /// Note that a style provider added by this function only affects
    /// the style of the widget to which `context` belongs. If you want
    /// to affect the style of all widgets, use
    /// `gtk.StyleContext.addProviderForScreen`.
    ///
    /// Note: If both priorities are the same, a `gtk.StyleProvider`
    /// added through this function takes precedence over another added
    /// through `gtk.StyleContext.addProviderForScreen`.
    extern fn gtk_style_context_add_provider(p_context: *StyleContext, p_provider: *gtk.StyleProvider, p_priority: c_uint) void;
    pub const addProvider = gtk_style_context_add_provider;

    /// Adds a region to `context`, so posterior calls to
    /// `gtk.StyleContext.get` or any of the gtk_render_*()
    /// functions will make use of this new region for styling.
    ///
    /// In the CSS file format, a `gtk.TreeView` defining a “row”
    /// region, would be matched by:
    ///
    /// ```
    /// treeview row { ... }
    /// ```
    ///
    /// Pseudo-classes are used for matching `flags`, so the two
    /// following rules:
    /// ```
    /// treeview row:nth-child(even) { ... }
    /// treeview row:nth-child(odd) { ... }
    /// ```
    ///
    /// would apply to even and odd rows, respectively.
    ///
    /// Region names must only contain lowercase letters
    /// and “-”, starting always with a lowercase letter.
    extern fn gtk_style_context_add_region(p_context: *StyleContext, p_region_name: [*:0]const u8, p_flags: gtk.RegionFlags) void;
    pub const addRegion = gtk_style_context_add_region;

    /// Stops all running animations for `region_id` and all animatable
    /// regions underneath.
    ///
    /// A `NULL` `region_id` will stop all ongoing animations in `context`,
    /// when dealing with a `gtk.StyleContext` obtained through
    /// `gtk.Widget.getStyleContext`, this is normally done for you
    /// in all circumstances you would expect all widget to be stopped,
    /// so this should be only used in complex widgets with different
    /// animatable regions.
    extern fn gtk_style_context_cancel_animations(p_context: *StyleContext, p_region_id: ?*anyopaque) void;
    pub const cancelAnimations = gtk_style_context_cancel_animations;

    /// Retrieves several style property values from `context` for a
    /// given state.
    ///
    /// See `gtk.StyleContext.getProperty` for details.
    ///
    /// For the property name / return value pairs, it works similarly as
    /// `gobject.Object.get`. Example:
    ///
    /// ```
    /// GdkRGBA *background_color = NULL;
    /// PangoFontDescription *font_desc = NULL;
    /// gint border_radius = 0;
    ///
    /// gtk_style_context_get (style_context,
    ///                        gtk_style_context_get_state (style_context),
    ///                        GTK_STYLE_PROPERTY_BACKGROUND_COLOR, &background_color,
    ///                        GTK_STYLE_PROPERTY_FONT, &font_desc,
    ///                        GTK_STYLE_PROPERTY_BORDER_RADIUS, &border_radius,
    ///                        NULL);
    ///
    /// // Do something with the property values.
    ///
    /// if (background_color != NULL)
    ///   gdk_rgba_free (background_color);
    /// if (font_desc != NULL)
    ///   pango_font_description_free (font_desc);
    /// ```
    extern fn gtk_style_context_get(p_context: *StyleContext, p_state: gtk.StateFlags, ...) void;
    pub const get = gtk_style_context_get;

    /// Gets the background color for a given state.
    ///
    /// This function is far less useful than it seems, and it should not be used in
    /// newly written code. CSS has no concept of "background color", as a background
    /// can be an image, or a gradient, or any other pattern including solid colors.
    ///
    /// The only reason why you would call `gtk.StyleContext.getBackgroundColor` is
    /// to use the returned value to draw the background with it; the correct way to
    /// achieve this result is to use `gtk.renderBackground` instead, along with CSS
    /// style classes to modify the color to be rendered.
    extern fn gtk_style_context_get_background_color(p_context: *StyleContext, p_state: gtk.StateFlags, p_color: *gdk.RGBA) void;
    pub const getBackgroundColor = gtk_style_context_get_background_color;

    /// Gets the border for a given state as a `gtk.Border`.
    ///
    /// See `gtk.StyleContext.getProperty` and
    /// `GTK_STYLE_PROPERTY_BORDER_WIDTH` for details.
    extern fn gtk_style_context_get_border(p_context: *StyleContext, p_state: gtk.StateFlags, p_border: *gtk.Border) void;
    pub const getBorder = gtk_style_context_get_border;

    /// Gets the border color for a given state.
    extern fn gtk_style_context_get_border_color(p_context: *StyleContext, p_state: gtk.StateFlags, p_color: *gdk.RGBA) void;
    pub const getBorderColor = gtk_style_context_get_border_color;

    /// Gets the foreground color for a given state.
    ///
    /// See `gtk.StyleContext.getProperty` and
    /// `GTK_STYLE_PROPERTY_COLOR` for details.
    extern fn gtk_style_context_get_color(p_context: *StyleContext, p_state: gtk.StateFlags, p_color: *gdk.RGBA) void;
    pub const getColor = gtk_style_context_get_color;

    /// Returns the widget direction used for rendering.
    extern fn gtk_style_context_get_direction(p_context: *StyleContext) gtk.TextDirection;
    pub const getDirection = gtk_style_context_get_direction;

    /// Returns the font description for a given state. The returned
    /// object is const and will remain valid until the
    /// `gtk.StyleContext.signals.changed` signal happens.
    extern fn gtk_style_context_get_font(p_context: *StyleContext, p_state: gtk.StateFlags) *const pango.FontDescription;
    pub const getFont = gtk_style_context_get_font;

    /// Returns the `gdk.FrameClock` to which `context` is attached.
    extern fn gtk_style_context_get_frame_clock(p_context: *StyleContext) ?*gdk.FrameClock;
    pub const getFrameClock = gtk_style_context_get_frame_clock;

    /// Returns the sides where rendered elements connect visually with others.
    extern fn gtk_style_context_get_junction_sides(p_context: *StyleContext) gtk.JunctionSides;
    pub const getJunctionSides = gtk_style_context_get_junction_sides;

    /// Gets the margin for a given state as a `gtk.Border`.
    /// See `gtk_style_property_get` and `GTK_STYLE_PROPERTY_MARGIN`
    /// for details.
    extern fn gtk_style_context_get_margin(p_context: *StyleContext, p_state: gtk.StateFlags, p_margin: *gtk.Border) void;
    pub const getMargin = gtk_style_context_get_margin;

    /// Gets the padding for a given state as a `gtk.Border`.
    /// See `gtk.StyleContext.get` and `GTK_STYLE_PROPERTY_PADDING`
    /// for details.
    extern fn gtk_style_context_get_padding(p_context: *StyleContext, p_state: gtk.StateFlags, p_padding: *gtk.Border) void;
    pub const getPadding = gtk_style_context_get_padding;

    /// Gets the parent context set via `gtk.StyleContext.setParent`.
    /// See that function for details.
    extern fn gtk_style_context_get_parent(p_context: *StyleContext) ?*gtk.StyleContext;
    pub const getParent = gtk_style_context_get_parent;

    /// Returns the widget path used for style matching.
    extern fn gtk_style_context_get_path(p_context: *StyleContext) *const gtk.WidgetPath;
    pub const getPath = gtk_style_context_get_path;

    /// Gets a style property from `context` for the given state.
    ///
    /// Note that not all CSS properties that are supported by GTK+ can be
    /// retrieved in this way, since they may not be representable as `gobject.Value`.
    /// GTK+ defines macros for a number of properties that can be used
    /// with this function.
    ///
    /// Note that passing a state other than the current state of `context`
    /// is not recommended unless the style context has been saved with
    /// `gtk.StyleContext.save`.
    ///
    /// When `value` is no longer needed, `gobject.Value.unset` must be called
    /// to free any allocated memory.
    extern fn gtk_style_context_get_property(p_context: *StyleContext, p_property: [*:0]const u8, p_state: gtk.StateFlags, p_value: *gobject.Value) void;
    pub const getProperty = gtk_style_context_get_property;

    /// Returns the scale used for assets.
    extern fn gtk_style_context_get_scale(p_context: *StyleContext) c_int;
    pub const getScale = gtk_style_context_get_scale;

    /// Returns the `gdk.Screen` to which `context` is attached.
    extern fn gtk_style_context_get_screen(p_context: *StyleContext) *gdk.Screen;
    pub const getScreen = gtk_style_context_get_screen;

    /// Queries the location in the CSS where `property` was defined for the
    /// current `context`. Note that the state to be queried is taken from
    /// `gtk.StyleContext.getState`.
    ///
    /// If the location is not available, `NULL` will be returned. The
    /// location might not be available for various reasons, such as the
    /// property being overridden, `property` not naming a supported CSS
    /// property or tracking of definitions being disabled for performance
    /// reasons.
    ///
    /// Shorthand CSS properties cannot be queried for a location and will
    /// always return `NULL`.
    extern fn gtk_style_context_get_section(p_context: *StyleContext, p_property: [*:0]const u8) ?*gtk.CssSection;
    pub const getSection = gtk_style_context_get_section;

    /// Returns the state used for style matching.
    ///
    /// This method should only be used to retrieve the `gtk.StateFlags`
    /// to pass to `gtk.StyleContext` methods, like `gtk.StyleContext.getPadding`.
    /// If you need to retrieve the current state of a `gtk.Widget`, use
    /// `gtk.Widget.getStateFlags`.
    extern fn gtk_style_context_get_state(p_context: *StyleContext) gtk.StateFlags;
    pub const getState = gtk_style_context_get_state;

    /// Retrieves several widget style properties from `context` according to the
    /// current style.
    extern fn gtk_style_context_get_style(p_context: *StyleContext, ...) void;
    pub const getStyle = gtk_style_context_get_style;

    /// Gets the value for a widget style property.
    ///
    /// When `value` is no longer needed, `gobject.Value.unset` must be called
    /// to free any allocated memory.
    extern fn gtk_style_context_get_style_property(p_context: *StyleContext, p_property_name: [*:0]const u8, p_value: *gobject.Value) void;
    pub const getStyleProperty = gtk_style_context_get_style_property;

    /// Retrieves several widget style properties from `context` according to the
    /// current style.
    extern fn gtk_style_context_get_style_valist(p_context: *StyleContext, p_args: std.builtin.VaList) void;
    pub const getStyleValist = gtk_style_context_get_style_valist;

    /// Retrieves several style property values from `context` for a given state.
    ///
    /// See `gtk.StyleContext.getProperty` for details.
    extern fn gtk_style_context_get_valist(p_context: *StyleContext, p_state: gtk.StateFlags, p_args: std.builtin.VaList) void;
    pub const getValist = gtk_style_context_get_valist;

    /// Returns `TRUE` if `context` currently has defined the
    /// given class name.
    extern fn gtk_style_context_has_class(p_context: *StyleContext, p_class_name: [*:0]const u8) c_int;
    pub const hasClass = gtk_style_context_has_class;

    /// Returns `TRUE` if `context` has the region defined.
    /// If `flags_return` is not `NULL`, it is set to the flags
    /// affecting the region.
    extern fn gtk_style_context_has_region(p_context: *StyleContext, p_region_name: [*:0]const u8, p_flags_return: ?*gtk.RegionFlags) c_int;
    pub const hasRegion = gtk_style_context_has_region;

    /// Invalidates `context` style information, so it will be reconstructed
    /// again. It is useful if you modify the `context` and need the new
    /// information immediately.
    extern fn gtk_style_context_invalidate(p_context: *StyleContext) void;
    pub const invalidate = gtk_style_context_invalidate;

    /// Returns the list of classes currently defined in `context`.
    extern fn gtk_style_context_list_classes(p_context: *StyleContext) *glib.List;
    pub const listClasses = gtk_style_context_list_classes;

    /// Returns the list of regions currently defined in `context`.
    extern fn gtk_style_context_list_regions(p_context: *StyleContext) *glib.List;
    pub const listRegions = gtk_style_context_list_regions;

    /// Looks up and resolves a color name in the `context` color map.
    extern fn gtk_style_context_lookup_color(p_context: *StyleContext, p_color_name: [*:0]const u8, p_color: *gdk.RGBA) c_int;
    pub const lookupColor = gtk_style_context_lookup_color;

    /// Looks up `stock_id` in the icon factories associated to `context` and
    /// the default icon factory, returning an icon set if found, otherwise
    /// `NULL`.
    extern fn gtk_style_context_lookup_icon_set(p_context: *StyleContext, p_stock_id: [*:0]const u8) ?*gtk.IconSet;
    pub const lookupIconSet = gtk_style_context_lookup_icon_set;

    /// Notifies a state change on `context`, so if the current style makes use
    /// of transition animations, one will be started so all rendered elements
    /// under `region_id` are animated for state `state` being set to value
    /// `state_value`.
    ///
    /// The `window` parameter is used in order to invalidate the rendered area
    /// as the animation runs, so make sure it is the same window that is being
    /// rendered on by the gtk_render_*() functions.
    ///
    /// If `region_id` is `NULL`, all rendered elements using `context` will be
    /// affected by this state transition.
    ///
    /// As a practical example, a `gtk.Button` notifying a state transition on
    /// the prelight state:
    /// ```
    /// gtk_style_context_notify_state_change (context,
    ///                                        gtk_widget_get_window (widget),
    ///                                        NULL,
    ///                                        GTK_STATE_PRELIGHT,
    ///                                        button->in_button);
    /// ```
    ///
    /// Can be handled in the CSS file like this:
    /// ```
    /// button {
    ///     background-color: `f00`
    /// }
    ///
    /// button:hover {
    ///     background-color: `fff`;
    ///     transition: 200ms linear
    /// }
    /// ```
    ///
    /// This combination will animate the button background from red to white
    /// if a pointer enters the button, and back to red if the pointer leaves
    /// the button.
    ///
    /// Note that `state` is used when finding the transition parameters, which
    /// is why the style places the transition under the :hover pseudo-class.
    extern fn gtk_style_context_notify_state_change(p_context: *StyleContext, p_window: *gdk.Window, p_region_id: ?*anyopaque, p_state: gtk.StateType, p_state_value: c_int) void;
    pub const notifyStateChange = gtk_style_context_notify_state_change;

    /// Pops an animatable region from `context`.
    /// See `gtk.StyleContext.pushAnimatableRegion`.
    extern fn gtk_style_context_pop_animatable_region(p_context: *StyleContext) void;
    pub const popAnimatableRegion = gtk_style_context_pop_animatable_region;

    /// Pushes an animatable region, so all further gtk_render_*() calls between
    /// this call and the following `gtk.StyleContext.popAnimatableRegion`
    /// will potentially show transition animations for this region if
    /// `gtk.StyleContext.notifyStateChange` is called for a given state,
    /// and the current theme/style defines transition animations for state
    /// changes.
    ///
    /// The `region_id` used must be unique in `context` so the themes
    /// can uniquely identify rendered elements subject to a state transition.
    extern fn gtk_style_context_push_animatable_region(p_context: *StyleContext, p_region_id: ?*anyopaque) void;
    pub const pushAnimatableRegion = gtk_style_context_push_animatable_region;

    /// Removes `class_name` from `context`.
    extern fn gtk_style_context_remove_class(p_context: *StyleContext, p_class_name: [*:0]const u8) void;
    pub const removeClass = gtk_style_context_remove_class;

    /// Removes `provider` from the style providers list in `context`.
    extern fn gtk_style_context_remove_provider(p_context: *StyleContext, p_provider: *gtk.StyleProvider) void;
    pub const removeProvider = gtk_style_context_remove_provider;

    /// Removes a region from `context`.
    extern fn gtk_style_context_remove_region(p_context: *StyleContext, p_region_name: [*:0]const u8) void;
    pub const removeRegion = gtk_style_context_remove_region;

    /// Restores `context` state to a previous stage.
    /// See `gtk.StyleContext.save`.
    extern fn gtk_style_context_restore(p_context: *StyleContext) void;
    pub const restore = gtk_style_context_restore;

    /// Saves the `context` state, so temporary modifications done through
    /// `gtk.StyleContext.addClass`, `gtk.StyleContext.removeClass`,
    /// `gtk.StyleContext.setState`, etc. can quickly be reverted
    /// in one go through `gtk.StyleContext.restore`.
    ///
    /// The matching call to `gtk.StyleContext.restore` must be done
    /// before GTK returns to the main loop.
    extern fn gtk_style_context_save(p_context: *StyleContext) void;
    pub const save = gtk_style_context_save;

    /// This function is analogous to `gdk.Window.scroll`, and
    /// should be called together with it so the invalidation
    /// areas for any ongoing animation are scrolled together
    /// with it.
    extern fn gtk_style_context_scroll_animations(p_context: *StyleContext, p_window: *gdk.Window, p_dx: c_int, p_dy: c_int) void;
    pub const scrollAnimations = gtk_style_context_scroll_animations;

    /// Sets the background of `window` to the background pattern or
    /// color specified in `context` for its current state.
    extern fn gtk_style_context_set_background(p_context: *StyleContext, p_window: *gdk.Window) void;
    pub const setBackground = gtk_style_context_set_background;

    /// Sets the reading direction for rendering purposes.
    ///
    /// If you are using a `gtk.StyleContext` returned from
    /// `gtk.Widget.getStyleContext`, you do not need to
    /// call this yourself.
    extern fn gtk_style_context_set_direction(p_context: *StyleContext, p_direction: gtk.TextDirection) void;
    pub const setDirection = gtk_style_context_set_direction;

    /// Attaches `context` to the given frame clock.
    ///
    /// The frame clock is used for the timing of animations.
    ///
    /// If you are using a `gtk.StyleContext` returned from
    /// `gtk.Widget.getStyleContext`, you do not need to
    /// call this yourself.
    extern fn gtk_style_context_set_frame_clock(p_context: *StyleContext, p_frame_clock: *gdk.FrameClock) void;
    pub const setFrameClock = gtk_style_context_set_frame_clock;

    /// Sets the sides where rendered elements (mostly through
    /// `gtk.renderFrame`) will visually connect with other visual elements.
    ///
    /// This is merely a hint that may or may not be honored
    /// by themes.
    ///
    /// Container widgets are expected to set junction hints as appropriate
    /// for their children, so it should not normally be necessary to call
    /// this function manually.
    extern fn gtk_style_context_set_junction_sides(p_context: *StyleContext, p_sides: gtk.JunctionSides) void;
    pub const setJunctionSides = gtk_style_context_set_junction_sides;

    /// Sets the parent style context for `context`. The parent style
    /// context is used to implement
    /// [inheritance](http://www.w3.org/TR/css3-cascade/`inheritance`)
    /// of properties.
    ///
    /// If you are using a `gtk.StyleContext` returned from
    /// `gtk.Widget.getStyleContext`, the parent will be set for you.
    extern fn gtk_style_context_set_parent(p_context: *StyleContext, p_parent: ?*gtk.StyleContext) void;
    pub const setParent = gtk_style_context_set_parent;

    /// Sets the `gtk.WidgetPath` used for style matching. As a
    /// consequence, the style will be regenerated to match
    /// the new given path.
    ///
    /// If you are using a `gtk.StyleContext` returned from
    /// `gtk.Widget.getStyleContext`, you do not need to call
    /// this yourself.
    extern fn gtk_style_context_set_path(p_context: *StyleContext, p_path: *gtk.WidgetPath) void;
    pub const setPath = gtk_style_context_set_path;

    /// Sets the scale to use when getting image assets for the style.
    extern fn gtk_style_context_set_scale(p_context: *StyleContext, p_scale: c_int) void;
    pub const setScale = gtk_style_context_set_scale;

    /// Attaches `context` to the given screen.
    ///
    /// The screen is used to add style information from “global” style
    /// providers, such as the screen’s `gtk.Settings` instance.
    ///
    /// If you are using a `gtk.StyleContext` returned from
    /// `gtk.Widget.getStyleContext`, you do not need to
    /// call this yourself.
    extern fn gtk_style_context_set_screen(p_context: *StyleContext, p_screen: *gdk.Screen) void;
    pub const setScreen = gtk_style_context_set_screen;

    /// Sets the state to be used for style matching.
    extern fn gtk_style_context_set_state(p_context: *StyleContext, p_flags: gtk.StateFlags) void;
    pub const setState = gtk_style_context_set_state;

    /// Returns `TRUE` if there is a transition animation running for the
    /// current region (see `gtk.StyleContext.pushAnimatableRegion`).
    ///
    /// If `progress` is not `NULL`, the animation progress will be returned
    /// there, 0.0 means the state is closest to being unset, while 1.0 means
    /// it’s closest to being set. This means transition animation will
    /// run from 0 to 1 when `state` is being set and from 1 to 0 when
    /// it’s being unset.
    extern fn gtk_style_context_state_is_running(p_context: *StyleContext, p_state: gtk.StateType, p_progress: *f64) c_int;
    pub const stateIsRunning = gtk_style_context_state_is_running;

    /// Converts the style context into a string representation.
    ///
    /// The string representation always includes information about
    /// the name, state, id, visibility and style classes of the CSS
    /// node that is backing `context`. Depending on the flags, more
    /// information may be included.
    ///
    /// This function is intended for testing and debugging of the
    /// CSS implementation in GTK+. There are no guarantees about
    /// the format of the returned string, it may change.
    extern fn gtk_style_context_to_string(p_context: *StyleContext, p_flags: gtk.StyleContextPrintFlags) [*:0]u8;
    pub const toString = gtk_style_context_to_string;

    extern fn gtk_style_context_get_type() usize;
    pub const getGObjectType = gtk_style_context_get_type;

    extern fn g_object_ref(p_self: *gtk.StyleContext) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.StyleContext) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *StyleContext, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkStyleProperties provides the storage for style information
/// that is used by `gtk.StyleContext` and other `gtk.StyleProvider`
/// implementations.
///
/// Before style properties can be stored in GtkStyleProperties, they
/// must be registered with `gtk.StyleProperties.registerProperty`.
///
/// Unless you are writing a `gtk.StyleProvider` implementation, you
/// are unlikely to use this API directly, as `gtk.StyleContext.get`
/// and its variants are the preferred way to access styling information
/// from widget implementations and theming engine implementations
/// should use the APIs provided by `gtk.ThemingEngine` instead.
///
/// `gtk.StyleProperties` has been deprecated in GTK 3.16. The CSS
/// machinery does not use it anymore and all users of this object
/// have been deprecated.
pub const StyleProperties = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gtk.StyleProvider};
    pub const Class = gtk.StylePropertiesClass;
    f_parent_object: gobject.Object,
    f_priv: ?*gtk.StylePropertiesPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Returns `TRUE` if a property has been registered, if `pspec` or
    /// `parse_func` are not `NULL`, the `gobject.ParamSpec` and parsing function
    /// will be respectively returned.
    extern fn gtk_style_properties_lookup_property(p_property_name: [*:0]const u8, p_parse_func: *gtk.StylePropertyParser, p_pspec: **gobject.ParamSpec) c_int;
    pub const lookupProperty = gtk_style_properties_lookup_property;

    /// Registers a property so it can be used in the CSS file format.
    /// This function is the low-level equivalent of
    /// `gtk.ThemingEngine.registerProperty`, if you are implementing
    /// a theming engine, you want to use that function instead.
    extern fn gtk_style_properties_register_property(p_parse_func: ?gtk.StylePropertyParser, p_pspec: *gobject.ParamSpec) void;
    pub const registerProperty = gtk_style_properties_register_property;

    /// Returns a newly created `gtk.StyleProperties`
    extern fn gtk_style_properties_new() *gtk.StyleProperties;
    pub const new = gtk_style_properties_new;

    /// Clears all style information from `props`.
    extern fn gtk_style_properties_clear(p_props: *StyleProperties) void;
    pub const clear = gtk_style_properties_clear;

    /// Retrieves several style property values from `props` for a
    /// given state.
    extern fn gtk_style_properties_get(p_props: *StyleProperties, p_state: gtk.StateFlags, ...) void;
    pub const get = gtk_style_properties_get;

    /// Gets a style property from `props` for the given state. When done with `value`,
    /// `gobject.Value.unset` needs to be called to free any allocated memory.
    extern fn gtk_style_properties_get_property(p_props: *StyleProperties, p_property: [*:0]const u8, p_state: gtk.StateFlags, p_value: *gobject.Value) c_int;
    pub const getProperty = gtk_style_properties_get_property;

    /// Retrieves several style property values from `props` for a given state.
    extern fn gtk_style_properties_get_valist(p_props: *StyleProperties, p_state: gtk.StateFlags, p_args: std.builtin.VaList) void;
    pub const getValist = gtk_style_properties_get_valist;

    /// Returns the symbolic color that is mapped
    /// to `name`.
    extern fn gtk_style_properties_lookup_color(p_props: *StyleProperties, p_name: [*:0]const u8) *gtk.SymbolicColor;
    pub const lookupColor = gtk_style_properties_lookup_color;

    /// Maps `color` so it can be referenced by `name`. See
    /// `gtk.StyleProperties.lookupColor`
    extern fn gtk_style_properties_map_color(p_props: *StyleProperties, p_name: [*:0]const u8, p_color: *gtk.SymbolicColor) void;
    pub const mapColor = gtk_style_properties_map_color;

    /// Merges into `props` all the style information contained
    /// in `props_to_merge`. If `replace` is `TRUE`, the values
    /// will be overwritten, if it is `FALSE`, the older values
    /// will prevail.
    extern fn gtk_style_properties_merge(p_props: *StyleProperties, p_props_to_merge: *const gtk.StyleProperties, p_replace: c_int) void;
    pub const merge = gtk_style_properties_merge;

    /// Sets several style properties on `props`.
    extern fn gtk_style_properties_set(p_props: *StyleProperties, p_state: gtk.StateFlags, ...) void;
    pub const set = gtk_style_properties_set;

    /// Sets a styling property in `props`.
    extern fn gtk_style_properties_set_property(p_props: *StyleProperties, p_property: [*:0]const u8, p_state: gtk.StateFlags, p_value: *const gobject.Value) void;
    pub const setProperty = gtk_style_properties_set_property;

    /// Sets several style properties on `props`.
    extern fn gtk_style_properties_set_valist(p_props: *StyleProperties, p_state: gtk.StateFlags, p_args: std.builtin.VaList) void;
    pub const setValist = gtk_style_properties_set_valist;

    /// Unsets a style property in `props`.
    extern fn gtk_style_properties_unset_property(p_props: *StyleProperties, p_property: [*:0]const u8, p_state: gtk.StateFlags) void;
    pub const unsetProperty = gtk_style_properties_unset_property;

    extern fn gtk_style_properties_get_type() usize;
    pub const getGObjectType = gtk_style_properties_get_type;

    extern fn g_object_ref(p_self: *gtk.StyleProperties) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.StyleProperties) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *StyleProperties, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.Switch` is a widget that has two states: on or off. The user can control
/// which state should be active by clicking the empty area, or by dragging the
/// handle.
///
/// GtkSwitch can also handle situations where the underlying state changes with
/// a delay. See `gtk.Switch.signals.state`-set for details.
///
/// # CSS nodes
///
/// ```
/// switch
/// ╰── slider
/// ```
///
/// GtkSwitch has two css nodes, the main node with the name switch and a subnode
/// named slider. Neither of them is using any style classes.
pub const Switch = extern struct {
    pub const Parent = gtk.Widget;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.SwitchClass;
    f_parent_instance: gtk.Widget,
    f_priv: ?*gtk.SwitchPrivate,

    pub const virtual_methods = struct {
        /// An action signal and emitting it causes the switch to animate.
        pub const activate = struct {
            pub fn call(p_class: anytype, p_sw: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Switch.Class, p_class).f_activate.?(gobject.ext.as(Switch, p_sw));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_sw: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Switch.Class, p_class).f_activate = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the ::state-set signal.
        pub const state_set = struct {
            pub fn call(p_class: anytype, p_sw: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_state: c_int) c_int {
                return gobject.ext.as(Switch.Class, p_class).f_state_set.?(gobject.ext.as(Switch, p_sw), p_state);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_sw: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_state: c_int) callconv(.c) c_int) void {
                gobject.ext.as(Switch.Class, p_class).f_state_set = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Whether the `gtk.Switch` widget is in its on or off state.
        pub const active = struct {
            pub const name = "active";

            pub const Type = c_int;
        };

        /// The backend state that is controlled by the switch.
        /// See `gtk.Switch.signals.state`-set for details.
        pub const state = struct {
            pub const name = "state";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::activate signal on GtkSwitch is an action signal and
        /// emitting it causes the switch to animate.
        /// Applications should never connect to this signal, but use the
        /// notify::active signal.
        pub const activate = struct {
            pub const name = "activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Switch, p_instance))),
                    gobject.signalLookup("activate", Switch.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::state-set signal on GtkSwitch is emitted to change the underlying
        /// state. It is emitted when the user changes the switch position. The
        /// default handler keeps the state in sync with the `gtk.Switch.properties.active`
        /// property.
        ///
        /// To implement delayed state change, applications can connect to this signal,
        /// initiate the change of the underlying state, and call `gtk.Switch.setState`
        /// when the underlying state change is complete. The signal handler should
        /// return `TRUE` to prevent the default handler from running.
        ///
        /// Visually, the underlying state is represented by the trough color of
        /// the switch, while the `gtk.Switch.properties.active` property is represented by the
        /// position of the switch.
        pub const state_set = struct {
            pub const name = "state-set";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_state: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Switch, p_instance))),
                    gobject.signalLookup("state-set", Switch.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.Switch` widget.
    extern fn gtk_switch_new() *gtk.Switch;
    pub const new = gtk_switch_new;

    /// Gets whether the `gtk.Switch` is in its “on” or “off” state.
    extern fn gtk_switch_get_active(p_sw: *Switch) c_int;
    pub const getActive = gtk_switch_get_active;

    /// Gets the underlying state of the `gtk.Switch`.
    extern fn gtk_switch_get_state(p_sw: *Switch) c_int;
    pub const getState = gtk_switch_get_state;

    /// Changes the state of `sw` to the desired one.
    extern fn gtk_switch_set_active(p_sw: *Switch, p_is_active: c_int) void;
    pub const setActive = gtk_switch_set_active;

    /// Sets the underlying state of the `gtk.Switch`.
    ///
    /// Normally, this is the same as `gtk.Switch.properties.active`, unless the switch
    /// is set up for delayed state changes. This function is typically
    /// called from a `gtk.Switch.signals.state`-set signal handler.
    ///
    /// See `gtk.Switch.signals.state`-set for details.
    extern fn gtk_switch_set_state(p_sw: *Switch, p_state: c_int) void;
    pub const setState = gtk_switch_set_state;

    extern fn gtk_switch_get_type() usize;
    pub const getGObjectType = gtk_switch_get_type;

    extern fn g_object_ref(p_self: *gtk.Switch) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Switch) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Switch, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SwitchAccessible = extern struct {
    pub const Parent = gtk.WidgetAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component };
    pub const Class = gtk.SwitchAccessibleClass;
    f_parent: gtk.WidgetAccessible,
    f_priv: ?*gtk.SwitchAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_switch_accessible_get_type() usize;
    pub const getGObjectType = gtk_switch_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.SwitchAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.SwitchAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SwitchAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Table` functions allow the programmer to arrange widgets in rows and
/// columns, making it easy to align many widgets next to each other,
/// horizontally and vertically.
///
/// Tables are created with a call to `gtk.Table.new`, the size of which can
/// later be changed with `gtk.Table.resize`.
///
/// Widgets can be added to a table using `gtk.Table.attach` or the more
/// convenient (but slightly less flexible) `gtk.Table.attachDefaults`.
///
/// To alter the space next to a specific row, use `gtk.Table.setRowSpacing`,
/// and for a column, `gtk.Table.setColSpacing`.
/// The gaps between all rows or columns can be changed by
/// calling `gtk.Table.setRowSpacings` or `gtk.Table.setColSpacings`
/// respectively. Note that spacing is added between the
/// children, while padding added by `gtk.Table.attach` is added on
/// either side of the widget it belongs to.
///
/// `gtk.Table.setHomogeneous`, can be used to set whether all cells in the
/// table will resize themselves to the size of the largest widget in the table.
///
/// > `gtk.Table` has been deprecated. Use `gtk.Grid` instead. It provides the same
/// > capabilities as GtkTable for arranging widgets in a rectangular grid, but
/// > does support height-for-width geometry management.
pub const Table = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.TableClass;
    f_container: gtk.Container,
    f_priv: ?*gtk.TablePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const column_spacing = struct {
            pub const name = "column-spacing";

            pub const Type = c_uint;
        };

        pub const homogeneous = struct {
            pub const name = "homogeneous";

            pub const Type = c_int;
        };

        pub const n_columns = struct {
            pub const name = "n-columns";

            pub const Type = c_uint;
        };

        pub const n_rows = struct {
            pub const name = "n-rows";

            pub const Type = c_uint;
        };

        pub const row_spacing = struct {
            pub const name = "row-spacing";

            pub const Type = c_uint;
        };
    };

    pub const signals = struct {};

    /// Used to create a new table widget. An initial size must be given by
    /// specifying how many rows and columns the table should have, although
    /// this can be changed later with `gtk.Table.resize`.  `rows` and `columns`
    /// must both be in the range 1 .. 65535. For historical reasons, 0 is accepted
    /// as well and is silently interpreted as 1.
    extern fn gtk_table_new(p_rows: c_uint, p_columns: c_uint, p_homogeneous: c_int) *gtk.Table;
    pub const new = gtk_table_new;

    /// Adds a widget to a table. The number of “cells” that a widget will occupy is
    /// specified by `left_attach`, `right_attach`, `top_attach` and `bottom_attach`.
    /// These each represent the leftmost, rightmost, uppermost and lowest column
    /// and row numbers of the table. (Columns and rows are indexed from zero).
    ///
    /// To make a button occupy the lower right cell of a 2x2 table, use
    /// ```
    /// gtk_table_attach (table, button,
    ///                   1, 2, // left, right attach
    ///                   1, 2, // top, bottom attach
    ///                   xoptions, yoptions,
    ///                   xpadding, ypadding);
    /// ```
    /// If you want to make the button span the entire bottom row, use `left_attach` == 0 and `right_attach` = 2 instead.
    extern fn gtk_table_attach(p_table: *Table, p_child: *gtk.Widget, p_left_attach: c_uint, p_right_attach: c_uint, p_top_attach: c_uint, p_bottom_attach: c_uint, p_xoptions: gtk.AttachOptions, p_yoptions: gtk.AttachOptions, p_xpadding: c_uint, p_ypadding: c_uint) void;
    pub const attach = gtk_table_attach;

    /// As there are many options associated with `gtk.Table.attach`, this convenience
    /// function provides the programmer with a means to add children to a table with
    /// identical padding and expansion options. The values used for the `gtk.AttachOptions`
    /// are `GTK_EXPAND | GTK_FILL`, and the padding is set to 0.
    extern fn gtk_table_attach_defaults(p_table: *Table, p_widget: *gtk.Widget, p_left_attach: c_uint, p_right_attach: c_uint, p_top_attach: c_uint, p_bottom_attach: c_uint) void;
    pub const attachDefaults = gtk_table_attach_defaults;

    /// Gets the amount of space between column `col`, and
    /// column `col` + 1. See `gtk.Table.setColSpacing`.
    extern fn gtk_table_get_col_spacing(p_table: *Table, p_column: c_uint) c_uint;
    pub const getColSpacing = gtk_table_get_col_spacing;

    /// Gets the default column spacing for the table. This is
    /// the spacing that will be used for newly added columns.
    /// (See `gtk.Table.setColSpacings`)
    extern fn gtk_table_get_default_col_spacing(p_table: *Table) c_uint;
    pub const getDefaultColSpacing = gtk_table_get_default_col_spacing;

    /// Gets the default row spacing for the table. This is
    /// the spacing that will be used for newly added rows.
    /// (See `gtk.Table.setRowSpacings`)
    extern fn gtk_table_get_default_row_spacing(p_table: *Table) c_uint;
    pub const getDefaultRowSpacing = gtk_table_get_default_row_spacing;

    /// Returns whether the table cells are all constrained to the same
    /// width and height. (See gtk_table_set_homogeneous ())
    extern fn gtk_table_get_homogeneous(p_table: *Table) c_int;
    pub const getHomogeneous = gtk_table_get_homogeneous;

    /// Gets the amount of space between row `row`, and
    /// row `row` + 1. See `gtk.Table.setRowSpacing`.
    extern fn gtk_table_get_row_spacing(p_table: *Table, p_row: c_uint) c_uint;
    pub const getRowSpacing = gtk_table_get_row_spacing;

    /// Gets the number of rows and columns in the table.
    extern fn gtk_table_get_size(p_table: *Table, p_rows: ?*c_uint, p_columns: ?*c_uint) void;
    pub const getSize = gtk_table_get_size;

    /// If you need to change a table’s size after
    /// it has been created, this function allows you to do so.
    extern fn gtk_table_resize(p_table: *Table, p_rows: c_uint, p_columns: c_uint) void;
    pub const resize = gtk_table_resize;

    /// Alters the amount of space between a given table column and the following
    /// column.
    extern fn gtk_table_set_col_spacing(p_table: *Table, p_column: c_uint, p_spacing: c_uint) void;
    pub const setColSpacing = gtk_table_set_col_spacing;

    /// Sets the space between every column in `table` equal to `spacing`.
    extern fn gtk_table_set_col_spacings(p_table: *Table, p_spacing: c_uint) void;
    pub const setColSpacings = gtk_table_set_col_spacings;

    /// Changes the homogenous property of table cells, ie. whether all cells are
    /// an equal size or not.
    extern fn gtk_table_set_homogeneous(p_table: *Table, p_homogeneous: c_int) void;
    pub const setHomogeneous = gtk_table_set_homogeneous;

    /// Changes the space between a given table row and the subsequent row.
    extern fn gtk_table_set_row_spacing(p_table: *Table, p_row: c_uint, p_spacing: c_uint) void;
    pub const setRowSpacing = gtk_table_set_row_spacing;

    /// Sets the space between every row in `table` equal to `spacing`.
    extern fn gtk_table_set_row_spacings(p_table: *Table, p_spacing: c_uint) void;
    pub const setRowSpacings = gtk_table_set_row_spacings;

    extern fn gtk_table_get_type() usize;
    pub const getGObjectType = gtk_table_get_type;

    extern fn g_object_ref(p_self: *gtk.Table) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Table) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Table, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.TearoffMenuItem` is a special `gtk.MenuItem` which is used to
/// tear off and reattach its menu.
///
/// When its menu is shown normally, the `gtk.TearoffMenuItem` is drawn as a
/// dotted line indicating that the menu can be torn off.  Activating it
/// causes its menu to be torn off and displayed in its own window
/// as a tearoff menu.
///
/// When its menu is shown as a tearoff menu, the `gtk.TearoffMenuItem` is drawn
/// as a dotted line which has a left pointing arrow graphic indicating that
/// the tearoff menu can be reattached.  Activating it will erase the tearoff
/// menu window.
///
/// > `gtk.TearoffMenuItem` is deprecated and should not be used in newly
/// > written code. Menus are not meant to be torn around.
pub const TearoffMenuItem = extern struct {
    pub const Parent = gtk.MenuItem;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.TearoffMenuItemClass;
    f_menu_item: gtk.MenuItem,
    f_priv: ?*gtk.TearoffMenuItemPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.TearoffMenuItem`.
    extern fn gtk_tearoff_menu_item_new() *gtk.TearoffMenuItem;
    pub const new = gtk_tearoff_menu_item_new;

    extern fn gtk_tearoff_menu_item_get_type() usize;
    pub const getGObjectType = gtk_tearoff_menu_item_get_type;

    extern fn g_object_ref(p_self: *gtk.TearoffMenuItem) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TearoffMenuItem) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TearoffMenuItem, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// You may wish to begin by reading the
/// [text widget conceptual overview](TextWidget.html)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
pub const TextBuffer = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.TextBufferClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.TextBufferPrivate,

    pub const virtual_methods = struct {
        /// Emits the “apply-tag” signal on `buffer`. The default
        /// handler for the signal applies `tag` to the given range.
        /// `start` and `end` do not have to be in order.
        pub const apply_tag = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tag: *gtk.TextTag, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter) void {
                return gobject.ext.as(TextBuffer.Class, p_class).f_apply_tag.?(gobject.ext.as(TextBuffer, p_buffer), p_tag, p_start, p_end);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tag: *gtk.TextTag, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter) callconv(.c) void) void {
                gobject.ext.as(TextBuffer.Class, p_class).f_apply_tag = @ptrCast(p_implementation);
            }
        };

        /// Called to indicate that the buffer operations between here and a
        /// call to `gtk.TextBuffer.endUserAction` are part of a single
        /// user-visible operation. The operations between
        /// `gtk.TextBuffer.beginUserAction` and
        /// `gtk.TextBuffer.endUserAction` can then be grouped when creating
        /// an undo stack. `gtk.TextBuffer` maintains a count of calls to
        /// `gtk.TextBuffer.beginUserAction` that have not been closed with
        /// a call to `gtk.TextBuffer.endUserAction`, and emits the
        /// “begin-user-action” and “end-user-action” signals only for the
        /// outermost pair of calls. This allows you to build user actions
        /// from other user actions.
        ///
        /// The “interactive” buffer mutation functions, such as
        /// `gtk.TextBuffer.insertInteractive`, automatically call begin/end
        /// user action around the buffer operations they perform, so there's
        /// no need to add extra calls if you user action consists solely of a
        /// single call to one of those functions.
        pub const begin_user_action = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TextBuffer.Class, p_class).f_begin_user_action.?(gobject.ext.as(TextBuffer, p_buffer));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TextBuffer.Class, p_class).f_begin_user_action = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextBuffer.signals.changed` signal.
        pub const changed = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TextBuffer.Class, p_class).f_changed.?(gobject.ext.as(TextBuffer, p_buffer));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TextBuffer.Class, p_class).f_changed = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextBuffer.signals.delete`-range signal.
        pub const delete_range = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_start: *gtk.TextIter, p_end: *gtk.TextIter) void {
                return gobject.ext.as(TextBuffer.Class, p_class).f_delete_range.?(gobject.ext.as(TextBuffer, p_buffer), p_start, p_end);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_start: *gtk.TextIter, p_end: *gtk.TextIter) callconv(.c) void) void {
                gobject.ext.as(TextBuffer.Class, p_class).f_delete_range = @ptrCast(p_implementation);
            }
        };

        /// Should be paired with a call to `gtk.TextBuffer.beginUserAction`.
        /// See that function for a full explanation.
        pub const end_user_action = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TextBuffer.Class, p_class).f_end_user_action.?(gobject.ext.as(TextBuffer, p_buffer));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TextBuffer.Class, p_class).f_end_user_action = @ptrCast(p_implementation);
            }
        };

        /// Inserts a child widget anchor into the text buffer at `iter`. The
        /// anchor will be counted as one character in character counts, and
        /// when obtaining the buffer contents as a string, will be represented
        /// by the Unicode “object replacement character” 0xFFFC. Note that the
        /// “slice” variants for obtaining portions of the buffer as a string
        /// include this character for child anchors, but the “text” variants do
        /// not. E.g. see `gtk.TextBuffer.getSlice` and
        /// `gtk.TextBuffer.getText`. Consider
        /// `gtk.TextBuffer.createChildAnchor` as a more convenient
        /// alternative to this function. The buffer will add a reference to
        /// the anchor, so you can unref it after insertion.
        pub const insert_child_anchor = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TextIter, p_anchor: *gtk.TextChildAnchor) void {
                return gobject.ext.as(TextBuffer.Class, p_class).f_insert_child_anchor.?(gobject.ext.as(TextBuffer, p_buffer), p_iter, p_anchor);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TextIter, p_anchor: *gtk.TextChildAnchor) callconv(.c) void) void {
                gobject.ext.as(TextBuffer.Class, p_class).f_insert_child_anchor = @ptrCast(p_implementation);
            }
        };

        /// Inserts an image into the text buffer at `iter`. The image will be
        /// counted as one character in character counts, and when obtaining
        /// the buffer contents as a string, will be represented by the Unicode
        /// “object replacement character” 0xFFFC. Note that the “slice”
        /// variants for obtaining portions of the buffer as a string include
        /// this character for pixbufs, but the “text” variants do
        /// not. e.g. see `gtk.TextBuffer.getSlice` and
        /// `gtk.TextBuffer.getText`.
        pub const insert_pixbuf = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TextIter, p_pixbuf: *gdkpixbuf.Pixbuf) void {
                return gobject.ext.as(TextBuffer.Class, p_class).f_insert_pixbuf.?(gobject.ext.as(TextBuffer, p_buffer), p_iter, p_pixbuf);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TextIter, p_pixbuf: *gdkpixbuf.Pixbuf) callconv(.c) void) void {
                gobject.ext.as(TextBuffer.Class, p_class).f_insert_pixbuf = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextBuffer.signals.insert`-text signal.
        pub const insert_text = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_pos: *gtk.TextIter, p_new_text: [*:0]const u8, p_new_text_length: c_int) void {
                return gobject.ext.as(TextBuffer.Class, p_class).f_insert_text.?(gobject.ext.as(TextBuffer, p_buffer), p_pos, p_new_text, p_new_text_length);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_pos: *gtk.TextIter, p_new_text: [*:0]const u8, p_new_text_length: c_int) callconv(.c) void) void {
                gobject.ext.as(TextBuffer.Class, p_class).f_insert_text = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextBuffer.signals.mark`-deleted signal.
        pub const mark_deleted = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_mark: *gtk.TextMark) void {
                return gobject.ext.as(TextBuffer.Class, p_class).f_mark_deleted.?(gobject.ext.as(TextBuffer, p_buffer), p_mark);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_mark: *gtk.TextMark) callconv(.c) void) void {
                gobject.ext.as(TextBuffer.Class, p_class).f_mark_deleted = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextBuffer.signals.mark`-set signal.
        pub const mark_set = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_location: *const gtk.TextIter, p_mark: *gtk.TextMark) void {
                return gobject.ext.as(TextBuffer.Class, p_class).f_mark_set.?(gobject.ext.as(TextBuffer, p_buffer), p_location, p_mark);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_location: *const gtk.TextIter, p_mark: *gtk.TextMark) callconv(.c) void) void {
                gobject.ext.as(TextBuffer.Class, p_class).f_mark_set = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextBuffer.signals.modified`-changed
        ///   signal.
        pub const modified_changed = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TextBuffer.Class, p_class).f_modified_changed.?(gobject.ext.as(TextBuffer, p_buffer));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TextBuffer.Class, p_class).f_modified_changed = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextBuffer.signals.paste`-done signal.
        pub const paste_done = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_clipboard: *gtk.Clipboard) void {
                return gobject.ext.as(TextBuffer.Class, p_class).f_paste_done.?(gobject.ext.as(TextBuffer, p_buffer), p_clipboard);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_clipboard: *gtk.Clipboard) callconv(.c) void) void {
                gobject.ext.as(TextBuffer.Class, p_class).f_paste_done = @ptrCast(p_implementation);
            }
        };

        /// Emits the “remove-tag” signal. The default handler for the signal
        /// removes all occurrences of `tag` from the given range. `start` and
        /// `end` don’t have to be in order.
        pub const remove_tag = struct {
            pub fn call(p_class: anytype, p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tag: *gtk.TextTag, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter) void {
                return gobject.ext.as(TextBuffer.Class, p_class).f_remove_tag.?(gobject.ext.as(TextBuffer, p_buffer), p_tag, p_start, p_end);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buffer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tag: *gtk.TextTag, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter) callconv(.c) void) void {
                gobject.ext.as(TextBuffer.Class, p_class).f_remove_tag = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The list of targets this buffer supports for clipboard copying
        /// and as DND source.
        pub const copy_target_list = struct {
            pub const name = "copy-target-list";

            pub const Type = ?*gtk.TargetList;
        };

        /// The position of the insert mark (as offset from the beginning
        /// of the buffer). It is useful for getting notified when the
        /// cursor moves.
        pub const cursor_position = struct {
            pub const name = "cursor-position";

            pub const Type = c_int;
        };

        /// Whether the buffer has some text currently selected.
        pub const has_selection = struct {
            pub const name = "has-selection";

            pub const Type = c_int;
        };

        /// The list of targets this buffer supports for clipboard pasting
        /// and as DND destination.
        pub const paste_target_list = struct {
            pub const name = "paste-target-list";

            pub const Type = ?*gtk.TargetList;
        };

        pub const tag_table = struct {
            pub const name = "tag-table";

            pub const Type = ?*gtk.TextTagTable;
        };

        /// The text content of the buffer. Without child widgets and images,
        /// see `gtk.TextBuffer.getText` for more information.
        pub const text = struct {
            pub const name = "text";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {
        /// The ::apply-tag signal is emitted to apply a tag to a
        /// range of text in a `gtk.TextBuffer`.
        /// Applying actually occurs in the default handler.
        ///
        /// Note that if your handler runs before the default handler it must not
        /// invalidate the `start` and `end` iters (or has to revalidate them).
        ///
        /// See also:
        /// `gtk.TextBuffer.applyTag`,
        /// `gtk.TextBuffer.insertWithTags`,
        /// `gtk.TextBuffer.insertRange`.
        pub const apply_tag = struct {
            pub const name = "apply-tag";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_tag: *gtk.TextTag, p_start: *gtk.TextIter, p_end: *gtk.TextIter, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextBuffer, p_instance))),
                    gobject.signalLookup("apply-tag", TextBuffer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::begin-user-action signal is emitted at the beginning of a single
        /// user-visible operation on a `gtk.TextBuffer`.
        ///
        /// See also:
        /// `gtk.TextBuffer.beginUserAction`,
        /// `gtk.TextBuffer.insertInteractive`,
        /// `gtk.TextBuffer.insertRangeInteractive`,
        /// `gtk.TextBuffer.deleteInteractive`,
        /// `gtk.TextBuffer.backspace`,
        /// `gtk.TextBuffer.deleteSelection`.
        pub const begin_user_action = struct {
            pub const name = "begin-user-action";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextBuffer, p_instance))),
                    gobject.signalLookup("begin-user-action", TextBuffer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::changed signal is emitted when the content of a `gtk.TextBuffer`
        /// has changed.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextBuffer, p_instance))),
                    gobject.signalLookup("changed", TextBuffer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::delete-range signal is emitted to delete a range
        /// from a `gtk.TextBuffer`.
        ///
        /// Note that if your handler runs before the default handler it must not
        /// invalidate the `start` and `end` iters (or has to revalidate them).
        /// The default signal handler revalidates the `start` and `end` iters to
        /// both point to the location where text was deleted. Handlers
        /// which run after the default handler (see `g_signal_connect_after`)
        /// do not have access to the deleted text.
        ///
        /// See also: `gtk.TextBuffer.delete`.
        pub const delete_range = struct {
            pub const name = "delete-range";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_start: *gtk.TextIter, p_end: *gtk.TextIter, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextBuffer, p_instance))),
                    gobject.signalLookup("delete-range", TextBuffer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::end-user-action signal is emitted at the end of a single
        /// user-visible operation on the `gtk.TextBuffer`.
        ///
        /// See also:
        /// `gtk.TextBuffer.endUserAction`,
        /// `gtk.TextBuffer.insertInteractive`,
        /// `gtk.TextBuffer.insertRangeInteractive`,
        /// `gtk.TextBuffer.deleteInteractive`,
        /// `gtk.TextBuffer.backspace`,
        /// `gtk.TextBuffer.deleteSelection`,
        /// `gtk.TextBuffer.backspace`.
        pub const end_user_action = struct {
            pub const name = "end-user-action";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextBuffer, p_instance))),
                    gobject.signalLookup("end-user-action", TextBuffer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::insert-child-anchor signal is emitted to insert a
        /// `gtk.TextChildAnchor` in a `gtk.TextBuffer`.
        /// Insertion actually occurs in the default handler.
        ///
        /// Note that if your handler runs before the default handler it must
        /// not invalidate the `location` iter (or has to revalidate it).
        /// The default signal handler revalidates it to be placed after the
        /// inserted `anchor`.
        ///
        /// See also: `gtk.TextBuffer.insertChildAnchor`.
        pub const insert_child_anchor = struct {
            pub const name = "insert-child-anchor";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_location: *gtk.TextIter, p_anchor: *gtk.TextChildAnchor, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextBuffer, p_instance))),
                    gobject.signalLookup("insert-child-anchor", TextBuffer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::insert-pixbuf signal is emitted to insert a `gdkpixbuf.Pixbuf`
        /// in a `gtk.TextBuffer`. Insertion actually occurs in the default handler.
        ///
        /// Note that if your handler runs before the default handler it must not
        /// invalidate the `location` iter (or has to revalidate it).
        /// The default signal handler revalidates it to be placed after the
        /// inserted `pixbuf`.
        ///
        /// See also: `gtk.TextBuffer.insertPixbuf`.
        pub const insert_pixbuf = struct {
            pub const name = "insert-pixbuf";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_location: *gtk.TextIter, p_pixbuf: *gdkpixbuf.Pixbuf, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextBuffer, p_instance))),
                    gobject.signalLookup("insert-pixbuf", TextBuffer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::insert-text signal is emitted to insert text in a `gtk.TextBuffer`.
        /// Insertion actually occurs in the default handler.
        ///
        /// Note that if your handler runs before the default handler it must not
        /// invalidate the `location` iter (or has to revalidate it).
        /// The default signal handler revalidates it to point to the end of the
        /// inserted text.
        ///
        /// See also:
        /// `gtk.TextBuffer.insert`,
        /// `gtk.TextBuffer.insertRange`.
        pub const insert_text = struct {
            pub const name = "insert-text";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_location: *gtk.TextIter, p_text: [*:0]u8, p_len: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextBuffer, p_instance))),
                    gobject.signalLookup("insert-text", TextBuffer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::mark-deleted signal is emitted as notification
        /// after a `gtk.TextMark` is deleted.
        ///
        /// See also:
        /// `gtk.TextBuffer.deleteMark`.
        pub const mark_deleted = struct {
            pub const name = "mark-deleted";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_mark: *gtk.TextMark, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextBuffer, p_instance))),
                    gobject.signalLookup("mark-deleted", TextBuffer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::mark-set signal is emitted as notification
        /// after a `gtk.TextMark` is set.
        ///
        /// See also:
        /// `gtk.TextBuffer.createMark`,
        /// `gtk.TextBuffer.moveMark`.
        pub const mark_set = struct {
            pub const name = "mark-set";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_location: *gtk.TextIter, p_mark: *gtk.TextMark, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextBuffer, p_instance))),
                    gobject.signalLookup("mark-set", TextBuffer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::modified-changed signal is emitted when the modified bit of a
        /// `gtk.TextBuffer` flips.
        ///
        /// See also:
        /// `gtk.TextBuffer.setModified`.
        pub const modified_changed = struct {
            pub const name = "modified-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextBuffer, p_instance))),
                    gobject.signalLookup("modified-changed", TextBuffer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The paste-done signal is emitted after paste operation has been completed.
        /// This is useful to properly scroll the view to the end of the pasted text.
        /// See `gtk.TextBuffer.pasteClipboard` for more details.
        pub const paste_done = struct {
            pub const name = "paste-done";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_clipboard: *gtk.Clipboard, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextBuffer, p_instance))),
                    gobject.signalLookup("paste-done", TextBuffer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::remove-tag signal is emitted to remove all occurrences of `tag` from
        /// a range of text in a `gtk.TextBuffer`.
        /// Removal actually occurs in the default handler.
        ///
        /// Note that if your handler runs before the default handler it must not
        /// invalidate the `start` and `end` iters (or has to revalidate them).
        ///
        /// See also:
        /// `gtk.TextBuffer.removeTag`.
        pub const remove_tag = struct {
            pub const name = "remove-tag";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_tag: *gtk.TextTag, p_start: *gtk.TextIter, p_end: *gtk.TextIter, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextBuffer, p_instance))),
                    gobject.signalLookup("remove-tag", TextBuffer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new text buffer.
    extern fn gtk_text_buffer_new(p_table: ?*gtk.TextTagTable) *gtk.TextBuffer;
    pub const new = gtk_text_buffer_new;

    /// Adds the mark at position `where`. The mark must not be added to
    /// another buffer, and if its name is not `NULL` then there must not
    /// be another mark in the buffer with the same name.
    ///
    /// Emits the `gtk.TextBuffer.signals.mark`-set signal as notification of the mark's
    /// initial placement.
    extern fn gtk_text_buffer_add_mark(p_buffer: *TextBuffer, p_mark: *gtk.TextMark, p_where: *const gtk.TextIter) void;
    pub const addMark = gtk_text_buffer_add_mark;

    /// Adds `clipboard` to the list of clipboards in which the selection
    /// contents of `buffer` are available. In most cases, `clipboard` will be
    /// the `gtk.Clipboard` of type `GDK_SELECTION_PRIMARY` for a view of `buffer`.
    extern fn gtk_text_buffer_add_selection_clipboard(p_buffer: *TextBuffer, p_clipboard: *gtk.Clipboard) void;
    pub const addSelectionClipboard = gtk_text_buffer_add_selection_clipboard;

    /// Emits the “apply-tag” signal on `buffer`. The default
    /// handler for the signal applies `tag` to the given range.
    /// `start` and `end` do not have to be in order.
    extern fn gtk_text_buffer_apply_tag(p_buffer: *TextBuffer, p_tag: *gtk.TextTag, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter) void;
    pub const applyTag = gtk_text_buffer_apply_tag;

    /// Calls `gtk.TextTagTable.lookup` on the buffer’s tag table to
    /// get a `gtk.TextTag`, then calls `gtk.TextBuffer.applyTag`.
    extern fn gtk_text_buffer_apply_tag_by_name(p_buffer: *TextBuffer, p_name: [*:0]const u8, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter) void;
    pub const applyTagByName = gtk_text_buffer_apply_tag_by_name;

    /// Performs the appropriate action as if the user hit the delete
    /// key with the cursor at the position specified by `iter`. In the
    /// normal case a single character will be deleted, but when
    /// combining accents are involved, more than one character can
    /// be deleted, and when precomposed character and accent combinations
    /// are involved, less than one character will be deleted.
    ///
    /// Because the buffer is modified, all outstanding iterators become
    /// invalid after calling this function; however, the `iter` will be
    /// re-initialized to point to the location where text was deleted.
    extern fn gtk_text_buffer_backspace(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_interactive: c_int, p_default_editable: c_int) c_int;
    pub const backspace = gtk_text_buffer_backspace;

    /// Called to indicate that the buffer operations between here and a
    /// call to `gtk.TextBuffer.endUserAction` are part of a single
    /// user-visible operation. The operations between
    /// `gtk.TextBuffer.beginUserAction` and
    /// `gtk.TextBuffer.endUserAction` can then be grouped when creating
    /// an undo stack. `gtk.TextBuffer` maintains a count of calls to
    /// `gtk.TextBuffer.beginUserAction` that have not been closed with
    /// a call to `gtk.TextBuffer.endUserAction`, and emits the
    /// “begin-user-action” and “end-user-action” signals only for the
    /// outermost pair of calls. This allows you to build user actions
    /// from other user actions.
    ///
    /// The “interactive” buffer mutation functions, such as
    /// `gtk.TextBuffer.insertInteractive`, automatically call begin/end
    /// user action around the buffer operations they perform, so there's
    /// no need to add extra calls if you user action consists solely of a
    /// single call to one of those functions.
    extern fn gtk_text_buffer_begin_user_action(p_buffer: *TextBuffer) void;
    pub const beginUserAction = gtk_text_buffer_begin_user_action;

    /// Copies the currently-selected text to a clipboard.
    extern fn gtk_text_buffer_copy_clipboard(p_buffer: *TextBuffer, p_clipboard: *gtk.Clipboard) void;
    pub const copyClipboard = gtk_text_buffer_copy_clipboard;

    /// This is a convenience function which simply creates a child anchor
    /// with `gtk.TextChildAnchor.new` and inserts it into the buffer
    /// with `gtk.TextBuffer.insertChildAnchor`. The new anchor is
    /// owned by the buffer; no reference count is returned to
    /// the caller of `gtk.TextBuffer.createChildAnchor`.
    extern fn gtk_text_buffer_create_child_anchor(p_buffer: *TextBuffer, p_iter: *gtk.TextIter) *gtk.TextChildAnchor;
    pub const createChildAnchor = gtk_text_buffer_create_child_anchor;

    /// Creates a mark at position `where`. If `mark_name` is `NULL`, the mark
    /// is anonymous; otherwise, the mark can be retrieved by name using
    /// `gtk.TextBuffer.getMark`. If a mark has left gravity, and text is
    /// inserted at the mark’s current location, the mark will be moved to
    /// the left of the newly-inserted text. If the mark has right gravity
    /// (`left_gravity` = `FALSE`), the mark will end up on the right of
    /// newly-inserted text. The standard left-to-right cursor is a mark
    /// with right gravity (when you type, the cursor stays on the right
    /// side of the text you’re typing).
    ///
    /// The caller of this function does not own a
    /// reference to the returned `gtk.TextMark`, so you can ignore the
    /// return value if you like. Marks are owned by the buffer and go
    /// away when the buffer does.
    ///
    /// Emits the `gtk.TextBuffer.signals.mark`-set signal as notification of the mark's
    /// initial placement.
    extern fn gtk_text_buffer_create_mark(p_buffer: *TextBuffer, p_mark_name: ?[*:0]const u8, p_where: *const gtk.TextIter, p_left_gravity: c_int) *gtk.TextMark;
    pub const createMark = gtk_text_buffer_create_mark;

    /// Creates a tag and adds it to the tag table for `buffer`.
    /// Equivalent to calling `gtk.TextTag.new` and then adding the
    /// tag to the buffer’s tag table. The returned tag is owned by
    /// the buffer’s tag table, so the ref count will be equal to one.
    ///
    /// If `tag_name` is `NULL`, the tag is anonymous.
    ///
    /// If `tag_name` is non-`NULL`, a tag called `tag_name` must not already
    /// exist in the tag table for this buffer.
    ///
    /// The `first_property_name` argument and subsequent arguments are a list
    /// of properties to set on the tag, as with `gobject.Object.set`.
    extern fn gtk_text_buffer_create_tag(p_buffer: *TextBuffer, p_tag_name: ?[*:0]const u8, p_first_property_name: ?[*:0]const u8, ...) *gtk.TextTag;
    pub const createTag = gtk_text_buffer_create_tag;

    /// Copies the currently-selected text to a clipboard, then deletes
    /// said text if it’s editable.
    extern fn gtk_text_buffer_cut_clipboard(p_buffer: *TextBuffer, p_clipboard: *gtk.Clipboard, p_default_editable: c_int) void;
    pub const cutClipboard = gtk_text_buffer_cut_clipboard;

    /// Deletes text between `start` and `end`. The order of `start` and `end`
    /// is not actually relevant; `gtk.TextBuffer.delete` will reorder
    /// them. This function actually emits the “delete-range” signal, and
    /// the default handler of that signal deletes the text. Because the
    /// buffer is modified, all outstanding iterators become invalid after
    /// calling this function; however, the `start` and `end` will be
    /// re-initialized to point to the location where text was deleted.
    extern fn gtk_text_buffer_delete(p_buffer: *TextBuffer, p_start: *gtk.TextIter, p_end: *gtk.TextIter) void;
    pub const delete = gtk_text_buffer_delete;

    /// Deletes all editable text in the given range.
    /// Calls `gtk.TextBuffer.delete` for each editable sub-range of
    /// [`start`,`end`). `start` and `end` are revalidated to point to
    /// the location of the last deleted range, or left untouched if
    /// no text was deleted.
    extern fn gtk_text_buffer_delete_interactive(p_buffer: *TextBuffer, p_start_iter: *gtk.TextIter, p_end_iter: *gtk.TextIter, p_default_editable: c_int) c_int;
    pub const deleteInteractive = gtk_text_buffer_delete_interactive;

    /// Deletes `mark`, so that it’s no longer located anywhere in the
    /// buffer. Removes the reference the buffer holds to the mark, so if
    /// you haven’t called `gobject.Object.ref` on the mark, it will be freed. Even
    /// if the mark isn’t freed, most operations on `mark` become
    /// invalid, until it gets added to a buffer again with
    /// `gtk.TextBuffer.addMark`. Use `gtk.TextMark.getDeleted` to
    /// find out if a mark has been removed from its buffer.
    /// The `gtk.TextBuffer.signals.mark`-deleted signal will be emitted as notification after
    /// the mark is deleted.
    extern fn gtk_text_buffer_delete_mark(p_buffer: *TextBuffer, p_mark: *gtk.TextMark) void;
    pub const deleteMark = gtk_text_buffer_delete_mark;

    /// Deletes the mark named `name`; the mark must exist. See
    /// `gtk.TextBuffer.deleteMark` for details.
    extern fn gtk_text_buffer_delete_mark_by_name(p_buffer: *TextBuffer, p_name: [*:0]const u8) void;
    pub const deleteMarkByName = gtk_text_buffer_delete_mark_by_name;

    /// Deletes the range between the “insert” and “selection_bound” marks,
    /// that is, the currently-selected text. If `interactive` is `TRUE`,
    /// the editability of the selection will be considered (users can’t delete
    /// uneditable text).
    extern fn gtk_text_buffer_delete_selection(p_buffer: *TextBuffer, p_interactive: c_int, p_default_editable: c_int) c_int;
    pub const deleteSelection = gtk_text_buffer_delete_selection;

    /// This function deserializes rich text in format `format` and inserts
    /// it at `iter`.
    ///
    /// `formats` to be used must be registered using
    /// `gtk.TextBuffer.registerDeserializeFormat` or
    /// `gtk.TextBuffer.registerDeserializeTagset` beforehand.
    extern fn gtk_text_buffer_deserialize(p_register_buffer: *TextBuffer, p_content_buffer: *gtk.TextBuffer, p_format: gdk.Atom, p_iter: *gtk.TextIter, p_data: [*]const u8, p_length: usize, p_error: ?*?*glib.Error) c_int;
    pub const deserialize = gtk_text_buffer_deserialize;

    /// This functions returns the value set with
    /// `gtk.TextBuffer.deserializeSetCanCreateTags`
    extern fn gtk_text_buffer_deserialize_get_can_create_tags(p_buffer: *TextBuffer, p_format: gdk.Atom) c_int;
    pub const deserializeGetCanCreateTags = gtk_text_buffer_deserialize_get_can_create_tags;

    /// Use this function to allow a rich text deserialization function to
    /// create new tags in the receiving buffer. Note that using this
    /// function is almost always a bad idea, because the rich text
    /// functions you register should know how to map the rich text format
    /// they handler to your text buffers set of tags.
    ///
    /// The ability of creating new (arbitrary!) tags in the receiving buffer
    /// is meant for special rich text formats like the internal one that
    /// is registered using `gtk.TextBuffer.registerDeserializeTagset`,
    /// because that format is essentially a dump of the internal structure
    /// of the source buffer, including its tag names.
    ///
    /// You should allow creation of tags only if you know what you are
    /// doing, e.g. if you defined a tagset name for your application
    /// suite’s text buffers and you know that it’s fine to receive new
    /// tags from these buffers, because you know that your application can
    /// handle the newly created tags.
    extern fn gtk_text_buffer_deserialize_set_can_create_tags(p_buffer: *TextBuffer, p_format: gdk.Atom, p_can_create_tags: c_int) void;
    pub const deserializeSetCanCreateTags = gtk_text_buffer_deserialize_set_can_create_tags;

    /// Should be paired with a call to `gtk.TextBuffer.beginUserAction`.
    /// See that function for a full explanation.
    extern fn gtk_text_buffer_end_user_action(p_buffer: *TextBuffer) void;
    pub const endUserAction = gtk_text_buffer_end_user_action;

    /// Retrieves the first and last iterators in the buffer, i.e. the
    /// entire buffer lies within the range [`start`,`end`).
    extern fn gtk_text_buffer_get_bounds(p_buffer: *TextBuffer, p_start: *gtk.TextIter, p_end: *gtk.TextIter) void;
    pub const getBounds = gtk_text_buffer_get_bounds;

    /// Gets the number of characters in the buffer; note that characters
    /// and bytes are not the same, you can’t e.g. expect the contents of
    /// the buffer in string form to be this many bytes long. The character
    /// count is cached, so this function is very fast.
    extern fn gtk_text_buffer_get_char_count(p_buffer: *TextBuffer) c_int;
    pub const getCharCount = gtk_text_buffer_get_char_count;

    /// This function returns the list of targets this text buffer can
    /// provide for copying and as DND source. The targets in the list are
    /// added with `info` values from the `gtk.TextBufferTargetInfo` enum,
    /// using `gtk.TargetList.addRichTextTargets` and
    /// `gtk.TargetList.addTextTargets`.
    extern fn gtk_text_buffer_get_copy_target_list(p_buffer: *TextBuffer) *gtk.TargetList;
    pub const getCopyTargetList = gtk_text_buffer_get_copy_target_list;

    /// This function returns the rich text deserialize formats registered
    /// with `buffer` using `gtk.TextBuffer.registerDeserializeFormat` or
    /// `gtk.TextBuffer.registerDeserializeTagset`
    extern fn gtk_text_buffer_get_deserialize_formats(p_buffer: *TextBuffer, p_n_formats: *c_int) [*]gdk.Atom;
    pub const getDeserializeFormats = gtk_text_buffer_get_deserialize_formats;

    /// Initializes `iter` with the “end iterator,” one past the last valid
    /// character in the text buffer. If dereferenced with
    /// `gtk.TextIter.getChar`, the end iterator has a character value of 0.
    /// The entire buffer lies in the range from the first position in
    /// the buffer (call `gtk.TextBuffer.getStartIter` to get
    /// character position 0) to the end iterator.
    extern fn gtk_text_buffer_get_end_iter(p_buffer: *TextBuffer, p_iter: *gtk.TextIter) void;
    pub const getEndIter = gtk_text_buffer_get_end_iter;

    /// Indicates whether the buffer has some text currently selected.
    extern fn gtk_text_buffer_get_has_selection(p_buffer: *TextBuffer) c_int;
    pub const getHasSelection = gtk_text_buffer_get_has_selection;

    /// Returns the mark that represents the cursor (insertion point).
    /// Equivalent to calling `gtk.TextBuffer.getMark` to get the mark
    /// named “insert”, but very slightly more efficient, and involves less
    /// typing.
    extern fn gtk_text_buffer_get_insert(p_buffer: *TextBuffer) *gtk.TextMark;
    pub const getInsert = gtk_text_buffer_get_insert;

    /// Obtains the location of `anchor` within `buffer`.
    extern fn gtk_text_buffer_get_iter_at_child_anchor(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_anchor: *gtk.TextChildAnchor) void;
    pub const getIterAtChildAnchor = gtk_text_buffer_get_iter_at_child_anchor;

    /// Initializes `iter` to the start of the given line. If `line_number` is greater
    /// than the number of lines in the `buffer`, the end iterator is returned.
    extern fn gtk_text_buffer_get_iter_at_line(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_line_number: c_int) void;
    pub const getIterAtLine = gtk_text_buffer_get_iter_at_line;

    /// Obtains an iterator pointing to `byte_index` within the given line.
    /// `byte_index` must be the start of a UTF-8 character. Note bytes, not
    /// characters; UTF-8 may encode one character as multiple bytes.
    ///
    /// Before the 3.20 version, it was not allowed to pass an invalid location.
    ///
    /// Since the 3.20 version, if `line_number` is greater than the number of lines
    /// in the `buffer`, the end iterator is returned. And if `byte_index` is off the
    /// end of the line, the iterator at the end of the line is returned.
    extern fn gtk_text_buffer_get_iter_at_line_index(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_line_number: c_int, p_byte_index: c_int) void;
    pub const getIterAtLineIndex = gtk_text_buffer_get_iter_at_line_index;

    /// Obtains an iterator pointing to `char_offset` within the given line. Note
    /// characters, not bytes; UTF-8 may encode one character as multiple bytes.
    ///
    /// Before the 3.20 version, it was not allowed to pass an invalid location.
    ///
    /// Since the 3.20 version, if `line_number` is greater than the number of lines
    /// in the `buffer`, the end iterator is returned. And if `char_offset` is off the
    /// end of the line, the iterator at the end of the line is returned.
    extern fn gtk_text_buffer_get_iter_at_line_offset(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_line_number: c_int, p_char_offset: c_int) void;
    pub const getIterAtLineOffset = gtk_text_buffer_get_iter_at_line_offset;

    /// Initializes `iter` with the current position of `mark`.
    extern fn gtk_text_buffer_get_iter_at_mark(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_mark: *gtk.TextMark) void;
    pub const getIterAtMark = gtk_text_buffer_get_iter_at_mark;

    /// Initializes `iter` to a position `char_offset` chars from the start
    /// of the entire buffer. If `char_offset` is -1 or greater than the number
    /// of characters in the buffer, `iter` is initialized to the end iterator,
    /// the iterator one past the last valid character in the buffer.
    extern fn gtk_text_buffer_get_iter_at_offset(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_char_offset: c_int) void;
    pub const getIterAtOffset = gtk_text_buffer_get_iter_at_offset;

    /// Obtains the number of lines in the buffer. This value is cached, so
    /// the function is very fast.
    extern fn gtk_text_buffer_get_line_count(p_buffer: *TextBuffer) c_int;
    pub const getLineCount = gtk_text_buffer_get_line_count;

    /// Returns the mark named `name` in buffer `buffer`, or `NULL` if no such
    /// mark exists in the buffer.
    extern fn gtk_text_buffer_get_mark(p_buffer: *TextBuffer, p_name: [*:0]const u8) ?*gtk.TextMark;
    pub const getMark = gtk_text_buffer_get_mark;

    /// Indicates whether the buffer has been modified since the last call
    /// to `gtk.TextBuffer.setModified` set the modification flag to
    /// `FALSE`. Used for example to enable a “save” function in a text
    /// editor.
    extern fn gtk_text_buffer_get_modified(p_buffer: *TextBuffer) c_int;
    pub const getModified = gtk_text_buffer_get_modified;

    /// This function returns the list of targets this text buffer supports
    /// for pasting and as DND destination. The targets in the list are
    /// added with `info` values from the `gtk.TextBufferTargetInfo` enum,
    /// using `gtk.TargetList.addRichTextTargets` and
    /// `gtk.TargetList.addTextTargets`.
    extern fn gtk_text_buffer_get_paste_target_list(p_buffer: *TextBuffer) *gtk.TargetList;
    pub const getPasteTargetList = gtk_text_buffer_get_paste_target_list;

    /// Returns the mark that represents the selection bound.  Equivalent
    /// to calling `gtk.TextBuffer.getMark` to get the mark named
    /// “selection_bound”, but very slightly more efficient, and involves
    /// less typing.
    ///
    /// The currently-selected text in `buffer` is the region between the
    /// “selection_bound” and “insert” marks. If “selection_bound” and
    /// “insert” are in the same place, then there is no current selection.
    /// `gtk.TextBuffer.getSelectionBounds` is another convenient function
    /// for handling the selection, if you just want to know whether there’s a
    /// selection and what its bounds are.
    extern fn gtk_text_buffer_get_selection_bound(p_buffer: *TextBuffer) *gtk.TextMark;
    pub const getSelectionBound = gtk_text_buffer_get_selection_bound;

    /// Returns `TRUE` if some text is selected; places the bounds
    /// of the selection in `start` and `end` (if the selection has length 0,
    /// then `start` and `end` are filled in with the same value).
    /// `start` and `end` will be in ascending order. If `start` and `end` are
    /// NULL, then they are not filled in, but the return value still indicates
    /// whether text is selected.
    extern fn gtk_text_buffer_get_selection_bounds(p_buffer: *TextBuffer, p_start: *gtk.TextIter, p_end: *gtk.TextIter) c_int;
    pub const getSelectionBounds = gtk_text_buffer_get_selection_bounds;

    /// This function returns the rich text serialize formats registered
    /// with `buffer` using `gtk.TextBuffer.registerSerializeFormat` or
    /// `gtk.TextBuffer.registerSerializeTagset`
    extern fn gtk_text_buffer_get_serialize_formats(p_buffer: *TextBuffer, p_n_formats: *c_int) [*]gdk.Atom;
    pub const getSerializeFormats = gtk_text_buffer_get_serialize_formats;

    /// Returns the text in the range [`start`,`end`). Excludes undisplayed
    /// text (text marked with tags that set the invisibility attribute) if
    /// `include_hidden_chars` is `FALSE`. The returned string includes a
    /// 0xFFFC character whenever the buffer contains
    /// embedded images, so byte and character indexes into
    /// the returned string do correspond to byte
    /// and character indexes into the buffer. Contrast with
    /// `gtk.TextBuffer.getText`. Note that 0xFFFC can occur in normal
    /// text as well, so it is not a reliable indicator that a pixbuf or
    /// widget is in the buffer.
    extern fn gtk_text_buffer_get_slice(p_buffer: *TextBuffer, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter, p_include_hidden_chars: c_int) [*:0]u8;
    pub const getSlice = gtk_text_buffer_get_slice;

    /// Initialized `iter` with the first position in the text buffer. This
    /// is the same as using `gtk.TextBuffer.getIterAtOffset` to get
    /// the iter at character offset 0.
    extern fn gtk_text_buffer_get_start_iter(p_buffer: *TextBuffer, p_iter: *gtk.TextIter) void;
    pub const getStartIter = gtk_text_buffer_get_start_iter;

    /// Get the `gtk.TextTagTable` associated with this buffer.
    extern fn gtk_text_buffer_get_tag_table(p_buffer: *TextBuffer) *gtk.TextTagTable;
    pub const getTagTable = gtk_text_buffer_get_tag_table;

    /// Returns the text in the range [`start`,`end`). Excludes undisplayed
    /// text (text marked with tags that set the invisibility attribute) if
    /// `include_hidden_chars` is `FALSE`. Does not include characters
    /// representing embedded images, so byte and character indexes into
    /// the returned string do not correspond to byte
    /// and character indexes into the buffer. Contrast with
    /// `gtk.TextBuffer.getSlice`.
    extern fn gtk_text_buffer_get_text(p_buffer: *TextBuffer, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter, p_include_hidden_chars: c_int) [*:0]u8;
    pub const getText = gtk_text_buffer_get_text;

    /// Inserts `len` bytes of `text` at position `iter`.  If `len` is -1,
    /// `text` must be nul-terminated and will be inserted in its
    /// entirety. Emits the “insert-text” signal; insertion actually occurs
    /// in the default handler for the signal. `iter` is invalidated when
    /// insertion occurs (because the buffer contents change), but the
    /// default signal handler revalidates it to point to the end of the
    /// inserted text.
    extern fn gtk_text_buffer_insert(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_text: [*:0]const u8, p_len: c_int) void;
    pub const insert = gtk_text_buffer_insert;

    /// Simply calls `gtk.TextBuffer.insert`, using the current
    /// cursor position as the insertion point.
    extern fn gtk_text_buffer_insert_at_cursor(p_buffer: *TextBuffer, p_text: [*:0]const u8, p_len: c_int) void;
    pub const insertAtCursor = gtk_text_buffer_insert_at_cursor;

    /// Inserts a child widget anchor into the text buffer at `iter`. The
    /// anchor will be counted as one character in character counts, and
    /// when obtaining the buffer contents as a string, will be represented
    /// by the Unicode “object replacement character” 0xFFFC. Note that the
    /// “slice” variants for obtaining portions of the buffer as a string
    /// include this character for child anchors, but the “text” variants do
    /// not. E.g. see `gtk.TextBuffer.getSlice` and
    /// `gtk.TextBuffer.getText`. Consider
    /// `gtk.TextBuffer.createChildAnchor` as a more convenient
    /// alternative to this function. The buffer will add a reference to
    /// the anchor, so you can unref it after insertion.
    extern fn gtk_text_buffer_insert_child_anchor(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_anchor: *gtk.TextChildAnchor) void;
    pub const insertChildAnchor = gtk_text_buffer_insert_child_anchor;

    /// Like `gtk.TextBuffer.insert`, but the insertion will not occur if
    /// `iter` is at a non-editable location in the buffer. Usually you
    /// want to prevent insertions at ineditable locations if the insertion
    /// results from a user action (is interactive).
    ///
    /// `default_editable` indicates the editability of text that doesn't
    /// have a tag affecting editability applied to it. Typically the
    /// result of `gtk.TextView.getEditable` is appropriate here.
    extern fn gtk_text_buffer_insert_interactive(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_text: [*:0]const u8, p_len: c_int, p_default_editable: c_int) c_int;
    pub const insertInteractive = gtk_text_buffer_insert_interactive;

    /// Calls `gtk.TextBuffer.insertInteractive` at the cursor
    /// position.
    ///
    /// `default_editable` indicates the editability of text that doesn't
    /// have a tag affecting editability applied to it. Typically the
    /// result of `gtk.TextView.getEditable` is appropriate here.
    extern fn gtk_text_buffer_insert_interactive_at_cursor(p_buffer: *TextBuffer, p_text: [*:0]const u8, p_len: c_int, p_default_editable: c_int) c_int;
    pub const insertInteractiveAtCursor = gtk_text_buffer_insert_interactive_at_cursor;

    /// Inserts the text in `markup` at position `iter`. `markup` will be inserted
    /// in its entirety and must be nul-terminated and valid UTF-8. Emits the
    /// `gtk.TextBuffer.signals.insert`-text signal, possibly multiple times; insertion
    /// actually occurs in the default handler for the signal. `iter` will point
    /// to the end of the inserted text on return.
    extern fn gtk_text_buffer_insert_markup(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_markup: [*:0]const u8, p_len: c_int) void;
    pub const insertMarkup = gtk_text_buffer_insert_markup;

    /// Inserts an image into the text buffer at `iter`. The image will be
    /// counted as one character in character counts, and when obtaining
    /// the buffer contents as a string, will be represented by the Unicode
    /// “object replacement character” 0xFFFC. Note that the “slice”
    /// variants for obtaining portions of the buffer as a string include
    /// this character for pixbufs, but the “text” variants do
    /// not. e.g. see `gtk.TextBuffer.getSlice` and
    /// `gtk.TextBuffer.getText`.
    extern fn gtk_text_buffer_insert_pixbuf(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_pixbuf: *gdkpixbuf.Pixbuf) void;
    pub const insertPixbuf = gtk_text_buffer_insert_pixbuf;

    /// Copies text, tags, and pixbufs between `start` and `end` (the order
    /// of `start` and `end` doesn’t matter) and inserts the copy at `iter`.
    /// Used instead of simply getting/inserting text because it preserves
    /// images and tags. If `start` and `end` are in a different buffer from
    /// `buffer`, the two buffers must share the same tag table.
    ///
    /// Implemented via emissions of the insert_text and apply_tag signals,
    /// so expect those.
    extern fn gtk_text_buffer_insert_range(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter) void;
    pub const insertRange = gtk_text_buffer_insert_range;

    /// Same as `gtk.TextBuffer.insertRange`, but does nothing if the
    /// insertion point isn’t editable. The `default_editable` parameter
    /// indicates whether the text is editable at `iter` if no tags
    /// enclosing `iter` affect editability. Typically the result of
    /// `gtk.TextView.getEditable` is appropriate here.
    extern fn gtk_text_buffer_insert_range_interactive(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter, p_default_editable: c_int) c_int;
    pub const insertRangeInteractive = gtk_text_buffer_insert_range_interactive;

    /// Inserts `text` into `buffer` at `iter`, applying the list of tags to
    /// the newly-inserted text. The last tag specified must be `NULL` to
    /// terminate the list. Equivalent to calling `gtk.TextBuffer.insert`,
    /// then `gtk.TextBuffer.applyTag` on the inserted text;
    /// `gtk.TextBuffer.insertWithTags` is just a convenience function.
    extern fn gtk_text_buffer_insert_with_tags(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_text: [*:0]const u8, p_len: c_int, p_first_tag: *gtk.TextTag, ...) void;
    pub const insertWithTags = gtk_text_buffer_insert_with_tags;

    /// Same as `gtk.TextBuffer.insertWithTags`, but allows you
    /// to pass in tag names instead of tag objects.
    extern fn gtk_text_buffer_insert_with_tags_by_name(p_buffer: *TextBuffer, p_iter: *gtk.TextIter, p_text: [*:0]const u8, p_len: c_int, p_first_tag_name: [*:0]const u8, ...) void;
    pub const insertWithTagsByName = gtk_text_buffer_insert_with_tags_by_name;

    /// Moves `mark` to the new location `where`. Emits the `gtk.TextBuffer.signals.mark`-set
    /// signal as notification of the move.
    extern fn gtk_text_buffer_move_mark(p_buffer: *TextBuffer, p_mark: *gtk.TextMark, p_where: *const gtk.TextIter) void;
    pub const moveMark = gtk_text_buffer_move_mark;

    /// Moves the mark named `name` (which must exist) to location `where`.
    /// See `gtk.TextBuffer.moveMark` for details.
    extern fn gtk_text_buffer_move_mark_by_name(p_buffer: *TextBuffer, p_name: [*:0]const u8, p_where: *const gtk.TextIter) void;
    pub const moveMarkByName = gtk_text_buffer_move_mark_by_name;

    /// Pastes the contents of a clipboard. If `override_location` is `NULL`, the
    /// pasted text will be inserted at the cursor position, or the buffer selection
    /// will be replaced if the selection is non-empty.
    ///
    /// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
    /// return, and at some point later after the main loop runs, the paste data will
    /// be inserted.
    extern fn gtk_text_buffer_paste_clipboard(p_buffer: *TextBuffer, p_clipboard: *gtk.Clipboard, p_override_location: ?*gtk.TextIter, p_default_editable: c_int) void;
    pub const pasteClipboard = gtk_text_buffer_paste_clipboard;

    /// This function moves the “insert” and “selection_bound” marks
    /// simultaneously.  If you move them to the same place in two steps
    /// with `gtk.TextBuffer.moveMark`, you will temporarily select a
    /// region in between their old and new locations, which can be pretty
    /// inefficient since the temporarily-selected region will force stuff
    /// to be recalculated. This function moves them as a unit, which can
    /// be optimized.
    extern fn gtk_text_buffer_place_cursor(p_buffer: *TextBuffer, p_where: *const gtk.TextIter) void;
    pub const placeCursor = gtk_text_buffer_place_cursor;

    /// This function registers a rich text deserialization `function` along with
    /// its `mime_type` with the passed `buffer`.
    extern fn gtk_text_buffer_register_deserialize_format(p_buffer: *TextBuffer, p_mime_type: [*:0]const u8, p_function: gtk.TextBufferDeserializeFunc, p_user_data: ?*anyopaque, p_user_data_destroy: ?glib.DestroyNotify) gdk.Atom;
    pub const registerDeserializeFormat = gtk_text_buffer_register_deserialize_format;

    /// This function registers GTK+’s internal rich text serialization
    /// format with the passed `buffer`. See
    /// `gtk.TextBuffer.registerSerializeTagset` for details.
    extern fn gtk_text_buffer_register_deserialize_tagset(p_buffer: *TextBuffer, p_tagset_name: ?[*:0]const u8) gdk.Atom;
    pub const registerDeserializeTagset = gtk_text_buffer_register_deserialize_tagset;

    /// This function registers a rich text serialization `function` along with
    /// its `mime_type` with the passed `buffer`.
    extern fn gtk_text_buffer_register_serialize_format(p_buffer: *TextBuffer, p_mime_type: [*:0]const u8, p_function: gtk.TextBufferSerializeFunc, p_user_data: ?*anyopaque, p_user_data_destroy: ?glib.DestroyNotify) gdk.Atom;
    pub const registerSerializeFormat = gtk_text_buffer_register_serialize_format;

    /// This function registers GTK+’s internal rich text serialization
    /// format with the passed `buffer`. The internal format does not comply
    /// to any standard rich text format and only works between `gtk.TextBuffer`
    /// instances. It is capable of serializing all of a text buffer’s tags
    /// and embedded pixbufs.
    ///
    /// This function is just a wrapper around
    /// `gtk.TextBuffer.registerSerializeFormat`. The mime type used
    /// for registering is “application/x-gtk-text-buffer-rich-text”, or
    /// “application/x-gtk-text-buffer-rich-text;format=`tagset_name`” if a
    /// `tagset_name` was passed.
    ///
    /// The `tagset_name` can be used to restrict the transfer of rich text
    /// to buffers with compatible sets of tags, in order to avoid unknown
    /// tags from being pasted. It is probably the common case to pass an
    /// identifier != `NULL` here, since the `NULL` tagset requires the
    /// receiving buffer to deal with with pasting of arbitrary tags.
    extern fn gtk_text_buffer_register_serialize_tagset(p_buffer: *TextBuffer, p_tagset_name: ?[*:0]const u8) gdk.Atom;
    pub const registerSerializeTagset = gtk_text_buffer_register_serialize_tagset;

    /// Removes all tags in the range between `start` and `end`.  Be careful
    /// with this function; it could remove tags added in code unrelated to
    /// the code you’re currently writing. That is, using this function is
    /// probably a bad idea if you have two or more unrelated code sections
    /// that add tags.
    extern fn gtk_text_buffer_remove_all_tags(p_buffer: *TextBuffer, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter) void;
    pub const removeAllTags = gtk_text_buffer_remove_all_tags;

    /// Removes a `gtk.Clipboard` added with
    /// `gtk.TextBuffer.addSelectionClipboard`.
    extern fn gtk_text_buffer_remove_selection_clipboard(p_buffer: *TextBuffer, p_clipboard: *gtk.Clipboard) void;
    pub const removeSelectionClipboard = gtk_text_buffer_remove_selection_clipboard;

    /// Emits the “remove-tag” signal. The default handler for the signal
    /// removes all occurrences of `tag` from the given range. `start` and
    /// `end` don’t have to be in order.
    extern fn gtk_text_buffer_remove_tag(p_buffer: *TextBuffer, p_tag: *gtk.TextTag, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter) void;
    pub const removeTag = gtk_text_buffer_remove_tag;

    /// Calls `gtk.TextTagTable.lookup` on the buffer’s tag table to
    /// get a `gtk.TextTag`, then calls `gtk.TextBuffer.removeTag`.
    extern fn gtk_text_buffer_remove_tag_by_name(p_buffer: *TextBuffer, p_name: [*:0]const u8, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter) void;
    pub const removeTagByName = gtk_text_buffer_remove_tag_by_name;

    /// This function moves the “insert” and “selection_bound” marks
    /// simultaneously.  If you move them in two steps
    /// with `gtk.TextBuffer.moveMark`, you will temporarily select a
    /// region in between their old and new locations, which can be pretty
    /// inefficient since the temporarily-selected region will force stuff
    /// to be recalculated. This function moves them as a unit, which can
    /// be optimized.
    extern fn gtk_text_buffer_select_range(p_buffer: *TextBuffer, p_ins: *const gtk.TextIter, p_bound: *const gtk.TextIter) void;
    pub const selectRange = gtk_text_buffer_select_range;

    /// This function serializes the portion of text between `start`
    /// and `end` in the rich text format represented by `format`.
    ///
    /// `formats` to be used must be registered using
    /// `gtk.TextBuffer.registerSerializeFormat` or
    /// `gtk.TextBuffer.registerSerializeTagset` beforehand.
    extern fn gtk_text_buffer_serialize(p_register_buffer: *TextBuffer, p_content_buffer: *gtk.TextBuffer, p_format: gdk.Atom, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter, p_length: *usize) [*]u8;
    pub const serialize = gtk_text_buffer_serialize;

    /// Used to keep track of whether the buffer has been modified since the
    /// last time it was saved. Whenever the buffer is saved to disk, call
    /// gtk_text_buffer_set_modified (`buffer`, FALSE). When the buffer is modified,
    /// it will automatically toggled on the modified bit again. When the modified
    /// bit flips, the buffer emits the `gtk.TextBuffer.signals.modified`-changed signal.
    extern fn gtk_text_buffer_set_modified(p_buffer: *TextBuffer, p_setting: c_int) void;
    pub const setModified = gtk_text_buffer_set_modified;

    /// Deletes current contents of `buffer`, and inserts `text` instead. If
    /// `len` is -1, `text` must be nul-terminated. `text` must be valid UTF-8.
    extern fn gtk_text_buffer_set_text(p_buffer: *TextBuffer, p_text: [*:0]const u8, p_len: c_int) void;
    pub const setText = gtk_text_buffer_set_text;

    /// This function unregisters a rich text format that was previously
    /// registered using `gtk.TextBuffer.registerDeserializeFormat` or
    /// `gtk.TextBuffer.registerDeserializeTagset`.
    extern fn gtk_text_buffer_unregister_deserialize_format(p_buffer: *TextBuffer, p_format: gdk.Atom) void;
    pub const unregisterDeserializeFormat = gtk_text_buffer_unregister_deserialize_format;

    /// This function unregisters a rich text format that was previously
    /// registered using `gtk.TextBuffer.registerSerializeFormat` or
    /// `gtk.TextBuffer.registerSerializeTagset`
    extern fn gtk_text_buffer_unregister_serialize_format(p_buffer: *TextBuffer, p_format: gdk.Atom) void;
    pub const unregisterSerializeFormat = gtk_text_buffer_unregister_serialize_format;

    extern fn gtk_text_buffer_get_type() usize;
    pub const getGObjectType = gtk_text_buffer_get_type;

    extern fn g_object_ref(p_self: *gtk.TextBuffer) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TextBuffer) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TextBuffer, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextCellAccessible = extern struct {
    pub const Parent = gtk.RendererCellAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.TableCell, atk.Text };
    pub const Class = gtk.TextCellAccessibleClass;
    f_parent: gtk.RendererCellAccessible,
    f_priv: ?*gtk.TextCellAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_text_cell_accessible_get_type() usize;
    pub const getGObjectType = gtk_text_cell_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.TextCellAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TextCellAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TextCellAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.TextChildAnchor` is a spot in the buffer where child widgets can
/// be “anchored” (inserted inline, as if they were characters). The anchor
/// can have multiple widgets anchored, to allow for multiple views.
pub const TextChildAnchor = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.TextChildAnchorClass;
    f_parent_instance: gobject.Object,
    f_segment: ?*anyopaque,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.TextChildAnchor`. Usually you would then insert
    /// it into a `gtk.TextBuffer` with `gtk.TextBuffer.insertChildAnchor`.
    /// To perform the creation and insertion in one step, use the
    /// convenience function `gtk.TextBuffer.createChildAnchor`.
    extern fn gtk_text_child_anchor_new() *gtk.TextChildAnchor;
    pub const new = gtk_text_child_anchor_new;

    /// Determines whether a child anchor has been deleted from
    /// the buffer. Keep in mind that the child anchor will be
    /// unreferenced when removed from the buffer, so you need to
    /// hold your own reference (with `gobject.Object.ref`) if you plan
    /// to use this function — otherwise all deleted child anchors
    /// will also be finalized.
    extern fn gtk_text_child_anchor_get_deleted(p_anchor: *TextChildAnchor) c_int;
    pub const getDeleted = gtk_text_child_anchor_get_deleted;

    /// Gets a list of all widgets anchored at this child anchor.
    /// The returned list should be freed with `glib.List.free`.
    extern fn gtk_text_child_anchor_get_widgets(p_anchor: *TextChildAnchor) *glib.List;
    pub const getWidgets = gtk_text_child_anchor_get_widgets;

    extern fn gtk_text_child_anchor_get_type() usize;
    pub const getGObjectType = gtk_text_child_anchor_get_type;

    extern fn g_object_ref(p_self: *gtk.TextChildAnchor) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TextChildAnchor) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TextChildAnchor, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// You may wish to begin by reading the
/// [text widget conceptual overview](TextWidget.html)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
///
/// A `gtk.TextMark` is like a bookmark in a text buffer; it preserves a position in
/// the text. You can convert the mark to an iterator using
/// `gtk.TextBuffer.getIterAtMark`. Unlike iterators, marks remain valid across
/// buffer mutations, because their behavior is defined when text is inserted or
/// deleted. When text containing a mark is deleted, the mark remains in the
/// position originally occupied by the deleted text. When text is inserted at a
/// mark, a mark with “left gravity” will be moved to the
/// beginning of the newly-inserted text, and a mark with “right
/// gravity” will be moved to the end.
///
/// Note that “left” and “right” here refer to logical direction (left
/// is the toward the start of the buffer); in some languages such as
/// Hebrew the logically-leftmost text is not actually on the left when
/// displayed.
///
/// Marks are reference counted, but the reference count only controls the validity
/// of the memory; marks can be deleted from the buffer at any time with
/// `gtk.TextBuffer.deleteMark`. Once deleted from the buffer, a mark is
/// essentially useless.
///
/// Marks optionally have names; these can be convenient to avoid passing the
/// `gtk.TextMark` object around.
///
/// Marks are typically created using the `gtk.TextBuffer.createMark` function.
pub const TextMark = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.TextMarkClass;
    f_parent_instance: gobject.Object,
    f_segment: ?*anyopaque,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Whether the mark has left gravity. When text is inserted at the mark’s
        /// current location, if the mark has left gravity it will be moved
        /// to the left of the newly-inserted text, otherwise to the right.
        pub const left_gravity = struct {
            pub const name = "left-gravity";

            pub const Type = c_int;
        };

        /// The name of the mark or `NULL` if the mark is anonymous.
        pub const name = struct {
            pub const name = "name";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a text mark. Add it to a buffer using `gtk.TextBuffer.addMark`.
    /// If `name` is `NULL`, the mark is anonymous; otherwise, the mark can be
    /// retrieved by name using `gtk.TextBuffer.getMark`. If a mark has left
    /// gravity, and text is inserted at the mark’s current location, the mark
    /// will be moved to the left of the newly-inserted text. If the mark has
    /// right gravity (`left_gravity` = `FALSE`), the mark will end up on the
    /// right of newly-inserted text. The standard left-to-right cursor is a
    /// mark with right gravity (when you type, the cursor stays on the right
    /// side of the text you’re typing).
    extern fn gtk_text_mark_new(p_name: ?[*:0]const u8, p_left_gravity: c_int) *gtk.TextMark;
    pub const new = gtk_text_mark_new;

    /// Gets the buffer this mark is located inside,
    /// or `NULL` if the mark is deleted.
    extern fn gtk_text_mark_get_buffer(p_mark: *TextMark) *gtk.TextBuffer;
    pub const getBuffer = gtk_text_mark_get_buffer;

    /// Returns `TRUE` if the mark has been removed from its buffer
    /// with `gtk.TextBuffer.deleteMark`. See `gtk.TextBuffer.addMark`
    /// for a way to add it to a buffer again.
    extern fn gtk_text_mark_get_deleted(p_mark: *TextMark) c_int;
    pub const getDeleted = gtk_text_mark_get_deleted;

    /// Determines whether the mark has left gravity.
    extern fn gtk_text_mark_get_left_gravity(p_mark: *TextMark) c_int;
    pub const getLeftGravity = gtk_text_mark_get_left_gravity;

    /// Returns the mark name; returns NULL for anonymous marks.
    extern fn gtk_text_mark_get_name(p_mark: *TextMark) ?[*:0]const u8;
    pub const getName = gtk_text_mark_get_name;

    /// Returns `TRUE` if the mark is visible (i.e. a cursor is displayed
    /// for it).
    extern fn gtk_text_mark_get_visible(p_mark: *TextMark) c_int;
    pub const getVisible = gtk_text_mark_get_visible;

    /// Sets the visibility of `mark`; the insertion point is normally
    /// visible, i.e. you can see it as a vertical bar. Also, the text
    /// widget uses a visible mark to indicate where a drop will occur when
    /// dragging-and-dropping text. Most other marks are not visible.
    /// Marks are not visible by default.
    extern fn gtk_text_mark_set_visible(p_mark: *TextMark, p_setting: c_int) void;
    pub const setVisible = gtk_text_mark_set_visible;

    extern fn gtk_text_mark_get_type() usize;
    pub const getGObjectType = gtk_text_mark_get_type;

    extern fn g_object_ref(p_self: *gtk.TextMark) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TextMark) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TextMark, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// You may wish to begin by reading the
/// [text widget conceptual overview](TextWidget.html)
/// which gives an overview of all the objects and
/// data types related to the text widget and how they work together.
///
/// Tags should be in the `gtk.TextTagTable` for a given `gtk.TextBuffer`
/// before using them with that buffer.
///
/// `gtk.TextBuffer.createTag` is the best way to create tags.
/// See “gtk3-demo” for numerous examples.
///
/// For each property of `gtk.TextTag`, there is a “set” property, e.g.
/// “font-set” corresponds to “font”. These “set” properties reflect
/// whether a property has been set or not.
/// They are maintained by GTK+ and you should not set them independently.
pub const TextTag = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.TextTagClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.TextTagPrivate,

    pub const virtual_methods = struct {
        /// Emits the “event” signal on the `gtk.TextTag`.
        pub const event = struct {
            pub fn call(p_class: anytype, p_tag: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event_object: *gobject.Object, p_event: *gdk.Event, p_iter: *const gtk.TextIter) c_int {
                return gobject.ext.as(TextTag.Class, p_class).f_event.?(gobject.ext.as(TextTag, p_tag), p_event_object, p_event, p_iter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tag: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event_object: *gobject.Object, p_event: *gdk.Event, p_iter: *const gtk.TextIter) callconv(.c) c_int) void {
                gobject.ext.as(TextTag.Class, p_class).f_event = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Whether the margins accumulate or override each other.
        ///
        /// When set to `TRUE` the margins of this tag are added to the margins
        /// of any other non-accumulative margins present. When set to `FALSE`
        /// the margins override one another (the default).
        pub const accumulative_margin = struct {
            pub const name = "accumulative-margin";

            pub const Type = c_int;
        };

        pub const background = struct {
            pub const name = "background";

            pub const Type = ?[*:0]u8;
        };

        pub const background_full_height = struct {
            pub const name = "background-full-height";

            pub const Type = c_int;
        };

        pub const background_full_height_set = struct {
            pub const name = "background-full-height-set";

            pub const Type = c_int;
        };

        /// Background color as a `gdk.Color`.
        pub const background_gdk = struct {
            pub const name = "background-gdk";

            pub const Type = ?*gdk.Color;
        };

        /// Background color as a `gdk.RGBA`.
        pub const background_rgba = struct {
            pub const name = "background-rgba";

            pub const Type = ?*gdk.RGBA;
        };

        pub const background_set = struct {
            pub const name = "background-set";

            pub const Type = c_int;
        };

        pub const direction = struct {
            pub const name = "direction";

            pub const Type = gtk.TextDirection;
        };

        pub const editable = struct {
            pub const name = "editable";

            pub const Type = c_int;
        };

        pub const editable_set = struct {
            pub const name = "editable-set";

            pub const Type = c_int;
        };

        /// Whether font fallback is enabled.
        ///
        /// When set to `TRUE`, other fonts will be substituted
        /// where the current font is missing glyphs.
        pub const fallback = struct {
            pub const name = "fallback";

            pub const Type = c_int;
        };

        pub const fallback_set = struct {
            pub const name = "fallback-set";

            pub const Type = c_int;
        };

        pub const family = struct {
            pub const name = "family";

            pub const Type = ?[*:0]u8;
        };

        pub const family_set = struct {
            pub const name = "family-set";

            pub const Type = c_int;
        };

        /// Font description as string, e.g. \"Sans Italic 12\".
        ///
        /// Note that the initial value of this property depends on
        /// the internals of `pango.FontDescription`.
        pub const font = struct {
            pub const name = "font";

            pub const Type = ?[*:0]u8;
        };

        pub const font_desc = struct {
            pub const name = "font-desc";

            pub const Type = ?*pango.FontDescription;
        };

        /// OpenType font features, as a string.
        pub const font_features = struct {
            pub const name = "font-features";

            pub const Type = ?[*:0]u8;
        };

        pub const font_features_set = struct {
            pub const name = "font-features-set";

            pub const Type = c_int;
        };

        pub const foreground = struct {
            pub const name = "foreground";

            pub const Type = ?[*:0]u8;
        };

        /// Foreground color as a `gdk.Color`.
        pub const foreground_gdk = struct {
            pub const name = "foreground-gdk";

            pub const Type = ?*gdk.Color;
        };

        /// Foreground color as a `gdk.RGBA`.
        pub const foreground_rgba = struct {
            pub const name = "foreground-rgba";

            pub const Type = ?*gdk.RGBA;
        };

        pub const foreground_set = struct {
            pub const name = "foreground-set";

            pub const Type = c_int;
        };

        pub const indent = struct {
            pub const name = "indent";

            pub const Type = c_int;
        };

        pub const indent_set = struct {
            pub const name = "indent-set";

            pub const Type = c_int;
        };

        /// Whether this text is hidden.
        ///
        /// Note that there may still be problems with the support for invisible
        /// text, in particular when navigating programmatically inside a buffer
        /// containing invisible segments.
        pub const invisible = struct {
            pub const name = "invisible";

            pub const Type = c_int;
        };

        pub const invisible_set = struct {
            pub const name = "invisible-set";

            pub const Type = c_int;
        };

        pub const justification = struct {
            pub const name = "justification";

            pub const Type = gtk.Justification;
        };

        pub const justification_set = struct {
            pub const name = "justification-set";

            pub const Type = c_int;
        };

        /// The language this text is in, as an ISO code. Pango can use this as a
        /// hint when rendering the text. If not set, an appropriate default will be
        /// used.
        ///
        /// Note that the initial value of this property depends on the current
        /// locale, see also `gtk.getDefaultLanguage`.
        pub const language = struct {
            pub const name = "language";

            pub const Type = ?[*:0]u8;
        };

        pub const language_set = struct {
            pub const name = "language-set";

            pub const Type = c_int;
        };

        pub const left_margin = struct {
            pub const name = "left-margin";

            pub const Type = c_int;
        };

        pub const left_margin_set = struct {
            pub const name = "left-margin-set";

            pub const Type = c_int;
        };

        /// Extra spacing between graphemes, in Pango units.
        pub const letter_spacing = struct {
            pub const name = "letter-spacing";

            pub const Type = c_int;
        };

        pub const letter_spacing_set = struct {
            pub const name = "letter-spacing-set";

            pub const Type = c_int;
        };

        pub const name = struct {
            pub const name = "name";

            pub const Type = ?[*:0]u8;
        };

        /// The paragraph background color as a string.
        pub const paragraph_background = struct {
            pub const name = "paragraph-background";

            pub const Type = ?[*:0]u8;
        };

        /// The paragraph background color as a `gdk.Color`.
        pub const paragraph_background_gdk = struct {
            pub const name = "paragraph-background-gdk";

            pub const Type = ?*gdk.Color;
        };

        /// The paragraph background color as a `gdk.RGBA`.
        pub const paragraph_background_rgba = struct {
            pub const name = "paragraph-background-rgba";

            pub const Type = ?*gdk.RGBA;
        };

        pub const paragraph_background_set = struct {
            pub const name = "paragraph-background-set";

            pub const Type = c_int;
        };

        pub const pixels_above_lines = struct {
            pub const name = "pixels-above-lines";

            pub const Type = c_int;
        };

        pub const pixels_above_lines_set = struct {
            pub const name = "pixels-above-lines-set";

            pub const Type = c_int;
        };

        pub const pixels_below_lines = struct {
            pub const name = "pixels-below-lines";

            pub const Type = c_int;
        };

        pub const pixels_below_lines_set = struct {
            pub const name = "pixels-below-lines-set";

            pub const Type = c_int;
        };

        pub const pixels_inside_wrap = struct {
            pub const name = "pixels-inside-wrap";

            pub const Type = c_int;
        };

        pub const pixels_inside_wrap_set = struct {
            pub const name = "pixels-inside-wrap-set";

            pub const Type = c_int;
        };

        pub const right_margin = struct {
            pub const name = "right-margin";

            pub const Type = c_int;
        };

        pub const right_margin_set = struct {
            pub const name = "right-margin-set";

            pub const Type = c_int;
        };

        pub const rise = struct {
            pub const name = "rise";

            pub const Type = c_int;
        };

        pub const rise_set = struct {
            pub const name = "rise-set";

            pub const Type = c_int;
        };

        pub const scale = struct {
            pub const name = "scale";

            pub const Type = f64;
        };

        pub const scale_set = struct {
            pub const name = "scale-set";

            pub const Type = c_int;
        };

        pub const size = struct {
            pub const name = "size";

            pub const Type = c_int;
        };

        pub const size_points = struct {
            pub const name = "size-points";

            pub const Type = f64;
        };

        pub const size_set = struct {
            pub const name = "size-set";

            pub const Type = c_int;
        };

        pub const stretch = struct {
            pub const name = "stretch";

            pub const Type = pango.Stretch;
        };

        pub const stretch_set = struct {
            pub const name = "stretch-set";

            pub const Type = c_int;
        };

        pub const strikethrough = struct {
            pub const name = "strikethrough";

            pub const Type = c_int;
        };

        /// This property modifies the color of strikeouts. If not set, strikeouts
        /// will use the forground color.
        pub const strikethrough_rgba = struct {
            pub const name = "strikethrough-rgba";

            pub const Type = ?*gdk.RGBA;
        };

        /// If the `gtk.TextTag.properties.strikethrough`-rgba property has been set.
        pub const strikethrough_rgba_set = struct {
            pub const name = "strikethrough-rgba-set";

            pub const Type = c_int;
        };

        pub const strikethrough_set = struct {
            pub const name = "strikethrough-set";

            pub const Type = c_int;
        };

        pub const style = struct {
            pub const name = "style";

            pub const Type = pango.Style;
        };

        pub const style_set = struct {
            pub const name = "style-set";

            pub const Type = c_int;
        };

        pub const tabs = struct {
            pub const name = "tabs";

            pub const Type = ?*pango.TabArray;
        };

        pub const tabs_set = struct {
            pub const name = "tabs-set";

            pub const Type = c_int;
        };

        pub const underline = struct {
            pub const name = "underline";

            pub const Type = pango.Underline;
        };

        /// This property modifies the color of underlines. If not set, underlines
        /// will use the forground color.
        ///
        /// If `gtk.TextTag.properties.underline` is set to `PANGO_UNDERLINE_ERROR`, an alternate
        /// color may be applied instead of the foreground. Setting this property
        /// will always override those defaults.
        pub const underline_rgba = struct {
            pub const name = "underline-rgba";

            pub const Type = ?*gdk.RGBA;
        };

        /// If the `gtk.TextTag.properties.underline`-rgba property has been set.
        pub const underline_rgba_set = struct {
            pub const name = "underline-rgba-set";

            pub const Type = c_int;
        };

        pub const underline_set = struct {
            pub const name = "underline-set";

            pub const Type = c_int;
        };

        pub const variant = struct {
            pub const name = "variant";

            pub const Type = pango.Variant;
        };

        pub const variant_set = struct {
            pub const name = "variant-set";

            pub const Type = c_int;
        };

        pub const weight = struct {
            pub const name = "weight";

            pub const Type = c_int;
        };

        pub const weight_set = struct {
            pub const name = "weight-set";

            pub const Type = c_int;
        };

        pub const wrap_mode = struct {
            pub const name = "wrap-mode";

            pub const Type = gtk.WrapMode;
        };

        pub const wrap_mode_set = struct {
            pub const name = "wrap-mode-set";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::event signal is emitted when an event occurs on a region of the
        /// buffer marked with this tag.
        pub const event = struct {
            pub const name = "event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: *gobject.Object, p_event: *gdk.Event, p_iter: *gtk.TextIter, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextTag, p_instance))),
                    gobject.signalLookup("event", TextTag.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a `gtk.TextTag`. Configure the tag using object arguments,
    /// i.e. using `gobject.Object.set`.
    extern fn gtk_text_tag_new(p_name: ?[*:0]const u8) *gtk.TextTag;
    pub const new = gtk_text_tag_new;

    /// Emits the `gtk.TextTagTable.signals.tag`-changed signal on the `gtk.TextTagTable` where
    /// the tag is included.
    ///
    /// The signal is already emitted when setting a `gtk.TextTag` property. This
    /// function is useful for a `gtk.TextTag` subclass.
    extern fn gtk_text_tag_changed(p_tag: *TextTag, p_size_changed: c_int) void;
    pub const changed = gtk_text_tag_changed;

    /// Emits the “event” signal on the `gtk.TextTag`.
    extern fn gtk_text_tag_event(p_tag: *TextTag, p_event_object: *gobject.Object, p_event: *gdk.Event, p_iter: *const gtk.TextIter) c_int;
    pub const event = gtk_text_tag_event;

    /// Get the tag priority.
    extern fn gtk_text_tag_get_priority(p_tag: *TextTag) c_int;
    pub const getPriority = gtk_text_tag_get_priority;

    /// Sets the priority of a `gtk.TextTag`. Valid priorities
    /// start at 0 and go to one less than `gtk.TextTagTable.getSize`.
    /// Each tag in a table has a unique priority; setting the priority
    /// of one tag shifts the priorities of all the other tags in the
    /// table to maintain a unique priority for each tag. Higher priority
    /// tags “win” if two tags both set the same text attribute. When adding
    /// a tag to a tag table, it will be assigned the highest priority in
    /// the table by default; so normally the precedence of a set of tags
    /// is the order in which they were added to the table, or created with
    /// `gtk.TextBuffer.createTag`, which adds the tag to the buffer’s table
    /// automatically.
    extern fn gtk_text_tag_set_priority(p_tag: *TextTag, p_priority: c_int) void;
    pub const setPriority = gtk_text_tag_set_priority;

    extern fn gtk_text_tag_get_type() usize;
    pub const getGObjectType = gtk_text_tag_get_type;

    extern fn g_object_ref(p_self: *gtk.TextTag) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TextTag) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TextTag, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// You may wish to begin by reading the
/// [text widget conceptual overview](TextWidget.html)
/// which gives an overview of all the objects and
/// data types related to the text widget and how they work together.
///
/// # GtkTextTagTables as GtkBuildable
///
/// The GtkTextTagTable implementation of the GtkBuildable interface
/// supports adding tags by specifying “tag” as the “type” attribute
/// of a `<child>` element.
///
/// An example of a UI definition fragment specifying tags:
///
/// ```
/// <object class="GtkTextTagTable">
///  <child type="tag">
///    <object class="GtkTextTag"/>
///  </child>
/// </object>
/// ```
pub const TextTagTable = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gtk.Buildable};
    pub const Class = gtk.TextTagTableClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.TextTagTablePrivate,

    pub const virtual_methods = struct {
        pub const tag_added = struct {
            pub fn call(p_class: anytype, p_table: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tag: *gtk.TextTag) void {
                return gobject.ext.as(TextTagTable.Class, p_class).f_tag_added.?(gobject.ext.as(TextTagTable, p_table), p_tag);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_table: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tag: *gtk.TextTag) callconv(.c) void) void {
                gobject.ext.as(TextTagTable.Class, p_class).f_tag_added = @ptrCast(p_implementation);
            }
        };

        pub const tag_changed = struct {
            pub fn call(p_class: anytype, p_table: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tag: *gtk.TextTag, p_size_changed: c_int) void {
                return gobject.ext.as(TextTagTable.Class, p_class).f_tag_changed.?(gobject.ext.as(TextTagTable, p_table), p_tag, p_size_changed);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_table: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tag: *gtk.TextTag, p_size_changed: c_int) callconv(.c) void) void {
                gobject.ext.as(TextTagTable.Class, p_class).f_tag_changed = @ptrCast(p_implementation);
            }
        };

        pub const tag_removed = struct {
            pub fn call(p_class: anytype, p_table: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tag: *gtk.TextTag) void {
                return gobject.ext.as(TextTagTable.Class, p_class).f_tag_removed.?(gobject.ext.as(TextTagTable, p_table), p_tag);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_table: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tag: *gtk.TextTag) callconv(.c) void) void {
                gobject.ext.as(TextTagTable.Class, p_class).f_tag_removed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        pub const tag_added = struct {
            pub const name = "tag-added";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_tag: *gtk.TextTag, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextTagTable, p_instance))),
                    gobject.signalLookup("tag-added", TextTagTable.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const tag_changed = struct {
            pub const name = "tag-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_tag: *gtk.TextTag, p_size_changed: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextTagTable, p_instance))),
                    gobject.signalLookup("tag-changed", TextTagTable.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const tag_removed = struct {
            pub const name = "tag-removed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_tag: *gtk.TextTag, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextTagTable, p_instance))),
                    gobject.signalLookup("tag-removed", TextTagTable.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.TextTagTable`. The table contains no tags by
    /// default.
    extern fn gtk_text_tag_table_new() *gtk.TextTagTable;
    pub const new = gtk_text_tag_table_new;

    /// Add a tag to the table. The tag is assigned the highest priority
    /// in the table.
    ///
    /// `tag` must not be in a tag table already, and may not have
    /// the same name as an already-added tag.
    extern fn gtk_text_tag_table_add(p_table: *TextTagTable, p_tag: *gtk.TextTag) c_int;
    pub const add = gtk_text_tag_table_add;

    /// Calls `func` on each tag in `table`, with user data `data`.
    /// Note that the table may not be modified while iterating
    /// over it (you can’t add/remove tags).
    extern fn gtk_text_tag_table_foreach(p_table: *TextTagTable, p_func: gtk.TextTagTableForeach, p_data: ?*anyopaque) void;
    pub const foreach = gtk_text_tag_table_foreach;

    /// Returns the size of the table (number of tags)
    extern fn gtk_text_tag_table_get_size(p_table: *TextTagTable) c_int;
    pub const getSize = gtk_text_tag_table_get_size;

    /// Look up a named tag.
    extern fn gtk_text_tag_table_lookup(p_table: *TextTagTable, p_name: [*:0]const u8) ?*gtk.TextTag;
    pub const lookup = gtk_text_tag_table_lookup;

    /// Remove a tag from the table. If a `gtk.TextBuffer` has `table` as its tag table,
    /// the tag is removed from the buffer. The table’s reference to the tag is
    /// removed, so the tag will end up destroyed if you don’t have a reference to
    /// it.
    extern fn gtk_text_tag_table_remove(p_table: *TextTagTable, p_tag: *gtk.TextTag) void;
    pub const remove = gtk_text_tag_table_remove;

    extern fn gtk_text_tag_table_get_type() usize;
    pub const getGObjectType = gtk_text_tag_table_get_type;

    extern fn g_object_ref(p_self: *gtk.TextTagTable) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TextTagTable) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TextTagTable, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// You may wish to begin by reading the
/// [text widget conceptual overview](TextWidget.html)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
///
/// # CSS nodes
///
/// ```
/// textview.view
/// ├── border.top
/// ├── border.left
/// ├── text
/// │   ╰── [selection]
/// ├── border.right
/// ├── border.bottom
/// ╰── [window.popup]
/// ```
///
/// GtkTextView has a main css node with name textview and style class .view,
/// and subnodes for each of the border windows, and the main text area,
/// with names border and text, respectively. The border nodes each get
/// one of the style classes .left, .right, .top or .bottom.
///
/// A node representing the selection will appear below the text node.
///
/// If a context menu is opened, the window node will appear as a subnode
/// of the main node.
pub const TextView = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Scrollable };
    pub const Class = gtk.TextViewClass;
    f_parent_instance: gtk.Container,
    f_priv: ?*gtk.TextViewPrivate,

    pub const virtual_methods = struct {
        /// The class handler for the `gtk.TextView.signals.backspace`
        ///   keybinding signal.
        pub const backspace = struct {
            pub fn call(p_class: anytype, p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TextView.Class, p_class).f_backspace.?(gobject.ext.as(TextView, p_text_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TextView.Class, p_class).f_backspace = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `GtkTextview.signals.copy`-clipboard
        ///   keybinding signal.
        pub const copy_clipboard = struct {
            pub fn call(p_class: anytype, p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TextView.Class, p_class).f_copy_clipboard.?(gobject.ext.as(TextView, p_text_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TextView.Class, p_class).f_copy_clipboard = @ptrCast(p_implementation);
            }
        };

        /// The create_buffer vfunc is called to create a `gtk.TextBuffer`
        ///   for the text view. The default implementation is to just call
        ///   `gtk.TextBuffer.new`. Since: 3.10
        pub const create_buffer = struct {
            pub fn call(p_class: anytype, p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gtk.TextBuffer {
                return gobject.ext.as(TextView.Class, p_class).f_create_buffer.?(gobject.ext.as(TextView, p_text_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gtk.TextBuffer) void {
                gobject.ext.as(TextView.Class, p_class).f_create_buffer = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextView.signals.cut`-clipboard
        ///   keybinding signal
        pub const cut_clipboard = struct {
            pub fn call(p_class: anytype, p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TextView.Class, p_class).f_cut_clipboard.?(gobject.ext.as(TextView, p_text_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TextView.Class, p_class).f_cut_clipboard = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextView.signals.delete`-from-cursor
        ///   keybinding signal.
        pub const delete_from_cursor = struct {
            pub fn call(p_class: anytype, p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_type: gtk.DeleteType, p_count: c_int) void {
                return gobject.ext.as(TextView.Class, p_class).f_delete_from_cursor.?(gobject.ext.as(TextView, p_text_view), p_type, p_count);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_type: gtk.DeleteType, p_count: c_int) callconv(.c) void) void {
                gobject.ext.as(TextView.Class, p_class).f_delete_from_cursor = @ptrCast(p_implementation);
            }
        };

        /// The draw_layer vfunc is called before and after the text
        ///   view is drawing its own text. Applications can override this vfunc
        ///   in a subclass to draw customized content underneath or above the
        ///   text. In the `GTK_TEXT_VIEW_LAYER_BELOW_TEXT` and `GTK_TEXT_VIEW_LAYER_ABOVE_TEXT`
        ///   the drawing is done in the buffer coordinate space, but the older (deprecated)
        ///   layers `GTK_TEXT_VIEW_LAYER_BELOW` and `GTK_TEXT_VIEW_LAYER_ABOVE` work in viewport
        ///   coordinates, which makes them unnecessarily hard to use. Since: 3.14
        pub const draw_layer = struct {
            pub fn call(p_class: anytype, p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_layer: gtk.TextViewLayer, p_cr: *cairo.Context) void {
                return gobject.ext.as(TextView.Class, p_class).f_draw_layer.?(gobject.ext.as(TextView, p_text_view), p_layer, p_cr);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_layer: gtk.TextViewLayer, p_cr: *cairo.Context) callconv(.c) void) void {
                gobject.ext.as(TextView.Class, p_class).f_draw_layer = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextView.signals.extend`-selection
        ///   signal. Since 3.16
        pub const extend_selection = struct {
            pub fn call(p_class: anytype, p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_granularity: gtk.TextExtendSelection, p_location: *const gtk.TextIter, p_start: *gtk.TextIter, p_end: *gtk.TextIter) c_int {
                return gobject.ext.as(TextView.Class, p_class).f_extend_selection.?(gobject.ext.as(TextView, p_text_view), p_granularity, p_location, p_start, p_end);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_granularity: gtk.TextExtendSelection, p_location: *const gtk.TextIter, p_start: *gtk.TextIter, p_end: *gtk.TextIter) callconv(.c) c_int) void {
                gobject.ext.as(TextView.Class, p_class).f_extend_selection = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextView.signals.insert`-at-cursor
        ///   keybinding signal.
        pub const insert_at_cursor = struct {
            pub fn call(p_class: anytype, p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_str: [*:0]const u8) void {
                return gobject.ext.as(TextView.Class, p_class).f_insert_at_cursor.?(gobject.ext.as(TextView, p_text_view), p_str);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_str: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(TextView.Class, p_class).f_insert_at_cursor = @ptrCast(p_implementation);
            }
        };

        pub const insert_emoji = struct {
            pub fn call(p_class: anytype, p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TextView.Class, p_class).f_insert_emoji.?(gobject.ext.as(TextView, p_text_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TextView.Class, p_class).f_insert_emoji = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextView.signals.move`-cursor
        ///   keybinding signal.
        pub const move_cursor = struct {
            pub fn call(p_class: anytype, p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_step: gtk.MovementStep, p_count: c_int, p_extend_selection: c_int) void {
                return gobject.ext.as(TextView.Class, p_class).f_move_cursor.?(gobject.ext.as(TextView, p_text_view), p_step, p_count, p_extend_selection);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_step: gtk.MovementStep, p_count: c_int, p_extend_selection: c_int) callconv(.c) void) void {
                gobject.ext.as(TextView.Class, p_class).f_move_cursor = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextView.signals.paste`-clipboard
        ///   keybinding signal.
        pub const paste_clipboard = struct {
            pub fn call(p_class: anytype, p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TextView.Class, p_class).f_paste_clipboard.?(gobject.ext.as(TextView, p_text_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TextView.Class, p_class).f_paste_clipboard = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextView.signals.populate`-popup
        ///   signal.
        pub const populate_popup = struct {
            pub fn call(p_class: anytype, p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_popup: *gtk.Widget) void {
                return gobject.ext.as(TextView.Class, p_class).f_populate_popup.?(gobject.ext.as(TextView, p_text_view), p_popup);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_popup: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(TextView.Class, p_class).f_populate_popup = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextView.signals.set`-anchor
        ///   keybinding signal.
        pub const set_anchor = struct {
            pub fn call(p_class: anytype, p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TextView.Class, p_class).f_set_anchor.?(gobject.ext.as(TextView, p_text_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TextView.Class, p_class).f_set_anchor = @ptrCast(p_implementation);
            }
        };

        /// The class handler for the `gtk.TextView.signals.toggle`-overwrite
        ///   keybinding signal.
        pub const toggle_overwrite = struct {
            pub fn call(p_class: anytype, p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TextView.Class, p_class).f_toggle_overwrite.?(gobject.ext.as(TextView, p_text_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_text_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TextView.Class, p_class).f_toggle_overwrite = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const accepts_tab = struct {
            pub const name = "accepts-tab";

            pub const Type = c_int;
        };

        /// The bottom margin for text in the text view.
        ///
        /// Note that this property is confusingly named. In CSS terms,
        /// the value set here is padding, and it is applied in addition
        /// to the padding from the theme.
        ///
        /// Don't confuse this property with `gtk.Widget.properties.margin`-bottom.
        pub const bottom_margin = struct {
            pub const name = "bottom-margin";

            pub const Type = c_int;
        };

        pub const buffer = struct {
            pub const name = "buffer";

            pub const Type = ?*gtk.TextBuffer;
        };

        pub const cursor_visible = struct {
            pub const name = "cursor-visible";

            pub const Type = c_int;
        };

        pub const editable = struct {
            pub const name = "editable";

            pub const Type = c_int;
        };

        /// Which IM (input method) module should be used for this text_view.
        /// See `gtk.IMContext`.
        ///
        /// Setting this to a non-`NULL` value overrides the
        /// system-wide IM module setting. See the GtkSettings
        /// `gtk.Settings.properties.gtk`-im-module property.
        pub const im_module = struct {
            pub const name = "im-module";

            pub const Type = ?[*:0]u8;
        };

        pub const indent = struct {
            pub const name = "indent";

            pub const Type = c_int;
        };

        /// Additional hints (beyond `gtk.TextView.properties.input`-purpose) that
        /// allow input methods to fine-tune their behaviour.
        pub const input_hints = struct {
            pub const name = "input-hints";

            pub const Type = gtk.InputHints;
        };

        /// The purpose of this text field.
        ///
        /// This property can be used by on-screen keyboards and other input
        /// methods to adjust their behaviour.
        pub const input_purpose = struct {
            pub const name = "input-purpose";

            pub const Type = gtk.InputPurpose;
        };

        pub const justification = struct {
            pub const name = "justification";

            pub const Type = gtk.Justification;
        };

        /// The default left margin for text in the text view.
        /// Tags in the buffer may override the default.
        ///
        /// Note that this property is confusingly named. In CSS terms,
        /// the value set here is padding, and it is applied in addition
        /// to the padding from the theme.
        ///
        /// Don't confuse this property with `gtk.Widget.properties.margin`-left.
        pub const left_margin = struct {
            pub const name = "left-margin";

            pub const Type = c_int;
        };

        pub const monospace = struct {
            pub const name = "monospace";

            pub const Type = c_int;
        };

        pub const overwrite = struct {
            pub const name = "overwrite";

            pub const Type = c_int;
        };

        pub const pixels_above_lines = struct {
            pub const name = "pixels-above-lines";

            pub const Type = c_int;
        };

        pub const pixels_below_lines = struct {
            pub const name = "pixels-below-lines";

            pub const Type = c_int;
        };

        pub const pixels_inside_wrap = struct {
            pub const name = "pixels-inside-wrap";

            pub const Type = c_int;
        };

        /// If :populate-all is `TRUE`, the `gtk.TextView.signals.populate`-popup
        /// signal is also emitted for touch popups.
        pub const populate_all = struct {
            pub const name = "populate-all";

            pub const Type = c_int;
        };

        /// The default right margin for text in the text view.
        /// Tags in the buffer may override the default.
        ///
        /// Note that this property is confusingly named. In CSS terms,
        /// the value set here is padding, and it is applied in addition
        /// to the padding from the theme.
        ///
        /// Don't confuse this property with `gtk.Widget.properties.margin`-right.
        pub const right_margin = struct {
            pub const name = "right-margin";

            pub const Type = c_int;
        };

        pub const tabs = struct {
            pub const name = "tabs";

            pub const Type = ?*pango.TabArray;
        };

        /// The top margin for text in the text view.
        ///
        /// Note that this property is confusingly named. In CSS terms,
        /// the value set here is padding, and it is applied in addition
        /// to the padding from the theme.
        ///
        /// Don't confuse this property with `gtk.Widget.properties.margin`-top.
        pub const top_margin = struct {
            pub const name = "top-margin";

            pub const Type = c_int;
        };

        pub const wrap_mode = struct {
            pub const name = "wrap-mode";

            pub const Type = gtk.WrapMode;
        };
    };

    pub const signals = struct {
        /// The ::backspace signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user asks for it.
        ///
        /// The default bindings for this signal are
        /// Backspace and Shift-Backspace.
        pub const backspace = struct {
            pub const name = "backspace";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("backspace", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::copy-clipboard signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to copy the selection to the clipboard.
        ///
        /// The default bindings for this signal are
        /// Ctrl-c and Ctrl-Insert.
        pub const copy_clipboard = struct {
            pub const name = "copy-clipboard";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("copy-clipboard", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::cut-clipboard signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to cut the selection to the clipboard.
        ///
        /// The default bindings for this signal are
        /// Ctrl-x and Shift-Delete.
        pub const cut_clipboard = struct {
            pub const name = "cut-clipboard";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("cut-clipboard", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::delete-from-cursor signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user initiates a text deletion.
        ///
        /// If the `type` is `GTK_DELETE_CHARS`, GTK+ deletes the selection
        /// if there is one, otherwise it deletes the requested number
        /// of characters.
        ///
        /// The default bindings for this signal are
        /// Delete for deleting a character, Ctrl-Delete for
        /// deleting a word and Ctrl-Backspace for deleting a word
        /// backwords.
        pub const delete_from_cursor = struct {
            pub const name = "delete-from-cursor";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_type: gtk.DeleteType, p_count: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("delete-from-cursor", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::extend-selection signal is emitted when the selection needs to be
        /// extended at `location`.
        pub const extend_selection = struct {
            pub const name = "extend-selection";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_granularity: gtk.TextExtendSelection, p_location: *gtk.TextIter, p_start: *gtk.TextIter, p_end: *gtk.TextIter, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("extend-selection", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::insert-at-cursor signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user initiates the insertion of a
        /// fixed string at the cursor.
        ///
        /// This signal has no default bindings.
        pub const insert_at_cursor = struct {
            pub const name = "insert-at-cursor";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_string: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("insert-at-cursor", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::insert-emoji signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to present the Emoji chooser for the `text_view`.
        ///
        /// The default bindings for this signal are Ctrl-. and Ctrl-;
        pub const insert_emoji = struct {
            pub const name = "insert-emoji";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("insert-emoji", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::move-cursor signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user initiates a cursor movement.
        /// If the cursor is not visible in `text_view`, this signal causes
        /// the viewport to be moved instead.
        ///
        /// Applications should not connect to it, but may emit it with
        /// `gobject.signalEmitByName` if they need to control the cursor
        /// programmatically.
        ///
        /// The default bindings for this signal come in two variants,
        /// the variant with the Shift modifier extends the selection,
        /// the variant without the Shift modifer does not.
        /// There are too many key combinations to list them all here.
        /// - Arrow keys move by individual characters/lines
        /// - Ctrl-arrow key combinations move by words/paragraphs
        /// - Home/End keys move to the ends of the buffer
        /// - PageUp/PageDown keys move vertically by pages
        /// - Ctrl-PageUp/PageDown keys move horizontally by pages
        pub const move_cursor = struct {
            pub const name = "move-cursor";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_step: gtk.MovementStep, p_count: c_int, p_extend_selection: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("move-cursor", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::move-viewport signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which can be bound to key combinations to allow the user
        /// to move the viewport, i.e. change what part of the text view
        /// is visible in a containing scrolled window.
        ///
        /// There are no default bindings for this signal.
        pub const move_viewport = struct {
            pub const name = "move-viewport";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_step: gtk.ScrollStep, p_count: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("move-viewport", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::paste-clipboard signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to paste the contents of the clipboard
        /// into the text view.
        ///
        /// The default bindings for this signal are
        /// Ctrl-v and Shift-Insert.
        pub const paste_clipboard = struct {
            pub const name = "paste-clipboard";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("paste-clipboard", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::populate-popup signal gets emitted before showing the
        /// context menu of the text view.
        ///
        /// If you need to add items to the context menu, connect
        /// to this signal and append your items to the `popup`, which
        /// will be a `gtk.Menu` in this case.
        ///
        /// If `gtk.TextView.properties.populate`-all is `TRUE`, this signal will
        /// also be emitted to populate touch popups. In this case,
        /// `popup` will be a different container, e.g. a `gtk.Toolbar`.
        ///
        /// The signal handler should not make assumptions about the
        /// type of `widget`, but check whether `popup` is a `gtk.Menu`
        /// or `gtk.Toolbar` or another kind of container.
        pub const populate_popup = struct {
            pub const name = "populate-popup";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_popup: *gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("populate-popup", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// If an input method is used, the typed text will not immediately
        /// be committed to the buffer. So if you are interested in the text,
        /// connect to this signal.
        ///
        /// This signal is only emitted if the text at the given position
        /// is actually editable.
        pub const preedit_changed = struct {
            pub const name = "preedit-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_preedit: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("preedit-changed", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::select-all signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to select or unselect the complete
        /// contents of the text view.
        ///
        /// The default bindings for this signal are Ctrl-a and Ctrl-/
        /// for selecting and Shift-Ctrl-a and Ctrl-\ for unselecting.
        pub const select_all = struct {
            pub const name = "select-all";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_select: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("select-all", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::set-anchor signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user initiates setting the "anchor"
        /// mark. The "anchor" mark gets placed at the same position as the
        /// "insert" mark.
        ///
        /// This signal has no default bindings.
        pub const set_anchor = struct {
            pub const name = "set-anchor";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("set-anchor", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::toggle-cursor-visible signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to toggle the `gtk.TextView.properties.cursor`-visible
        /// property.
        ///
        /// The default binding for this signal is F7.
        pub const toggle_cursor_visible = struct {
            pub const name = "toggle-cursor-visible";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("toggle-cursor-visible", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::toggle-overwrite signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted to toggle the overwrite mode of the text view.
        ///
        /// The default bindings for this signal is Insert.
        pub const toggle_overwrite = struct {
            pub const name = "toggle-overwrite";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TextView, p_instance))),
                    gobject.signalLookup("toggle-overwrite", TextView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.TextView`. If you don’t call `gtk.TextView.setBuffer`
    /// before using the text view, an empty default buffer will be created
    /// for you. Get the buffer with `gtk.TextView.getBuffer`. If you want
    /// to specify your own buffer, consider `gtk.TextView.newWithBuffer`.
    extern fn gtk_text_view_new() *gtk.TextView;
    pub const new = gtk_text_view_new;

    /// Creates a new `gtk.TextView` widget displaying the buffer
    /// `buffer`. One buffer can be shared among many widgets.
    /// `buffer` may be `NULL` to create a default buffer, in which case
    /// this function is equivalent to `gtk.TextView.new`. The
    /// text view adds its own reference count to the buffer; it does not
    /// take over an existing reference.
    extern fn gtk_text_view_new_with_buffer(p_buffer: *gtk.TextBuffer) *gtk.TextView;
    pub const newWithBuffer = gtk_text_view_new_with_buffer;

    /// Adds a child widget in the text buffer, at the given `anchor`.
    extern fn gtk_text_view_add_child_at_anchor(p_text_view: *TextView, p_child: *gtk.Widget, p_anchor: *gtk.TextChildAnchor) void;
    pub const addChildAtAnchor = gtk_text_view_add_child_at_anchor;

    /// Adds a child at fixed coordinates in one of the text widget's
    /// windows.
    ///
    /// The window must have nonzero size (see
    /// `gtk.TextView.setBorderWindowSize`). Note that the child
    /// coordinates are given relative to scrolling. When
    /// placing a child in `GTK_TEXT_WINDOW_WIDGET`, scrolling is
    /// irrelevant, the child floats above all scrollable areas. But when
    /// placing a child in one of the scrollable windows (border windows or
    /// text window) it will move with the scrolling as needed.
    extern fn gtk_text_view_add_child_in_window(p_text_view: *TextView, p_child: *gtk.Widget, p_which_window: gtk.TextWindowType, p_xpos: c_int, p_ypos: c_int) void;
    pub const addChildInWindow = gtk_text_view_add_child_in_window;

    /// Moves the given `iter` backward by one display (wrapped) line.
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `gtk.TextBuffer`.
    extern fn gtk_text_view_backward_display_line(p_text_view: *TextView, p_iter: *gtk.TextIter) c_int;
    pub const backwardDisplayLine = gtk_text_view_backward_display_line;

    /// Moves the given `iter` backward to the next display line start.
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `gtk.TextBuffer`.
    extern fn gtk_text_view_backward_display_line_start(p_text_view: *TextView, p_iter: *gtk.TextIter) c_int;
    pub const backwardDisplayLineStart = gtk_text_view_backward_display_line_start;

    /// Converts coordinate (`buffer_x`, `buffer_y`) to coordinates for the window
    /// `win`, and stores the result in (`window_x`, `window_y`).
    ///
    /// Note that you can’t convert coordinates for a nonexisting window (see
    /// `gtk.TextView.setBorderWindowSize`).
    extern fn gtk_text_view_buffer_to_window_coords(p_text_view: *TextView, p_win: gtk.TextWindowType, p_buffer_x: c_int, p_buffer_y: c_int, p_window_x: ?*c_int, p_window_y: ?*c_int) void;
    pub const bufferToWindowCoords = gtk_text_view_buffer_to_window_coords;

    /// Moves the given `iter` forward by one display (wrapped) line.
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `gtk.TextBuffer`.
    extern fn gtk_text_view_forward_display_line(p_text_view: *TextView, p_iter: *gtk.TextIter) c_int;
    pub const forwardDisplayLine = gtk_text_view_forward_display_line;

    /// Moves the given `iter` forward to the next display line end.
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `gtk.TextBuffer`.
    extern fn gtk_text_view_forward_display_line_end(p_text_view: *TextView, p_iter: *gtk.TextIter) c_int;
    pub const forwardDisplayLineEnd = gtk_text_view_forward_display_line_end;

    /// Returns whether pressing the Tab key inserts a tab characters.
    /// `gtk.TextView.setAcceptsTab`.
    extern fn gtk_text_view_get_accepts_tab(p_text_view: *TextView) c_int;
    pub const getAcceptsTab = gtk_text_view_get_accepts_tab;

    /// Gets the width of the specified border window. See
    /// `gtk.TextView.setBorderWindowSize`.
    extern fn gtk_text_view_get_border_window_size(p_text_view: *TextView, p_type: gtk.TextWindowType) c_int;
    pub const getBorderWindowSize = gtk_text_view_get_border_window_size;

    /// Gets the bottom margin for text in the `text_view`.
    extern fn gtk_text_view_get_bottom_margin(p_text_view: *TextView) c_int;
    pub const getBottomMargin = gtk_text_view_get_bottom_margin;

    /// Returns the `gtk.TextBuffer` being displayed by this text view.
    /// The reference count on the buffer is not incremented; the caller
    /// of this function won’t own a new reference.
    extern fn gtk_text_view_get_buffer(p_text_view: *TextView) *gtk.TextBuffer;
    pub const getBuffer = gtk_text_view_get_buffer;

    /// Given an `iter` within a text layout, determine the positions of the
    /// strong and weak cursors if the insertion point is at that
    /// iterator. The position of each cursor is stored as a zero-width
    /// rectangle. The strong cursor location is the location where
    /// characters of the directionality equal to the base direction of the
    /// paragraph are inserted.  The weak cursor location is the location
    /// where characters of the directionality opposite to the base
    /// direction of the paragraph are inserted.
    ///
    /// If `iter` is `NULL`, the actual cursor position is used.
    ///
    /// Note that if `iter` happens to be the actual cursor position, and
    /// there is currently an IM preedit sequence being entered, the
    /// returned locations will be adjusted to account for the preedit
    /// cursor’s offset within the preedit sequence.
    ///
    /// The rectangle position is in buffer coordinates; use
    /// `gtk.TextView.bufferToWindowCoords` to convert these
    /// coordinates to coordinates for one of the windows in the text view.
    extern fn gtk_text_view_get_cursor_locations(p_text_view: *TextView, p_iter: ?*const gtk.TextIter, p_strong: ?*gdk.Rectangle, p_weak: ?*gdk.Rectangle) void;
    pub const getCursorLocations = gtk_text_view_get_cursor_locations;

    /// Find out whether the cursor should be displayed.
    extern fn gtk_text_view_get_cursor_visible(p_text_view: *TextView) c_int;
    pub const getCursorVisible = gtk_text_view_get_cursor_visible;

    /// Obtains a copy of the default text attributes. These are the
    /// attributes used for text unless a tag overrides them.
    /// You’d typically pass the default attributes in to
    /// `gtk.TextIter.getAttributes` in order to get the
    /// attributes in effect at a given text position.
    ///
    /// The return value is a copy owned by the caller of this function,
    /// and should be freed with `gtk.TextAttributes.unref`.
    extern fn gtk_text_view_get_default_attributes(p_text_view: *TextView) *gtk.TextAttributes;
    pub const getDefaultAttributes = gtk_text_view_get_default_attributes;

    /// Returns the default editability of the `gtk.TextView`. Tags in the
    /// buffer may override this setting for some ranges of text.
    extern fn gtk_text_view_get_editable(p_text_view: *TextView) c_int;
    pub const getEditable = gtk_text_view_get_editable;

    /// Gets the horizontal-scrolling `gtk.Adjustment`.
    extern fn gtk_text_view_get_hadjustment(p_text_view: *TextView) *gtk.Adjustment;
    pub const getHadjustment = gtk_text_view_get_hadjustment;

    /// Gets the default indentation of paragraphs in `text_view`.
    /// Tags in the view’s buffer may override the default.
    /// The indentation may be negative.
    extern fn gtk_text_view_get_indent(p_text_view: *TextView) c_int;
    pub const getIndent = gtk_text_view_get_indent;

    /// Gets the value of the `gtk.TextView.properties.input`-hints property.
    extern fn gtk_text_view_get_input_hints(p_text_view: *TextView) gtk.InputHints;
    pub const getInputHints = gtk_text_view_get_input_hints;

    /// Gets the value of the `gtk.TextView.properties.input`-purpose property.
    extern fn gtk_text_view_get_input_purpose(p_text_view: *TextView) gtk.InputPurpose;
    pub const getInputPurpose = gtk_text_view_get_input_purpose;

    /// Retrieves the iterator at buffer coordinates `x` and `y`. Buffer
    /// coordinates are coordinates for the entire buffer, not just the
    /// currently-displayed portion.  If you have coordinates from an
    /// event, you have to convert those to buffer coordinates with
    /// `gtk.TextView.windowToBufferCoords`.
    extern fn gtk_text_view_get_iter_at_location(p_text_view: *TextView, p_iter: *gtk.TextIter, p_x: c_int, p_y: c_int) c_int;
    pub const getIterAtLocation = gtk_text_view_get_iter_at_location;

    /// Retrieves the iterator pointing to the character at buffer
    /// coordinates `x` and `y`. Buffer coordinates are coordinates for
    /// the entire buffer, not just the currently-displayed portion.
    /// If you have coordinates from an event, you have to convert
    /// those to buffer coordinates with
    /// `gtk.TextView.windowToBufferCoords`.
    ///
    /// Note that this is different from `gtk.TextView.getIterAtLocation`,
    /// which returns cursor locations, i.e. positions between
    /// characters.
    extern fn gtk_text_view_get_iter_at_position(p_text_view: *TextView, p_iter: *gtk.TextIter, p_trailing: ?*c_int, p_x: c_int, p_y: c_int) c_int;
    pub const getIterAtPosition = gtk_text_view_get_iter_at_position;

    /// Gets a rectangle which roughly contains the character at `iter`.
    /// The rectangle position is in buffer coordinates; use
    /// `gtk.TextView.bufferToWindowCoords` to convert these
    /// coordinates to coordinates for one of the windows in the text view.
    extern fn gtk_text_view_get_iter_location(p_text_view: *TextView, p_iter: *const gtk.TextIter, p_location: *gdk.Rectangle) void;
    pub const getIterLocation = gtk_text_view_get_iter_location;

    /// Gets the default justification of paragraphs in `text_view`.
    /// Tags in the buffer may override the default.
    extern fn gtk_text_view_get_justification(p_text_view: *TextView) gtk.Justification;
    pub const getJustification = gtk_text_view_get_justification;

    /// Gets the default left margin size of paragraphs in the `text_view`.
    /// Tags in the buffer may override the default.
    extern fn gtk_text_view_get_left_margin(p_text_view: *TextView) c_int;
    pub const getLeftMargin = gtk_text_view_get_left_margin;

    /// Gets the `gtk.TextIter` at the start of the line containing
    /// the coordinate `y`. `y` is in buffer coordinates, convert from
    /// window coordinates with `gtk.TextView.windowToBufferCoords`.
    /// If non-`NULL`, `line_top` will be filled with the coordinate of the top
    /// edge of the line.
    extern fn gtk_text_view_get_line_at_y(p_text_view: *TextView, p_target_iter: *gtk.TextIter, p_y: c_int, p_line_top: *c_int) void;
    pub const getLineAtY = gtk_text_view_get_line_at_y;

    /// Gets the y coordinate of the top of the line containing `iter`,
    /// and the height of the line. The coordinate is a buffer coordinate;
    /// convert to window coordinates with `gtk.TextView.bufferToWindowCoords`.
    extern fn gtk_text_view_get_line_yrange(p_text_view: *TextView, p_iter: *const gtk.TextIter, p_y: *c_int, p_height: *c_int) void;
    pub const getLineYrange = gtk_text_view_get_line_yrange;

    /// Gets the value of the `gtk.TextView.properties.monospace` property.
    extern fn gtk_text_view_get_monospace(p_text_view: *TextView) c_int;
    pub const getMonospace = gtk_text_view_get_monospace;

    /// Returns whether the `gtk.TextView` is in overwrite mode or not.
    extern fn gtk_text_view_get_overwrite(p_text_view: *TextView) c_int;
    pub const getOverwrite = gtk_text_view_get_overwrite;

    /// Gets the default number of pixels to put above paragraphs.
    /// Adding this function with `gtk.TextView.getPixelsBelowLines`
    /// is equal to the line space between each paragraph.
    extern fn gtk_text_view_get_pixels_above_lines(p_text_view: *TextView) c_int;
    pub const getPixelsAboveLines = gtk_text_view_get_pixels_above_lines;

    /// Gets the value set by `gtk.TextView.setPixelsBelowLines`.
    ///
    /// The line space is the sum of the value returned by this function and the
    /// value returned by `gtk.TextView.getPixelsAboveLines`.
    extern fn gtk_text_view_get_pixels_below_lines(p_text_view: *TextView) c_int;
    pub const getPixelsBelowLines = gtk_text_view_get_pixels_below_lines;

    /// Gets the value set by `gtk.TextView.setPixelsInsideWrap`.
    extern fn gtk_text_view_get_pixels_inside_wrap(p_text_view: *TextView) c_int;
    pub const getPixelsInsideWrap = gtk_text_view_get_pixels_inside_wrap;

    /// Gets the default right margin for text in `text_view`. Tags
    /// in the buffer may override the default.
    extern fn gtk_text_view_get_right_margin(p_text_view: *TextView) c_int;
    pub const getRightMargin = gtk_text_view_get_right_margin;

    /// Gets the default tabs for `text_view`. Tags in the buffer may
    /// override the defaults. The returned array will be `NULL` if
    /// “standard” (8-space) tabs are used. Free the return value
    /// with `pango.TabArray.free`.
    extern fn gtk_text_view_get_tabs(p_text_view: *TextView) ?*pango.TabArray;
    pub const getTabs = gtk_text_view_get_tabs;

    /// Gets the top margin for text in the `text_view`.
    extern fn gtk_text_view_get_top_margin(p_text_view: *TextView) c_int;
    pub const getTopMargin = gtk_text_view_get_top_margin;

    /// Gets the vertical-scrolling `gtk.Adjustment`.
    extern fn gtk_text_view_get_vadjustment(p_text_view: *TextView) *gtk.Adjustment;
    pub const getVadjustment = gtk_text_view_get_vadjustment;

    /// Fills `visible_rect` with the currently-visible
    /// region of the buffer, in buffer coordinates. Convert to window coordinates
    /// with `gtk.TextView.bufferToWindowCoords`.
    extern fn gtk_text_view_get_visible_rect(p_text_view: *TextView, p_visible_rect: *gdk.Rectangle) void;
    pub const getVisibleRect = gtk_text_view_get_visible_rect;

    /// Retrieves the `gdk.Window` corresponding to an area of the text view;
    /// possible windows include the overall widget window, child windows
    /// on the left, right, top, bottom, and the window that displays the
    /// text buffer. Windows are `NULL` and nonexistent if their width or
    /// height is 0, and are nonexistent before the widget has been
    /// realized.
    extern fn gtk_text_view_get_window(p_text_view: *TextView, p_win: gtk.TextWindowType) ?*gdk.Window;
    pub const getWindow = gtk_text_view_get_window;

    /// Usually used to find out which window an event corresponds to.
    ///
    /// If you connect to an event signal on `text_view`, this function
    /// should be called on `event->window` to see which window it was.
    extern fn gtk_text_view_get_window_type(p_text_view: *TextView, p_window: *gdk.Window) gtk.TextWindowType;
    pub const getWindowType = gtk_text_view_get_window_type;

    /// Gets the line wrapping for the view.
    extern fn gtk_text_view_get_wrap_mode(p_text_view: *TextView) gtk.WrapMode;
    pub const getWrapMode = gtk_text_view_get_wrap_mode;

    /// Allow the `gtk.TextView` input method to internally handle key press
    /// and release events. If this function returns `TRUE`, then no further
    /// processing should be done for this key event. See
    /// `gtk.IMContext.filterKeypress`.
    ///
    /// Note that you are expected to call this function from your handler
    /// when overriding key event handling. This is needed in the case when
    /// you need to insert your own key handling between the input method
    /// and the default key event handling of the `gtk.TextView`.
    ///
    /// ```
    /// static gboolean
    /// gtk_foo_bar_key_press_event (GtkWidget   *widget,
    ///                              GdkEventKey *event)
    /// {
    ///   guint keyval;
    ///
    ///   gdk_event_get_keyval ((GdkEvent*)event, &keyval);
    ///
    ///   if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
    ///     {
    ///       if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
    ///         return TRUE;
    ///     }
    ///
    ///   // Do some stuff
    ///
    ///   return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
    /// }
    /// ```
    extern fn gtk_text_view_im_context_filter_keypress(p_text_view: *TextView, p_event: *gdk.EventKey) c_int;
    pub const imContextFilterKeypress = gtk_text_view_im_context_filter_keypress;

    /// Updates the position of a child, as for `gtk.TextView.addChildInWindow`.
    extern fn gtk_text_view_move_child(p_text_view: *TextView, p_child: *gtk.Widget, p_xpos: c_int, p_ypos: c_int) void;
    pub const moveChild = gtk_text_view_move_child;

    /// Moves a mark within the buffer so that it's
    /// located within the currently-visible text area.
    extern fn gtk_text_view_move_mark_onscreen(p_text_view: *TextView, p_mark: *gtk.TextMark) c_int;
    pub const moveMarkOnscreen = gtk_text_view_move_mark_onscreen;

    /// Move the iterator a given number of characters visually, treating
    /// it as the strong cursor position. If `count` is positive, then the
    /// new strong cursor position will be `count` positions to the right of
    /// the old cursor position. If `count` is negative then the new strong
    /// cursor position will be `count` positions to the left of the old
    /// cursor position.
    ///
    /// In the presence of bi-directional text, the correspondence
    /// between logical and visual order will depend on the direction
    /// of the current run, and there may be jumps when the cursor
    /// is moved off of the end of a run.
    extern fn gtk_text_view_move_visually(p_text_view: *TextView, p_iter: *gtk.TextIter, p_count: c_int) c_int;
    pub const moveVisually = gtk_text_view_move_visually;

    /// Moves the cursor to the currently visible region of the
    /// buffer, it it isn’t there already.
    extern fn gtk_text_view_place_cursor_onscreen(p_text_view: *TextView) c_int;
    pub const placeCursorOnscreen = gtk_text_view_place_cursor_onscreen;

    /// Ensures that the cursor is shown (i.e. not in an 'off' blink
    /// interval) and resets the time that it will stay blinking (or
    /// visible, in case blinking is disabled).
    ///
    /// This function should be called in response to user input
    /// (e.g. from derived classes that override the textview's
    /// `gtk.Widget.signals.key`-press-event handler).
    extern fn gtk_text_view_reset_cursor_blink(p_text_view: *TextView) void;
    pub const resetCursorBlink = gtk_text_view_reset_cursor_blink;

    /// Reset the input method context of the text view if needed.
    ///
    /// This can be necessary in the case where modifying the buffer
    /// would confuse on-going input method behavior.
    extern fn gtk_text_view_reset_im_context(p_text_view: *TextView) void;
    pub const resetImContext = gtk_text_view_reset_im_context;

    /// Scrolls `text_view` the minimum distance such that `mark` is contained
    /// within the visible area of the widget.
    extern fn gtk_text_view_scroll_mark_onscreen(p_text_view: *TextView, p_mark: *gtk.TextMark) void;
    pub const scrollMarkOnscreen = gtk_text_view_scroll_mark_onscreen;

    /// Scrolls `text_view` so that `iter` is on the screen in the position
    /// indicated by `xalign` and `yalign`. An alignment of 0.0 indicates
    /// left or top, 1.0 indicates right or bottom, 0.5 means center.
    /// If `use_align` is `FALSE`, the text scrolls the minimal distance to
    /// get the mark onscreen, possibly not scrolling at all. The effective
    /// screen for purposes of this function is reduced by a margin of size
    /// `within_margin`.
    ///
    /// Note that this function uses the currently-computed height of the
    /// lines in the text buffer. Line heights are computed in an idle
    /// handler; so this function may not have the desired effect if it’s
    /// called before the height computations. To avoid oddness, consider
    /// using `gtk.TextView.scrollToMark` which saves a point to be
    /// scrolled to after line validation.
    extern fn gtk_text_view_scroll_to_iter(p_text_view: *TextView, p_iter: *gtk.TextIter, p_within_margin: f64, p_use_align: c_int, p_xalign: f64, p_yalign: f64) c_int;
    pub const scrollToIter = gtk_text_view_scroll_to_iter;

    /// Scrolls `text_view` so that `mark` is on the screen in the position
    /// indicated by `xalign` and `yalign`. An alignment of 0.0 indicates
    /// left or top, 1.0 indicates right or bottom, 0.5 means center.
    /// If `use_align` is `FALSE`, the text scrolls the minimal distance to
    /// get the mark onscreen, possibly not scrolling at all. The effective
    /// screen for purposes of this function is reduced by a margin of size
    /// `within_margin`.
    extern fn gtk_text_view_scroll_to_mark(p_text_view: *TextView, p_mark: *gtk.TextMark, p_within_margin: f64, p_use_align: c_int, p_xalign: f64, p_yalign: f64) void;
    pub const scrollToMark = gtk_text_view_scroll_to_mark;

    /// Sets the behavior of the text widget when the Tab key is pressed.
    /// If `accepts_tab` is `TRUE`, a tab character is inserted. If `accepts_tab`
    /// is `FALSE` the keyboard focus is moved to the next widget in the focus
    /// chain.
    extern fn gtk_text_view_set_accepts_tab(p_text_view: *TextView, p_accepts_tab: c_int) void;
    pub const setAcceptsTab = gtk_text_view_set_accepts_tab;

    /// Sets the width of `GTK_TEXT_WINDOW_LEFT` or `GTK_TEXT_WINDOW_RIGHT`,
    /// or the height of `GTK_TEXT_WINDOW_TOP` or `GTK_TEXT_WINDOW_BOTTOM`.
    /// Automatically destroys the corresponding window if the size is set
    /// to 0, and creates the window if the size is set to non-zero.  This
    /// function can only be used for the “border windows”, and it won’t
    /// work with `GTK_TEXT_WINDOW_WIDGET`, `GTK_TEXT_WINDOW_TEXT`, or
    /// `GTK_TEXT_WINDOW_PRIVATE`.
    extern fn gtk_text_view_set_border_window_size(p_text_view: *TextView, p_type: gtk.TextWindowType, p_size: c_int) void;
    pub const setBorderWindowSize = gtk_text_view_set_border_window_size;

    /// Sets the bottom margin for text in `text_view`.
    ///
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    extern fn gtk_text_view_set_bottom_margin(p_text_view: *TextView, p_bottom_margin: c_int) void;
    pub const setBottomMargin = gtk_text_view_set_bottom_margin;

    /// Sets `buffer` as the buffer being displayed by `text_view`. The previous
    /// buffer displayed by the text view is unreferenced, and a reference is
    /// added to `buffer`. If you owned a reference to `buffer` before passing it
    /// to this function, you must remove that reference yourself; `gtk.TextView`
    /// will not “adopt” it.
    extern fn gtk_text_view_set_buffer(p_text_view: *TextView, p_buffer: ?*gtk.TextBuffer) void;
    pub const setBuffer = gtk_text_view_set_buffer;

    /// Toggles whether the insertion point should be displayed. A buffer with
    /// no editable text probably shouldn’t have a visible cursor, so you may
    /// want to turn the cursor off.
    ///
    /// Note that this property may be overridden by the
    /// `gtk.Settings.properties.gtk`-keynave-use-caret settings.
    extern fn gtk_text_view_set_cursor_visible(p_text_view: *TextView, p_setting: c_int) void;
    pub const setCursorVisible = gtk_text_view_set_cursor_visible;

    /// Sets the default editability of the `gtk.TextView`. You can override
    /// this default setting with tags in the buffer, using the “editable”
    /// attribute of tags.
    extern fn gtk_text_view_set_editable(p_text_view: *TextView, p_setting: c_int) void;
    pub const setEditable = gtk_text_view_set_editable;

    /// Sets the default indentation for paragraphs in `text_view`.
    /// Tags in the buffer may override the default.
    extern fn gtk_text_view_set_indent(p_text_view: *TextView, p_indent: c_int) void;
    pub const setIndent = gtk_text_view_set_indent;

    /// Sets the `gtk.TextView.properties.input`-hints property, which
    /// allows input methods to fine-tune their behaviour.
    extern fn gtk_text_view_set_input_hints(p_text_view: *TextView, p_hints: gtk.InputHints) void;
    pub const setInputHints = gtk_text_view_set_input_hints;

    /// Sets the `gtk.TextView.properties.input`-purpose property which
    /// can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    extern fn gtk_text_view_set_input_purpose(p_text_view: *TextView, p_purpose: gtk.InputPurpose) void;
    pub const setInputPurpose = gtk_text_view_set_input_purpose;

    /// Sets the default justification of text in `text_view`.
    /// Tags in the view’s buffer may override the default.
    extern fn gtk_text_view_set_justification(p_text_view: *TextView, p_justification: gtk.Justification) void;
    pub const setJustification = gtk_text_view_set_justification;

    /// Sets the default left margin for text in `text_view`.
    /// Tags in the buffer may override the default.
    ///
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    extern fn gtk_text_view_set_left_margin(p_text_view: *TextView, p_left_margin: c_int) void;
    pub const setLeftMargin = gtk_text_view_set_left_margin;

    /// Sets the `gtk.TextView.properties.monospace` property, which
    /// indicates that the text view should use monospace
    /// fonts.
    extern fn gtk_text_view_set_monospace(p_text_view: *TextView, p_monospace: c_int) void;
    pub const setMonospace = gtk_text_view_set_monospace;

    /// Changes the `gtk.TextView` overwrite mode.
    extern fn gtk_text_view_set_overwrite(p_text_view: *TextView, p_overwrite: c_int) void;
    pub const setOverwrite = gtk_text_view_set_overwrite;

    /// Sets the default number of blank pixels above paragraphs in `text_view`.
    /// Tags in the buffer for `text_view` may override the defaults.
    extern fn gtk_text_view_set_pixels_above_lines(p_text_view: *TextView, p_pixels_above_lines: c_int) void;
    pub const setPixelsAboveLines = gtk_text_view_set_pixels_above_lines;

    /// Sets the default number of pixels of blank space
    /// to put below paragraphs in `text_view`. May be overridden
    /// by tags applied to `text_view`’s buffer.
    extern fn gtk_text_view_set_pixels_below_lines(p_text_view: *TextView, p_pixels_below_lines: c_int) void;
    pub const setPixelsBelowLines = gtk_text_view_set_pixels_below_lines;

    /// Sets the default number of pixels of blank space to leave between
    /// display/wrapped lines within a paragraph. May be overridden by
    /// tags in `text_view`’s buffer.
    extern fn gtk_text_view_set_pixels_inside_wrap(p_text_view: *TextView, p_pixels_inside_wrap: c_int) void;
    pub const setPixelsInsideWrap = gtk_text_view_set_pixels_inside_wrap;

    /// Sets the default right margin for text in the text view.
    /// Tags in the buffer may override the default.
    ///
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    extern fn gtk_text_view_set_right_margin(p_text_view: *TextView, p_right_margin: c_int) void;
    pub const setRightMargin = gtk_text_view_set_right_margin;

    /// Sets the default tab stops for paragraphs in `text_view`.
    /// Tags in the buffer may override the default.
    extern fn gtk_text_view_set_tabs(p_text_view: *TextView, p_tabs: *pango.TabArray) void;
    pub const setTabs = gtk_text_view_set_tabs;

    /// Sets the top margin for text in `text_view`.
    ///
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    extern fn gtk_text_view_set_top_margin(p_text_view: *TextView, p_top_margin: c_int) void;
    pub const setTopMargin = gtk_text_view_set_top_margin;

    /// Sets the line wrapping for the view.
    extern fn gtk_text_view_set_wrap_mode(p_text_view: *TextView, p_wrap_mode: gtk.WrapMode) void;
    pub const setWrapMode = gtk_text_view_set_wrap_mode;

    /// Determines whether `iter` is at the start of a display line.
    /// See `gtk.TextView.forwardDisplayLine` for an explanation of
    /// display lines vs. paragraphs.
    extern fn gtk_text_view_starts_display_line(p_text_view: *TextView, p_iter: *const gtk.TextIter) c_int;
    pub const startsDisplayLine = gtk_text_view_starts_display_line;

    /// Converts coordinates on the window identified by `win` to buffer
    /// coordinates, storing the result in (`buffer_x`,`buffer_y`).
    ///
    /// Note that you can’t convert coordinates for a nonexisting window (see
    /// `gtk.TextView.setBorderWindowSize`).
    extern fn gtk_text_view_window_to_buffer_coords(p_text_view: *TextView, p_win: gtk.TextWindowType, p_window_x: c_int, p_window_y: c_int, p_buffer_x: ?*c_int, p_buffer_y: ?*c_int) void;
    pub const windowToBufferCoords = gtk_text_view_window_to_buffer_coords;

    extern fn gtk_text_view_get_type() usize;
    pub const getGObjectType = gtk_text_view_get_type;

    extern fn g_object_ref(p_self: *gtk.TextView) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TextView) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TextView, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextViewAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{ atk.Component, atk.EditableText, atk.StreamableContent, atk.Text };
    pub const Class = gtk.TextViewAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.TextViewAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_text_view_accessible_get_type() usize;
    pub const getGObjectType = gtk_text_view_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.TextViewAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TextViewAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TextViewAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.ThemingEngine` was the object used for rendering themed content
/// in GTK+ widgets. It used to allow overriding GTK+'s default
/// implementation of rendering functions by allowing engines to be
/// loaded as modules.
///
/// `gtk.ThemingEngine` has been deprecated in GTK+ 3.14 and will be
/// ignored for rendering. The advancements in CSS theming are good
/// enough to allow themers to achieve their goals without the need
/// to modify source code.
pub const ThemingEngine = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.ThemingEngineClass;
    f_parent_object: gobject.Object,
    f_priv: ?*gtk.ThemingEnginePrivate,

    pub const virtual_methods = struct {
        /// Renders an area displaying activity, such as in `gtk.Spinner`,
        ///                   or `gtk.ProgressBar`.
        pub const render_activity = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_activity.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_activity = @ptrCast(p_implementation);
            }
        };

        /// Renders an arrow pointing to a certain direction.
        pub const render_arrow = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_angle: f64, p_x: f64, p_y: f64, p_size: f64) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_arrow.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_angle, p_x, p_y, p_size);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_angle: f64, p_x: f64, p_y: f64, p_size: f64) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_arrow = @ptrCast(p_implementation);
            }
        };

        /// Renders the background area of a widget region.
        pub const render_background = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_background.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_background = @ptrCast(p_implementation);
            }
        };

        /// Renders a checkmark, as in `gtk.CheckButton`.
        pub const render_check = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_check.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_check = @ptrCast(p_implementation);
            }
        };

        /// Renders an element what will expose/expand part of
        ///                   the UI, as in `gtk.Expander`.
        pub const render_expander = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_expander.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_expander = @ptrCast(p_implementation);
            }
        };

        /// Renders a extension to a box, usually a notebook tab.
        pub const render_extension = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64, p_gap_side: gtk.PositionType) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_extension.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_x, p_y, p_width, p_height, p_gap_side);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64, p_gap_side: gtk.PositionType) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_extension = @ptrCast(p_implementation);
            }
        };

        /// Renders the focus indicator.
        pub const render_focus = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_focus.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_focus = @ptrCast(p_implementation);
            }
        };

        /// Renders the frame around a widget area.
        pub const render_frame = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_frame.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_frame = @ptrCast(p_implementation);
            }
        };

        /// Renders the frame around a widget area with a gap in it.
        pub const render_frame_gap = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64, p_gap_side: gtk.PositionType, p_xy0_gap: f64, p_xy1_gap: f64) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_frame_gap.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_x, p_y, p_width, p_height, p_gap_side, p_xy0_gap, p_xy1_gap);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64, p_gap_side: gtk.PositionType, p_xy0_gap: f64, p_xy1_gap: f64) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_frame_gap = @ptrCast(p_implementation);
            }
        };

        /// Renders a handle to drag UI elements, as in `gtk.Paned`.
        pub const render_handle = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_handle.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_handle = @ptrCast(p_implementation);
            }
        };

        /// Renders an icon given as a `gdkpixbuf.Pixbuf`.
        pub const render_icon = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_pixbuf: *gdkpixbuf.Pixbuf, p_x: f64, p_y: f64) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_icon.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_pixbuf, p_x, p_y);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_pixbuf: *gdkpixbuf.Pixbuf, p_x: f64, p_y: f64) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_icon = @ptrCast(p_implementation);
            }
        };

        /// Renders an icon as a `gdkpixbuf.Pixbuf`.
        pub const render_icon_pixbuf = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_source: *const gtk.IconSource, p_size: gtk.IconSize) *gdkpixbuf.Pixbuf {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_icon_pixbuf.?(gobject.ext.as(ThemingEngine, p_engine), p_source, p_size);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_source: *const gtk.IconSource, p_size: gtk.IconSize) callconv(.c) *gdkpixbuf.Pixbuf) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_icon_pixbuf = @ptrCast(p_implementation);
            }
        };

        /// Renders an icon given as a `cairo.Surface`.
        pub const render_icon_surface = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_surface: *cairo.Surface, p_x: f64, p_y: f64) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_icon_surface.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_surface, p_x, p_y);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_surface: *cairo.Surface, p_x: f64, p_y: f64) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_icon_surface = @ptrCast(p_implementation);
            }
        };

        /// Renders a `pango.Layout`
        pub const render_layout = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_layout: *pango.Layout) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_layout.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_x, p_y, p_layout);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_layout: *pango.Layout) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_layout = @ptrCast(p_implementation);
            }
        };

        /// Renders a line between two points.
        pub const render_line = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x0: f64, p_y0: f64, p_x1: f64, p_y1: f64) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_line.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_x0, p_y0, p_x1, p_y1);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x0: f64, p_y0: f64, p_x1: f64, p_y1: f64) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_line = @ptrCast(p_implementation);
            }
        };

        /// Renders an option, as in `gtk.RadioButton`.
        pub const render_option = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_option.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_x, p_y, p_width, p_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_option = @ptrCast(p_implementation);
            }
        };

        /// Renders a slider control, as in `gtk.Scale`.
        pub const render_slider = struct {
            pub fn call(p_class: anytype, p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64, p_orientation: gtk.Orientation) void {
                return gobject.ext.as(ThemingEngine.Class, p_class).f_render_slider.?(gobject.ext.as(ThemingEngine, p_engine), p_cr, p_x, p_y, p_width, p_height, p_orientation);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_engine: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64, p_orientation: gtk.Orientation) callconv(.c) void) void {
                gobject.ext.as(ThemingEngine.Class, p_class).f_render_slider = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The theming engine name, this name will be used when registering
        /// custom properties, for a theming engine named "Clearlooks" registering
        /// a "glossy" custom property, it could be referenced in the CSS file as
        ///
        /// ```
        /// -Clearlooks-glossy: true;
        /// ```
        pub const name = struct {
            pub const name = "name";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Loads and initializes a theming engine module from the
    /// standard directories.
    extern fn gtk_theming_engine_load(p_name: [*:0]const u8) ?*gtk.ThemingEngine;
    pub const load = gtk_theming_engine_load;

    /// Registers a property so it can be used in the CSS file format,
    /// on the CSS file the property will look like
    /// "-${`name_space`}-${property_name}". being
    /// ${property_name} the given to `pspec`. `name_space` will usually
    /// be the theme engine name.
    ///
    /// For any type a `parse_func` may be provided, being this function
    /// used for turning any property value (between “:” and “;”) in
    /// CSS to the `gobject.Value` needed. For basic types there is already
    /// builtin parsing support, so `NULL` may be provided for these
    /// cases.
    ///
    /// Engines must ensure property registration happens exactly once,
    /// usually GTK+ deals with theming engines as singletons, so this
    /// should be guaranteed to happen once, but bear this in mind
    /// when creating `GtkThemeEngines` yourself.
    ///
    /// In order to make use of the custom registered properties in
    /// the CSS file, make sure the engine is loaded first by specifying
    /// the engine property, either in a previous rule or within the same
    /// one.
    /// ```
    /// * {
    ///     engine: someengine;
    ///     -SomeEngine-custom-property: 2;
    /// }
    /// ```
    extern fn gtk_theming_engine_register_property(p_name_space: [*:0]const u8, p_parse_func: ?gtk.StylePropertyParser, p_pspec: *gobject.ParamSpec) void;
    pub const registerProperty = gtk_theming_engine_register_property;

    /// Retrieves several style property values that apply to the currently
    /// rendered element.
    extern fn gtk_theming_engine_get(p_engine: *ThemingEngine, p_state: gtk.StateFlags, ...) void;
    pub const get = gtk_theming_engine_get;

    /// Gets the background color for a given state.
    extern fn gtk_theming_engine_get_background_color(p_engine: *ThemingEngine, p_state: gtk.StateFlags, p_color: *gdk.RGBA) void;
    pub const getBackgroundColor = gtk_theming_engine_get_background_color;

    /// Gets the border for a given state as a `gtk.Border`.
    extern fn gtk_theming_engine_get_border(p_engine: *ThemingEngine, p_state: gtk.StateFlags, p_border: *gtk.Border) void;
    pub const getBorder = gtk_theming_engine_get_border;

    /// Gets the border color for a given state.
    extern fn gtk_theming_engine_get_border_color(p_engine: *ThemingEngine, p_state: gtk.StateFlags, p_color: *gdk.RGBA) void;
    pub const getBorderColor = gtk_theming_engine_get_border_color;

    /// Gets the foreground color for a given state.
    extern fn gtk_theming_engine_get_color(p_engine: *ThemingEngine, p_state: gtk.StateFlags, p_color: *gdk.RGBA) void;
    pub const getColor = gtk_theming_engine_get_color;

    /// Returns the widget direction used for rendering.
    extern fn gtk_theming_engine_get_direction(p_engine: *ThemingEngine) gtk.TextDirection;
    pub const getDirection = gtk_theming_engine_get_direction;

    /// Returns the font description for a given state.
    extern fn gtk_theming_engine_get_font(p_engine: *ThemingEngine, p_state: gtk.StateFlags) *const pango.FontDescription;
    pub const getFont = gtk_theming_engine_get_font;

    /// Returns the widget direction used for rendering.
    extern fn gtk_theming_engine_get_junction_sides(p_engine: *ThemingEngine) gtk.JunctionSides;
    pub const getJunctionSides = gtk_theming_engine_get_junction_sides;

    /// Gets the margin for a given state as a `gtk.Border`.
    extern fn gtk_theming_engine_get_margin(p_engine: *ThemingEngine, p_state: gtk.StateFlags, p_margin: *gtk.Border) void;
    pub const getMargin = gtk_theming_engine_get_margin;

    /// Gets the padding for a given state as a `gtk.Border`.
    extern fn gtk_theming_engine_get_padding(p_engine: *ThemingEngine, p_state: gtk.StateFlags, p_padding: *gtk.Border) void;
    pub const getPadding = gtk_theming_engine_get_padding;

    /// Returns the widget path used for style matching.
    extern fn gtk_theming_engine_get_path(p_engine: *ThemingEngine) *const gtk.WidgetPath;
    pub const getPath = gtk_theming_engine_get_path;

    /// Gets a property value as retrieved from the style settings that apply
    /// to the currently rendered element.
    extern fn gtk_theming_engine_get_property(p_engine: *ThemingEngine, p_property: [*:0]const u8, p_state: gtk.StateFlags, p_value: *gobject.Value) void;
    pub const getProperty = gtk_theming_engine_get_property;

    /// Returns the `gdk.Screen` to which `engine` currently rendering to.
    extern fn gtk_theming_engine_get_screen(p_engine: *ThemingEngine) ?*gdk.Screen;
    pub const getScreen = gtk_theming_engine_get_screen;

    /// returns the state used when rendering.
    extern fn gtk_theming_engine_get_state(p_engine: *ThemingEngine) gtk.StateFlags;
    pub const getState = gtk_theming_engine_get_state;

    /// Retrieves several widget style properties from `engine` according
    /// to the currently rendered content’s style.
    extern fn gtk_theming_engine_get_style(p_engine: *ThemingEngine, ...) void;
    pub const getStyle = gtk_theming_engine_get_style;

    /// Gets the value for a widget style property.
    extern fn gtk_theming_engine_get_style_property(p_engine: *ThemingEngine, p_property_name: [*:0]const u8, p_value: *gobject.Value) void;
    pub const getStyleProperty = gtk_theming_engine_get_style_property;

    /// Retrieves several widget style properties from `engine` according to the
    /// currently rendered content’s style.
    extern fn gtk_theming_engine_get_style_valist(p_engine: *ThemingEngine, p_args: std.builtin.VaList) void;
    pub const getStyleValist = gtk_theming_engine_get_style_valist;

    /// Retrieves several style property values that apply to the currently
    /// rendered element.
    extern fn gtk_theming_engine_get_valist(p_engine: *ThemingEngine, p_state: gtk.StateFlags, p_args: std.builtin.VaList) void;
    pub const getValist = gtk_theming_engine_get_valist;

    /// Returns `TRUE` if the currently rendered contents have
    /// defined the given class name.
    extern fn gtk_theming_engine_has_class(p_engine: *ThemingEngine, p_style_class: [*:0]const u8) c_int;
    pub const hasClass = gtk_theming_engine_has_class;

    /// Returns `TRUE` if the currently rendered contents have the
    /// region defined. If `flags_return` is not `NULL`, it is set
    /// to the flags affecting the region.
    extern fn gtk_theming_engine_has_region(p_engine: *ThemingEngine, p_style_region: [*:0]const u8, p_flags: ?*gtk.RegionFlags) c_int;
    pub const hasRegion = gtk_theming_engine_has_region;

    /// Looks up and resolves a color name in the current style’s color map.
    extern fn gtk_theming_engine_lookup_color(p_engine: *ThemingEngine, p_color_name: [*:0]const u8, p_color: *gdk.RGBA) c_int;
    pub const lookupColor = gtk_theming_engine_lookup_color;

    /// Returns `TRUE` if there is a transition animation running for the
    /// current region (see `gtk.StyleContext.pushAnimatableRegion`).
    ///
    /// If `progress` is not `NULL`, the animation progress will be returned
    /// there, 0.0 means the state is closest to being `FALSE`, while 1.0 means
    /// it’s closest to being `TRUE`. This means transition animations will
    /// run from 0 to 1 when `state` is being set to `TRUE` and from 1 to 0 when
    /// it’s being set to `FALSE`.
    extern fn gtk_theming_engine_state_is_running(p_engine: *ThemingEngine, p_state: gtk.StateType, p_progress: *f64) c_int;
    pub const stateIsRunning = gtk_theming_engine_state_is_running;

    extern fn gtk_theming_engine_get_type() usize;
    pub const getGObjectType = gtk_theming_engine_get_type;

    extern fn g_object_ref(p_self: *gtk.ThemingEngine) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ThemingEngine) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ThemingEngine, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.ToggleAction` corresponds roughly to a `gtk.CheckMenuItem`. It has an
/// “active” state specifying whether the action has been checked or not.
pub const ToggleAction = extern struct {
    pub const Parent = gtk.Action;
    pub const Implements = [_]type{gtk.Buildable};
    pub const Class = gtk.ToggleActionClass;
    f_parent: gtk.Action,
    f_private_data: ?*gtk.ToggleActionPrivate,

    pub const virtual_methods = struct {
        /// Emits the “toggled” signal on the toggle action.
        pub const toggled = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ToggleAction.Class, p_class).f_toggled.?(gobject.ext.as(ToggleAction, p_action));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ToggleAction.Class, p_class).f_toggled = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Whether the toggle action should be active.
        pub const active = struct {
            pub const name = "active";

            pub const Type = c_int;
        };

        /// Whether the proxies for this action look like radio action proxies.
        ///
        /// This is an appearance property and thus only applies if
        /// `gtk.Activatable.properties.use`-action-appearance is `TRUE`.
        pub const draw_as_radio = struct {
            pub const name = "draw-as-radio";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Should be connected if you wish to perform an action
        /// whenever the `gtk.ToggleAction` state is changed.
        pub const toggled = struct {
            pub const name = "toggled";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ToggleAction, p_instance))),
                    gobject.signalLookup("toggled", ToggleAction.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.ToggleAction` object. To add the action to
    /// a `gtk.ActionGroup` and set the accelerator for the action,
    /// call `gtk.ActionGroup.addActionWithAccel`.
    extern fn gtk_toggle_action_new(p_name: [*:0]const u8, p_label: ?[*:0]const u8, p_tooltip: ?[*:0]const u8, p_stock_id: ?[*:0]const u8) *gtk.ToggleAction;
    pub const new = gtk_toggle_action_new;

    /// Returns the checked state of the toggle action.
    extern fn gtk_toggle_action_get_active(p_action: *ToggleAction) c_int;
    pub const getActive = gtk_toggle_action_get_active;

    /// Returns whether the action should have proxies like a radio action.
    extern fn gtk_toggle_action_get_draw_as_radio(p_action: *ToggleAction) c_int;
    pub const getDrawAsRadio = gtk_toggle_action_get_draw_as_radio;

    /// Sets the checked state on the toggle action.
    extern fn gtk_toggle_action_set_active(p_action: *ToggleAction, p_is_active: c_int) void;
    pub const setActive = gtk_toggle_action_set_active;

    /// Sets whether the action should have proxies like a radio action.
    extern fn gtk_toggle_action_set_draw_as_radio(p_action: *ToggleAction, p_draw_as_radio: c_int) void;
    pub const setDrawAsRadio = gtk_toggle_action_set_draw_as_radio;

    /// Emits the “toggled” signal on the toggle action.
    extern fn gtk_toggle_action_toggled(p_action: *ToggleAction) void;
    pub const toggled = gtk_toggle_action_toggled;

    extern fn gtk_toggle_action_get_type() usize;
    pub const getGObjectType = gtk_toggle_action_get_type;

    extern fn g_object_ref(p_self: *gtk.ToggleAction) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ToggleAction) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ToggleAction, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.ToggleButton` is a `gtk.Button` which will remain “pressed-in” when
/// clicked. Clicking again will cause the toggle button to return to its
/// normal state.
///
/// A toggle button is created by calling either `gtk.ToggleButton.new` or
/// `gtk.ToggleButton.newWithLabel`. If using the former, it is advisable to
/// pack a widget, (such as a `gtk.Label` and/or a `gtk.Image`), into the toggle
/// button’s container. (See `gtk.Button` for more information).
///
/// The state of a `gtk.ToggleButton` can be set specifically using
/// `gtk.ToggleButton.setActive`, and retrieved using
/// `gtk.ToggleButton.getActive`.
///
/// To simply switch the state of a toggle button, use `gtk.ToggleButton.toggled`.
///
/// # CSS nodes
///
/// GtkToggleButton has a single CSS node with name button. To differentiate
/// it from a plain `gtk.Button`, it gets the .toggle style class.
///
/// ## Creating two
///
/// ```
/// static void output_state (GtkToggleButton *source, gpointer user_data) {
///   printf ("Active: `d`\n", gtk_toggle_button_get_active (source));
/// }
///
/// void make_toggles (void) {
///   GtkWidget *window, *toggle1, *toggle2;
///   GtkWidget *box;
///   const char *text;
///
///   window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
///   box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
///
///   text = "Hi, I’m a toggle button.";
///   toggle1 = gtk_toggle_button_new_with_label (text);
///
///   // Makes this toggle button invisible
///   gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle1),
///                               TRUE);
///
///   g_signal_connect (toggle1, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_container_add (GTK_CONTAINER (box), toggle1);
///
///   text = "Hi, I’m a toggle button.";
///   toggle2 = gtk_toggle_button_new_with_label (text);
///   gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle2),
///                               FALSE);
///   g_signal_connect (toggle2, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_container_add (GTK_CONTAINER (box), toggle2);
///
///   gtk_container_add (GTK_CONTAINER (window), box);
///   gtk_widget_show_all (window);
/// }
/// ```
pub const ToggleButton = extern struct {
    pub const Parent = gtk.Button;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.ToggleButtonClass;
    f_button: gtk.Button,
    f_priv: ?*gtk.ToggleButtonPrivate,

    pub const virtual_methods = struct {
        /// Emits the `gtk.ToggleButton.signals.toggled` signal on the
        /// `gtk.ToggleButton`. There is no good reason for an
        /// application ever to call this function.
        pub const toggled = struct {
            pub fn call(p_class: anytype, p_toggle_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ToggleButton.Class, p_class).f_toggled.?(gobject.ext.as(ToggleButton, p_toggle_button));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_toggle_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ToggleButton.Class, p_class).f_toggled = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const active = struct {
            pub const name = "active";

            pub const Type = c_int;
        };

        pub const draw_indicator = struct {
            pub const name = "draw-indicator";

            pub const Type = c_int;
        };

        pub const inconsistent = struct {
            pub const name = "inconsistent";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Should be connected if you wish to perform an action whenever the
        /// `gtk.ToggleButton`'s state is changed.
        pub const toggled = struct {
            pub const name = "toggled";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ToggleButton, p_instance))),
                    gobject.signalLookup("toggled", ToggleButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new toggle button. A widget should be packed into the button, as in `gtk.Button.new`.
    extern fn gtk_toggle_button_new() *gtk.ToggleButton;
    pub const new = gtk_toggle_button_new;

    /// Creates a new toggle button with a text label.
    extern fn gtk_toggle_button_new_with_label(p_label: [*:0]const u8) *gtk.ToggleButton;
    pub const newWithLabel = gtk_toggle_button_new_with_label;

    /// Creates a new `gtk.ToggleButton` containing a label. The label
    /// will be created using `gtk.Label.newWithMnemonic`, so underscores
    /// in `label` indicate the mnemonic for the button.
    extern fn gtk_toggle_button_new_with_mnemonic(p_label: [*:0]const u8) *gtk.ToggleButton;
    pub const newWithMnemonic = gtk_toggle_button_new_with_mnemonic;

    /// Queries a `gtk.ToggleButton` and returns its current state. Returns `TRUE` if
    /// the toggle button is pressed in and `FALSE` if it is raised.
    extern fn gtk_toggle_button_get_active(p_toggle_button: *ToggleButton) c_int;
    pub const getActive = gtk_toggle_button_get_active;

    /// Gets the value set by `gtk.ToggleButton.setInconsistent`.
    extern fn gtk_toggle_button_get_inconsistent(p_toggle_button: *ToggleButton) c_int;
    pub const getInconsistent = gtk_toggle_button_get_inconsistent;

    /// Retrieves whether the button is displayed as a separate indicator
    /// and label. See `gtk.ToggleButton.setMode`.
    extern fn gtk_toggle_button_get_mode(p_toggle_button: *ToggleButton) c_int;
    pub const getMode = gtk_toggle_button_get_mode;

    /// Sets the status of the toggle button. Set to `TRUE` if you want the
    /// GtkToggleButton to be “pressed in”, and `FALSE` to raise it.
    /// This action causes the `gtk.ToggleButton.signals.toggled` signal and the
    /// `gtk.Button.signals.clicked` signal to be emitted.
    extern fn gtk_toggle_button_set_active(p_toggle_button: *ToggleButton, p_is_active: c_int) void;
    pub const setActive = gtk_toggle_button_set_active;

    /// If the user has selected a range of elements (such as some text or
    /// spreadsheet cells) that are affected by a toggle button, and the
    /// current values in that range are inconsistent, you may want to
    /// display the toggle in an “in between” state. This function turns on
    /// “in between” display.  Normally you would turn off the inconsistent
    /// state again if the user toggles the toggle button. This has to be
    /// done manually, `gtk.ToggleButton.setInconsistent` only affects
    /// visual appearance, it doesn’t affect the semantics of the button.
    extern fn gtk_toggle_button_set_inconsistent(p_toggle_button: *ToggleButton, p_setting: c_int) void;
    pub const setInconsistent = gtk_toggle_button_set_inconsistent;

    /// Sets whether the button is displayed as a separate indicator and label.
    /// You can call this function on a checkbutton or a radiobutton with
    /// `draw_indicator` = `FALSE` to make the button look like a normal button.
    ///
    /// This can be used to create linked strip of buttons that work like
    /// a `gtk.StackSwitcher`.
    ///
    /// This function only affects instances of classes like `gtk.CheckButton`
    /// and `gtk.RadioButton` that derive from `gtk.ToggleButton`,
    /// not instances of `gtk.ToggleButton` itself.
    extern fn gtk_toggle_button_set_mode(p_toggle_button: *ToggleButton, p_draw_indicator: c_int) void;
    pub const setMode = gtk_toggle_button_set_mode;

    /// Emits the `gtk.ToggleButton.signals.toggled` signal on the
    /// `gtk.ToggleButton`. There is no good reason for an
    /// application ever to call this function.
    extern fn gtk_toggle_button_toggled(p_toggle_button: *ToggleButton) void;
    pub const toggled = gtk_toggle_button_toggled;

    extern fn gtk_toggle_button_get_type() usize;
    pub const getGObjectType = gtk_toggle_button_get_type;

    extern fn g_object_ref(p_self: *gtk.ToggleButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ToggleButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ToggleButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToggleButtonAccessible = extern struct {
    pub const Parent = gtk.ButtonAccessible;
    pub const Implements = [_]type{ atk.Action, atk.Component, atk.Image };
    pub const Class = gtk.ToggleButtonAccessibleClass;
    f_parent: gtk.ButtonAccessible,
    f_priv: ?*gtk.ToggleButtonAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_toggle_button_accessible_get_type() usize;
    pub const getGObjectType = gtk_toggle_button_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ToggleButtonAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ToggleButtonAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ToggleButtonAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.ToggleToolButton` is a `gtk.ToolItem` that contains a toggle
/// button.
///
/// Use `gtk.ToggleToolButton.new` to create a new GtkToggleToolButton.
///
/// # CSS nodes
///
/// GtkToggleToolButton has a single CSS node with name togglebutton.
pub const ToggleToolButton = extern struct {
    pub const Parent = gtk.ToolButton;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.ToggleToolButtonClass;
    f_parent: gtk.ToolButton,
    f_priv: ?*gtk.ToggleToolButtonPrivate,

    pub const virtual_methods = struct {
        /// Signal emitted whenever the toggle tool button changes state.
        pub const toggled = struct {
            pub fn call(p_class: anytype, p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ToggleToolButton.Class, p_class).f_toggled.?(gobject.ext.as(ToggleToolButton, p_button));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_button: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ToggleToolButton.Class, p_class).f_toggled = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// If the toggle tool button should be pressed in.
        pub const active = struct {
            pub const name = "active";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted whenever the toggle tool button changes state.
        pub const toggled = struct {
            pub const name = "toggled";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ToggleToolButton, p_instance))),
                    gobject.signalLookup("toggled", ToggleToolButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Returns a new `gtk.ToggleToolButton`
    extern fn gtk_toggle_tool_button_new() *gtk.ToggleToolButton;
    pub const new = gtk_toggle_tool_button_new;

    /// Creates a new `gtk.ToggleToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    ///
    /// It is an error if `stock_id` is not a name of a stock item.
    extern fn gtk_toggle_tool_button_new_from_stock(p_stock_id: [*:0]const u8) *gtk.ToggleToolButton;
    pub const newFromStock = gtk_toggle_tool_button_new_from_stock;

    /// Queries a `gtk.ToggleToolButton` and returns its current state.
    /// Returns `TRUE` if the toggle button is pressed in and `FALSE` if it is raised.
    extern fn gtk_toggle_tool_button_get_active(p_button: *ToggleToolButton) c_int;
    pub const getActive = gtk_toggle_tool_button_get_active;

    /// Sets the status of the toggle tool button. Set to `TRUE` if you
    /// want the GtkToggleButton to be “pressed in”, and `FALSE` to raise it.
    /// This action causes the toggled signal to be emitted.
    extern fn gtk_toggle_tool_button_set_active(p_button: *ToggleToolButton, p_is_active: c_int) void;
    pub const setActive = gtk_toggle_tool_button_set_active;

    extern fn gtk_toggle_tool_button_get_type() usize;
    pub const getGObjectType = gtk_toggle_tool_button_get_type;

    extern fn g_object_ref(p_self: *gtk.ToggleToolButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ToggleToolButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ToggleToolButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GtkToolButtons` are `GtkToolItems` containing buttons.
///
/// Use `gtk.ToolButton.new` to create a new `gtk.ToolButton`.
///
/// The label of a `gtk.ToolButton` is determined by the properties
/// `gtk.ToolButton.properties.label`-widget, `gtk.ToolButton.properties.label`, and
/// `gtk.ToolButton.properties.stock`-id. If `gtk.ToolButton.properties.label`-widget is
/// non-`NULL`, then that widget is used as the label. Otherwise, if
/// `gtk.ToolButton.properties.label` is non-`NULL`, that string is used as the label.
/// Otherwise, if `gtk.ToolButton.properties.stock`-id is non-`NULL`, the label is
/// determined by the stock item. Otherwise, the button does not have a label.
///
/// The icon of a `gtk.ToolButton` is determined by the properties
/// `gtk.ToolButton.properties.icon`-widget and `gtk.ToolButton.properties.stock`-id. If
/// `gtk.ToolButton.properties.icon`-widget is non-`NULL`, then
/// that widget is used as the icon. Otherwise, if `gtk.ToolButton.properties.stock`-id is
/// non-`NULL`, the icon is determined by the stock item. Otherwise,
/// the button does not have a icon.
///
/// # CSS nodes
///
/// GtkToolButton has a single CSS node with name toolbutton.
pub const ToolButton = extern struct {
    pub const Parent = gtk.ToolItem;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.ToolButtonClass;
    f_parent: gtk.ToolItem,
    f_priv: ?*gtk.ToolButtonPrivate,

    pub const virtual_methods = struct {
        /// Signal emitted when the tool button is clicked with the
        ///    mouse or activated with the keyboard.
        pub const clicked = struct {
            pub fn call(p_class: anytype, p_tool_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ToolButton.Class, p_class).f_clicked.?(gobject.ext.as(ToolButton, p_tool_item));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tool_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ToolButton.Class, p_class).f_clicked = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The name of the themed icon displayed on the item.
        /// This property only has an effect if not overridden by
        /// `gtk.ToolButton.properties.label`-widget, `gtk.ToolButton.properties.icon`-widget or
        /// `gtk.ToolButton.properties.stock`-id properties.
        pub const icon_name = struct {
            pub const name = "icon-name";

            pub const Type = ?[*:0]u8;
        };

        pub const icon_widget = struct {
            pub const name = "icon-widget";

            pub const Type = ?*gtk.Widget;
        };

        pub const label = struct {
            pub const name = "label";

            pub const Type = ?[*:0]u8;
        };

        pub const label_widget = struct {
            pub const name = "label-widget";

            pub const Type = ?*gtk.Widget;
        };

        pub const stock_id = struct {
            pub const name = "stock-id";

            pub const Type = ?[*:0]u8;
        };

        pub const use_underline = struct {
            pub const name = "use-underline";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// This signal is emitted when the tool button is clicked with the mouse
        /// or activated with the keyboard.
        pub const clicked = struct {
            pub const name = "clicked";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ToolButton, p_instance))),
                    gobject.signalLookup("clicked", ToolButton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.ToolButton` using `icon_widget` as contents and `label` as
    /// label.
    extern fn gtk_tool_button_new(p_icon_widget: ?*gtk.Widget, p_label: ?[*:0]const u8) *gtk.ToolButton;
    pub const new = gtk_tool_button_new;

    /// Creates a new `gtk.ToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    ///
    /// It is an error if `stock_id` is not a name of a stock item.
    extern fn gtk_tool_button_new_from_stock(p_stock_id: [*:0]const u8) *gtk.ToolButton;
    pub const newFromStock = gtk_tool_button_new_from_stock;

    /// Returns the name of the themed icon for the tool button,
    /// see `gtk.ToolButton.setIconName`.
    extern fn gtk_tool_button_get_icon_name(p_button: *ToolButton) ?[*:0]const u8;
    pub const getIconName = gtk_tool_button_get_icon_name;

    /// Return the widget used as icon widget on `button`.
    /// See `gtk.ToolButton.setIconWidget`.
    extern fn gtk_tool_button_get_icon_widget(p_button: *ToolButton) ?*gtk.Widget;
    pub const getIconWidget = gtk_tool_button_get_icon_widget;

    /// Returns the label used by the tool button, or `NULL` if the tool button
    /// doesn’t have a label. or uses a the label from a stock item. The returned
    /// string is owned by GTK+, and must not be modified or freed.
    extern fn gtk_tool_button_get_label(p_button: *ToolButton) ?[*:0]const u8;
    pub const getLabel = gtk_tool_button_get_label;

    /// Returns the widget used as label on `button`.
    /// See `gtk.ToolButton.setLabelWidget`.
    extern fn gtk_tool_button_get_label_widget(p_button: *ToolButton) ?*gtk.Widget;
    pub const getLabelWidget = gtk_tool_button_get_label_widget;

    /// Returns the name of the stock item. See `gtk.ToolButton.setStockId`.
    /// The returned string is owned by GTK+ and must not be freed or modifed.
    extern fn gtk_tool_button_get_stock_id(p_button: *ToolButton) [*:0]const u8;
    pub const getStockId = gtk_tool_button_get_stock_id;

    /// Returns whether underscores in the label property are used as mnemonics
    /// on menu items on the overflow menu. See `gtk.ToolButton.setUseUnderline`.
    extern fn gtk_tool_button_get_use_underline(p_button: *ToolButton) c_int;
    pub const getUseUnderline = gtk_tool_button_get_use_underline;

    /// Sets the icon for the tool button from a named themed icon.
    /// See the docs for `gtk.IconTheme` for more details.
    /// The `gtk.ToolButton.properties.icon`-name property only has an effect if not
    /// overridden by non-`NULL` `gtk.ToolButton.properties.label`-widget,
    /// `gtk.ToolButton.properties.icon`-widget and `gtk.ToolButton.properties.stock`-id properties.
    extern fn gtk_tool_button_set_icon_name(p_button: *ToolButton, p_icon_name: ?[*:0]const u8) void;
    pub const setIconName = gtk_tool_button_set_icon_name;

    /// Sets `icon` as the widget used as icon on `button`. If `icon_widget` is
    /// `NULL` the icon is determined by the `gtk.ToolButton.properties.stock`-id property. If the
    /// `gtk.ToolButton.properties.stock`-id property is also `NULL`, `button` will not have an icon.
    extern fn gtk_tool_button_set_icon_widget(p_button: *ToolButton, p_icon_widget: ?*gtk.Widget) void;
    pub const setIconWidget = gtk_tool_button_set_icon_widget;

    /// Sets `label` as the label used for the tool button. The `gtk.ToolButton.properties.label`
    /// property only has an effect if not overridden by a non-`NULL`
    /// `gtk.ToolButton.properties.label`-widget property. If both the `gtk.ToolButton.properties.label`-widget
    /// and `gtk.ToolButton.properties.label` properties are `NULL`, the label is determined by the
    /// `gtk.ToolButton.properties.stock`-id property. If the `gtk.ToolButton.properties.stock`-id property is
    /// also `NULL`, `button` will not have a label.
    extern fn gtk_tool_button_set_label(p_button: *ToolButton, p_label: ?[*:0]const u8) void;
    pub const setLabel = gtk_tool_button_set_label;

    /// Sets `label_widget` as the widget that will be used as the label
    /// for `button`. If `label_widget` is `NULL` the `gtk.ToolButton.properties.label` property is used
    /// as label. If `gtk.ToolButton.properties.label` is also `NULL`, the label in the stock item
    /// determined by the `gtk.ToolButton.properties.stock`-id property is used as label. If
    /// `gtk.ToolButton.properties.stock`-id is also `NULL`, `button` does not have a label.
    extern fn gtk_tool_button_set_label_widget(p_button: *ToolButton, p_label_widget: ?*gtk.Widget) void;
    pub const setLabelWidget = gtk_tool_button_set_label_widget;

    /// Sets the name of the stock item. See `gtk.ToolButton.newFromStock`.
    /// The stock_id property only has an effect if not overridden by non-`NULL`
    /// `gtk.ToolButton.properties.label`-widget and `gtk.ToolButton.properties.icon`-widget properties.
    extern fn gtk_tool_button_set_stock_id(p_button: *ToolButton, p_stock_id: ?[*:0]const u8) void;
    pub const setStockId = gtk_tool_button_set_stock_id;

    /// If set, an underline in the label property indicates that the next character
    /// should be used for the mnemonic accelerator key in the overflow menu. For
    /// example, if the label property is “_Open” and `use_underline` is `TRUE`,
    /// the label on the tool button will be “Open” and the item on the overflow
    /// menu will have an underlined “O”.
    ///
    /// Labels shown on tool buttons never have mnemonics on them; this property
    /// only affects the menu item on the overflow menu.
    extern fn gtk_tool_button_set_use_underline(p_button: *ToolButton, p_use_underline: c_int) void;
    pub const setUseUnderline = gtk_tool_button_set_use_underline;

    extern fn gtk_tool_button_get_type() usize;
    pub const getGObjectType = gtk_tool_button_get_type;

    extern fn g_object_ref(p_self: *gtk.ToolButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ToolButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ToolButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GtkToolItems` are widgets that can appear on a toolbar. To
/// create a toolbar item that contain something else than a button, use
/// `gtk.ToolItem.new`. Use `gtk.Container.add` to add a child
/// widget to the tool item.
///
/// For toolbar items that contain buttons, see the `gtk.ToolButton`,
/// `gtk.ToggleToolButton` and `gtk.RadioToolButton` classes.
///
/// See the `gtk.Toolbar` class for a description of the toolbar widget, and
/// `gtk.ToolShell` for a description of the tool shell interface.
pub const ToolItem = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Activatable, gtk.Buildable };
    pub const Class = gtk.ToolItemClass;
    f_parent: gtk.Bin,
    f_priv: ?*gtk.ToolItemPrivate,

    pub const virtual_methods = struct {
        /// Signal emitted when the toolbar needs
        ///    information from tool_item about whether the item should appear in
        ///    the toolbar overflow menu.
        pub const create_menu_proxy = struct {
            pub fn call(p_class: anytype, p_tool_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(ToolItem.Class, p_class).f_create_menu_proxy.?(gobject.ext.as(ToolItem, p_tool_item));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tool_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(ToolItem.Class, p_class).f_create_menu_proxy = @ptrCast(p_implementation);
            }
        };

        /// Emits the signal `gtk.ToolItem.signals.toolbar_reconfigured` on `tool_item`.
        /// `gtk.Toolbar` and other `gtk.ToolShell` implementations use this function
        /// to notify children, when some aspect of their configuration changes.
        pub const toolbar_reconfigured = struct {
            pub fn call(p_class: anytype, p_tool_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ToolItem.Class, p_class).f_toolbar_reconfigured.?(gobject.ext.as(ToolItem, p_tool_item));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tool_item: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ToolItem.Class, p_class).f_toolbar_reconfigured = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const is_important = struct {
            pub const name = "is-important";

            pub const Type = c_int;
        };

        pub const visible_horizontal = struct {
            pub const name = "visible-horizontal";

            pub const Type = c_int;
        };

        pub const visible_vertical = struct {
            pub const name = "visible-vertical";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// This signal is emitted when the toolbar needs information from `tool_item`
        /// about whether the item should appear in the toolbar overflow menu. In
        /// response the tool item should either
        ///
        /// - call `gtk.ToolItem.setProxyMenuItem` with a `NULL`
        ///   pointer and return `TRUE` to indicate that the item should not appear
        ///   in the overflow menu
        ///
        /// - call `gtk.ToolItem.setProxyMenuItem` with a new menu
        ///   item and return `TRUE`, or
        ///
        /// - return `FALSE` to indicate that the signal was not handled by the item.
        ///   This means that the item will not appear in the overflow menu unless
        ///   a later handler installs a menu item.
        ///
        /// The toolbar may cache the result of this signal. When the tool item changes
        /// how it will respond to this signal it must call `gtk.ToolItem.rebuildMenu`
        /// to invalidate the cache and ensure that the toolbar rebuilds its overflow
        /// menu.
        pub const create_menu_proxy = struct {
            pub const name = "create-menu-proxy";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ToolItem, p_instance))),
                    gobject.signalLookup("create-menu-proxy", ToolItem.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when some property of the toolbar that the
        /// item is a child of changes. For custom subclasses of `gtk.ToolItem`,
        /// the default handler of this signal use the functions
        /// - `gtk.ToolShell.getOrientation`
        /// - `gtk.ToolShell.getStyle`
        /// - `gtk.ToolShell.getIconSize`
        /// - `gtk.ToolShell.getReliefStyle`
        /// to find out what the toolbar should look like and change
        /// themselves accordingly.
        pub const toolbar_reconfigured = struct {
            pub const name = "toolbar-reconfigured";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ToolItem, p_instance))),
                    gobject.signalLookup("toolbar-reconfigured", ToolItem.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.ToolItem`
    extern fn gtk_tool_item_new() *gtk.ToolItem;
    pub const new = gtk_tool_item_new;

    /// Returns the ellipsize mode used for `tool_item`. Custom subclasses of
    /// `gtk.ToolItem` should call this function to find out how text should
    /// be ellipsized.
    extern fn gtk_tool_item_get_ellipsize_mode(p_tool_item: *ToolItem) pango.EllipsizeMode;
    pub const getEllipsizeMode = gtk_tool_item_get_ellipsize_mode;

    /// Returns whether `tool_item` is allocated extra space.
    /// See `gtk.ToolItem.setExpand`.
    extern fn gtk_tool_item_get_expand(p_tool_item: *ToolItem) c_int;
    pub const getExpand = gtk_tool_item_get_expand;

    /// Returns whether `tool_item` is the same size as other homogeneous
    /// items. See `gtk.ToolItem.setHomogeneous`.
    extern fn gtk_tool_item_get_homogeneous(p_tool_item: *ToolItem) c_int;
    pub const getHomogeneous = gtk_tool_item_get_homogeneous;

    /// Returns the icon size used for `tool_item`. Custom subclasses of
    /// `gtk.ToolItem` should call this function to find out what size icons
    /// they should use.
    extern fn gtk_tool_item_get_icon_size(p_tool_item: *ToolItem) c_int;
    pub const getIconSize = gtk_tool_item_get_icon_size;

    /// Returns whether `tool_item` is considered important. See
    /// `gtk.ToolItem.setIsImportant`
    extern fn gtk_tool_item_get_is_important(p_tool_item: *ToolItem) c_int;
    pub const getIsImportant = gtk_tool_item_get_is_important;

    /// Returns the orientation used for `tool_item`. Custom subclasses of
    /// `gtk.ToolItem` should call this function to find out what size icons
    /// they should use.
    extern fn gtk_tool_item_get_orientation(p_tool_item: *ToolItem) gtk.Orientation;
    pub const getOrientation = gtk_tool_item_get_orientation;

    /// If `menu_item_id` matches the string passed to
    /// `gtk.ToolItem.setProxyMenuItem` return the corresponding `gtk.MenuItem`.
    ///
    /// Custom subclasses of `gtk.ToolItem` should use this function to
    /// update their menu item when the `gtk.ToolItem` changes. That the
    /// `menu_item_ids` must match ensures that a `gtk.ToolItem`
    /// will not inadvertently change a menu item that they did not create.
    extern fn gtk_tool_item_get_proxy_menu_item(p_tool_item: *ToolItem, p_menu_item_id: [*:0]const u8) ?*gtk.Widget;
    pub const getProxyMenuItem = gtk_tool_item_get_proxy_menu_item;

    /// Returns the relief style of `tool_item`. See `gtk.Button.setRelief`.
    /// Custom subclasses of `gtk.ToolItem` should call this function in the handler
    /// of the `gtk.ToolItem.signals.toolbar_reconfigured` signal to find out the
    /// relief style of buttons.
    extern fn gtk_tool_item_get_relief_style(p_tool_item: *ToolItem) gtk.ReliefStyle;
    pub const getReliefStyle = gtk_tool_item_get_relief_style;

    /// Returns the text alignment used for `tool_item`. Custom subclasses of
    /// `gtk.ToolItem` should call this function to find out how text should
    /// be aligned.
    extern fn gtk_tool_item_get_text_alignment(p_tool_item: *ToolItem) f32;
    pub const getTextAlignment = gtk_tool_item_get_text_alignment;

    /// Returns the text orientation used for `tool_item`. Custom subclasses of
    /// `gtk.ToolItem` should call this function to find out how text should
    /// be orientated.
    extern fn gtk_tool_item_get_text_orientation(p_tool_item: *ToolItem) gtk.Orientation;
    pub const getTextOrientation = gtk_tool_item_get_text_orientation;

    /// Returns the size group used for labels in `tool_item`.
    /// Custom subclasses of `gtk.ToolItem` should call this function
    /// and use the size group for labels.
    extern fn gtk_tool_item_get_text_size_group(p_tool_item: *ToolItem) *gtk.SizeGroup;
    pub const getTextSizeGroup = gtk_tool_item_get_text_size_group;

    /// Returns the toolbar style used for `tool_item`. Custom subclasses of
    /// `gtk.ToolItem` should call this function in the handler of the
    /// GtkToolItem::toolbar_reconfigured signal to find out in what style
    /// the toolbar is displayed and change themselves accordingly
    ///
    /// Possibilities are:
    /// - `GTK_TOOLBAR_BOTH`, meaning the tool item should show
    ///   both an icon and a label, stacked vertically
    /// - `GTK_TOOLBAR_ICONS`, meaning the toolbar shows only icons
    /// - `GTK_TOOLBAR_TEXT`, meaning the tool item should only show text
    /// - `GTK_TOOLBAR_BOTH_HORIZ`, meaning the tool item should show
    ///   both an icon and a label, arranged horizontally
    extern fn gtk_tool_item_get_toolbar_style(p_tool_item: *ToolItem) gtk.ToolbarStyle;
    pub const getToolbarStyle = gtk_tool_item_get_toolbar_style;

    /// Returns whether `tool_item` has a drag window. See
    /// `gtk.ToolItem.setUseDragWindow`.
    extern fn gtk_tool_item_get_use_drag_window(p_tool_item: *ToolItem) c_int;
    pub const getUseDragWindow = gtk_tool_item_get_use_drag_window;

    /// Returns whether the `tool_item` is visible on toolbars that are
    /// docked horizontally.
    extern fn gtk_tool_item_get_visible_horizontal(p_tool_item: *ToolItem) c_int;
    pub const getVisibleHorizontal = gtk_tool_item_get_visible_horizontal;

    /// Returns whether `tool_item` is visible when the toolbar is docked vertically.
    /// See `gtk.ToolItem.setVisibleVertical`.
    extern fn gtk_tool_item_get_visible_vertical(p_tool_item: *ToolItem) c_int;
    pub const getVisibleVertical = gtk_tool_item_get_visible_vertical;

    /// Calling this function signals to the toolbar that the
    /// overflow menu item for `tool_item` has changed. If the
    /// overflow menu is visible when this function it called,
    /// the menu will be rebuilt.
    ///
    /// The function must be called when the tool item changes what it
    /// will do in response to the `gtk.ToolItem.signals.create`-menu-proxy signal.
    extern fn gtk_tool_item_rebuild_menu(p_tool_item: *ToolItem) void;
    pub const rebuildMenu = gtk_tool_item_rebuild_menu;

    /// Returns the `gtk.MenuItem` that was last set by
    /// `gtk.ToolItem.setProxyMenuItem`, ie. the `gtk.MenuItem`
    /// that is going to appear in the overflow menu.
    extern fn gtk_tool_item_retrieve_proxy_menu_item(p_tool_item: *ToolItem) *gtk.Widget;
    pub const retrieveProxyMenuItem = gtk_tool_item_retrieve_proxy_menu_item;

    /// Sets whether `tool_item` is allocated extra space when there
    /// is more room on the toolbar then needed for the items. The
    /// effect is that the item gets bigger when the toolbar gets bigger
    /// and smaller when the toolbar gets smaller.
    extern fn gtk_tool_item_set_expand(p_tool_item: *ToolItem, p_expand: c_int) void;
    pub const setExpand = gtk_tool_item_set_expand;

    /// Sets whether `tool_item` is to be allocated the same size as other
    /// homogeneous items. The effect is that all homogeneous items will have
    /// the same width as the widest of the items.
    extern fn gtk_tool_item_set_homogeneous(p_tool_item: *ToolItem, p_homogeneous: c_int) void;
    pub const setHomogeneous = gtk_tool_item_set_homogeneous;

    /// Sets whether `tool_item` should be considered important. The `gtk.ToolButton`
    /// class uses this property to determine whether to show or hide its label
    /// when the toolbar style is `GTK_TOOLBAR_BOTH_HORIZ`. The result is that
    /// only tool buttons with the “is_important” property set have labels, an
    /// effect known as “priority text”
    extern fn gtk_tool_item_set_is_important(p_tool_item: *ToolItem, p_is_important: c_int) void;
    pub const setIsImportant = gtk_tool_item_set_is_important;

    /// Sets the `gtk.MenuItem` used in the toolbar overflow menu. The
    /// `menu_item_id` is used to identify the caller of this function and
    /// should also be used with `gtk.ToolItem.getProxyMenuItem`.
    ///
    /// See also `gtk.ToolItem.signals.create`-menu-proxy.
    extern fn gtk_tool_item_set_proxy_menu_item(p_tool_item: *ToolItem, p_menu_item_id: [*:0]const u8, p_menu_item: ?*gtk.Widget) void;
    pub const setProxyMenuItem = gtk_tool_item_set_proxy_menu_item;

    /// Sets the markup text to be displayed as tooltip on the item.
    /// See `gtk.Widget.setTooltipMarkup`.
    extern fn gtk_tool_item_set_tooltip_markup(p_tool_item: *ToolItem, p_markup: [*:0]const u8) void;
    pub const setTooltipMarkup = gtk_tool_item_set_tooltip_markup;

    /// Sets the text to be displayed as tooltip on the item.
    /// See `gtk.Widget.setTooltipText`.
    extern fn gtk_tool_item_set_tooltip_text(p_tool_item: *ToolItem, p_text: [*:0]const u8) void;
    pub const setTooltipText = gtk_tool_item_set_tooltip_text;

    /// Sets whether `tool_item` has a drag window. When `TRUE` the
    /// toolitem can be used as a drag source through `gtk.Widget.dragSourceSet`.
    /// When `tool_item` has a drag window it will intercept all events,
    /// even those that would otherwise be sent to a child of `tool_item`.
    extern fn gtk_tool_item_set_use_drag_window(p_tool_item: *ToolItem, p_use_drag_window: c_int) void;
    pub const setUseDragWindow = gtk_tool_item_set_use_drag_window;

    /// Sets whether `tool_item` is visible when the toolbar is docked horizontally.
    extern fn gtk_tool_item_set_visible_horizontal(p_tool_item: *ToolItem, p_visible_horizontal: c_int) void;
    pub const setVisibleHorizontal = gtk_tool_item_set_visible_horizontal;

    /// Sets whether `tool_item` is visible when the toolbar is docked
    /// vertically. Some tool items, such as text entries, are too wide to be
    /// useful on a vertically docked toolbar. If `visible_vertical` is `FALSE`
    /// `tool_item` will not appear on toolbars that are docked vertically.
    extern fn gtk_tool_item_set_visible_vertical(p_tool_item: *ToolItem, p_visible_vertical: c_int) void;
    pub const setVisibleVertical = gtk_tool_item_set_visible_vertical;

    /// Emits the signal `gtk.ToolItem.signals.toolbar_reconfigured` on `tool_item`.
    /// `gtk.Toolbar` and other `gtk.ToolShell` implementations use this function
    /// to notify children, when some aspect of their configuration changes.
    extern fn gtk_tool_item_toolbar_reconfigured(p_tool_item: *ToolItem) void;
    pub const toolbarReconfigured = gtk_tool_item_toolbar_reconfigured;

    extern fn gtk_tool_item_get_type() usize;
    pub const getGObjectType = gtk_tool_item_get_type;

    extern fn g_object_ref(p_self: *gtk.ToolItem) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ToolItem) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ToolItem, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.ToolItemGroup` is used together with `gtk.ToolPalette` to add
/// `GtkToolItems` to a palette like container with different
/// categories and drag and drop support.
///
/// # CSS nodes
///
/// GtkToolItemGroup has a single CSS node named toolitemgroup.
pub const ToolItemGroup = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.ToolShell };
    pub const Class = gtk.ToolItemGroupClass;
    f_parent_instance: gtk.Container,
    f_priv: ?*gtk.ToolItemGroupPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const collapsed = struct {
            pub const name = "collapsed";

            pub const Type = c_int;
        };

        pub const ellipsize = struct {
            pub const name = "ellipsize";

            pub const Type = pango.EllipsizeMode;
        };

        pub const header_relief = struct {
            pub const name = "header-relief";

            pub const Type = gtk.ReliefStyle;
        };

        pub const label = struct {
            pub const name = "label";

            pub const Type = ?[*:0]u8;
        };

        pub const label_widget = struct {
            pub const name = "label-widget";

            pub const Type = ?*gtk.Widget;
        };
    };

    pub const signals = struct {};

    /// Creates a new tool item group with label `label`.
    extern fn gtk_tool_item_group_new(p_label: [*:0]const u8) *gtk.ToolItemGroup;
    pub const new = gtk_tool_item_group_new;

    /// Gets whether `group` is collapsed or expanded.
    extern fn gtk_tool_item_group_get_collapsed(p_group: *ToolItemGroup) c_int;
    pub const getCollapsed = gtk_tool_item_group_get_collapsed;

    /// Gets the tool item at position (x, y).
    extern fn gtk_tool_item_group_get_drop_item(p_group: *ToolItemGroup, p_x: c_int, p_y: c_int) *gtk.ToolItem;
    pub const getDropItem = gtk_tool_item_group_get_drop_item;

    /// Gets the ellipsization mode of `group`.
    extern fn gtk_tool_item_group_get_ellipsize(p_group: *ToolItemGroup) pango.EllipsizeMode;
    pub const getEllipsize = gtk_tool_item_group_get_ellipsize;

    /// Gets the relief mode of the header button of `group`.
    extern fn gtk_tool_item_group_get_header_relief(p_group: *ToolItemGroup) gtk.ReliefStyle;
    pub const getHeaderRelief = gtk_tool_item_group_get_header_relief;

    /// Gets the position of `item` in `group` as index.
    extern fn gtk_tool_item_group_get_item_position(p_group: *ToolItemGroup, p_item: *gtk.ToolItem) c_int;
    pub const getItemPosition = gtk_tool_item_group_get_item_position;

    /// Gets the label of `group`.
    extern fn gtk_tool_item_group_get_label(p_group: *ToolItemGroup) [*:0]const u8;
    pub const getLabel = gtk_tool_item_group_get_label;

    /// Gets the label widget of `group`.
    /// See `gtk.ToolItemGroup.setLabelWidget`.
    extern fn gtk_tool_item_group_get_label_widget(p_group: *ToolItemGroup) *gtk.Widget;
    pub const getLabelWidget = gtk_tool_item_group_get_label_widget;

    /// Gets the number of tool items in `group`.
    extern fn gtk_tool_item_group_get_n_items(p_group: *ToolItemGroup) c_uint;
    pub const getNItems = gtk_tool_item_group_get_n_items;

    /// Gets the tool item at `index` in group.
    extern fn gtk_tool_item_group_get_nth_item(p_group: *ToolItemGroup, p_index: c_uint) *gtk.ToolItem;
    pub const getNthItem = gtk_tool_item_group_get_nth_item;

    /// Inserts `item` at `position` in the list of children of `group`.
    extern fn gtk_tool_item_group_insert(p_group: *ToolItemGroup, p_item: *gtk.ToolItem, p_position: c_int) void;
    pub const insert = gtk_tool_item_group_insert;

    /// Sets whether the `group` should be collapsed or expanded.
    extern fn gtk_tool_item_group_set_collapsed(p_group: *ToolItemGroup, p_collapsed: c_int) void;
    pub const setCollapsed = gtk_tool_item_group_set_collapsed;

    /// Sets the ellipsization mode which should be used by labels in `group`.
    extern fn gtk_tool_item_group_set_ellipsize(p_group: *ToolItemGroup, p_ellipsize: pango.EllipsizeMode) void;
    pub const setEllipsize = gtk_tool_item_group_set_ellipsize;

    /// Set the button relief of the group header.
    /// See `gtk.Button.setRelief` for details.
    extern fn gtk_tool_item_group_set_header_relief(p_group: *ToolItemGroup, p_style: gtk.ReliefStyle) void;
    pub const setHeaderRelief = gtk_tool_item_group_set_header_relief;

    /// Sets the position of `item` in the list of children of `group`.
    extern fn gtk_tool_item_group_set_item_position(p_group: *ToolItemGroup, p_item: *gtk.ToolItem, p_position: c_int) void;
    pub const setItemPosition = gtk_tool_item_group_set_item_position;

    /// Sets the label of the tool item group. The label is displayed in the header
    /// of the group.
    extern fn gtk_tool_item_group_set_label(p_group: *ToolItemGroup, p_label: [*:0]const u8) void;
    pub const setLabel = gtk_tool_item_group_set_label;

    /// Sets the label of the tool item group.
    /// The label widget is displayed in the header of the group, in place
    /// of the usual label.
    extern fn gtk_tool_item_group_set_label_widget(p_group: *ToolItemGroup, p_label_widget: *gtk.Widget) void;
    pub const setLabelWidget = gtk_tool_item_group_set_label_widget;

    extern fn gtk_tool_item_group_get_type() usize;
    pub const getGObjectType = gtk_tool_item_group_get_type;

    extern fn g_object_ref(p_self: *gtk.ToolItemGroup) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ToolItemGroup) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ToolItemGroup, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.ToolPalette` allows you to add `GtkToolItems` to a palette-like
/// container with different categories and drag and drop support.
///
/// A `gtk.ToolPalette` is created with a call to `gtk.ToolPalette.new`.
///
/// `GtkToolItems` cannot be added directly to a `gtk.ToolPalette` -
/// instead they are added to a `gtk.ToolItemGroup` which can than be added
/// to a `gtk.ToolPalette`. To add a `gtk.ToolItemGroup` to a `gtk.ToolPalette`,
/// use `gtk.Container.add`.
///
/// ```
/// GtkWidget *palette, *group;
/// GtkToolItem *item;
///
/// palette = gtk_tool_palette_new ();
/// group = gtk_tool_item_group_new (_("Test Category"));
/// gtk_container_add (GTK_CONTAINER (palette), group);
///
/// item = gtk_tool_button_new (NULL, _("_Open"));
/// gtk_tool_button_set_icon_name (GTK_TOOL_BUTTON (item), "document-open");
/// gtk_tool_item_group_insert (GTK_TOOL_ITEM_GROUP (group), item, -1);
/// ```
///
/// The easiest way to use drag and drop with `gtk.ToolPalette` is to call
/// `gtk.ToolPalette.addDragDest` with the desired drag source `palette`
/// and the desired drag target `widget`. Then `gtk.ToolPalette.getDragItem`
/// can be used to get the dragged item in the `gtk.Widget.signals.drag`-data-received
/// signal handler of the drag target.
///
/// ```
/// static void
/// passive_canvas_drag_data_received (GtkWidget        *widget,
///                                    GdkDragContext   *context,
///                                    gint              x,
///                                    gint              y,
///                                    GtkSelectionData *selection,
///                                    guint             info,
///                                    guint             time,
///                                    gpointer          data)
/// {
///   GtkWidget *palette;
///   GtkWidget *item;
///
///   // Get the dragged item
///   palette = gtk_widget_get_ancestor (gtk_drag_get_source_widget (context),
///                                      GTK_TYPE_TOOL_PALETTE);
///   if (palette != NULL)
///     item = gtk_tool_palette_get_drag_item (GTK_TOOL_PALETTE (palette),
///                                            selection);
///
///   // Do something with item
/// }
///
/// GtkWidget *target, palette;
///
/// palette = gtk_tool_palette_new ();
/// target = gtk_drawing_area_new ();
///
/// g_signal_connect (G_OBJECT (target), "drag-data-received",
///                   G_CALLBACK (passive_canvas_drag_data_received), NULL);
/// gtk_tool_palette_add_drag_dest (GTK_TOOL_PALETTE (palette), target,
///                                 GTK_DEST_DEFAULT_ALL,
///                                 GTK_TOOL_PALETTE_DRAG_ITEMS,
///                                 GDK_ACTION_COPY);
/// ```
///
/// # CSS nodes
///
/// GtkToolPalette has a single CSS node named toolpalette.
pub const ToolPalette = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable, gtk.Scrollable };
    pub const Class = gtk.ToolPaletteClass;
    f_parent_instance: gtk.Container,
    f_priv: ?*gtk.ToolPalettePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The size of the icons in a tool palette. When this property is set,
        /// it overrides the default setting.
        ///
        /// This should only be used for special-purpose tool palettes, normal
        /// application tool palettes should respect the user preferences for the
        /// size of icons.
        pub const icon_size = struct {
            pub const name = "icon-size";

            pub const Type = gtk.IconSize;
        };

        /// Is `TRUE` if the `gtk.ToolPalette.properties.icon`-size property has been set.
        pub const icon_size_set = struct {
            pub const name = "icon-size-set";

            pub const Type = c_int;
        };

        /// The style of items in the tool palette.
        pub const toolbar_style = struct {
            pub const name = "toolbar-style";

            pub const Type = gtk.ToolbarStyle;
        };
    };

    pub const signals = struct {};

    /// Get the target entry for a dragged `gtk.ToolItemGroup`.
    extern fn gtk_tool_palette_get_drag_target_group() *const gtk.TargetEntry;
    pub const getDragTargetGroup = gtk_tool_palette_get_drag_target_group;

    /// Gets the target entry for a dragged `gtk.ToolItem`.
    extern fn gtk_tool_palette_get_drag_target_item() *const gtk.TargetEntry;
    pub const getDragTargetItem = gtk_tool_palette_get_drag_target_item;

    /// Creates a new tool palette.
    extern fn gtk_tool_palette_new() *gtk.ToolPalette;
    pub const new = gtk_tool_palette_new;

    /// Sets `palette` as drag source (see `gtk.ToolPalette.setDragSource`)
    /// and sets `widget` as a drag destination for drags from `palette`.
    /// See `gtk.Widget.dragDestSet`.
    extern fn gtk_tool_palette_add_drag_dest(p_palette: *ToolPalette, p_widget: *gtk.Widget, p_flags: gtk.DestDefaults, p_targets: gtk.ToolPaletteDragTargets, p_actions: gdk.DragAction) void;
    pub const addDragDest = gtk_tool_palette_add_drag_dest;

    /// Get the dragged item from the selection.
    /// This could be a `gtk.ToolItem` or a `gtk.ToolItemGroup`.
    extern fn gtk_tool_palette_get_drag_item(p_palette: *ToolPalette, p_selection: *const gtk.SelectionData) *gtk.Widget;
    pub const getDragItem = gtk_tool_palette_get_drag_item;

    /// Gets the group at position (x, y).
    extern fn gtk_tool_palette_get_drop_group(p_palette: *ToolPalette, p_x: c_int, p_y: c_int) ?*gtk.ToolItemGroup;
    pub const getDropGroup = gtk_tool_palette_get_drop_group;

    /// Gets the item at position (x, y).
    /// See `gtk.ToolPalette.getDropGroup`.
    extern fn gtk_tool_palette_get_drop_item(p_palette: *ToolPalette, p_x: c_int, p_y: c_int) ?*gtk.ToolItem;
    pub const getDropItem = gtk_tool_palette_get_drop_item;

    /// Gets whether `group` is exclusive or not.
    /// See `gtk.ToolPalette.setExclusive`.
    extern fn gtk_tool_palette_get_exclusive(p_palette: *ToolPalette, p_group: *gtk.ToolItemGroup) c_int;
    pub const getExclusive = gtk_tool_palette_get_exclusive;

    /// Gets whether group should be given extra space.
    /// See `gtk.ToolPalette.setExpand`.
    extern fn gtk_tool_palette_get_expand(p_palette: *ToolPalette, p_group: *gtk.ToolItemGroup) c_int;
    pub const getExpand = gtk_tool_palette_get_expand;

    /// Gets the position of `group` in `palette` as index.
    /// See `gtk.ToolPalette.setGroupPosition`.
    extern fn gtk_tool_palette_get_group_position(p_palette: *ToolPalette, p_group: *gtk.ToolItemGroup) c_int;
    pub const getGroupPosition = gtk_tool_palette_get_group_position;

    /// Gets the horizontal adjustment of the tool palette.
    extern fn gtk_tool_palette_get_hadjustment(p_palette: *ToolPalette) *gtk.Adjustment;
    pub const getHadjustment = gtk_tool_palette_get_hadjustment;

    /// Gets the size of icons in the tool palette.
    /// See `gtk.ToolPalette.setIconSize`.
    extern fn gtk_tool_palette_get_icon_size(p_palette: *ToolPalette) c_int;
    pub const getIconSize = gtk_tool_palette_get_icon_size;

    /// Gets the style (icons, text or both) of items in the tool palette.
    extern fn gtk_tool_palette_get_style(p_palette: *ToolPalette) gtk.ToolbarStyle;
    pub const getStyle = gtk_tool_palette_get_style;

    /// Gets the vertical adjustment of the tool palette.
    extern fn gtk_tool_palette_get_vadjustment(p_palette: *ToolPalette) *gtk.Adjustment;
    pub const getVadjustment = gtk_tool_palette_get_vadjustment;

    /// Sets the tool palette as a drag source.
    /// Enables all groups and items in the tool palette as drag sources
    /// on button 1 and button 3 press with copy and move actions.
    /// See `gtk.Widget.dragSourceSet`.
    extern fn gtk_tool_palette_set_drag_source(p_palette: *ToolPalette, p_targets: gtk.ToolPaletteDragTargets) void;
    pub const setDragSource = gtk_tool_palette_set_drag_source;

    /// Sets whether the group should be exclusive or not.
    /// If an exclusive group is expanded all other groups are collapsed.
    extern fn gtk_tool_palette_set_exclusive(p_palette: *ToolPalette, p_group: *gtk.ToolItemGroup, p_exclusive: c_int) void;
    pub const setExclusive = gtk_tool_palette_set_exclusive;

    /// Sets whether the group should be given extra space.
    extern fn gtk_tool_palette_set_expand(p_palette: *ToolPalette, p_group: *gtk.ToolItemGroup, p_expand: c_int) void;
    pub const setExpand = gtk_tool_palette_set_expand;

    /// Sets the position of the group as an index of the tool palette.
    /// If position is 0 the group will become the first child, if position is
    /// -1 it will become the last child.
    extern fn gtk_tool_palette_set_group_position(p_palette: *ToolPalette, p_group: *gtk.ToolItemGroup, p_position: c_int) void;
    pub const setGroupPosition = gtk_tool_palette_set_group_position;

    /// Sets the size of icons in the tool palette.
    extern fn gtk_tool_palette_set_icon_size(p_palette: *ToolPalette, p_icon_size: c_int) void;
    pub const setIconSize = gtk_tool_palette_set_icon_size;

    /// Sets the style (text, icons or both) of items in the tool palette.
    extern fn gtk_tool_palette_set_style(p_palette: *ToolPalette, p_style: gtk.ToolbarStyle) void;
    pub const setStyle = gtk_tool_palette_set_style;

    /// Unsets the tool palette icon size set with `gtk.ToolPalette.setIconSize`,
    /// so that user preferences will be used to determine the icon size.
    extern fn gtk_tool_palette_unset_icon_size(p_palette: *ToolPalette) void;
    pub const unsetIconSize = gtk_tool_palette_unset_icon_size;

    /// Unsets a toolbar style set with `gtk.ToolPalette.setStyle`,
    /// so that user preferences will be used to determine the toolbar style.
    extern fn gtk_tool_palette_unset_style(p_palette: *ToolPalette) void;
    pub const unsetStyle = gtk_tool_palette_unset_style;

    extern fn gtk_tool_palette_get_type() usize;
    pub const getGObjectType = gtk_tool_palette_get_type;

    extern fn g_object_ref(p_self: *gtk.ToolPalette) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ToolPalette) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ToolPalette, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A toolbar is created with a call to `gtk.Toolbar.new`.
///
/// A toolbar can contain instances of a subclass of `gtk.ToolItem`. To add
/// a `gtk.ToolItem` to the a toolbar, use `gtk.Toolbar.insert`. To remove
/// an item from the toolbar use `gtk.Container.remove`. To add a button
/// to the toolbar, add an instance of `gtk.ToolButton`.
///
/// Toolbar items can be visually grouped by adding instances of
/// `gtk.SeparatorToolItem` to the toolbar. If the GtkToolbar child property
/// “expand” is `TRUE` and the property `gtk.SeparatorToolItem.properties.draw` is set to
/// `FALSE`, the effect is to force all following items to the end of the toolbar.
///
/// By default, a toolbar can be shrunk, upon which it will add an arrow button
/// to show an overflow menu offering access to any `gtk.ToolItem` child that has
/// a proxy menu item. To disable this and request enough size for all children,
/// call `gtk.Toolbar.setShowArrow` to set `gtk.Toolbar.properties.show`-arrow to `FALSE`.
///
/// Creating a context menu for the toolbar can be done by connecting to
/// the `gtk.Toolbar.signals.popup`-context-menu signal.
///
/// # CSS nodes
///
/// GtkToolbar has a single CSS node with name toolbar.
pub const Toolbar = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable, gtk.ToolShell };
    pub const Class = gtk.ToolbarClass;
    f_container: gtk.Container,
    f_priv: ?*gtk.ToolbarPrivate,

    pub const virtual_methods = struct {
        pub const orientation_changed = struct {
            pub fn call(p_class: anytype, p_toolbar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_orientation: gtk.Orientation) void {
                return gobject.ext.as(Toolbar.Class, p_class).f_orientation_changed.?(gobject.ext.as(Toolbar, p_toolbar), p_orientation);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_toolbar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_orientation: gtk.Orientation) callconv(.c) void) void {
                gobject.ext.as(Toolbar.Class, p_class).f_orientation_changed = @ptrCast(p_implementation);
            }
        };

        pub const popup_context_menu = struct {
            pub fn call(p_class: anytype, p_toolbar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_x: c_int, p_y: c_int, p_button_number: c_int) c_int {
                return gobject.ext.as(Toolbar.Class, p_class).f_popup_context_menu.?(gobject.ext.as(Toolbar, p_toolbar), p_x, p_y, p_button_number);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_toolbar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_x: c_int, p_y: c_int, p_button_number: c_int) callconv(.c) c_int) void {
                gobject.ext.as(Toolbar.Class, p_class).f_popup_context_menu = @ptrCast(p_implementation);
            }
        };

        pub const style_changed = struct {
            pub fn call(p_class: anytype, p_toolbar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_style: gtk.ToolbarStyle) void {
                return gobject.ext.as(Toolbar.Class, p_class).f_style_changed.?(gobject.ext.as(Toolbar, p_toolbar), p_style);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_toolbar: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_style: gtk.ToolbarStyle) callconv(.c) void) void {
                gobject.ext.as(Toolbar.Class, p_class).f_style_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The size of the icons in a toolbar is normally determined by
        /// the toolbar-icon-size setting. When this property is set, it
        /// overrides the setting.
        ///
        /// This should only be used for special-purpose toolbars, normal
        /// application toolbars should respect the user preferences for the
        /// size of icons.
        pub const icon_size = struct {
            pub const name = "icon-size";

            pub const Type = gtk.IconSize;
        };

        /// Is `TRUE` if the icon-size property has been set.
        pub const icon_size_set = struct {
            pub const name = "icon-size-set";

            pub const Type = c_int;
        };

        pub const show_arrow = struct {
            pub const name = "show-arrow";

            pub const Type = c_int;
        };

        pub const toolbar_style = struct {
            pub const name = "toolbar-style";

            pub const Type = gtk.ToolbarStyle;
        };
    };

    pub const signals = struct {
        /// A keybinding signal used internally by GTK+. This signal can't
        /// be used in application code
        pub const focus_home_or_end = struct {
            pub const name = "focus-home-or-end";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_focus_home: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Toolbar, p_instance))),
                    gobject.signalLookup("focus-home-or-end", Toolbar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the orientation of the toolbar changes.
        pub const orientation_changed = struct {
            pub const name = "orientation-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_orientation: gtk.Orientation, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Toolbar, p_instance))),
                    gobject.signalLookup("orientation-changed", Toolbar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the user right-clicks the toolbar or uses the
        /// keybinding to display a popup menu.
        ///
        /// Application developers should handle this signal if they want
        /// to display a context menu on the toolbar. The context-menu should
        /// appear at the coordinates given by `x` and `y`. The mouse button
        /// number is given by the `button` parameter. If the menu was popped
        /// up using the keybaord, `button` is -1.
        pub const popup_context_menu = struct {
            pub const name = "popup-context-menu";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_x: c_int, p_y: c_int, p_button: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Toolbar, p_instance))),
                    gobject.signalLookup("popup-context-menu", Toolbar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the style of the toolbar changes.
        pub const style_changed = struct {
            pub const name = "style-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_style: gtk.ToolbarStyle, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Toolbar, p_instance))),
                    gobject.signalLookup("style-changed", Toolbar.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new toolbar.
    extern fn gtk_toolbar_new() *gtk.Toolbar;
    pub const new = gtk_toolbar_new;

    /// Returns the position corresponding to the indicated point on
    /// `toolbar`. This is useful when dragging items to the toolbar:
    /// this function returns the position a new item should be
    /// inserted.
    ///
    /// `x` and `y` are in `toolbar` coordinates.
    extern fn gtk_toolbar_get_drop_index(p_toolbar: *Toolbar, p_x: c_int, p_y: c_int) c_int;
    pub const getDropIndex = gtk_toolbar_get_drop_index;

    /// Retrieves the icon size for the toolbar. See `gtk.Toolbar.setIconSize`.
    extern fn gtk_toolbar_get_icon_size(p_toolbar: *Toolbar) gtk.IconSize;
    pub const getIconSize = gtk_toolbar_get_icon_size;

    /// Returns the position of `item` on the toolbar, starting from 0.
    /// It is an error if `item` is not a child of the toolbar.
    extern fn gtk_toolbar_get_item_index(p_toolbar: *Toolbar, p_item: *gtk.ToolItem) c_int;
    pub const getItemIndex = gtk_toolbar_get_item_index;

    /// Returns the number of items on the toolbar.
    extern fn gtk_toolbar_get_n_items(p_toolbar: *Toolbar) c_int;
    pub const getNItems = gtk_toolbar_get_n_items;

    /// Returns the `n`'th item on `toolbar`, or `NULL` if the
    /// toolbar does not contain an `n`'th item.
    extern fn gtk_toolbar_get_nth_item(p_toolbar: *Toolbar, p_n: c_int) ?*gtk.ToolItem;
    pub const getNthItem = gtk_toolbar_get_nth_item;

    /// Returns the relief style of buttons on `toolbar`. See
    /// `gtk.Button.setRelief`.
    extern fn gtk_toolbar_get_relief_style(p_toolbar: *Toolbar) gtk.ReliefStyle;
    pub const getReliefStyle = gtk_toolbar_get_relief_style;

    /// Returns whether the toolbar has an overflow menu.
    /// See `gtk.Toolbar.setShowArrow`.
    extern fn gtk_toolbar_get_show_arrow(p_toolbar: *Toolbar) c_int;
    pub const getShowArrow = gtk_toolbar_get_show_arrow;

    /// Retrieves whether the toolbar has text, icons, or both . See
    /// `gtk.Toolbar.setStyle`.
    extern fn gtk_toolbar_get_style(p_toolbar: *Toolbar) gtk.ToolbarStyle;
    pub const getStyle = gtk_toolbar_get_style;

    /// Insert a `gtk.ToolItem` into the toolbar at position `pos`. If `pos` is
    /// 0 the item is prepended to the start of the toolbar. If `pos` is
    /// negative, the item is appended to the end of the toolbar.
    extern fn gtk_toolbar_insert(p_toolbar: *Toolbar, p_item: *gtk.ToolItem, p_pos: c_int) void;
    pub const insert = gtk_toolbar_insert;

    /// Highlights `toolbar` to give an idea of what it would look like
    /// if `item` was added to `toolbar` at the position indicated by `index_`.
    /// If `item` is `NULL`, highlighting is turned off. In that case `index_`
    /// is ignored.
    ///
    /// The `tool_item` passed to this function must not be part of any widget
    /// hierarchy. When an item is set as drop highlight item it can not
    /// added to any widget hierarchy or used as highlight item for another
    /// toolbar.
    extern fn gtk_toolbar_set_drop_highlight_item(p_toolbar: *Toolbar, p_tool_item: ?*gtk.ToolItem, p_index_: c_int) void;
    pub const setDropHighlightItem = gtk_toolbar_set_drop_highlight_item;

    /// This function sets the size of stock icons in the toolbar. You
    /// can call it both before you add the icons and after they’ve been
    /// added. The size you set will override user preferences for the default
    /// icon size.
    ///
    /// This should only be used for special-purpose toolbars, normal
    /// application toolbars should respect the user preferences for the
    /// size of icons.
    extern fn gtk_toolbar_set_icon_size(p_toolbar: *Toolbar, p_icon_size: gtk.IconSize) void;
    pub const setIconSize = gtk_toolbar_set_icon_size;

    /// Sets whether to show an overflow menu when `toolbar` isn’t allocated enough
    /// size to show all of its items. If `TRUE`, items which can’t fit in `toolbar`,
    /// and which have a proxy menu item set by `gtk.ToolItem.setProxyMenuItem`
    /// or `gtk.ToolItem.signals.create`-menu-proxy, will be available in an overflow menu,
    /// which can be opened by an added arrow button. If `FALSE`, `toolbar` will
    /// request enough size to fit all of its child items without any overflow.
    extern fn gtk_toolbar_set_show_arrow(p_toolbar: *Toolbar, p_show_arrow: c_int) void;
    pub const setShowArrow = gtk_toolbar_set_show_arrow;

    /// Alters the view of `toolbar` to display either icons only, text only, or both.
    extern fn gtk_toolbar_set_style(p_toolbar: *Toolbar, p_style: gtk.ToolbarStyle) void;
    pub const setStyle = gtk_toolbar_set_style;

    /// Unsets toolbar icon size set with `gtk.Toolbar.setIconSize`, so that
    /// user preferences will be used to determine the icon size.
    extern fn gtk_toolbar_unset_icon_size(p_toolbar: *Toolbar) void;
    pub const unsetIconSize = gtk_toolbar_unset_icon_size;

    /// Unsets a toolbar style set with `gtk.Toolbar.setStyle`, so that
    /// user preferences will be used to determine the toolbar style.
    extern fn gtk_toolbar_unset_style(p_toolbar: *Toolbar) void;
    pub const unsetStyle = gtk_toolbar_unset_style;

    extern fn gtk_toolbar_get_type() usize;
    pub const getGObjectType = gtk_toolbar_get_type;

    extern fn g_object_ref(p_self: *gtk.Toolbar) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Toolbar) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Toolbar, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Basic tooltips can be realized simply by using `gtk.Widget.setTooltipText`
/// or `gtk.Widget.setTooltipMarkup` without any explicit tooltip object.
///
/// When you need a tooltip with a little more fancy contents, like adding an
/// image, or you want the tooltip to have different contents per `gtk.TreeView`
/// row or cell, you will have to do a little more work:
///
/// - Set the `gtk.Widget.properties.has`-tooltip property to `TRUE`, this will make GTK+
///   monitor the widget for motion and related events which are needed to
///   determine when and where to show a tooltip.
///
/// - Connect to the `gtk.Widget.signals.query`-tooltip signal.  This signal will be
///   emitted when a tooltip is supposed to be shown. One of the arguments passed
///   to the signal handler is a GtkTooltip object. This is the object that we
///   are about to display as a tooltip, and can be manipulated in your callback
///   using functions like `gtk.Tooltip.setIcon`. There are functions for setting
///   the tooltip’s markup, setting an image from a named icon, or even putting in
///   a custom widget.
///
///   Return `TRUE` from your query-tooltip handler. This causes the tooltip to be
///   show. If you return `FALSE`, it will not be shown.
///
/// In the probably rare case where you want to have even more control over the
/// tooltip that is about to be shown, you can set your own `gtk.Window` which
/// will be used as tooltip window.  This works as follows:
///
/// - Set `gtk.Widget.properties.has`-tooltip and connect to `gtk.Widget.signals.query`-tooltip as before.
///   Use `gtk.Widget.setTooltipWindow` to set a `gtk.Window` created by you as
///   tooltip window.
///
/// - In the `gtk.Widget.signals.query`-tooltip callback you can access your window using
///   `gtk.Widget.getTooltipWindow` and manipulate as you wish. The semantics of
///   the return value are exactly as before, return `TRUE` to show the window,
///   `FALSE` to not show it.
pub const Tooltip = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = Tooltip;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Triggers a new tooltip query on `display`, in order to update the current
    /// visible tooltip, or to show/hide the current tooltip.  This function is
    /// useful to call when, for example, the state of the widget changed by a
    /// key press.
    extern fn gtk_tooltip_trigger_tooltip_query(p_display: *gdk.Display) void;
    pub const triggerTooltipQuery = gtk_tooltip_trigger_tooltip_query;

    /// Replaces the widget packed into the tooltip with
    /// `custom_widget`. `custom_widget` does not get destroyed when the tooltip goes
    /// away.
    /// By default a box with a `gtk.Image` and `gtk.Label` is embedded in
    /// the tooltip, which can be configured using `gtk.Tooltip.setMarkup`
    /// and `gtk.Tooltip.setIcon`.
    extern fn gtk_tooltip_set_custom(p_tooltip: *Tooltip, p_custom_widget: ?*gtk.Widget) void;
    pub const setCustom = gtk_tooltip_set_custom;

    /// Sets the icon of the tooltip (which is in front of the text) to be
    /// `pixbuf`.  If `pixbuf` is `NULL`, the image will be hidden.
    extern fn gtk_tooltip_set_icon(p_tooltip: *Tooltip, p_pixbuf: ?*gdkpixbuf.Pixbuf) void;
    pub const setIcon = gtk_tooltip_set_icon;

    /// Sets the icon of the tooltip (which is in front of the text)
    /// to be the icon indicated by `gicon` with the size indicated
    /// by `size`. If `gicon` is `NULL`, the image will be hidden.
    extern fn gtk_tooltip_set_icon_from_gicon(p_tooltip: *Tooltip, p_gicon: ?*gio.Icon, p_size: c_int) void;
    pub const setIconFromGicon = gtk_tooltip_set_icon_from_gicon;

    /// Sets the icon of the tooltip (which is in front of the text) to be
    /// the icon indicated by `icon_name` with the size indicated
    /// by `size`.  If `icon_name` is `NULL`, the image will be hidden.
    extern fn gtk_tooltip_set_icon_from_icon_name(p_tooltip: *Tooltip, p_icon_name: ?[*:0]const u8, p_size: c_int) void;
    pub const setIconFromIconName = gtk_tooltip_set_icon_from_icon_name;

    /// Sets the icon of the tooltip (which is in front of the text) to be
    /// the stock item indicated by `stock_id` with the size indicated
    /// by `size`.  If `stock_id` is `NULL`, the image will be hidden.
    extern fn gtk_tooltip_set_icon_from_stock(p_tooltip: *Tooltip, p_stock_id: ?[*:0]const u8, p_size: c_int) void;
    pub const setIconFromStock = gtk_tooltip_set_icon_from_stock;

    /// Sets the text of the tooltip to be `markup`, which is marked up
    /// with the [Pango text markup language][PangoMarkupFormat].
    /// If `markup` is `NULL`, the label will be hidden.
    extern fn gtk_tooltip_set_markup(p_tooltip: *Tooltip, p_markup: ?[*:0]const u8) void;
    pub const setMarkup = gtk_tooltip_set_markup;

    /// Sets the text of the tooltip to be `text`. If `text` is `NULL`, the label
    /// will be hidden. See also `gtk.Tooltip.setMarkup`.
    extern fn gtk_tooltip_set_text(p_tooltip: *Tooltip, p_text: ?[*:0]const u8) void;
    pub const setText = gtk_tooltip_set_text;

    /// Sets the area of the widget, where the contents of this tooltip apply,
    /// to be `rect` (in widget coordinates).  This is especially useful for
    /// properly setting tooltips on `gtk.TreeView` rows and cells, `GtkIconViews`,
    /// etc.
    ///
    /// For setting tooltips on `gtk.TreeView`, please refer to the convenience
    /// functions for this: `gtk.TreeView.setTooltipRow` and
    /// `gtk.TreeView.setTooltipCell`.
    extern fn gtk_tooltip_set_tip_area(p_tooltip: *Tooltip, p_rect: *const gdk.Rectangle) void;
    pub const setTipArea = gtk_tooltip_set_tip_area;

    extern fn gtk_tooltip_get_type() usize;
    pub const getGObjectType = gtk_tooltip_get_type;

    extern fn g_object_ref(p_self: *gtk.Tooltip) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Tooltip) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Tooltip, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToplevelAccessible = extern struct {
    pub const Parent = atk.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.ToplevelAccessibleClass;
    f_parent: atk.Object,
    f_priv: ?*gtk.ToplevelAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_toplevel_accessible_get_children(p_accessible: *ToplevelAccessible) *glib.List;
    pub const getChildren = gtk_toplevel_accessible_get_children;

    extern fn gtk_toplevel_accessible_get_type() usize;
    pub const getGObjectType = gtk_toplevel_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.ToplevelAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ToplevelAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ToplevelAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.TreeModelFilter` is a tree model which wraps another tree model,
/// and can do the following things:
///
/// - Filter specific rows, based on data from a “visible column”, a column
///   storing booleans indicating whether the row should be filtered or not,
///   or based on the return value of a “visible function”, which gets a
///   model, iter and user_data and returns a boolean indicating whether the
///   row should be filtered or not.
///
/// - Modify the “appearance” of the model, using a modify function.
///   This is extremely powerful and allows for just changing some
///   values and also for creating a completely different model based
///   on the given child model.
///
/// - Set a different root node, also known as a “virtual root”. You can pass
///   in a `gtk.TreePath` indicating the root node for the filter at construction
///   time.
///
/// The basic API is similar to `gtk.TreeModelSort`. For an example on its usage,
/// see the section on `gtk.TreeModelSort`.
///
/// When using `gtk.TreeModelFilter`, it is important to realize that
/// `gtk.TreeModelFilter` maintains an internal cache of all nodes which are
/// visible in its clients. The cache is likely to be a subtree of the tree
/// exposed by the child model. `gtk.TreeModelFilter` will not cache the entire
/// child model when unnecessary to not compromise the caching mechanism
/// that is exposed by the reference counting scheme. If the child model
/// implements reference counting, unnecessary signals may not be emitted
/// because of reference counting rule 3, see the `gtk.TreeModel`
/// documentation. (Note that e.g. `gtk.TreeStore` does not implement
/// reference counting and will always emit all signals, even when
/// the receiving node is not visible).
///
/// Because of this, limitations for possible visible functions do apply.
/// In general, visible functions should only use data or properties from
/// the node for which the visibility state must be determined, its siblings
/// or its parents. Usually, having a dependency on the state of any child
/// node is not possible, unless references are taken on these explicitly.
/// When no such reference exists, no signals may be received for these child
/// nodes (see reference couting rule number 3 in the `gtk.TreeModel` section).
///
/// Determining the visibility state of a given node based on the state
/// of its child nodes is a frequently occurring use case. Therefore,
/// `gtk.TreeModelFilter` explicitly supports this. For example, when a node
/// does not have any children, you might not want the node to be visible.
/// As soon as the first row is added to the node’s child level (or the
/// last row removed), the node’s visibility should be updated.
///
/// This introduces a dependency from the node on its child nodes. In order
/// to accommodate this, `gtk.TreeModelFilter` must make sure the necessary
/// signals are received from the child model. This is achieved by building,
/// for all nodes which are exposed as visible nodes to `gtk.TreeModelFilter`'s
/// clients, the child level (if any) and take a reference on the first node
/// in this level. Furthermore, for every row-inserted, row-changed or
/// row-deleted signal (also these which were not handled because the node
/// was not cached), `gtk.TreeModelFilter` will check if the visibility state
/// of any parent node has changed.
///
/// Beware, however, that this explicit support is limited to these two
/// cases. For example, if you want a node to be visible only if two nodes
/// in a child’s child level (2 levels deeper) are visible, you are on your
/// own. In this case, either rely on `gtk.TreeStore` to emit all signals
/// because it does not implement reference counting, or for models that
/// do implement reference counting, obtain references on these child levels
/// yourself.
pub const TreeModelFilter = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gtk.TreeDragSource, gtk.TreeModel };
    pub const Class = gtk.TreeModelFilterClass;
    f_parent: gobject.Object,
    f_priv: ?*gtk.TreeModelFilterPrivate,

    pub const virtual_methods = struct {
        pub const modify = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_value: *gobject.Value, p_column: c_int) void {
                return gobject.ext.as(TreeModelFilter.Class, p_class).f_modify.?(gobject.ext.as(TreeModelFilter, p_self), p_child_model, p_iter, p_value, p_column);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_value: *gobject.Value, p_column: c_int) callconv(.c) void) void {
                gobject.ext.as(TreeModelFilter.Class, p_class).f_modify = @ptrCast(p_implementation);
            }
        };

        pub const visible = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child_model: *gtk.TreeModel, p_iter: *gtk.TreeIter) c_int {
                return gobject.ext.as(TreeModelFilter.Class, p_class).f_visible.?(gobject.ext.as(TreeModelFilter, p_self), p_child_model, p_iter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child_model: *gtk.TreeModel, p_iter: *gtk.TreeIter) callconv(.c) c_int) void {
                gobject.ext.as(TreeModelFilter.Class, p_class).f_visible = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const child_model = struct {
            pub const name = "child-model";

            pub const Type = ?*gtk.TreeModel;
        };

        pub const virtual_root = struct {
            pub const name = "virtual-root";

            pub const Type = ?*gtk.TreePath;
        };
    };

    pub const signals = struct {};

    /// This function should almost never be called. It clears the `filter`
    /// of any cached iterators that haven’t been reffed with
    /// `gtk.TreeModel.refNode`. This might be useful if the child model
    /// being filtered is static (and doesn’t change often) and there has been
    /// a lot of unreffed access to nodes. As a side effect of this function,
    /// all unreffed iters will be invalid.
    extern fn gtk_tree_model_filter_clear_cache(p_filter: *TreeModelFilter) void;
    pub const clearCache = gtk_tree_model_filter_clear_cache;

    /// Sets `filter_iter` to point to the row in `filter` that corresponds to the
    /// row pointed at by `child_iter`.  If `filter_iter` was not set, `FALSE` is
    /// returned.
    extern fn gtk_tree_model_filter_convert_child_iter_to_iter(p_filter: *TreeModelFilter, p_filter_iter: *gtk.TreeIter, p_child_iter: *gtk.TreeIter) c_int;
    pub const convertChildIterToIter = gtk_tree_model_filter_convert_child_iter_to_iter;

    /// Converts `child_path` to a path relative to `filter`. That is, `child_path`
    /// points to a path in the child model. The rerturned path will point to the
    /// same row in the filtered model. If `child_path` isn’t a valid path on the
    /// child model or points to a row which is not visible in `filter`, then `NULL`
    /// is returned.
    extern fn gtk_tree_model_filter_convert_child_path_to_path(p_filter: *TreeModelFilter, p_child_path: *gtk.TreePath) ?*gtk.TreePath;
    pub const convertChildPathToPath = gtk_tree_model_filter_convert_child_path_to_path;

    /// Sets `child_iter` to point to the row pointed to by `filter_iter`.
    extern fn gtk_tree_model_filter_convert_iter_to_child_iter(p_filter: *TreeModelFilter, p_child_iter: *gtk.TreeIter, p_filter_iter: *gtk.TreeIter) void;
    pub const convertIterToChildIter = gtk_tree_model_filter_convert_iter_to_child_iter;

    /// Converts `filter_path` to a path on the child model of `filter`. That is,
    /// `filter_path` points to a location in `filter`. The returned path will
    /// point to the same location in the model not being filtered. If `filter_path`
    /// does not point to a location in the child model, `NULL` is returned.
    extern fn gtk_tree_model_filter_convert_path_to_child_path(p_filter: *TreeModelFilter, p_filter_path: *gtk.TreePath) ?*gtk.TreePath;
    pub const convertPathToChildPath = gtk_tree_model_filter_convert_path_to_child_path;

    /// Returns a pointer to the child model of `filter`.
    extern fn gtk_tree_model_filter_get_model(p_filter: *TreeModelFilter) *gtk.TreeModel;
    pub const getModel = gtk_tree_model_filter_get_model;

    /// Emits ::row_changed for each row in the child model, which causes
    /// the filter to re-evaluate whether a row is visible or not.
    extern fn gtk_tree_model_filter_refilter(p_filter: *TreeModelFilter) void;
    pub const refilter = gtk_tree_model_filter_refilter;

    /// With the `n_columns` and `types` parameters, you give an array of column
    /// types for this model (which will be exposed to the parent model/view).
    /// The `func`, `data` and `destroy` parameters are for specifying the modify
    /// function. The modify function will get called for each
    /// data access, the goal of the modify function is to return the data which
    /// should be displayed at the location specified using the parameters of the
    /// modify function.
    ///
    /// Note that `gtk.TreeModelFilter.setModifyFunc`
    /// can only be called once for a given filter model.
    extern fn gtk_tree_model_filter_set_modify_func(p_filter: *TreeModelFilter, p_n_columns: c_int, p_types: [*]usize, p_func: gtk.TreeModelFilterModifyFunc, p_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setModifyFunc = gtk_tree_model_filter_set_modify_func;

    /// Sets `column` of the child_model to be the column where `filter` should
    /// look for visibility information. `columns` should be a column of type
    /// `G_TYPE_BOOLEAN`, where `TRUE` means that a row is visible, and `FALSE`
    /// if not.
    ///
    /// Note that `gtk.TreeModelFilter.setVisibleFunc` or
    /// `gtk.TreeModelFilter.setVisibleColumn` can only be called
    /// once for a given filter model.
    extern fn gtk_tree_model_filter_set_visible_column(p_filter: *TreeModelFilter, p_column: c_int) void;
    pub const setVisibleColumn = gtk_tree_model_filter_set_visible_column;

    /// Sets the visible function used when filtering the `filter` to be `func`.
    /// The function should return `TRUE` if the given row should be visible and
    /// `FALSE` otherwise.
    ///
    /// If the condition calculated by the function changes over time (e.g.
    /// because it depends on some global parameters), you must call
    /// `gtk.TreeModelFilter.refilter` to keep the visibility information
    /// of the model up-to-date.
    ///
    /// Note that `func` is called whenever a row is inserted, when it may still
    /// be empty. The visible function should therefore take special care of empty
    /// rows, like in the example below.
    ///
    /// ```
    /// static gboolean
    /// visible_func (GtkTreeModel *model,
    ///               GtkTreeIter  *iter,
    ///               gpointer      data)
    /// {
    ///   // Visible if row is non-empty and first column is “HI”
    ///   gchar *str;
    ///   gboolean visible = FALSE;
    ///
    ///   gtk_tree_model_get (model, iter, 0, &str, -1);
    ///   if (str && strcmp (str, "HI") == 0)
    ///     visible = TRUE;
    ///   g_free (str);
    ///
    ///   return visible;
    /// }
    /// ```
    ///
    /// Note that `gtk.TreeModelFilter.setVisibleFunc` or
    /// `gtk.TreeModelFilter.setVisibleColumn` can only be called
    /// once for a given filter model.
    extern fn gtk_tree_model_filter_set_visible_func(p_filter: *TreeModelFilter, p_func: gtk.TreeModelFilterVisibleFunc, p_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setVisibleFunc = gtk_tree_model_filter_set_visible_func;

    extern fn gtk_tree_model_filter_get_type() usize;
    pub const getGObjectType = gtk_tree_model_filter_get_type;

    extern fn g_object_ref(p_self: *gtk.TreeModelFilter) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TreeModelFilter) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TreeModelFilter, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.TreeModelSort` is a model which implements the `gtk.TreeSortable`
/// interface.  It does not hold any data itself, but rather is created with
/// a child model and proxies its data.  It has identical column types to
/// this child model, and the changes in the child are propagated.  The
/// primary purpose of this model is to provide a way to sort a different
/// model without modifying it. Note that the sort function used by
/// `gtk.TreeModelSort` is not guaranteed to be stable.
///
/// The use of this is best demonstrated through an example.  In the
/// following sample code we create two `gtk.TreeView` widgets each with a
/// view of the same data.  As the model is wrapped here by a
/// `gtk.TreeModelSort`, the two `GtkTreeViews` can each sort their
/// view of the data without affecting the other.  By contrast, if we
/// simply put the same model in each widget, then sorting the first would
/// sort the second.
///
/// ## Using a
///
/// ```
/// {
///   GtkTreeView *tree_view1;
///   GtkTreeView *tree_view2;
///   GtkTreeModel *sort_model1;
///   GtkTreeModel *sort_model2;
///   GtkTreeModel *child_model;
///
///   // get the child model
///   child_model = get_my_model ();
///
///   // Create the first tree
///   sort_model1 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view1 = gtk_tree_view_new_with_model (sort_model1);
///
///   // Create the second tree
///   sort_model2 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view2 = gtk_tree_view_new_with_model (sort_model2);
///
///   // Now we can sort the two models independently
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model1),
///                                         COLUMN_1, GTK_SORT_ASCENDING);
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model2),
///                                         COLUMN_1, GTK_SORT_DESCENDING);
/// }
/// ```
///
/// To demonstrate how to access the underlying child model from the sort
/// model, the next example will be a callback for the `gtk.TreeSelection`
/// `gtk.TreeSelection.signals.changed` signal.  In this callback, we get a string
/// from COLUMN_1 of the model.  We then modify the string, find the same
/// selected row on the child model, and change the row there.
///
/// ## Accessing the child model of in a selection changed callback
///
/// ```
/// void
/// selection_changed (GtkTreeSelection *selection, gpointer data)
/// {
///   GtkTreeModel *sort_model = NULL;
///   GtkTreeModel *child_model;
///   GtkTreeIter sort_iter;
///   GtkTreeIter child_iter;
///   char *some_data = NULL;
///   char *modified_data;
///
///   // Get the current selected row and the model.
///   if (! gtk_tree_selection_get_selected (selection,
///                                          &sort_model,
///                                          &sort_iter))
///     return;
///
///   // Look up the current value on the selected row and get
///   // a new value to change it to.
///   gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
///                       COLUMN_1, &some_data,
///                       -1);
///
///   modified_data = change_the_data (some_data);
///   g_free (some_data);
///
///   // Get an iterator on the child model, instead of the sort model.
///   gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
///                                                   &child_iter,
///                                                   &sort_iter);
///
///   // Get the child model and change the value of the row. In this
///   // example, the child model is a GtkListStore. It could be any other
///   // type of model, though.
///   child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
///   gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
///                       COLUMN_1, &modified_data,
///                       -1);
///   g_free (modified_data);
/// }
/// ```
pub const TreeModelSort = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gtk.TreeDragSource, gtk.TreeModel, gtk.TreeSortable };
    pub const Class = gtk.TreeModelSortClass;
    f_parent: gobject.Object,
    f_priv: ?*gtk.TreeModelSortPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const model = struct {
            pub const name = "model";

            pub const Type = ?*gtk.TreeModel;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.TreeModelSort`, with `child_model` as the child model.
    extern fn gtk_tree_model_sort_new_with_model(p_child_model: *gtk.TreeModel) *gtk.TreeModelSort;
    pub const newWithModel = gtk_tree_model_sort_new_with_model;

    /// This function should almost never be called.  It clears the `tree_model_sort`
    /// of any cached iterators that haven’t been reffed with
    /// `gtk.TreeModel.refNode`.  This might be useful if the child model being
    /// sorted is static (and doesn’t change often) and there has been a lot of
    /// unreffed access to nodes.  As a side effect of this function, all unreffed
    /// iters will be invalid.
    extern fn gtk_tree_model_sort_clear_cache(p_tree_model_sort: *TreeModelSort) void;
    pub const clearCache = gtk_tree_model_sort_clear_cache;

    /// Sets `sort_iter` to point to the row in `tree_model_sort` that corresponds to
    /// the row pointed at by `child_iter`.  If `sort_iter` was not set, `FALSE`
    /// is returned.  Note: a boolean is only returned since 2.14.
    extern fn gtk_tree_model_sort_convert_child_iter_to_iter(p_tree_model_sort: *TreeModelSort, p_sort_iter: *gtk.TreeIter, p_child_iter: *gtk.TreeIter) c_int;
    pub const convertChildIterToIter = gtk_tree_model_sort_convert_child_iter_to_iter;

    /// Converts `child_path` to a path relative to `tree_model_sort`.  That is,
    /// `child_path` points to a path in the child model.  The returned path will
    /// point to the same row in the sorted model.  If `child_path` isn’t a valid
    /// path on the child model, then `NULL` is returned.
    extern fn gtk_tree_model_sort_convert_child_path_to_path(p_tree_model_sort: *TreeModelSort, p_child_path: *gtk.TreePath) ?*gtk.TreePath;
    pub const convertChildPathToPath = gtk_tree_model_sort_convert_child_path_to_path;

    /// Sets `child_iter` to point to the row pointed to by `sorted_iter`.
    extern fn gtk_tree_model_sort_convert_iter_to_child_iter(p_tree_model_sort: *TreeModelSort, p_child_iter: *gtk.TreeIter, p_sorted_iter: *gtk.TreeIter) void;
    pub const convertIterToChildIter = gtk_tree_model_sort_convert_iter_to_child_iter;

    /// Converts `sorted_path` to a path on the child model of `tree_model_sort`.
    /// That is, `sorted_path` points to a location in `tree_model_sort`.  The
    /// returned path will point to the same location in the model not being
    /// sorted.  If `sorted_path` does not point to a location in the child model,
    /// `NULL` is returned.
    extern fn gtk_tree_model_sort_convert_path_to_child_path(p_tree_model_sort: *TreeModelSort, p_sorted_path: *gtk.TreePath) ?*gtk.TreePath;
    pub const convertPathToChildPath = gtk_tree_model_sort_convert_path_to_child_path;

    /// Returns the model the `gtk.TreeModelSort` is sorting.
    extern fn gtk_tree_model_sort_get_model(p_tree_model: *TreeModelSort) *gtk.TreeModel;
    pub const getModel = gtk_tree_model_sort_get_model;

    /// > This function is slow. Only use it for debugging and/or testing
    /// > purposes.
    ///
    /// Checks if the given iter is a valid iter for this `gtk.TreeModelSort`.
    extern fn gtk_tree_model_sort_iter_is_valid(p_tree_model_sort: *TreeModelSort, p_iter: *gtk.TreeIter) c_int;
    pub const iterIsValid = gtk_tree_model_sort_iter_is_valid;

    /// This resets the default sort function to be in the “unsorted” state.  That
    /// is, it is in the same order as the child model. It will re-sort the model
    /// to be in the same order as the child model only if the `gtk.TreeModelSort`
    /// is in “unsorted” state.
    extern fn gtk_tree_model_sort_reset_default_sort_func(p_tree_model_sort: *TreeModelSort) void;
    pub const resetDefaultSortFunc = gtk_tree_model_sort_reset_default_sort_func;

    extern fn gtk_tree_model_sort_get_type() usize;
    pub const getGObjectType = gtk_tree_model_sort_get_type;

    extern fn g_object_ref(p_self: *gtk.TreeModelSort) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TreeModelSort) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TreeModelSort, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.TreeSelection` object is a helper object to manage the selection
/// for a `gtk.TreeView` widget.  The `gtk.TreeSelection` object is
/// automatically created when a new `gtk.TreeView` widget is created, and
/// cannot exist independently of this widget.  The primary reason the
/// `gtk.TreeSelection` objects exists is for cleanliness of code and API.
/// That is, there is no conceptual reason all these functions could not be
/// methods on the `gtk.TreeView` widget instead of a separate function.
///
/// The `gtk.TreeSelection` object is gotten from a `gtk.TreeView` by calling
/// `gtk.TreeView.getSelection`.  It can be manipulated to check the
/// selection status of the tree, as well as select and deselect individual
/// rows.  Selection is done completely view side.  As a result, multiple
/// views of the same model can have completely different selections.
/// Additionally, you cannot change the selection of a row on the model that
/// is not currently displayed by the view without expanding its parents
/// first.
///
/// One of the important things to remember when monitoring the selection of
/// a view is that the `gtk.TreeSelection.signals.changed` signal is mostly a hint.
/// That is, it may only emit one signal when a range of rows is selected.
/// Additionally, it may on occasion emit a `gtk.TreeSelection.signals.changed` signal
/// when nothing has happened (mostly as a result of programmers calling
/// select_row on an already selected row).
pub const TreeSelection = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.TreeSelectionClass;
    f_parent: gobject.Object,
    f_priv: ?*gtk.TreeSelectionPrivate,

    pub const virtual_methods = struct {
        /// Signal emitted whenever the selection has (possibly) changed.
        pub const changed = struct {
            pub fn call(p_class: anytype, p_selection: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TreeSelection.Class, p_class).f_changed.?(gobject.ext.as(TreeSelection, p_selection));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_selection: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TreeSelection.Class, p_class).f_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Selection mode.
        /// See `gtk.TreeSelection.setMode` for more information on this property.
        pub const mode = struct {
            pub const name = "mode";

            pub const Type = gtk.SelectionMode;
        };
    };

    pub const signals = struct {
        /// Emitted whenever the selection has (possibly) changed. Please note that
        /// this signal is mostly a hint.  It may only be emitted once when a range
        /// of rows are selected, and it may occasionally be emitted when nothing
        /// has happened.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeSelection, p_instance))),
                    gobject.signalLookup("changed", TreeSelection.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Returns the number of rows that have been selected in `tree`.
    extern fn gtk_tree_selection_count_selected_rows(p_selection: *TreeSelection) c_int;
    pub const countSelectedRows = gtk_tree_selection_count_selected_rows;

    /// Gets the selection mode for `selection`. See
    /// `gtk.TreeSelection.setMode`.
    extern fn gtk_tree_selection_get_mode(p_selection: *TreeSelection) gtk.SelectionMode;
    pub const getMode = gtk_tree_selection_get_mode;

    /// Returns the current selection function.
    extern fn gtk_tree_selection_get_select_function(p_selection: *TreeSelection) gtk.TreeSelectionFunc;
    pub const getSelectFunction = gtk_tree_selection_get_select_function;

    /// Sets `iter` to the currently selected node, if `selection` is set to
    /// `GTK_SELECTION_SINGLE` or `GTK_SELECTION_BROWSE`.
    ///
    /// The `iter` argument may be `NULL` if you just want to test if `selection`
    /// has any selected nodes.
    ///
    /// The `model` argument is filled with the current model as a convenience.
    ///
    /// This function will not work with `GTK_SELECTION_MULTIPLE`. See
    /// `gtk.TreeSelection.getSelectedRows` instead.
    extern fn gtk_tree_selection_get_selected(p_selection: *TreeSelection, p_model: ?**gtk.TreeModel, p_iter: ?*gtk.TreeIter) c_int;
    pub const getSelected = gtk_tree_selection_get_selected;

    /// Creates a list of path of all selected rows.
    ///
    /// Additionally, if you are planning on modifying the model after calling
    /// this function, you may want to convert the returned list into a list
    /// of `GtkTreeRowReferences`.
    ///
    /// To do this, you can use `gtk.TreeRowReference.new`.
    ///
    /// To free the return value, use:
    ///
    /// ```
    /// g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
    /// ```
    extern fn gtk_tree_selection_get_selected_rows(p_selection: *TreeSelection, p_model: ?**gtk.TreeModel) *glib.List;
    pub const getSelectedRows = gtk_tree_selection_get_selected_rows;

    /// Returns the tree view associated with `selection`.
    extern fn gtk_tree_selection_get_tree_view(p_selection: *TreeSelection) *gtk.TreeView;
    pub const getTreeView = gtk_tree_selection_get_tree_view;

    /// Returns the user data for the selection function.
    extern fn gtk_tree_selection_get_user_data(p_selection: *TreeSelection) ?*anyopaque;
    pub const getUserData = gtk_tree_selection_get_user_data;

    /// Returns `TRUE` if the row at `iter` is currently selected.
    extern fn gtk_tree_selection_iter_is_selected(p_selection: *TreeSelection, p_iter: *gtk.TreeIter) c_int;
    pub const iterIsSelected = gtk_tree_selection_iter_is_selected;

    /// Returns `TRUE` if the row pointed to by `path` is currently selected.  If `path`
    /// does not point to a valid location, `FALSE` is returned
    extern fn gtk_tree_selection_path_is_selected(p_selection: *TreeSelection, p_path: *gtk.TreePath) c_int;
    pub const pathIsSelected = gtk_tree_selection_path_is_selected;

    /// Selects all the nodes. `selection` must be set to `GTK_SELECTION_MULTIPLE`
    /// mode.
    extern fn gtk_tree_selection_select_all(p_selection: *TreeSelection) void;
    pub const selectAll = gtk_tree_selection_select_all;

    /// Selects the specified iterator.
    extern fn gtk_tree_selection_select_iter(p_selection: *TreeSelection, p_iter: *gtk.TreeIter) void;
    pub const selectIter = gtk_tree_selection_select_iter;

    /// Select the row at `path`.
    extern fn gtk_tree_selection_select_path(p_selection: *TreeSelection, p_path: *gtk.TreePath) void;
    pub const selectPath = gtk_tree_selection_select_path;

    /// Selects a range of nodes, determined by `start_path` and `end_path` inclusive.
    /// `selection` must be set to `GTK_SELECTION_MULTIPLE` mode.
    extern fn gtk_tree_selection_select_range(p_selection: *TreeSelection, p_start_path: *gtk.TreePath, p_end_path: *gtk.TreePath) void;
    pub const selectRange = gtk_tree_selection_select_range;

    /// Calls a function for each selected node. Note that you cannot modify
    /// the tree or selection from within this function. As a result,
    /// `gtk.TreeSelection.getSelectedRows` might be more useful.
    extern fn gtk_tree_selection_selected_foreach(p_selection: *TreeSelection, p_func: gtk.TreeSelectionForeachFunc, p_data: ?*anyopaque) void;
    pub const selectedForeach = gtk_tree_selection_selected_foreach;

    /// Sets the selection mode of the `selection`.  If the previous type was
    /// `GTK_SELECTION_MULTIPLE`, then the anchor is kept selected, if it was
    /// previously selected.
    extern fn gtk_tree_selection_set_mode(p_selection: *TreeSelection, p_type: gtk.SelectionMode) void;
    pub const setMode = gtk_tree_selection_set_mode;

    /// Sets the selection function.
    ///
    /// If set, this function is called before any node is selected or unselected,
    /// giving some control over which nodes are selected. The select function
    /// should return `TRUE` if the state of the node may be toggled, and `FALSE`
    /// if the state of the node should be left unchanged.
    extern fn gtk_tree_selection_set_select_function(p_selection: *TreeSelection, p_func: ?gtk.TreeSelectionFunc, p_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setSelectFunction = gtk_tree_selection_set_select_function;

    /// Unselects all the nodes.
    extern fn gtk_tree_selection_unselect_all(p_selection: *TreeSelection) void;
    pub const unselectAll = gtk_tree_selection_unselect_all;

    /// Unselects the specified iterator.
    extern fn gtk_tree_selection_unselect_iter(p_selection: *TreeSelection, p_iter: *gtk.TreeIter) void;
    pub const unselectIter = gtk_tree_selection_unselect_iter;

    /// Unselects the row at `path`.
    extern fn gtk_tree_selection_unselect_path(p_selection: *TreeSelection, p_path: *gtk.TreePath) void;
    pub const unselectPath = gtk_tree_selection_unselect_path;

    /// Unselects a range of nodes, determined by `start_path` and `end_path`
    /// inclusive.
    extern fn gtk_tree_selection_unselect_range(p_selection: *TreeSelection, p_start_path: *gtk.TreePath, p_end_path: *gtk.TreePath) void;
    pub const unselectRange = gtk_tree_selection_unselect_range;

    extern fn gtk_tree_selection_get_type() usize;
    pub const getGObjectType = gtk_tree_selection_get_type;

    extern fn g_object_ref(p_self: *gtk.TreeSelection) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TreeSelection) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TreeSelection, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.TreeStore` object is a list model for use with a `gtk.TreeView`
/// widget.  It implements the `gtk.TreeModel` interface, and consequentially,
/// can use all of the methods available there.  It also implements the
/// `gtk.TreeSortable` interface so it can be sorted by the view.  Finally,
/// it also implements the tree
/// [drag and drop][gtk3-GtkTreeView-drag-and-drop]
/// interfaces.
///
/// # GtkTreeStore as GtkBuildable
///
/// The GtkTreeStore implementation of the `gtk.Buildable` interface allows
/// to specify the model columns with a `<columns>` element that may contain
/// multiple `<column>` elements, each specifying one model column. The “type”
/// attribute specifies the data type for the column.
///
/// An example of a UI Definition fragment for a tree store:
///
/// ```
/// <object class="GtkTreeStore">
///   <columns>
///     <column type="gchararray"/>
///     <column type="gchararray"/>
///     <column type="gint"/>
///   </columns>
/// </object>
/// ```
pub const TreeStore = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gtk.Buildable, gtk.TreeDragDest, gtk.TreeDragSource, gtk.TreeModel, gtk.TreeSortable };
    pub const Class = gtk.TreeStoreClass;
    f_parent: gobject.Object,
    f_priv: ?*gtk.TreeStorePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new tree store as with `n_columns` columns each of the types passed
    /// in.  Note that only types derived from standard GObject fundamental types
    /// are supported.
    ///
    /// As an example, `gtk_tree_store_new (3, G_TYPE_INT, G_TYPE_STRING,
    /// GDK_TYPE_PIXBUF);` will create a new `gtk.TreeStore` with three columns, of type
    /// `gint`, `gchararray`, and `gdkpixbuf.Pixbuf` respectively.
    extern fn gtk_tree_store_new(p_n_columns: c_int, ...) *gtk.TreeStore;
    pub const new = gtk_tree_store_new;

    /// Non vararg creation function.  Used primarily by language bindings.
    extern fn gtk_tree_store_newv(p_n_columns: c_int, p_types: [*]usize) *gtk.TreeStore;
    pub const newv = gtk_tree_store_newv;

    /// Appends a new row to `tree_store`.  If `parent` is non-`NULL`, then it will append the
    /// new row after the last child of `parent`, otherwise it will append a row to
    /// the top level.  `iter` will be changed to point to this new row.  The row will
    /// be empty after this function is called.  To fill in values, you need to call
    /// `gtk.TreeStore.set` or `gtk.TreeStore.setValue`.
    extern fn gtk_tree_store_append(p_tree_store: *TreeStore, p_iter: *gtk.TreeIter, p_parent: ?*gtk.TreeIter) void;
    pub const append = gtk_tree_store_append;

    /// Removes all rows from `tree_store`
    extern fn gtk_tree_store_clear(p_tree_store: *TreeStore) void;
    pub const clear = gtk_tree_store_clear;

    /// Creates a new row at `position`.  If parent is non-`NULL`, then the row will be
    /// made a child of `parent`.  Otherwise, the row will be created at the toplevel.
    /// If `position` is -1 or is larger than the number of rows at that level, then
    /// the new row will be inserted to the end of the list.  `iter` will be changed
    /// to point to this new row.  The row will be empty after this function is
    /// called.  To fill in values, you need to call `gtk.TreeStore.set` or
    /// `gtk.TreeStore.setValue`.
    extern fn gtk_tree_store_insert(p_tree_store: *TreeStore, p_iter: *gtk.TreeIter, p_parent: ?*gtk.TreeIter, p_position: c_int) void;
    pub const insert = gtk_tree_store_insert;

    /// Inserts a new row after `sibling`.  If `sibling` is `NULL`, then the row will be
    /// prepended to `parent` ’s children.  If `parent` and `sibling` are `NULL`, then
    /// the row will be prepended to the toplevel.  If both `sibling` and `parent` are
    /// set, then `parent` must be the parent of `sibling`.  When `sibling` is set,
    /// `parent` is optional.
    ///
    /// `iter` will be changed to point to this new row.  The row will be empty after
    /// this function is called.  To fill in values, you need to call
    /// `gtk.TreeStore.set` or `gtk.TreeStore.setValue`.
    extern fn gtk_tree_store_insert_after(p_tree_store: *TreeStore, p_iter: *gtk.TreeIter, p_parent: ?*gtk.TreeIter, p_sibling: ?*gtk.TreeIter) void;
    pub const insertAfter = gtk_tree_store_insert_after;

    /// Inserts a new row before `sibling`.  If `sibling` is `NULL`, then the row will
    /// be appended to `parent` ’s children.  If `parent` and `sibling` are `NULL`, then
    /// the row will be appended to the toplevel.  If both `sibling` and `parent` are
    /// set, then `parent` must be the parent of `sibling`.  When `sibling` is set,
    /// `parent` is optional.
    ///
    /// `iter` will be changed to point to this new row.  The row will be empty after
    /// this function is called.  To fill in values, you need to call
    /// `gtk.TreeStore.set` or `gtk.TreeStore.setValue`.
    extern fn gtk_tree_store_insert_before(p_tree_store: *TreeStore, p_iter: *gtk.TreeIter, p_parent: ?*gtk.TreeIter, p_sibling: ?*gtk.TreeIter) void;
    pub const insertBefore = gtk_tree_store_insert_before;

    /// Creates a new row at `position`. `iter` will be changed to point to this
    /// new row. If `position` is -1, or larger than the number of rows on the list, then
    /// the new row will be appended to the list. The row will be filled with
    /// the values given to this function.
    ///
    /// Calling
    /// `gtk_tree_store_insert_with_values (tree_store, iter, position, ...)`
    /// has the same effect as calling
    /// ```
    /// gtk_tree_store_insert (tree_store, iter, position);
    /// gtk_tree_store_set (tree_store, iter, ...);
    /// ```
    /// with the different that the former will only emit a row_inserted signal,
    /// while the latter will emit row_inserted, row_changed and if the tree store
    /// is sorted, rows_reordered.  Since emitting the rows_reordered signal
    /// repeatedly can affect the performance of the program,
    /// `gtk.TreeStore.insertWithValues` should generally be preferred when
    /// inserting rows in a sorted tree store.
    extern fn gtk_tree_store_insert_with_values(p_tree_store: *TreeStore, p_iter: ?*gtk.TreeIter, p_parent: ?*gtk.TreeIter, p_position: c_int, ...) void;
    pub const insertWithValues = gtk_tree_store_insert_with_values;

    /// A variant of `gtk.TreeStore.insertWithValues` which takes
    /// the columns and values as two arrays, instead of varargs.  This
    /// function is mainly intended for language bindings.
    extern fn gtk_tree_store_insert_with_valuesv(p_tree_store: *TreeStore, p_iter: ?*gtk.TreeIter, p_parent: ?*gtk.TreeIter, p_position: c_int, p_columns: [*]c_int, p_values: [*]gobject.Value, p_n_values: c_int) void;
    pub const insertWithValuesv = gtk_tree_store_insert_with_valuesv;

    /// Returns `TRUE` if `iter` is an ancestor of `descendant`.  That is, `iter` is the
    /// parent (or grandparent or great-grandparent) of `descendant`.
    extern fn gtk_tree_store_is_ancestor(p_tree_store: *TreeStore, p_iter: *gtk.TreeIter, p_descendant: *gtk.TreeIter) c_int;
    pub const isAncestor = gtk_tree_store_is_ancestor;

    /// Returns the depth of `iter`.  This will be 0 for anything on the root level, 1
    /// for anything down a level, etc.
    extern fn gtk_tree_store_iter_depth(p_tree_store: *TreeStore, p_iter: *gtk.TreeIter) c_int;
    pub const iterDepth = gtk_tree_store_iter_depth;

    /// WARNING: This function is slow. Only use it for debugging and/or testing
    /// purposes.
    ///
    /// Checks if the given iter is a valid iter for this `gtk.TreeStore`.
    extern fn gtk_tree_store_iter_is_valid(p_tree_store: *TreeStore, p_iter: *gtk.TreeIter) c_int;
    pub const iterIsValid = gtk_tree_store_iter_is_valid;

    /// Moves `iter` in `tree_store` to the position after `position`. `iter` and
    /// `position` should be in the same level. Note that this function only
    /// works with unsorted stores. If `position` is `NULL`, `iter` will be moved
    /// to the start of the level.
    extern fn gtk_tree_store_move_after(p_tree_store: *TreeStore, p_iter: *gtk.TreeIter, p_position: ?*gtk.TreeIter) void;
    pub const moveAfter = gtk_tree_store_move_after;

    /// Moves `iter` in `tree_store` to the position before `position`. `iter` and
    /// `position` should be in the same level. Note that this function only
    /// works with unsorted stores. If `position` is `NULL`, `iter` will be
    /// moved to the end of the level.
    extern fn gtk_tree_store_move_before(p_tree_store: *TreeStore, p_iter: *gtk.TreeIter, p_position: ?*gtk.TreeIter) void;
    pub const moveBefore = gtk_tree_store_move_before;

    /// Prepends a new row to `tree_store`.  If `parent` is non-`NULL`, then it will prepend
    /// the new row before the first child of `parent`, otherwise it will prepend a row
    /// to the top level.  `iter` will be changed to point to this new row.  The row
    /// will be empty after this function is called.  To fill in values, you need to
    /// call `gtk.TreeStore.set` or `gtk.TreeStore.setValue`.
    extern fn gtk_tree_store_prepend(p_tree_store: *TreeStore, p_iter: *gtk.TreeIter, p_parent: ?*gtk.TreeIter) void;
    pub const prepend = gtk_tree_store_prepend;

    /// Removes `iter` from `tree_store`.  After being removed, `iter` is set to the
    /// next valid row at that level, or invalidated if it previously pointed to the
    /// last one.
    extern fn gtk_tree_store_remove(p_tree_store: *TreeStore, p_iter: *gtk.TreeIter) c_int;
    pub const remove = gtk_tree_store_remove;

    /// Reorders the children of `parent` in `tree_store` to follow the order
    /// indicated by `new_order`. Note that this function only works with
    /// unsorted stores.
    extern fn gtk_tree_store_reorder(p_tree_store: *TreeStore, p_parent: ?*gtk.TreeIter, p_new_order: [*]c_int) void;
    pub const reorder = gtk_tree_store_reorder;

    /// Sets the value of one or more cells in the row referenced by `iter`.
    /// The variable argument list should contain integer column numbers,
    /// each column number followed by the value to be set.
    /// The list is terminated by a -1. For example, to set column 0 with type
    /// `G_TYPE_STRING` to “Foo”, you would write
    /// `gtk_tree_store_set (store, iter, 0, "Foo", -1)`.
    ///
    /// The value will be referenced by the store if it is a `G_TYPE_OBJECT`, and it
    /// will be copied if it is a `G_TYPE_STRING` or `G_TYPE_BOXED`.
    extern fn gtk_tree_store_set(p_tree_store: *TreeStore, p_iter: *gtk.TreeIter, ...) void;
    pub const set = gtk_tree_store_set;

    /// This function is meant primarily for `GObjects` that inherit from
    /// `gtk.TreeStore`, and should only be used when constructing a new
    /// `gtk.TreeStore`.  It will not function after a row has been added,
    /// or a method on the `gtk.TreeModel` interface is called.
    extern fn gtk_tree_store_set_column_types(p_tree_store: *TreeStore, p_n_columns: c_int, p_types: [*]usize) void;
    pub const setColumnTypes = gtk_tree_store_set_column_types;

    /// See `gtk.TreeStore.set`; this version takes a va_list for
    /// use by language bindings.
    extern fn gtk_tree_store_set_valist(p_tree_store: *TreeStore, p_iter: *gtk.TreeIter, p_var_args: std.builtin.VaList) void;
    pub const setValist = gtk_tree_store_set_valist;

    /// Sets the data in the cell specified by `iter` and `column`.
    /// The type of `value` must be convertible to the type of the
    /// column.
    extern fn gtk_tree_store_set_value(p_tree_store: *TreeStore, p_iter: *gtk.TreeIter, p_column: c_int, p_value: *gobject.Value) void;
    pub const setValue = gtk_tree_store_set_value;

    /// A variant of `gtk.TreeStore.setValist` which takes
    /// the columns and values as two arrays, instead of varargs.  This
    /// function is mainly intended for language bindings or in case
    /// the number of columns to change is not known until run-time.
    extern fn gtk_tree_store_set_valuesv(p_tree_store: *TreeStore, p_iter: *gtk.TreeIter, p_columns: [*]c_int, p_values: [*]gobject.Value, p_n_values: c_int) void;
    pub const setValuesv = gtk_tree_store_set_valuesv;

    /// Swaps `a` and `b` in the same level of `tree_store`. Note that this function
    /// only works with unsorted stores.
    extern fn gtk_tree_store_swap(p_tree_store: *TreeStore, p_a: *gtk.TreeIter, p_b: *gtk.TreeIter) void;
    pub const swap = gtk_tree_store_swap;

    extern fn gtk_tree_store_get_type() usize;
    pub const getGObjectType = gtk_tree_store_get_type;

    extern fn g_object_ref(p_self: *gtk.TreeStore) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TreeStore) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TreeStore, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Widget that displays any object that implements the `gtk.TreeModel` interface.
///
/// Please refer to the
/// [tree widget conceptual overview](TreeWidget.html)
/// for an overview of all the objects and data types related
/// to the tree widget and how they work together.
///
/// Several different coordinate systems are exposed in the GtkTreeView API.
/// These are:
///
/// ![](tree-view-coordinates.png)
///
/// Coordinate systems in GtkTreeView API:
///
/// - Widget coordinates: Coordinates relative to the widget (usually `widget->window`).
///
/// - Bin window coordinates: Coordinates relative to the window that GtkTreeView renders to.
///
/// - Tree coordinates: Coordinates relative to the entire scrollable area of GtkTreeView. These
///   coordinates start at (0, 0) for row 0 of the tree.
///
/// Several functions are available for converting between the different
/// coordinate systems.  The most common translations are between widget and bin
/// window coordinates and between bin window and tree coordinates. For the
/// former you can use `gtk.TreeView.convertWidgetToBinWindowCoords`
/// (and vice versa), for the latter `gtk.TreeView.convertBinWindowToTreeCoords`
/// (and vice versa).
///
/// # GtkTreeView as GtkBuildable
///
/// The GtkTreeView implementation of the GtkBuildable interface accepts
/// `gtk.TreeViewColumn` objects as `<child>` elements and exposes the internal
/// `gtk.TreeSelection` in UI definitions.
///
/// An example of a UI definition fragment with GtkTreeView:
///
/// ```
/// <object class="GtkTreeView" id="treeview">
///   <property name="model">liststore1</property>
///   <child>
///     <object class="GtkTreeViewColumn" id="test-column">
///       <property name="title">Test</property>
///       <child>
///         <object class="GtkCellRendererText" id="test-renderer"/>
///         <attributes>
///           <attribute name="text">1</attribute>
///         </attributes>
///       </child>
///     </object>
///   </child>
///   <child internal-child="selection">
///     <object class="GtkTreeSelection" id="selection">
///       <signal name="changed" handler="on_treeview_selection_changed"/>
///     </object>
///   </child>
/// </object>
/// ```
///
/// # CSS nodes
///
/// ```
/// treeview.view
/// ├── header
/// │   ├── <column header>
/// ┊   ┊
/// │   ╰── <column header>
/// │
/// ╰── [rubberband]
/// ```
///
/// GtkTreeView has a main CSS node with name treeview and style class .view.
/// It has a subnode with name header, which is the parent for all the column
/// header widgets' CSS nodes.
/// For rubberband selection, a subnode with name rubberband is used.
pub const TreeView = extern struct {
    pub const Parent = gtk.Container;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Scrollable };
    pub const Class = gtk.TreeViewClass;
    f_parent: gtk.Container,
    f_priv: ?*gtk.TreeViewPrivate,

    pub const virtual_methods = struct {
        pub const columns_changed = struct {
            pub fn call(p_class: anytype, p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TreeView.Class, p_class).f_columns_changed.?(gobject.ext.as(TreeView, p_tree_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TreeView.Class, p_class).f_columns_changed = @ptrCast(p_implementation);
            }
        };

        pub const cursor_changed = struct {
            pub fn call(p_class: anytype, p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TreeView.Class, p_class).f_cursor_changed.?(gobject.ext.as(TreeView, p_tree_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TreeView.Class, p_class).f_cursor_changed = @ptrCast(p_implementation);
            }
        };

        pub const expand_collapse_cursor_row = struct {
            pub fn call(p_class: anytype, p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_logical: c_int, p_expand: c_int, p_open_all: c_int) c_int {
                return gobject.ext.as(TreeView.Class, p_class).f_expand_collapse_cursor_row.?(gobject.ext.as(TreeView, p_tree_view), p_logical, p_expand, p_open_all);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_logical: c_int, p_expand: c_int, p_open_all: c_int) callconv(.c) c_int) void {
                gobject.ext.as(TreeView.Class, p_class).f_expand_collapse_cursor_row = @ptrCast(p_implementation);
            }
        };

        pub const move_cursor = struct {
            pub fn call(p_class: anytype, p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_step: gtk.MovementStep, p_count: c_int) c_int {
                return gobject.ext.as(TreeView.Class, p_class).f_move_cursor.?(gobject.ext.as(TreeView, p_tree_view), p_step, p_count);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_step: gtk.MovementStep, p_count: c_int) callconv(.c) c_int) void {
                gobject.ext.as(TreeView.Class, p_class).f_move_cursor = @ptrCast(p_implementation);
            }
        };

        /// Activates the cell determined by `path` and `column`.
        pub const row_activated = struct {
            pub fn call(p_class: anytype, p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath, p_column: *gtk.TreeViewColumn) void {
                return gobject.ext.as(TreeView.Class, p_class).f_row_activated.?(gobject.ext.as(TreeView, p_tree_view), p_path, p_column);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath, p_column: *gtk.TreeViewColumn) callconv(.c) void) void {
                gobject.ext.as(TreeView.Class, p_class).f_row_activated = @ptrCast(p_implementation);
            }
        };

        pub const row_collapsed = struct {
            pub fn call(p_class: anytype, p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) void {
                return gobject.ext.as(TreeView.Class, p_class).f_row_collapsed.?(gobject.ext.as(TreeView, p_tree_view), p_iter, p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) callconv(.c) void) void {
                gobject.ext.as(TreeView.Class, p_class).f_row_collapsed = @ptrCast(p_implementation);
            }
        };

        pub const row_expanded = struct {
            pub fn call(p_class: anytype, p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) void {
                return gobject.ext.as(TreeView.Class, p_class).f_row_expanded.?(gobject.ext.as(TreeView, p_tree_view), p_iter, p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) callconv(.c) void) void {
                gobject.ext.as(TreeView.Class, p_class).f_row_expanded = @ptrCast(p_implementation);
            }
        };

        pub const select_all = struct {
            pub fn call(p_class: anytype, p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(TreeView.Class, p_class).f_select_all.?(gobject.ext.as(TreeView, p_tree_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(TreeView.Class, p_class).f_select_all = @ptrCast(p_implementation);
            }
        };

        pub const select_cursor_parent = struct {
            pub fn call(p_class: anytype, p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(TreeView.Class, p_class).f_select_cursor_parent.?(gobject.ext.as(TreeView, p_tree_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(TreeView.Class, p_class).f_select_cursor_parent = @ptrCast(p_implementation);
            }
        };

        pub const select_cursor_row = struct {
            pub fn call(p_class: anytype, p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_start_editing: c_int) c_int {
                return gobject.ext.as(TreeView.Class, p_class).f_select_cursor_row.?(gobject.ext.as(TreeView, p_tree_view), p_start_editing);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_start_editing: c_int) callconv(.c) c_int) void {
                gobject.ext.as(TreeView.Class, p_class).f_select_cursor_row = @ptrCast(p_implementation);
            }
        };

        pub const start_interactive_search = struct {
            pub fn call(p_class: anytype, p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(TreeView.Class, p_class).f_start_interactive_search.?(gobject.ext.as(TreeView, p_tree_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(TreeView.Class, p_class).f_start_interactive_search = @ptrCast(p_implementation);
            }
        };

        pub const test_collapse_row = struct {
            pub fn call(p_class: anytype, p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) c_int {
                return gobject.ext.as(TreeView.Class, p_class).f_test_collapse_row.?(gobject.ext.as(TreeView, p_tree_view), p_iter, p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) callconv(.c) c_int) void {
                gobject.ext.as(TreeView.Class, p_class).f_test_collapse_row = @ptrCast(p_implementation);
            }
        };

        pub const test_expand_row = struct {
            pub fn call(p_class: anytype, p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) c_int {
                return gobject.ext.as(TreeView.Class, p_class).f_test_expand_row.?(gobject.ext.as(TreeView, p_tree_view), p_iter, p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) callconv(.c) c_int) void {
                gobject.ext.as(TreeView.Class, p_class).f_test_expand_row = @ptrCast(p_implementation);
            }
        };

        pub const toggle_cursor_row = struct {
            pub fn call(p_class: anytype, p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(TreeView.Class, p_class).f_toggle_cursor_row.?(gobject.ext.as(TreeView, p_tree_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(TreeView.Class, p_class).f_toggle_cursor_row = @ptrCast(p_implementation);
            }
        };

        pub const unselect_all = struct {
            pub fn call(p_class: anytype, p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(TreeView.Class, p_class).f_unselect_all.?(gobject.ext.as(TreeView, p_tree_view));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_view: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(TreeView.Class, p_class).f_unselect_all = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The activate-on-single-click property specifies whether the "row-activated" signal
        /// will be emitted after a single click.
        pub const activate_on_single_click = struct {
            pub const name = "activate-on-single-click";

            pub const Type = c_int;
        };

        pub const enable_grid_lines = struct {
            pub const name = "enable-grid-lines";

            pub const Type = gtk.TreeViewGridLines;
        };

        pub const enable_search = struct {
            pub const name = "enable-search";

            pub const Type = c_int;
        };

        pub const enable_tree_lines = struct {
            pub const name = "enable-tree-lines";

            pub const Type = c_int;
        };

        pub const expander_column = struct {
            pub const name = "expander-column";

            pub const Type = ?*gtk.TreeViewColumn;
        };

        /// Setting the ::fixed-height-mode property to `TRUE` speeds up
        /// `gtk.TreeView` by assuming that all rows have the same height.
        /// Only enable this option if all rows are the same height.
        /// Please see `gtk.TreeView.setFixedHeightMode` for more
        /// information on this option.
        pub const fixed_height_mode = struct {
            pub const name = "fixed-height-mode";

            pub const Type = c_int;
        };

        pub const headers_clickable = struct {
            pub const name = "headers-clickable";

            pub const Type = c_int;
        };

        pub const headers_visible = struct {
            pub const name = "headers-visible";

            pub const Type = c_int;
        };

        /// Enables or disables the hover expansion mode of `tree_view`.
        /// Hover expansion makes rows expand or collapse if the pointer moves
        /// over them.
        ///
        /// This mode is primarily intended for treeviews in popups, e.g.
        /// in `gtk.ComboBox` or `gtk.EntryCompletion`.
        pub const hover_expand = struct {
            pub const name = "hover-expand";

            pub const Type = c_int;
        };

        /// Enables or disables the hover selection mode of `tree_view`.
        /// Hover selection makes the selected row follow the pointer.
        /// Currently, this works only for the selection modes
        /// `GTK_SELECTION_SINGLE` and `GTK_SELECTION_BROWSE`.
        ///
        /// This mode is primarily intended for treeviews in popups, e.g.
        /// in `gtk.ComboBox` or `gtk.EntryCompletion`.
        pub const hover_selection = struct {
            pub const name = "hover-selection";

            pub const Type = c_int;
        };

        /// Extra indentation for each level.
        pub const level_indentation = struct {
            pub const name = "level-indentation";

            pub const Type = c_int;
        };

        pub const model = struct {
            pub const name = "model";

            pub const Type = ?*gtk.TreeModel;
        };

        pub const reorderable = struct {
            pub const name = "reorderable";

            pub const Type = c_int;
        };

        pub const rubber_banding = struct {
            pub const name = "rubber-banding";

            pub const Type = c_int;
        };

        /// Sets a hint to the theme to draw rows in alternating colors.
        pub const rules_hint = struct {
            pub const name = "rules-hint";

            pub const Type = c_int;
        };

        pub const search_column = struct {
            pub const name = "search-column";

            pub const Type = c_int;
        };

        /// `TRUE` if the view has expanders.
        pub const show_expanders = struct {
            pub const name = "show-expanders";

            pub const Type = c_int;
        };

        pub const tooltip_column = struct {
            pub const name = "tooltip-column";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The number of columns of the treeview has changed.
        pub const columns_changed = struct {
            pub const name = "columns-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeView, p_instance))),
                    gobject.signalLookup("columns-changed", TreeView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The position of the cursor (focused cell) has changed.
        pub const cursor_changed = struct {
            pub const name = "cursor-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeView, p_instance))),
                    gobject.signalLookup("cursor-changed", TreeView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const expand_collapse_cursor_row = struct {
            pub const name = "expand-collapse-cursor-row";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: c_int, p_p0: c_int, p_p1: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeView, p_instance))),
                    gobject.signalLookup("expand-collapse-cursor-row", TreeView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The `gtk.TreeView.signals.move`-cursor signal is a [keybinding
        /// signal][GtkBindingSignal] which gets emitted when the user
        /// presses one of the cursor keys.
        ///
        /// Applications should not connect to it, but may emit it with
        /// `gobject.signalEmitByName` if they need to control the cursor
        /// programmatically. In contrast to `gtk.TreeView.setCursor` and
        /// `gtk.TreeView.setCursorOnCell` when moving horizontally
        /// `gtk.TreeView.signals.move`-cursor does not reset the current selection.
        pub const move_cursor = struct {
            pub const name = "move-cursor";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_step: gtk.MovementStep, p_direction: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeView, p_instance))),
                    gobject.signalLookup("move-cursor", TreeView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The "row-activated" signal is emitted when the method
        /// `gtk.TreeView.rowActivated` is called, when the user double
        /// clicks a treeview row with the "activate-on-single-click"
        /// property set to `FALSE`, or when the user single clicks a row when
        /// the "activate-on-single-click" property set to `TRUE`. It is also
        /// emitted when a non-editable row is selected and one of the keys:
        /// Space, Shift+Space, Return or Enter is pressed.
        ///
        /// For selection handling refer to the
        /// [tree widget conceptual overview](TreeWidget.html)
        /// as well as `gtk.TreeSelection`.
        pub const row_activated = struct {
            pub const name = "row-activated";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_path: *gtk.TreePath, p_column: *gtk.TreeViewColumn, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeView, p_instance))),
                    gobject.signalLookup("row-activated", TreeView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The given row has been collapsed (child nodes are hidden).
        pub const row_collapsed = struct {
            pub const name = "row-collapsed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_iter: *gtk.TreeIter, p_path: *gtk.TreePath, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeView, p_instance))),
                    gobject.signalLookup("row-collapsed", TreeView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The given row has been expanded (child nodes are shown).
        pub const row_expanded = struct {
            pub const name = "row-expanded";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_iter: *gtk.TreeIter, p_path: *gtk.TreePath, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeView, p_instance))),
                    gobject.signalLookup("row-expanded", TreeView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const select_all = struct {
            pub const name = "select-all";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeView, p_instance))),
                    gobject.signalLookup("select-all", TreeView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const select_cursor_parent = struct {
            pub const name = "select-cursor-parent";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeView, p_instance))),
                    gobject.signalLookup("select-cursor-parent", TreeView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const select_cursor_row = struct {
            pub const name = "select-cursor-row";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeView, p_instance))),
                    gobject.signalLookup("select-cursor-row", TreeView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const start_interactive_search = struct {
            pub const name = "start-interactive-search";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeView, p_instance))),
                    gobject.signalLookup("start-interactive-search", TreeView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The given row is about to be collapsed (hide its children nodes). Use this
        /// signal if you need to control the collapsibility of individual rows.
        pub const test_collapse_row = struct {
            pub const name = "test-collapse-row";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_iter: *gtk.TreeIter, p_path: *gtk.TreePath, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeView, p_instance))),
                    gobject.signalLookup("test-collapse-row", TreeView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The given row is about to be expanded (show its children nodes). Use this
        /// signal if you need to control the expandability of individual rows.
        pub const test_expand_row = struct {
            pub const name = "test-expand-row";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_iter: *gtk.TreeIter, p_path: *gtk.TreePath, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeView, p_instance))),
                    gobject.signalLookup("test-expand-row", TreeView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const toggle_cursor_row = struct {
            pub const name = "toggle-cursor-row";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeView, p_instance))),
                    gobject.signalLookup("toggle-cursor-row", TreeView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const unselect_all = struct {
            pub const name = "unselect-all";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeView, p_instance))),
                    gobject.signalLookup("unselect-all", TreeView.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.TreeView` widget.
    extern fn gtk_tree_view_new() *gtk.TreeView;
    pub const new = gtk_tree_view_new;

    /// Creates a new `gtk.TreeView` widget with the model initialized to `model`.
    extern fn gtk_tree_view_new_with_model(p_model: *gtk.TreeModel) *gtk.TreeView;
    pub const newWithModel = gtk_tree_view_new_with_model;

    /// Appends `column` to the list of columns. If `tree_view` has “fixed_height”
    /// mode enabled, then `column` must have its “sizing” property set to be
    /// GTK_TREE_VIEW_COLUMN_FIXED.
    extern fn gtk_tree_view_append_column(p_tree_view: *TreeView, p_column: *gtk.TreeViewColumn) c_int;
    pub const appendColumn = gtk_tree_view_append_column;

    /// Recursively collapses all visible, expanded nodes in `tree_view`.
    extern fn gtk_tree_view_collapse_all(p_tree_view: *TreeView) void;
    pub const collapseAll = gtk_tree_view_collapse_all;

    /// Collapses a row (hides its child rows, if they exist).
    extern fn gtk_tree_view_collapse_row(p_tree_view: *TreeView, p_path: *gtk.TreePath) c_int;
    pub const collapseRow = gtk_tree_view_collapse_row;

    /// Resizes all columns to their optimal width. Only works after the
    /// treeview has been realized.
    extern fn gtk_tree_view_columns_autosize(p_tree_view: *TreeView) void;
    pub const columnsAutosize = gtk_tree_view_columns_autosize;

    /// Converts bin_window coordinates to coordinates for the
    /// tree (the full scrollable area of the tree).
    extern fn gtk_tree_view_convert_bin_window_to_tree_coords(p_tree_view: *TreeView, p_bx: c_int, p_by: c_int, p_tx: *c_int, p_ty: *c_int) void;
    pub const convertBinWindowToTreeCoords = gtk_tree_view_convert_bin_window_to_tree_coords;

    /// Converts bin_window coordinates (see `gtk.TreeView.getBinWindow`)
    /// to widget relative coordinates.
    extern fn gtk_tree_view_convert_bin_window_to_widget_coords(p_tree_view: *TreeView, p_bx: c_int, p_by: c_int, p_wx: *c_int, p_wy: *c_int) void;
    pub const convertBinWindowToWidgetCoords = gtk_tree_view_convert_bin_window_to_widget_coords;

    /// Converts tree coordinates (coordinates in full scrollable area of the tree)
    /// to bin_window coordinates.
    extern fn gtk_tree_view_convert_tree_to_bin_window_coords(p_tree_view: *TreeView, p_tx: c_int, p_ty: c_int, p_bx: *c_int, p_by: *c_int) void;
    pub const convertTreeToBinWindowCoords = gtk_tree_view_convert_tree_to_bin_window_coords;

    /// Converts tree coordinates (coordinates in full scrollable area of the tree)
    /// to widget coordinates.
    extern fn gtk_tree_view_convert_tree_to_widget_coords(p_tree_view: *TreeView, p_tx: c_int, p_ty: c_int, p_wx: *c_int, p_wy: *c_int) void;
    pub const convertTreeToWidgetCoords = gtk_tree_view_convert_tree_to_widget_coords;

    /// Converts widget coordinates to coordinates for the bin_window
    /// (see `gtk.TreeView.getBinWindow`).
    extern fn gtk_tree_view_convert_widget_to_bin_window_coords(p_tree_view: *TreeView, p_wx: c_int, p_wy: c_int, p_bx: *c_int, p_by: *c_int) void;
    pub const convertWidgetToBinWindowCoords = gtk_tree_view_convert_widget_to_bin_window_coords;

    /// Converts widget coordinates to coordinates for the
    /// tree (the full scrollable area of the tree).
    extern fn gtk_tree_view_convert_widget_to_tree_coords(p_tree_view: *TreeView, p_wx: c_int, p_wy: c_int, p_tx: *c_int, p_ty: *c_int) void;
    pub const convertWidgetToTreeCoords = gtk_tree_view_convert_widget_to_tree_coords;

    /// Creates a `cairo.Surface` representation of the row at `path`.
    /// This image is used for a drag icon.
    extern fn gtk_tree_view_create_row_drag_icon(p_tree_view: *TreeView, p_path: *gtk.TreePath) *cairo.Surface;
    pub const createRowDragIcon = gtk_tree_view_create_row_drag_icon;

    /// Turns `tree_view` into a drop destination for automatic DND. Calling
    /// this method sets `gtk.TreeView.properties.reorderable` to `FALSE`.
    extern fn gtk_tree_view_enable_model_drag_dest(p_tree_view: *TreeView, p_targets: [*]const gtk.TargetEntry, p_n_targets: c_int, p_actions: gdk.DragAction) void;
    pub const enableModelDragDest = gtk_tree_view_enable_model_drag_dest;

    /// Turns `tree_view` into a drag source for automatic DND. Calling this
    /// method sets `gtk.TreeView.properties.reorderable` to `FALSE`.
    extern fn gtk_tree_view_enable_model_drag_source(p_tree_view: *TreeView, p_start_button_mask: gdk.ModifierType, p_targets: [*]const gtk.TargetEntry, p_n_targets: c_int, p_actions: gdk.DragAction) void;
    pub const enableModelDragSource = gtk_tree_view_enable_model_drag_source;

    /// Recursively expands all nodes in the `tree_view`.
    extern fn gtk_tree_view_expand_all(p_tree_view: *TreeView) void;
    pub const expandAll = gtk_tree_view_expand_all;

    /// Opens the row so its children are visible.
    extern fn gtk_tree_view_expand_row(p_tree_view: *TreeView, p_path: *gtk.TreePath, p_open_all: c_int) c_int;
    pub const expandRow = gtk_tree_view_expand_row;

    /// Expands the row at `path`. This will also expand all parent rows of
    /// `path` as necessary.
    extern fn gtk_tree_view_expand_to_path(p_tree_view: *TreeView, p_path: *gtk.TreePath) void;
    pub const expandToPath = gtk_tree_view_expand_to_path;

    /// Gets the setting set by `gtk.TreeView.setActivateOnSingleClick`.
    extern fn gtk_tree_view_get_activate_on_single_click(p_tree_view: *TreeView) c_int;
    pub const getActivateOnSingleClick = gtk_tree_view_get_activate_on_single_click;

    /// Fills the bounding rectangle in bin_window coordinates for the cell at the
    /// row specified by `path` and the column specified by `column`.  If `path` is
    /// `NULL`, or points to a node not found in the tree, the `y` and `height` fields of
    /// the rectangle will be filled with 0. If `column` is `NULL`, the `x` and `width`
    /// fields will be filled with 0.  The returned rectangle is equivalent to the
    /// `background_area` passed to `gtk.CellRenderer.render`.  These background
    /// areas tile to cover the entire bin window.  Contrast with the `cell_area`,
    /// returned by `gtk.TreeView.getCellArea`, which returns only the cell
    /// itself, excluding surrounding borders and the tree expander area.
    extern fn gtk_tree_view_get_background_area(p_tree_view: *TreeView, p_path: ?*gtk.TreePath, p_column: ?*gtk.TreeViewColumn, p_rect: *gdk.Rectangle) void;
    pub const getBackgroundArea = gtk_tree_view_get_background_area;

    /// Returns the window that `tree_view` renders to.
    /// This is used primarily to compare to `event->window`
    /// to confirm that the event on `tree_view` is on the right window.
    extern fn gtk_tree_view_get_bin_window(p_tree_view: *TreeView) ?*gdk.Window;
    pub const getBinWindow = gtk_tree_view_get_bin_window;

    /// Fills the bounding rectangle in bin_window coordinates for the cell at the
    /// row specified by `path` and the column specified by `column`.  If `path` is
    /// `NULL`, or points to a path not currently displayed, the `y` and `height` fields
    /// of the rectangle will be filled with 0. If `column` is `NULL`, the `x` and `width`
    /// fields will be filled with 0.  The sum of all cell rects does not cover the
    /// entire tree; there are extra pixels in between rows, for example. The
    /// returned rectangle is equivalent to the `cell_area` passed to
    /// `gtk.CellRenderer.render`.  This function is only valid if `tree_view` is
    /// realized.
    extern fn gtk_tree_view_get_cell_area(p_tree_view: *TreeView, p_path: ?*gtk.TreePath, p_column: ?*gtk.TreeViewColumn, p_rect: *gdk.Rectangle) void;
    pub const getCellArea = gtk_tree_view_get_cell_area;

    /// Gets the `gtk.TreeViewColumn` at the given position in the `tree_view`.
    extern fn gtk_tree_view_get_column(p_tree_view: *TreeView, p_n: c_int) ?*gtk.TreeViewColumn;
    pub const getColumn = gtk_tree_view_get_column;

    /// Returns a `glib.List` of all the `gtk.TreeViewColumn` s currently in `tree_view`.
    /// The returned list must be freed with g_list_free ().
    extern fn gtk_tree_view_get_columns(p_tree_view: *TreeView) *glib.List;
    pub const getColumns = gtk_tree_view_get_columns;

    /// Fills in `path` and `focus_column` with the current path and focus column.  If
    /// the cursor isn’t currently set, then *`path` will be `NULL`.  If no column
    /// currently has focus, then *`focus_column` will be `NULL`.
    ///
    /// The returned `gtk.TreePath` must be freed with `gtk.TreePath.free` when
    /// you are done with it.
    extern fn gtk_tree_view_get_cursor(p_tree_view: *TreeView, p_path: ?**gtk.TreePath, p_focus_column: ?**gtk.TreeViewColumn) void;
    pub const getCursor = gtk_tree_view_get_cursor;

    /// Determines the destination row for a given position.  `drag_x` and
    /// `drag_y` are expected to be in widget coordinates.  This function is only
    /// meaningful if `tree_view` is realized.  Therefore this function will always
    /// return `FALSE` if `tree_view` is not realized or does not have a model.
    extern fn gtk_tree_view_get_dest_row_at_pos(p_tree_view: *TreeView, p_drag_x: c_int, p_drag_y: c_int, p_path: ?**gtk.TreePath, p_pos: ?*gtk.TreeViewDropPosition) c_int;
    pub const getDestRowAtPos = gtk_tree_view_get_dest_row_at_pos;

    /// Gets information about the row that is highlighted for feedback.
    extern fn gtk_tree_view_get_drag_dest_row(p_tree_view: *TreeView, p_path: ?**gtk.TreePath, p_pos: ?*gtk.TreeViewDropPosition) void;
    pub const getDragDestRow = gtk_tree_view_get_drag_dest_row;

    /// Returns whether or not the tree allows to start interactive searching
    /// by typing in text.
    extern fn gtk_tree_view_get_enable_search(p_tree_view: *TreeView) c_int;
    pub const getEnableSearch = gtk_tree_view_get_enable_search;

    /// Returns whether or not tree lines are drawn in `tree_view`.
    extern fn gtk_tree_view_get_enable_tree_lines(p_tree_view: *TreeView) c_int;
    pub const getEnableTreeLines = gtk_tree_view_get_enable_tree_lines;

    /// Returns the column that is the current expander column.
    /// This column has the expander arrow drawn next to it.
    extern fn gtk_tree_view_get_expander_column(p_tree_view: *TreeView) *gtk.TreeViewColumn;
    pub const getExpanderColumn = gtk_tree_view_get_expander_column;

    /// Returns whether fixed height mode is turned on for `tree_view`.
    extern fn gtk_tree_view_get_fixed_height_mode(p_tree_view: *TreeView) c_int;
    pub const getFixedHeightMode = gtk_tree_view_get_fixed_height_mode;

    /// Returns which grid lines are enabled in `tree_view`.
    extern fn gtk_tree_view_get_grid_lines(p_tree_view: *TreeView) gtk.TreeViewGridLines;
    pub const getGridLines = gtk_tree_view_get_grid_lines;

    /// Gets the `gtk.Adjustment` currently being used for the horizontal aspect.
    extern fn gtk_tree_view_get_hadjustment(p_tree_view: *TreeView) *gtk.Adjustment;
    pub const getHadjustment = gtk_tree_view_get_hadjustment;

    /// Returns whether all header columns are clickable.
    extern fn gtk_tree_view_get_headers_clickable(p_tree_view: *TreeView) c_int;
    pub const getHeadersClickable = gtk_tree_view_get_headers_clickable;

    /// Returns `TRUE` if the headers on the `tree_view` are visible.
    extern fn gtk_tree_view_get_headers_visible(p_tree_view: *TreeView) c_int;
    pub const getHeadersVisible = gtk_tree_view_get_headers_visible;

    /// Returns whether hover expansion mode is turned on for `tree_view`.
    extern fn gtk_tree_view_get_hover_expand(p_tree_view: *TreeView) c_int;
    pub const getHoverExpand = gtk_tree_view_get_hover_expand;

    /// Returns whether hover selection mode is turned on for `tree_view`.
    extern fn gtk_tree_view_get_hover_selection(p_tree_view: *TreeView) c_int;
    pub const getHoverSelection = gtk_tree_view_get_hover_selection;

    /// Returns the amount, in pixels, of extra indentation for child levels
    /// in `tree_view`.
    extern fn gtk_tree_view_get_level_indentation(p_tree_view: *TreeView) c_int;
    pub const getLevelIndentation = gtk_tree_view_get_level_indentation;

    /// Returns the model the `gtk.TreeView` is based on.  Returns `NULL` if the
    /// model is unset.
    extern fn gtk_tree_view_get_model(p_tree_view: *TreeView) ?*gtk.TreeModel;
    pub const getModel = gtk_tree_view_get_model;

    /// Queries the number of columns in the given `tree_view`.
    extern fn gtk_tree_view_get_n_columns(p_tree_view: *TreeView) c_uint;
    pub const getNColumns = gtk_tree_view_get_n_columns;

    /// Finds the path at the point (`x`, `y`), relative to bin_window coordinates
    /// (please see `gtk.TreeView.getBinWindow`).
    /// That is, `x` and `y` are relative to an events coordinates. `x` and `y` must
    /// come from an event on the `tree_view` only where `event->window ==
    /// gtk_tree_view_get_bin_window ()`. It is primarily for
    /// things like popup menus. If `path` is non-`NULL`, then it will be filled
    /// with the `gtk.TreePath` at that point.  This path should be freed with
    /// `gtk.TreePath.free`.  If `column` is non-`NULL`, then it will be filled
    /// with the column at that point.  `cell_x` and `cell_y` return the coordinates
    /// relative to the cell background (i.e. the `background_area` passed to
    /// `gtk.CellRenderer.render`).  This function is only meaningful if
    /// `tree_view` is realized.  Therefore this function will always return `FALSE`
    /// if `tree_view` is not realized or does not have a model.
    ///
    /// For converting widget coordinates (eg. the ones you get from
    /// GtkWidget::query-tooltip), please see
    /// `gtk.TreeView.convertWidgetToBinWindowCoords`.
    extern fn gtk_tree_view_get_path_at_pos(p_tree_view: *TreeView, p_x: c_int, p_y: c_int, p_path: ?**gtk.TreePath, p_column: ?**gtk.TreeViewColumn, p_cell_x: ?*c_int, p_cell_y: ?*c_int) c_int;
    pub const getPathAtPos = gtk_tree_view_get_path_at_pos;

    /// Retrieves whether the user can reorder the tree via drag-and-drop. See
    /// `gtk.TreeView.setReorderable`.
    extern fn gtk_tree_view_get_reorderable(p_tree_view: *TreeView) c_int;
    pub const getReorderable = gtk_tree_view_get_reorderable;

    /// Returns the current row separator function.
    extern fn gtk_tree_view_get_row_separator_func(p_tree_view: *TreeView) gtk.TreeViewRowSeparatorFunc;
    pub const getRowSeparatorFunc = gtk_tree_view_get_row_separator_func;

    /// Returns whether rubber banding is turned on for `tree_view`.  If the
    /// selection mode is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the
    /// user to select multiple rows by dragging the mouse.
    extern fn gtk_tree_view_get_rubber_banding(p_tree_view: *TreeView) c_int;
    pub const getRubberBanding = gtk_tree_view_get_rubber_banding;

    /// Gets the setting set by `gtk.TreeView.setRulesHint`.
    extern fn gtk_tree_view_get_rules_hint(p_tree_view: *TreeView) c_int;
    pub const getRulesHint = gtk_tree_view_get_rules_hint;

    /// Gets the column searched on by the interactive search code.
    extern fn gtk_tree_view_get_search_column(p_tree_view: *TreeView) c_int;
    pub const getSearchColumn = gtk_tree_view_get_search_column;

    /// Returns the `gtk.Entry` which is currently in use as interactive search
    /// entry for `tree_view`.  In case the built-in entry is being used, `NULL`
    /// will be returned.
    extern fn gtk_tree_view_get_search_entry(p_tree_view: *TreeView) *gtk.Entry;
    pub const getSearchEntry = gtk_tree_view_get_search_entry;

    /// Returns the compare function currently in use.
    extern fn gtk_tree_view_get_search_equal_func(p_tree_view: *TreeView) gtk.TreeViewSearchEqualFunc;
    pub const getSearchEqualFunc = gtk_tree_view_get_search_equal_func;

    /// Returns the positioning function currently in use.
    extern fn gtk_tree_view_get_search_position_func(p_tree_view: *TreeView) gtk.TreeViewSearchPositionFunc;
    pub const getSearchPositionFunc = gtk_tree_view_get_search_position_func;

    /// Gets the `gtk.TreeSelection` associated with `tree_view`.
    extern fn gtk_tree_view_get_selection(p_tree_view: *TreeView) *gtk.TreeSelection;
    pub const getSelection = gtk_tree_view_get_selection;

    /// Returns whether or not expanders are drawn in `tree_view`.
    extern fn gtk_tree_view_get_show_expanders(p_tree_view: *TreeView) c_int;
    pub const getShowExpanders = gtk_tree_view_get_show_expanders;

    /// Returns the column of `tree_view`’s model which is being used for
    /// displaying tooltips on `tree_view`’s rows.
    extern fn gtk_tree_view_get_tooltip_column(p_tree_view: *TreeView) c_int;
    pub const getTooltipColumn = gtk_tree_view_get_tooltip_column;

    /// This function is supposed to be used in a `gtk.Widget.signals.query`-tooltip
    /// signal handler for `gtk.TreeView`.  The `x`, `y` and `keyboard_tip` values
    /// which are received in the signal handler, should be passed to this
    /// function without modification.
    ///
    /// The return value indicates whether there is a tree view row at the given
    /// coordinates (`TRUE`) or not (`FALSE`) for mouse tooltips.  For keyboard
    /// tooltips the row returned will be the cursor row.  When `TRUE`, then any of
    /// `model`, `path` and `iter` which have been provided will be set to point to
    /// that row and the corresponding model.  `x` and `y` will always be converted
    /// to be relative to `tree_view`’s bin_window if `keyboard_tooltip` is `FALSE`.
    extern fn gtk_tree_view_get_tooltip_context(p_tree_view: *TreeView, p_x: *c_int, p_y: *c_int, p_keyboard_tip: c_int, p_model: ?**gtk.TreeModel, p_path: ?**gtk.TreePath, p_iter: ?*gtk.TreeIter) c_int;
    pub const getTooltipContext = gtk_tree_view_get_tooltip_context;

    /// Gets the `gtk.Adjustment` currently being used for the vertical aspect.
    extern fn gtk_tree_view_get_vadjustment(p_tree_view: *TreeView) *gtk.Adjustment;
    pub const getVadjustment = gtk_tree_view_get_vadjustment;

    /// Sets `start_path` and `end_path` to be the first and last visible path.
    /// Note that there may be invisible paths in between.
    ///
    /// The paths should be freed with `gtk.TreePath.free` after use.
    extern fn gtk_tree_view_get_visible_range(p_tree_view: *TreeView, p_start_path: ?**gtk.TreePath, p_end_path: ?**gtk.TreePath) c_int;
    pub const getVisibleRange = gtk_tree_view_get_visible_range;

    /// Fills `visible_rect` with the currently-visible region of the
    /// buffer, in tree coordinates. Convert to bin_window coordinates with
    /// `gtk.TreeView.convertTreeToBinWindowCoords`.
    /// Tree coordinates start at 0,0 for row 0 of the tree, and cover the entire
    /// scrollable area of the tree.
    extern fn gtk_tree_view_get_visible_rect(p_tree_view: *TreeView, p_visible_rect: *gdk.Rectangle) void;
    pub const getVisibleRect = gtk_tree_view_get_visible_rect;

    /// This inserts the `column` into the `tree_view` at `position`.  If `position` is
    /// -1, then the column is inserted at the end. If `tree_view` has
    /// “fixed_height” mode enabled, then `column` must have its “sizing” property
    /// set to be GTK_TREE_VIEW_COLUMN_FIXED.
    extern fn gtk_tree_view_insert_column(p_tree_view: *TreeView, p_column: *gtk.TreeViewColumn, p_position: c_int) c_int;
    pub const insertColumn = gtk_tree_view_insert_column;

    /// Creates a new `gtk.TreeViewColumn` and inserts it into the `tree_view` at
    /// `position`.  If `position` is -1, then the newly created column is inserted at
    /// the end.  The column is initialized with the attributes given. If `tree_view`
    /// has “fixed_height” mode enabled, then the new column will have its sizing
    /// property set to be GTK_TREE_VIEW_COLUMN_FIXED.
    extern fn gtk_tree_view_insert_column_with_attributes(p_tree_view: *TreeView, p_position: c_int, p_title: [*:0]const u8, p_cell: *gtk.CellRenderer, ...) c_int;
    pub const insertColumnWithAttributes = gtk_tree_view_insert_column_with_attributes;

    /// Convenience function that inserts a new column into the `gtk.TreeView`
    /// with the given cell renderer and a `gtk.TreeCellDataFunc` to set cell renderer
    /// attributes (normally using data from the model). See also
    /// `gtk.TreeViewColumn.setCellDataFunc`, `gtk.TreeViewColumn.packStart`.
    /// If `tree_view` has “fixed_height” mode enabled, then the new column will have its
    /// “sizing” property set to be GTK_TREE_VIEW_COLUMN_FIXED.
    extern fn gtk_tree_view_insert_column_with_data_func(p_tree_view: *TreeView, p_position: c_int, p_title: [*:0]const u8, p_cell: *gtk.CellRenderer, p_func: gtk.TreeCellDataFunc, p_data: ?*anyopaque, p_dnotify: ?glib.DestroyNotify) c_int;
    pub const insertColumnWithDataFunc = gtk_tree_view_insert_column_with_data_func;

    /// Determine whether the point (`x`, `y`) in `tree_view` is blank, that is no
    /// cell content nor an expander arrow is drawn at the location. If so, the
    /// location can be considered as the background. You might wish to take
    /// special action on clicks on the background, such as clearing a current
    /// selection, having a custom context menu or starting rubber banding.
    ///
    /// The `x` and `y` coordinate that are provided must be relative to bin_window
    /// coordinates.  That is, `x` and `y` must come from an event on `tree_view`
    /// where `event->window == gtk_tree_view_get_bin_window ()`.
    ///
    /// For converting widget coordinates (eg. the ones you get from
    /// GtkWidget::query-tooltip), please see
    /// `gtk.TreeView.convertWidgetToBinWindowCoords`.
    ///
    /// The `path`, `column`, `cell_x` and `cell_y` arguments will be filled in
    /// likewise as for `gtk.TreeView.getPathAtPos`.  Please see
    /// `gtk.TreeView.getPathAtPos` for more information.
    extern fn gtk_tree_view_is_blank_at_pos(p_tree_view: *TreeView, p_x: c_int, p_y: c_int, p_path: ?**gtk.TreePath, p_column: ?**gtk.TreeViewColumn, p_cell_x: ?*c_int, p_cell_y: ?*c_int) c_int;
    pub const isBlankAtPos = gtk_tree_view_is_blank_at_pos;

    /// Returns whether a rubber banding operation is currently being done
    /// in `tree_view`.
    extern fn gtk_tree_view_is_rubber_banding_active(p_tree_view: *TreeView) c_int;
    pub const isRubberBandingActive = gtk_tree_view_is_rubber_banding_active;

    /// Calls `func` on all expanded rows.
    extern fn gtk_tree_view_map_expanded_rows(p_tree_view: *TreeView, p_func: gtk.TreeViewMappingFunc, p_data: ?*anyopaque) void;
    pub const mapExpandedRows = gtk_tree_view_map_expanded_rows;

    /// Moves `column` to be after to `base_column`.  If `base_column` is `NULL`, then
    /// `column` is placed in the first position.
    extern fn gtk_tree_view_move_column_after(p_tree_view: *TreeView, p_column: *gtk.TreeViewColumn, p_base_column: ?*gtk.TreeViewColumn) void;
    pub const moveColumnAfter = gtk_tree_view_move_column_after;

    /// Removes `column` from `tree_view`.
    extern fn gtk_tree_view_remove_column(p_tree_view: *TreeView, p_column: *gtk.TreeViewColumn) c_int;
    pub const removeColumn = gtk_tree_view_remove_column;

    /// Activates the cell determined by `path` and `column`.
    extern fn gtk_tree_view_row_activated(p_tree_view: *TreeView, p_path: *gtk.TreePath, p_column: *gtk.TreeViewColumn) void;
    pub const rowActivated = gtk_tree_view_row_activated;

    /// Returns `TRUE` if the node pointed to by `path` is expanded in `tree_view`.
    extern fn gtk_tree_view_row_expanded(p_tree_view: *TreeView, p_path: *gtk.TreePath) c_int;
    pub const rowExpanded = gtk_tree_view_row_expanded;

    /// Moves the alignments of `tree_view` to the position specified by `column` and
    /// `path`.  If `column` is `NULL`, then no horizontal scrolling occurs.  Likewise,
    /// if `path` is `NULL` no vertical scrolling occurs.  At a minimum, one of `column`
    /// or `path` need to be non-`NULL`.  `row_align` determines where the row is
    /// placed, and `col_align` determines where `column` is placed.  Both are expected
    /// to be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means
    /// right/bottom alignment, 0.5 means center.
    ///
    /// If `use_align` is `FALSE`, then the alignment arguments are ignored, and the
    /// tree does the minimum amount of work to scroll the cell onto the screen.
    /// This means that the cell will be scrolled to the edge closest to its current
    /// position.  If the cell is currently visible on the screen, nothing is done.
    ///
    /// This function only works if the model is set, and `path` is a valid row on the
    /// model.  If the model changes before the `tree_view` is realized, the centered
    /// path will be modified to reflect this change.
    extern fn gtk_tree_view_scroll_to_cell(p_tree_view: *TreeView, p_path: ?*gtk.TreePath, p_column: ?*gtk.TreeViewColumn, p_use_align: c_int, p_row_align: f32, p_col_align: f32) void;
    pub const scrollToCell = gtk_tree_view_scroll_to_cell;

    /// Scrolls the tree view such that the top-left corner of the visible
    /// area is `tree_x`, `tree_y`, where `tree_x` and `tree_y` are specified
    /// in tree coordinates.  The `tree_view` must be realized before
    /// this function is called.  If it isn't, you probably want to be
    /// using `gtk.TreeView.scrollToCell`.
    ///
    /// If either `tree_x` or `tree_y` are -1, then that direction isn’t scrolled.
    extern fn gtk_tree_view_scroll_to_point(p_tree_view: *TreeView, p_tree_x: c_int, p_tree_y: c_int) void;
    pub const scrollToPoint = gtk_tree_view_scroll_to_point;

    /// Cause the `gtk.TreeView.signals.row`-activated signal to be emitted
    /// on a single click instead of a double click.
    extern fn gtk_tree_view_set_activate_on_single_click(p_tree_view: *TreeView, p_single: c_int) void;
    pub const setActivateOnSingleClick = gtk_tree_view_set_activate_on_single_click;

    /// Sets a user function for determining where a column may be dropped when
    /// dragged.  This function is called on every column pair in turn at the
    /// beginning of a column drag to determine where a drop can take place.  The
    /// arguments passed to `func` are: the `tree_view`, the `gtk.TreeViewColumn` being
    /// dragged, the two `gtk.TreeViewColumn` s determining the drop spot, and
    /// `user_data`.  If either of the `gtk.TreeViewColumn` arguments for the drop spot
    /// are `NULL`, then they indicate an edge.  If `func` is set to be `NULL`, then
    /// `tree_view` reverts to the default behavior of allowing all columns to be
    /// dropped everywhere.
    extern fn gtk_tree_view_set_column_drag_function(p_tree_view: *TreeView, p_func: ?gtk.TreeViewColumnDropFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setColumnDragFunction = gtk_tree_view_set_column_drag_function;

    /// Sets the current keyboard focus to be at `path`, and selects it.  This is
    /// useful when you want to focus the user’s attention on a particular row.  If
    /// `focus_column` is not `NULL`, then focus is given to the column specified by
    /// it. Additionally, if `focus_column` is specified, and `start_editing` is
    /// `TRUE`, then editing should be started in the specified cell.
    /// This function is often followed by `gtk_widget_grab_focus` (`tree_view`)
    /// in order to give keyboard focus to the widget.  Please note that editing
    /// can only happen when the widget is realized.
    ///
    /// If `path` is invalid for `model`, the current cursor (if any) will be unset
    /// and the function will return without failing.
    extern fn gtk_tree_view_set_cursor(p_tree_view: *TreeView, p_path: *gtk.TreePath, p_focus_column: ?*gtk.TreeViewColumn, p_start_editing: c_int) void;
    pub const setCursor = gtk_tree_view_set_cursor;

    /// Sets the current keyboard focus to be at `path`, and selects it.  This is
    /// useful when you want to focus the user’s attention on a particular row.  If
    /// `focus_column` is not `NULL`, then focus is given to the column specified by
    /// it. If `focus_column` and `focus_cell` are not `NULL`, and `focus_column`
    /// contains 2 or more editable or activatable cells, then focus is given to
    /// the cell specified by `focus_cell`. Additionally, if `focus_column` is
    /// specified, and `start_editing` is `TRUE`, then editing should be started in
    /// the specified cell.  This function is often followed by
    /// `gtk_widget_grab_focus` (`tree_view`) in order to give keyboard focus to the
    /// widget.  Please note that editing can only happen when the widget is
    /// realized.
    ///
    /// If `path` is invalid for `model`, the current cursor (if any) will be unset
    /// and the function will return without failing.
    extern fn gtk_tree_view_set_cursor_on_cell(p_tree_view: *TreeView, p_path: *gtk.TreePath, p_focus_column: ?*gtk.TreeViewColumn, p_focus_cell: ?*gtk.CellRenderer, p_start_editing: c_int) void;
    pub const setCursorOnCell = gtk_tree_view_set_cursor_on_cell;

    /// This function should almost never be used.  It is meant for private use by
    /// ATK for determining the number of visible children that are removed when the
    /// user collapses a row, or a row is deleted.
    extern fn gtk_tree_view_set_destroy_count_func(p_tree_view: *TreeView, p_func: ?gtk.TreeDestroyCountFunc, p_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setDestroyCountFunc = gtk_tree_view_set_destroy_count_func;

    /// Sets the row that is highlighted for feedback.
    /// If `path` is `NULL`, an existing highlight is removed.
    extern fn gtk_tree_view_set_drag_dest_row(p_tree_view: *TreeView, p_path: ?*gtk.TreePath, p_pos: gtk.TreeViewDropPosition) void;
    pub const setDragDestRow = gtk_tree_view_set_drag_dest_row;

    /// If `enable_search` is set, then the user can type in text to search through
    /// the tree interactively (this is sometimes called "typeahead find").
    ///
    /// Note that even if this is `FALSE`, the user can still initiate a search
    /// using the “start-interactive-search” key binding.
    extern fn gtk_tree_view_set_enable_search(p_tree_view: *TreeView, p_enable_search: c_int) void;
    pub const setEnableSearch = gtk_tree_view_set_enable_search;

    /// Sets whether to draw lines interconnecting the expanders in `tree_view`.
    /// This does not have any visible effects for lists.
    extern fn gtk_tree_view_set_enable_tree_lines(p_tree_view: *TreeView, p_enabled: c_int) void;
    pub const setEnableTreeLines = gtk_tree_view_set_enable_tree_lines;

    /// Sets the column to draw the expander arrow at. It must be in `tree_view`.
    /// If `column` is `NULL`, then the expander arrow is always at the first
    /// visible column.
    ///
    /// If you do not want expander arrow to appear in your tree, set the
    /// expander column to a hidden column.
    extern fn gtk_tree_view_set_expander_column(p_tree_view: *TreeView, p_column: ?*gtk.TreeViewColumn) void;
    pub const setExpanderColumn = gtk_tree_view_set_expander_column;

    /// Enables or disables the fixed height mode of `tree_view`.
    /// Fixed height mode speeds up `gtk.TreeView` by assuming that all
    /// rows have the same height.
    /// Only enable this option if all rows are the same height and all
    /// columns are of type `GTK_TREE_VIEW_COLUMN_FIXED`.
    extern fn gtk_tree_view_set_fixed_height_mode(p_tree_view: *TreeView, p_enable: c_int) void;
    pub const setFixedHeightMode = gtk_tree_view_set_fixed_height_mode;

    /// Sets which grid lines to draw in `tree_view`.
    extern fn gtk_tree_view_set_grid_lines(p_tree_view: *TreeView, p_grid_lines: gtk.TreeViewGridLines) void;
    pub const setGridLines = gtk_tree_view_set_grid_lines;

    /// Sets the `gtk.Adjustment` for the current horizontal aspect.
    extern fn gtk_tree_view_set_hadjustment(p_tree_view: *TreeView, p_adjustment: ?*gtk.Adjustment) void;
    pub const setHadjustment = gtk_tree_view_set_hadjustment;

    /// Allow the column title buttons to be clicked.
    extern fn gtk_tree_view_set_headers_clickable(p_tree_view: *TreeView, p_setting: c_int) void;
    pub const setHeadersClickable = gtk_tree_view_set_headers_clickable;

    /// Sets the visibility state of the headers.
    extern fn gtk_tree_view_set_headers_visible(p_tree_view: *TreeView, p_headers_visible: c_int) void;
    pub const setHeadersVisible = gtk_tree_view_set_headers_visible;

    /// Enables or disables the hover expansion mode of `tree_view`.
    /// Hover expansion makes rows expand or collapse if the pointer
    /// moves over them.
    extern fn gtk_tree_view_set_hover_expand(p_tree_view: *TreeView, p_expand: c_int) void;
    pub const setHoverExpand = gtk_tree_view_set_hover_expand;

    /// Enables or disables the hover selection mode of `tree_view`.
    /// Hover selection makes the selected row follow the pointer.
    /// Currently, this works only for the selection modes
    /// `GTK_SELECTION_SINGLE` and `GTK_SELECTION_BROWSE`.
    extern fn gtk_tree_view_set_hover_selection(p_tree_view: *TreeView, p_hover: c_int) void;
    pub const setHoverSelection = gtk_tree_view_set_hover_selection;

    /// Sets the amount of extra indentation for child levels to use in `tree_view`
    /// in addition to the default indentation.  The value should be specified in
    /// pixels, a value of 0 disables this feature and in this case only the default
    /// indentation will be used.
    /// This does not have any visible effects for lists.
    extern fn gtk_tree_view_set_level_indentation(p_tree_view: *TreeView, p_indentation: c_int) void;
    pub const setLevelIndentation = gtk_tree_view_set_level_indentation;

    /// Sets the model for a `gtk.TreeView`.  If the `tree_view` already has a model
    /// set, it will remove it before setting the new model.  If `model` is `NULL`,
    /// then it will unset the old model.
    extern fn gtk_tree_view_set_model(p_tree_view: *TreeView, p_model: ?*gtk.TreeModel) void;
    pub const setModel = gtk_tree_view_set_model;

    /// This function is a convenience function to allow you to reorder
    /// models that support the `gtk.TreeDragSourceIface` and the
    /// `gtk.TreeDragDestIface`.  Both `gtk.TreeStore` and `gtk.ListStore` support
    /// these.  If `reorderable` is `TRUE`, then the user can reorder the
    /// model by dragging and dropping rows. The developer can listen to
    /// these changes by connecting to the model’s `gtk.TreeModel.signals.row`-inserted
    /// and `gtk.TreeModel.signals.row`-deleted signals. The reordering is implemented
    /// by setting up the tree view as a drag source and destination.
    /// Therefore, drag and drop can not be used in a reorderable view for any
    /// other purpose.
    ///
    /// This function does not give you any degree of control over the order -- any
    /// reordering is allowed.  If more control is needed, you should probably
    /// handle drag and drop manually.
    extern fn gtk_tree_view_set_reorderable(p_tree_view: *TreeView, p_reorderable: c_int) void;
    pub const setReorderable = gtk_tree_view_set_reorderable;

    /// Sets the row separator function, which is used to determine
    /// whether a row should be drawn as a separator. If the row separator
    /// function is `NULL`, no separators are drawn. This is the default value.
    extern fn gtk_tree_view_set_row_separator_func(p_tree_view: *TreeView, p_func: ?gtk.TreeViewRowSeparatorFunc, p_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setRowSeparatorFunc = gtk_tree_view_set_row_separator_func;

    /// Enables or disables rubber banding in `tree_view`.  If the selection mode
    /// is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the user to select
    /// multiple rows by dragging the mouse.
    extern fn gtk_tree_view_set_rubber_banding(p_tree_view: *TreeView, p_enable: c_int) void;
    pub const setRubberBanding = gtk_tree_view_set_rubber_banding;

    /// Sets a hint for the theme to draw even/odd rows in the `tree_view`
    /// with different colors, also known as "zebra striping".
    ///
    /// This function tells the GTK+ theme that the user interface for your
    /// application requires users to read across tree rows and associate
    /// cells with one another.
    ///
    /// Do not use it just because you prefer the appearance of the ruled
    /// tree; that’s a question for the theme. Some themes will draw tree
    /// rows in alternating colors even when rules are turned off, and
    /// users who prefer that appearance all the time can choose those
    /// themes. You should call this function only as a semantic hint to
    /// the theme engine that your tree makes alternating colors useful
    /// from a functional standpoint (since it has lots of columns,
    /// generally).
    extern fn gtk_tree_view_set_rules_hint(p_tree_view: *TreeView, p_setting: c_int) void;
    pub const setRulesHint = gtk_tree_view_set_rules_hint;

    /// Sets `column` as the column where the interactive search code should
    /// search in for the current model.
    ///
    /// If the search column is set, users can use the “start-interactive-search”
    /// key binding to bring up search popup. The enable-search property controls
    /// whether simply typing text will also start an interactive search.
    ///
    /// Note that `column` refers to a column of the current model. The search
    /// column is reset to -1 when the model is changed.
    extern fn gtk_tree_view_set_search_column(p_tree_view: *TreeView, p_column: c_int) void;
    pub const setSearchColumn = gtk_tree_view_set_search_column;

    /// Sets the entry which the interactive search code will use for this
    /// `tree_view`.  This is useful when you want to provide a search entry
    /// in our interface at all time at a fixed position.  Passing `NULL` for
    /// `entry` will make the interactive search code use the built-in popup
    /// entry again.
    extern fn gtk_tree_view_set_search_entry(p_tree_view: *TreeView, p_entry: ?*gtk.Entry) void;
    pub const setSearchEntry = gtk_tree_view_set_search_entry;

    /// Sets the compare function for the interactive search capabilities; note
    /// that somewhat like `strcmp` returning 0 for equality
    /// `gtk.TreeViewSearchEqualFunc` returns `FALSE` on matches.
    extern fn gtk_tree_view_set_search_equal_func(p_tree_view: *TreeView, p_search_equal_func: gtk.TreeViewSearchEqualFunc, p_search_user_data: ?*anyopaque, p_search_destroy: ?glib.DestroyNotify) void;
    pub const setSearchEqualFunc = gtk_tree_view_set_search_equal_func;

    /// Sets the function to use when positioning the search dialog.
    extern fn gtk_tree_view_set_search_position_func(p_tree_view: *TreeView, p_func: ?gtk.TreeViewSearchPositionFunc, p_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setSearchPositionFunc = gtk_tree_view_set_search_position_func;

    /// Sets whether to draw and enable expanders and indent child rows in
    /// `tree_view`.  When disabled there will be no expanders visible in trees
    /// and there will be no way to expand and collapse rows by default.  Also
    /// note that hiding the expanders will disable the default indentation.  You
    /// can set a custom indentation in this case using
    /// `gtk.TreeView.setLevelIndentation`.
    /// This does not have any visible effects for lists.
    extern fn gtk_tree_view_set_show_expanders(p_tree_view: *TreeView, p_enabled: c_int) void;
    pub const setShowExpanders = gtk_tree_view_set_show_expanders;

    /// Sets the tip area of `tooltip` to the area `path`, `column` and `cell` have
    /// in common.  For example if `path` is `NULL` and `column` is set, the tip
    /// area will be set to the full area covered by `column`.  See also
    /// `gtk.Tooltip.setTipArea`.
    ///
    /// Note that if `path` is not specified and `cell` is set and part of a column
    /// containing the expander, the tooltip might not show and hide at the correct
    /// position.  In such cases `path` must be set to the current node under the
    /// mouse cursor for this function to operate correctly.
    ///
    /// See also `gtk.TreeView.setTooltipColumn` for a simpler alternative.
    extern fn gtk_tree_view_set_tooltip_cell(p_tree_view: *TreeView, p_tooltip: *gtk.Tooltip, p_path: ?*gtk.TreePath, p_column: ?*gtk.TreeViewColumn, p_cell: ?*gtk.CellRenderer) void;
    pub const setTooltipCell = gtk_tree_view_set_tooltip_cell;

    /// If you only plan to have simple (text-only) tooltips on full rows, you
    /// can use this function to have `gtk.TreeView` handle these automatically
    /// for you. `column` should be set to the column in `tree_view`’s model
    /// containing the tooltip texts, or -1 to disable this feature.
    ///
    /// When enabled, `gtk.Widget.properties.has`-tooltip will be set to `TRUE` and
    /// `tree_view` will connect a `gtk.Widget.signals.query`-tooltip signal handler.
    ///
    /// Note that the signal handler sets the text with `gtk.Tooltip.setMarkup`,
    /// so &, <, etc have to be escaped in the text.
    extern fn gtk_tree_view_set_tooltip_column(p_tree_view: *TreeView, p_column: c_int) void;
    pub const setTooltipColumn = gtk_tree_view_set_tooltip_column;

    /// Sets the tip area of `tooltip` to be the area covered by the row at `path`.
    /// See also `gtk.TreeView.setTooltipColumn` for a simpler alternative.
    /// See also `gtk.Tooltip.setTipArea`.
    extern fn gtk_tree_view_set_tooltip_row(p_tree_view: *TreeView, p_tooltip: *gtk.Tooltip, p_path: *gtk.TreePath) void;
    pub const setTooltipRow = gtk_tree_view_set_tooltip_row;

    /// Sets the `gtk.Adjustment` for the current vertical aspect.
    extern fn gtk_tree_view_set_vadjustment(p_tree_view: *TreeView, p_adjustment: ?*gtk.Adjustment) void;
    pub const setVadjustment = gtk_tree_view_set_vadjustment;

    /// Undoes the effect of
    /// `gtk.TreeView.enableModelDragDest`. Calling this method sets
    /// `gtk.TreeView.properties.reorderable` to `FALSE`.
    extern fn gtk_tree_view_unset_rows_drag_dest(p_tree_view: *TreeView) void;
    pub const unsetRowsDragDest = gtk_tree_view_unset_rows_drag_dest;

    /// Undoes the effect of
    /// `gtk.TreeView.enableModelDragSource`. Calling this method sets
    /// `gtk.TreeView.properties.reorderable` to `FALSE`.
    extern fn gtk_tree_view_unset_rows_drag_source(p_tree_view: *TreeView) void;
    pub const unsetRowsDragSource = gtk_tree_view_unset_rows_drag_source;

    extern fn gtk_tree_view_get_type() usize;
    pub const getGObjectType = gtk_tree_view_get_type;

    extern fn g_object_ref(p_self: *gtk.TreeView) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TreeView) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TreeView, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeViewAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Selection, atk.Table, gtk.CellAccessibleParent };
    pub const Class = gtk.TreeViewAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.TreeViewAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_tree_view_accessible_get_type() usize;
    pub const getGObjectType = gtk_tree_view_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.TreeViewAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TreeViewAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TreeViewAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The GtkTreeViewColumn object represents a visible column in a `gtk.TreeView` widget.
/// It allows to set properties of the column header, and functions as a holding pen for
/// the cell renderers which determine how the data in the column is displayed.
///
/// Please refer to the [tree widget conceptual overview](TreeWidget.html)
/// for an overview of all the objects and data types related to the tree widget and how
/// they work together.
pub const TreeViewColumn = extern struct {
    pub const Parent = gobject.InitiallyUnowned;
    pub const Implements = [_]type{ gtk.Buildable, gtk.CellLayout };
    pub const Class = gtk.TreeViewColumnClass;
    f_parent_instance: gobject.InitiallyUnowned,
    f_priv: ?*gtk.TreeViewColumnPrivate,

    pub const virtual_methods = struct {
        /// Emits the “clicked” signal on the column.  This function will only work if
        /// `tree_column` is clickable.
        pub const clicked = struct {
            pub fn call(p_class: anytype, p_tree_column: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TreeViewColumn.Class, p_class).f_clicked.?(gobject.ext.as(TreeViewColumn, p_tree_column));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_column: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TreeViewColumn.Class, p_class).f_clicked = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const alignment = struct {
            pub const name = "alignment";

            pub const Type = f32;
        };

        /// The `gtk.CellArea` used to layout cell renderers for this column.
        ///
        /// If no area is specified when creating the tree view column with `gtk.TreeViewColumn.newWithArea`
        /// a horizontally oriented `gtk.CellAreaBox` will be used.
        pub const cell_area = struct {
            pub const name = "cell-area";

            pub const Type = ?*gtk.CellArea;
        };

        pub const clickable = struct {
            pub const name = "clickable";

            pub const Type = c_int;
        };

        pub const expand = struct {
            pub const name = "expand";

            pub const Type = c_int;
        };

        pub const fixed_width = struct {
            pub const name = "fixed-width";

            pub const Type = c_int;
        };

        pub const max_width = struct {
            pub const name = "max-width";

            pub const Type = c_int;
        };

        pub const min_width = struct {
            pub const name = "min-width";

            pub const Type = c_int;
        };

        pub const reorderable = struct {
            pub const name = "reorderable";

            pub const Type = c_int;
        };

        pub const resizable = struct {
            pub const name = "resizable";

            pub const Type = c_int;
        };

        pub const sizing = struct {
            pub const name = "sizing";

            pub const Type = gtk.TreeViewColumnSizing;
        };

        /// Logical sort column ID this column sorts on when selected for sorting. Setting the sort column ID makes the column header
        /// clickable. Set to -1 to make the column unsortable.
        pub const sort_column_id = struct {
            pub const name = "sort-column-id";

            pub const Type = c_int;
        };

        pub const sort_indicator = struct {
            pub const name = "sort-indicator";

            pub const Type = c_int;
        };

        pub const sort_order = struct {
            pub const name = "sort-order";

            pub const Type = gtk.SortType;
        };

        pub const spacing = struct {
            pub const name = "spacing";

            pub const Type = c_int;
        };

        pub const title = struct {
            pub const name = "title";

            pub const Type = ?[*:0]u8;
        };

        pub const visible = struct {
            pub const name = "visible";

            pub const Type = c_int;
        };

        pub const widget = struct {
            pub const name = "widget";

            pub const Type = ?*gtk.Widget;
        };

        pub const width = struct {
            pub const name = "width";

            pub const Type = c_int;
        };

        pub const x_offset = struct {
            pub const name = "x-offset";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        pub const clicked = struct {
            pub const name = "clicked";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeViewColumn, p_instance))),
                    gobject.signalLookup("clicked", TreeViewColumn.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.TreeViewColumn`.
    extern fn gtk_tree_view_column_new() *gtk.TreeViewColumn;
    pub const new = gtk_tree_view_column_new;

    /// Creates a new `gtk.TreeViewColumn` using `area` to render its cells.
    extern fn gtk_tree_view_column_new_with_area(p_area: *gtk.CellArea) *gtk.TreeViewColumn;
    pub const newWithArea = gtk_tree_view_column_new_with_area;

    /// Creates a new `gtk.TreeViewColumn` with a number of default values.
    /// This is equivalent to calling `gtk.TreeViewColumn.setTitle`,
    /// `gtk.TreeViewColumn.packStart`, and
    /// `gtk.TreeViewColumn.setAttributes` on the newly created `gtk.TreeViewColumn`.
    ///
    /// Here’s a simple example:
    /// ```
    ///  enum { TEXT_COLUMN, COLOR_COLUMN, N_COLUMNS };
    ///  // ...
    ///  {
    ///    GtkTreeViewColumn *column;
    ///    GtkCellRenderer   *renderer = gtk_cell_renderer_text_new ();
    ///
    ///    column = gtk_tree_view_column_new_with_attributes ("Title",
    ///                                                       renderer,
    ///                                                       "text", TEXT_COLUMN,
    ///                                                       "foreground", COLOR_COLUMN,
    ///                                                       NULL);
    ///  }
    /// ```
    extern fn gtk_tree_view_column_new_with_attributes(p_title: [*:0]const u8, p_cell: *gtk.CellRenderer, ...) *gtk.TreeViewColumn;
    pub const newWithAttributes = gtk_tree_view_column_new_with_attributes;

    /// Adds an attribute mapping to the list in `tree_column`.  The `column` is the
    /// column of the model to get a value from, and the `attribute` is the
    /// parameter on `cell_renderer` to be set from the value. So for example
    /// if column 2 of the model contains strings, you could have the
    /// “text” attribute of a `gtk.CellRendererText` get its values from
    /// column 2.
    extern fn gtk_tree_view_column_add_attribute(p_tree_column: *TreeViewColumn, p_cell_renderer: *gtk.CellRenderer, p_attribute: [*:0]const u8, p_column: c_int) void;
    pub const addAttribute = gtk_tree_view_column_add_attribute;

    /// Obtains the horizontal position and size of a cell in a column. If the
    /// cell is not found in the column, `start_pos` and `width` are not changed and
    /// `FALSE` is returned.
    extern fn gtk_tree_view_column_cell_get_position(p_tree_column: *TreeViewColumn, p_cell_renderer: *gtk.CellRenderer, p_x_offset: ?*c_int, p_width: ?*c_int) c_int;
    pub const cellGetPosition = gtk_tree_view_column_cell_get_position;

    /// Obtains the width and height needed to render the column.  This is used
    /// primarily by the `gtk.TreeView`.
    extern fn gtk_tree_view_column_cell_get_size(p_tree_column: *TreeViewColumn, p_cell_area: ?*const gdk.Rectangle, p_x_offset: ?*c_int, p_y_offset: ?*c_int, p_width: ?*c_int, p_height: ?*c_int) void;
    pub const cellGetSize = gtk_tree_view_column_cell_get_size;

    /// Returns `TRUE` if any of the cells packed into the `tree_column` are visible.
    /// For this to be meaningful, you must first initialize the cells with
    /// `gtk.TreeViewColumn.cellSetCellData`
    extern fn gtk_tree_view_column_cell_is_visible(p_tree_column: *TreeViewColumn) c_int;
    pub const cellIsVisible = gtk_tree_view_column_cell_is_visible;

    /// Sets the cell renderer based on the `tree_model` and `iter`.  That is, for
    /// every attribute mapping in `tree_column`, it will get a value from the set
    /// column on the `iter`, and use that value to set the attribute on the cell
    /// renderer.  This is used primarily by the `gtk.TreeView`.
    extern fn gtk_tree_view_column_cell_set_cell_data(p_tree_column: *TreeViewColumn, p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_is_expander: c_int, p_is_expanded: c_int) void;
    pub const cellSetCellData = gtk_tree_view_column_cell_set_cell_data;

    /// Unsets all the mappings on all renderers on the `tree_column`.
    extern fn gtk_tree_view_column_clear(p_tree_column: *TreeViewColumn) void;
    pub const clear = gtk_tree_view_column_clear;

    /// Clears all existing attributes previously set with
    /// `gtk.TreeViewColumn.setAttributes`.
    extern fn gtk_tree_view_column_clear_attributes(p_tree_column: *TreeViewColumn, p_cell_renderer: *gtk.CellRenderer) void;
    pub const clearAttributes = gtk_tree_view_column_clear_attributes;

    /// Emits the “clicked” signal on the column.  This function will only work if
    /// `tree_column` is clickable.
    extern fn gtk_tree_view_column_clicked(p_tree_column: *TreeViewColumn) void;
    pub const clicked = gtk_tree_view_column_clicked;

    /// Sets the current keyboard focus to be at `cell`, if the column contains
    /// 2 or more editable and activatable cells.
    extern fn gtk_tree_view_column_focus_cell(p_tree_column: *TreeViewColumn, p_cell: *gtk.CellRenderer) void;
    pub const focusCell = gtk_tree_view_column_focus_cell;

    /// Returns the current x alignment of `tree_column`.  This value can range
    /// between 0.0 and 1.0.
    extern fn gtk_tree_view_column_get_alignment(p_tree_column: *TreeViewColumn) f32;
    pub const getAlignment = gtk_tree_view_column_get_alignment;

    /// Returns the button used in the treeview column header
    extern fn gtk_tree_view_column_get_button(p_tree_column: *TreeViewColumn) *gtk.Widget;
    pub const getButton = gtk_tree_view_column_get_button;

    /// Returns `TRUE` if the user can click on the header for the column.
    extern fn gtk_tree_view_column_get_clickable(p_tree_column: *TreeViewColumn) c_int;
    pub const getClickable = gtk_tree_view_column_get_clickable;

    /// Returns `TRUE` if the column expands to fill available space.
    extern fn gtk_tree_view_column_get_expand(p_tree_column: *TreeViewColumn) c_int;
    pub const getExpand = gtk_tree_view_column_get_expand;

    /// Gets the fixed width of the column.  This may not be the actual displayed
    /// width of the column; for that, use `gtk.TreeViewColumn.getWidth`.
    extern fn gtk_tree_view_column_get_fixed_width(p_tree_column: *TreeViewColumn) c_int;
    pub const getFixedWidth = gtk_tree_view_column_get_fixed_width;

    /// Returns the maximum width in pixels of the `tree_column`, or -1 if no maximum
    /// width is set.
    extern fn gtk_tree_view_column_get_max_width(p_tree_column: *TreeViewColumn) c_int;
    pub const getMaxWidth = gtk_tree_view_column_get_max_width;

    /// Returns the minimum width in pixels of the `tree_column`, or -1 if no minimum
    /// width is set.
    extern fn gtk_tree_view_column_get_min_width(p_tree_column: *TreeViewColumn) c_int;
    pub const getMinWidth = gtk_tree_view_column_get_min_width;

    /// Returns `TRUE` if the `tree_column` can be reordered by the user.
    extern fn gtk_tree_view_column_get_reorderable(p_tree_column: *TreeViewColumn) c_int;
    pub const getReorderable = gtk_tree_view_column_get_reorderable;

    /// Returns `TRUE` if the `tree_column` can be resized by the end user.
    extern fn gtk_tree_view_column_get_resizable(p_tree_column: *TreeViewColumn) c_int;
    pub const getResizable = gtk_tree_view_column_get_resizable;

    /// Returns the current type of `tree_column`.
    extern fn gtk_tree_view_column_get_sizing(p_tree_column: *TreeViewColumn) gtk.TreeViewColumnSizing;
    pub const getSizing = gtk_tree_view_column_get_sizing;

    /// Gets the logical `sort_column_id` that the model sorts on when this
    /// column is selected for sorting.
    /// See `gtk.TreeViewColumn.setSortColumnId`.
    extern fn gtk_tree_view_column_get_sort_column_id(p_tree_column: *TreeViewColumn) c_int;
    pub const getSortColumnId = gtk_tree_view_column_get_sort_column_id;

    /// Gets the value set by `gtk.TreeViewColumn.setSortIndicator`.
    extern fn gtk_tree_view_column_get_sort_indicator(p_tree_column: *TreeViewColumn) c_int;
    pub const getSortIndicator = gtk_tree_view_column_get_sort_indicator;

    /// Gets the value set by `gtk.TreeViewColumn.setSortOrder`.
    extern fn gtk_tree_view_column_get_sort_order(p_tree_column: *TreeViewColumn) gtk.SortType;
    pub const getSortOrder = gtk_tree_view_column_get_sort_order;

    /// Returns the spacing of `tree_column`.
    extern fn gtk_tree_view_column_get_spacing(p_tree_column: *TreeViewColumn) c_int;
    pub const getSpacing = gtk_tree_view_column_get_spacing;

    /// Returns the title of the widget.
    extern fn gtk_tree_view_column_get_title(p_tree_column: *TreeViewColumn) [*:0]const u8;
    pub const getTitle = gtk_tree_view_column_get_title;

    /// Returns the `gtk.TreeView` wherein `tree_column` has been inserted.
    /// If `column` is currently not inserted in any tree view, `NULL` is
    /// returned.
    extern fn gtk_tree_view_column_get_tree_view(p_tree_column: *TreeViewColumn) ?*gtk.Widget;
    pub const getTreeView = gtk_tree_view_column_get_tree_view;

    /// Returns `TRUE` if `tree_column` is visible.
    extern fn gtk_tree_view_column_get_visible(p_tree_column: *TreeViewColumn) c_int;
    pub const getVisible = gtk_tree_view_column_get_visible;

    /// Returns the `gtk.Widget` in the button on the column header.
    /// If a custom widget has not been set then `NULL` is returned.
    extern fn gtk_tree_view_column_get_widget(p_tree_column: *TreeViewColumn) ?*gtk.Widget;
    pub const getWidget = gtk_tree_view_column_get_widget;

    /// Returns the current size of `tree_column` in pixels.
    extern fn gtk_tree_view_column_get_width(p_tree_column: *TreeViewColumn) c_int;
    pub const getWidth = gtk_tree_view_column_get_width;

    /// Returns the current X offset of `tree_column` in pixels.
    extern fn gtk_tree_view_column_get_x_offset(p_tree_column: *TreeViewColumn) c_int;
    pub const getXOffset = gtk_tree_view_column_get_x_offset;

    /// Adds the `cell` to end of the column. If `expand` is `FALSE`, then the `cell`
    /// is allocated no more space than it needs. Any unused space is divided
    /// evenly between cells for which `expand` is `TRUE`.
    extern fn gtk_tree_view_column_pack_end(p_tree_column: *TreeViewColumn, p_cell: *gtk.CellRenderer, p_expand: c_int) void;
    pub const packEnd = gtk_tree_view_column_pack_end;

    /// Packs the `cell` into the beginning of the column. If `expand` is `FALSE`, then
    /// the `cell` is allocated no more space than it needs. Any unused space is divided
    /// evenly between cells for which `expand` is `TRUE`.
    extern fn gtk_tree_view_column_pack_start(p_tree_column: *TreeViewColumn, p_cell: *gtk.CellRenderer, p_expand: c_int) void;
    pub const packStart = gtk_tree_view_column_pack_start;

    /// Flags the column, and the cell renderers added to this column, to have
    /// their sizes renegotiated.
    extern fn gtk_tree_view_column_queue_resize(p_tree_column: *TreeViewColumn) void;
    pub const queueResize = gtk_tree_view_column_queue_resize;

    /// Sets the alignment of the title or custom widget inside the column header.
    /// The alignment determines its location inside the button -- 0.0 for left, 0.5
    /// for center, 1.0 for right.
    extern fn gtk_tree_view_column_set_alignment(p_tree_column: *TreeViewColumn, p_xalign: f32) void;
    pub const setAlignment = gtk_tree_view_column_set_alignment;

    /// Sets the attributes in the list as the attributes of `tree_column`.
    /// The attributes should be in attribute/column order, as in
    /// `gtk.TreeViewColumn.addAttribute`. All existing attributes
    /// are removed, and replaced with the new attributes.
    extern fn gtk_tree_view_column_set_attributes(p_tree_column: *TreeViewColumn, p_cell_renderer: *gtk.CellRenderer, ...) void;
    pub const setAttributes = gtk_tree_view_column_set_attributes;

    /// Sets the `gtk.TreeCellDataFunc` to use for the column.  This
    /// function is used instead of the standard attributes mapping for
    /// setting the column value, and should set the value of `tree_column`'s
    /// cell renderer as appropriate.  `func` may be `NULL` to remove an
    /// older one.
    extern fn gtk_tree_view_column_set_cell_data_func(p_tree_column: *TreeViewColumn, p_cell_renderer: *gtk.CellRenderer, p_func: ?gtk.TreeCellDataFunc, p_func_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setCellDataFunc = gtk_tree_view_column_set_cell_data_func;

    /// Sets the header to be active if `clickable` is `TRUE`.  When the header is
    /// active, then it can take keyboard focus, and can be clicked.
    extern fn gtk_tree_view_column_set_clickable(p_tree_column: *TreeViewColumn, p_clickable: c_int) void;
    pub const setClickable = gtk_tree_view_column_set_clickable;

    /// Sets the column to take available extra space.  This space is shared equally
    /// amongst all columns that have the expand set to `TRUE`.  If no column has this
    /// option set, then the last column gets all extra space.  By default, every
    /// column is created with this `FALSE`.
    ///
    /// Along with “fixed-width”, the “expand” property changes when the column is
    /// resized by the user.
    extern fn gtk_tree_view_column_set_expand(p_tree_column: *TreeViewColumn, p_expand: c_int) void;
    pub const setExpand = gtk_tree_view_column_set_expand;

    /// If `fixed_width` is not -1, sets the fixed width of `tree_column`; otherwise
    /// unsets it.  The effective value of `fixed_width` is clamped between the
    /// minimum and maximum width of the column; however, the value stored in the
    /// “fixed-width” property is not clamped.  If the column sizing is
    /// `GTK_TREE_VIEW_COLUMN_GROW_ONLY` or `GTK_TREE_VIEW_COLUMN_AUTOSIZE`, setting
    /// a fixed width overrides the automatically calculated width.  Note that
    /// `fixed_width` is only a hint to GTK+; the width actually allocated to the
    /// column may be greater or less than requested.
    ///
    /// Along with “expand”, the “fixed-width” property changes when the column is
    /// resized by the user.
    extern fn gtk_tree_view_column_set_fixed_width(p_tree_column: *TreeViewColumn, p_fixed_width: c_int) void;
    pub const setFixedWidth = gtk_tree_view_column_set_fixed_width;

    /// Sets the maximum width of the `tree_column`.  If `max_width` is -1, then the
    /// maximum width is unset.  Note, the column can actually be wider than max
    /// width if it’s the last column in a view.  In this case, the column expands to
    /// fill any extra space.
    extern fn gtk_tree_view_column_set_max_width(p_tree_column: *TreeViewColumn, p_max_width: c_int) void;
    pub const setMaxWidth = gtk_tree_view_column_set_max_width;

    /// Sets the minimum width of the `tree_column`.  If `min_width` is -1, then the
    /// minimum width is unset.
    extern fn gtk_tree_view_column_set_min_width(p_tree_column: *TreeViewColumn, p_min_width: c_int) void;
    pub const setMinWidth = gtk_tree_view_column_set_min_width;

    /// If `reorderable` is `TRUE`, then the column can be reordered by the end user
    /// dragging the header.
    extern fn gtk_tree_view_column_set_reorderable(p_tree_column: *TreeViewColumn, p_reorderable: c_int) void;
    pub const setReorderable = gtk_tree_view_column_set_reorderable;

    /// If `resizable` is `TRUE`, then the user can explicitly resize the column by
    /// grabbing the outer edge of the column button.  If resizable is `TRUE` and
    /// sizing mode of the column is `GTK_TREE_VIEW_COLUMN_AUTOSIZE`, then the sizing
    /// mode is changed to `GTK_TREE_VIEW_COLUMN_GROW_ONLY`.
    extern fn gtk_tree_view_column_set_resizable(p_tree_column: *TreeViewColumn, p_resizable: c_int) void;
    pub const setResizable = gtk_tree_view_column_set_resizable;

    /// Sets the growth behavior of `tree_column` to `type`.
    extern fn gtk_tree_view_column_set_sizing(p_tree_column: *TreeViewColumn, p_type: gtk.TreeViewColumnSizing) void;
    pub const setSizing = gtk_tree_view_column_set_sizing;

    /// Sets the logical `sort_column_id` that this column sorts on when this column
    /// is selected for sorting.  Doing so makes the column header clickable.
    extern fn gtk_tree_view_column_set_sort_column_id(p_tree_column: *TreeViewColumn, p_sort_column_id: c_int) void;
    pub const setSortColumnId = gtk_tree_view_column_set_sort_column_id;

    /// Call this function with a `setting` of `TRUE` to display an arrow in
    /// the header button indicating the column is sorted. Call
    /// `gtk.TreeViewColumn.setSortOrder` to change the direction of
    /// the arrow.
    extern fn gtk_tree_view_column_set_sort_indicator(p_tree_column: *TreeViewColumn, p_setting: c_int) void;
    pub const setSortIndicator = gtk_tree_view_column_set_sort_indicator;

    /// Changes the appearance of the sort indicator.
    ///
    /// This does not actually sort the model.  Use
    /// `gtk.TreeViewColumn.setSortColumnId` if you want automatic sorting
    /// support.  This function is primarily for custom sorting behavior, and should
    /// be used in conjunction with `gtk.TreeSortable.setSortColumnId` to do
    /// that. For custom models, the mechanism will vary.
    ///
    /// The sort indicator changes direction to indicate normal sort or reverse sort.
    /// Note that you must have the sort indicator enabled to see anything when
    /// calling this function; see `gtk.TreeViewColumn.setSortIndicator`.
    extern fn gtk_tree_view_column_set_sort_order(p_tree_column: *TreeViewColumn, p_order: gtk.SortType) void;
    pub const setSortOrder = gtk_tree_view_column_set_sort_order;

    /// Sets the spacing field of `tree_column`, which is the number of pixels to
    /// place between cell renderers packed into it.
    extern fn gtk_tree_view_column_set_spacing(p_tree_column: *TreeViewColumn, p_spacing: c_int) void;
    pub const setSpacing = gtk_tree_view_column_set_spacing;

    /// Sets the title of the `tree_column`.  If a custom widget has been set, then
    /// this value is ignored.
    extern fn gtk_tree_view_column_set_title(p_tree_column: *TreeViewColumn, p_title: [*:0]const u8) void;
    pub const setTitle = gtk_tree_view_column_set_title;

    /// Sets the visibility of `tree_column`.
    extern fn gtk_tree_view_column_set_visible(p_tree_column: *TreeViewColumn, p_visible: c_int) void;
    pub const setVisible = gtk_tree_view_column_set_visible;

    /// Sets the widget in the header to be `widget`.  If widget is `NULL`, then the
    /// header button is set with a `gtk.Label` set to the title of `tree_column`.
    extern fn gtk_tree_view_column_set_widget(p_tree_column: *TreeViewColumn, p_widget: ?*gtk.Widget) void;
    pub const setWidget = gtk_tree_view_column_set_widget;

    extern fn gtk_tree_view_column_get_type() usize;
    pub const getGObjectType = gtk_tree_view_column_get_type;

    extern fn g_object_ref(p_self: *gtk.TreeViewColumn) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TreeViewColumn) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TreeViewColumn, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.UIManager` constructs a user interface (menus and toolbars) from
/// one or more UI definitions, which reference actions from one or more
/// action groups.
///
/// > GtkUIManager is deprecated since GTK+ 3.10. To construct user interfaces
/// > from XML definitions, you should use `gtk.Builder`, `gio.MenuModel`, et al. To
/// > work with actions, use `gio.Action`, `gtk.Actionable` et al. These newer classes
/// > support richer functionality and integration with various desktop shells.
/// > It should be possible to migrate most/all functionality from GtkUIManager.
///
/// # UI Definitions
///
/// The UI definitions are specified in an XML format which can be
/// roughly described by the following DTD.
///
/// > Do not confuse the GtkUIManager UI Definitions described here with
/// > the similarly named [GtkBuilder UI Definitions][BUILDER-UI].
///
/// ```
/// <!ELEMENT ui          (menubar|toolbar|popup|accelerator)* >
/// <!ELEMENT menubar     (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT menu        (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT popup       (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT toolbar     (toolitem|separator|placeholder)* >
/// <!ELEMENT placeholder (menuitem|toolitem|separator|placeholder|menu)* >
/// <!ELEMENT menuitem     EMPTY >
/// <!ELEMENT toolitem     (menu?) >
/// <!ELEMENT separator    EMPTY >
/// <!ELEMENT accelerator  EMPTY >
/// <!ATTLIST menubar      name                      `IMPLIED`
///                        action                    `IMPLIED` >
/// <!ATTLIST toolbar      name                      `IMPLIED`
///                        action                    `IMPLIED` >
/// <!ATTLIST popup        name                      `IMPLIED`
///                        action                    `IMPLIED`
///                        accelerators (true|false) `IMPLIED` >
/// <!ATTLIST placeholder  name                      `IMPLIED`
///                        action                    `IMPLIED` >
/// <!ATTLIST separator    name                      `IMPLIED`
///                        action                    `IMPLIED`
///                        expand       (true|false) `IMPLIED` >
/// <!ATTLIST menu         name                      `IMPLIED`
///                        action                    `REQUIRED`
///                        position     (top|bot)    `IMPLIED` >
/// <!ATTLIST menuitem     name                      `IMPLIED`
///                        action                    `REQUIRED`
///                        position     (top|bot)    `IMPLIED`
///                        always-show-image (true|false) `IMPLIED` >
/// <!ATTLIST toolitem     name                      `IMPLIED`
///                        action                    `REQUIRED`
///                        position     (top|bot)    `IMPLIED` >
/// <!ATTLIST accelerator  name                      `IMPLIED`
///                        action                    `REQUIRED` >
/// ```
///
/// There are some additional restrictions beyond those specified in the
/// DTD, e.g. every toolitem must have a toolbar in its anchestry and
/// every menuitem must have a menubar or popup in its anchestry. Since
/// a `glib.MarkupParser` is used to parse the UI description, it must not only
/// be valid XML, but valid markup.
///
/// If a name is not specified, it defaults to the action. If an action is
/// not specified either, the element name is used. The name and action
/// attributes must not contain “/” characters after parsing (since that
/// would mess up path lookup) and must be usable as XML attributes when
/// enclosed in doublequotes, thus they must not “"” characters or references
/// to the &quot; entity.
///
/// # A UI definition
///
/// ```
/// <ui>
///   <menubar>
///     <menu name="FileMenu" action="FileMenuAction">
///       <menuitem name="New" action="New2Action" />
///       <placeholder name="FileMenuAdditions" />
///     </menu>
///     <menu name="JustifyMenu" action="JustifyMenuAction">
///       <menuitem name="Left" action="justify-left"/>
///       <menuitem name="Centre" action="justify-center"/>
///       <menuitem name="Right" action="justify-right"/>
///       <menuitem name="Fill" action="justify-fill"/>
///     </menu>
///   </menubar>
///   <toolbar action="toolbar1">
///     <placeholder name="JustifyToolItems">
///       <separator/>
///       <toolitem name="Left" action="justify-left"/>
///       <toolitem name="Centre" action="justify-center"/>
///       <toolitem name="Right" action="justify-right"/>
///       <toolitem name="Fill" action="justify-fill"/>
///       <separator/>
///     </placeholder>
///   </toolbar>
/// </ui>
/// ```
///
/// The constructed widget hierarchy is very similar to the element tree
/// of the XML, with the exception that placeholders are merged into their
/// parents. The correspondence of XML elements to widgets should be
/// almost obvious:
///
/// - menubar
///
///    a `gtk.MenuBar`
///
/// - toolbar
///
///    a `gtk.Toolbar`
///
/// - popup
///
///    a toplevel `gtk.Menu`
///
/// - menu
///
///    a `gtk.Menu` attached to a menuitem
///
/// - menuitem
///
///    a `gtk.MenuItem` subclass, the exact type depends on the action
///
/// - toolitem
///
///    a `gtk.ToolItem` subclass, the exact type depends on the
///    action. Note that toolitem elements may contain a menu element,
///    but only if their associated action specifies a
///    `gtk.MenuToolButton` as proxy.
///
/// - separator
///
///    a `gtk.SeparatorMenuItem` or `gtk.SeparatorToolItem`
///
/// - accelerator
///
///    a keyboard accelerator
///
/// The “position” attribute determines where a constructed widget is positioned
/// wrt. to its siblings in the partially constructed tree. If it is
/// “top”, the widget is prepended, otherwise it is appended.
///
/// # UI Merging
///
/// The most remarkable feature of `gtk.UIManager` is that it can overlay a set
/// of menuitems and toolitems over another one, and demerge them later.
///
/// Merging is done based on the names of the XML elements. Each element is
/// identified by a path which consists of the names of its anchestors, separated
/// by slashes. For example, the menuitem named “Left” in the example above
/// has the path `/ui/menubar/JustifyMenu/Left` and the
/// toolitem with the same name has path
/// `/ui/toolbar1/JustifyToolItems/Left`.
///
/// # Accelerators
///
/// Every action has an accelerator path. Accelerators are installed together
/// with menuitem proxies, but they can also be explicitly added with
/// `<accelerator>` elements in the UI definition. This makes it possible to
/// have accelerators for actions even if they have no visible proxies.
///
/// # Smart Separators
///
/// The separators created by `gtk.UIManager` are “smart”, i.e. they do not show up
/// in the UI unless they end up between two visible menu or tool items. Separators
/// which are located at the very beginning or end of the menu or toolbar
/// containing them, or multiple separators next to each other, are hidden. This
/// is a useful feature, since the merging of UI elements from multiple sources
/// can make it hard or impossible to determine in advance whether a separator
/// will end up in such an unfortunate position.
///
/// For separators in toolbars, you can set `expand="true"` to
/// turn them from a small, visible separator to an expanding, invisible one.
/// Toolitems following an expanding separator are effectively right-aligned.
///
/// # Empty Menus
///
/// Submenus pose similar problems to separators inconnection with merging. It is
/// impossible to know in advance whether they will end up empty after merging.
/// `gtk.UIManager` offers two ways to treat empty submenus:
///
/// - make them disappear by hiding the menu item they’re attached to
///
/// - add an insensitive “Empty” item
///
/// The behaviour is chosen based on the “hide_if_empty” property of the action
/// to which the submenu is associated.
///
/// # GtkUIManager as GtkBuildable
///
/// The GtkUIManager implementation of the GtkBuildable interface accepts
/// GtkActionGroup objects as `<child>` elements in UI definitions.
///
/// A GtkUIManager UI definition as described above can be embedded in
/// an GtkUIManager `<object>` element in a GtkBuilder UI definition.
///
/// The widgets that are constructed by a GtkUIManager can be embedded in
/// other parts of the constructed user interface with the help of the
/// “constructor” attribute. See the example below.
///
/// ## An embedded GtkUIManager UI definition
///
/// ```
/// <object class="GtkUIManager" id="uiman">
///   <child>
///     <object class="GtkActionGroup" id="actiongroup">
///       <child>
///         <object class="GtkAction" id="file">
///           <property name="label">_File</property>
///         </object>
///       </child>
///     </object>
///   </child>
///   <ui>
///     <menubar name="menubar1">
///       <menu action="file">
///       </menu>
///     </menubar>
///   </ui>
/// </object>
/// <object class="GtkWindow" id="main-window">
///   <child>
///     <object class="GtkMenuBar" id="menubar1" constructor="uiman"/>
///   </child>
/// </object>
/// ```
pub const UIManager = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gtk.Buildable};
    pub const Class = gtk.UIManagerClass;
    f_parent: gobject.Object,
    f_private_data: ?*gtk.UIManagerPrivate,

    pub const virtual_methods = struct {
        pub const actions_changed = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(UIManager.Class, p_class).f_actions_changed.?(gobject.ext.as(UIManager, p_manager));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(UIManager.Class, p_class).f_actions_changed = @ptrCast(p_implementation);
            }
        };

        pub const add_widget = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget) void {
                return gobject.ext.as(UIManager.Class, p_class).f_add_widget.?(gobject.ext.as(UIManager, p_manager), p_widget);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_widget: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(UIManager.Class, p_class).f_add_widget = @ptrCast(p_implementation);
            }
        };

        pub const connect_proxy = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action: *gtk.Action, p_proxy: *gtk.Widget) void {
                return gobject.ext.as(UIManager.Class, p_class).f_connect_proxy.?(gobject.ext.as(UIManager, p_manager), p_action, p_proxy);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action: *gtk.Action, p_proxy: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(UIManager.Class, p_class).f_connect_proxy = @ptrCast(p_implementation);
            }
        };

        pub const disconnect_proxy = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action: *gtk.Action, p_proxy: *gtk.Widget) void {
                return gobject.ext.as(UIManager.Class, p_class).f_disconnect_proxy.?(gobject.ext.as(UIManager, p_manager), p_action, p_proxy);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action: *gtk.Action, p_proxy: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(UIManager.Class, p_class).f_disconnect_proxy = @ptrCast(p_implementation);
            }
        };

        /// Looks up an action by following a path. See `gtk.UIManager.getWidget`
        /// for more information about paths.
        pub const get_action = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: [*:0]const u8) *gtk.Action {
                return gobject.ext.as(UIManager.Class, p_class).f_get_action.?(gobject.ext.as(UIManager, p_manager), p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: [*:0]const u8) callconv(.c) *gtk.Action) void {
                gobject.ext.as(UIManager.Class, p_class).f_get_action = @ptrCast(p_implementation);
            }
        };

        /// Looks up a widget by following a path.
        /// The path consists of the names specified in the XML description of the UI.
        /// separated by “/”. Elements which don’t have a name or action attribute in
        /// the XML (e.g. `<popup>`) can be addressed by their XML element name
        /// (e.g. "popup"). The root element ("/ui") can be omitted in the path.
        ///
        /// Note that the widget found by following a path that ends in a `<menu>`;
        /// element is the menuitem to which the menu is attached, not the menu it
        /// manages.
        ///
        /// Also note that the widgets constructed by a ui manager are not tied to
        /// the lifecycle of the ui manager. If you add the widgets returned by this
        /// function to some container or explicitly ref them, they will survive the
        /// destruction of the ui manager.
        pub const get_widget = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: [*:0]const u8) *gtk.Widget {
                return gobject.ext.as(UIManager.Class, p_class).f_get_widget.?(gobject.ext.as(UIManager, p_manager), p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: [*:0]const u8) callconv(.c) *gtk.Widget) void {
                gobject.ext.as(UIManager.Class, p_class).f_get_widget = @ptrCast(p_implementation);
            }
        };

        pub const post_activate = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action: *gtk.Action) void {
                return gobject.ext.as(UIManager.Class, p_class).f_post_activate.?(gobject.ext.as(UIManager, p_manager), p_action);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action: *gtk.Action) callconv(.c) void) void {
                gobject.ext.as(UIManager.Class, p_class).f_post_activate = @ptrCast(p_implementation);
            }
        };

        pub const pre_activate = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action: *gtk.Action) void {
                return gobject.ext.as(UIManager.Class, p_class).f_pre_activate.?(gobject.ext.as(UIManager, p_manager), p_action);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action: *gtk.Action) callconv(.c) void) void {
                gobject.ext.as(UIManager.Class, p_class).f_pre_activate = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The "add-tearoffs" property controls whether generated menus
        /// have tearoff menu items.
        ///
        /// Note that this only affects regular menus. Generated popup
        /// menus never have tearoff menu items.
        pub const add_tearoffs = struct {
            pub const name = "add-tearoffs";

            pub const Type = c_int;
        };

        pub const ui = struct {
            pub const name = "ui";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {
        /// The ::actions-changed signal is emitted whenever the set of actions
        /// changes.
        pub const actions_changed = struct {
            pub const name = "actions-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(UIManager, p_instance))),
                    gobject.signalLookup("actions-changed", UIManager.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::add-widget signal is emitted for each generated menubar and toolbar.
        /// It is not emitted for generated popup menus, which can be obtained by
        /// `gtk.UIManager.getWidget`.
        pub const add_widget = struct {
            pub const name = "add-widget";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_widget: *gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(UIManager, p_instance))),
                    gobject.signalLookup("add-widget", UIManager.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::connect-proxy signal is emitted after connecting a proxy to
        /// an action in the group.
        ///
        /// This is intended for simple customizations for which a custom action
        /// class would be too clumsy, e.g. showing tooltips for menuitems in the
        /// statusbar.
        pub const connect_proxy = struct {
            pub const name = "connect-proxy";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_action: *gtk.Action, p_proxy: *gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(UIManager, p_instance))),
                    gobject.signalLookup("connect-proxy", UIManager.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::disconnect-proxy signal is emitted after disconnecting a proxy
        /// from an action in the group.
        pub const disconnect_proxy = struct {
            pub const name = "disconnect-proxy";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_action: *gtk.Action, p_proxy: *gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(UIManager, p_instance))),
                    gobject.signalLookup("disconnect-proxy", UIManager.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::post-activate signal is emitted just after the `action`
        /// is activated.
        ///
        /// This is intended for applications to get notification
        /// just after any action is activated.
        pub const post_activate = struct {
            pub const name = "post-activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_action: *gtk.Action, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(UIManager, p_instance))),
                    gobject.signalLookup("post-activate", UIManager.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::pre-activate signal is emitted just before the `action`
        /// is activated.
        ///
        /// This is intended for applications to get notification
        /// just before any action is activated.
        pub const pre_activate = struct {
            pub const name = "pre-activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_action: *gtk.Action, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(UIManager, p_instance))),
                    gobject.signalLookup("pre-activate", UIManager.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new ui manager object.
    extern fn gtk_ui_manager_new() *gtk.UIManager;
    pub const new = gtk_ui_manager_new;

    /// Adds a UI element to the current contents of `manager`.
    ///
    /// If `type` is `GTK_UI_MANAGER_AUTO`, GTK+ inserts a menuitem, toolitem or
    /// separator if such an element can be inserted at the place determined by
    /// `path`. Otherwise `type` must indicate an element that can be inserted at
    /// the place determined by `path`.
    ///
    /// If `path` points to a menuitem or toolitem, the new element will be inserted
    /// before or after this item, depending on `top`.
    extern fn gtk_ui_manager_add_ui(p_manager: *UIManager, p_merge_id: c_uint, p_path: [*:0]const u8, p_name: [*:0]const u8, p_action: ?[*:0]const u8, p_type: gtk.UIManagerItemType, p_top: c_int) void;
    pub const addUi = gtk_ui_manager_add_ui;

    /// Parses a file containing a [UI definition][XML-UI] and
    /// merges it with the current contents of `manager`.
    extern fn gtk_ui_manager_add_ui_from_file(p_manager: *UIManager, p_filename: [*:0]const u8, p_error: ?*?*glib.Error) c_uint;
    pub const addUiFromFile = gtk_ui_manager_add_ui_from_file;

    /// Parses a resource file containing a [UI definition][XML-UI] and
    /// merges it with the current contents of `manager`.
    extern fn gtk_ui_manager_add_ui_from_resource(p_manager: *UIManager, p_resource_path: [*:0]const u8, p_error: ?*?*glib.Error) c_uint;
    pub const addUiFromResource = gtk_ui_manager_add_ui_from_resource;

    /// Parses a string containing a [UI definition][XML-UI] and merges it with
    /// the current contents of `manager`. An enclosing `<ui>` element is added if
    /// it is missing.
    extern fn gtk_ui_manager_add_ui_from_string(p_manager: *UIManager, p_buffer: [*:0]const u8, p_length: isize, p_error: ?*?*glib.Error) c_uint;
    pub const addUiFromString = gtk_ui_manager_add_ui_from_string;

    /// Makes sure that all pending updates to the UI have been completed.
    ///
    /// This may occasionally be necessary, since `gtk.UIManager` updates the
    /// UI in an idle function. A typical example where this function is
    /// useful is to enforce that the menubar and toolbar have been added to
    /// the main window before showing it:
    /// ```
    /// gtk_container_add (GTK_CONTAINER (window), vbox);
    /// g_signal_connect (merge, "add-widget",
    ///                   G_CALLBACK (add_widget), vbox);
    /// gtk_ui_manager_add_ui_from_file (merge, "my-menus");
    /// gtk_ui_manager_add_ui_from_file (merge, "my-toolbars");
    /// gtk_ui_manager_ensure_update (merge);
    /// gtk_widget_show (window);
    /// ```
    extern fn gtk_ui_manager_ensure_update(p_manager: *UIManager) void;
    pub const ensureUpdate = gtk_ui_manager_ensure_update;

    /// Returns the `gtk.AccelGroup` associated with `manager`.
    extern fn gtk_ui_manager_get_accel_group(p_manager: *UIManager) *gtk.AccelGroup;
    pub const getAccelGroup = gtk_ui_manager_get_accel_group;

    /// Looks up an action by following a path. See `gtk.UIManager.getWidget`
    /// for more information about paths.
    extern fn gtk_ui_manager_get_action(p_manager: *UIManager, p_path: [*:0]const u8) *gtk.Action;
    pub const getAction = gtk_ui_manager_get_action;

    /// Returns the list of action groups associated with `manager`.
    extern fn gtk_ui_manager_get_action_groups(p_manager: *UIManager) *glib.List;
    pub const getActionGroups = gtk_ui_manager_get_action_groups;

    /// Returns whether menus generated by this `gtk.UIManager`
    /// will have tearoff menu items.
    extern fn gtk_ui_manager_get_add_tearoffs(p_manager: *UIManager) c_int;
    pub const getAddTearoffs = gtk_ui_manager_get_add_tearoffs;

    /// Obtains a list of all toplevel widgets of the requested types.
    extern fn gtk_ui_manager_get_toplevels(p_manager: *UIManager, p_types: gtk.UIManagerItemType) *glib.SList;
    pub const getToplevels = gtk_ui_manager_get_toplevels;

    /// Creates a [UI definition][XML-UI] of the merged UI.
    extern fn gtk_ui_manager_get_ui(p_manager: *UIManager) [*:0]u8;
    pub const getUi = gtk_ui_manager_get_ui;

    /// Looks up a widget by following a path.
    /// The path consists of the names specified in the XML description of the UI.
    /// separated by “/”. Elements which don’t have a name or action attribute in
    /// the XML (e.g. `<popup>`) can be addressed by their XML element name
    /// (e.g. "popup"). The root element ("/ui") can be omitted in the path.
    ///
    /// Note that the widget found by following a path that ends in a `<menu>`;
    /// element is the menuitem to which the menu is attached, not the menu it
    /// manages.
    ///
    /// Also note that the widgets constructed by a ui manager are not tied to
    /// the lifecycle of the ui manager. If you add the widgets returned by this
    /// function to some container or explicitly ref them, they will survive the
    /// destruction of the ui manager.
    extern fn gtk_ui_manager_get_widget(p_manager: *UIManager, p_path: [*:0]const u8) *gtk.Widget;
    pub const getWidget = gtk_ui_manager_get_widget;

    /// Inserts an action group into the list of action groups associated
    /// with `manager`. Actions in earlier groups hide actions with the same
    /// name in later groups.
    ///
    /// If `pos` is larger than the number of action groups in `manager`, or
    /// negative, `action_group` will be inserted at the end of the internal
    /// list.
    extern fn gtk_ui_manager_insert_action_group(p_manager: *UIManager, p_action_group: *gtk.ActionGroup, p_pos: c_int) void;
    pub const insertActionGroup = gtk_ui_manager_insert_action_group;

    /// Returns an unused merge id, suitable for use with
    /// `gtk.UIManager.addUi`.
    extern fn gtk_ui_manager_new_merge_id(p_manager: *UIManager) c_uint;
    pub const newMergeId = gtk_ui_manager_new_merge_id;

    /// Removes an action group from the list of action groups associated
    /// with `manager`.
    extern fn gtk_ui_manager_remove_action_group(p_manager: *UIManager, p_action_group: *gtk.ActionGroup) void;
    pub const removeActionGroup = gtk_ui_manager_remove_action_group;

    /// Unmerges the part of `manager`'s content identified by `merge_id`.
    extern fn gtk_ui_manager_remove_ui(p_manager: *UIManager, p_merge_id: c_uint) void;
    pub const removeUi = gtk_ui_manager_remove_ui;

    /// Sets the “add_tearoffs” property, which controls whether menus
    /// generated by this `gtk.UIManager` will have tearoff menu items.
    ///
    /// Note that this only affects regular menus. Generated popup
    /// menus never have tearoff menu items.
    extern fn gtk_ui_manager_set_add_tearoffs(p_manager: *UIManager, p_add_tearoffs: c_int) void;
    pub const setAddTearoffs = gtk_ui_manager_set_add_tearoffs;

    extern fn gtk_ui_manager_get_type() usize;
    pub const getGObjectType = gtk_ui_manager_get_type;

    extern fn g_object_ref(p_self: *gtk.UIManager) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.UIManager) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *UIManager, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.VBox` is a container that organizes child widgets into a single column.
///
/// Use the `gtk.Box` packing interface to determine the arrangement,
/// spacing, height, and alignment of `gtk.VBox` children.
///
/// All children are allocated the same width.
///
/// GtkVBox has been deprecated. You can use `gtk.Box` with a `gtk.Orientable.properties.orientation`
/// set to `GTK_ORIENTATION_VERTICAL` instead when calling `gtk.Box.new`,
/// which is a very quick and easy change.
///
/// If you have derived your own classes from GtkVBox, you can change the
/// inheritance to derive directly from `gtk.Box`, and set the `gtk.Orientable.properties.orientation`
/// property to `GTK_ORIENTATION_VERTICAL` in your instance init function,
/// with a call like:
///
/// ```
///   gtk_orientable_set_orientation (GTK_ORIENTABLE (object),
///                                   GTK_ORIENTATION_VERTICAL);
/// ```
///
/// If you have a grid-like layout composed of nested boxes, and you don’t
/// need first-child or last-child styling, the recommendation is to switch
/// to `gtk.Grid`. For more information about migrating to `gtk.Grid`, see
/// [Migrating from other containers to GtkGrid][gtk-migrating-GtkGrid].
pub const VBox = extern struct {
    pub const Parent = gtk.Box;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.VBoxClass;
    f_box: gtk.Box,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.VBox`.
    extern fn gtk_vbox_new(p_homogeneous: c_int, p_spacing: c_int) *gtk.VBox;
    pub const new = gtk_vbox_new;

    extern fn gtk_vbox_get_type() usize;
    pub const getGObjectType = gtk_vbox_get_type;

    extern fn g_object_ref(p_self: *gtk.VBox) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.VBox) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *VBox, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const VButtonBox = extern struct {
    pub const Parent = gtk.ButtonBox;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.VButtonBoxClass;
    f_button_box: gtk.ButtonBox,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new vertical button box.
    extern fn gtk_vbutton_box_new() *gtk.VButtonBox;
    pub const new = gtk_vbutton_box_new;

    extern fn gtk_vbutton_box_get_type() usize;
    pub const getGObjectType = gtk_vbutton_box_get_type;

    extern fn g_object_ref(p_self: *gtk.VButtonBox) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.VButtonBox) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *VButtonBox, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The VPaned widget is a container widget with two
/// children arranged vertically. The division between
/// the two panes is adjustable by the user by dragging
/// a handle. See `gtk.Paned` for details.
///
/// GtkVPaned has been deprecated, use `gtk.Paned` instead.
pub const VPaned = extern struct {
    pub const Parent = gtk.Paned;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.VPanedClass;
    f_paned: gtk.Paned,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Create a new `gtk.VPaned`
    extern fn gtk_vpaned_new() *gtk.VPaned;
    pub const new = gtk_vpaned_new;

    extern fn gtk_vpaned_get_type() usize;
    pub const getGObjectType = gtk_vpaned_get_type;

    extern fn g_object_ref(p_self: *gtk.VPaned) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.VPaned) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *VPaned, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.VScale` widget is used to allow the user to select a value using
/// a vertical slider. To create one, use `gtk.HScale.newWithRange`.
///
/// The position to show the current value, and the number of decimal places
/// shown can be set using the parent `gtk.Scale` class’s functions.
///
/// GtkVScale has been deprecated, use `gtk.Scale` instead.
pub const VScale = extern struct {
    pub const Parent = gtk.Scale;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.VScaleClass;
    f_scale: gtk.Scale,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.VScale`.
    extern fn gtk_vscale_new(p_adjustment: *gtk.Adjustment) *gtk.VScale;
    pub const new = gtk_vscale_new;

    /// Creates a new vertical scale widget that lets the user input a
    /// number between `min` and `max` (including `min` and `max`) with the
    /// increment `step`.  `step` must be nonzero; it’s the distance the
    /// slider moves when using the arrow keys to adjust the scale value.
    ///
    /// Note that the way in which the precision is derived works best if `step`
    /// is a power of ten. If the resulting precision is not suitable for your
    /// needs, use `gtk.Scale.setDigits` to correct it.
    extern fn gtk_vscale_new_with_range(p_min: f64, p_max: f64, p_step: f64) *gtk.VScale;
    pub const newWithRange = gtk_vscale_new_with_range;

    extern fn gtk_vscale_get_type() usize;
    pub const getGObjectType = gtk_vscale_get_type;

    extern fn g_object_ref(p_self: *gtk.VScale) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.VScale) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *VScale, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.VScrollbar` widget is a widget arranged vertically creating a
/// scrollbar. See `gtk.Scrollbar` for details on
/// scrollbars. `gtk.Adjustment` pointers may be added to handle the
/// adjustment of the scrollbar or it may be left `NULL` in which case one
/// will be created for you. See `gtk.Scrollbar` for a description of what the
/// fields in an adjustment represent for a scrollbar.
///
/// GtkVScrollbar has been deprecated, use `gtk.Scrollbar` instead.
pub const VScrollbar = extern struct {
    pub const Parent = gtk.Scrollbar;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.VScrollbarClass;
    f_scrollbar: gtk.Scrollbar,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new vertical scrollbar.
    extern fn gtk_vscrollbar_new(p_adjustment: ?*gtk.Adjustment) *gtk.VScrollbar;
    pub const new = gtk_vscrollbar_new;

    extern fn gtk_vscrollbar_get_type() usize;
    pub const getGObjectType = gtk_vscrollbar_get_type;

    extern fn g_object_ref(p_self: *gtk.VScrollbar) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.VScrollbar) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *VScrollbar, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.VSeparator` widget is a vertical separator, used to group the
/// widgets within a window. It displays a vertical line with a shadow to
/// make it appear sunken into the interface.
///
/// GtkVSeparator has been deprecated, use `gtk.Separator` instead.
pub const VSeparator = extern struct {
    pub const Parent = gtk.Separator;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.VSeparatorClass;
    f_separator: gtk.Separator,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.VSeparator`.
    extern fn gtk_vseparator_new() *gtk.VSeparator;
    pub const new = gtk_vseparator_new;

    extern fn gtk_vseparator_get_type() usize;
    pub const getGObjectType = gtk_vseparator_get_type;

    extern fn g_object_ref(p_self: *gtk.VSeparator) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.VSeparator) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *VSeparator, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Viewport` widget acts as an adaptor class, implementing
/// scrollability for child widgets that lack their own scrolling
/// capabilities. Use GtkViewport to scroll child widgets such as
/// `gtk.Grid`, `gtk.Box`, and so on.
///
/// If a widget has native scrolling abilities, such as `gtk.TextView`,
/// `gtk.TreeView` or `gtk.IconView`, it can be added to a `gtk.ScrolledWindow`
/// with `gtk.Container.add`. If a widget does not, you must first add the
/// widget to a `gtk.Viewport`, then add the viewport to the scrolled window.
/// `gtk.Container.add` does this automatically if a child that does not
/// implement `gtk.Scrollable` is added to a `gtk.ScrolledWindow`, so you can
/// ignore the presence of the viewport.
///
/// The GtkViewport will start scrolling content only if allocated less
/// than the child widget’s minimum size in a given orientation.
///
/// # CSS nodes
///
/// GtkViewport has a single CSS node with name viewport.
pub const Viewport = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable, gtk.Scrollable };
    pub const Class = gtk.ViewportClass;
    f_bin: gtk.Bin,
    f_priv: ?*gtk.ViewportPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const shadow_type = struct {
            pub const name = "shadow-type";

            pub const Type = gtk.ShadowType;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gtk.Viewport` with the given adjustments, or with default
    /// adjustments if none are given.
    extern fn gtk_viewport_new(p_hadjustment: ?*gtk.Adjustment, p_vadjustment: ?*gtk.Adjustment) *gtk.Viewport;
    pub const new = gtk_viewport_new;

    /// Gets the bin window of the `gtk.Viewport`.
    extern fn gtk_viewport_get_bin_window(p_viewport: *Viewport) *gdk.Window;
    pub const getBinWindow = gtk_viewport_get_bin_window;

    /// Returns the horizontal adjustment of the viewport.
    extern fn gtk_viewport_get_hadjustment(p_viewport: *Viewport) *gtk.Adjustment;
    pub const getHadjustment = gtk_viewport_get_hadjustment;

    /// Gets the shadow type of the `gtk.Viewport`. See
    /// `gtk.Viewport.setShadowType`.
    extern fn gtk_viewport_get_shadow_type(p_viewport: *Viewport) gtk.ShadowType;
    pub const getShadowType = gtk_viewport_get_shadow_type;

    /// Returns the vertical adjustment of the viewport.
    extern fn gtk_viewport_get_vadjustment(p_viewport: *Viewport) *gtk.Adjustment;
    pub const getVadjustment = gtk_viewport_get_vadjustment;

    /// Gets the view window of the `gtk.Viewport`.
    extern fn gtk_viewport_get_view_window(p_viewport: *Viewport) *gdk.Window;
    pub const getViewWindow = gtk_viewport_get_view_window;

    /// Sets the horizontal adjustment of the viewport.
    extern fn gtk_viewport_set_hadjustment(p_viewport: *Viewport, p_adjustment: ?*gtk.Adjustment) void;
    pub const setHadjustment = gtk_viewport_set_hadjustment;

    /// Sets the shadow type of the viewport.
    extern fn gtk_viewport_set_shadow_type(p_viewport: *Viewport, p_type: gtk.ShadowType) void;
    pub const setShadowType = gtk_viewport_set_shadow_type;

    /// Sets the vertical adjustment of the viewport.
    extern fn gtk_viewport_set_vadjustment(p_viewport: *Viewport, p_adjustment: ?*gtk.Adjustment) void;
    pub const setVadjustment = gtk_viewport_set_vadjustment;

    extern fn gtk_viewport_get_type() usize;
    pub const getGObjectType = gtk_viewport_get_type;

    extern fn g_object_ref(p_self: *gtk.Viewport) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Viewport) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Viewport, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.VolumeButton` is a subclass of `gtk.ScaleButton` that has
/// been tailored for use as a volume control widget with suitable
/// icons, tooltips and accessible labels.
pub const VolumeButton = extern struct {
    pub const Parent = gtk.ScaleButton;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Actionable, gtk.Activatable, gtk.Buildable, gtk.Orientable };
    pub const Class = gtk.VolumeButtonClass;
    f_parent: gtk.ScaleButton,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Whether to use symbolic icons as the icons. Note that
        /// if the symbolic icons are not available in your installed
        /// theme, then the normal (potentially colorful) icons will
        /// be used.
        pub const use_symbolic = struct {
            pub const name = "use-symbolic";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a `gtk.VolumeButton`, with a range between 0.0 and 1.0, with
    /// a stepping of 0.02. Volume values can be obtained and modified using
    /// the functions from `gtk.ScaleButton`.
    extern fn gtk_volume_button_new() *gtk.VolumeButton;
    pub const new = gtk_volume_button_new;

    extern fn gtk_volume_button_get_type() usize;
    pub const getGObjectType = gtk_volume_button_get_type;

    extern fn g_object_ref(p_self: *gtk.VolumeButton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.VolumeButton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *VolumeButton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkWidget is the base class all widgets in GTK+ derive from. It manages the
/// widget lifecycle, states and style.
///
/// # Height-for-width Geometry Management
///
/// GTK+ uses a height-for-width (and width-for-height) geometry management
/// system. Height-for-width means that a widget can change how much
/// vertical space it needs, depending on the amount of horizontal space
/// that it is given (and similar for width-for-height). The most common
/// example is a label that reflows to fill up the available width, wraps
/// to fewer lines, and therefore needs less height.
///
/// Height-for-width geometry management is implemented in GTK+ by way
/// of five virtual methods:
///
/// - `gtk.WidgetClass.virtual_methods.get_request_mode`
/// - `gtk.WidgetClass.virtual_methods.get_preferred_width`
/// - `gtk.WidgetClass.virtual_methods.get_preferred_height`
/// - `gtk.WidgetClass.virtual_methods.get_preferred_height_for_width`
/// - `gtk.WidgetClass.virtual_methods.get_preferred_width_for_height`
/// - `gtk.WidgetClass.virtual_methods.get_preferred_height_and_baseline_for_width`
///
/// There are some important things to keep in mind when implementing
/// height-for-width and when using it in container implementations.
///
/// The geometry management system will query a widget hierarchy in
/// only one orientation at a time. When widgets are initially queried
/// for their minimum sizes it is generally done in two initial passes
/// in the `gtk.SizeRequestMode` chosen by the toplevel.
///
/// For example, when queried in the normal
/// `GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH` mode:
/// First, the default minimum and natural width for each widget
/// in the interface will be computed using `gtk.Widget.getPreferredWidth`.
/// Because the preferred widths for each container depend on the preferred
/// widths of their children, this information propagates up the hierarchy,
/// and finally a minimum and natural width is determined for the entire
/// toplevel. Next, the toplevel will use the minimum width to query for the
/// minimum height contextual to that width using
/// `gtk.Widget.getPreferredHeightForWidth`, which will also be a highly
/// recursive operation. The minimum height for the minimum width is normally
/// used to set the minimum size constraint on the toplevel
/// (unless `gtk.Window.setGeometryHints` is explicitly used instead).
///
/// After the toplevel window has initially requested its size in both
/// dimensions it can go on to allocate itself a reasonable size (or a size
/// previously specified with `gtk.Window.setDefaultSize`). During the
/// recursive allocation process it’s important to note that request cycles
/// will be recursively executed while container widgets allocate their children.
/// Each container widget, once allocated a size, will go on to first share the
/// space in one orientation among its children and then request each child's
/// height for its target allocated width or its width for allocated height,
/// depending. In this way a `gtk.Widget` will typically be requested its size
/// a number of times before actually being allocated a size. The size a
/// widget is finally allocated can of course differ from the size it has
/// requested. For this reason, `gtk.Widget` caches a  small number of results
/// to avoid re-querying for the same sizes in one allocation cycle.
///
/// See
/// [GtkContainer’s geometry management section][container-geometry-management]
/// to learn more about how height-for-width allocations are performed
/// by container widgets.
///
/// If a widget does move content around to intelligently use up the
/// allocated size then it must support the request in both
/// `GtkSizeRequestModes` even if the widget in question only
/// trades sizes in a single orientation.
///
/// For instance, a `gtk.Label` that does height-for-width word wrapping
/// will not expect to have `gtk.WidgetClass.virtual_methods.get_preferred_height` called
/// because that call is specific to a width-for-height request. In this
/// case the label must return the height required for its own minimum
/// possible width. By following this rule any widget that handles
/// height-for-width or width-for-height requests will always be allocated
/// at least enough space to fit its own content.
///
/// Here are some examples of how a `GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH` widget
/// generally deals with width-for-height requests, for `gtk.WidgetClass.virtual_methods.get_preferred_height`
/// it will do:
///
/// ```
/// static void
/// foo_widget_get_preferred_height (GtkWidget *widget,
///                                  gint *min_height,
///                                  gint *nat_height)
/// {
///    if (i_am_in_height_for_width_mode)
///      {
///        gint min_width, nat_width;
///
///        GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
///                                                            &min_width,
///                                                            &nat_width);
///        GTK_WIDGET_GET_CLASS (widget)->get_preferred_height_for_width
///                                                           (widget,
///                                                            min_width,
///                                                            min_height,
///                                                            nat_height);
///      }
///    else
///      {
///         ... some widgets do both. For instance, if a GtkLabel is
///         rotated to 90 degrees it will return the minimum and
///         natural height for the rotated label here.
///      }
/// }
/// ```
///
/// And in `gtk.WidgetClass.virtual_methods.get_preferred_width_for_height` it will simply return
/// the minimum and natural width:
/// ```
/// static void
/// foo_widget_get_preferred_width_for_height (GtkWidget *widget,
///                                            gint for_height,
///                                            gint *min_width,
///                                            gint *nat_width)
/// {
///    if (i_am_in_height_for_width_mode)
///      {
///        GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
///                                                            min_width,
///                                                            nat_width);
///      }
///    else
///      {
///         ... again if a widget is sometimes operating in
///         width-for-height mode (like a rotated GtkLabel) it can go
///         ahead and do its real width for height calculation here.
///      }
/// }
/// ```
///
/// Often a widget needs to get its own request during size request or
/// allocation. For example, when computing height it may need to also
/// compute width. Or when deciding how to use an allocation, the widget
/// may need to know its natural size. In these cases, the widget should
/// be careful to call its virtual methods directly, like this:
///
/// ```
/// GTK_WIDGET_GET_CLASS(widget)->get_preferred_width (widget,
///                                                    &min,
///                                                    &natural);
/// ```
///
/// It will not work to use the wrapper functions, such as
/// `gtk.Widget.getPreferredWidth` inside your own size request
/// implementation. These return a request adjusted by `gtk.SizeGroup`
/// and by the `gtk.WidgetClass.virtual_methods.adjust_size_request` virtual method. If a
/// widget used the wrappers inside its virtual method implementations,
/// then the adjustments (such as widget margins) would be applied
/// twice. GTK+ therefore does not allow this and will warn if you try
/// to do it.
///
/// Of course if you are getting the size request for
/// another widget, such as a child of a
/// container, you must use the wrapper APIs.
/// Otherwise, you would not properly consider widget margins,
/// `gtk.SizeGroup`, and so forth.
///
/// Since 3.10 GTK+ also supports baseline vertical alignment of widgets. This
/// means that widgets are positioned such that the typographical baseline of
/// widgets in the same row are aligned. This happens if a widget supports baselines,
/// has a vertical alignment of `GTK_ALIGN_BASELINE`, and is inside a container
/// that supports baselines and has a natural “row” that it aligns to the baseline,
/// or a baseline assigned to it by the grandparent.
///
/// Baseline alignment support for a widget is done by the `gtk.WidgetClass.virtual_methods.get_preferred_height_and_baseline_for_width`
/// virtual function. It allows you to report a baseline in combination with the
/// minimum and natural height. If there is no baseline you can return -1 to indicate
/// this. The default implementation of this virtual function calls into the
/// `gtk.WidgetClass.virtual_methods.get_preferred_height` and `gtk.WidgetClass.virtual_methods.get_preferred_height_for_width`,
/// so if baselines are not supported it doesn’t need to be implemented.
///
/// If a widget ends up baseline aligned it will be allocated all the space in the parent
/// as if it was `GTK_ALIGN_FILL`, but the selected baseline can be found via `gtk.Widget.getAllocatedBaseline`.
/// If this has a value other than -1 you need to align the widget such that the baseline
/// appears at the position.
///
/// # Style Properties
///
/// `gtk.Widget` introduces “style
/// properties” - these are basically object properties that are stored
/// not on the object, but in the style object associated to the widget. Style
/// properties are set in [resource files][gtk3-Resource-Files].
/// This mechanism is used for configuring such things as the location of the
/// scrollbar arrows through the theme, giving theme authors more control over the
/// look of applications without the need to write a theme engine in C.
///
/// Use `gtk.WidgetClass.installStyleProperty` to install style properties for
/// a widget class, `gtk.WidgetClass.findStyleProperty` or
/// `gtk.WidgetClass.listStyleProperties` to get information about existing
/// style properties and `gtk.Widget.styleGetProperty`, `gtk.Widget.styleGet` or
/// `gtk.Widget.styleGetValist` to obtain the value of a style property.
///
/// # GtkWidget as GtkBuildable
///
/// The GtkWidget implementation of the GtkBuildable interface supports a
/// custom `<accelerator>` element, which has attributes named ”key”, ”modifiers”
/// and ”signal” and allows to specify accelerators.
///
/// An example of a UI definition fragment specifying an accelerator:
///
/// ```
/// <object class="GtkButton">
///   <accelerator key="q" modifiers="GDK_CONTROL_MASK" signal="clicked"/>
/// </object>
/// ```
///
/// In addition to accelerators, GtkWidget also support a custom `<accessible>`
/// element, which supports actions and relations. Properties on the accessible
/// implementation of an object can be set by accessing the internal child
/// “accessible” of a `gtk.Widget`.
///
/// An example of a UI definition fragment specifying an accessible:
///
/// ```
/// <object class="GtkLabel" id="label1"/>
///   <property name="label">I am a Label for a Button</property>
/// </object>
/// <object class="GtkButton" id="button1">
///   <accessibility>
///     <action action_name="click" translatable="yes">Click the button.</action>
///     <relation target="label1" type="labelled-by"/>
///   </accessibility>
///   <child internal-child="accessible">
///     <object class="AtkObject" id="a11y-button1">
///       <property name="accessible-name">Clickable Button</property>
///     </object>
///   </child>
/// </object>
/// ```
///
/// Finally, GtkWidget allows style information such as style classes to
/// be associated with widgets, using the custom `<style>` element:
///
/// ```
/// <object class="GtkButton" id="button1">
///   <style>
///     <class name="my-special-button-class"/>
///     <class name="dark-button"/>
///   </style>
/// </object>
/// ```
///
/// # Building composite widgets from template XML
///
/// GtkWidget exposes some facilities to automate the procedure
/// of creating composite widgets using `gtk.Builder` interface description
/// language.
///
/// To create composite widgets with `gtk.Builder` XML, one must associate
/// the interface description with the widget class at class initialization
/// time using `gtk.WidgetClass.setTemplate`.
///
/// The interface description semantics expected in composite template descriptions
/// is slightly different from regular `gtk.Builder` XML.
///
/// Unlike regular interface descriptions, `gtk.WidgetClass.setTemplate` will
/// expect a `<template>` tag as a direct child of the toplevel `<interface>`
/// tag. The `<template>` tag must specify the “class” attribute which must be
/// the type name of the widget. Optionally, the “parent” attribute may be
/// specified to specify the direct parent type of the widget type, this is
/// ignored by the GtkBuilder but required for Glade to introspect what kind
/// of properties and internal children exist for a given type when the actual
/// type does not exist.
///
/// The XML which is contained inside the `<template>` tag behaves as if it were
/// added to the `<object>` tag defining "widget" itself. You may set properties
/// on `widget` by inserting `<property>` tags into the `<template>` tag, and also
/// add `<child>` tags to add children and extend "widget" in the normal way you
/// would with `<object>` tags.
///
/// Additionally, `<object>` tags can also be added before and after the initial
/// `<template>` tag in the normal way, allowing one to define auxiliary objects
/// which might be referenced by other widgets declared as children of the
/// `<template>` tag.
///
/// An example of a GtkBuilder Template Definition:
///
/// ```
/// <interface>
///   <template class="FooWidget" parent="GtkBox">
///     <property name="orientation">GTK_ORIENTATION_HORIZONTAL</property>
///     <property name="spacing">4</property>
///     <child>
///       <object class="GtkButton" id="hello_button">
///         <property name="label">Hello World</property>
///         <signal name="clicked" handler="hello_button_clicked" object="FooWidget" swapped="yes"/>
///       </object>
///     </child>
///     <child>
///       <object class="GtkButton" id="goodbye_button">
///         <property name="label">Goodbye World</property>
///       </object>
///     </child>
///   </template>
/// </interface>
/// ```
///
/// Typically, you'll place the template fragment into a file that is
/// bundled with your project, using `gio.Resource`. In order to load the
/// template, you need to call `gtk.WidgetClass.setTemplateFromResource`
/// from the class initialization of your `gtk.Widget` type:
///
/// ```
/// static void
/// foo_widget_class_init (FooWidgetClass *klass)
/// {
///   // ...
///
///   gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
///                                                "/com/example/ui/foowidget.ui");
/// }
/// ```
///
/// You will also need to call `gtk.Widget.initTemplate` from the instance
/// initialization function:
///
/// ```
/// static void
/// foo_widget_init (FooWidget *self)
/// {
///   // ...
///   gtk_widget_init_template (GTK_WIDGET (self));
/// }
/// ```
///
/// You can access widgets defined in the template using the
/// `gtk.Widget.getTemplateChild` function, but you will typically declare
/// a pointer in the instance private data structure of your type using the same
/// name as the widget in the template definition, and call
/// `gtk_widget_class_bind_template_child_private` with that name, e.g.
///
/// ```
/// typedef struct {
///   GtkWidget *hello_button;
///   GtkWidget *goodbye_button;
/// } FooWidgetPrivate;
///
/// G_DEFINE_TYPE_WITH_PRIVATE (FooWidget, foo_widget, GTK_TYPE_BOX)
///
/// static void
/// foo_widget_class_init (FooWidgetClass *klass)
/// {
///   // ...
///   gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
///                                                "/com/example/ui/foowidget.ui");
///   gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
///                                                 FooWidget, hello_button);
///   gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
///                                                 FooWidget, goodbye_button);
/// }
///
/// static void
/// foo_widget_init (FooWidget *widget)
/// {
///
/// }
/// ```
///
/// You can also use `gtk_widget_class_bind_template_callback` to connect a signal
/// callback defined in the template with a function visible in the scope of the
/// class, e.g.
///
/// ```
/// // the signal handler has the instance and user data swapped
/// // because of the swapped="yes" attribute in the template XML
/// static void
/// hello_button_clicked (FooWidget *self,
///                       GtkButton *button)
/// {
///   g_print ("Hello, world!\n");
/// }
///
/// static void
/// foo_widget_class_init (FooWidgetClass *klass)
/// {
///   // ...
///   gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
///                                                "/com/example/ui/foowidget.ui");
///   gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
/// }
/// ```
pub const Widget = extern struct {
    pub const Parent = gobject.InitiallyUnowned;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.WidgetClass;
    f_parent_instance: gobject.InitiallyUnowned,
    f_priv: ?*gtk.WidgetPrivate,

    pub const virtual_methods = struct {
        pub const adjust_baseline_allocation = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_baseline: *c_int) void {
                return gobject.ext.as(Widget.Class, p_class).f_adjust_baseline_allocation.?(gobject.ext.as(Widget, p_widget), p_baseline);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_baseline: *c_int) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_adjust_baseline_allocation = @ptrCast(p_implementation);
            }
        };

        pub const adjust_baseline_request = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_minimum_baseline: *c_int, p_natural_baseline: *c_int) void {
                return gobject.ext.as(Widget.Class, p_class).f_adjust_baseline_request.?(gobject.ext.as(Widget, p_widget), p_minimum_baseline, p_natural_baseline);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_minimum_baseline: *c_int, p_natural_baseline: *c_int) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_adjust_baseline_request = @ptrCast(p_implementation);
            }
        };

        /// Convert an initial size allocation assigned
        ///   by a `gtk.Container` using `gtk.Widget.sizeAllocate`, into an actual
        ///   size allocation to be used by the widget. adjust_size_allocation
        ///   adjusts to a child widget’s actual allocation
        ///   from what a parent container computed for the
        ///   child. The adjusted allocation must be entirely within the original
        ///   allocation. In any custom implementation, chain up to the default
        ///   `gtk.Widget` implementation of this method, which applies the margin
        ///   and alignment properties of `gtk.Widget`. Chain up
        ///   before performing your own adjustments so your
        ///   own adjustments remove more allocation after the `gtk.Widget` base
        ///   class has already removed margin and alignment. The natural size
        ///   passed in should be adjusted in the same way as the allocated size,
        ///   which allows adjustments to perform alignments or other changes
        ///   based on natural size.
        pub const adjust_size_allocation = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_orientation: gtk.Orientation, p_minimum_size: *c_int, p_natural_size: *c_int, p_allocated_pos: *c_int, p_allocated_size: *c_int) void {
                return gobject.ext.as(Widget.Class, p_class).f_adjust_size_allocation.?(gobject.ext.as(Widget, p_widget), p_orientation, p_minimum_size, p_natural_size, p_allocated_pos, p_allocated_size);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_orientation: gtk.Orientation, p_minimum_size: *c_int, p_natural_size: *c_int, p_allocated_pos: *c_int, p_allocated_size: *c_int) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_adjust_size_allocation = @ptrCast(p_implementation);
            }
        };

        /// Convert an initial size request from a widget's
        ///   `gtk.SizeRequestMode` virtual method implementations into a size request to
        ///   be used by parent containers in laying out the widget.
        ///   adjust_size_request adjusts from a child widget's
        ///   original request to what a parent container should
        ///   use for layout. The `for_size` argument will be -1 if the request should
        ///   not be for a particular size in the opposing orientation, i.e. if the
        ///   request is not height-for-width or width-for-height. If `for_size` is
        ///   greater than -1, it is the proposed allocation in the opposing
        ///   orientation that we need the request for. Implementations of
        ///   adjust_size_request should chain up to the default implementation,
        ///   which applies `gtk.Widget`’s margin properties and imposes any values
        ///   from `gtk.Widget.setSizeRequest`. Chaining up should be last,
        ///   after your subclass adjusts the request, so
        ///   `gtk.Widget` can apply constraints and add the margin properly.
        pub const adjust_size_request = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_orientation: gtk.Orientation, p_minimum_size: *c_int, p_natural_size: *c_int) void {
                return gobject.ext.as(Widget.Class, p_class).f_adjust_size_request.?(gobject.ext.as(Widget, p_widget), p_orientation, p_minimum_size, p_natural_size);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_orientation: gtk.Orientation, p_minimum_size: *c_int, p_natural_size: *c_int) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_adjust_size_request = @ptrCast(p_implementation);
            }
        };

        /// Signal will be emitted when a button
        ///   (typically from a mouse) is pressed.
        pub const button_press_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventButton) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_button_press_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventButton) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_button_press_event = @ptrCast(p_implementation);
            }
        };

        /// Signal will be emitted when a button
        ///   (typically from a mouse) is released.
        pub const button_release_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventButton) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_button_release_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventButton) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_button_release_event = @ptrCast(p_implementation);
            }
        };

        /// Determines whether an accelerator that activates the signal
        /// identified by `signal_id` can currently be activated.
        /// This is done by emitting the `gtk.Widget.signals.can`-activate-accel
        /// signal on `widget`; if the signal isn’t overridden by a
        /// handler or in a derived widget, then the default check is
        /// that the widget must be sensitive, and the widget and all
        /// its ancestors mapped.
        pub const can_activate_accel = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_signal_id: c_uint) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_can_activate_accel.?(gobject.ext.as(Widget, p_widget), p_signal_id);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_signal_id: c_uint) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_can_activate_accel = @ptrCast(p_implementation);
            }
        };

        /// Emits a `gtk.Widget.signals.child`-notify signal for the
        /// [child property][child-properties] `child_property`
        /// on `widget`.
        ///
        /// This is the analogue of `gobject.Object.notify` for child properties.
        ///
        /// Also see `gtk.Container.childNotify`.
        pub const child_notify = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child_property: *gobject.ParamSpec) void {
                return gobject.ext.as(Widget.Class, p_class).f_child_notify.?(gobject.ext.as(Widget, p_widget), p_child_property);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_child_property: *gobject.ParamSpec) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_child_notify = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the composited status of
        ///   widgets screen changes. See `gdk.Screen.isComposited`.
        pub const composited_changed = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Widget.Class, p_class).f_composited_changed.?(gobject.ext.as(Widget, p_widget));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_composited_changed = @ptrCast(p_implementation);
            }
        };

        /// Computes whether a container should give this
        ///   widget extra space when possible.
        pub const compute_expand = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_hexpand_p: *c_int, p_vexpand_p: *c_int) void {
                return gobject.ext.as(Widget.Class, p_class).f_compute_expand.?(gobject.ext.as(Widget, p_widget), p_hexpand_p, p_vexpand_p);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_hexpand_p: *c_int, p_vexpand_p: *c_int) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_compute_expand = @ptrCast(p_implementation);
            }
        };

        /// Signal will be emitted when the size, position or
        ///   stacking of the widget’s window has changed.
        pub const configure_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventConfigure) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_configure_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventConfigure) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_configure_event = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when a redirected window belonging to
        ///   widget gets drawn into.
        pub const damage_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventExpose) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_damage_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventExpose) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_damage_event = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted if a user requests that a toplevel
        ///   window is closed.
        pub const delete_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventAny) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_delete_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventAny) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_delete_event = @ptrCast(p_implementation);
            }
        };

        /// Destroys a widget.
        ///
        /// When a widget is destroyed all references it holds on other objects
        /// will be released:
        ///
        ///  - if the widget is inside a container, it will be removed from its
        ///  parent
        ///  - if the widget is a container, all its children will be destroyed,
        ///  recursively
        ///  - if the widget is a top level, it will be removed from the list
        ///  of top level widgets that GTK+ maintains internally
        ///
        /// It's expected that all references held on the widget will also
        /// be released; you should connect to the `gtk.Widget.signals.destroy` signal
        /// if you hold a reference to `widget` and you wish to remove it when
        /// this function is called. It is not necessary to do so if you are
        /// implementing a `gtk.Container`, as you'll be able to use the
        /// `gtk.ContainerClass.virtual_methods.remove` virtual function for that.
        ///
        /// It's important to notice that `gtk.Widget.destroy` will only cause
        /// the `widget` to be finalized if no additional references, acquired
        /// using `gobject.Object.ref`, are held on it. In case additional references
        /// are in place, the `widget` will be in an "inert" state after calling
        /// this function; `widget` will still point to valid memory, allowing you
        /// to release the references you hold, but you may not query the widget's
        /// own state.
        ///
        /// You should typically call this function on top level widgets, and
        /// rarely on child widgets.
        ///
        /// See also: `gtk.Container.remove`
        pub const destroy = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Widget.Class, p_class).f_destroy.?(gobject.ext.as(Widget, p_widget));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_destroy = @ptrCast(p_implementation);
            }
        };

        /// Signal is emitted when a `gdk.Window` is destroyed.
        pub const destroy_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventAny) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_destroy_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventAny) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_destroy_event = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the text direction of a
        ///   widget changes.
        pub const direction_changed = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_previous_direction: gtk.TextDirection) void {
                return gobject.ext.as(Widget.Class, p_class).f_direction_changed.?(gobject.ext.as(Widget, p_widget), p_previous_direction);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_previous_direction: gtk.TextDirection) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_direction_changed = @ptrCast(p_implementation);
            }
        };

        /// Seldomly overidden.
        pub const dispatch_child_properties_changed = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_n_pspecs: c_uint, p_pspecs: **gobject.ParamSpec) void {
                return gobject.ext.as(Widget.Class, p_class).f_dispatch_child_properties_changed.?(gobject.ext.as(Widget, p_widget), p_n_pspecs, p_pspecs);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_n_pspecs: c_uint, p_pspecs: **gobject.ParamSpec) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_dispatch_child_properties_changed = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted on the drag source when a drag is
        ///   started.
        pub const drag_begin = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext) void {
                return gobject.ext.as(Widget.Class, p_class).f_drag_begin.?(gobject.ext.as(Widget, p_widget), p_context);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_drag_begin = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted on the drag source when a drag
        ///   with the action `GDK_ACTION_MOVE` is successfully completed.
        pub const drag_data_delete = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext) void {
                return gobject.ext.as(Widget.Class, p_class).f_drag_data_delete.?(gobject.ext.as(Widget, p_widget), p_context);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_drag_data_delete = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted on the drag source when the drop
        ///   site requests the data which is dragged.
        pub const drag_data_get = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext, p_selection_data: *gtk.SelectionData, p_info: c_uint, p_time_: c_uint) void {
                return gobject.ext.as(Widget.Class, p_class).f_drag_data_get.?(gobject.ext.as(Widget, p_widget), p_context, p_selection_data, p_info, p_time_);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext, p_selection_data: *gtk.SelectionData, p_info: c_uint, p_time_: c_uint) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_drag_data_get = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted on the drop site when the
        ///   dragged data has been received.
        pub const drag_data_received = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext, p_x: c_int, p_y: c_int, p_selection_data: *gtk.SelectionData, p_info: c_uint, p_time_: c_uint) void {
                return gobject.ext.as(Widget.Class, p_class).f_drag_data_received.?(gobject.ext.as(Widget, p_widget), p_context, p_x, p_y, p_selection_data, p_info, p_time_);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext, p_x: c_int, p_y: c_int, p_selection_data: *gtk.SelectionData, p_info: c_uint, p_time_: c_uint) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_drag_data_received = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted on the drop site when the user drops the
        ///   data onto the widget.
        pub const drag_drop = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext, p_x: c_int, p_y: c_int, p_time_: c_uint) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_drag_drop.?(gobject.ext.as(Widget, p_widget), p_context, p_x, p_y, p_time_);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext, p_x: c_int, p_y: c_int, p_time_: c_uint) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_drag_drop = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted on the drag source when a drag is
        ///   finished.
        pub const drag_end = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext) void {
                return gobject.ext.as(Widget.Class, p_class).f_drag_end.?(gobject.ext.as(Widget, p_widget), p_context);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_drag_end = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted on the drag source when a drag has
        ///   failed.
        pub const drag_failed = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext, p_result: gtk.DragResult) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_drag_failed.?(gobject.ext.as(Widget, p_widget), p_context, p_result);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext, p_result: gtk.DragResult) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_drag_failed = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted on the drop site when the cursor leaves
        ///   the widget.
        pub const drag_leave = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext, p_time_: c_uint) void {
                return gobject.ext.as(Widget.Class, p_class).f_drag_leave.?(gobject.ext.as(Widget, p_widget), p_context, p_time_);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext, p_time_: c_uint) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_drag_leave = @ptrCast(p_implementation);
            }
        };

        /// signal emitted on the drop site when the user moves
        ///   the cursor over the widget during a drag.
        pub const drag_motion = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext, p_x: c_int, p_y: c_int, p_time_: c_uint) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_drag_motion.?(gobject.ext.as(Widget, p_widget), p_context, p_x, p_y, p_time_);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gdk.DragContext, p_x: c_int, p_y: c_int, p_time_: c_uint) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_drag_motion = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when a widget is supposed to render itself.
        pub const draw = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_draw.?(gobject.ext.as(Widget, p_widget), p_cr);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cr: *cairo.Context) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_draw = @ptrCast(p_implementation);
            }
        };

        /// Signal event will be emitted when the pointer
        ///   enters the widget’s window.
        pub const enter_notify_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventCrossing) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_enter_notify_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventCrossing) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_enter_notify_event = @ptrCast(p_implementation);
            }
        };

        /// Rarely-used function. This function is used to emit
        /// the event signals on a widget (those signals should never
        /// be emitted without using this function to do so).
        /// If you want to synthesize an event though, don’t use this function;
        /// instead, use `gtk.mainDoEvent` so the event will behave as if
        /// it were in the event queue. Don’t synthesize expose events; instead,
        /// use `gdk.Window.invalidateRect` to invalidate a region of the
        /// window.
        pub const event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.Event) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.Event) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_event = @ptrCast(p_implementation);
            }
        };

        pub const focus = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.DirectionType) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_focus.?(gobject.ext.as(Widget, p_widget), p_direction);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.DirectionType) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_focus = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the keyboard focus enters the
        /// widget’s window.
        pub const focus_in_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventFocus) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_focus_in_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventFocus) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_focus_in_event = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the keyboard focus leaves the
        /// widget’s window.
        pub const focus_out_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventFocus) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_focus_out_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventFocus) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_focus_out_event = @ptrCast(p_implementation);
            }
        };

        /// Returns the accessible object that describes the widget to an
        /// assistive technology.
        ///
        /// If accessibility support is not available, this `atk.Object`
        /// instance may be a no-op. Likewise, if no class-specific `atk.Object`
        /// implementation is available for the widget instance in question,
        /// it will inherit an `atk.Object` implementation from the first ancestor
        /// class for which such an implementation is defined.
        ///
        /// The documentation of the
        /// [ATK](http://developer.gnome.org/atk/stable/)
        /// library contains more information about accessible objects and their uses.
        pub const get_accessible = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *atk.Object {
                return gobject.ext.as(Widget.Class, p_class).f_get_accessible.?(gobject.ext.as(Widget, p_widget));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *atk.Object) void {
                gobject.ext.as(Widget.Class, p_class).f_get_accessible = @ptrCast(p_implementation);
            }
        };

        /// Retrieves a widget’s initial minimum and natural height.
        ///
        /// This call is specific to width-for-height requests.
        ///
        /// The returned request will be modified by the
        /// GtkWidgetClass::adjust_size_request virtual method and by any
        /// `GtkSizeGroups` that have been applied. That is, the returned request
        /// is the one that should be used for layout, not necessarily the one
        /// returned by the widget itself.
        pub const get_preferred_height = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) void {
                return gobject.ext.as(Widget.Class, p_class).f_get_preferred_height.?(gobject.ext.as(Widget, p_widget), p_minimum_height, p_natural_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_get_preferred_height = @ptrCast(p_implementation);
            }
        };

        /// Retrieves a widget’s minimum and natural height and the corresponding baselines if it would be given
        /// the specified `width`, or the default height if `width` is -1. The baselines may be -1 which means
        /// that no baseline is requested for this widget.
        ///
        /// The returned request will be modified by the
        /// GtkWidgetClass::adjust_size_request and GtkWidgetClass::adjust_baseline_request virtual methods
        /// and by any `GtkSizeGroups` that have been applied. That is, the returned request
        /// is the one that should be used for layout, not necessarily the one
        /// returned by the widget itself.
        pub const get_preferred_height_and_baseline_for_width = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int, p_minimum_baseline: ?*c_int, p_natural_baseline: ?*c_int) void {
                return gobject.ext.as(Widget.Class, p_class).f_get_preferred_height_and_baseline_for_width.?(gobject.ext.as(Widget, p_widget), p_width, p_minimum_height, p_natural_height, p_minimum_baseline, p_natural_baseline);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int, p_minimum_baseline: ?*c_int, p_natural_baseline: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_get_preferred_height_and_baseline_for_width = @ptrCast(p_implementation);
            }
        };

        /// Retrieves a widget’s minimum and natural height if it would be given
        /// the specified `width`.
        ///
        /// The returned request will be modified by the
        /// GtkWidgetClass::adjust_size_request virtual method and by any
        /// `GtkSizeGroups` that have been applied. That is, the returned request
        /// is the one that should be used for layout, not necessarily the one
        /// returned by the widget itself.
        pub const get_preferred_height_for_width = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) void {
                return gobject.ext.as(Widget.Class, p_class).f_get_preferred_height_for_width.?(gobject.ext.as(Widget, p_widget), p_width, p_minimum_height, p_natural_height);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_get_preferred_height_for_width = @ptrCast(p_implementation);
            }
        };

        /// Retrieves a widget’s initial minimum and natural width.
        ///
        /// This call is specific to height-for-width requests.
        ///
        /// The returned request will be modified by the
        /// GtkWidgetClass::adjust_size_request virtual method and by any
        /// `GtkSizeGroups` that have been applied. That is, the returned request
        /// is the one that should be used for layout, not necessarily the one
        /// returned by the widget itself.
        pub const get_preferred_width = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) void {
                return gobject.ext.as(Widget.Class, p_class).f_get_preferred_width.?(gobject.ext.as(Widget, p_widget), p_minimum_width, p_natural_width);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_get_preferred_width = @ptrCast(p_implementation);
            }
        };

        /// Retrieves a widget’s minimum and natural width if it would be given
        /// the specified `height`.
        ///
        /// The returned request will be modified by the
        /// GtkWidgetClass::adjust_size_request virtual method and by any
        /// `GtkSizeGroups` that have been applied. That is, the returned request
        /// is the one that should be used for layout, not necessarily the one
        /// returned by the widget itself.
        pub const get_preferred_width_for_height = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) void {
                return gobject.ext.as(Widget.Class, p_class).f_get_preferred_width_for_height.?(gobject.ext.as(Widget, p_widget), p_height, p_minimum_width, p_natural_width);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_get_preferred_width_for_height = @ptrCast(p_implementation);
            }
        };

        /// Gets whether the widget prefers a height-for-width layout
        /// or a width-for-height layout.
        ///
        /// `gtk.Bin` widgets generally propagate the preference of
        /// their child, container widgets need to request something either in
        /// context of their children or in context of their allocation
        /// capabilities.
        pub const get_request_mode = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) gtk.SizeRequestMode {
                return gobject.ext.as(Widget.Class, p_class).f_get_request_mode.?(gobject.ext.as(Widget, p_widget));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) gtk.SizeRequestMode) void {
                gobject.ext.as(Widget.Class, p_class).f_get_request_mode = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when a pointer or keyboard grab
        ///   on a window belonging to widget gets broken.
        pub const grab_broken_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventGrabBroken) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_grab_broken_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventGrabBroken) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_grab_broken_event = @ptrCast(p_implementation);
            }
        };

        /// Causes `widget` to have the keyboard focus for the `gtk.Window` it's
        /// inside. `widget` must be a focusable widget, such as a `gtk.Entry`;
        /// something like `gtk.Frame` won’t work.
        ///
        /// More precisely, it must have the `GTK_CAN_FOCUS` flag set. Use
        /// `gtk.Widget.setCanFocus` to modify that flag.
        ///
        /// The widget also needs to be realized and mapped. This is indicated by the
        /// related signals. Grabbing the focus immediately after creating the widget
        /// will likely fail and cause critical warnings.
        pub const grab_focus = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Widget.Class, p_class).f_grab_focus.?(gobject.ext.as(Widget, p_widget));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_grab_focus = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when a widget becomes shadowed by a
        ///   GTK+ grab (not a pointer or keyboard grab) on another widget, or
        ///   when it becomes unshadowed due to a grab being removed.
        pub const grab_notify = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_was_grabbed: c_int) void {
                return gobject.ext.as(Widget.Class, p_class).f_grab_notify.?(gobject.ext.as(Widget, p_widget), p_was_grabbed);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_was_grabbed: c_int) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_grab_notify = @ptrCast(p_implementation);
            }
        };

        /// Reverses the effects of `gtk.Widget.show`, causing the widget to be
        /// hidden (invisible to the user).
        pub const hide = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Widget.Class, p_class).f_hide.?(gobject.ext.as(Widget, p_widget));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_hide = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the anchored state of a
        ///   widget changes.
        pub const hierarchy_changed = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_previous_toplevel: *gtk.Widget) void {
                return gobject.ext.as(Widget.Class, p_class).f_hierarchy_changed.?(gobject.ext.as(Widget, p_widget), p_previous_toplevel);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_previous_toplevel: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_hierarchy_changed = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when a key is pressed.
        pub const key_press_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventKey) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_key_press_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventKey) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_key_press_event = @ptrCast(p_implementation);
            }
        };

        /// Signal is emitted when a key is released.
        pub const key_release_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventKey) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_key_release_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventKey) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_key_release_event = @ptrCast(p_implementation);
            }
        };

        /// This function should be called whenever keyboard navigation within
        /// a single widget hits a boundary. The function emits the
        /// `gtk.Widget.signals.keynav`-failed signal on the widget and its return
        /// value should be interpreted in a way similar to the return value of
        /// `gtk.Widget.childFocus`:
        ///
        /// When `TRUE` is returned, stay in the widget, the failed keyboard
        /// navigation is OK and/or there is nowhere we can/should move the
        /// focus to.
        ///
        /// When `FALSE` is returned, the caller should continue with keyboard
        /// navigation outside the widget, e.g. by calling
        /// `gtk.Widget.childFocus` on the widget’s toplevel.
        ///
        /// The default ::keynav-failed handler returns `FALSE` for
        /// `GTK_DIR_TAB_FORWARD` and `GTK_DIR_TAB_BACKWARD`. For the other
        /// values of `gtk.DirectionType` it returns `TRUE`.
        ///
        /// Whenever the default handler returns `TRUE`, it also calls
        /// `gtk.Widget.errorBell` to notify the user of the failed keyboard
        /// navigation.
        ///
        /// A use case for providing an own implementation of ::keynav-failed
        /// (either by connecting to it or by overriding it) would be a row of
        /// `gtk.Entry` widgets where the user should be able to navigate the
        /// entire row with the cursor keys, as e.g. known from user interfaces
        /// that require entering license keys.
        pub const keynav_failed = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.DirectionType) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_keynav_failed.?(gobject.ext.as(Widget, p_widget), p_direction);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.DirectionType) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_keynav_failed = @ptrCast(p_implementation);
            }
        };

        /// Will be emitted when the pointer leaves the
        ///   widget’s window.
        pub const leave_notify_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventCrossing) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_leave_notify_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventCrossing) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_leave_notify_event = @ptrCast(p_implementation);
            }
        };

        /// This function is only for use in widget implementations. Causes
        /// a widget to be mapped if it isn’t already.
        pub const map = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Widget.Class, p_class).f_map.?(gobject.ext.as(Widget, p_widget));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_map = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the widget’s window is mapped.
        pub const map_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventAny) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_map_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventAny) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_map_event = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gtk.Widget.signals.mnemonic`-activate signal.
        pub const mnemonic_activate = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_group_cycling: c_int) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_mnemonic_activate.?(gobject.ext.as(Widget, p_widget), p_group_cycling);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_group_cycling: c_int) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_mnemonic_activate = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the pointer moves over
        ///   the widget’s `gdk.Window`.
        pub const motion_notify_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventMotion) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_motion_notify_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventMotion) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_motion_notify_event = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when a change of focus is requested
        pub const move_focus = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.DirectionType) void {
                return gobject.ext.as(Widget.Class, p_class).f_move_focus.?(gobject.ext.as(Widget, p_widget), p_direction);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_direction: gtk.DirectionType) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_move_focus = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when a new parent has been set on a
        ///   widget.
        pub const parent_set = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_previous_parent: *gtk.Widget) void {
                return gobject.ext.as(Widget.Class, p_class).f_parent_set.?(gobject.ext.as(Widget, p_widget), p_previous_parent);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_previous_parent: *gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_parent_set = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted whenever a widget should pop up a
        ///   context menu.
        pub const popup_menu = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_popup_menu.?(gobject.ext.as(Widget, p_widget));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_popup_menu = @ptrCast(p_implementation);
            }
        };

        /// Signal will be emitted when a property on
        ///   the widget’s window has been changed or deleted.
        pub const property_notify_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventProperty) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_property_notify_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventProperty) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_property_notify_event = @ptrCast(p_implementation);
            }
        };

        pub const proximity_in_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventProximity) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_proximity_in_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventProximity) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_proximity_in_event = @ptrCast(p_implementation);
            }
        };

        pub const proximity_out_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventProximity) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_proximity_out_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventProximity) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_proximity_out_event = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when “has-tooltip” is `TRUE` and the
        ///   hover timeout has expired with the cursor hovering “above”
        ///   widget; or emitted when widget got focus in keyboard mode.
        pub const query_tooltip = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_x: c_int, p_y: c_int, p_keyboard_tooltip: c_int, p_tooltip: *gtk.Tooltip) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_query_tooltip.?(gobject.ext.as(Widget, p_widget), p_x, p_y, p_keyboard_tooltip, p_tooltip);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_x: c_int, p_y: c_int, p_keyboard_tooltip: c_int, p_tooltip: *gtk.Tooltip) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_query_tooltip = @ptrCast(p_implementation);
            }
        };

        /// Invalidates the area of `widget` defined by `region` by calling
        /// `gdk.Window.invalidateRegion` on the widget’s window and all its
        /// child windows. Once the main loop becomes idle (after the current
        /// batch of events has been processed, roughly), the window will
        /// receive expose events for the union of all regions that have been
        /// invalidated.
        ///
        /// Normally you would only use this function in widget
        /// implementations. You might also use it to schedule a redraw of a
        /// `gtk.DrawingArea` or some portion thereof.
        pub const queue_draw_region = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_region: *const cairo.Region) void {
                return gobject.ext.as(Widget.Class, p_class).f_queue_draw_region.?(gobject.ext.as(Widget, p_widget), p_region);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_region: *const cairo.Region) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_queue_draw_region = @ptrCast(p_implementation);
            }
        };

        /// Creates the GDK (windowing system) resources associated with a
        /// widget.  For example, `widget`->window will be created when a widget
        /// is realized.  Normally realization happens implicitly; if you show
        /// a widget and all its parent containers, then the widget will be
        /// realized and mapped automatically.
        ///
        /// Realizing a widget requires all
        /// the widget’s parent widgets to be realized; calling
        /// `gtk.Widget.realize` realizes the widget’s parents in addition to
        /// `widget` itself. If a widget is not yet inside a toplevel window
        /// when you realize it, bad things will happen.
        ///
        /// This function is primarily used in widget implementations, and
        /// isn’t very useful otherwise. Many times when you think you might
        /// need it, a better approach is to connect to a signal that will be
        /// called after the widget is realized automatically, such as
        /// `gtk.Widget.signals.draw`. Or simply g_signal_connect () to the
        /// `gtk.Widget.signals.realize` signal.
        pub const realize = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Widget.Class, p_class).f_realize.?(gobject.ext.as(Widget, p_widget));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_realize = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the screen of a widget has
        ///   changed.
        pub const screen_changed = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_previous_screen: *gdk.Screen) void {
                return gobject.ext.as(Widget.Class, p_class).f_screen_changed.?(gobject.ext.as(Widget, p_widget), p_previous_screen);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_previous_screen: *gdk.Screen) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_screen_changed = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when a button in the 4 to 7 range is
        ///   pressed.
        pub const scroll_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventScroll) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_scroll_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventScroll) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_scroll_event = @ptrCast(p_implementation);
            }
        };

        /// Signal will be emitted when the the
        ///   widget’s window has lost ownership of a selection.
        pub const selection_clear_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventSelection) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_selection_clear_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventSelection) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_selection_clear_event = @ptrCast(p_implementation);
            }
        };

        pub const selection_get = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_selection_data: *gtk.SelectionData, p_info: c_uint, p_time_: c_uint) void {
                return gobject.ext.as(Widget.Class, p_class).f_selection_get.?(gobject.ext.as(Widget, p_widget), p_selection_data, p_info, p_time_);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_selection_data: *gtk.SelectionData, p_info: c_uint, p_time_: c_uint) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_selection_get = @ptrCast(p_implementation);
            }
        };

        pub const selection_notify_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventSelection) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_selection_notify_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventSelection) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_selection_notify_event = @ptrCast(p_implementation);
            }
        };

        pub const selection_received = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_selection_data: *gtk.SelectionData, p_time_: c_uint) void {
                return gobject.ext.as(Widget.Class, p_class).f_selection_received.?(gobject.ext.as(Widget, p_widget), p_selection_data, p_time_);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_selection_data: *gtk.SelectionData, p_time_: c_uint) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_selection_received = @ptrCast(p_implementation);
            }
        };

        /// Signal will be emitted when another
        ///   client requests ownership of the selection owned by the widget's
        ///   window.
        pub const selection_request_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventSelection) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_selection_request_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventSelection) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_selection_request_event = @ptrCast(p_implementation);
            }
        };

        /// Flags a widget to be displayed. Any widget that isn’t shown will
        /// not appear on the screen. If you want to show all the widgets in a
        /// container, it’s easier to call `gtk.Widget.showAll` on the
        /// container, instead of individually showing the widgets.
        ///
        /// Remember that you have to show the containers containing a widget,
        /// in addition to the widget itself, before it will appear onscreen.
        ///
        /// When a toplevel container is shown, it is immediately realized and
        /// mapped; other shown widgets are realized and mapped when their
        /// toplevel container is realized and mapped.
        pub const show = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Widget.Class, p_class).f_show.?(gobject.ext.as(Widget, p_widget));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_show = @ptrCast(p_implementation);
            }
        };

        /// Recursively shows a widget, and any child widgets (if the widget is
        /// a container).
        pub const show_all = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Widget.Class, p_class).f_show_all.?(gobject.ext.as(Widget, p_widget));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_show_all = @ptrCast(p_implementation);
            }
        };

        pub const show_help = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_help_type: gtk.WidgetHelpType) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_show_help.?(gobject.ext.as(Widget, p_widget), p_help_type);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_help_type: gtk.WidgetHelpType) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_show_help = @ptrCast(p_implementation);
            }
        };

        /// This function is only used by `gtk.Container` subclasses, to assign a size
        /// and position to their child widgets.
        ///
        /// In this function, the allocation may be adjusted. It will be forced
        /// to a 1x1 minimum size, and the adjust_size_allocation virtual
        /// method on the child will be used to adjust the allocation. Standard
        /// adjustments include removing the widget’s margins, and applying the
        /// widget’s `gtk.Widget.properties.halign` and `gtk.Widget.properties.valign` properties.
        ///
        /// For baseline support in containers you need to use `gtk.Widget.sizeAllocateWithBaseline`
        /// instead.
        pub const size_allocate = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_allocation: *gtk.Allocation) void {
                return gobject.ext.as(Widget.Class, p_class).f_size_allocate.?(gobject.ext.as(Widget, p_widget), p_allocation);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_allocation: *gtk.Allocation) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_size_allocate = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the widget state
        ///   changes. Deprecated: 3.0
        pub const state_changed = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_previous_state: gtk.StateType) void {
                return gobject.ext.as(Widget.Class, p_class).f_state_changed.?(gobject.ext.as(Widget, p_widget), p_previous_state);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_previous_state: gtk.StateType) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_state_changed = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the widget state changes,
        ///   see `gtk.Widget.getStateFlags`.
        pub const state_flags_changed = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_previous_state_flags: gtk.StateFlags) void {
                return gobject.ext.as(Widget.Class, p_class).f_state_flags_changed.?(gobject.ext.as(Widget, p_widget), p_previous_state_flags);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_previous_state_flags: gtk.StateFlags) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_state_flags_changed = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when a new style has been set on a
        /// widget. Deprecated: 3.0
        pub const style_set = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_previous_style: *gtk.Style) void {
                return gobject.ext.as(Widget.Class, p_class).f_style_set.?(gobject.ext.as(Widget, p_widget), p_previous_style);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_previous_style: *gtk.Style) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_style_set = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the GtkStyleContext of a widget
        ///   is changed.
        pub const style_updated = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Widget.Class, p_class).f_style_updated.?(gobject.ext.as(Widget, p_widget));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_style_updated = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when a touch event happens
        pub const touch_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventTouch) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_touch_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventTouch) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_touch_event = @ptrCast(p_implementation);
            }
        };

        /// This function is only for use in widget implementations. Causes
        /// a widget to be unmapped if it’s currently mapped.
        pub const unmap = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Widget.Class, p_class).f_unmap.?(gobject.ext.as(Widget, p_widget));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_unmap = @ptrCast(p_implementation);
            }
        };

        /// Signal will be emitted when the widget’s window is
        ///   unmapped.
        pub const unmap_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventAny) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_unmap_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventAny) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_unmap_event = @ptrCast(p_implementation);
            }
        };

        /// This function is only useful in widget implementations.
        /// Causes a widget to be unrealized (frees all GDK resources
        /// associated with the widget, such as `widget`->window).
        pub const unrealize = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Widget.Class, p_class).f_unrealize.?(gobject.ext.as(Widget, p_widget));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Widget.Class, p_class).f_unrealize = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the widget’s window is
        ///   obscured or unobscured.
        pub const visibility_notify_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventVisibility) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_visibility_notify_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventVisibility) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_visibility_notify_event = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the state of the toplevel
        ///   window associated to the widget changes.
        pub const window_state_event = struct {
            pub fn call(p_class: anytype, p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventWindowState) c_int {
                return gobject.ext.as(Widget.Class, p_class).f_window_state_event.?(gobject.ext.as(Widget, p_widget), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_widget: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: *gdk.EventWindowState) callconv(.c) c_int) void {
                gobject.ext.as(Widget.Class, p_class).f_window_state_event = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const app_paintable = struct {
            pub const name = "app-paintable";

            pub const Type = c_int;
        };

        pub const can_default = struct {
            pub const name = "can-default";

            pub const Type = c_int;
        };

        pub const can_focus = struct {
            pub const name = "can-focus";

            pub const Type = c_int;
        };

        pub const composite_child = struct {
            pub const name = "composite-child";

            pub const Type = c_int;
        };

        /// Whether the widget is double buffered.
        pub const double_buffered = struct {
            pub const name = "double-buffered";

            pub const Type = c_int;
        };

        pub const events = struct {
            pub const name = "events";

            pub const Type = gdk.EventMask;
        };

        /// Whether to expand in both directions. Setting this sets both `gtk.Widget.properties.hexpand` and `gtk.Widget.properties.vexpand`
        pub const expand = struct {
            pub const name = "expand";

            pub const Type = c_int;
        };

        /// Whether the widget should grab focus when it is clicked with the mouse.
        ///
        /// This property is only relevant for widgets that can take focus.
        ///
        /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
        /// GtkComboBox) implemented this property individually.
        pub const focus_on_click = struct {
            pub const name = "focus-on-click";

            pub const Type = c_int;
        };

        /// How to distribute horizontal space if widget gets extra space, see `gtk.Align`
        pub const halign = struct {
            pub const name = "halign";

            pub const Type = gtk.Align;
        };

        pub const has_default = struct {
            pub const name = "has-default";

            pub const Type = c_int;
        };

        pub const has_focus = struct {
            pub const name = "has-focus";

            pub const Type = c_int;
        };

        /// Enables or disables the emission of `gtk.Widget.signals.query`-tooltip on `widget`.
        /// A value of `TRUE` indicates that `widget` can have a tooltip, in this case
        /// the widget will be queried using `gtk.Widget.signals.query`-tooltip to determine
        /// whether it will provide a tooltip or not.
        ///
        /// Note that setting this property to `TRUE` for the first time will change
        /// the event masks of the GdkWindows of this widget to include leave-notify
        /// and motion-notify events.  This cannot and will not be undone when the
        /// property is set to `FALSE` again.
        pub const has_tooltip = struct {
            pub const name = "has-tooltip";

            pub const Type = c_int;
        };

        pub const height_request = struct {
            pub const name = "height-request";

            pub const Type = c_int;
        };

        /// Whether to expand horizontally. See `gtk.Widget.setHexpand`.
        pub const hexpand = struct {
            pub const name = "hexpand";

            pub const Type = c_int;
        };

        /// Whether to use the `gtk.Widget.properties.hexpand` property. See `gtk.Widget.getHexpandSet`.
        pub const hexpand_set = struct {
            pub const name = "hexpand-set";

            pub const Type = c_int;
        };

        pub const is_focus = struct {
            pub const name = "is-focus";

            pub const Type = c_int;
        };

        /// Sets all four sides' margin at once. If read, returns max
        /// margin on any side.
        pub const margin = struct {
            pub const name = "margin";

            pub const Type = c_int;
        };

        /// Margin on bottom side of widget.
        ///
        /// This property adds margin outside of the widget's normal size
        /// request, the margin will be added in addition to the size from
        /// `gtk.Widget.setSizeRequest` for example.
        pub const margin_bottom = struct {
            pub const name = "margin-bottom";

            pub const Type = c_int;
        };

        /// Margin on end of widget, horizontally. This property supports
        /// left-to-right and right-to-left text directions.
        ///
        /// This property adds margin outside of the widget's normal size
        /// request, the margin will be added in addition to the size from
        /// `gtk.Widget.setSizeRequest` for example.
        pub const margin_end = struct {
            pub const name = "margin-end";

            pub const Type = c_int;
        };

        /// Margin on left side of widget.
        ///
        /// This property adds margin outside of the widget's normal size
        /// request, the margin will be added in addition to the size from
        /// `gtk.Widget.setSizeRequest` for example.
        pub const margin_left = struct {
            pub const name = "margin-left";

            pub const Type = c_int;
        };

        /// Margin on right side of widget.
        ///
        /// This property adds margin outside of the widget's normal size
        /// request, the margin will be added in addition to the size from
        /// `gtk.Widget.setSizeRequest` for example.
        pub const margin_right = struct {
            pub const name = "margin-right";

            pub const Type = c_int;
        };

        /// Margin on start of widget, horizontally. This property supports
        /// left-to-right and right-to-left text directions.
        ///
        /// This property adds margin outside of the widget's normal size
        /// request, the margin will be added in addition to the size from
        /// `gtk.Widget.setSizeRequest` for example.
        pub const margin_start = struct {
            pub const name = "margin-start";

            pub const Type = c_int;
        };

        /// Margin on top side of widget.
        ///
        /// This property adds margin outside of the widget's normal size
        /// request, the margin will be added in addition to the size from
        /// `gtk.Widget.setSizeRequest` for example.
        pub const margin_top = struct {
            pub const name = "margin-top";

            pub const Type = c_int;
        };

        pub const name = struct {
            pub const name = "name";

            pub const Type = ?[*:0]u8;
        };

        pub const no_show_all = struct {
            pub const name = "no-show-all";

            pub const Type = c_int;
        };

        /// The requested opacity of the widget. See `gtk.Widget.setOpacity` for
        /// more details about window opacity.
        ///
        /// Before 3.8 this was only available in GtkWindow
        pub const opacity = struct {
            pub const name = "opacity";

            pub const Type = f64;
        };

        pub const parent = struct {
            pub const name = "parent";

            pub const Type = ?*gtk.Container;
        };

        pub const receives_default = struct {
            pub const name = "receives-default";

            pub const Type = c_int;
        };

        /// The scale factor of the widget. See `gtk.Widget.getScaleFactor` for
        /// more details about widget scaling.
        pub const scale_factor = struct {
            pub const name = "scale-factor";

            pub const Type = c_int;
        };

        pub const sensitive = struct {
            pub const name = "sensitive";

            pub const Type = c_int;
        };

        /// The style of the widget, which contains information about how it will look (colors, etc).
        pub const style = struct {
            pub const name = "style";

            pub const Type = ?*gtk.Style;
        };

        /// Sets the text of tooltip to be the given string, which is marked up
        /// with the [Pango text markup language][PangoMarkupFormat].
        /// Also see `gtk.Tooltip.setMarkup`.
        ///
        /// This is a convenience property which will take care of getting the
        /// tooltip shown if the given string is not `NULL`: `gtk.Widget.properties.has`-tooltip
        /// will automatically be set to `TRUE` and there will be taken care of
        /// `gtk.Widget.signals.query`-tooltip in the default signal handler.
        ///
        /// Note that if both `gtk.Widget.properties.tooltip`-text and `gtk.Widget.properties.tooltip`-markup
        /// are set, the last one wins.
        pub const tooltip_markup = struct {
            pub const name = "tooltip-markup";

            pub const Type = ?[*:0]u8;
        };

        /// Sets the text of tooltip to be the given string.
        ///
        /// Also see `gtk.Tooltip.setText`.
        ///
        /// This is a convenience property which will take care of getting the
        /// tooltip shown if the given string is not `NULL`: `gtk.Widget.properties.has`-tooltip
        /// will automatically be set to `TRUE` and there will be taken care of
        /// `gtk.Widget.signals.query`-tooltip in the default signal handler.
        ///
        /// Note that if both `gtk.Widget.properties.tooltip`-text and `gtk.Widget.properties.tooltip`-markup
        /// are set, the last one wins.
        pub const tooltip_text = struct {
            pub const name = "tooltip-text";

            pub const Type = ?[*:0]u8;
        };

        /// How to distribute vertical space if widget gets extra space, see `gtk.Align`
        pub const valign = struct {
            pub const name = "valign";

            pub const Type = gtk.Align;
        };

        /// Whether to expand vertically. See `gtk.Widget.setVexpand`.
        pub const vexpand = struct {
            pub const name = "vexpand";

            pub const Type = c_int;
        };

        /// Whether to use the `gtk.Widget.properties.vexpand` property. See `gtk.Widget.getVexpandSet`.
        pub const vexpand_set = struct {
            pub const name = "vexpand-set";

            pub const Type = c_int;
        };

        pub const visible = struct {
            pub const name = "visible";

            pub const Type = c_int;
        };

        pub const width_request = struct {
            pub const name = "width-request";

            pub const Type = c_int;
        };

        /// The widget's window if it is realized, `NULL` otherwise.
        pub const window = struct {
            pub const name = "window";

            pub const Type = ?*gdk.Window;
        };
    };

    pub const signals = struct {
        pub const accel_closures_changed = struct {
            pub const name = "accel-closures-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("accel-closures-changed", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::button-press-event signal will be emitted when a button
        /// (typically from a mouse) is pressed.
        ///
        /// To receive this signal, the `gdk.Window` associated to the
        /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
        ///
        /// This signal will be sent to the grab widget if there is one.
        pub const button_press_event = struct {
            pub const name = "button-press-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventButton, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("button-press-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::button-release-event signal will be emitted when a button
        /// (typically from a mouse) is released.
        ///
        /// To receive this signal, the `gdk.Window` associated to the
        /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
        ///
        /// This signal will be sent to the grab widget if there is one.
        pub const button_release_event = struct {
            pub const name = "button-release-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventButton, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("button-release-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Determines whether an accelerator that activates the signal
        /// identified by `signal_id` can currently be activated.
        /// This signal is present to allow applications and derived
        /// widgets to override the default `gtk.Widget` handling
        /// for determining whether an accelerator can be activated.
        pub const can_activate_accel = struct {
            pub const name = "can-activate-accel";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_signal_id: c_uint, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("can-activate-accel", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::child-notify signal is emitted for each
        /// [child property][child-properties]  that has
        /// changed on an object. The signal's detail holds the property name.
        pub const child_notify = struct {
            pub const name = "child-notify";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_child_property: *gobject.ParamSpec, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("child-notify", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::composited-changed signal is emitted when the composited
        /// status of `widgets` screen changes.
        /// See `gdk.Screen.isComposited`.
        pub const composited_changed = struct {
            pub const name = "composited-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("composited-changed", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::configure-event signal will be emitted when the size, position or
        /// stacking of the `widget`'s window has changed.
        ///
        /// To receive this signal, the `gdk.Window` associated to the widget needs
        /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
        /// automatically for all new windows.
        pub const configure_event = struct {
            pub const name = "configure-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventConfigure, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("configure-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when a redirected window belonging to `widget` gets drawn into.
        /// The region/area members of the event shows what area of the redirected
        /// drawable was drawn into.
        pub const damage_event = struct {
            pub const name = "damage-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventExpose, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("damage-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::delete-event signal is emitted if a user requests that
        /// a toplevel window is closed. The default handler for this signal
        /// destroys the window. Connecting `gtk.Widget.hideOnDelete` to
        /// this signal will cause the window to be hidden instead, so that
        /// it can later be shown again without reconstructing it.
        pub const delete_event = struct {
            pub const name = "delete-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.Event, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("delete-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Signals that all holders of a reference to the widget should release
        /// the reference that they hold. May result in finalization of the widget
        /// if all references are released.
        ///
        /// This signal is not suitable for saving widget state.
        pub const destroy = struct {
            pub const name = "destroy";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("destroy", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::destroy-event signal is emitted when a `gdk.Window` is destroyed.
        /// You rarely get this signal, because most widgets disconnect themselves
        /// from their window before they destroy it, so no widget owns the
        /// window at destroy time.
        ///
        /// To receive this signal, the `gdk.Window` associated to the widget needs
        /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
        /// automatically for all new windows.
        pub const destroy_event = struct {
            pub const name = "destroy-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.Event, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("destroy-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::direction-changed signal is emitted when the text direction
        /// of a widget changes.
        pub const direction_changed = struct {
            pub const name = "direction-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_previous_direction: gtk.TextDirection, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("direction-changed", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::drag-begin signal is emitted on the drag source when a drag is
        /// started. A typical reason to connect to this signal is to set up a
        /// custom drag icon with e.g. `gtk.Widget.dragSourceSetIconPixbuf`.
        ///
        /// Note that some widgets set up a drag icon in the default handler of
        /// this signal, so you may have to use `g_signal_connect_after` to
        /// override what the default handler did.
        pub const drag_begin = struct {
            pub const name = "drag-begin";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gdk.DragContext, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("drag-begin", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::drag-data-delete signal is emitted on the drag source when a drag
        /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
        /// handler is responsible for deleting the data that has been dropped. What
        /// "delete" means depends on the context of the drag operation.
        pub const drag_data_delete = struct {
            pub const name = "drag-data-delete";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gdk.DragContext, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("drag-data-delete", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::drag-data-get signal is emitted on the drag source when the drop
        /// site requests the data which is dragged. It is the responsibility of
        /// the signal handler to fill `data` with the data in the format which
        /// is indicated by `info`. See `gtk.SelectionData.set` and
        /// `gtk.SelectionData.setText`.
        pub const drag_data_get = struct {
            pub const name = "drag-data-get";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gdk.DragContext, p_data: *gtk.SelectionData, p_info: c_uint, p_time: c_uint, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("drag-data-get", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::drag-data-received signal is emitted on the drop site when the
        /// dragged data has been received. If the data was received in order to
        /// determine whether the drop will be accepted, the handler is expected
        /// to call `gdk.dragStatus` and not finish the drag.
        /// If the data was received in response to a `gtk.Widget.signals.drag`-drop signal
        /// (and this is the last target to be received), the handler for this
        /// signal is expected to process the received data and then call
        /// `gtk.dragFinish`, setting the `success` parameter depending on
        /// whether the data was processed successfully.
        ///
        /// Applications must create some means to determine why the signal was emitted
        /// and therefore whether to call `gdk.dragStatus` or `gtk.dragFinish`.
        ///
        /// The handler may inspect the selected action with
        /// `gdk.DragContext.getSelectedAction` before calling
        /// `gtk.dragFinish`, e.g. to implement `GDK_ACTION_ASK` as
        /// shown in the following example:
        /// ```
        /// void
        /// drag_data_received (GtkWidget          *widget,
        ///                     GdkDragContext     *context,
        ///                     gint                x,
        ///                     gint                y,
        ///                     GtkSelectionData   *data,
        ///                     guint               info,
        ///                     guint               time)
        /// {
        ///   if ((data->length >= 0) && (data->format == 8))
        ///     {
        ///       GdkDragAction action;
        ///
        ///       // handle data here
        ///
        ///       action = gdk_drag_context_get_selected_action (context);
        ///       if (action == GDK_ACTION_ASK)
        ///         {
        ///           GtkWidget *dialog;
        ///           gint response;
        ///
        ///           dialog = gtk_message_dialog_new (NULL,
        ///                                            GTK_DIALOG_MODAL |
        ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
        ///                                            GTK_MESSAGE_INFO,
        ///                                            GTK_BUTTONS_YES_NO,
        ///                                            "Move the data ?\n");
        ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
        ///           gtk_widget_destroy (dialog);
        ///
        ///           if (response == GTK_RESPONSE_YES)
        ///             action = GDK_ACTION_MOVE;
        ///           else
        ///             action = GDK_ACTION_COPY;
        ///          }
        ///
        ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
        ///     }
        ///   else
        ///     gtk_drag_finish (context, FALSE, FALSE, time);
        ///  }
        /// ```
        pub const drag_data_received = struct {
            pub const name = "drag-data-received";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gdk.DragContext, p_x: c_int, p_y: c_int, p_data: *gtk.SelectionData, p_info: c_uint, p_time: c_uint, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("drag-data-received", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::drag-drop signal is emitted on the drop site when the user drops
        /// the data onto the widget. The signal handler must determine whether
        /// the cursor position is in a drop zone or not. If it is not in a drop
        /// zone, it returns `FALSE` and no further processing is necessary.
        /// Otherwise, the handler returns `TRUE`. In this case, the handler must
        /// ensure that `gtk.dragFinish` is called to let the source know that
        /// the drop is done. The call to `gtk.dragFinish` can be done either
        /// directly or in a `gtk.Widget.signals.drag`-data-received handler which gets
        /// triggered by calling `gtk.Widget.dragGetData` to receive the data for one
        /// or more of the supported targets.
        pub const drag_drop = struct {
            pub const name = "drag-drop";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gdk.DragContext, p_x: c_int, p_y: c_int, p_time: c_uint, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("drag-drop", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::drag-end signal is emitted on the drag source when a drag is
        /// finished.  A typical reason to connect to this signal is to undo
        /// things done in `gtk.Widget.signals.drag`-begin.
        pub const drag_end = struct {
            pub const name = "drag-end";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gdk.DragContext, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("drag-end", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::drag-failed signal is emitted on the drag source when a drag has
        /// failed. The signal handler may hook custom code to handle a failed DnD
        /// operation based on the type of error, it returns `TRUE` is the failure has
        /// been already handled (not showing the default "drag operation failed"
        /// animation), otherwise it returns `FALSE`.
        pub const drag_failed = struct {
            pub const name = "drag-failed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gdk.DragContext, p_result: gtk.DragResult, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("drag-failed", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::drag-leave signal is emitted on the drop site when the cursor
        /// leaves the widget. A typical reason to connect to this signal is to
        /// undo things done in `gtk.Widget.signals.drag`-motion, e.g. undo highlighting
        /// with `gtk.Widget.dragUnhighlight`.
        ///
        ///
        /// Likewise, the `gtk.Widget.signals.drag`-leave signal is also emitted before the
        /// ::drag-drop signal, for instance to allow cleaning up of a preview item
        /// created in the `gtk.Widget.signals.drag`-motion signal handler.
        pub const drag_leave = struct {
            pub const name = "drag-leave";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gdk.DragContext, p_time: c_uint, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("drag-leave", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::drag-motion signal is emitted on the drop site when the user
        /// moves the cursor over the widget during a drag. The signal handler
        /// must determine whether the cursor position is in a drop zone or not.
        /// If it is not in a drop zone, it returns `FALSE` and no further processing
        /// is necessary. Otherwise, the handler returns `TRUE`. In this case, the
        /// handler is responsible for providing the necessary information for
        /// displaying feedback to the user, by calling `gdk.dragStatus`.
        ///
        /// If the decision whether the drop will be accepted or rejected can't be
        /// made based solely on the cursor position and the type of the data, the
        /// handler may inspect the dragged data by calling `gtk.Widget.dragGetData` and
        /// defer the `gdk.dragStatus` call to the `gtk.Widget.signals.drag`-data-received
        /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
        /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk.Widget.dragDestSet`
        /// when using the drag-motion signal that way.
        ///
        /// Also note that there is no drag-enter signal. The drag receiver has to
        /// keep track of whether he has received any drag-motion signals since the
        /// last `gtk.Widget.signals.drag`-leave and if not, treat the drag-motion signal as
        /// an "enter" signal. Upon an "enter", the handler will typically highlight
        /// the drop site with `gtk.Widget.dragHighlight`.
        /// ```
        /// static void
        /// drag_motion (GtkWidget      *widget,
        ///              GdkDragContext *context,
        ///              gint            x,
        ///              gint            y,
        ///              guint           time)
        /// {
        ///   GdkAtom target;
        ///
        ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
        ///
        ///   if (!private_data->drag_highlight)
        ///    {
        ///      private_data->drag_highlight = 1;
        ///      gtk_drag_highlight (widget);
        ///    }
        ///
        ///   target = gtk_drag_dest_find_target (widget, context, NULL);
        ///   if (target == GDK_NONE)
        ///     gdk_drag_status (context, 0, time);
        ///   else
        ///    {
        ///      private_data->pending_status
        ///         = gdk_drag_context_get_suggested_action (context);
        ///      gtk_drag_get_data (widget, context, target, time);
        ///    }
        ///
        ///   return TRUE;
        /// }
        ///
        /// static void
        /// drag_data_received (GtkWidget        *widget,
        ///                     GdkDragContext   *context,
        ///                     gint              x,
        ///                     gint              y,
        ///                     GtkSelectionData *selection_data,
        ///                     guint             info,
        ///                     guint             time)
        /// {
        ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
        ///
        ///   if (private_data->suggested_action)
        ///    {
        ///      private_data->suggested_action = 0;
        ///
        ///      // We are getting this data due to a request in drag_motion,
        ///      // rather than due to a request in drag_drop, so we are just
        ///      // supposed to call `gdk.dragStatus`, not actually paste in
        ///      // the data.
        ///
        ///      str = gtk_selection_data_get_text (selection_data);
        ///      if (!data_is_acceptable (str))
        ///        gdk_drag_status (context, 0, time);
        ///      else
        ///        gdk_drag_status (context,
        ///                         private_data->suggested_action,
        ///                         time);
        ///    }
        ///   else
        ///    {
        ///      // accept the drop
        ///    }
        /// }
        /// ```
        pub const drag_motion = struct {
            pub const name = "drag-motion";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gdk.DragContext, p_x: c_int, p_y: c_int, p_time: c_uint, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("drag-motion", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when a widget is supposed to render itself.
        /// The `widget`'s top left corner must be painted at the origin of
        /// the passed in context and be sized to the values returned by
        /// `gtk.Widget.getAllocatedWidth` and
        /// `gtk.Widget.getAllocatedHeight`.
        ///
        /// Signal handlers connected to this signal can modify the cairo
        /// context passed as `cr` in any way they like and don't need to
        /// restore it. The signal emission takes care of calling `cairo_save`
        /// before and `cairo_restore` after invoking the handler.
        ///
        /// The signal handler will get a `cr` with a clip region already set to the
        /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
        /// widgets that want to avoid redrawing themselves completely can get the full
        /// extents of the clip region with `gdk.cairoGetClipRectangle`, or they can
        /// get a finer-grained representation of the dirty region with
        /// `cairo_copy_clip_rectangle_list`.
        pub const draw = struct {
            pub const name = "draw";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_cr: *cairo.Context, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("draw", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::enter-notify-event will be emitted when the pointer enters
        /// the `widget`'s window.
        ///
        /// To receive this signal, the `gdk.Window` associated to the widget needs
        /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
        ///
        /// This signal will be sent to the grab widget if there is one.
        pub const enter_notify_event = struct {
            pub const name = "enter-notify-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventCrossing, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("enter-notify-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The GTK+ main loop will emit three signals for each GDK event delivered
        /// to a widget: one generic ::event signal, another, more specific,
        /// signal that matches the type of event delivered (e.g.
        /// `gtk.Widget.signals.key`-press-event) and finally a generic
        /// `gtk.Widget.signals.event`-after signal.
        pub const event = struct {
            pub const name = "event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.Event, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// After the emission of the `gtk.Widget.signals.event` signal and (optionally)
        /// the second more specific signal, ::event-after will be emitted
        /// regardless of the previous two signals handlers return values.
        pub const event_after = struct {
            pub const name = "event-after";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.Event, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("event-after", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const focus = struct {
            pub const name = "focus";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_direction: gtk.DirectionType, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("focus", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::focus-in-event signal will be emitted when the keyboard focus
        /// enters the `widget`'s window.
        ///
        /// To receive this signal, the `gdk.Window` associated to the widget needs
        /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
        pub const focus_in_event = struct {
            pub const name = "focus-in-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventFocus, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("focus-in-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::focus-out-event signal will be emitted when the keyboard focus
        /// leaves the `widget`'s window.
        ///
        /// To receive this signal, the `gdk.Window` associated to the widget needs
        /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
        pub const focus_out_event = struct {
            pub const name = "focus-out-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventFocus, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("focus-out-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when a pointer or keyboard grab on a window belonging
        /// to `widget` gets broken.
        ///
        /// On X11, this happens when the grab window becomes unviewable
        /// (i.e. it or one of its ancestors is unmapped), or if the same
        /// application grabs the pointer or keyboard again.
        pub const grab_broken_event = struct {
            pub const name = "grab-broken-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventGrabBroken, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("grab-broken-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const grab_focus = struct {
            pub const name = "grab-focus";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("grab-focus", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::grab-notify signal is emitted when a widget becomes
        /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
        /// another widget, or when it becomes unshadowed due to a grab
        /// being removed.
        ///
        /// A widget is shadowed by a `gtk.Widget.grabAdd` when the topmost
        /// grab widget in the grab stack of its window group is not
        /// its ancestor.
        pub const grab_notify = struct {
            pub const name = "grab-notify";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_was_grabbed: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("grab-notify", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::hide signal is emitted when `widget` is hidden, for example with
        /// `gtk.Widget.hide`.
        pub const hide = struct {
            pub const name = "hide";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("hide", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::hierarchy-changed signal is emitted when the
        /// anchored state of a widget changes. A widget is
        /// “anchored” when its toplevel
        /// ancestor is a `gtk.Window`. This signal is emitted when
        /// a widget changes from un-anchored to anchored or vice-versa.
        pub const hierarchy_changed = struct {
            pub const name = "hierarchy-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_previous_toplevel: ?*gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("hierarchy-changed", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::key-press-event signal is emitted when a key is pressed. The signal
        /// emission will reoccur at the key-repeat rate when the key is kept pressed.
        ///
        /// To receive this signal, the `gdk.Window` associated to the widget needs
        /// to enable the `GDK_KEY_PRESS_MASK` mask.
        ///
        /// This signal will be sent to the grab widget if there is one.
        pub const key_press_event = struct {
            pub const name = "key-press-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventKey, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("key-press-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::key-release-event signal is emitted when a key is released.
        ///
        /// To receive this signal, the `gdk.Window` associated to the widget needs
        /// to enable the `GDK_KEY_RELEASE_MASK` mask.
        ///
        /// This signal will be sent to the grab widget if there is one.
        pub const key_release_event = struct {
            pub const name = "key-release-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventKey, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("key-release-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Gets emitted if keyboard navigation fails.
        /// See `gtk.Widget.keynavFailed` for details.
        pub const keynav_failed = struct {
            pub const name = "keynav-failed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_direction: gtk.DirectionType, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("keynav-failed", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::leave-notify-event will be emitted when the pointer leaves
        /// the `widget`'s window.
        ///
        /// To receive this signal, the `gdk.Window` associated to the widget needs
        /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
        ///
        /// This signal will be sent to the grab widget if there is one.
        pub const leave_notify_event = struct {
            pub const name = "leave-notify-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventCrossing, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("leave-notify-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::map signal is emitted when `widget` is going to be mapped, that is
        /// when the widget is visible (which is controlled with
        /// `gtk.Widget.setVisible`) and all its parents up to the toplevel widget
        /// are also visible. Once the map has occurred, `gtk.Widget.signals.map`-event will
        /// be emitted.
        ///
        /// The ::map signal can be used to determine whether a widget will be drawn,
        /// for instance it can resume an animation that was stopped during the
        /// emission of `gtk.Widget.signals.unmap`.
        pub const map = struct {
            pub const name = "map";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("map", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::map-event signal will be emitted when the `widget`'s window is
        /// mapped. A window is mapped when it becomes visible on the screen.
        ///
        /// To receive this signal, the `gdk.Window` associated to the widget needs
        /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
        /// automatically for all new windows.
        pub const map_event = struct {
            pub const name = "map-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventAny, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("map-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The default handler for this signal activates `widget` if `group_cycling`
        /// is `FALSE`, or just makes `widget` grab focus if `group_cycling` is `TRUE`.
        pub const mnemonic_activate = struct {
            pub const name = "mnemonic-activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_group_cycling: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("mnemonic-activate", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::motion-notify-event signal is emitted when the pointer moves
        /// over the widget's `gdk.Window`.
        ///
        /// To receive this signal, the `gdk.Window` associated to the widget
        /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
        ///
        /// This signal will be sent to the grab widget if there is one.
        pub const motion_notify_event = struct {
            pub const name = "motion-notify-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventMotion, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("motion-notify-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const move_focus = struct {
            pub const name = "move-focus";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_direction: gtk.DirectionType, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("move-focus", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::parent-set signal is emitted when a new parent
        /// has been set on a widget.
        pub const parent_set = struct {
            pub const name = "parent-set";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_old_parent: ?*gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("parent-set", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal gets emitted whenever a widget should pop up a context
        /// menu. This usually happens through the standard key binding mechanism;
        /// by pressing a certain key while a widget is focused, the user can cause
        /// the widget to pop up a menu.  For example, the `gtk.Entry` widget creates
        /// a menu with clipboard commands. See the
        /// [Popup Menu Migration Checklist][checklist-popup-menu]
        /// for an example of how to use this signal.
        pub const popup_menu = struct {
            pub const name = "popup-menu";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("popup-menu", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::property-notify-event signal will be emitted when a property on
        /// the `widget`'s window has been changed or deleted.
        ///
        /// To receive this signal, the `gdk.Window` associated to the widget needs
        /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
        pub const property_notify_event = struct {
            pub const name = "property-notify-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventProperty, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("property-notify-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// To receive this signal the `gdk.Window` associated to the widget needs
        /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
        ///
        /// This signal will be sent to the grab widget if there is one.
        pub const proximity_in_event = struct {
            pub const name = "proximity-in-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventProximity, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("proximity-in-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// To receive this signal the `gdk.Window` associated to the widget needs
        /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
        ///
        /// This signal will be sent to the grab widget if there is one.
        pub const proximity_out_event = struct {
            pub const name = "proximity-out-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventProximity, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("proximity-out-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when `gtk.Widget.properties.has`-tooltip is `TRUE` and the hover timeout
        /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
        /// focus in keyboard mode.
        ///
        /// Using the given coordinates, the signal handler should determine
        /// whether a tooltip should be shown for `widget`. If this is the case
        /// `TRUE` should be returned, `FALSE` otherwise.  Note that if
        /// `keyboard_mode` is `TRUE`, the values of `x` and `y` are undefined and
        /// should not be used.
        ///
        /// The signal handler is free to manipulate `tooltip` with the therefore
        /// destined function calls.
        pub const query_tooltip = struct {
            pub const name = "query-tooltip";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_x: c_int, p_y: c_int, p_keyboard_mode: c_int, p_tooltip: *gtk.Tooltip, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("query-tooltip", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::realize signal is emitted when `widget` is associated with a
        /// `gdk.Window`, which means that `gtk.Widget.realize` has been called or the
        /// widget has been mapped (that is, it is going to be drawn).
        pub const realize = struct {
            pub const name = "realize";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("realize", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::screen-changed signal gets emitted when the
        /// screen of a widget has changed.
        pub const screen_changed = struct {
            pub const name = "screen-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_previous_screen: ?*gdk.Screen, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("screen-changed", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::scroll-event signal is emitted when a button in the 4 to 7
        /// range is pressed. Wheel mice are usually configured to generate
        /// button press events for buttons 4 and 5 when the wheel is turned.
        ///
        /// To receive this signal, the `gdk.Window` associated to the widget needs
        /// to enable the `GDK_SCROLL_MASK` mask.
        ///
        /// This signal will be sent to the grab widget if there is one.
        pub const scroll_event = struct {
            pub const name = "scroll-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventScroll, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("scroll-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::selection-clear-event signal will be emitted when the
        /// the `widget`'s window has lost ownership of a selection.
        pub const selection_clear_event = struct {
            pub const name = "selection-clear-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventSelection, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("selection-clear-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const selection_get = struct {
            pub const name = "selection-get";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_data: *gtk.SelectionData, p_info: c_uint, p_time: c_uint, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("selection-get", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const selection_notify_event = struct {
            pub const name = "selection-notify-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventSelection, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("selection-notify-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const selection_received = struct {
            pub const name = "selection-received";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_data: *gtk.SelectionData, p_time: c_uint, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("selection-received", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::selection-request-event signal will be emitted when
        /// another client requests ownership of the selection owned by
        /// the `widget`'s window.
        pub const selection_request_event = struct {
            pub const name = "selection-request-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventSelection, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("selection-request-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::show signal is emitted when `widget` is shown, for example with
        /// `gtk.Widget.show`.
        pub const show = struct {
            pub const name = "show";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("show", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const show_help = struct {
            pub const name = "show-help";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_help_type: gtk.WidgetHelpType, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("show-help", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const size_allocate = struct {
            pub const name = "size-allocate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_allocation: *gtk.Allocation, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("size-allocate", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::state-changed signal is emitted when the widget state changes.
        /// See `gtk.Widget.getState`.
        pub const state_changed = struct {
            pub const name = "state-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_state: gtk.StateType, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("state-changed", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::state-flags-changed signal is emitted when the widget state
        /// changes, see `gtk.Widget.getStateFlags`.
        pub const state_flags_changed = struct {
            pub const name = "state-flags-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_flags: gtk.StateFlags, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("state-flags-changed", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::style-set signal is emitted when a new style has been set
        /// on a widget. Note that style-modifying functions like
        /// `gtk.Widget.modifyBase` also cause this signal to be emitted.
        ///
        /// Note that this signal is emitted for changes to the deprecated
        /// `gtk.Style`. To track changes to the `gtk.StyleContext` associated
        /// with a widget, use the `gtk.Widget.signals.style`-updated signal.
        pub const style_set = struct {
            pub const name = "style-set";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_previous_style: ?*gtk.Style, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("style-set", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::style-updated signal is a convenience signal that is emitted when the
        /// `gtk.StyleContext.signals.changed` signal is emitted on the `widget`'s associated
        /// `gtk.StyleContext` as returned by `gtk.Widget.getStyleContext`.
        ///
        /// Note that style-modifying functions like `gtk.Widget.overrideColor` also
        /// cause this signal to be emitted.
        pub const style_updated = struct {
            pub const name = "style-updated";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("style-updated", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        pub const touch_event = struct {
            pub const name = "touch-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: *gdk.Event, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("touch-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::unmap signal is emitted when `widget` is going to be unmapped, which
        /// means that either it or any of its parents up to the toplevel widget have
        /// been set as hidden.
        ///
        /// As ::unmap indicates that a widget will not be shown any longer, it can be
        /// used to, for example, stop an animation on the widget.
        pub const unmap = struct {
            pub const name = "unmap";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("unmap", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::unmap-event signal will be emitted when the `widget`'s window is
        /// unmapped. A window is unmapped when it becomes invisible on the screen.
        ///
        /// To receive this signal, the `gdk.Window` associated to the widget needs
        /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
        /// automatically for all new windows.
        pub const unmap_event = struct {
            pub const name = "unmap-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventAny, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("unmap-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::unrealize signal is emitted when the `gdk.Window` associated with
        /// `widget` is destroyed, which means that `gtk.Widget.unrealize` has been
        /// called or the widget has been unmapped (that is, it is going to be
        /// hidden).
        pub const unrealize = struct {
            pub const name = "unrealize";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("unrealize", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::visibility-notify-event will be emitted when the `widget`'s
        /// window is obscured or unobscured.
        ///
        /// To receive this signal the `gdk.Window` associated to the widget needs
        /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
        pub const visibility_notify_event = struct {
            pub const name = "visibility-notify-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventVisibility, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("visibility-notify-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::window-state-event will be emitted when the state of the
        /// toplevel window associated to the `widget` changes.
        ///
        /// To receive this signal the `gdk.Window` associated to the widget
        /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
        /// this mask automatically for all new windows.
        pub const window_state_event = struct {
            pub const name = "window-state-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: *gdk.EventWindowState, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Widget, p_instance))),
                    gobject.signalLookup("window-state-event", Widget.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Obtains the current default reading direction. See
    /// `gtk.Widget.setDefaultDirection`.
    extern fn gtk_widget_get_default_direction() gtk.TextDirection;
    pub const getDefaultDirection = gtk_widget_get_default_direction;

    /// Returns the default style used by all widgets initially.
    extern fn gtk_widget_get_default_style() *gtk.Style;
    pub const getDefaultStyle = gtk_widget_get_default_style;

    /// Cancels the effect of a previous call to `gtk.Widget.pushCompositeChild`.
    extern fn gtk_widget_pop_composite_child() void;
    pub const popCompositeChild = gtk_widget_pop_composite_child;

    /// Makes all newly-created widgets as composite children until
    /// the corresponding `gtk.Widget.popCompositeChild` call.
    ///
    /// A composite child is a child that’s an implementation detail of the
    /// container it’s inside and should not be visible to people using the
    /// container. Composite children aren’t treated differently by GTK+ (but
    /// see `gtk.Container.foreach` vs. `gtk.Container.forall`), but e.g. GUI
    /// builders might want to treat them in a different way.
    extern fn gtk_widget_push_composite_child() void;
    pub const pushCompositeChild = gtk_widget_push_composite_child;

    /// Sets the default reading direction for widgets where the
    /// direction has not been explicitly set by `gtk.Widget.setDirection`.
    extern fn gtk_widget_set_default_direction(p_dir: gtk.TextDirection) void;
    pub const setDefaultDirection = gtk_widget_set_default_direction;

    /// This is a convenience function for creating a widget and setting
    /// its properties in one go. For example you might write:
    /// `gtk_widget_new (GTK_TYPE_LABEL, "label", "Hello World", "xalign",
    /// 0.0, NULL)` to create a left-aligned label. Equivalent to
    /// `gobject.Object.new`, but returns a widget so you don’t have to
    /// cast the object yourself.
    extern fn gtk_widget_new(p_type: usize, p_first_property_name: [*:0]const u8, ...) *gtk.Widget;
    pub const new = gtk_widget_new;

    /// For widgets that can be “activated” (buttons, menu items, etc.)
    /// this function activates them. Activation is what happens when you
    /// press Enter on a widget during key navigation. If `widget` isn't
    /// activatable, the function returns `FALSE`.
    extern fn gtk_widget_activate(p_widget: *Widget) c_int;
    pub const activate = gtk_widget_activate;

    /// Installs an accelerator for this `widget` in `accel_group` that causes
    /// `accel_signal` to be emitted if the accelerator is activated.
    /// The `accel_group` needs to be added to the widget’s toplevel via
    /// `gtk.Window.addAccelGroup`, and the signal must be of type `G_SIGNAL_ACTION`.
    /// Accelerators added through this function are not user changeable during
    /// runtime. If you want to support accelerators that can be changed by the
    /// user, use `gtk.AccelMap.addEntry` and `gtk.Widget.setAccelPath` or
    /// `gtk.MenuItem.setAccelPath` instead.
    extern fn gtk_widget_add_accelerator(p_widget: *Widget, p_accel_signal: [*:0]const u8, p_accel_group: *gtk.AccelGroup, p_accel_key: c_uint, p_accel_mods: gdk.ModifierType, p_accel_flags: gtk.AccelFlags) void;
    pub const addAccelerator = gtk_widget_add_accelerator;

    /// Adds the device events in the bitfield `events` to the event mask for
    /// `widget`. See `gtk.Widget.setDeviceEvents` for details.
    extern fn gtk_widget_add_device_events(p_widget: *Widget, p_device: *gdk.Device, p_events: gdk.EventMask) void;
    pub const addDeviceEvents = gtk_widget_add_device_events;

    /// Adds the events in the bitfield `events` to the event mask for
    /// `widget`. See `gtk.Widget.setEvents` and the
    /// [input handling overview][event-masks] for details.
    extern fn gtk_widget_add_events(p_widget: *Widget, p_events: c_int) void;
    pub const addEvents = gtk_widget_add_events;

    /// Adds a widget to the list of mnemonic labels for
    /// this widget. (See `gtk.Widget.listMnemonicLabels`). Note the
    /// list of mnemonic labels for the widget is cleared when the
    /// widget is destroyed, so the caller must make sure to update
    /// its internal state at this point as well, by using a connection
    /// to the `gtk.Widget.signals.destroy` signal or a weak notifier.
    extern fn gtk_widget_add_mnemonic_label(p_widget: *Widget, p_label: *gtk.Widget) void;
    pub const addMnemonicLabel = gtk_widget_add_mnemonic_label;

    /// Queues an animation frame update and adds a callback to be called
    /// before each frame. Until the tick callback is removed, it will be
    /// called frequently (usually at the frame rate of the output device
    /// or as quickly as the application can be repainted, whichever is
    /// slower). For this reason, is most suitable for handling graphics
    /// that change every frame or every few frames. The tick callback does
    /// not automatically imply a relayout or repaint. If you want a
    /// repaint or relayout, and aren’t changing widget properties that
    /// would trigger that (for example, changing the text of a `gtk.Label`),
    /// then you will have to call `gtk.Widget.queueResize` or
    /// `gtk.Widget.queueDrawArea` yourself.
    ///
    /// `gdk.FrameClock.getFrameTime` should generally be used for timing
    /// continuous animations and
    /// `gdk.FrameTimings.getPredictedPresentationTime` if you are
    /// trying to display isolated frames at particular times.
    ///
    /// This is a more convenient alternative to connecting directly to the
    /// `gdk.FrameClock.signals.update` signal of `gdk.FrameClock`, since you don't
    /// have to worry about when a `gdk.FrameClock` is assigned to a widget.
    extern fn gtk_widget_add_tick_callback(p_widget: *Widget, p_callback: gtk.TickCallback, p_user_data: ?*anyopaque, p_notify: ?glib.DestroyNotify) c_uint;
    pub const addTickCallback = gtk_widget_add_tick_callback;

    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This is done by emitting the `gtk.Widget.signals.can`-activate-accel
    /// signal on `widget`; if the signal isn’t overridden by a
    /// handler or in a derived widget, then the default check is
    /// that the widget must be sensitive, and the widget and all
    /// its ancestors mapped.
    extern fn gtk_widget_can_activate_accel(p_widget: *Widget, p_signal_id: c_uint) c_int;
    pub const canActivateAccel = gtk_widget_can_activate_accel;

    /// This function is used by custom widget implementations; if you're
    /// writing an app, you’d use `gtk.Widget.grabFocus` to move the focus
    /// to a particular widget, and `gtk.Container.setFocusChain` to
    /// change the focus tab order. So you may want to investigate those
    /// functions instead.
    ///
    /// `gtk.Widget.childFocus` is called by containers as the user moves
    /// around the window using keyboard shortcuts. `direction` indicates
    /// what kind of motion is taking place (up, down, left, right, tab
    /// forward, tab backward). `gtk.Widget.childFocus` emits the
    /// `gtk.Widget.signals.focus` signal; widgets override the default handler
    /// for this signal in order to implement appropriate focus behavior.
    ///
    /// The default ::focus handler for a widget should return `TRUE` if
    /// moving in `direction` left the focus on a focusable location inside
    /// that widget, and `FALSE` if moving in `direction` moved the focus
    /// outside the widget. If returning `TRUE`, widgets normally
    /// call `gtk.Widget.grabFocus` to place the focus accordingly;
    /// if returning `FALSE`, they don’t modify the current focus location.
    extern fn gtk_widget_child_focus(p_widget: *Widget, p_direction: gtk.DirectionType) c_int;
    pub const childFocus = gtk_widget_child_focus;

    /// Emits a `gtk.Widget.signals.child`-notify signal for the
    /// [child property][child-properties] `child_property`
    /// on `widget`.
    ///
    /// This is the analogue of `gobject.Object.notify` for child properties.
    ///
    /// Also see `gtk.Container.childNotify`.
    extern fn gtk_widget_child_notify(p_widget: *Widget, p_child_property: [*:0]const u8) void;
    pub const childNotify = gtk_widget_child_notify;

    /// Same as `gtk.Widget.path`, but always uses the name of a widget’s type,
    /// never uses a custom name set with `gtk.Widget.setName`.
    extern fn gtk_widget_class_path(p_widget: *Widget, p_path_length: ?*c_uint, p_path: ?*[*:0]u8, p_path_reversed: ?*[*:0]u8) void;
    pub const classPath = gtk_widget_class_path;

    /// Computes whether a container should give this widget extra space
    /// when possible. Containers should check this, rather than
    /// looking at `gtk.Widget.getHexpand` or `gtk.Widget.getVexpand`.
    ///
    /// This function already checks whether the widget is visible, so
    /// visibility does not need to be checked separately. Non-visible
    /// widgets are not expanded.
    ///
    /// The computed expand value uses either the expand setting explicitly
    /// set on the widget itself, or, if none has been explicitly set,
    /// the widget may expand if some of its children do.
    extern fn gtk_widget_compute_expand(p_widget: *Widget, p_orientation: gtk.Orientation) c_int;
    pub const computeExpand = gtk_widget_compute_expand;

    /// Creates a new `pango.Context` with the appropriate font map,
    /// font options, font description, and base direction for drawing
    /// text for this widget. See also `gtk.Widget.getPangoContext`.
    extern fn gtk_widget_create_pango_context(p_widget: *Widget) *pango.Context;
    pub const createPangoContext = gtk_widget_create_pango_context;

    /// Creates a new `pango.Layout` with the appropriate font map,
    /// font description, and base direction for drawing text for
    /// this widget.
    ///
    /// If you keep a `pango.Layout` created in this way around, you need
    /// to re-create it when the widget `pango.Context` is replaced.
    /// This can be tracked by using the `gtk.Widget.signals.screen`-changed signal
    /// on the widget.
    extern fn gtk_widget_create_pango_layout(p_widget: *Widget, p_text: ?[*:0]const u8) *pango.Layout;
    pub const createPangoLayout = gtk_widget_create_pango_layout;

    /// Destroys a widget.
    ///
    /// When a widget is destroyed all references it holds on other objects
    /// will be released:
    ///
    ///  - if the widget is inside a container, it will be removed from its
    ///  parent
    ///  - if the widget is a container, all its children will be destroyed,
    ///  recursively
    ///  - if the widget is a top level, it will be removed from the list
    ///  of top level widgets that GTK+ maintains internally
    ///
    /// It's expected that all references held on the widget will also
    /// be released; you should connect to the `gtk.Widget.signals.destroy` signal
    /// if you hold a reference to `widget` and you wish to remove it when
    /// this function is called. It is not necessary to do so if you are
    /// implementing a `gtk.Container`, as you'll be able to use the
    /// `gtk.ContainerClass.virtual_methods.remove` virtual function for that.
    ///
    /// It's important to notice that `gtk.Widget.destroy` will only cause
    /// the `widget` to be finalized if no additional references, acquired
    /// using `gobject.Object.ref`, are held on it. In case additional references
    /// are in place, the `widget` will be in an "inert" state after calling
    /// this function; `widget` will still point to valid memory, allowing you
    /// to release the references you hold, but you may not query the widget's
    /// own state.
    ///
    /// You should typically call this function on top level widgets, and
    /// rarely on child widgets.
    ///
    /// See also: `gtk.Container.remove`
    extern fn gtk_widget_destroy(p_widget: *Widget) void;
    pub const destroy = gtk_widget_destroy;

    /// This function sets *`widget_pointer` to `NULL` if `widget_pointer` !=
    /// `NULL`.  It’s intended to be used as a callback connected to the
    /// “destroy” signal of a widget. You connect `gtk.Widget.destroyed`
    /// as a signal handler, and pass the address of your widget variable
    /// as user data. Then when the widget is destroyed, the variable will
    /// be set to `NULL`. Useful for example to avoid multiple copies
    /// of the same dialog.
    extern fn gtk_widget_destroyed(p_widget: *Widget, p_widget_pointer: **gtk.Widget) void;
    pub const destroyed = gtk_widget_destroyed;

    /// Returns `TRUE` if `device` has been shadowed by a GTK+
    /// device grab on another widget, so it would stop sending
    /// events to `widget`. This may be used in the
    /// `gtk.Widget.signals.grab`-notify signal to check for specific
    /// devices. See `gtk.deviceGrabAdd`.
    extern fn gtk_widget_device_is_shadowed(p_widget: *Widget, p_device: *gdk.Device) c_int;
    pub const deviceIsShadowed = gtk_widget_device_is_shadowed;

    /// This function is equivalent to `gtk.Widget.dragBeginWithCoordinates`,
    /// passing -1, -1 as coordinates.
    extern fn gtk_drag_begin(p_widget: *Widget, p_targets: *gtk.TargetList, p_actions: gdk.DragAction, p_button: c_int, p_event: ?*gdk.Event) *gdk.DragContext;
    pub const dragBegin = gtk_drag_begin;

    /// Initiates a drag on the source side. The function only needs to be used
    /// when the application is starting drags itself, and is not needed when
    /// `gtk.Widget.dragSourceSet` is used.
    ///
    /// The `event` is used to retrieve the timestamp that will be used internally to
    /// grab the pointer.  If `event` is `NULL`, then `GDK_CURRENT_TIME` will be used.
    /// However, you should try to pass a real event in all cases, since that can be
    /// used to get information about the drag.
    ///
    /// Generally there are three cases when you want to start a drag by hand by
    /// calling this function:
    ///
    /// 1. During a `gtk.Widget.signals.button`-press-event handler, if you want to start a drag
    /// immediately when the user presses the mouse button.  Pass the `event`
    /// that you have in your `gtk.Widget.signals.button`-press-event handler.
    ///
    /// 2. During a `gtk.Widget.signals.motion`-notify-event handler, if you want to start a drag
    /// when the mouse moves past a certain threshold distance after a button-press.
    /// Pass the `event` that you have in your `gtk.Widget.signals.motion`-notify-event handler.
    ///
    /// 3. During a timeout handler, if you want to start a drag after the mouse
    /// button is held down for some time.  Try to save the last event that you got
    /// from the mouse, using `gdk.Event.copy`, and pass it to this function
    /// (remember to free the event with `gdk.Event.free` when you are done).
    /// If you really cannot pass a real event, pass `NULL` instead.
    extern fn gtk_drag_begin_with_coordinates(p_widget: *Widget, p_targets: *gtk.TargetList, p_actions: gdk.DragAction, p_button: c_int, p_event: ?*gdk.Event, p_x: c_int, p_y: c_int) *gdk.DragContext;
    pub const dragBeginWithCoordinates = gtk_drag_begin_with_coordinates;

    /// Checks to see if a mouse drag starting at (`start_x`, `start_y`) and ending
    /// at (`current_x`, `current_y`) has passed the GTK+ drag threshold, and thus
    /// should trigger the beginning of a drag-and-drop operation.
    extern fn gtk_drag_check_threshold(p_widget: *Widget, p_start_x: c_int, p_start_y: c_int, p_current_x: c_int, p_current_y: c_int) c_int;
    pub const dragCheckThreshold = gtk_drag_check_threshold;

    /// Add the image targets supported by `gtk.SelectionData` to
    /// the target list of the drag destination. The targets
    /// are added with `info` = 0. If you need another value,
    /// use `gtk.TargetList.addImageTargets` and
    /// `gtk.Widget.dragDestSetTargetList`.
    extern fn gtk_drag_dest_add_image_targets(p_widget: *Widget) void;
    pub const dragDestAddImageTargets = gtk_drag_dest_add_image_targets;

    /// Add the text targets supported by `gtk.SelectionData` to
    /// the target list of the drag destination. The targets
    /// are added with `info` = 0. If you need another value,
    /// use `gtk.TargetList.addTextTargets` and
    /// `gtk.Widget.dragDestSetTargetList`.
    extern fn gtk_drag_dest_add_text_targets(p_widget: *Widget) void;
    pub const dragDestAddTextTargets = gtk_drag_dest_add_text_targets;

    /// Add the URI targets supported by `gtk.SelectionData` to
    /// the target list of the drag destination. The targets
    /// are added with `info` = 0. If you need another value,
    /// use `gtk.TargetList.addUriTargets` and
    /// `gtk.Widget.dragDestSetTargetList`.
    extern fn gtk_drag_dest_add_uri_targets(p_widget: *Widget) void;
    pub const dragDestAddUriTargets = gtk_drag_dest_add_uri_targets;

    /// Looks for a match between the supported targets of `context` and the
    /// `dest_target_list`, returning the first matching target, otherwise
    /// returning `GDK_NONE`. `dest_target_list` should usually be the return
    /// value from `gtk.Widget.dragDestGetTargetList`, but some widgets may
    /// have different valid targets for different parts of the widget; in
    /// that case, they will have to implement a drag_motion handler that
    /// passes the correct target list to this function.
    extern fn gtk_drag_dest_find_target(p_widget: *Widget, p_context: *gdk.DragContext, p_target_list: ?*gtk.TargetList) gdk.Atom;
    pub const dragDestFindTarget = gtk_drag_dest_find_target;

    /// Returns the list of targets this widget can accept from
    /// drag-and-drop.
    extern fn gtk_drag_dest_get_target_list(p_widget: *Widget) ?*gtk.TargetList;
    pub const dragDestGetTargetList = gtk_drag_dest_get_target_list;

    /// Returns whether the widget has been configured to always
    /// emit `gtk.Widget.signals.drag`-motion signals.
    extern fn gtk_drag_dest_get_track_motion(p_widget: *Widget) c_int;
    pub const dragDestGetTrackMotion = gtk_drag_dest_get_track_motion;

    /// Sets a widget as a potential drop destination, and adds default behaviors.
    ///
    /// The default behaviors listed in `flags` have an effect similar
    /// to installing default handlers for the widget’s drag-and-drop signals
    /// (`gtk.Widget.signals.drag`-motion, `gtk.Widget.signals.drag`-drop, ...). They all exist
    /// for convenience. When passing `GTK_DEST_DEFAULT_ALL` for instance it is
    /// sufficient to connect to the widget’s `gtk.Widget.signals.drag`-data-received
    /// signal to get primitive, but consistent drag-and-drop support.
    ///
    /// Things become more complicated when you try to preview the dragged data,
    /// as described in the documentation for `gtk.Widget.signals.drag`-motion. The default
    /// behaviors described by `flags` make some assumptions, that can conflict
    /// with your own signal handlers. For instance `GTK_DEST_DEFAULT_DROP` causes
    /// invokations of `gdk.dragStatus` in the context of `gtk.Widget.signals.drag`-motion,
    /// and invokations of `gtk.dragFinish` in `gtk.Widget.signals.drag`-data-received.
    /// Especially the later is dramatic, when your own `gtk.Widget.signals.drag`-motion
    /// handler calls `gtk.Widget.dragGetData` to inspect the dragged data.
    ///
    /// There’s no way to set a default action here, you can use the
    /// `gtk.Widget.signals.drag`-motion callback for that. Here’s an example which selects
    /// the action to use depending on whether the control key is pressed or not:
    /// ```
    /// static void
    /// drag_motion (GtkWidget *widget,
    ///              GdkDragContext *context,
    ///              gint x,
    ///              gint y,
    ///              guint time)
    /// {
    ///   GdkModifierType mask;
    ///
    ///   gdk_window_get_pointer (gtk_widget_get_window (widget),
    ///                           NULL, NULL, &mask);
    ///   if (mask & GDK_CONTROL_MASK)
    ///     gdk_drag_status (context, GDK_ACTION_COPY, time);
    ///   else
    ///     gdk_drag_status (context, GDK_ACTION_MOVE, time);
    /// }
    /// ```
    extern fn gtk_drag_dest_set(p_widget: *Widget, p_flags: gtk.DestDefaults, p_targets: ?[*]const gtk.TargetEntry, p_n_targets: c_int, p_actions: gdk.DragAction) void;
    pub const dragDestSet = gtk_drag_dest_set;

    /// Sets this widget as a proxy for drops to another window.
    extern fn gtk_drag_dest_set_proxy(p_widget: *Widget, p_proxy_window: *gdk.Window, p_protocol: gdk.DragProtocol, p_use_coordinates: c_int) void;
    pub const dragDestSetProxy = gtk_drag_dest_set_proxy;

    /// Sets the target types that this widget can accept from drag-and-drop.
    /// The widget must first be made into a drag destination with
    /// `gtk.Widget.dragDestSet`.
    extern fn gtk_drag_dest_set_target_list(p_widget: *Widget, p_target_list: ?*gtk.TargetList) void;
    pub const dragDestSetTargetList = gtk_drag_dest_set_target_list;

    /// Tells the widget to emit `gtk.Widget.signals.drag`-motion and
    /// `gtk.Widget.signals.drag`-leave events regardless of the targets and the
    /// `GTK_DEST_DEFAULT_MOTION` flag.
    ///
    /// This may be used when a widget wants to do generic
    /// actions regardless of the targets that the source offers.
    extern fn gtk_drag_dest_set_track_motion(p_widget: *Widget, p_track_motion: c_int) void;
    pub const dragDestSetTrackMotion = gtk_drag_dest_set_track_motion;

    /// Clears information about a drop destination set with
    /// `gtk.Widget.dragDestSet`. The widget will no longer receive
    /// notification of drags.
    extern fn gtk_drag_dest_unset(p_widget: *Widget) void;
    pub const dragDestUnset = gtk_drag_dest_unset;

    /// Gets the data associated with a drag. When the data
    /// is received or the retrieval fails, GTK+ will emit a
    /// `gtk.Widget.signals.drag`-data-received signal. Failure of the retrieval
    /// is indicated by the length field of the `selection_data`
    /// signal parameter being negative. However, when `gtk.Widget.dragGetData`
    /// is called implicitely because the `GTK_DEST_DEFAULT_DROP` was set,
    /// then the widget will not receive notification of failed
    /// drops.
    extern fn gtk_drag_get_data(p_widget: *Widget, p_context: *gdk.DragContext, p_target: gdk.Atom, p_time_: u32) void;
    pub const dragGetData = gtk_drag_get_data;

    /// Highlights a widget as a currently hovered drop target.
    /// To end the highlight, call `gtk.Widget.dragUnhighlight`.
    /// GTK+ calls this automatically if `GTK_DEST_DEFAULT_HIGHLIGHT` is set.
    extern fn gtk_drag_highlight(p_widget: *Widget) void;
    pub const dragHighlight = gtk_drag_highlight;

    /// Add the writable image targets supported by `gtk.SelectionData` to
    /// the target list of the drag source. The targets
    /// are added with `info` = 0. If you need another value,
    /// use `gtk.TargetList.addImageTargets` and
    /// `gtk.Widget.dragSourceSetTargetList`.
    extern fn gtk_drag_source_add_image_targets(p_widget: *Widget) void;
    pub const dragSourceAddImageTargets = gtk_drag_source_add_image_targets;

    /// Add the text targets supported by `gtk.SelectionData` to
    /// the target list of the drag source.  The targets
    /// are added with `info` = 0. If you need another value,
    /// use `gtk.TargetList.addTextTargets` and
    /// `gtk.Widget.dragSourceSetTargetList`.
    extern fn gtk_drag_source_add_text_targets(p_widget: *Widget) void;
    pub const dragSourceAddTextTargets = gtk_drag_source_add_text_targets;

    /// Add the URI targets supported by `gtk.SelectionData` to
    /// the target list of the drag source.  The targets
    /// are added with `info` = 0. If you need another value,
    /// use `gtk.TargetList.addUriTargets` and
    /// `gtk.Widget.dragSourceSetTargetList`.
    extern fn gtk_drag_source_add_uri_targets(p_widget: *Widget) void;
    pub const dragSourceAddUriTargets = gtk_drag_source_add_uri_targets;

    /// Gets the list of targets this widget can provide for
    /// drag-and-drop.
    extern fn gtk_drag_source_get_target_list(p_widget: *Widget) ?*gtk.TargetList;
    pub const dragSourceGetTargetList = gtk_drag_source_get_target_list;

    /// Sets up a widget so that GTK+ will start a drag operation when the user
    /// clicks and drags on the widget. The widget must have a window.
    extern fn gtk_drag_source_set(p_widget: *Widget, p_start_button_mask: gdk.ModifierType, p_targets: ?[*]const gtk.TargetEntry, p_n_targets: c_int, p_actions: gdk.DragAction) void;
    pub const dragSourceSet = gtk_drag_source_set;

    /// Sets the icon that will be used for drags from a particular source
    /// to `icon`. See the docs for `gtk.IconTheme` for more details.
    extern fn gtk_drag_source_set_icon_gicon(p_widget: *Widget, p_icon: *gio.Icon) void;
    pub const dragSourceSetIconGicon = gtk_drag_source_set_icon_gicon;

    /// Sets the icon that will be used for drags from a particular source
    /// to a themed icon. See the docs for `gtk.IconTheme` for more details.
    extern fn gtk_drag_source_set_icon_name(p_widget: *Widget, p_icon_name: [*:0]const u8) void;
    pub const dragSourceSetIconName = gtk_drag_source_set_icon_name;

    /// Sets the icon that will be used for drags from a particular widget
    /// from a `gdkpixbuf.Pixbuf`. GTK+ retains a reference for `pixbuf` and will
    /// release it when it is no longer needed.
    extern fn gtk_drag_source_set_icon_pixbuf(p_widget: *Widget, p_pixbuf: *gdkpixbuf.Pixbuf) void;
    pub const dragSourceSetIconPixbuf = gtk_drag_source_set_icon_pixbuf;

    /// Sets the icon that will be used for drags from a particular source
    /// to a stock icon.
    extern fn gtk_drag_source_set_icon_stock(p_widget: *Widget, p_stock_id: [*:0]const u8) void;
    pub const dragSourceSetIconStock = gtk_drag_source_set_icon_stock;

    /// Changes the target types that this widget offers for drag-and-drop.
    /// The widget must first be made into a drag source with
    /// `gtk.Widget.dragSourceSet`.
    extern fn gtk_drag_source_set_target_list(p_widget: *Widget, p_target_list: ?*gtk.TargetList) void;
    pub const dragSourceSetTargetList = gtk_drag_source_set_target_list;

    /// Undoes the effects of `gtk.Widget.dragSourceSet`.
    extern fn gtk_drag_source_unset(p_widget: *Widget) void;
    pub const dragSourceUnset = gtk_drag_source_unset;

    /// Removes a highlight set by `gtk.Widget.dragHighlight` from
    /// a widget.
    extern fn gtk_drag_unhighlight(p_widget: *Widget) void;
    pub const dragUnhighlight = gtk_drag_unhighlight;

    /// Draws `widget` to `cr`. The top left corner of the widget will be
    /// drawn to the currently set origin point of `cr`.
    ///
    /// You should pass a cairo context as `cr` argument that is in an
    /// original state. Otherwise the resulting drawing is undefined. For
    /// example changing the operator using `cairo_set_operator` or the
    /// line width using `cairo_set_line_width` might have unwanted side
    /// effects.
    /// You may however change the context’s transform matrix - like with
    /// `cairo_scale`, `cairo_translate` or `cairo_set_matrix` and clip
    /// region with `cairo_clip` prior to calling this function. Also, it
    /// is fine to modify the context with `cairo_save` and
    /// `cairo_push_group` prior to calling this function.
    ///
    /// Note that special-purpose widgets may contain special code for
    /// rendering to the screen and might appear differently on screen
    /// and when rendered using `gtk.Widget.draw`.
    extern fn gtk_widget_draw(p_widget: *Widget, p_cr: *cairo.Context) void;
    pub const draw = gtk_widget_draw;

    /// Ensures that `widget` has a style (`widget`->style).
    ///
    /// Not a very useful function; most of the time, if you
    /// want the style, the widget is realized, and realized
    /// widgets are guaranteed to have a style already.
    extern fn gtk_widget_ensure_style(p_widget: *Widget) void;
    pub const ensureStyle = gtk_widget_ensure_style;

    /// Notifies the user about an input-related error on this widget.
    /// If the `gtk.Settings.properties.gtk`-error-bell setting is `TRUE`, it calls
    /// `gdk.Window.beep`, otherwise it does nothing.
    ///
    /// Note that the effect of `gdk.Window.beep` can be configured in many
    /// ways, depending on the windowing backend and the desktop environment
    /// or window manager that is used.
    extern fn gtk_widget_error_bell(p_widget: *Widget) void;
    pub const errorBell = gtk_widget_error_bell;

    /// Rarely-used function. This function is used to emit
    /// the event signals on a widget (those signals should never
    /// be emitted without using this function to do so).
    /// If you want to synthesize an event though, don’t use this function;
    /// instead, use `gtk.mainDoEvent` so the event will behave as if
    /// it were in the event queue. Don’t synthesize expose events; instead,
    /// use `gdk.Window.invalidateRect` to invalidate a region of the
    /// window.
    extern fn gtk_widget_event(p_widget: *Widget, p_event: *gdk.Event) c_int;
    pub const event = gtk_widget_event;

    /// Stops emission of `gtk.Widget.signals.child`-notify signals on `widget`. The
    /// signals are queued until `gtk.Widget.thawChildNotify` is called
    /// on `widget`.
    ///
    /// This is the analogue of `gobject.Object.freezeNotify` for child properties.
    extern fn gtk_widget_freeze_child_notify(p_widget: *Widget) void;
    pub const freezeChildNotify = gtk_widget_freeze_child_notify;

    /// Returns the accessible object that describes the widget to an
    /// assistive technology.
    ///
    /// If accessibility support is not available, this `atk.Object`
    /// instance may be a no-op. Likewise, if no class-specific `atk.Object`
    /// implementation is available for the widget instance in question,
    /// it will inherit an `atk.Object` implementation from the first ancestor
    /// class for which such an implementation is defined.
    ///
    /// The documentation of the
    /// [ATK](http://developer.gnome.org/atk/stable/)
    /// library contains more information about accessible objects and their uses.
    extern fn gtk_widget_get_accessible(p_widget: *Widget) *atk.Object;
    pub const getAccessible = gtk_widget_get_accessible;

    /// Retrieves the `gio.ActionGroup` that was registered using `prefix`. The resulting
    /// `gio.ActionGroup` may have been registered to `widget` or any `gtk.Widget` in its
    /// ancestry.
    ///
    /// If no action group was found matching `prefix`, then `NULL` is returned.
    extern fn gtk_widget_get_action_group(p_widget: *Widget, p_prefix: [*:0]const u8) ?*gio.ActionGroup;
    pub const getActionGroup = gtk_widget_get_action_group;

    /// Returns the baseline that has currently been allocated to `widget`.
    /// This function is intended to be used when implementing handlers
    /// for the `gtk.Widget.signals.draw` function, and when allocating child
    /// widgets in `gtk.Widget.signals.size_allocate`.
    extern fn gtk_widget_get_allocated_baseline(p_widget: *Widget) c_int;
    pub const getAllocatedBaseline = gtk_widget_get_allocated_baseline;

    /// Returns the height that has currently been allocated to `widget`.
    /// This function is intended to be used when implementing handlers
    /// for the `gtk.Widget.signals.draw` function.
    extern fn gtk_widget_get_allocated_height(p_widget: *Widget) c_int;
    pub const getAllocatedHeight = gtk_widget_get_allocated_height;

    /// Retrieves the widget’s allocated size.
    ///
    /// This function returns the last values passed to
    /// `gtk.Widget.sizeAllocateWithBaseline`. The value differs from
    /// the size returned in `gtk.Widget.getAllocation` in that functions
    /// like `gtk.Widget.setHalign` can adjust the allocation, but not
    /// the value returned by this function.
    ///
    /// If a widget is not visible, its allocated size is 0.
    extern fn gtk_widget_get_allocated_size(p_widget: *Widget, p_allocation: *gtk.Allocation, p_baseline: ?*c_int) void;
    pub const getAllocatedSize = gtk_widget_get_allocated_size;

    /// Returns the width that has currently been allocated to `widget`.
    /// This function is intended to be used when implementing handlers
    /// for the `gtk.Widget.signals.draw` function.
    extern fn gtk_widget_get_allocated_width(p_widget: *Widget) c_int;
    pub const getAllocatedWidth = gtk_widget_get_allocated_width;

    /// Retrieves the widget’s allocation.
    ///
    /// Note, when implementing a `gtk.Container`: a widget’s allocation will
    /// be its “adjusted” allocation, that is, the widget’s parent
    /// container typically calls `gtk.Widget.sizeAllocate` with an
    /// allocation, and that allocation is then adjusted (to handle margin
    /// and alignment for example) before assignment to the widget.
    /// `gtk.Widget.getAllocation` returns the adjusted allocation that
    /// was actually assigned to the widget. The adjusted allocation is
    /// guaranteed to be completely contained within the
    /// `gtk.Widget.sizeAllocate` allocation, however. So a `gtk.Container`
    /// is guaranteed that its children stay inside the assigned bounds,
    /// but not that they have exactly the bounds the container assigned.
    /// There is no way to get the original allocation assigned by
    /// `gtk.Widget.sizeAllocate`, since it isn’t stored; if a container
    /// implementation needs that information it will have to track it itself.
    extern fn gtk_widget_get_allocation(p_widget: *Widget, p_allocation: *gtk.Allocation) void;
    pub const getAllocation = gtk_widget_get_allocation;

    /// Gets the first ancestor of `widget` with type `widget_type`. For example,
    /// `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets
    /// the first `gtk.Box` that’s an ancestor of `widget`. No reference will be
    /// added to the returned widget; it should not be unreferenced. See note
    /// about checking for a toplevel `gtk.Window` in the docs for
    /// `gtk.Widget.getToplevel`.
    ///
    /// Note that unlike `gtk.Widget.isAncestor`, `gtk.Widget.getAncestor`
    /// considers `widget` to be an ancestor of itself.
    extern fn gtk_widget_get_ancestor(p_widget: *Widget, p_widget_type: usize) ?*gtk.Widget;
    pub const getAncestor = gtk_widget_get_ancestor;

    /// Determines whether the application intends to draw on the widget in
    /// an `gtk.Widget.signals.draw` handler.
    ///
    /// See `gtk.Widget.setAppPaintable`
    extern fn gtk_widget_get_app_paintable(p_widget: *Widget) c_int;
    pub const getAppPaintable = gtk_widget_get_app_paintable;

    /// Determines whether `widget` can be a default widget. See
    /// `gtk.Widget.setCanDefault`.
    extern fn gtk_widget_get_can_default(p_widget: *Widget) c_int;
    pub const getCanDefault = gtk_widget_get_can_default;

    /// Determines whether `widget` can own the input focus. See
    /// `gtk.Widget.setCanFocus`.
    extern fn gtk_widget_get_can_focus(p_widget: *Widget) c_int;
    pub const getCanFocus = gtk_widget_get_can_focus;

    /// This function is only for use in widget implementations. Obtains
    /// `widget`->requisition, unless someone has forced a particular
    /// geometry on the widget (e.g. with `gtk.Widget.setSizeRequest`),
    /// in which case it returns that geometry instead of the widget's
    /// requisition.
    ///
    /// This function differs from `gtk.Widget.sizeRequest` in that
    /// it retrieves the last size request value from `widget`->requisition,
    /// while `gtk.Widget.sizeRequest` actually calls the "size_request" method
    /// on `widget` to compute the size request and fill in `widget`->requisition,
    /// and only then returns `widget`->requisition.
    ///
    /// Because this function does not call the “size_request” method, it
    /// can only be used when you know that `widget`->requisition is
    /// up-to-date, that is, `gtk.Widget.sizeRequest` has been called
    /// since the last time a resize was queued. In general, only container
    /// implementations have this information; applications should use
    /// `gtk.Widget.sizeRequest`.
    extern fn gtk_widget_get_child_requisition(p_widget: *Widget, p_requisition: *gtk.Requisition) void;
    pub const getChildRequisition = gtk_widget_get_child_requisition;

    /// Gets the value set with `gtk.Widget.setChildVisible`.
    /// If you feel a need to use this function, your code probably
    /// needs reorganization.
    ///
    /// This function is only useful for container implementations and
    /// never should be called by an application.
    extern fn gtk_widget_get_child_visible(p_widget: *Widget) c_int;
    pub const getChildVisible = gtk_widget_get_child_visible;

    /// Retrieves the widget’s clip area.
    ///
    /// The clip area is the area in which all of `widget`'s drawing will
    /// happen. Other toolkits call it the bounding box.
    ///
    /// Historically, in GTK+ the clip area has been equal to the allocation
    /// retrieved via `gtk.Widget.getAllocation`.
    extern fn gtk_widget_get_clip(p_widget: *Widget, p_clip: *gtk.Allocation) void;
    pub const getClip = gtk_widget_get_clip;

    /// Returns the clipboard object for the given selection to
    /// be used with `widget`. `widget` must have a `gdk.Display`
    /// associated with it, so must be attached to a toplevel
    /// window.
    extern fn gtk_widget_get_clipboard(p_widget: *Widget, p_selection: gdk.Atom) *gtk.Clipboard;
    pub const getClipboard = gtk_widget_get_clipboard;

    /// Obtains the composite name of a widget.
    extern fn gtk_widget_get_composite_name(p_widget: *Widget) [*:0]u8;
    pub const getCompositeName = gtk_widget_get_composite_name;

    /// Returns whether `device` can interact with `widget` and its
    /// children. See `gtk.Widget.setDeviceEnabled`.
    extern fn gtk_widget_get_device_enabled(p_widget: *Widget, p_device: *gdk.Device) c_int;
    pub const getDeviceEnabled = gtk_widget_get_device_enabled;

    /// Returns the events mask for the widget corresponding to an specific device. These
    /// are the events that the widget will receive when `device` operates on it.
    extern fn gtk_widget_get_device_events(p_widget: *Widget, p_device: *gdk.Device) gdk.EventMask;
    pub const getDeviceEvents = gtk_widget_get_device_events;

    /// Gets the reading direction for a particular widget. See
    /// `gtk.Widget.setDirection`.
    extern fn gtk_widget_get_direction(p_widget: *Widget) gtk.TextDirection;
    pub const getDirection = gtk_widget_get_direction;

    /// Get the `gdk.Display` for the toplevel window associated with
    /// this widget. This function can only be called after the widget
    /// has been added to a widget hierarchy with a `gtk.Window` at the top.
    ///
    /// In general, you should only create display specific
    /// resources when a widget has been realized, and you should
    /// free those resources when the widget is unrealized.
    extern fn gtk_widget_get_display(p_widget: *Widget) *gdk.Display;
    pub const getDisplay = gtk_widget_get_display;

    /// Determines whether the widget is double buffered.
    ///
    /// See `gtk.Widget.setDoubleBuffered`
    extern fn gtk_widget_get_double_buffered(p_widget: *Widget) c_int;
    pub const getDoubleBuffered = gtk_widget_get_double_buffered;

    /// Returns the event mask (see `gdk.EventMask`) for the widget. These are the
    /// events that the widget will receive.
    ///
    /// Note: Internally, the widget event mask will be the logical OR of the event
    /// mask set through `gtk.Widget.setEvents` or `gtk.Widget.addEvents`, and the
    /// event mask necessary to cater for every `gtk.EventController` created for the
    /// widget.
    extern fn gtk_widget_get_events(p_widget: *Widget) c_int;
    pub const getEvents = gtk_widget_get_events;

    /// Returns whether the widget should grab focus when it is clicked with the mouse.
    /// See `gtk.Widget.setFocusOnClick`.
    extern fn gtk_widget_get_focus_on_click(p_widget: *Widget) c_int;
    pub const getFocusOnClick = gtk_widget_get_focus_on_click;

    /// Gets the font map that has been set with `gtk.Widget.setFontMap`.
    extern fn gtk_widget_get_font_map(p_widget: *Widget) ?*pango.FontMap;
    pub const getFontMap = gtk_widget_get_font_map;

    /// Returns the `cairo.FontOptions` used for Pango rendering. When not set,
    /// the defaults font options for the `gdk.Screen` will be used.
    extern fn gtk_widget_get_font_options(p_widget: *Widget) ?*const cairo.FontOptions;
    pub const getFontOptions = gtk_widget_get_font_options;

    /// Obtains the frame clock for a widget. The frame clock is a global
    /// “ticker” that can be used to drive animations and repaints.  The
    /// most common reason to get the frame clock is to call
    /// `gdk.FrameClock.getFrameTime`, in order to get a time to use for
    /// animating. For example you might record the start of the animation
    /// with an initial value from `gdk.FrameClock.getFrameTime`, and
    /// then update the animation by calling
    /// `gdk.FrameClock.getFrameTime` again during each repaint.
    ///
    /// `gdk.FrameClock.requestPhase` will result in a new frame on the
    /// clock, but won’t necessarily repaint any widgets. To repaint a
    /// widget, you have to use `gtk.Widget.queueDraw` which invalidates
    /// the widget (thus scheduling it to receive a draw on the next
    /// frame). `gtk.Widget.queueDraw` will also end up requesting a frame
    /// on the appropriate frame clock.
    ///
    /// A widget’s frame clock will not change while the widget is
    /// mapped. Reparenting a widget (which implies a temporary unmap) can
    /// change the widget’s frame clock.
    ///
    /// Unrealized widgets do not have a frame clock.
    extern fn gtk_widget_get_frame_clock(p_widget: *Widget) ?*gdk.FrameClock;
    pub const getFrameClock = gtk_widget_get_frame_clock;

    /// Gets the value of the `gtk.Widget.properties.halign` property.
    ///
    /// For backwards compatibility reasons this method will never return
    /// `GTK_ALIGN_BASELINE`, but instead it will convert it to
    /// `GTK_ALIGN_FILL`. Baselines are not supported for horizontal
    /// alignment.
    extern fn gtk_widget_get_halign(p_widget: *Widget) gtk.Align;
    pub const getHalign = gtk_widget_get_halign;

    /// Returns the current value of the has-tooltip property.  See
    /// `gtk.Widget.properties.has`-tooltip for more information.
    extern fn gtk_widget_get_has_tooltip(p_widget: *Widget) c_int;
    pub const getHasTooltip = gtk_widget_get_has_tooltip;

    /// Determines whether `widget` has a `gdk.Window` of its own. See
    /// `gtk.Widget.setHasWindow`.
    extern fn gtk_widget_get_has_window(p_widget: *Widget) c_int;
    pub const getHasWindow = gtk_widget_get_has_window;

    /// Gets whether the widget would like any available extra horizontal
    /// space. When a user resizes a `gtk.Window`, widgets with expand=TRUE
    /// generally receive the extra space. For example, a list or
    /// scrollable area or document in your window would often be set to
    /// expand.
    ///
    /// Containers should use `gtk.Widget.computeExpand` rather than
    /// this function, to see whether a widget, or any of its children,
    /// has the expand flag set. If any child of a widget wants to
    /// expand, the parent may ask to expand also.
    ///
    /// This function only looks at the widget’s own hexpand flag, rather
    /// than computing whether the entire widget tree rooted at this widget
    /// wants to expand.
    extern fn gtk_widget_get_hexpand(p_widget: *Widget) c_int;
    pub const getHexpand = gtk_widget_get_hexpand;

    /// Gets whether `gtk.Widget.setHexpand` has been used to
    /// explicitly set the expand flag on this widget.
    ///
    /// If hexpand is set, then it overrides any computed
    /// expand value based on child widgets. If hexpand is not
    /// set, then the expand value depends on whether any
    /// children of the widget would like to expand.
    ///
    /// There are few reasons to use this function, but it’s here
    /// for completeness and consistency.
    extern fn gtk_widget_get_hexpand_set(p_widget: *Widget) c_int;
    pub const getHexpandSet = gtk_widget_get_hexpand_set;

    /// Whether the widget is mapped.
    extern fn gtk_widget_get_mapped(p_widget: *Widget) c_int;
    pub const getMapped = gtk_widget_get_mapped;

    /// Gets the value of the `gtk.Widget.properties.margin`-bottom property.
    extern fn gtk_widget_get_margin_bottom(p_widget: *Widget) c_int;
    pub const getMarginBottom = gtk_widget_get_margin_bottom;

    /// Gets the value of the `gtk.Widget.properties.margin`-end property.
    extern fn gtk_widget_get_margin_end(p_widget: *Widget) c_int;
    pub const getMarginEnd = gtk_widget_get_margin_end;

    /// Gets the value of the `gtk.Widget.properties.margin`-left property.
    extern fn gtk_widget_get_margin_left(p_widget: *Widget) c_int;
    pub const getMarginLeft = gtk_widget_get_margin_left;

    /// Gets the value of the `gtk.Widget.properties.margin`-right property.
    extern fn gtk_widget_get_margin_right(p_widget: *Widget) c_int;
    pub const getMarginRight = gtk_widget_get_margin_right;

    /// Gets the value of the `gtk.Widget.properties.margin`-start property.
    extern fn gtk_widget_get_margin_start(p_widget: *Widget) c_int;
    pub const getMarginStart = gtk_widget_get_margin_start;

    /// Gets the value of the `gtk.Widget.properties.margin`-top property.
    extern fn gtk_widget_get_margin_top(p_widget: *Widget) c_int;
    pub const getMarginTop = gtk_widget_get_margin_top;

    /// Returns the modifier mask the `widget`’s windowing system backend
    /// uses for a particular purpose.
    ///
    /// See `gdk.Keymap.getModifierMask`.
    extern fn gtk_widget_get_modifier_mask(p_widget: *Widget, p_intent: gdk.ModifierIntent) gdk.ModifierType;
    pub const getModifierMask = gtk_widget_get_modifier_mask;

    /// Returns the current modifier style for the widget. (As set by
    /// `gtk.Widget.modifyStyle`.) If no style has previously set, a new
    /// `gtk.RcStyle` will be created with all values unset, and set as the
    /// modifier style for the widget. If you make changes to this rc
    /// style, you must call `gtk.Widget.modifyStyle`, passing in the
    /// returned rc style, to make sure that your changes take effect.
    ///
    /// Caution: passing the style back to `gtk.Widget.modifyStyle` will
    /// normally end up destroying it, because `gtk.Widget.modifyStyle` copies
    /// the passed-in style and sets the copy as the new modifier style,
    /// thus dropping any reference to the old modifier style. Add a reference
    /// to the modifier style if you want to keep it alive.
    extern fn gtk_widget_get_modifier_style(p_widget: *Widget) *gtk.RcStyle;
    pub const getModifierStyle = gtk_widget_get_modifier_style;

    /// Retrieves the name of a widget. See `gtk.Widget.setName` for the
    /// significance of widget names.
    extern fn gtk_widget_get_name(p_widget: *Widget) [*:0]const u8;
    pub const getName = gtk_widget_get_name;

    /// Returns the current value of the `gtk.Widget.properties.no`-show-all property,
    /// which determines whether calls to `gtk.Widget.showAll`
    /// will affect this widget.
    extern fn gtk_widget_get_no_show_all(p_widget: *Widget) c_int;
    pub const getNoShowAll = gtk_widget_get_no_show_all;

    /// Fetches the requested opacity for this widget.
    /// See `gtk.Widget.setOpacity`.
    extern fn gtk_widget_get_opacity(p_widget: *Widget) f64;
    pub const getOpacity = gtk_widget_get_opacity;

    /// Gets a `pango.Context` with the appropriate font map, font description,
    /// and base direction for this widget. Unlike the context returned
    /// by `gtk.Widget.createPangoContext`, this context is owned by
    /// the widget (it can be used until the screen for the widget changes
    /// or the widget is removed from its toplevel), and will be updated to
    /// match any changes to the widget’s attributes. This can be tracked
    /// by using the `gtk.Widget.signals.screen`-changed signal on the widget.
    extern fn gtk_widget_get_pango_context(p_widget: *Widget) *pango.Context;
    pub const getPangoContext = gtk_widget_get_pango_context;

    /// Returns the parent container of `widget`.
    extern fn gtk_widget_get_parent(p_widget: *Widget) ?*gtk.Widget;
    pub const getParent = gtk_widget_get_parent;

    /// Gets `widget`’s parent window, or `NULL` if it does not have one.
    extern fn gtk_widget_get_parent_window(p_widget: *Widget) ?*gdk.Window;
    pub const getParentWindow = gtk_widget_get_parent_window;

    /// Returns the `gtk.WidgetPath` representing `widget`, if the widget
    /// is not connected to a toplevel widget, a partial path will be
    /// created.
    extern fn gtk_widget_get_path(p_widget: *Widget) *gtk.WidgetPath;
    pub const getPath = gtk_widget_get_path;

    /// Obtains the location of the mouse pointer in widget coordinates.
    /// Widget coordinates are a bit odd; for historical reasons, they are
    /// defined as `widget`->window coordinates for widgets that return `TRUE` for
    /// `gtk.Widget.getHasWindow`; and are relative to `widget`->allocation.x,
    /// `widget`->allocation.y otherwise.
    extern fn gtk_widget_get_pointer(p_widget: *Widget, p_x: ?*c_int, p_y: ?*c_int) void;
    pub const getPointer = gtk_widget_get_pointer;

    /// Retrieves a widget’s initial minimum and natural height.
    ///
    /// This call is specific to width-for-height requests.
    ///
    /// The returned request will be modified by the
    /// GtkWidgetClass::adjust_size_request virtual method and by any
    /// `GtkSizeGroups` that have been applied. That is, the returned request
    /// is the one that should be used for layout, not necessarily the one
    /// returned by the widget itself.
    extern fn gtk_widget_get_preferred_height(p_widget: *Widget, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) void;
    pub const getPreferredHeight = gtk_widget_get_preferred_height;

    /// Retrieves a widget’s minimum and natural height and the corresponding baselines if it would be given
    /// the specified `width`, or the default height if `width` is -1. The baselines may be -1 which means
    /// that no baseline is requested for this widget.
    ///
    /// The returned request will be modified by the
    /// GtkWidgetClass::adjust_size_request and GtkWidgetClass::adjust_baseline_request virtual methods
    /// and by any `GtkSizeGroups` that have been applied. That is, the returned request
    /// is the one that should be used for layout, not necessarily the one
    /// returned by the widget itself.
    extern fn gtk_widget_get_preferred_height_and_baseline_for_width(p_widget: *Widget, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int, p_minimum_baseline: ?*c_int, p_natural_baseline: ?*c_int) void;
    pub const getPreferredHeightAndBaselineForWidth = gtk_widget_get_preferred_height_and_baseline_for_width;

    /// Retrieves a widget’s minimum and natural height if it would be given
    /// the specified `width`.
    ///
    /// The returned request will be modified by the
    /// GtkWidgetClass::adjust_size_request virtual method and by any
    /// `GtkSizeGroups` that have been applied. That is, the returned request
    /// is the one that should be used for layout, not necessarily the one
    /// returned by the widget itself.
    extern fn gtk_widget_get_preferred_height_for_width(p_widget: *Widget, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) void;
    pub const getPreferredHeightForWidth = gtk_widget_get_preferred_height_for_width;

    /// Retrieves the minimum and natural size of a widget, taking
    /// into account the widget’s preference for height-for-width management.
    ///
    /// This is used to retrieve a suitable size by container widgets which do
    /// not impose any restrictions on the child placement. It can be used
    /// to deduce toplevel window and menu sizes as well as child widgets in
    /// free-form containers such as GtkLayout.
    ///
    /// Handle with care. Note that the natural height of a height-for-width
    /// widget will generally be a smaller size than the minimum height, since the required
    /// height for the natural width is generally smaller than the required height for
    /// the minimum width.
    ///
    /// Use `gtk.Widget.getPreferredHeightAndBaselineForWidth` if you want to support
    /// baseline alignment.
    extern fn gtk_widget_get_preferred_size(p_widget: *Widget, p_minimum_size: ?*gtk.Requisition, p_natural_size: ?*gtk.Requisition) void;
    pub const getPreferredSize = gtk_widget_get_preferred_size;

    /// Retrieves a widget’s initial minimum and natural width.
    ///
    /// This call is specific to height-for-width requests.
    ///
    /// The returned request will be modified by the
    /// GtkWidgetClass::adjust_size_request virtual method and by any
    /// `GtkSizeGroups` that have been applied. That is, the returned request
    /// is the one that should be used for layout, not necessarily the one
    /// returned by the widget itself.
    extern fn gtk_widget_get_preferred_width(p_widget: *Widget, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) void;
    pub const getPreferredWidth = gtk_widget_get_preferred_width;

    /// Retrieves a widget’s minimum and natural width if it would be given
    /// the specified `height`.
    ///
    /// The returned request will be modified by the
    /// GtkWidgetClass::adjust_size_request virtual method and by any
    /// `GtkSizeGroups` that have been applied. That is, the returned request
    /// is the one that should be used for layout, not necessarily the one
    /// returned by the widget itself.
    extern fn gtk_widget_get_preferred_width_for_height(p_widget: *Widget, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) void;
    pub const getPreferredWidthForHeight = gtk_widget_get_preferred_width_for_height;

    /// Determines whether `widget` is realized.
    extern fn gtk_widget_get_realized(p_widget: *Widget) c_int;
    pub const getRealized = gtk_widget_get_realized;

    /// Determines whether `widget` is always treated as the default widget
    /// within its toplevel when it has the focus, even if another widget
    /// is the default.
    ///
    /// See `gtk.Widget.setReceivesDefault`.
    extern fn gtk_widget_get_receives_default(p_widget: *Widget) c_int;
    pub const getReceivesDefault = gtk_widget_get_receives_default;

    /// Gets whether the widget prefers a height-for-width layout
    /// or a width-for-height layout.
    ///
    /// `gtk.Bin` widgets generally propagate the preference of
    /// their child, container widgets need to request something either in
    /// context of their children or in context of their allocation
    /// capabilities.
    extern fn gtk_widget_get_request_mode(p_widget: *Widget) gtk.SizeRequestMode;
    pub const getRequestMode = gtk_widget_get_request_mode;

    /// Retrieves the widget’s requisition.
    ///
    /// This function should only be used by widget implementations in
    /// order to figure whether the widget’s requisition has actually
    /// changed after some internal state change (so that they can call
    /// `gtk.Widget.queueResize` instead of `gtk.Widget.queueDraw`).
    ///
    /// Normally, `gtk.Widget.sizeRequest` should be used.
    extern fn gtk_widget_get_requisition(p_widget: *Widget, p_requisition: *gtk.Requisition) void;
    pub const getRequisition = gtk_widget_get_requisition;

    /// Get the root window where this widget is located. This function can
    /// only be called after the widget has been added to a widget
    /// hierarchy with `gtk.Window` at the top.
    ///
    /// The root window is useful for such purposes as creating a popup
    /// `gdk.Window` associated with the window. In general, you should only
    /// create display specific resources when a widget has been realized,
    /// and you should free those resources when the widget is unrealized.
    extern fn gtk_widget_get_root_window(p_widget: *Widget) *gdk.Window;
    pub const getRootWindow = gtk_widget_get_root_window;

    /// Retrieves the internal scale factor that maps from window coordinates
    /// to the actual device pixels. On traditional systems this is 1, on
    /// high density outputs, it can be a higher value (typically 2).
    ///
    /// See `gdk.Window.getScaleFactor`.
    extern fn gtk_widget_get_scale_factor(p_widget: *Widget) c_int;
    pub const getScaleFactor = gtk_widget_get_scale_factor;

    /// Get the `gdk.Screen` from the toplevel window associated with
    /// this widget. This function can only be called after the widget
    /// has been added to a widget hierarchy with a `gtk.Window`
    /// at the top.
    ///
    /// In general, you should only create screen specific
    /// resources when a widget has been realized, and you should
    /// free those resources when the widget is unrealized.
    extern fn gtk_widget_get_screen(p_widget: *Widget) *gdk.Screen;
    pub const getScreen = gtk_widget_get_screen;

    /// Returns the widget’s sensitivity (in the sense of returning
    /// the value that has been set using `gtk.Widget.setSensitive`).
    ///
    /// The effective sensitivity of a widget is however determined by both its
    /// own and its parent widget’s sensitivity. See `gtk.Widget.isSensitive`.
    extern fn gtk_widget_get_sensitive(p_widget: *Widget) c_int;
    pub const getSensitive = gtk_widget_get_sensitive;

    /// Gets the settings object holding the settings used for this widget.
    ///
    /// Note that this function can only be called when the `gtk.Widget`
    /// is attached to a toplevel, since the settings object is specific
    /// to a particular `gdk.Screen`.
    extern fn gtk_widget_get_settings(p_widget: *Widget) *gtk.Settings;
    pub const getSettings = gtk_widget_get_settings;

    /// Gets the size request that was explicitly set for the widget using
    /// `gtk.Widget.setSizeRequest`. A value of -1 stored in `width` or
    /// `height` indicates that that dimension has not been set explicitly
    /// and the natural requisition of the widget will be used instead. See
    /// `gtk.Widget.setSizeRequest`. To get the size a widget will
    /// actually request, call `gtk.Widget.getPreferredSize` instead of
    /// this function.
    extern fn gtk_widget_get_size_request(p_widget: *Widget, p_width: ?*c_int, p_height: ?*c_int) void;
    pub const getSizeRequest = gtk_widget_get_size_request;

    /// Returns the widget’s state. See `gtk.Widget.setState`.
    extern fn gtk_widget_get_state(p_widget: *Widget) gtk.StateType;
    pub const getState = gtk_widget_get_state;

    /// Returns the widget state as a flag set. It is worth mentioning
    /// that the effective `GTK_STATE_FLAG_INSENSITIVE` state will be
    /// returned, that is, also based on parent insensitivity, even if
    /// `widget` itself is sensitive.
    ///
    /// Also note that if you are looking for a way to obtain the
    /// `gtk.StateFlags` to pass to a `gtk.StyleContext` method, you
    /// should look at `gtk.StyleContext.getState`.
    extern fn gtk_widget_get_state_flags(p_widget: *Widget) gtk.StateFlags;
    pub const getStateFlags = gtk_widget_get_state_flags;

    /// Simply an accessor function that returns `widget`->style.
    extern fn gtk_widget_get_style(p_widget: *Widget) *gtk.Style;
    pub const getStyle = gtk_widget_get_style;

    /// Returns the style context associated to `widget`. The returned object is
    /// guaranteed to be the same for the lifetime of `widget`.
    extern fn gtk_widget_get_style_context(p_widget: *Widget) *gtk.StyleContext;
    pub const getStyleContext = gtk_widget_get_style_context;

    /// Returns `TRUE` if `widget` is multiple pointer aware. See
    /// `gtk.Widget.setSupportMultidevice` for more information.
    extern fn gtk_widget_get_support_multidevice(p_widget: *Widget) c_int;
    pub const getSupportMultidevice = gtk_widget_get_support_multidevice;

    /// Fetch an object build from the template XML for `widget_type` in this `widget` instance.
    ///
    /// This will only report children which were previously declared with
    /// `gtk.WidgetClass.bindTemplateChildFull` or one of its
    /// variants.
    ///
    /// This function is only meant to be called for code which is private to the `widget_type` which
    /// declared the child and is meant for language bindings which cannot easily make use
    /// of the GObject structure offsets.
    extern fn gtk_widget_get_template_child(p_widget: *Widget, p_widget_type: usize, p_name: [*:0]const u8) *gobject.Object;
    pub const getTemplateChild = gtk_widget_get_template_child;

    /// Gets the contents of the tooltip for `widget`.
    extern fn gtk_widget_get_tooltip_markup(p_widget: *Widget) ?[*:0]u8;
    pub const getTooltipMarkup = gtk_widget_get_tooltip_markup;

    /// Gets the contents of the tooltip for `widget`.
    extern fn gtk_widget_get_tooltip_text(p_widget: *Widget) ?[*:0]u8;
    pub const getTooltipText = gtk_widget_get_tooltip_text;

    /// Returns the `gtk.Window` of the current tooltip. This can be the
    /// GtkWindow created by default, or the custom tooltip window set
    /// using `gtk.Widget.setTooltipWindow`.
    extern fn gtk_widget_get_tooltip_window(p_widget: *Widget) *gtk.Window;
    pub const getTooltipWindow = gtk_widget_get_tooltip_window;

    /// This function returns the topmost widget in the container hierarchy
    /// `widget` is a part of. If `widget` has no parent widgets, it will be
    /// returned as the topmost widget. No reference will be added to the
    /// returned widget; it should not be unreferenced.
    ///
    /// Note the difference in behavior vs. `gtk.Widget.getAncestor`;
    /// `gtk_widget_get_ancestor (widget, GTK_TYPE_WINDOW)`
    /// would return
    /// `NULL` if `widget` wasn’t inside a toplevel window, and if the
    /// window was inside a `gtk.Window`-derived widget which was in turn
    /// inside the toplevel `gtk.Window`. While the second case may
    /// seem unlikely, it actually happens when a `gtk.Plug` is embedded
    /// inside a `gtk.Socket` within the same application.
    ///
    /// To reliably find the toplevel `gtk.Window`, use
    /// `gtk.Widget.getToplevel` and call `GTK_IS_WINDOW`
    /// on the result. For instance, to get the title of a widget's toplevel
    /// window, one might use:
    /// ```
    /// static const char *
    /// get_widget_toplevel_title (GtkWidget *widget)
    /// {
    ///   GtkWidget *toplevel = gtk_widget_get_toplevel (widget);
    ///   if (GTK_IS_WINDOW (toplevel))
    ///     {
    ///       return gtk_window_get_title (GTK_WINDOW (toplevel));
    ///     }
    ///
    ///   return NULL;
    /// }
    /// ```
    extern fn gtk_widget_get_toplevel(p_widget: *Widget) *gtk.Widget;
    pub const getToplevel = gtk_widget_get_toplevel;

    /// Gets the value of the `gtk.Widget.properties.valign` property.
    ///
    /// For backwards compatibility reasons this method will never return
    /// `GTK_ALIGN_BASELINE`, but instead it will convert it to
    /// `GTK_ALIGN_FILL`. If your widget want to support baseline aligned
    /// children it must use `gtk.Widget.getValignWithBaseline`, or
    /// `g_object_get (widget, "valign", &value, NULL)`, which will
    /// also report the true value.
    extern fn gtk_widget_get_valign(p_widget: *Widget) gtk.Align;
    pub const getValign = gtk_widget_get_valign;

    /// Gets the value of the `gtk.Widget.properties.valign` property, including
    /// `GTK_ALIGN_BASELINE`.
    extern fn gtk_widget_get_valign_with_baseline(p_widget: *Widget) gtk.Align;
    pub const getValignWithBaseline = gtk_widget_get_valign_with_baseline;

    /// Gets whether the widget would like any available extra vertical
    /// space.
    ///
    /// See `gtk.Widget.getHexpand` for more detail.
    extern fn gtk_widget_get_vexpand(p_widget: *Widget) c_int;
    pub const getVexpand = gtk_widget_get_vexpand;

    /// Gets whether `gtk.Widget.setVexpand` has been used to
    /// explicitly set the expand flag on this widget.
    ///
    /// See `gtk.Widget.getHexpandSet` for more detail.
    extern fn gtk_widget_get_vexpand_set(p_widget: *Widget) c_int;
    pub const getVexpandSet = gtk_widget_get_vexpand_set;

    /// Determines whether the widget is visible. If you want to
    /// take into account whether the widget’s parent is also marked as
    /// visible, use `gtk.Widget.isVisible` instead.
    ///
    /// This function does not check if the widget is obscured in any way.
    ///
    /// See `gtk.Widget.setVisible`.
    extern fn gtk_widget_get_visible(p_widget: *Widget) c_int;
    pub const getVisible = gtk_widget_get_visible;

    /// Gets the visual that will be used to render `widget`.
    extern fn gtk_widget_get_visual(p_widget: *Widget) *gdk.Visual;
    pub const getVisual = gtk_widget_get_visual;

    /// Returns the widget’s window if it is realized, `NULL` otherwise
    extern fn gtk_widget_get_window(p_widget: *Widget) ?*gdk.Window;
    pub const getWindow = gtk_widget_get_window;

    /// Makes `widget` the current grabbed widget.
    ///
    /// This means that interaction with other widgets in the same
    /// application is blocked and mouse as well as keyboard events
    /// are delivered to this widget.
    ///
    /// If `widget` is not sensitive, it is not set as the current
    /// grabbed widget and this function does nothing.
    extern fn gtk_grab_add(p_widget: *Widget) void;
    pub const grabAdd = gtk_grab_add;

    /// Causes `widget` to become the default widget. `widget` must be able to be
    /// a default widget; typically you would ensure this yourself
    /// by calling `gtk.Widget.setCanDefault` with a `TRUE` value.
    /// The default widget is activated when
    /// the user presses Enter in a window. Default widgets must be
    /// activatable, that is, `gtk.Widget.activate` should affect them. Note
    /// that `gtk.Entry` widgets require the “activates-default” property
    /// set to `TRUE` before they activate the default widget when Enter
    /// is pressed and the `gtk.Entry` is focused.
    extern fn gtk_widget_grab_default(p_widget: *Widget) void;
    pub const grabDefault = gtk_widget_grab_default;

    /// Causes `widget` to have the keyboard focus for the `gtk.Window` it's
    /// inside. `widget` must be a focusable widget, such as a `gtk.Entry`;
    /// something like `gtk.Frame` won’t work.
    ///
    /// More precisely, it must have the `GTK_CAN_FOCUS` flag set. Use
    /// `gtk.Widget.setCanFocus` to modify that flag.
    ///
    /// The widget also needs to be realized and mapped. This is indicated by the
    /// related signals. Grabbing the focus immediately after creating the widget
    /// will likely fail and cause critical warnings.
    extern fn gtk_widget_grab_focus(p_widget: *Widget) void;
    pub const grabFocus = gtk_widget_grab_focus;

    /// Removes the grab from the given widget.
    ///
    /// You have to pair calls to `gtk.Widget.grabAdd` and `gtk.Widget.grabRemove`.
    ///
    /// If `widget` does not have the grab, this function does nothing.
    extern fn gtk_grab_remove(p_widget: *Widget) void;
    pub const grabRemove = gtk_grab_remove;

    /// Determines whether `widget` is the current default widget within its
    /// toplevel. See `gtk.Widget.setCanDefault`.
    extern fn gtk_widget_has_default(p_widget: *Widget) c_int;
    pub const hasDefault = gtk_widget_has_default;

    /// Determines if the widget has the global input focus. See
    /// `gtk.Widget.isFocus` for the difference between having the global
    /// input focus, and only having the focus within a toplevel.
    extern fn gtk_widget_has_focus(p_widget: *Widget) c_int;
    pub const hasFocus = gtk_widget_has_focus;

    /// Determines whether the widget is currently grabbing events, so it
    /// is the only widget receiving input events (keyboard and mouse).
    ///
    /// See also `gtk.Widget.grabAdd`.
    extern fn gtk_widget_has_grab(p_widget: *Widget) c_int;
    pub const hasGrab = gtk_widget_has_grab;

    /// Determines if the widget style has been looked up through the rc mechanism.
    extern fn gtk_widget_has_rc_style(p_widget: *Widget) c_int;
    pub const hasRcStyle = gtk_widget_has_rc_style;

    /// Checks whether there is a `gdk.Screen` is associated with
    /// this widget. All toplevel widgets have an associated
    /// screen, and all widgets added into a hierarchy with a toplevel
    /// window at the top.
    extern fn gtk_widget_has_screen(p_widget: *Widget) c_int;
    pub const hasScreen = gtk_widget_has_screen;

    /// Determines if the widget should show a visible indication that
    /// it has the global input focus. This is a convenience function for
    /// use in ::draw handlers that takes into account whether focus
    /// indication should currently be shown in the toplevel window of
    /// `widget`. See `gtk.Window.getFocusVisible` for more information
    /// about focus indication.
    ///
    /// To find out if the widget has the global input focus, use
    /// `gtk.Widget.hasFocus`.
    extern fn gtk_widget_has_visible_focus(p_widget: *Widget) c_int;
    pub const hasVisibleFocus = gtk_widget_has_visible_focus;

    /// Reverses the effects of `gtk.Widget.show`, causing the widget to be
    /// hidden (invisible to the user).
    extern fn gtk_widget_hide(p_widget: *Widget) void;
    pub const hide = gtk_widget_hide;

    /// Utility function; intended to be connected to the `gtk.Widget.signals.delete`-event
    /// signal on a `gtk.Window`. The function calls `gtk.Widget.hide` on its
    /// argument, then returns `TRUE`. If connected to ::delete-event, the
    /// result is that clicking the close button for a window (on the
    /// window frame, top right corner usually) will hide but not destroy
    /// the window. By default, GTK+ destroys windows when ::delete-event
    /// is received.
    extern fn gtk_widget_hide_on_delete(p_widget: *Widget) c_int;
    pub const hideOnDelete = gtk_widget_hide_on_delete;

    /// Returns whether the widget is currently being destroyed.
    /// This information can sometimes be used to avoid doing
    /// unnecessary work.
    extern fn gtk_widget_in_destruction(p_widget: *Widget) c_int;
    pub const inDestruction = gtk_widget_in_destruction;

    /// Creates and initializes child widgets defined in templates. This
    /// function must be called in the instance initializer for any
    /// class which assigned itself a template using `gtk.WidgetClass.setTemplate`
    ///
    /// It is important to call this function in the instance initializer
    /// of a `gtk.Widget` subclass and not in `gobject.Object.virtual_methods.constructed` or
    /// `gobject.Object.virtual_methods.constructor` for two reasons.
    ///
    /// One reason is that generally derived widgets will assume that parent
    /// class composite widgets have been created in their instance
    /// initializers.
    ///
    /// Another reason is that when calling `gobject.Object.new` on a widget with
    /// composite templates, it’s important to build the composite widgets
    /// before the construct properties are set. Properties passed to `gobject.Object.new`
    /// should take precedence over properties set in the private template XML.
    extern fn gtk_widget_init_template(p_widget: *Widget) void;
    pub const initTemplate = gtk_widget_init_template;

    /// Sets an input shape for this widget’s GDK window. This allows for
    /// windows which react to mouse click in a nonrectangular region, see
    /// `gdk.Window.inputShapeCombineRegion` for more information.
    extern fn gtk_widget_input_shape_combine_region(p_widget: *Widget, p_region: ?*cairo.Region) void;
    pub const inputShapeCombineRegion = gtk_widget_input_shape_combine_region;

    /// Inserts `group` into `widget`. Children of `widget` that implement
    /// `gtk.Actionable` can then be associated with actions in `group` by
    /// setting their “action-name” to
    /// `prefix`.`action-name`.
    ///
    /// If `group` is `NULL`, a previously inserted group for `name` is removed
    /// from `widget`.
    extern fn gtk_widget_insert_action_group(p_widget: *Widget, p_name: [*:0]const u8, p_group: ?*gio.ActionGroup) void;
    pub const insertActionGroup = gtk_widget_insert_action_group;

    /// Computes the intersection of a `widget`’s area and `area`, storing
    /// the intersection in `intersection`, and returns `TRUE` if there was
    /// an intersection.  `intersection` may be `NULL` if you’re only
    /// interested in whether there was an intersection.
    extern fn gtk_widget_intersect(p_widget: *Widget, p_area: *const gdk.Rectangle, p_intersection: ?*gdk.Rectangle) c_int;
    pub const intersect = gtk_widget_intersect;

    /// Determines whether `widget` is somewhere inside `ancestor`, possibly with
    /// intermediate containers.
    extern fn gtk_widget_is_ancestor(p_widget: *Widget, p_ancestor: *gtk.Widget) c_int;
    pub const isAncestor = gtk_widget_is_ancestor;

    /// Whether `widget` can rely on having its alpha channel
    /// drawn correctly. On X11 this function returns whether a
    /// compositing manager is running for `widget`’s screen.
    ///
    /// Please note that the semantics of this call will change
    /// in the future if used on a widget that has a composited
    /// window in its hierarchy (as set by `gdk.Window.setComposited`).
    extern fn gtk_widget_is_composited(p_widget: *Widget) c_int;
    pub const isComposited = gtk_widget_is_composited;

    /// Determines whether `widget` can be drawn to. A widget can be drawn
    /// to if it is mapped and visible.
    extern fn gtk_widget_is_drawable(p_widget: *Widget) c_int;
    pub const isDrawable = gtk_widget_is_drawable;

    /// Determines if the widget is the focus widget within its
    /// toplevel. (This does not mean that the `gtk.Widget.properties.has`-focus property is
    /// necessarily set; `gtk.Widget.properties.has`-focus will only be set if the
    /// toplevel widget additionally has the global input focus.)
    extern fn gtk_widget_is_focus(p_widget: *Widget) c_int;
    pub const isFocus = gtk_widget_is_focus;

    /// Returns the widget’s effective sensitivity, which means
    /// it is sensitive itself and also its parent widget is sensitive
    extern fn gtk_widget_is_sensitive(p_widget: *Widget) c_int;
    pub const isSensitive = gtk_widget_is_sensitive;

    /// Determines whether `widget` is a toplevel widget.
    ///
    /// Currently only `gtk.Window` and `gtk.Invisible` (and out-of-process
    /// `GtkPlugs`) are toplevel widgets. Toplevel widgets have no parent
    /// widget.
    extern fn gtk_widget_is_toplevel(p_widget: *Widget) c_int;
    pub const isToplevel = gtk_widget_is_toplevel;

    /// Determines whether the widget and all its parents are marked as
    /// visible.
    ///
    /// This function does not check if the widget is obscured in any way.
    ///
    /// See also `gtk.Widget.getVisible` and `gtk.Widget.setVisible`
    extern fn gtk_widget_is_visible(p_widget: *Widget) c_int;
    pub const isVisible = gtk_widget_is_visible;

    /// This function should be called whenever keyboard navigation within
    /// a single widget hits a boundary. The function emits the
    /// `gtk.Widget.signals.keynav`-failed signal on the widget and its return
    /// value should be interpreted in a way similar to the return value of
    /// `gtk.Widget.childFocus`:
    ///
    /// When `TRUE` is returned, stay in the widget, the failed keyboard
    /// navigation is OK and/or there is nowhere we can/should move the
    /// focus to.
    ///
    /// When `FALSE` is returned, the caller should continue with keyboard
    /// navigation outside the widget, e.g. by calling
    /// `gtk.Widget.childFocus` on the widget’s toplevel.
    ///
    /// The default ::keynav-failed handler returns `FALSE` for
    /// `GTK_DIR_TAB_FORWARD` and `GTK_DIR_TAB_BACKWARD`. For the other
    /// values of `gtk.DirectionType` it returns `TRUE`.
    ///
    /// Whenever the default handler returns `TRUE`, it also calls
    /// `gtk.Widget.errorBell` to notify the user of the failed keyboard
    /// navigation.
    ///
    /// A use case for providing an own implementation of ::keynav-failed
    /// (either by connecting to it or by overriding it) would be a row of
    /// `gtk.Entry` widgets where the user should be able to navigate the
    /// entire row with the cursor keys, as e.g. known from user interfaces
    /// that require entering license keys.
    extern fn gtk_widget_keynav_failed(p_widget: *Widget, p_direction: gtk.DirectionType) c_int;
    pub const keynavFailed = gtk_widget_keynav_failed;

    /// Lists the closures used by `widget` for accelerator group connections
    /// with `gtk.AccelGroup.connectByPath` or `gtk.AccelGroup.connect`.
    /// The closures can be used to monitor accelerator changes on `widget`,
    /// by connecting to the `GtkAccelGroup`::accel-changed signal of the
    /// `gtk.AccelGroup` of a closure which can be found out with
    /// `gtk.AccelGroup.fromAccelClosure`.
    extern fn gtk_widget_list_accel_closures(p_widget: *Widget) *glib.List;
    pub const listAccelClosures = gtk_widget_list_accel_closures;

    /// Retrieves a `NULL`-terminated array of strings containing the prefixes of
    /// `gio.ActionGroup`'s available to `widget`.
    extern fn gtk_widget_list_action_prefixes(p_widget: *Widget) [*][*:0]const u8;
    pub const listActionPrefixes = gtk_widget_list_action_prefixes;

    /// Returns a newly allocated list of the widgets, normally labels, for
    /// which this widget is the target of a mnemonic (see for example,
    /// `gtk.Label.setMnemonicWidget`).
    ///
    /// The widgets in the list are not individually referenced. If you
    /// want to iterate through the list and perform actions involving
    /// callbacks that might destroy the widgets, you
    /// must call `g_list_foreach (result,
    /// (GFunc)g_object_ref, NULL)` first, and then unref all the
    /// widgets afterwards.
    extern fn gtk_widget_list_mnemonic_labels(p_widget: *Widget) *glib.List;
    pub const listMnemonicLabels = gtk_widget_list_mnemonic_labels;

    /// This function is only for use in widget implementations. Causes
    /// a widget to be mapped if it isn’t already.
    extern fn gtk_widget_map(p_widget: *Widget) void;
    pub const map = gtk_widget_map;

    /// Emits the `gtk.Widget.signals.mnemonic`-activate signal.
    extern fn gtk_widget_mnemonic_activate(p_widget: *Widget, p_group_cycling: c_int) c_int;
    pub const mnemonicActivate = gtk_widget_mnemonic_activate;

    /// Sets the base color for a widget in a particular state.
    /// All other style values are left untouched. The base color
    /// is the background color used along with the text color
    /// (see `gtk.Widget.modifyText`) for widgets such as `gtk.Entry`
    /// and `gtk.TextView`. See also `gtk.Widget.modifyStyle`.
    ///
    /// > Note that “no window” widgets (which have the `GTK_NO_WINDOW`
    /// > flag set) draw on their parent container’s window and thus may
    /// > not draw any background themselves. This is the case for e.g.
    /// > `gtk.Label`.
    /// >
    /// > To modify the background of such widgets, you have to set the
    /// > base color on their parent; if you want to set the background
    /// > of a rectangular area around a label, try placing the label in
    /// > a `gtk.EventBox` widget and setting the base color on that.
    extern fn gtk_widget_modify_base(p_widget: *Widget, p_state: gtk.StateType, p_color: ?*const gdk.Color) void;
    pub const modifyBase = gtk_widget_modify_base;

    /// Sets the background color for a widget in a particular state.
    ///
    /// All other style values are left untouched.
    /// See also `gtk.Widget.modifyStyle`.
    ///
    /// > Note that “no window” widgets (which have the `GTK_NO_WINDOW`
    /// > flag set) draw on their parent container’s window and thus may
    /// > not draw any background themselves. This is the case for e.g.
    /// > `gtk.Label`.
    /// >
    /// > To modify the background of such widgets, you have to set the
    /// > background color on their parent; if you want to set the background
    /// > of a rectangular area around a label, try placing the label in
    /// > a `gtk.EventBox` widget and setting the background color on that.
    extern fn gtk_widget_modify_bg(p_widget: *Widget, p_state: gtk.StateType, p_color: ?*const gdk.Color) void;
    pub const modifyBg = gtk_widget_modify_bg;

    /// Sets the cursor color to use in a widget, overriding the `gtk.Widget`
    /// cursor-color and secondary-cursor-color
    /// style properties.
    ///
    /// All other style values are left untouched.
    /// See also `gtk.Widget.modifyStyle`.
    extern fn gtk_widget_modify_cursor(p_widget: *Widget, p_primary: ?*const gdk.Color, p_secondary: ?*const gdk.Color) void;
    pub const modifyCursor = gtk_widget_modify_cursor;

    /// Sets the foreground color for a widget in a particular state.
    ///
    /// All other style values are left untouched.
    /// See also `gtk.Widget.modifyStyle`.
    extern fn gtk_widget_modify_fg(p_widget: *Widget, p_state: gtk.StateType, p_color: ?*const gdk.Color) void;
    pub const modifyFg = gtk_widget_modify_fg;

    /// Sets the font to use for a widget.
    ///
    /// All other style values are left untouched.
    /// See also `gtk.Widget.modifyStyle`.
    extern fn gtk_widget_modify_font(p_widget: *Widget, p_font_desc: ?*pango.FontDescription) void;
    pub const modifyFont = gtk_widget_modify_font;

    /// Modifies style values on the widget.
    ///
    /// Modifications made using this technique take precedence over
    /// style values set via an RC file, however, they will be overridden
    /// if a style is explicitly set on the widget using `gtk.Widget.setStyle`.
    /// The `gtk.RcStyle`-struct is designed so each field can either be
    /// set or unset, so it is possible, using this function, to modify some
    /// style values and leave the others unchanged.
    ///
    /// Note that modifications made with this function are not cumulative
    /// with previous calls to `gtk.Widget.modifyStyle` or with such
    /// functions as `gtk.Widget.modifyFg`. If you wish to retain
    /// previous values, you must first call `gtk.Widget.getModifierStyle`,
    /// make your modifications to the returned style, then call
    /// `gtk.Widget.modifyStyle` with that style. On the other hand,
    /// if you first call `gtk.Widget.modifyStyle`, subsequent calls
    /// to such functions `gtk.Widget.modifyFg` will have a cumulative
    /// effect with the initial modifications.
    extern fn gtk_widget_modify_style(p_widget: *Widget, p_style: *gtk.RcStyle) void;
    pub const modifyStyle = gtk_widget_modify_style;

    /// Sets the text color for a widget in a particular state.
    ///
    /// All other style values are left untouched.
    /// The text color is the foreground color used along with the
    /// base color (see `gtk.Widget.modifyBase`) for widgets such
    /// as `gtk.Entry` and `gtk.TextView`.
    /// See also `gtk.Widget.modifyStyle`.
    extern fn gtk_widget_modify_text(p_widget: *Widget, p_state: gtk.StateType, p_color: ?*const gdk.Color) void;
    pub const modifyText = gtk_widget_modify_text;

    /// Sets the background color to use for a widget.
    ///
    /// All other style values are left untouched.
    /// See `gtk.Widget.overrideColor`.
    extern fn gtk_widget_override_background_color(p_widget: *Widget, p_state: gtk.StateFlags, p_color: ?*const gdk.RGBA) void;
    pub const overrideBackgroundColor = gtk_widget_override_background_color;

    /// Sets the color to use for a widget.
    ///
    /// All other style values are left untouched.
    ///
    /// This function does not act recursively. Setting the color of a
    /// container does not affect its children. Note that some widgets that
    /// you may not think of as containers, for instance `GtkButtons`,
    /// are actually containers.
    ///
    /// This API is mostly meant as a quick way for applications to
    /// change a widget appearance. If you are developing a widgets
    /// library and intend this change to be themeable, it is better
    /// done by setting meaningful CSS classes in your
    /// widget/container implementation through `gtk.StyleContext.addClass`.
    ///
    /// This way, your widget library can install a `gtk.CssProvider`
    /// with the `GTK_STYLE_PROVIDER_PRIORITY_FALLBACK` priority in order
    /// to provide a default styling for those widgets that need so, and
    /// this theming may fully overridden by the user’s theme.
    ///
    /// Note that for complex widgets this may bring in undesired
    /// results (such as uniform background color everywhere), in
    /// these cases it is better to fully style such widgets through a
    /// `gtk.CssProvider` with the `GTK_STYLE_PROVIDER_PRIORITY_APPLICATION`
    /// priority.
    extern fn gtk_widget_override_color(p_widget: *Widget, p_state: gtk.StateFlags, p_color: ?*const gdk.RGBA) void;
    pub const overrideColor = gtk_widget_override_color;

    /// Sets the cursor color to use in a widget, overriding the
    /// cursor-color and secondary-cursor-color
    /// style properties. All other style values are left untouched.
    /// See also `gtk.Widget.modifyStyle`.
    ///
    /// Note that the underlying properties have the `gdk.Color` type,
    /// so the alpha value in `primary` and `secondary` will be ignored.
    extern fn gtk_widget_override_cursor(p_widget: *Widget, p_cursor: ?*const gdk.RGBA, p_secondary_cursor: ?*const gdk.RGBA) void;
    pub const overrideCursor = gtk_widget_override_cursor;

    /// Sets the font to use for a widget. All other style values are
    /// left untouched. See `gtk.Widget.overrideColor`.
    extern fn gtk_widget_override_font(p_widget: *Widget, p_font_desc: ?*const pango.FontDescription) void;
    pub const overrideFont = gtk_widget_override_font;

    /// Sets a symbolic color for a widget.
    ///
    /// All other style values are left untouched.
    /// See `gtk.Widget.overrideColor` for overriding the foreground
    /// or background color.
    extern fn gtk_widget_override_symbolic_color(p_widget: *Widget, p_name: [*:0]const u8, p_color: ?*const gdk.RGBA) void;
    pub const overrideSymbolicColor = gtk_widget_override_symbolic_color;

    /// Obtains the full path to `widget`. The path is simply the name of a
    /// widget and all its parents in the container hierarchy, separated by
    /// periods. The name of a widget comes from
    /// `gtk.Widget.getName`. Paths are used to apply styles to a widget
    /// in gtkrc configuration files. Widget names are the type of the
    /// widget by default (e.g. “GtkButton”) or can be set to an
    /// application-specific value with `gtk.Widget.setName`. By setting
    /// the name of a widget, you allow users or theme authors to apply
    /// styles to that specific widget in their gtkrc
    /// file. `path_reversed_p` fills in the path in reverse order,
    /// i.e. starting with `widget`’s name instead of starting with the name
    /// of `widget`’s outermost ancestor.
    extern fn gtk_widget_path(p_widget: *Widget, p_path_length: ?*c_uint, p_path: ?*[*:0]u8, p_path_reversed: ?*[*:0]u8) void;
    pub const path = gtk_widget_path;

    /// This function is only for use in widget implementations.
    ///
    /// Flags the widget for a rerun of the GtkWidgetClass::size_allocate
    /// function. Use this function instead of `gtk.Widget.queueResize`
    /// when the `widget`'s size request didn't change but it wants to
    /// reposition its contents.
    ///
    /// An example user of this function is `gtk.Widget.setHalign`.
    extern fn gtk_widget_queue_allocate(p_widget: *Widget) void;
    pub const queueAllocate = gtk_widget_queue_allocate;

    /// Mark `widget` as needing to recompute its expand flags. Call
    /// this function when setting legacy expand child properties
    /// on the child of a container.
    ///
    /// See `gtk.Widget.computeExpand`.
    extern fn gtk_widget_queue_compute_expand(p_widget: *Widget) void;
    pub const queueComputeExpand = gtk_widget_queue_compute_expand;

    /// Equivalent to calling `gtk.Widget.queueDrawArea` for the
    /// entire area of a widget.
    extern fn gtk_widget_queue_draw(p_widget: *Widget) void;
    pub const queueDraw = gtk_widget_queue_draw;

    /// Convenience function that calls `gtk.Widget.queueDrawRegion` on
    /// the region created from the given coordinates.
    ///
    /// The region here is specified in widget coordinates.
    /// Widget coordinates are a bit odd; for historical reasons, they are
    /// defined as `widget`->window coordinates for widgets that return `TRUE` for
    /// `gtk.Widget.getHasWindow`, and are relative to `widget`->allocation.x,
    /// `widget`->allocation.y otherwise.
    ///
    /// `width` or `height` may be 0, in this case this function does
    /// nothing. Negative values for `width` and `height` are not allowed.
    extern fn gtk_widget_queue_draw_area(p_widget: *Widget, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void;
    pub const queueDrawArea = gtk_widget_queue_draw_area;

    /// Invalidates the area of `widget` defined by `region` by calling
    /// `gdk.Window.invalidateRegion` on the widget’s window and all its
    /// child windows. Once the main loop becomes idle (after the current
    /// batch of events has been processed, roughly), the window will
    /// receive expose events for the union of all regions that have been
    /// invalidated.
    ///
    /// Normally you would only use this function in widget
    /// implementations. You might also use it to schedule a redraw of a
    /// `gtk.DrawingArea` or some portion thereof.
    extern fn gtk_widget_queue_draw_region(p_widget: *Widget, p_region: *const cairo.Region) void;
    pub const queueDrawRegion = gtk_widget_queue_draw_region;

    /// This function is only for use in widget implementations.
    /// Flags a widget to have its size renegotiated; should
    /// be called when a widget for some reason has a new size request.
    /// For example, when you change the text in a `gtk.Label`, `gtk.Label`
    /// queues a resize to ensure there’s enough space for the new text.
    ///
    /// Note that you cannot call `gtk.Widget.queueResize` on a widget
    /// from inside its implementation of the GtkWidgetClass::size_allocate
    /// virtual method. Calls to `gtk.Widget.queueResize` from inside
    /// GtkWidgetClass::size_allocate will be silently ignored.
    extern fn gtk_widget_queue_resize(p_widget: *Widget) void;
    pub const queueResize = gtk_widget_queue_resize;

    /// This function works like `gtk.Widget.queueResize`,
    /// except that the widget is not invalidated.
    extern fn gtk_widget_queue_resize_no_redraw(p_widget: *Widget) void;
    pub const queueResizeNoRedraw = gtk_widget_queue_resize_no_redraw;

    /// Creates the GDK (windowing system) resources associated with a
    /// widget.  For example, `widget`->window will be created when a widget
    /// is realized.  Normally realization happens implicitly; if you show
    /// a widget and all its parent containers, then the widget will be
    /// realized and mapped automatically.
    ///
    /// Realizing a widget requires all
    /// the widget’s parent widgets to be realized; calling
    /// `gtk.Widget.realize` realizes the widget’s parents in addition to
    /// `widget` itself. If a widget is not yet inside a toplevel window
    /// when you realize it, bad things will happen.
    ///
    /// This function is primarily used in widget implementations, and
    /// isn’t very useful otherwise. Many times when you think you might
    /// need it, a better approach is to connect to a signal that will be
    /// called after the widget is realized automatically, such as
    /// `gtk.Widget.signals.draw`. Or simply g_signal_connect () to the
    /// `gtk.Widget.signals.realize` signal.
    extern fn gtk_widget_realize(p_widget: *Widget) void;
    pub const realize = gtk_widget_realize;

    /// Computes the intersection of a `widget`’s area and `region`, returning
    /// the intersection. The result may be empty, use `cairo_region_is_empty` to
    /// check.
    extern fn gtk_widget_region_intersect(p_widget: *Widget, p_region: *const cairo.Region) *cairo.Region;
    pub const regionIntersect = gtk_widget_region_intersect;

    /// Registers a `gdk.Window` with the widget and sets it up so that
    /// the widget receives events for it. Call `gtk.Widget.unregisterWindow`
    /// when destroying the window.
    ///
    /// Before 3.8 you needed to call `gdk.Window.setUserData` directly to set
    /// this up. This is now deprecated and you should use `gtk.Widget.registerWindow`
    /// instead. Old code will keep working as is, although some new features like
    /// transparency might not work perfectly.
    extern fn gtk_widget_register_window(p_widget: *Widget, p_window: *gdk.Window) void;
    pub const registerWindow = gtk_widget_register_window;

    /// Removes an accelerator from `widget`, previously installed with
    /// `gtk.Widget.addAccelerator`.
    extern fn gtk_widget_remove_accelerator(p_widget: *Widget, p_accel_group: *gtk.AccelGroup, p_accel_key: c_uint, p_accel_mods: gdk.ModifierType) c_int;
    pub const removeAccelerator = gtk_widget_remove_accelerator;

    /// Removes a widget from the list of mnemonic labels for
    /// this widget. (See `gtk.Widget.listMnemonicLabels`). The widget
    /// must have previously been added to the list with
    /// `gtk.Widget.addMnemonicLabel`.
    extern fn gtk_widget_remove_mnemonic_label(p_widget: *Widget, p_label: *gtk.Widget) void;
    pub const removeMnemonicLabel = gtk_widget_remove_mnemonic_label;

    /// Removes a tick callback previously registered with
    /// `gtk.Widget.addTickCallback`.
    extern fn gtk_widget_remove_tick_callback(p_widget: *Widget, p_id: c_uint) void;
    pub const removeTickCallback = gtk_widget_remove_tick_callback;

    /// A convenience function that uses the theme settings for `widget`
    /// to look up `stock_id` and render it to a pixbuf. `stock_id` should
    /// be a stock icon ID such as `GTK_STOCK_OPEN` or `GTK_STOCK_OK`. `size`
    /// should be a size such as `GTK_ICON_SIZE_MENU`. `detail` should be a
    /// string that identifies the widget or code doing the rendering, so
    /// that theme engines can special-case rendering for that widget or
    /// code.
    ///
    /// The pixels in the returned `gdkpixbuf.Pixbuf` are shared with the rest of
    /// the application and should not be modified. The pixbuf should be
    /// freed after use with `gobject.Object.unref`.
    extern fn gtk_widget_render_icon(p_widget: *Widget, p_stock_id: [*:0]const u8, p_size: c_int, p_detail: ?[*:0]const u8) ?*gdkpixbuf.Pixbuf;
    pub const renderIcon = gtk_widget_render_icon;

    /// A convenience function that uses the theme engine and style
    /// settings for `widget` to look up `stock_id` and render it to
    /// a pixbuf. `stock_id` should be a stock icon ID such as
    /// `GTK_STOCK_OPEN` or `GTK_STOCK_OK`. `size` should be a size
    /// such as `GTK_ICON_SIZE_MENU`.
    ///
    /// The pixels in the returned `gdkpixbuf.Pixbuf` are shared with the rest of
    /// the application and should not be modified. The pixbuf should be freed
    /// after use with `gobject.Object.unref`.
    extern fn gtk_widget_render_icon_pixbuf(p_widget: *Widget, p_stock_id: [*:0]const u8, p_size: c_int) ?*gdkpixbuf.Pixbuf;
    pub const renderIconPixbuf = gtk_widget_render_icon_pixbuf;

    /// Moves a widget from one `gtk.Container` to another, handling reference
    /// count issues to avoid destroying the widget.
    extern fn gtk_widget_reparent(p_widget: *Widget, p_new_parent: *gtk.Widget) void;
    pub const reparent = gtk_widget_reparent;

    /// Reset the styles of `widget` and all descendents, so when
    /// they are looked up again, they get the correct values
    /// for the currently loaded RC file settings.
    ///
    /// This function is not useful for applications.
    extern fn gtk_widget_reset_rc_styles(p_widget: *Widget) void;
    pub const resetRcStyles = gtk_widget_reset_rc_styles;

    /// Updates the style context of `widget` and all descendants
    /// by updating its widget path. `GtkContainers` may want
    /// to use this on a child when reordering it in a way that a different
    /// style might apply to it. See also `gtk.Container.getPathForChild`.
    extern fn gtk_widget_reset_style(p_widget: *Widget) void;
    pub const resetStyle = gtk_widget_reset_style;

    /// Very rarely-used function. This function is used to emit
    /// an expose event on a widget. This function is not normally used
    /// directly. The only time it is used is when propagating an expose
    /// event to a windowless child widget (`gtk.Widget.getHasWindow` is `FALSE`),
    /// and that is normally done using `gtk.Container.propagateDraw`.
    ///
    /// If you want to force an area of a window to be redrawn,
    /// use `gdk.Window.invalidateRect` or `gdk.Window.invalidateRegion`.
    /// To cause the redraw to be done immediately, follow that call
    /// with a call to `gdk.Window.processUpdates`.
    extern fn gtk_widget_send_expose(p_widget: *Widget, p_event: *gdk.Event) c_int;
    pub const sendExpose = gtk_widget_send_expose;

    /// Sends the focus change `event` to `widget`
    ///
    /// This function is not meant to be used by applications. The only time it
    /// should be used is when it is necessary for a `gtk.Widget` to assign focus
    /// to a widget that is semantically owned by the first widget even though
    /// it’s not a direct child - for instance, a search entry in a floating
    /// window similar to the quick search in `gtk.TreeView`.
    ///
    /// An example of its usage is:
    ///
    /// ```
    ///   GdkEvent *fevent = gdk_event_new (GDK_FOCUS_CHANGE);
    ///
    ///   fevent->focus_change.type = GDK_FOCUS_CHANGE;
    ///   fevent->focus_change.in = TRUE;
    ///   fevent->focus_change.window = _gtk_widget_get_window (widget);
    ///   if (fevent->focus_change.window != NULL)
    ///     g_object_ref (fevent->focus_change.window);
    ///
    ///   gtk_widget_send_focus_change (widget, fevent);
    ///
    ///   gdk_event_free (event);
    /// ```
    extern fn gtk_widget_send_focus_change(p_widget: *Widget, p_event: *gdk.Event) c_int;
    pub const sendFocusChange = gtk_widget_send_focus_change;

    /// Given an accelerator group, `accel_group`, and an accelerator path,
    /// `accel_path`, sets up an accelerator in `accel_group` so whenever the
    /// key binding that is defined for `accel_path` is pressed, `widget`
    /// will be activated.  This removes any accelerators (for any
    /// accelerator group) installed by previous calls to
    /// `gtk.Widget.setAccelPath`. Associating accelerators with
    /// paths allows them to be modified by the user and the modifications
    /// to be saved for future use. (See `gtk.AccelMap.save`.)
    ///
    /// This function is a low level function that would most likely
    /// be used by a menu creation system like `gtk.UIManager`. If you
    /// use `gtk.UIManager`, setting up accelerator paths will be done
    /// automatically.
    ///
    /// Even when you you aren’t using `gtk.UIManager`, if you only want to
    /// set up accelerators on menu items `gtk.MenuItem.setAccelPath`
    /// provides a somewhat more convenient interface.
    ///
    /// Note that `accel_path` string will be stored in a `glib.Quark`. Therefore, if you
    /// pass a static string, you can save some memory by interning it first with
    /// `glib.internStaticString`.
    extern fn gtk_widget_set_accel_path(p_widget: *Widget, p_accel_path: ?[*:0]const u8, p_accel_group: ?*gtk.AccelGroup) void;
    pub const setAccelPath = gtk_widget_set_accel_path;

    /// Sets the widget’s allocation.  This should not be used
    /// directly, but from within a widget’s size_allocate method.
    ///
    /// The allocation set should be the “adjusted” or actual
    /// allocation. If you’re implementing a `gtk.Container`, you want to use
    /// `gtk.Widget.sizeAllocate` instead of `gtk.Widget.setAllocation`.
    /// The GtkWidgetClass::adjust_size_allocation virtual method adjusts the
    /// allocation inside `gtk.Widget.sizeAllocate` to create an adjusted
    /// allocation.
    extern fn gtk_widget_set_allocation(p_widget: *Widget, p_allocation: *const gtk.Allocation) void;
    pub const setAllocation = gtk_widget_set_allocation;

    /// Sets whether the application intends to draw on the widget in
    /// an `gtk.Widget.signals.draw` handler.
    ///
    /// This is a hint to the widget and does not affect the behavior of
    /// the GTK+ core; many widgets ignore this flag entirely. For widgets
    /// that do pay attention to the flag, such as `gtk.EventBox` and `gtk.Window`,
    /// the effect is to suppress default themed drawing of the widget's
    /// background. (Children of the widget will still be drawn.) The application
    /// is then entirely responsible for drawing the widget background.
    ///
    /// Note that the background is still drawn when the widget is mapped.
    extern fn gtk_widget_set_app_paintable(p_widget: *Widget, p_app_paintable: c_int) void;
    pub const setAppPaintable = gtk_widget_set_app_paintable;

    /// Specifies whether `widget` can be a default widget. See
    /// `gtk.Widget.grabDefault` for details about the meaning of
    /// “default”.
    extern fn gtk_widget_set_can_default(p_widget: *Widget, p_can_default: c_int) void;
    pub const setCanDefault = gtk_widget_set_can_default;

    /// Specifies whether `widget` can own the input focus. See
    /// `gtk.Widget.grabFocus` for actually setting the input focus on a
    /// widget.
    extern fn gtk_widget_set_can_focus(p_widget: *Widget, p_can_focus: c_int) void;
    pub const setCanFocus = gtk_widget_set_can_focus;

    /// Sets whether `widget` should be mapped along with its when its parent
    /// is mapped and `widget` has been shown with `gtk.Widget.show`.
    ///
    /// The child visibility can be set for widget before it is added to
    /// a container with `gtk.Widget.setParent`, to avoid mapping
    /// children unnecessary before immediately unmapping them. However
    /// it will be reset to its default state of `TRUE` when the widget
    /// is removed from a container.
    ///
    /// Note that changing the child visibility of a widget does not
    /// queue a resize on the widget. Most of the time, the size of
    /// a widget is computed from all visible children, whether or
    /// not they are mapped. If this is not the case, the container
    /// can queue a resize itself.
    ///
    /// This function is only useful for container implementations and
    /// never should be called by an application.
    extern fn gtk_widget_set_child_visible(p_widget: *Widget, p_is_visible: c_int) void;
    pub const setChildVisible = gtk_widget_set_child_visible;

    /// Sets the widget’s clip.  This must not be used directly,
    /// but from within a widget’s size_allocate method.
    /// It must be called after `gtk.Widget.setAllocation` (or after chaining up
    /// to the parent class), because that function resets the clip.
    ///
    /// The clip set should be the area that `widget` draws on. If `widget` is a
    /// `gtk.Container`, the area must contain all children's clips.
    ///
    /// If this function is not called by `widget` during a ::size-allocate handler,
    /// the clip will be set to `widget`'s allocation.
    extern fn gtk_widget_set_clip(p_widget: *Widget, p_clip: *const gtk.Allocation) void;
    pub const setClip = gtk_widget_set_clip;

    /// Sets a widgets composite name. The widget must be
    /// a composite child of its parent; see `gtk.Widget.pushCompositeChild`.
    extern fn gtk_widget_set_composite_name(p_widget: *Widget, p_name: [*:0]const u8) void;
    pub const setCompositeName = gtk_widget_set_composite_name;

    /// Enables or disables a `gdk.Device` to interact with `widget`
    /// and all its children.
    ///
    /// It does so by descending through the `gdk.Window` hierarchy
    /// and enabling the same mask that is has for core events
    /// (i.e. the one that `gdk.Window.getEvents` returns).
    extern fn gtk_widget_set_device_enabled(p_widget: *Widget, p_device: *gdk.Device, p_enabled: c_int) void;
    pub const setDeviceEnabled = gtk_widget_set_device_enabled;

    /// Sets the device event mask (see `gdk.EventMask`) for a widget. The event
    /// mask determines which events a widget will receive from `device`. Keep
    /// in mind that different widgets have different default event masks, and by
    /// changing the event mask you may disrupt a widget’s functionality,
    /// so be careful. This function must be called while a widget is
    /// unrealized. Consider `gtk.Widget.addDeviceEvents` for widgets that are
    /// already realized, or if you want to preserve the existing event
    /// mask. This function can’t be used with windowless widgets (which return
    /// `FALSE` from `gtk.Widget.getHasWindow`);
    /// to get events on those widgets, place them inside a `gtk.EventBox`
    /// and receive events on the event box.
    extern fn gtk_widget_set_device_events(p_widget: *Widget, p_device: *gdk.Device, p_events: gdk.EventMask) void;
    pub const setDeviceEvents = gtk_widget_set_device_events;

    /// Sets the reading direction on a particular widget. This direction
    /// controls the primary direction for widgets containing text,
    /// and also the direction in which the children of a container are
    /// packed. The ability to set the direction is present in order
    /// so that correct localization into languages with right-to-left
    /// reading directions can be done. Generally, applications will
    /// let the default reading direction present, except for containers
    /// where the containers are arranged in an order that is explicitly
    /// visual rather than logical (such as buttons for text justification).
    ///
    /// If the direction is set to `GTK_TEXT_DIR_NONE`, then the value
    /// set by `gtk.Widget.setDefaultDirection` will be used.
    extern fn gtk_widget_set_direction(p_widget: *Widget, p_dir: gtk.TextDirection) void;
    pub const setDirection = gtk_widget_set_direction;

    /// Widgets are double buffered by default; you can use this function
    /// to turn off the buffering. “Double buffered” simply means that
    /// `gdk.Window.beginDrawFrame` and `gdk.Window.endDrawFrame` are called
    /// automatically around expose events sent to the
    /// widget. `gdk.Window.beginDrawFrame` diverts all drawing to a widget's
    /// window to an offscreen buffer, and `gdk.Window.endDrawFrame` draws the
    /// buffer to the screen. The result is that users see the window
    /// update in one smooth step, and don’t see individual graphics
    /// primitives being rendered.
    ///
    /// In very simple terms, double buffered widgets don’t flicker,
    /// so you would only use this function to turn off double buffering
    /// if you had special needs and really knew what you were doing.
    ///
    /// Note: if you turn off double-buffering, you have to handle
    /// expose events, since even the clearing to the background color or
    /// pixmap will not happen automatically (as it is done in
    /// `gdk.Window.beginDrawFrame`).
    ///
    /// In 3.10 GTK and GDK have been restructured for translucent drawing. Since
    /// then expose events for double-buffered widgets are culled into a single
    /// event to the toplevel GDK window. If you now unset double buffering, you
    /// will cause a separate rendering pass for every widget. This will likely
    /// cause rendering problems - in particular related to stacking - and usually
    /// increases rendering times significantly.
    extern fn gtk_widget_set_double_buffered(p_widget: *Widget, p_double_buffered: c_int) void;
    pub const setDoubleBuffered = gtk_widget_set_double_buffered;

    /// Sets the event mask (see `gdk.EventMask`) for a widget. The event
    /// mask determines which events a widget will receive. Keep in mind
    /// that different widgets have different default event masks, and by
    /// changing the event mask you may disrupt a widget’s functionality,
    /// so be careful. This function must be called while a widget is
    /// unrealized. Consider `gtk.Widget.addEvents` for widgets that are
    /// already realized, or if you want to preserve the existing event
    /// mask. This function can’t be used with widgets that have no window.
    /// (See `gtk.Widget.getHasWindow`).  To get events on those widgets,
    /// place them inside a `gtk.EventBox` and receive events on the event
    /// box.
    extern fn gtk_widget_set_events(p_widget: *Widget, p_events: c_int) void;
    pub const setEvents = gtk_widget_set_events;

    /// Sets whether the widget should grab focus when it is clicked with the mouse.
    /// Making mouse clicks not grab focus is useful in places like toolbars where
    /// you don’t want the keyboard focus removed from the main area of the
    /// application.
    extern fn gtk_widget_set_focus_on_click(p_widget: *Widget, p_focus_on_click: c_int) void;
    pub const setFocusOnClick = gtk_widget_set_focus_on_click;

    /// Sets the font map to use for Pango rendering. When not set, the widget
    /// will inherit the font map from its parent.
    extern fn gtk_widget_set_font_map(p_widget: *Widget, p_font_map: ?*pango.FontMap) void;
    pub const setFontMap = gtk_widget_set_font_map;

    /// Sets the `cairo.FontOptions` used for Pango rendering in this widget.
    /// When not set, the default font options for the `gdk.Screen` will be used.
    extern fn gtk_widget_set_font_options(p_widget: *Widget, p_options: ?*const cairo.FontOptions) void;
    pub const setFontOptions = gtk_widget_set_font_options;

    /// Sets the horizontal alignment of `widget`.
    /// See the `gtk.Widget.properties.halign` property.
    extern fn gtk_widget_set_halign(p_widget: *Widget, p_align: gtk.Align) void;
    pub const setHalign = gtk_widget_set_halign;

    /// Sets the has-tooltip property on `widget` to `has_tooltip`.  See
    /// `gtk.Widget.properties.has`-tooltip for more information.
    extern fn gtk_widget_set_has_tooltip(p_widget: *Widget, p_has_tooltip: c_int) void;
    pub const setHasTooltip = gtk_widget_set_has_tooltip;

    /// Specifies whether `widget` has a `gdk.Window` of its own. Note that
    /// all realized widgets have a non-`NULL` “window” pointer
    /// (`gtk.Widget.getWindow` never returns a `NULL` window when a widget
    /// is realized), but for many of them it’s actually the `gdk.Window` of
    /// one of its parent widgets. Widgets that do not create a `window` for
    /// themselves in `gtk.Widget.signals.realize` must announce this by
    /// calling this function with `has_window` = `FALSE`.
    ///
    /// This function should only be called by widget implementations,
    /// and they should call it in their `init` function.
    extern fn gtk_widget_set_has_window(p_widget: *Widget, p_has_window: c_int) void;
    pub const setHasWindow = gtk_widget_set_has_window;

    /// Sets whether the widget would like any available extra horizontal
    /// space. When a user resizes a `gtk.Window`, widgets with expand=TRUE
    /// generally receive the extra space. For example, a list or
    /// scrollable area or document in your window would often be set to
    /// expand.
    ///
    /// Call this function to set the expand flag if you would like your
    /// widget to become larger horizontally when the window has extra
    /// room.
    ///
    /// By default, widgets automatically expand if any of their children
    /// want to expand. (To see if a widget will automatically expand given
    /// its current children and state, call `gtk.Widget.computeExpand`. A
    /// container can decide how the expandability of children affects the
    /// expansion of the container by overriding the compute_expand virtual
    /// method on `gtk.Widget`.).
    ///
    /// Setting hexpand explicitly with this function will override the
    /// automatic expand behavior.
    ///
    /// This function forces the widget to expand or not to expand,
    /// regardless of children.  The override occurs because
    /// `gtk.Widget.setHexpand` sets the hexpand-set property (see
    /// `gtk.Widget.setHexpandSet`) which causes the widget’s hexpand
    /// value to be used, rather than looking at children and widget state.
    extern fn gtk_widget_set_hexpand(p_widget: *Widget, p_expand: c_int) void;
    pub const setHexpand = gtk_widget_set_hexpand;

    /// Sets whether the hexpand flag (see `gtk.Widget.getHexpand`) will
    /// be used.
    ///
    /// The hexpand-set property will be set automatically when you call
    /// `gtk.Widget.setHexpand` to set hexpand, so the most likely
    /// reason to use this function would be to unset an explicit expand
    /// flag.
    ///
    /// If hexpand is set, then it overrides any computed
    /// expand value based on child widgets. If hexpand is not
    /// set, then the expand value depends on whether any
    /// children of the widget would like to expand.
    ///
    /// There are few reasons to use this function, but it’s here
    /// for completeness and consistency.
    extern fn gtk_widget_set_hexpand_set(p_widget: *Widget, p_set: c_int) void;
    pub const setHexpandSet = gtk_widget_set_hexpand_set;

    /// Marks the widget as being mapped.
    ///
    /// This function should only ever be called in a derived widget's
    /// “map” or “unmap” implementation.
    extern fn gtk_widget_set_mapped(p_widget: *Widget, p_mapped: c_int) void;
    pub const setMapped = gtk_widget_set_mapped;

    /// Sets the bottom margin of `widget`.
    /// See the `gtk.Widget.properties.margin`-bottom property.
    extern fn gtk_widget_set_margin_bottom(p_widget: *Widget, p_margin: c_int) void;
    pub const setMarginBottom = gtk_widget_set_margin_bottom;

    /// Sets the end margin of `widget`.
    /// See the `gtk.Widget.properties.margin`-end property.
    extern fn gtk_widget_set_margin_end(p_widget: *Widget, p_margin: c_int) void;
    pub const setMarginEnd = gtk_widget_set_margin_end;

    /// Sets the left margin of `widget`.
    /// See the `gtk.Widget.properties.margin`-left property.
    extern fn gtk_widget_set_margin_left(p_widget: *Widget, p_margin: c_int) void;
    pub const setMarginLeft = gtk_widget_set_margin_left;

    /// Sets the right margin of `widget`.
    /// See the `gtk.Widget.properties.margin`-right property.
    extern fn gtk_widget_set_margin_right(p_widget: *Widget, p_margin: c_int) void;
    pub const setMarginRight = gtk_widget_set_margin_right;

    /// Sets the start margin of `widget`.
    /// See the `gtk.Widget.properties.margin`-start property.
    extern fn gtk_widget_set_margin_start(p_widget: *Widget, p_margin: c_int) void;
    pub const setMarginStart = gtk_widget_set_margin_start;

    /// Sets the top margin of `widget`.
    /// See the `gtk.Widget.properties.margin`-top property.
    extern fn gtk_widget_set_margin_top(p_widget: *Widget, p_margin: c_int) void;
    pub const setMarginTop = gtk_widget_set_margin_top;

    /// Widgets can be named, which allows you to refer to them from a
    /// CSS file. You can apply a style to widgets with a particular name
    /// in the CSS file. See the documentation for the CSS syntax (on the
    /// same page as the docs for `gtk.StyleContext`).
    ///
    /// Note that the CSS syntax has certain special characters to delimit
    /// and represent elements in a selector (period, #, >, *...), so using
    /// these will make your widget impossible to match by name. Any combination
    /// of alphanumeric symbols, dashes and underscores will suffice.
    extern fn gtk_widget_set_name(p_widget: *Widget, p_name: [*:0]const u8) void;
    pub const setName = gtk_widget_set_name;

    /// Sets the `gtk.Widget.properties.no`-show-all property, which determines whether
    /// calls to `gtk.Widget.showAll` will affect this widget.
    ///
    /// This is mostly for use in constructing widget hierarchies with externally
    /// controlled visibility, see `gtk.UIManager`.
    extern fn gtk_widget_set_no_show_all(p_widget: *Widget, p_no_show_all: c_int) void;
    pub const setNoShowAll = gtk_widget_set_no_show_all;

    /// Request the `widget` to be rendered partially transparent,
    /// with opacity 0 being fully transparent and 1 fully opaque. (Opacity values
    /// are clamped to the [0,1] range.).
    /// This works on both toplevel widget, and child widgets, although there
    /// are some limitations:
    ///
    /// For toplevel widgets this depends on the capabilities of the windowing
    /// system. On X11 this has any effect only on X screens with a compositing manager
    /// running. See `gtk.Widget.isComposited`. On Windows it should work
    /// always, although setting a window’s opacity after the window has been
    /// shown causes it to flicker once on Windows.
    ///
    /// For child widgets it doesn’t work if any affected widget has a native window, or
    /// disables double buffering.
    extern fn gtk_widget_set_opacity(p_widget: *Widget, p_opacity: f64) void;
    pub const setOpacity = gtk_widget_set_opacity;

    /// This function is useful only when implementing subclasses of
    /// `gtk.Container`.
    /// Sets the container as the parent of `widget`, and takes care of
    /// some details such as updating the state and style of the child
    /// to reflect its new location. The opposite function is
    /// `gtk.Widget.unparent`.
    extern fn gtk_widget_set_parent(p_widget: *Widget, p_parent: *gtk.Widget) void;
    pub const setParent = gtk_widget_set_parent;

    /// Sets a non default parent window for `widget`.
    ///
    /// For `gtk.Window` classes, setting a `parent_window` effects whether
    /// the window is a toplevel window or can be embedded into other
    /// widgets.
    ///
    /// For `gtk.Window` classes, this needs to be called before the
    /// window is realized.
    extern fn gtk_widget_set_parent_window(p_widget: *Widget, p_parent_window: *gdk.Window) void;
    pub const setParentWindow = gtk_widget_set_parent_window;

    /// Marks the widget as being realized. This function must only be
    /// called after all `GdkWindows` for the `widget` have been created
    /// and registered.
    ///
    /// This function should only ever be called in a derived widget's
    /// “realize” or “unrealize” implementation.
    extern fn gtk_widget_set_realized(p_widget: *Widget, p_realized: c_int) void;
    pub const setRealized = gtk_widget_set_realized;

    /// Specifies whether `widget` will be treated as the default widget
    /// within its toplevel when it has the focus, even if another widget
    /// is the default.
    ///
    /// See `gtk.Widget.grabDefault` for details about the meaning of
    /// “default”.
    extern fn gtk_widget_set_receives_default(p_widget: *Widget, p_receives_default: c_int) void;
    pub const setReceivesDefault = gtk_widget_set_receives_default;

    /// Sets whether the entire widget is queued for drawing when its size
    /// allocation changes. By default, this setting is `TRUE` and
    /// the entire widget is redrawn on every size change. If your widget
    /// leaves the upper left unchanged when made bigger, turning this
    /// setting off will improve performance.
    ///
    /// Note that for widgets where `gtk.Widget.getHasWindow` is `FALSE`
    /// setting this flag to `FALSE` turns off all allocation on resizing:
    /// the widget will not even redraw if its position changes; this is to
    /// allow containers that don’t draw anything to avoid excess
    /// invalidations. If you set this flag on a widget with no window that
    /// does draw on `widget`->window, you are
    /// responsible for invalidating both the old and new allocation of the
    /// widget when the widget is moved and responsible for invalidating
    /// regions newly when the widget increases size.
    extern fn gtk_widget_set_redraw_on_allocate(p_widget: *Widget, p_redraw_on_allocate: c_int) void;
    pub const setRedrawOnAllocate = gtk_widget_set_redraw_on_allocate;

    /// Sets the sensitivity of a widget. A widget is sensitive if the user
    /// can interact with it. Insensitive widgets are “grayed out” and the
    /// user can’t interact with them. Insensitive widgets are known as
    /// “inactive”, “disabled”, or “ghosted” in some other toolkits.
    extern fn gtk_widget_set_sensitive(p_widget: *Widget, p_sensitive: c_int) void;
    pub const setSensitive = gtk_widget_set_sensitive;

    /// Sets the minimum size of a widget; that is, the widget’s size
    /// request will be at least `width` by `height`. You can use this
    /// function to force a widget to be larger than it normally would be.
    ///
    /// In most cases, `gtk.Window.setDefaultSize` is a better choice for
    /// toplevel windows than this function; setting the default size will
    /// still allow users to shrink the window. Setting the size request
    /// will force them to leave the window at least as large as the size
    /// request. When dealing with window sizes,
    /// `gtk.Window.setGeometryHints` can be a useful function as well.
    ///
    /// Note the inherent danger of setting any fixed size - themes,
    /// translations into other languages, different fonts, and user action
    /// can all change the appropriate size for a given widget. So, it's
    /// basically impossible to hardcode a size that will always be
    /// correct.
    ///
    /// The size request of a widget is the smallest size a widget can
    /// accept while still functioning well and drawing itself correctly.
    /// However in some strange cases a widget may be allocated less than
    /// its requested size, and in many cases a widget may be allocated more
    /// space than it requested.
    ///
    /// If the size request in a given direction is -1 (unset), then
    /// the “natural” size request of the widget will be used instead.
    ///
    /// The size request set here does not include any margin from the
    /// `gtk.Widget` properties margin-left, margin-right, margin-top, and
    /// margin-bottom, but it does include pretty much all other padding
    /// or border properties set by any subclass of `gtk.Widget`.
    extern fn gtk_widget_set_size_request(p_widget: *Widget, p_width: c_int, p_height: c_int) void;
    pub const setSizeRequest = gtk_widget_set_size_request;

    /// This function is for use in widget implementations. Sets the state
    /// of a widget (insensitive, prelighted, etc.) Usually you should set
    /// the state using wrapper functions such as `gtk.Widget.setSensitive`.
    extern fn gtk_widget_set_state(p_widget: *Widget, p_state: gtk.StateType) void;
    pub const setState = gtk_widget_set_state;

    /// This function is for use in widget implementations. Turns on flag
    /// values in the current widget state (insensitive, prelighted, etc.).
    ///
    /// This function accepts the values `GTK_STATE_FLAG_DIR_LTR` and
    /// `GTK_STATE_FLAG_DIR_RTL` but ignores them. If you want to set the widget's
    /// direction, use `gtk.Widget.setDirection`.
    ///
    /// It is worth mentioning that any other state than `GTK_STATE_FLAG_INSENSITIVE`,
    /// will be propagated down to all non-internal children if `widget` is a
    /// `gtk.Container`, while `GTK_STATE_FLAG_INSENSITIVE` itself will be propagated
    /// down to all `gtk.Container` children by different means than turning on the
    /// state flag down the hierarchy, both `gtk.Widget.getStateFlags` and
    /// `gtk.Widget.isSensitive` will make use of these.
    extern fn gtk_widget_set_state_flags(p_widget: *Widget, p_flags: gtk.StateFlags, p_clear: c_int) void;
    pub const setStateFlags = gtk_widget_set_state_flags;

    /// Used to set the `gtk.Style` for a widget (`widget`->style). Since
    /// GTK 3, this function does nothing, the passed in style is ignored.
    extern fn gtk_widget_set_style(p_widget: *Widget, p_style: ?*gtk.Style) void;
    pub const setStyle = gtk_widget_set_style;

    /// Enables or disables multiple pointer awareness. If this setting is `TRUE`,
    /// `widget` will start receiving multiple, per device enter/leave events. Note
    /// that if custom `GdkWindows` are created in `gtk.Widget.signals.realize`,
    /// `gdk.Window.setSupportMultidevice` will have to be called manually on them.
    extern fn gtk_widget_set_support_multidevice(p_widget: *Widget, p_support_multidevice: c_int) void;
    pub const setSupportMultidevice = gtk_widget_set_support_multidevice;

    /// Sets `markup` as the contents of the tooltip, which is marked up with
    ///  the [Pango text markup language][PangoMarkupFormat].
    ///
    /// This function will take care of setting `gtk.Widget.properties.has`-tooltip to `TRUE`
    /// and of the default handler for the `gtk.Widget.signals.query`-tooltip signal.
    ///
    /// See also the `gtk.Widget.properties.tooltip`-markup property and
    /// `gtk.Tooltip.setMarkup`.
    extern fn gtk_widget_set_tooltip_markup(p_widget: *Widget, p_markup: ?[*:0]const u8) void;
    pub const setTooltipMarkup = gtk_widget_set_tooltip_markup;

    /// Sets `text` as the contents of the tooltip. This function will take
    /// care of setting `gtk.Widget.properties.has`-tooltip to `TRUE` and of the default
    /// handler for the `gtk.Widget.signals.query`-tooltip signal.
    ///
    /// See also the `gtk.Widget.properties.tooltip`-text property and `gtk.Tooltip.setText`.
    extern fn gtk_widget_set_tooltip_text(p_widget: *Widget, p_text: ?[*:0]const u8) void;
    pub const setTooltipText = gtk_widget_set_tooltip_text;

    /// Replaces the default window used for displaying
    /// tooltips with `custom_window`. GTK+ will take care of showing and
    /// hiding `custom_window` at the right moment, to behave likewise as
    /// the default tooltip window. If `custom_window` is `NULL`, the default
    /// tooltip window will be used.
    extern fn gtk_widget_set_tooltip_window(p_widget: *Widget, p_custom_window: ?*gtk.Window) void;
    pub const setTooltipWindow = gtk_widget_set_tooltip_window;

    /// Sets the vertical alignment of `widget`.
    /// See the `gtk.Widget.properties.valign` property.
    extern fn gtk_widget_set_valign(p_widget: *Widget, p_align: gtk.Align) void;
    pub const setValign = gtk_widget_set_valign;

    /// Sets whether the widget would like any available extra vertical
    /// space.
    ///
    /// See `gtk.Widget.setHexpand` for more detail.
    extern fn gtk_widget_set_vexpand(p_widget: *Widget, p_expand: c_int) void;
    pub const setVexpand = gtk_widget_set_vexpand;

    /// Sets whether the vexpand flag (see `gtk.Widget.getVexpand`) will
    /// be used.
    ///
    /// See `gtk.Widget.setHexpandSet` for more detail.
    extern fn gtk_widget_set_vexpand_set(p_widget: *Widget, p_set: c_int) void;
    pub const setVexpandSet = gtk_widget_set_vexpand_set;

    /// Sets the visibility state of `widget`. Note that setting this to
    /// `TRUE` doesn’t mean the widget is actually viewable, see
    /// `gtk.Widget.getVisible`.
    ///
    /// This function simply calls `gtk.Widget.show` or `gtk.Widget.hide`
    /// but is nicer to use when the visibility of the widget depends on
    /// some condition.
    extern fn gtk_widget_set_visible(p_widget: *Widget, p_visible: c_int) void;
    pub const setVisible = gtk_widget_set_visible;

    /// Sets the visual that should be used for by widget and its children for
    /// creating `GdkWindows`. The visual must be on the same `gdk.Screen` as
    /// returned by `gtk.Widget.getScreen`, so handling the
    /// `gtk.Widget.signals.screen`-changed signal is necessary.
    ///
    /// Setting a new `visual` will not cause `widget` to recreate its windows,
    /// so you should call this function before `widget` is realized.
    extern fn gtk_widget_set_visual(p_widget: *Widget, p_visual: ?*gdk.Visual) void;
    pub const setVisual = gtk_widget_set_visual;

    /// Sets a widget’s window. This function should only be used in a
    /// widget’s `gtk.Widget.signals.realize` implementation. The `window` passed is
    /// usually either new window created with `gdk.Window.new`, or the
    /// window of its parent widget as returned by
    /// `gtk.Widget.getParentWindow`.
    ///
    /// Widgets must indicate whether they will create their own `gdk.Window`
    /// by calling `gtk.Widget.setHasWindow`. This is usually done in the
    /// widget’s `init` function.
    ///
    /// Note that this function does not add any reference to `window`.
    extern fn gtk_widget_set_window(p_widget: *Widget, p_window: *gdk.Window) void;
    pub const setWindow = gtk_widget_set_window;

    /// Sets a shape for this widget’s GDK window. This allows for
    /// transparent windows etc., see `gdk.Window.shapeCombineRegion`
    /// for more information.
    extern fn gtk_widget_shape_combine_region(p_widget: *Widget, p_region: ?*cairo.Region) void;
    pub const shapeCombineRegion = gtk_widget_shape_combine_region;

    /// Flags a widget to be displayed. Any widget that isn’t shown will
    /// not appear on the screen. If you want to show all the widgets in a
    /// container, it’s easier to call `gtk.Widget.showAll` on the
    /// container, instead of individually showing the widgets.
    ///
    /// Remember that you have to show the containers containing a widget,
    /// in addition to the widget itself, before it will appear onscreen.
    ///
    /// When a toplevel container is shown, it is immediately realized and
    /// mapped; other shown widgets are realized and mapped when their
    /// toplevel container is realized and mapped.
    extern fn gtk_widget_show(p_widget: *Widget) void;
    pub const show = gtk_widget_show;

    /// Recursively shows a widget, and any child widgets (if the widget is
    /// a container).
    extern fn gtk_widget_show_all(p_widget: *Widget) void;
    pub const showAll = gtk_widget_show_all;

    /// Shows a widget. If the widget is an unmapped toplevel widget
    /// (i.e. a `gtk.Window` that has not yet been shown), enter the main
    /// loop and wait for the window to actually be mapped. Be careful;
    /// because the main loop is running, anything can happen during
    /// this function.
    extern fn gtk_widget_show_now(p_widget: *Widget) void;
    pub const showNow = gtk_widget_show_now;

    /// This function is only used by `gtk.Container` subclasses, to assign a size
    /// and position to their child widgets.
    ///
    /// In this function, the allocation may be adjusted. It will be forced
    /// to a 1x1 minimum size, and the adjust_size_allocation virtual
    /// method on the child will be used to adjust the allocation. Standard
    /// adjustments include removing the widget’s margins, and applying the
    /// widget’s `gtk.Widget.properties.halign` and `gtk.Widget.properties.valign` properties.
    ///
    /// For baseline support in containers you need to use `gtk.Widget.sizeAllocateWithBaseline`
    /// instead.
    extern fn gtk_widget_size_allocate(p_widget: *Widget, p_allocation: *gtk.Allocation) void;
    pub const sizeAllocate = gtk_widget_size_allocate;

    /// This function is only used by `gtk.Container` subclasses, to assign a size,
    /// position and (optionally) baseline to their child widgets.
    ///
    /// In this function, the allocation and baseline may be adjusted. It
    /// will be forced to a 1x1 minimum size, and the
    /// adjust_size_allocation virtual and adjust_baseline_allocation
    /// methods on the child will be used to adjust the allocation and
    /// baseline. Standard adjustments include removing the widget's
    /// margins, and applying the widget’s `gtk.Widget.properties.halign` and
    /// `gtk.Widget.properties.valign` properties.
    ///
    /// If the child widget does not have a valign of `GTK_ALIGN_BASELINE` the
    /// baseline argument is ignored and -1 is used instead.
    extern fn gtk_widget_size_allocate_with_baseline(p_widget: *Widget, p_allocation: *gtk.Allocation, p_baseline: c_int) void;
    pub const sizeAllocateWithBaseline = gtk_widget_size_allocate_with_baseline;

    /// This function is typically used when implementing a `gtk.Container`
    /// subclass.  Obtains the preferred size of a widget. The container
    /// uses this information to arrange its child widgets and decide what
    /// size allocations to give them with `gtk.Widget.sizeAllocate`.
    ///
    /// You can also call this function from an application, with some
    /// caveats. Most notably, getting a size request requires the widget
    /// to be associated with a screen, because font information may be
    /// needed. Multihead-aware applications should keep this in mind.
    ///
    /// Also remember that the size request is not necessarily the size
    /// a widget will actually be allocated.
    extern fn gtk_widget_size_request(p_widget: *Widget, p_requisition: *gtk.Requisition) void;
    pub const sizeRequest = gtk_widget_size_request;

    /// This function attaches the widget’s `gtk.Style` to the widget's
    /// `gdk.Window`. It is a replacement for
    ///
    /// ```
    /// widget->style = gtk_style_attach (widget->style, widget->window);
    /// ```
    ///
    /// and should only ever be called in a derived widget’s “realize”
    /// implementation which does not chain up to its parent class'
    /// “realize” implementation, because one of the parent classes
    /// (finally `gtk.Widget`) would attach the style itself.
    extern fn gtk_widget_style_attach(p_widget: *Widget) void;
    pub const styleAttach = gtk_widget_style_attach;

    /// Gets the values of a multiple style properties of `widget`.
    extern fn gtk_widget_style_get(p_widget: *Widget, p_first_property_name: [*:0]const u8, ...) void;
    pub const styleGet = gtk_widget_style_get;

    /// Gets the value of a style property of `widget`.
    extern fn gtk_widget_style_get_property(p_widget: *Widget, p_property_name: [*:0]const u8, p_value: *gobject.Value) void;
    pub const styleGetProperty = gtk_widget_style_get_property;

    /// Non-vararg variant of `gtk.Widget.styleGet`. Used primarily by language
    /// bindings.
    extern fn gtk_widget_style_get_valist(p_widget: *Widget, p_first_property_name: [*:0]const u8, p_var_args: std.builtin.VaList) void;
    pub const styleGetValist = gtk_widget_style_get_valist;

    /// Reverts the effect of a previous call to `gtk.Widget.freezeChildNotify`.
    /// This causes all queued `gtk.Widget.signals.child`-notify signals on `widget` to be
    /// emitted.
    extern fn gtk_widget_thaw_child_notify(p_widget: *Widget) void;
    pub const thawChildNotify = gtk_widget_thaw_child_notify;

    /// Translate coordinates relative to `src_widget`’s allocation to coordinates
    /// relative to `dest_widget`’s allocations. In order to perform this
    /// operation, both widgets must be realized, and must share a common
    /// toplevel.
    extern fn gtk_widget_translate_coordinates(p_src_widget: *Widget, p_dest_widget: *gtk.Widget, p_src_x: c_int, p_src_y: c_int, p_dest_x: ?*c_int, p_dest_y: ?*c_int) c_int;
    pub const translateCoordinates = gtk_widget_translate_coordinates;

    /// Triggers a tooltip query on the display where the toplevel of `widget`
    /// is located. See `gtk.Tooltip.triggerTooltipQuery` for more
    /// information.
    extern fn gtk_widget_trigger_tooltip_query(p_widget: *Widget) void;
    pub const triggerTooltipQuery = gtk_widget_trigger_tooltip_query;

    /// This function is only for use in widget implementations. Causes
    /// a widget to be unmapped if it’s currently mapped.
    extern fn gtk_widget_unmap(p_widget: *Widget) void;
    pub const unmap = gtk_widget_unmap;

    /// This function is only for use in widget implementations.
    /// Should be called by implementations of the remove method
    /// on `gtk.Container`, to dissociate a child from the container.
    extern fn gtk_widget_unparent(p_widget: *Widget) void;
    pub const unparent = gtk_widget_unparent;

    /// This function is only useful in widget implementations.
    /// Causes a widget to be unrealized (frees all GDK resources
    /// associated with the widget, such as `widget`->window).
    extern fn gtk_widget_unrealize(p_widget: *Widget) void;
    pub const unrealize = gtk_widget_unrealize;

    /// Unregisters a `gdk.Window` from the widget that was previously set up with
    /// `gtk.Widget.registerWindow`. You need to call this when the window is
    /// no longer used by the widget, such as when you destroy it.
    extern fn gtk_widget_unregister_window(p_widget: *Widget, p_window: *gdk.Window) void;
    pub const unregisterWindow = gtk_widget_unregister_window;

    /// This function is for use in widget implementations. Turns off flag
    /// values for the current widget state (insensitive, prelighted, etc.).
    /// See `gtk.Widget.setStateFlags`.
    extern fn gtk_widget_unset_state_flags(p_widget: *Widget, p_flags: gtk.StateFlags) void;
    pub const unsetStateFlags = gtk_widget_unset_state_flags;

    extern fn gtk_widget_get_type() usize;
    pub const getGObjectType = gtk_widget_get_type;

    extern fn g_object_ref(p_self: *gtk.Widget) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Widget) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Widget, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const WidgetAccessible = extern struct {
    pub const Parent = gtk.Accessible;
    pub const Implements = [_]type{atk.Component};
    pub const Class = gtk.WidgetAccessibleClass;
    f_parent: gtk.Accessible,
    f_priv: ?*gtk.WidgetAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_widget_accessible_get_type() usize;
    pub const getGObjectType = gtk_widget_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.WidgetAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.WidgetAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *WidgetAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkWindow is a toplevel window which can contain other widgets.
/// Windows normally have decorations that are under the control
/// of the windowing system and allow the user to manipulate the window
/// (resize it, move it, close it,...).
///
/// # GtkWindow as GtkBuildable
///
/// The GtkWindow implementation of the `gtk.Buildable` interface supports a
/// custom `<accel-groups>` element, which supports any number of `<group>`
/// elements representing the `gtk.AccelGroup` objects you want to add to
/// your window (synonymous with `gtk.Window.addAccelGroup`.
///
/// It also supports the `<initial-focus>` element, whose name property names
/// the widget to receive the focus when the window is mapped.
///
/// An example of a UI definition fragment with accel groups:
///
/// ```
/// <object class="GtkWindow">
///   <accel-groups>
///     <group name="accelgroup1"/>
///   </accel-groups>
///   <initial-focus name="thunderclap"/>
/// </object>
///
/// ...
///
/// <object class="GtkAccelGroup" id="accelgroup1"/>
/// ```
///
/// The GtkWindow implementation of the `gtk.Buildable` interface supports
/// setting a child as the titlebar by specifying “titlebar” as the “type”
/// attribute of a `<child>` element.
///
/// # CSS nodes
///
/// ```
/// window.background
/// ├── decoration
/// ├── <titlebar child>.titlebar [.default-decoration]
/// ╰── <child>
/// ```
///
/// GtkWindow has a main CSS node with name window and style class .background,
/// and a subnode with name decoration.
///
/// Style classes that are typically used with the main CSS node are .csd (when
/// client-side decorations are in use), .solid-csd (for client-side decorations
/// without invisible borders), .ssd (used by mutter when rendering server-side
/// decorations). GtkWindow also represents window states with the following
/// style classes on the main node: .tiled, .maximized, .fullscreen. Specialized
/// types of window often add their own discriminating style classes, such as
/// .popup or .tooltip.
///
/// GtkWindow adds the .titlebar and .default-decoration style classes to the
/// widget that is added as a titlebar child.
pub const Window = extern struct {
    pub const Parent = gtk.Bin;
    pub const Implements = [_]type{ atk.ImplementorIface, gtk.Buildable };
    pub const Class = gtk.WindowClass;
    f_bin: gtk.Bin,
    f_priv: ?*gtk.WindowPrivate,

    pub const virtual_methods = struct {
        /// Activates the default widget for the window.
        pub const activate_default = struct {
            pub fn call(p_class: anytype, p_window: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Window.Class, p_class).f_activate_default.?(gobject.ext.as(Window, p_window));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_window: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Window.Class, p_class).f_activate_default = @ptrCast(p_implementation);
            }
        };

        /// Activates the current focused widget within the window.
        pub const activate_focus = struct {
            pub fn call(p_class: anytype, p_window: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Window.Class, p_class).f_activate_focus.?(gobject.ext.as(Window, p_window));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_window: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Window.Class, p_class).f_activate_focus = @ptrCast(p_implementation);
            }
        };

        /// Class handler for the `gtk.Window.signals.enable`-debugging
        ///   keybinding signal. Since: 3.14
        pub const enable_debugging = struct {
            pub fn call(p_class: anytype, p_window: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_toggle: c_int) c_int {
                return gobject.ext.as(Window.Class, p_class).f_enable_debugging.?(gobject.ext.as(Window, p_window), p_toggle);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_window: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_toggle: c_int) callconv(.c) c_int) void {
                gobject.ext.as(Window.Class, p_class).f_enable_debugging = @ptrCast(p_implementation);
            }
        };

        /// Signal gets emitted when the set of accelerators or
        ///   mnemonics that are associated with window changes.
        pub const keys_changed = struct {
            pub fn call(p_class: anytype, p_window: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Window.Class, p_class).f_keys_changed.?(gobject.ext.as(Window, p_window));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_window: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Window.Class, p_class).f_keys_changed = @ptrCast(p_implementation);
            }
        };

        /// If `focus` is not the current focus widget, and is focusable, sets
        /// it as the focus widget for the window. If `focus` is `NULL`, unsets
        /// the focus widget for this window. To set the focus to a particular
        /// widget in the toplevel, it is usually more convenient to use
        /// `gtk.Widget.grabFocus` instead of this function.
        pub const set_focus = struct {
            pub fn call(p_class: anytype, p_window: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_focus: ?*gtk.Widget) void {
                return gobject.ext.as(Window.Class, p_class).f_set_focus.?(gobject.ext.as(Window, p_window), p_focus);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_window: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_focus: ?*gtk.Widget) callconv(.c) void) void {
                gobject.ext.as(Window.Class, p_class).f_set_focus = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Whether the window should receive the input focus.
        pub const accept_focus = struct {
            pub const name = "accept-focus";

            pub const Type = c_int;
        };

        /// The `gtk.Application` associated with the window.
        ///
        /// The application will be kept alive for at least as long as it
        /// has any windows associated with it (see `gio.Application.hold`
        /// for a way to keep it alive without windows).
        ///
        /// Normally, the connection between the application and the window
        /// will remain until the window is destroyed, but you can explicitly
        /// remove it by setting the :application property to `NULL`.
        pub const application = struct {
            pub const name = "application";

            pub const Type = ?*gtk.Application;
        };

        /// The widget to which this window is attached.
        /// See `gtk.Window.setAttachedTo`.
        ///
        /// Examples of places where specifying this relation is useful are
        /// for instance a `gtk.Menu` created by a `gtk.ComboBox`, a completion
        /// popup window created by `gtk.Entry` or a typeahead search entry
        /// created by `gtk.TreeView`.
        pub const attached_to = struct {
            pub const name = "attached-to";

            pub const Type = ?*gtk.Widget;
        };

        /// Whether the window should be decorated by the window manager.
        pub const decorated = struct {
            pub const name = "decorated";

            pub const Type = c_int;
        };

        pub const default_height = struct {
            pub const name = "default-height";

            pub const Type = c_int;
        };

        pub const default_width = struct {
            pub const name = "default-width";

            pub const Type = c_int;
        };

        /// Whether the window frame should have a close button.
        pub const deletable = struct {
            pub const name = "deletable";

            pub const Type = c_int;
        };

        pub const destroy_with_parent = struct {
            pub const name = "destroy-with-parent";

            pub const Type = c_int;
        };

        /// Whether the window should receive the input focus when mapped.
        pub const focus_on_map = struct {
            pub const name = "focus-on-map";

            pub const Type = c_int;
        };

        /// Whether 'focus rectangles' are currently visible in this window.
        ///
        /// This property is maintained by GTK+ based on user input
        /// and should not be set by applications.
        pub const focus_visible = struct {
            pub const name = "focus-visible";

            pub const Type = c_int;
        };

        /// The window gravity of the window. See `gtk.Window.move` and `gdk.Gravity` for
        /// more details about window gravity.
        pub const gravity = struct {
            pub const name = "gravity";

            pub const Type = gdk.Gravity;
        };

        /// Whether the window has a corner resize grip.
        ///
        /// Note that the resize grip is only shown if the window is
        /// actually resizable and not maximized. Use
        /// `gtk.Window.properties.resize`-grip-visible to find out if the resize
        /// grip is currently shown.
        pub const has_resize_grip = struct {
            pub const name = "has-resize-grip";

            pub const Type = c_int;
        };

        pub const has_toplevel_focus = struct {
            pub const name = "has-toplevel-focus";

            pub const Type = c_int;
        };

        /// Whether the titlebar should be hidden during maximization.
        pub const hide_titlebar_when_maximized = struct {
            pub const name = "hide-titlebar-when-maximized";

            pub const Type = c_int;
        };

        pub const icon = struct {
            pub const name = "icon";

            pub const Type = ?*gdkpixbuf.Pixbuf;
        };

        /// The :icon-name property specifies the name of the themed icon to
        /// use as the window icon. See `gtk.IconTheme` for more details.
        pub const icon_name = struct {
            pub const name = "icon-name";

            pub const Type = ?[*:0]u8;
        };

        pub const is_active = struct {
            pub const name = "is-active";

            pub const Type = c_int;
        };

        pub const is_maximized = struct {
            pub const name = "is-maximized";

            pub const Type = c_int;
        };

        /// Whether mnemonics are currently visible in this window.
        ///
        /// This property is maintained by GTK+ based on user input,
        /// and should not be set by applications.
        pub const mnemonics_visible = struct {
            pub const name = "mnemonics-visible";

            pub const Type = c_int;
        };

        pub const modal = struct {
            pub const name = "modal";

            pub const Type = c_int;
        };

        pub const resizable = struct {
            pub const name = "resizable";

            pub const Type = c_int;
        };

        /// Whether a corner resize grip is currently shown.
        pub const resize_grip_visible = struct {
            pub const name = "resize-grip-visible";

            pub const Type = c_int;
        };

        pub const role = struct {
            pub const name = "role";

            pub const Type = ?[*:0]u8;
        };

        pub const screen = struct {
            pub const name = "screen";

            pub const Type = ?*gdk.Screen;
        };

        pub const skip_pager_hint = struct {
            pub const name = "skip-pager-hint";

            pub const Type = c_int;
        };

        pub const skip_taskbar_hint = struct {
            pub const name = "skip-taskbar-hint";

            pub const Type = c_int;
        };

        /// The :startup-id is a write-only property for setting window's
        /// startup notification identifier. See `gtk.Window.setStartupId`
        /// for more details.
        pub const startup_id = struct {
            pub const name = "startup-id";

            pub const Type = ?[*:0]u8;
        };

        pub const title = struct {
            pub const name = "title";

            pub const Type = ?[*:0]u8;
        };

        /// The transient parent of the window. See `gtk.Window.setTransientFor` for
        /// more details about transient windows.
        pub const transient_for = struct {
            pub const name = "transient-for";

            pub const Type = ?*gtk.Window;
        };

        pub const @"type" = struct {
            pub const name = "type";

            pub const Type = gtk.WindowType;
        };

        pub const type_hint = struct {
            pub const name = "type-hint";

            pub const Type = gdk.WindowTypeHint;
        };

        pub const urgency_hint = struct {
            pub const name = "urgency-hint";

            pub const Type = c_int;
        };

        pub const window_position = struct {
            pub const name = "window-position";

            pub const Type = gtk.WindowPosition;
        };
    };

    pub const signals = struct {
        /// The ::activate-default signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user activates the default widget
        /// of `window`.
        pub const activate_default = struct {
            pub const name = "activate-default";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Window, p_instance))),
                    gobject.signalLookup("activate-default", Window.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::activate-focus signal is a
        /// [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user activates the currently
        /// focused widget of `window`.
        pub const activate_focus = struct {
            pub const name = "activate-focus";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Window, p_instance))),
                    gobject.signalLookup("activate-focus", Window.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::enable-debugging signal is a [keybinding signal][GtkBindingSignal]
        /// which gets emitted when the user enables or disables interactive
        /// debugging. When `toggle` is `TRUE`, interactive debugging is toggled
        /// on or off, when it is `FALSE`, the debugger will be pointed at the
        /// widget under the pointer.
        ///
        /// The default bindings for this signal are Ctrl-Shift-I
        /// and Ctrl-Shift-D.
        pub const enable_debugging = struct {
            pub const name = "enable-debugging";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_toggle: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Window, p_instance))),
                    gobject.signalLookup("enable-debugging", Window.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::keys-changed signal gets emitted when the set of accelerators
        /// or mnemonics that are associated with `window` changes.
        pub const keys_changed = struct {
            pub const name = "keys-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Window, p_instance))),
                    gobject.signalLookup("keys-changed", Window.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted whenever the currently focused widget in
        /// this window changes.
        pub const set_focus = struct {
            pub const name = "set-focus";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_widget: ?*gtk.Widget, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Window, p_instance))),
                    gobject.signalLookup("set-focus", Window.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Gets the value set by `gtk.Window.setDefaultIconList`.
    /// The list is a copy and should be freed with `glib.List.free`,
    /// but the pixbufs in the list have not had their reference count
    /// incremented.
    extern fn gtk_window_get_default_icon_list() *glib.List;
    pub const getDefaultIconList = gtk_window_get_default_icon_list;

    /// Returns the fallback icon name for windows that has been set
    /// with `gtk.Window.setDefaultIconName`. The returned
    /// string is owned by GTK+ and should not be modified. It
    /// is only valid until the next call to
    /// `gtk.Window.setDefaultIconName`.
    extern fn gtk_window_get_default_icon_name() [*:0]const u8;
    pub const getDefaultIconName = gtk_window_get_default_icon_name;

    /// Returns a list of all existing toplevel windows. The widgets
    /// in the list are not individually referenced. If you want
    /// to iterate through the list and perform actions involving
    /// callbacks that might destroy the widgets, you must call
    /// `g_list_foreach (result, (GFunc)g_object_ref, NULL)` first, and
    /// then unref all the widgets afterwards.
    extern fn gtk_window_list_toplevels() *glib.List;
    pub const listToplevels = gtk_window_list_toplevels;

    /// By default, after showing the first `gtk.Window`, GTK+ calls
    /// `gdk.notifyStartupComplete`.  Call this function to disable
    /// the automatic startup notification. You might do this if your
    /// first window is a splash screen, and you want to delay notification
    /// until after your real main window has been shown, for example.
    ///
    /// In that example, you would disable startup notification
    /// temporarily, show your splash screen, then re-enable it so that
    /// showing the main window would automatically result in notification.
    extern fn gtk_window_set_auto_startup_notification(p_setting: c_int) void;
    pub const setAutoStartupNotification = gtk_window_set_auto_startup_notification;

    /// Sets an icon to be used as fallback for windows that haven't
    /// had `gtk.Window.setIcon` called on them from a pixbuf.
    extern fn gtk_window_set_default_icon(p_icon: *gdkpixbuf.Pixbuf) void;
    pub const setDefaultIcon = gtk_window_set_default_icon;

    /// Sets an icon to be used as fallback for windows that haven't
    /// had `gtk.Window.setIconList` called on them from a file
    /// on disk. Warns on failure if `err` is `NULL`.
    extern fn gtk_window_set_default_icon_from_file(p_filename: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const setDefaultIconFromFile = gtk_window_set_default_icon_from_file;

    /// Sets an icon list to be used as fallback for windows that haven't
    /// had `gtk.Window.setIconList` called on them to set up a
    /// window-specific icon list. This function allows you to set up the
    /// icon for all windows in your app at once.
    ///
    /// See `gtk.Window.setIconList` for more details.
    extern fn gtk_window_set_default_icon_list(p_list: *glib.List) void;
    pub const setDefaultIconList = gtk_window_set_default_icon_list;

    /// Sets an icon to be used as fallback for windows that haven't
    /// had `gtk.Window.setIconList` called on them from a named
    /// themed icon, see `gtk.Window.setIconName`.
    extern fn gtk_window_set_default_icon_name(p_name: [*:0]const u8) void;
    pub const setDefaultIconName = gtk_window_set_default_icon_name;

    /// Opens or closes the [interactive debugger][interactive-debugging],
    /// which offers access to the widget hierarchy of the application
    /// and to useful debugging tools.
    extern fn gtk_window_set_interactive_debugging(p_enable: c_int) void;
    pub const setInteractiveDebugging = gtk_window_set_interactive_debugging;

    /// Creates a new `gtk.Window`, which is a toplevel window that can
    /// contain other widgets. Nearly always, the type of the window should
    /// be `GTK_WINDOW_TOPLEVEL`. If you’re implementing something like a
    /// popup menu from scratch (which is a bad idea, just use `gtk.Menu`),
    /// you might use `GTK_WINDOW_POPUP`. `GTK_WINDOW_POPUP` is not for
    /// dialogs, though in some other toolkits dialogs are called “popups”.
    /// In GTK+, `GTK_WINDOW_POPUP` means a pop-up menu or pop-up tooltip.
    /// On X11, popup windows are not controlled by the
    /// [window manager][gtk-X11-arch].
    ///
    /// If you simply want an undecorated window (no window borders), use
    /// `gtk.Window.setDecorated`, don’t use `GTK_WINDOW_POPUP`.
    ///
    /// All top-level windows created by `gtk.Window.new` are stored in
    /// an internal top-level window list.  This list can be obtained from
    /// `gtk.Window.listToplevels`.  Due to Gtk+ keeping a reference to
    /// the window internally, `gtk.Window.new` does not return a reference
    /// to the caller.
    ///
    /// To delete a `gtk.Window`, call `gtk.Widget.destroy`.
    extern fn gtk_window_new(p_type: gtk.WindowType) *gtk.Window;
    pub const new = gtk_window_new;

    /// Activates the default widget for the window, unless the current
    /// focused widget has been configured to receive the default action
    /// (see `gtk.Widget.setReceivesDefault`), in which case the
    /// focused widget is activated.
    extern fn gtk_window_activate_default(p_window: *Window) c_int;
    pub const activateDefault = gtk_window_activate_default;

    /// Activates the current focused widget within the window.
    extern fn gtk_window_activate_focus(p_window: *Window) c_int;
    pub const activateFocus = gtk_window_activate_focus;

    /// Activates mnemonics and accelerators for this `gtk.Window`. This is normally
    /// called by the default ::key_press_event handler for toplevel windows,
    /// however in some cases it may be useful to call this directly when
    /// overriding the standard key handling for a toplevel window.
    extern fn gtk_window_activate_key(p_window: *Window, p_event: *gdk.EventKey) c_int;
    pub const activateKey = gtk_window_activate_key;

    /// Associate `accel_group` with `window`, such that calling
    /// `gtk.accelGroupsActivate` on `window` will activate accelerators
    /// in `accel_group`.
    extern fn gtk_window_add_accel_group(p_window: *Window, p_accel_group: *gtk.AccelGroup) void;
    pub const addAccelGroup = gtk_window_add_accel_group;

    /// Adds a mnemonic to this window.
    extern fn gtk_window_add_mnemonic(p_window: *Window, p_keyval: c_uint, p_target: *gtk.Widget) void;
    pub const addMnemonic = gtk_window_add_mnemonic;

    /// Starts moving a window. This function is used if an application has
    /// window movement grips. When GDK can support it, the window movement
    /// will be done using the standard mechanism for the
    /// [window manager][gtk-X11-arch] or windowing
    /// system. Otherwise, GDK will try to emulate window movement,
    /// potentially not all that well, depending on the windowing system.
    extern fn gtk_window_begin_move_drag(p_window: *Window, p_button: c_int, p_root_x: c_int, p_root_y: c_int, p_timestamp: u32) void;
    pub const beginMoveDrag = gtk_window_begin_move_drag;

    /// Starts resizing a window. This function is used if an application
    /// has window resizing controls. When GDK can support it, the resize
    /// will be done using the standard mechanism for the
    /// [window manager][gtk-X11-arch] or windowing
    /// system. Otherwise, GDK will try to emulate window resizing,
    /// potentially not all that well, depending on the windowing system.
    extern fn gtk_window_begin_resize_drag(p_window: *Window, p_edge: gdk.WindowEdge, p_button: c_int, p_root_x: c_int, p_root_y: c_int, p_timestamp: u32) void;
    pub const beginResizeDrag = gtk_window_begin_resize_drag;

    /// Requests that the window is closed, similar to what happens
    /// when a window manager close button is clicked.
    ///
    /// This function can be used with close buttons in custom
    /// titlebars.
    extern fn gtk_window_close(p_window: *Window) void;
    pub const close = gtk_window_close;

    /// Asks to deiconify (i.e. unminimize) the specified `window`. Note
    /// that you shouldn’t assume the window is definitely deiconified
    /// afterward, because other entities (e.g. the user or
    /// [window manager][gtk-X11-arch])) could iconify it
    /// again before your code which assumes deiconification gets to run.
    ///
    /// You can track iconification via the “window-state-event” signal
    /// on `gtk.Widget`.
    extern fn gtk_window_deiconify(p_window: *Window) void;
    pub const deiconify = gtk_window_deiconify;

    /// Asks to place `window` in the fullscreen state. Note that you
    /// shouldn’t assume the window is definitely full screen afterward,
    /// because other entities (e.g. the user or
    /// [window manager][gtk-X11-arch]) could unfullscreen it
    /// again, and not all window managers honor requests to fullscreen
    /// windows. But normally the window will end up fullscreen. Just
    /// don’t write code that crashes if not.
    ///
    /// You can track the fullscreen state via the “window-state-event” signal
    /// on `gtk.Widget`.
    extern fn gtk_window_fullscreen(p_window: *Window) void;
    pub const fullscreen = gtk_window_fullscreen;

    /// Asks to place `window` in the fullscreen state. Note that you shouldn't assume
    /// the window is definitely full screen afterward.
    ///
    /// You can track the fullscreen state via the "window-state-event" signal
    /// on `gtk.Widget`.
    extern fn gtk_window_fullscreen_on_monitor(p_window: *Window, p_screen: *gdk.Screen, p_monitor: c_int) void;
    pub const fullscreenOnMonitor = gtk_window_fullscreen_on_monitor;

    /// Gets the value set by `gtk.Window.setAcceptFocus`.
    extern fn gtk_window_get_accept_focus(p_window: *Window) c_int;
    pub const getAcceptFocus = gtk_window_get_accept_focus;

    /// Gets the `gtk.Application` associated with the window (if any).
    extern fn gtk_window_get_application(p_window: *Window) ?*gtk.Application;
    pub const getApplication = gtk_window_get_application;

    /// Fetches the attach widget for this window. See
    /// `gtk.Window.setAttachedTo`.
    extern fn gtk_window_get_attached_to(p_window: *Window) ?*gtk.Widget;
    pub const getAttachedTo = gtk_window_get_attached_to;

    /// Returns whether the window has been set to have decorations
    /// such as a title bar via `gtk.Window.setDecorated`.
    extern fn gtk_window_get_decorated(p_window: *Window) c_int;
    pub const getDecorated = gtk_window_get_decorated;

    /// Gets the default size of the window. A value of -1 for the width or
    /// height indicates that a default size has not been explicitly set
    /// for that dimension, so the “natural” size of the window will be
    /// used.
    extern fn gtk_window_get_default_size(p_window: *Window, p_width: ?*c_int, p_height: ?*c_int) void;
    pub const getDefaultSize = gtk_window_get_default_size;

    /// Returns the default widget for `window`. See
    /// `gtk.Window.setDefault` for more details.
    extern fn gtk_window_get_default_widget(p_window: *Window) ?*gtk.Widget;
    pub const getDefaultWidget = gtk_window_get_default_widget;

    /// Returns whether the window has been set to have a close button
    /// via `gtk.Window.setDeletable`.
    extern fn gtk_window_get_deletable(p_window: *Window) c_int;
    pub const getDeletable = gtk_window_get_deletable;

    /// Returns whether the window will be destroyed with its transient parent. See
    /// gtk_window_set_destroy_with_parent ().
    extern fn gtk_window_get_destroy_with_parent(p_window: *Window) c_int;
    pub const getDestroyWithParent = gtk_window_get_destroy_with_parent;

    /// Retrieves the current focused widget within the window.
    /// Note that this is the widget that would have the focus
    /// if the toplevel window focused; if the toplevel window
    /// is not focused then  `gtk_widget_has_focus (widget)` will
    /// not be `TRUE` for the widget.
    extern fn gtk_window_get_focus(p_window: *Window) ?*gtk.Widget;
    pub const getFocus = gtk_window_get_focus;

    /// Gets the value set by `gtk.Window.setFocusOnMap`.
    extern fn gtk_window_get_focus_on_map(p_window: *Window) c_int;
    pub const getFocusOnMap = gtk_window_get_focus_on_map;

    /// Gets the value of the `gtk.Window.properties.focus`-visible property.
    extern fn gtk_window_get_focus_visible(p_window: *Window) c_int;
    pub const getFocusVisible = gtk_window_get_focus_visible;

    /// Gets the value set by `gtk.Window.setGravity`.
    extern fn gtk_window_get_gravity(p_window: *Window) gdk.Gravity;
    pub const getGravity = gtk_window_get_gravity;

    /// Returns the group for `window` or the default group, if
    /// `window` is `NULL` or if `window` does not have an explicit
    /// window group.
    extern fn gtk_window_get_group(p_window: ?*Window) *gtk.WindowGroup;
    pub const getGroup = gtk_window_get_group;

    /// Determines whether the window may have a resize grip.
    extern fn gtk_window_get_has_resize_grip(p_window: *Window) c_int;
    pub const getHasResizeGrip = gtk_window_get_has_resize_grip;

    /// Returns whether the window has requested to have its titlebar hidden
    /// when maximized. See gtk_window_set_hide_titlebar_when_maximized ().
    extern fn gtk_window_get_hide_titlebar_when_maximized(p_window: *Window) c_int;
    pub const getHideTitlebarWhenMaximized = gtk_window_get_hide_titlebar_when_maximized;

    /// Gets the value set by `gtk.Window.setIcon` (or if you've
    /// called `gtk.Window.setIconList`, gets the first icon in
    /// the icon list).
    extern fn gtk_window_get_icon(p_window: *Window) ?*gdkpixbuf.Pixbuf;
    pub const getIcon = gtk_window_get_icon;

    /// Retrieves the list of icons set by `gtk.Window.setIconList`.
    /// The list is copied, but the reference count on each
    /// member won’t be incremented.
    extern fn gtk_window_get_icon_list(p_window: *Window) *glib.List;
    pub const getIconList = gtk_window_get_icon_list;

    /// Returns the name of the themed icon for the window,
    /// see `gtk.Window.setIconName`.
    extern fn gtk_window_get_icon_name(p_window: *Window) ?[*:0]const u8;
    pub const getIconName = gtk_window_get_icon_name;

    /// Returns the mnemonic modifier for this window. See
    /// `gtk.Window.setMnemonicModifier`.
    extern fn gtk_window_get_mnemonic_modifier(p_window: *Window) gdk.ModifierType;
    pub const getMnemonicModifier = gtk_window_get_mnemonic_modifier;

    /// Gets the value of the `gtk.Window.properties.mnemonics`-visible property.
    extern fn gtk_window_get_mnemonics_visible(p_window: *Window) c_int;
    pub const getMnemonicsVisible = gtk_window_get_mnemonics_visible;

    /// Returns whether the window is modal. See `gtk.Window.setModal`.
    extern fn gtk_window_get_modal(p_window: *Window) c_int;
    pub const getModal = gtk_window_get_modal;

    /// Fetches the requested opacity for this window. See
    /// `gtk.Window.setOpacity`.
    extern fn gtk_window_get_opacity(p_window: *Window) f64;
    pub const getOpacity = gtk_window_get_opacity;

    /// This function returns the position you need to pass to
    /// `gtk.Window.move` to keep `window` in its current position.
    /// This means that the meaning of the returned value varies with
    /// window gravity. See `gtk.Window.move` for more details.
    ///
    /// The reliability of this function depends on the windowing system
    /// currently in use. Some windowing systems, such as Wayland, do not
    /// support a global coordinate system, and thus the position of the
    /// window will always be (0, 0). Others, like X11, do not have a reliable
    /// way to obtain the geometry of the decorations of a window if they are
    /// provided by the window manager. Additionally, on X11, window manager
    /// have been known to mismanage window gravity, which result in windows
    /// moving even if you use the coordinates of the current position as
    /// returned by this function.
    ///
    /// If you haven’t changed the window gravity, its gravity will be
    /// `GDK_GRAVITY_NORTH_WEST`. This means that `gtk.Window.getPosition`
    /// gets the position of the top-left corner of the window manager
    /// frame for the window. `gtk.Window.move` sets the position of this
    /// same top-left corner.
    ///
    /// If a window has gravity `GDK_GRAVITY_STATIC` the window manager
    /// frame is not relevant, and thus `gtk.Window.getPosition` will
    /// always produce accurate results. However you can’t use static
    /// gravity to do things like place a window in a corner of the screen,
    /// because static gravity ignores the window manager decorations.
    ///
    /// Ideally, this function should return appropriate values if the
    /// window has client side decorations, assuming that the windowing
    /// system supports global coordinates.
    ///
    /// In practice, saving the window position should not be left to
    /// applications, as they lack enough knowledge of the windowing
    /// system and the window manager state to effectively do so. The
    /// appropriate way to implement saving the window position is to
    /// use a platform-specific protocol, wherever that is available.
    extern fn gtk_window_get_position(p_window: *Window, p_root_x: ?*c_int, p_root_y: ?*c_int) void;
    pub const getPosition = gtk_window_get_position;

    /// Gets the value set by `gtk.Window.setResizable`.
    extern fn gtk_window_get_resizable(p_window: *Window) c_int;
    pub const getResizable = gtk_window_get_resizable;

    /// If a window has a resize grip, this will retrieve the grip
    /// position, width and height into the specified `gdk.Rectangle`.
    extern fn gtk_window_get_resize_grip_area(p_window: *Window, p_rect: *gdk.Rectangle) c_int;
    pub const getResizeGripArea = gtk_window_get_resize_grip_area;

    /// Returns the role of the window. See `gtk.Window.setRole` for
    /// further explanation.
    extern fn gtk_window_get_role(p_window: *Window) ?[*:0]const u8;
    pub const getRole = gtk_window_get_role;

    /// Returns the `gdk.Screen` associated with `window`.
    extern fn gtk_window_get_screen(p_window: *Window) *gdk.Screen;
    pub const getScreen = gtk_window_get_screen;

    /// Obtains the current size of `window`.
    ///
    /// If `window` is not visible on screen, this function return the size GTK+
    /// will suggest to the [window manager][gtk-X11-arch] for the initial window
    /// size (but this is not reliably the same as the size the window manager
    /// will actually select). See: `gtk.Window.setDefaultSize`.
    ///
    /// Depending on the windowing system and the window manager constraints,
    /// the size returned by this function may not match the size set using
    /// `gtk.Window.resize`; additionally, since `gtk.Window.resize` may be
    /// implemented as an asynchronous operation, GTK+ cannot guarantee in any
    /// way that this code:
    ///
    /// ```
    ///   // width and height are set elsewhere
    ///   gtk_window_resize (window, width, height);
    ///
    ///   int new_width, new_height;
    ///   gtk_window_get_size (window, &new_width, &new_height);
    /// ```
    ///
    /// will result in `new_width` and `new_height` matching `width` and
    /// `height`, respectively.
    ///
    /// This function will return the logical size of the `gtk.Window`,
    /// excluding the widgets used in client side decorations; there is,
    /// however, no guarantee that the result will be completely accurate
    /// because client side decoration may include widgets that depend on
    /// the user preferences and that may not be visibile at the time you
    /// call this function.
    ///
    /// The dimensions returned by this function are suitable for being
    /// stored across sessions; use `gtk.Window.setDefaultSize` to
    /// restore them when before showing the window.
    ///
    /// To avoid potential race conditions, you should only call this
    /// function in response to a size change notification, for instance
    /// inside a handler for the `gtk.Widget.signals.size`-allocate signal, or
    /// inside a handler for the `gtk.Widget.signals.configure`-event signal:
    ///
    /// ```
    /// static void
    /// on_size_allocate (GtkWidget *widget, GtkAllocation *allocation)
    /// {
    ///   int new_width, new_height;
    ///
    ///   gtk_window_get_size (GTK_WINDOW (widget), &new_width, &new_height);
    ///
    ///   ...
    /// }
    /// ```
    ///
    /// Note that, if you connect to the `gtk.Widget.signals.size`-allocate signal,
    /// you should not use the dimensions of the `gtk.Allocation` passed to
    /// the signal handler, as the allocation may contain client side
    /// decorations added by GTK+, depending on the windowing system in
    /// use.
    ///
    /// If you are getting a window size in order to position the window
    /// on the screen, you should, instead, simply set the window’s semantic
    /// type with `gtk.Window.setTypeHint`, which allows the window manager
    /// to e.g. center dialogs. Also, if you set the transient parent of
    /// dialogs with `gtk.Window.setTransientFor` window managers will
    /// often center the dialog over its parent window. It's much preferred
    /// to let the window manager handle these cases rather than doing it
    /// yourself, because all apps will behave consistently and according to
    /// user or system preferences, if the window manager handles it. Also,
    /// the window manager can take into account the size of the window
    /// decorations and border that it may add, and of which GTK+ has no
    /// knowledge. Additionally, positioning windows in global screen coordinates
    /// may not be allowed by the windowing system. For more information,
    /// see: `gtk.Window.setPosition`.
    extern fn gtk_window_get_size(p_window: *Window, p_width: ?*c_int, p_height: ?*c_int) void;
    pub const getSize = gtk_window_get_size;

    /// Gets the value set by `gtk.Window.setSkipPagerHint`.
    extern fn gtk_window_get_skip_pager_hint(p_window: *Window) c_int;
    pub const getSkipPagerHint = gtk_window_get_skip_pager_hint;

    /// Gets the value set by `gtk.Window.setSkipTaskbarHint`
    extern fn gtk_window_get_skip_taskbar_hint(p_window: *Window) c_int;
    pub const getSkipTaskbarHint = gtk_window_get_skip_taskbar_hint;

    /// Retrieves the title of the window. See `gtk.Window.setTitle`.
    extern fn gtk_window_get_title(p_window: *Window) ?[*:0]const u8;
    pub const getTitle = gtk_window_get_title;

    /// Returns the custom titlebar that has been set with
    /// `gtk.Window.setTitlebar`.
    extern fn gtk_window_get_titlebar(p_window: *Window) ?*gtk.Widget;
    pub const getTitlebar = gtk_window_get_titlebar;

    /// Fetches the transient parent for this window. See
    /// `gtk.Window.setTransientFor`.
    extern fn gtk_window_get_transient_for(p_window: *Window) ?*gtk.Window;
    pub const getTransientFor = gtk_window_get_transient_for;

    /// Gets the type hint for this window. See `gtk.Window.setTypeHint`.
    extern fn gtk_window_get_type_hint(p_window: *Window) gdk.WindowTypeHint;
    pub const getTypeHint = gtk_window_get_type_hint;

    /// Gets the value set by `gtk.Window.setUrgencyHint`
    extern fn gtk_window_get_urgency_hint(p_window: *Window) c_int;
    pub const getUrgencyHint = gtk_window_get_urgency_hint;

    /// Gets the type of the window. See `gtk.WindowType`.
    extern fn gtk_window_get_window_type(p_window: *Window) gtk.WindowType;
    pub const getWindowType = gtk_window_get_window_type;

    /// Returns whether `window` has an explicit window group.
    extern fn gtk_window_has_group(p_window: *Window) c_int;
    pub const hasGroup = gtk_window_has_group;

    /// Returns whether the input focus is within this GtkWindow.
    /// For real toplevel windows, this is identical to `gtk.Window.isActive`,
    /// but for embedded windows, like `gtk.Plug`, the results will differ.
    extern fn gtk_window_has_toplevel_focus(p_window: *Window) c_int;
    pub const hasToplevelFocus = gtk_window_has_toplevel_focus;

    /// Asks to iconify (i.e. minimize) the specified `window`. Note that
    /// you shouldn’t assume the window is definitely iconified afterward,
    /// because other entities (e.g. the user or
    /// [window manager][gtk-X11-arch]) could deiconify it
    /// again, or there may not be a window manager in which case
    /// iconification isn’t possible, etc. But normally the window will end
    /// up iconified. Just don’t write code that crashes if not.
    ///
    /// It’s permitted to call this function before showing a window,
    /// in which case the window will be iconified before it ever appears
    /// onscreen.
    ///
    /// You can track iconification via the “window-state-event” signal
    /// on `gtk.Widget`.
    extern fn gtk_window_iconify(p_window: *Window) void;
    pub const iconify = gtk_window_iconify;

    /// Returns whether the window is part of the current active toplevel.
    /// (That is, the toplevel window receiving keystrokes.)
    /// The return value is `TRUE` if the window is active toplevel
    /// itself, but also if it is, say, a `gtk.Plug` embedded in the active toplevel.
    /// You might use this function if you wanted to draw a widget
    /// differently in an active window from a widget in an inactive window.
    /// See `gtk.Window.hasToplevelFocus`
    extern fn gtk_window_is_active(p_window: *Window) c_int;
    pub const isActive = gtk_window_is_active;

    /// Retrieves the current maximized state of `window`.
    ///
    /// Note that since maximization is ultimately handled by the window
    /// manager and happens asynchronously to an application request, you
    /// shouldn’t assume the return value of this function changing
    /// immediately (or at all), as an effect of calling
    /// `gtk.Window.maximize` or `gtk.Window.unmaximize`.
    extern fn gtk_window_is_maximized(p_window: *Window) c_int;
    pub const isMaximized = gtk_window_is_maximized;

    /// Asks to maximize `window`, so that it becomes full-screen. Note that
    /// you shouldn’t assume the window is definitely maximized afterward,
    /// because other entities (e.g. the user or
    /// [window manager][gtk-X11-arch]) could unmaximize it
    /// again, and not all window managers support maximization. But
    /// normally the window will end up maximized. Just don’t write code
    /// that crashes if not.
    ///
    /// It’s permitted to call this function before showing a window,
    /// in which case the window will be maximized when it appears onscreen
    /// initially.
    ///
    /// You can track maximization via the “window-state-event” signal
    /// on `gtk.Widget`, or by listening to notifications on the
    /// `gtk.Window.properties.is`-maximized property.
    extern fn gtk_window_maximize(p_window: *Window) void;
    pub const maximize = gtk_window_maximize;

    /// Activates the targets associated with the mnemonic.
    extern fn gtk_window_mnemonic_activate(p_window: *Window, p_keyval: c_uint, p_modifier: gdk.ModifierType) c_int;
    pub const mnemonicActivate = gtk_window_mnemonic_activate;

    /// Asks the [window manager][gtk-X11-arch] to move
    /// `window` to the given position.  Window managers are free to ignore
    /// this; most window managers ignore requests for initial window
    /// positions (instead using a user-defined placement algorithm) and
    /// honor requests after the window has already been shown.
    ///
    /// Note: the position is the position of the gravity-determined
    /// reference point for the window. The gravity determines two things:
    /// first, the location of the reference point in root window
    /// coordinates; and second, which point on the window is positioned at
    /// the reference point.
    ///
    /// By default the gravity is `GDK_GRAVITY_NORTH_WEST`, so the reference
    /// point is simply the `x`, `y` supplied to `gtk.Window.move`. The
    /// top-left corner of the window decorations (aka window frame or
    /// border) will be placed at `x`, `y`.  Therefore, to position a window
    /// at the top left of the screen, you want to use the default gravity
    /// (which is `GDK_GRAVITY_NORTH_WEST`) and move the window to 0,0.
    ///
    /// To position a window at the bottom right corner of the screen, you
    /// would set `GDK_GRAVITY_SOUTH_EAST`, which means that the reference
    /// point is at `x` + the window width and `y` + the window height, and
    /// the bottom-right corner of the window border will be placed at that
    /// reference point. So, to place a window in the bottom right corner
    /// you would first set gravity to south east, then write:
    /// `gtk_window_move (window, gdk_screen_width () - window_width,
    /// gdk_screen_height () - window_height)` (note that this
    /// example does not take multi-head scenarios into account).
    ///
    /// The [Extended Window Manager Hints Specification](http://www.freedesktop.org/Standards/wm-spec)
    /// has a nice table of gravities in the “implementation notes” section.
    ///
    /// The `gtk.Window.getPosition` documentation may also be relevant.
    extern fn gtk_window_move(p_window: *Window, p_x: c_int, p_y: c_int) void;
    pub const move = gtk_window_move;

    /// Parses a standard X Window System geometry string - see the
    /// manual page for X (type “man X”) for details on this.
    /// `gtk.Window.parseGeometry` does work on all GTK+ ports
    /// including Win32 but is primarily intended for an X environment.
    ///
    /// If either a size or a position can be extracted from the
    /// geometry string, `gtk.Window.parseGeometry` returns `TRUE`
    /// and calls `gtk.Window.setDefaultSize` and/or `gtk.Window.move`
    /// to resize/move the window.
    ///
    /// If `gtk.Window.parseGeometry` returns `TRUE`, it will also
    /// set the `GDK_HINT_USER_POS` and/or `GDK_HINT_USER_SIZE` hints
    /// indicating to the window manager that the size/position of
    /// the window was user-specified. This causes most window
    /// managers to honor the geometry.
    ///
    /// Note that for `gtk.Window.parseGeometry` to work as expected, it has
    /// to be called when the window has its “final” size, i.e. after calling
    /// `gtk.Widget.showAll` on the contents and `gtk.Window.setGeometryHints`
    /// on the window.
    /// ```
    /// `include` <gtk/gtk.h>
    ///
    /// static void
    /// fill_with_content (GtkWidget *vbox)
    /// {
    ///   // fill with content...
    /// }
    ///
    /// int
    /// main (int argc, char *argv[])
    /// {
    ///   GtkWidget *window, *vbox;
    ///   GdkGeometry size_hints = {
    ///     100, 50, 0, 0, 100, 50, 10,
    ///     10, 0.0, 0.0, GDK_GRAVITY_NORTH_WEST
    ///   };
    ///
    ///   gtk_init (&argc, &argv);
    ///
    ///   window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    ///   vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
    ///
    ///   gtk_container_add (GTK_CONTAINER (window), vbox);
    ///   fill_with_content (vbox);
    ///   gtk_widget_show_all (vbox);
    ///
    ///   gtk_window_set_geometry_hints (GTK_WINDOW (window),
    ///                       NULL,
    ///                     &size_hints,
    ///                     GDK_HINT_MIN_SIZE |
    ///                     GDK_HINT_BASE_SIZE |
    ///                     GDK_HINT_RESIZE_INC);
    ///
    ///   if (argc > 1)
    ///     {
    ///       gboolean res;
    ///       res = gtk_window_parse_geometry (GTK_WINDOW (window),
    ///                                        argv[1]);
    ///       if (! res)
    ///         fprintf (stderr,
    ///                  "Failed to parse “`s`”\n",
    ///                  argv[1]);
    ///     }
    ///
    ///   gtk_widget_show_all (window);
    ///   gtk_main ();
    ///
    ///   return 0;
    /// }
    /// ```
    extern fn gtk_window_parse_geometry(p_window: *Window, p_geometry: [*:0]const u8) c_int;
    pub const parseGeometry = gtk_window_parse_geometry;

    /// Presents a window to the user. This function should not be used
    /// as when it is called, it is too late to gather a valid timestamp
    /// to allow focus stealing prevention to work correctly.
    extern fn gtk_window_present(p_window: *Window) void;
    pub const present = gtk_window_present;

    /// Presents a window to the user. This may mean raising the window
    /// in the stacking order, deiconifying it, moving it to the current
    /// desktop, and/or giving it the keyboard focus, possibly dependent
    /// on the user’s platform, window manager, and preferences.
    ///
    /// If `window` is hidden, this function calls `gtk.Widget.show`
    /// as well.
    ///
    /// This function should be used when the user tries to open a window
    /// that’s already open. Say for example the preferences dialog is
    /// currently open, and the user chooses Preferences from the menu
    /// a second time; use `gtk.Window.present` to move the already-open dialog
    /// where the user can see it.
    ///
    /// Presents a window to the user in response to a user interaction. The
    /// timestamp should be gathered when the window was requested to be shown
    /// (when clicking a link for example), rather than once the window is
    /// ready to be shown.
    extern fn gtk_window_present_with_time(p_window: *Window, p_timestamp: u32) void;
    pub const presentWithTime = gtk_window_present_with_time;

    /// Propagate a key press or release event to the focus widget and
    /// up the focus container chain until a widget handles `event`.
    /// This is normally called by the default ::key_press_event and
    /// ::key_release_event handlers for toplevel windows,
    /// however in some cases it may be useful to call this directly when
    /// overriding the standard key handling for a toplevel window.
    extern fn gtk_window_propagate_key_event(p_window: *Window, p_event: *gdk.EventKey) c_int;
    pub const propagateKeyEvent = gtk_window_propagate_key_event;

    /// Reverses the effects of `gtk.Window.addAccelGroup`.
    extern fn gtk_window_remove_accel_group(p_window: *Window, p_accel_group: *gtk.AccelGroup) void;
    pub const removeAccelGroup = gtk_window_remove_accel_group;

    /// Removes a mnemonic from this window.
    extern fn gtk_window_remove_mnemonic(p_window: *Window, p_keyval: c_uint, p_target: *gtk.Widget) void;
    pub const removeMnemonic = gtk_window_remove_mnemonic;

    /// Hides `window`, then reshows it, resetting the
    /// default size and position of the window. Used
    /// by GUI builders only.
    extern fn gtk_window_reshow_with_initial_size(p_window: *Window) void;
    pub const reshowWithInitialSize = gtk_window_reshow_with_initial_size;

    /// Resizes the window as if the user had done so, obeying geometry
    /// constraints. The default geometry constraint is that windows may
    /// not be smaller than their size request; to override this
    /// constraint, call `gtk.Widget.setSizeRequest` to set the window's
    /// request to a smaller value.
    ///
    /// If `gtk.Window.resize` is called before showing a window for the
    /// first time, it overrides any default size set with
    /// `gtk.Window.setDefaultSize`.
    ///
    /// Windows may not be resized smaller than 1 by 1 pixels.
    ///
    /// When using client side decorations, GTK+ will do its best to adjust
    /// the given size so that the resulting window size matches the
    /// requested size without the title bar, borders and shadows added for
    /// the client side decorations, but there is no guarantee that the
    /// result will be totally accurate because these widgets added for
    /// client side decorations depend on the theme and may not be realized
    /// or visible at the time `gtk.Window.resize` is issued.
    ///
    /// If the GtkWindow has a titlebar widget (see `gtk.Window.setTitlebar`), then
    /// typically, `gtk.Window.resize` will compensate for the height of the titlebar
    /// widget only if the height is known when the resulting GtkWindow configuration
    /// is issued.
    /// For example, if new widgets are added after the GtkWindow configuration
    /// and cause the titlebar widget to grow in height, this will result in a
    /// window content smaller that specified by `gtk.Window.resize` and not
    /// a larger window.
    extern fn gtk_window_resize(p_window: *Window, p_width: c_int, p_height: c_int) void;
    pub const resize = gtk_window_resize;

    /// Determines whether a resize grip is visible for the specified window.
    extern fn gtk_window_resize_grip_is_visible(p_window: *Window) c_int;
    pub const resizeGripIsVisible = gtk_window_resize_grip_is_visible;

    /// Like `gtk.Window.resize`, but `width` and `height` are interpreted
    /// in terms of the base size and increment set with
    /// gtk_window_set_geometry_hints.
    extern fn gtk_window_resize_to_geometry(p_window: *Window, p_width: c_int, p_height: c_int) void;
    pub const resizeToGeometry = gtk_window_resize_to_geometry;

    /// Windows may set a hint asking the desktop environment not to receive
    /// the input focus. This function sets this hint.
    extern fn gtk_window_set_accept_focus(p_window: *Window, p_setting: c_int) void;
    pub const setAcceptFocus = gtk_window_set_accept_focus;

    /// Sets or unsets the `gtk.Application` associated with the window.
    ///
    /// The application will be kept alive for at least as long as it has any windows
    /// associated with it (see `gio.Application.hold` for a way to keep it alive
    /// without windows).
    ///
    /// Normally, the connection between the application and the window will remain
    /// until the window is destroyed, but you can explicitly remove it by setting
    /// the `application` to `NULL`.
    ///
    /// This is equivalent to calling `gtk.Application.removeWindow` and/or
    /// `gtk.Application.addWindow` on the old/new applications as relevant.
    extern fn gtk_window_set_application(p_window: *Window, p_application: ?*gtk.Application) void;
    pub const setApplication = gtk_window_set_application;

    /// Marks `window` as attached to `attach_widget`. This creates a logical binding
    /// between the window and the widget it belongs to, which is used by GTK+ to
    /// propagate information such as styling or accessibility to `window` as if it
    /// was a children of `attach_widget`.
    ///
    /// Examples of places where specifying this relation is useful are for instance
    /// a `gtk.Menu` created by a `gtk.ComboBox`, a completion popup window
    /// created by `gtk.Entry` or a typeahead search entry created by `gtk.TreeView`.
    ///
    /// Note that this function should not be confused with
    /// `gtk.Window.setTransientFor`, which specifies a window manager relation
    /// between two toplevels instead.
    ///
    /// Passing `NULL` for `attach_widget` detaches the window.
    extern fn gtk_window_set_attached_to(p_window: *Window, p_attach_widget: ?*gtk.Widget) void;
    pub const setAttachedTo = gtk_window_set_attached_to;

    /// By default, windows are decorated with a title bar, resize
    /// controls, etc.  Some [window managers][gtk-X11-arch]
    /// allow GTK+ to disable these decorations, creating a
    /// borderless window. If you set the decorated property to `FALSE`
    /// using this function, GTK+ will do its best to convince the window
    /// manager not to decorate the window. Depending on the system, this
    /// function may not have any effect when called on a window that is
    /// already visible, so you should call it before calling `gtk.Widget.show`.
    ///
    /// On Windows, this function always works, since there’s no window manager
    /// policy involved.
    extern fn gtk_window_set_decorated(p_window: *Window, p_setting: c_int) void;
    pub const setDecorated = gtk_window_set_decorated;

    /// The default widget is the widget that’s activated when the user
    /// presses Enter in a dialog (for example). This function sets or
    /// unsets the default widget for a `gtk.Window`. When setting (rather
    /// than unsetting) the default widget it’s generally easier to call
    /// `gtk.Widget.grabDefault` on the widget. Before making a widget
    /// the default widget, you must call `gtk.Widget.setCanDefault` on
    /// the widget you’d like to make the default.
    extern fn gtk_window_set_default(p_window: *Window, p_default_widget: ?*gtk.Widget) void;
    pub const setDefault = gtk_window_set_default;

    /// Like `gtk.Window.setDefaultSize`, but `width` and `height` are interpreted
    /// in terms of the base size and increment set with
    /// gtk_window_set_geometry_hints.
    extern fn gtk_window_set_default_geometry(p_window: *Window, p_width: c_int, p_height: c_int) void;
    pub const setDefaultGeometry = gtk_window_set_default_geometry;

    /// Sets the default size of a window. If the window’s “natural” size
    /// (its size request) is larger than the default, the default will be
    /// ignored. More generally, if the default size does not obey the
    /// geometry hints for the window (`gtk.Window.setGeometryHints` can
    /// be used to set these explicitly), the default size will be clamped
    /// to the nearest permitted size.
    ///
    /// Unlike `gtk.Widget.setSizeRequest`, which sets a size request for
    /// a widget and thus would keep users from shrinking the window, this
    /// function only sets the initial size, just as if the user had
    /// resized the window themselves. Users can still shrink the window
    /// again as they normally would. Setting a default size of -1 means to
    /// use the “natural” default size (the size request of the window).
    ///
    /// For more control over a window’s initial size and how resizing works,
    /// investigate `gtk.Window.setGeometryHints`.
    ///
    /// For some uses, `gtk.Window.resize` is a more appropriate function.
    /// `gtk.Window.resize` changes the current size of the window, rather
    /// than the size to be used on initial display. `gtk.Window.resize` always
    /// affects the window itself, not the geometry widget.
    ///
    /// The default size of a window only affects the first time a window is
    /// shown; if a window is hidden and re-shown, it will remember the size
    /// it had prior to hiding, rather than using the default size.
    ///
    /// Windows can’t actually be 0x0 in size, they must be at least 1x1, but
    /// passing 0 for `width` and `height` is OK, resulting in a 1x1 default size.
    ///
    /// If you use this function to reestablish a previously saved window size,
    /// note that the appropriate size to save is the one returned by
    /// `gtk.Window.getSize`. Using the window allocation directly will not
    /// work in all circumstances and can lead to growing or shrinking windows.
    extern fn gtk_window_set_default_size(p_window: *Window, p_width: c_int, p_height: c_int) void;
    pub const setDefaultSize = gtk_window_set_default_size;

    /// By default, windows have a close button in the window frame. Some
    /// [window managers][gtk-X11-arch] allow GTK+ to
    /// disable this button. If you set the deletable property to `FALSE`
    /// using this function, GTK+ will do its best to convince the window
    /// manager not to show a close button. Depending on the system, this
    /// function may not have any effect when called on a window that is
    /// already visible, so you should call it before calling `gtk.Widget.show`.
    ///
    /// On Windows, this function always works, since there’s no window manager
    /// policy involved.
    extern fn gtk_window_set_deletable(p_window: *Window, p_setting: c_int) void;
    pub const setDeletable = gtk_window_set_deletable;

    /// If `setting` is `TRUE`, then destroying the transient parent of `window`
    /// will also destroy `window` itself. This is useful for dialogs that
    /// shouldn’t persist beyond the lifetime of the main window they're
    /// associated with, for example.
    extern fn gtk_window_set_destroy_with_parent(p_window: *Window, p_setting: c_int) void;
    pub const setDestroyWithParent = gtk_window_set_destroy_with_parent;

    /// If `focus` is not the current focus widget, and is focusable, sets
    /// it as the focus widget for the window. If `focus` is `NULL`, unsets
    /// the focus widget for this window. To set the focus to a particular
    /// widget in the toplevel, it is usually more convenient to use
    /// `gtk.Widget.grabFocus` instead of this function.
    extern fn gtk_window_set_focus(p_window: *Window, p_focus: ?*gtk.Widget) void;
    pub const setFocus = gtk_window_set_focus;

    /// Windows may set a hint asking the desktop environment not to receive
    /// the input focus when the window is mapped.  This function sets this
    /// hint.
    extern fn gtk_window_set_focus_on_map(p_window: *Window, p_setting: c_int) void;
    pub const setFocusOnMap = gtk_window_set_focus_on_map;

    /// Sets the `gtk.Window.properties.focus`-visible property.
    extern fn gtk_window_set_focus_visible(p_window: *Window, p_setting: c_int) void;
    pub const setFocusVisible = gtk_window_set_focus_visible;

    /// This function sets up hints about how a window can be resized by
    /// the user.  You can set a minimum and maximum size; allowed resize
    /// increments (e.g. for xterm, you can only resize by the size of a
    /// character); aspect ratios; and more. See the `gdk.Geometry` struct.
    extern fn gtk_window_set_geometry_hints(p_window: *Window, p_geometry_widget: ?*gtk.Widget, p_geometry: ?*gdk.Geometry, p_geom_mask: gdk.WindowHints) void;
    pub const setGeometryHints = gtk_window_set_geometry_hints;

    /// Window gravity defines the meaning of coordinates passed to
    /// `gtk.Window.move`. See `gtk.Window.move` and `gdk.Gravity` for
    /// more details.
    ///
    /// The default window gravity is `GDK_GRAVITY_NORTH_WEST` which will
    /// typically “do what you mean.”
    extern fn gtk_window_set_gravity(p_window: *Window, p_gravity: gdk.Gravity) void;
    pub const setGravity = gtk_window_set_gravity;

    /// Sets whether `window` has a corner resize grip.
    ///
    /// Note that the resize grip is only shown if the window
    /// is actually resizable and not maximized. Use
    /// `gtk.Window.resizeGripIsVisible` to find out if the
    /// resize grip is currently shown.
    extern fn gtk_window_set_has_resize_grip(p_window: *Window, p_value: c_int) void;
    pub const setHasResizeGrip = gtk_window_set_has_resize_grip;

    /// Tells GTK+ whether to drop its extra reference to the window
    /// when `gtk.Widget.destroy` is called.
    ///
    /// This function is only exported for the benefit of language
    /// bindings which may need to keep the window alive until their
    /// wrapper object is garbage collected. There is no justification
    /// for ever calling this function in an application.
    extern fn gtk_window_set_has_user_ref_count(p_window: *Window, p_setting: c_int) void;
    pub const setHasUserRefCount = gtk_window_set_has_user_ref_count;

    /// If `setting` is `TRUE`, then `window` will request that it’s titlebar
    /// should be hidden when maximized.
    /// This is useful for windows that don’t convey any information other
    /// than the application name in the titlebar, to put the available
    /// screen space to better use. If the underlying window system does not
    /// support the request, the setting will not have any effect.
    ///
    /// Note that custom titlebars set with `gtk.Window.setTitlebar` are
    /// not affected by this. The application is in full control of their
    /// content and visibility anyway.
    extern fn gtk_window_set_hide_titlebar_when_maximized(p_window: *Window, p_setting: c_int) void;
    pub const setHideTitlebarWhenMaximized = gtk_window_set_hide_titlebar_when_maximized;

    /// Sets up the icon representing a `gtk.Window`. This icon is used when
    /// the window is minimized (also known as iconified).  Some window
    /// managers or desktop environments may also place it in the window
    /// frame, or display it in other contexts. On others, the icon is not
    /// used at all, so your mileage may vary.
    ///
    /// The icon should be provided in whatever size it was naturally
    /// drawn; that is, don’t scale the image before passing it to
    /// GTK+. Scaling is postponed until the last minute, when the desired
    /// final size is known, to allow best quality.
    ///
    /// If you have your icon hand-drawn in multiple sizes, use
    /// `gtk.Window.setIconList`. Then the best size will be used.
    ///
    /// This function is equivalent to calling `gtk.Window.setIconList`
    /// with a 1-element list.
    ///
    /// See also `gtk.Window.setDefaultIconList` to set the icon
    /// for all windows in your application in one go.
    extern fn gtk_window_set_icon(p_window: *Window, p_icon: ?*gdkpixbuf.Pixbuf) void;
    pub const setIcon = gtk_window_set_icon;

    /// Sets the icon for `window`.
    /// Warns on failure if `err` is `NULL`.
    ///
    /// This function is equivalent to calling `gtk.Window.setIcon`
    /// with a pixbuf created by loading the image from `filename`.
    extern fn gtk_window_set_icon_from_file(p_window: *Window, p_filename: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const setIconFromFile = gtk_window_set_icon_from_file;

    /// Sets up the icon representing a `gtk.Window`. The icon is used when
    /// the window is minimized (also known as iconified).  Some window
    /// managers or desktop environments may also place it in the window
    /// frame, or display it in other contexts. On others, the icon is not
    /// used at all, so your mileage may vary.
    ///
    /// `gtk.Window.setIconList` allows you to pass in the same icon in
    /// several hand-drawn sizes. The list should contain the natural sizes
    /// your icon is available in; that is, don’t scale the image before
    /// passing it to GTK+. Scaling is postponed until the last minute,
    /// when the desired final size is known, to allow best quality.
    ///
    /// By passing several sizes, you may improve the final image quality
    /// of the icon, by reducing or eliminating automatic image scaling.
    ///
    /// Recommended sizes to provide: 16x16, 32x32, 48x48 at minimum, and
    /// larger images (64x64, 128x128) if you have them.
    ///
    /// See also `gtk.Window.setDefaultIconList` to set the icon
    /// for all windows in your application in one go.
    ///
    /// Note that transient windows (those who have been set transient for another
    /// window using `gtk.Window.setTransientFor`) will inherit their
    /// icon from their transient parent. So there’s no need to explicitly
    /// set the icon on transient windows.
    extern fn gtk_window_set_icon_list(p_window: *Window, p_list: *glib.List) void;
    pub const setIconList = gtk_window_set_icon_list;

    /// Sets the icon for the window from a named themed icon.
    /// See the docs for `gtk.IconTheme` for more details.
    /// On some platforms, the window icon is not used at all.
    ///
    /// Note that this has nothing to do with the WM_ICON_NAME
    /// property which is mentioned in the ICCCM.
    extern fn gtk_window_set_icon_name(p_window: *Window, p_name: ?[*:0]const u8) void;
    pub const setIconName = gtk_window_set_icon_name;

    /// Asks to keep `window` above, so that it stays on top. Note that
    /// you shouldn’t assume the window is definitely above afterward,
    /// because other entities (e.g. the user or
    /// [window manager][gtk-X11-arch]) could not keep it above,
    /// and not all window managers support keeping windows above. But
    /// normally the window will end kept above. Just don’t write code
    /// that crashes if not.
    ///
    /// It’s permitted to call this function before showing a window,
    /// in which case the window will be kept above when it appears onscreen
    /// initially.
    ///
    /// You can track the above state via the “window-state-event” signal
    /// on `gtk.Widget`.
    ///
    /// Note that, according to the
    /// [Extended Window Manager Hints Specification](http://www.freedesktop.org/Standards/wm-spec),
    /// the above state is mainly meant for user preferences and should not
    /// be used by applications e.g. for drawing attention to their
    /// dialogs.
    extern fn gtk_window_set_keep_above(p_window: *Window, p_setting: c_int) void;
    pub const setKeepAbove = gtk_window_set_keep_above;

    /// Asks to keep `window` below, so that it stays in bottom. Note that
    /// you shouldn’t assume the window is definitely below afterward,
    /// because other entities (e.g. the user or
    /// [window manager][gtk-X11-arch]) could not keep it below,
    /// and not all window managers support putting windows below. But
    /// normally the window will be kept below. Just don’t write code
    /// that crashes if not.
    ///
    /// It’s permitted to call this function before showing a window,
    /// in which case the window will be kept below when it appears onscreen
    /// initially.
    ///
    /// You can track the below state via the “window-state-event” signal
    /// on `gtk.Widget`.
    ///
    /// Note that, according to the
    /// [Extended Window Manager Hints Specification](http://www.freedesktop.org/Standards/wm-spec),
    /// the above state is mainly meant for user preferences and should not
    /// be used by applications e.g. for drawing attention to their
    /// dialogs.
    extern fn gtk_window_set_keep_below(p_window: *Window, p_setting: c_int) void;
    pub const setKeepBelow = gtk_window_set_keep_below;

    /// Sets the mnemonic modifier for this window.
    extern fn gtk_window_set_mnemonic_modifier(p_window: *Window, p_modifier: gdk.ModifierType) void;
    pub const setMnemonicModifier = gtk_window_set_mnemonic_modifier;

    /// Sets the `gtk.Window.properties.mnemonics`-visible property.
    extern fn gtk_window_set_mnemonics_visible(p_window: *Window, p_setting: c_int) void;
    pub const setMnemonicsVisible = gtk_window_set_mnemonics_visible;

    /// Sets a window modal or non-modal. Modal windows prevent interaction
    /// with other windows in the same application. To keep modal dialogs
    /// on top of main application windows, use
    /// `gtk.Window.setTransientFor` to make the dialog transient for the
    /// parent; most [window managers][gtk-X11-arch]
    /// will then disallow lowering the dialog below the parent.
    extern fn gtk_window_set_modal(p_window: *Window, p_modal: c_int) void;
    pub const setModal = gtk_window_set_modal;

    /// Request the windowing system to make `window` partially transparent,
    /// with opacity 0 being fully transparent and 1 fully opaque. (Values
    /// of the opacity parameter are clamped to the [0,1] range.) On X11
    /// this has any effect only on X screens with a compositing manager
    /// running. See `gtk.Widget.isComposited`. On Windows it should work
    /// always.
    ///
    /// Note that setting a window’s opacity after the window has been
    /// shown causes it to flicker once on Windows.
    extern fn gtk_window_set_opacity(p_window: *Window, p_opacity: f64) void;
    pub const setOpacity = gtk_window_set_opacity;

    /// Sets a position constraint for this window. If the old or new
    /// constraint is `GTK_WIN_POS_CENTER_ALWAYS`, this will also cause
    /// the window to be repositioned to satisfy the new constraint.
    extern fn gtk_window_set_position(p_window: *Window, p_position: gtk.WindowPosition) void;
    pub const setPosition = gtk_window_set_position;

    /// Sets whether the user can resize a window. Windows are user resizable
    /// by default.
    extern fn gtk_window_set_resizable(p_window: *Window, p_resizable: c_int) void;
    pub const setResizable = gtk_window_set_resizable;

    /// This function is only useful on X11, not with other GTK+ targets.
    ///
    /// In combination with the window title, the window role allows a
    /// [window manager][gtk-X11-arch] to identify "the
    /// same" window when an application is restarted. So for example you
    /// might set the “toolbox” role on your app’s toolbox window, so that
    /// when the user restarts their session, the window manager can put
    /// the toolbox back in the same place.
    ///
    /// If a window already has a unique title, you don’t need to set the
    /// role, since the WM can use the title to identify the window when
    /// restoring the session.
    extern fn gtk_window_set_role(p_window: *Window, p_role: [*:0]const u8) void;
    pub const setRole = gtk_window_set_role;

    /// Sets the `gdk.Screen` where the `window` is displayed; if
    /// the window is already mapped, it will be unmapped, and
    /// then remapped on the new screen.
    extern fn gtk_window_set_screen(p_window: *Window, p_screen: *gdk.Screen) void;
    pub const setScreen = gtk_window_set_screen;

    /// Windows may set a hint asking the desktop environment not to display
    /// the window in the pager. This function sets this hint.
    /// (A "pager" is any desktop navigation tool such as a workspace
    /// switcher that displays a thumbnail representation of the windows
    /// on the screen.)
    extern fn gtk_window_set_skip_pager_hint(p_window: *Window, p_setting: c_int) void;
    pub const setSkipPagerHint = gtk_window_set_skip_pager_hint;

    /// Windows may set a hint asking the desktop environment not to display
    /// the window in the task bar. This function sets this hint.
    extern fn gtk_window_set_skip_taskbar_hint(p_window: *Window, p_setting: c_int) void;
    pub const setSkipTaskbarHint = gtk_window_set_skip_taskbar_hint;

    /// Startup notification identifiers are used by desktop environment to
    /// track application startup, to provide user feedback and other
    /// features. This function changes the corresponding property on the
    /// underlying GdkWindow. Normally, startup identifier is managed
    /// automatically and you should only use this function in special cases
    /// like transferring focus from other processes. You should use this
    /// function before calling `gtk.Window.present` or any equivalent
    /// function generating a window map event.
    ///
    /// This function is only useful on X11, not with other GTK+ targets.
    extern fn gtk_window_set_startup_id(p_window: *Window, p_startup_id: [*:0]const u8) void;
    pub const setStartupId = gtk_window_set_startup_id;

    /// Sets the title of the `gtk.Window`. The title of a window will be
    /// displayed in its title bar; on the X Window System, the title bar
    /// is rendered by the [window manager][gtk-X11-arch],
    /// so exactly how the title appears to users may vary
    /// according to a user’s exact configuration. The title should help a
    /// user distinguish this window from other windows they may have
    /// open. A good title might include the application name and current
    /// document filename, for example.
    extern fn gtk_window_set_title(p_window: *Window, p_title: [*:0]const u8) void;
    pub const setTitle = gtk_window_set_title;

    /// Sets a custom titlebar for `window`.
    ///
    /// A typical widget used here is `gtk.HeaderBar`, as it provides various features
    /// expected of a titlebar while allowing the addition of child widgets to it.
    ///
    /// If you set a custom titlebar, GTK+ will do its best to convince
    /// the window manager not to put its own titlebar on the window.
    /// Depending on the system, this function may not work for a window
    /// that is already visible, so you set the titlebar before calling
    /// `gtk.Widget.show`.
    extern fn gtk_window_set_titlebar(p_window: *Window, p_titlebar: ?*gtk.Widget) void;
    pub const setTitlebar = gtk_window_set_titlebar;

    /// Dialog windows should be set transient for the main application
    /// window they were spawned from. This allows
    /// [window managers][gtk-X11-arch] to e.g. keep the
    /// dialog on top of the main window, or center the dialog over the
    /// main window. `gtk.Dialog.newWithButtons` and other convenience
    /// functions in GTK+ will sometimes call
    /// `gtk.Window.setTransientFor` on your behalf.
    ///
    /// Passing `NULL` for `parent` unsets the current transient window.
    ///
    /// On Wayland, this function can also be used to attach a new
    /// `GTK_WINDOW_POPUP` to a `GTK_WINDOW_TOPLEVEL` parent already mapped
    /// on screen so that the `GTK_WINDOW_POPUP` will be created as a
    /// subsurface-based window `GDK_WINDOW_SUBSURFACE` which can be
    /// positioned at will relatively to the `GTK_WINDOW_TOPLEVEL` surface.
    ///
    /// On Windows, this function puts the child window on top of the parent,
    /// much as the window manager would have done on X.
    extern fn gtk_window_set_transient_for(p_window: *Window, p_parent: ?*gtk.Window) void;
    pub const setTransientFor = gtk_window_set_transient_for;

    /// By setting the type hint for the window, you allow the window
    /// manager to decorate and handle the window in a way which is
    /// suitable to the function of the window in your application.
    ///
    /// This function should be called before the window becomes visible.
    ///
    /// `gtk.Dialog.newWithButtons` and other convenience functions in GTK+
    /// will sometimes call `gtk.Window.setTypeHint` on your behalf.
    extern fn gtk_window_set_type_hint(p_window: *Window, p_hint: gdk.WindowTypeHint) void;
    pub const setTypeHint = gtk_window_set_type_hint;

    /// Windows may set a hint asking the desktop environment to draw
    /// the users attention to the window. This function sets this hint.
    extern fn gtk_window_set_urgency_hint(p_window: *Window, p_setting: c_int) void;
    pub const setUrgencyHint = gtk_window_set_urgency_hint;

    /// Don’t use this function. It sets the X Window System “class” and
    /// “name” hints for a window.  According to the ICCCM, you should
    /// always set these to the same value for all windows in an
    /// application, and GTK+ sets them to that value by default, so calling
    /// this function is sort of pointless. However, you may want to call
    /// `gtk.Window.setRole` on each window in your application, for the
    /// benefit of the session manager. Setting the role allows the window
    /// manager to restore window positions when loading a saved session.
    extern fn gtk_window_set_wmclass(p_window: *Window, p_wmclass_name: [*:0]const u8, p_wmclass_class: [*:0]const u8) void;
    pub const setWmclass = gtk_window_set_wmclass;

    /// Asks to stick `window`, which means that it will appear on all user
    /// desktops. Note that you shouldn’t assume the window is definitely
    /// stuck afterward, because other entities (e.g. the user or
    /// [window manager][gtk-X11-arch] could unstick it
    /// again, and some window managers do not support sticking
    /// windows. But normally the window will end up stuck. Just don't
    /// write code that crashes if not.
    ///
    /// It’s permitted to call this function before showing a window.
    ///
    /// You can track stickiness via the “window-state-event” signal
    /// on `gtk.Widget`.
    extern fn gtk_window_stick(p_window: *Window) void;
    pub const stick = gtk_window_stick;

    /// Asks to toggle off the fullscreen state for `window`. Note that you
    /// shouldn’t assume the window is definitely not full screen
    /// afterward, because other entities (e.g. the user or
    /// [window manager][gtk-X11-arch]) could fullscreen it
    /// again, and not all window managers honor requests to unfullscreen
    /// windows. But normally the window will end up restored to its normal
    /// state. Just don’t write code that crashes if not.
    ///
    /// You can track the fullscreen state via the “window-state-event” signal
    /// on `gtk.Widget`.
    extern fn gtk_window_unfullscreen(p_window: *Window) void;
    pub const unfullscreen = gtk_window_unfullscreen;

    /// Asks to unmaximize `window`. Note that you shouldn’t assume the
    /// window is definitely unmaximized afterward, because other entities
    /// (e.g. the user or [window manager][gtk-X11-arch])
    /// could maximize it again, and not all window
    /// managers honor requests to unmaximize. But normally the window will
    /// end up unmaximized. Just don’t write code that crashes if not.
    ///
    /// You can track maximization via the “window-state-event” signal
    /// on `gtk.Widget`.
    extern fn gtk_window_unmaximize(p_window: *Window) void;
    pub const unmaximize = gtk_window_unmaximize;

    /// Asks to unstick `window`, which means that it will appear on only
    /// one of the user’s desktops. Note that you shouldn’t assume the
    /// window is definitely unstuck afterward, because other entities
    /// (e.g. the user or [window manager][gtk-X11-arch]) could
    /// stick it again. But normally the window will
    /// end up unstuck. Just don’t write code that crashes if not.
    ///
    /// You can track stickiness via the “window-state-event” signal
    /// on `gtk.Widget`.
    extern fn gtk_window_unstick(p_window: *Window) void;
    pub const unstick = gtk_window_unstick;

    extern fn gtk_window_get_type() usize;
    pub const getGObjectType = gtk_window_get_type;

    extern fn g_object_ref(p_self: *gtk.Window) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Window) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Window, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const WindowAccessible = extern struct {
    pub const Parent = gtk.ContainerAccessible;
    pub const Implements = [_]type{ atk.Component, atk.Window };
    pub const Class = gtk.WindowAccessibleClass;
    f_parent: gtk.ContainerAccessible,
    f_priv: ?*gtk.WindowAccessiblePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_window_accessible_get_type() usize;
    pub const getGObjectType = gtk_window_accessible_get_type;

    extern fn g_object_ref(p_self: *gtk.WindowAccessible) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.WindowAccessible) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *WindowAccessible, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.WindowGroup` restricts the effect of grabs to windows
/// in the same group, thereby making window groups almost behave
/// like separate applications.
///
/// A window can be a member in at most one window group at a time.
/// Windows that have not been explicitly assigned to a group are
/// implicitly treated like windows of the default window group.
///
/// GtkWindowGroup objects are referenced by each window in the group,
/// so once you have added all windows to a GtkWindowGroup, you can drop
/// the initial reference to the window group with `gobject.Object.unref`. If the
/// windows in the window group are subsequently destroyed, then they will
/// be removed from the window group and drop their references on the window
/// group; when all window have been removed, the window group will be
/// freed.
pub const WindowGroup = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gtk.WindowGroupClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gtk.WindowGroupPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gtk.WindowGroup` object. Grabs added with
    /// `gtk.Widget.grabAdd` only affect windows within the same `gtk.WindowGroup`.
    extern fn gtk_window_group_new() *gtk.WindowGroup;
    pub const new = gtk_window_group_new;

    /// Adds a window to a `gtk.WindowGroup`.
    extern fn gtk_window_group_add_window(p_window_group: *WindowGroup, p_window: *gtk.Window) void;
    pub const addWindow = gtk_window_group_add_window;

    /// Returns the current grab widget for `device`, or `NULL` if none.
    extern fn gtk_window_group_get_current_device_grab(p_window_group: *WindowGroup, p_device: *gdk.Device) ?*gtk.Widget;
    pub const getCurrentDeviceGrab = gtk_window_group_get_current_device_grab;

    /// Gets the current grab widget of the given group,
    /// see `gtk.Widget.grabAdd`.
    extern fn gtk_window_group_get_current_grab(p_window_group: *WindowGroup) *gtk.Widget;
    pub const getCurrentGrab = gtk_window_group_get_current_grab;

    /// Returns a list of the `GtkWindows` that belong to `window_group`.
    extern fn gtk_window_group_list_windows(p_window_group: *WindowGroup) *glib.List;
    pub const listWindows = gtk_window_group_list_windows;

    /// Removes a window from a `gtk.WindowGroup`.
    extern fn gtk_window_group_remove_window(p_window_group: *WindowGroup, p_window: *gtk.Window) void;
    pub const removeWindow = gtk_window_group_remove_window;

    extern fn gtk_window_group_get_type() usize;
    pub const getGObjectType = gtk_window_group_get_type;

    extern fn g_object_ref(p_self: *gtk.WindowGroup) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.WindowGroup) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *WindowGroup, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// This interface provides a convenient way of associating widgets with
/// actions on a `gtk.ApplicationWindow` or `gtk.Application`.
///
/// It primarily consists of two properties: `gtk.Actionable.properties.action`-name
/// and `gtk.Actionable.properties.action`-target. There are also some convenience APIs
/// for setting these properties.
///
/// The action will be looked up in action groups that are found among
/// the widgets ancestors. Most commonly, these will be the actions with
/// the “win.” or “app.” prefix that are associated with the `gtk.ApplicationWindow`
/// or `gtk.Application`, but other action groups that are added with
/// `gtk.Widget.insertActionGroup` will be consulted as well.
pub const Actionable = opaque {
    pub const Prerequisites = [_]type{gtk.Widget};
    pub const Iface = gtk.ActionableInterface;
    pub const virtual_methods = struct {
        /// Gets the action name for `actionable`.
        ///
        /// See `gtk.Actionable.setActionName` for more information.
        pub const get_action_name = struct {
            pub fn call(p_class: anytype, p_actionable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]const u8 {
                return gobject.ext.as(Actionable.Iface, p_class).f_get_action_name.?(gobject.ext.as(Actionable, p_actionable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_actionable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]const u8) void {
                gobject.ext.as(Actionable.Iface, p_class).f_get_action_name = @ptrCast(p_implementation);
            }
        };

        /// Gets the current target value of `actionable`.
        ///
        /// See `gtk.Actionable.setActionTargetValue` for more information.
        pub const get_action_target_value = struct {
            pub fn call(p_class: anytype, p_actionable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *glib.Variant {
                return gobject.ext.as(Actionable.Iface, p_class).f_get_action_target_value.?(gobject.ext.as(Actionable, p_actionable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_actionable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *glib.Variant) void {
                gobject.ext.as(Actionable.Iface, p_class).f_get_action_target_value = @ptrCast(p_implementation);
            }
        };

        /// Specifies the name of the action with which this widget should be
        /// associated.  If `action_name` is `NULL` then the widget will be
        /// unassociated from any previous action.
        ///
        /// Usually this function is used when the widget is located (or will be
        /// located) within the hierarchy of a `gtk.ApplicationWindow`.
        ///
        /// Names are of the form “win.save” or “app.quit” for actions on the
        /// containing `gtk.ApplicationWindow` or its associated `gtk.Application`,
        /// respectively.  This is the same form used for actions in the `gio.Menu`
        /// associated with the window.
        pub const set_action_name = struct {
            pub fn call(p_class: anytype, p_actionable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: ?[*:0]const u8) void {
                return gobject.ext.as(Actionable.Iface, p_class).f_set_action_name.?(gobject.ext.as(Actionable, p_actionable), p_action_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_actionable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: ?[*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(Actionable.Iface, p_class).f_set_action_name = @ptrCast(p_implementation);
            }
        };

        /// Sets the target value of an actionable widget.
        ///
        /// If `target_value` is `NULL` then the target value is unset.
        ///
        /// The target value has two purposes.  First, it is used as the
        /// parameter to activation of the action associated with the
        /// `gtk.Actionable` widget. Second, it is used to determine if the widget
        /// should be rendered as “active” — the widget is active if the state
        /// is equal to the given target.
        ///
        /// Consider the example of associating a set of buttons with a `gio.Action`
        /// with string state in a typical “radio button” situation.  Each button
        /// will be associated with the same action, but with a different target
        /// value for that action.  Clicking on a particular button will activate
        /// the action with the target of that button, which will typically cause
        /// the action’s state to change to that value.  Since the action’s state
        /// is now equal to the target value of the button, the button will now
        /// be rendered as active (and the other buttons, with different targets,
        /// rendered inactive).
        pub const set_action_target_value = struct {
            pub fn call(p_class: anytype, p_actionable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_target_value: ?*glib.Variant) void {
                return gobject.ext.as(Actionable.Iface, p_class).f_set_action_target_value.?(gobject.ext.as(Actionable, p_actionable), p_target_value);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_actionable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_target_value: ?*glib.Variant) callconv(.c) void) void {
                gobject.ext.as(Actionable.Iface, p_class).f_set_action_target_value = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        pub const action_name = struct {
            pub const name = "action-name";

            pub const Type = ?[*:0]u8;
        };

        pub const action_target = struct {
            pub const name = "action-target";

            pub const Type = ?*glib.Variant;
        };
    };

    pub const signals = struct {};

    /// Gets the action name for `actionable`.
    ///
    /// See `gtk.Actionable.setActionName` for more information.
    extern fn gtk_actionable_get_action_name(p_actionable: *Actionable) ?[*:0]const u8;
    pub const getActionName = gtk_actionable_get_action_name;

    /// Gets the current target value of `actionable`.
    ///
    /// See `gtk.Actionable.setActionTargetValue` for more information.
    extern fn gtk_actionable_get_action_target_value(p_actionable: *Actionable) *glib.Variant;
    pub const getActionTargetValue = gtk_actionable_get_action_target_value;

    /// Specifies the name of the action with which this widget should be
    /// associated.  If `action_name` is `NULL` then the widget will be
    /// unassociated from any previous action.
    ///
    /// Usually this function is used when the widget is located (or will be
    /// located) within the hierarchy of a `gtk.ApplicationWindow`.
    ///
    /// Names are of the form “win.save” or “app.quit” for actions on the
    /// containing `gtk.ApplicationWindow` or its associated `gtk.Application`,
    /// respectively.  This is the same form used for actions in the `gio.Menu`
    /// associated with the window.
    extern fn gtk_actionable_set_action_name(p_actionable: *Actionable, p_action_name: ?[*:0]const u8) void;
    pub const setActionName = gtk_actionable_set_action_name;

    /// Sets the target of an actionable widget.
    ///
    /// This is a convenience function that calls `glib.Variant.new` for
    /// `format_string` and uses the result to call
    /// `gtk.Actionable.setActionTargetValue`.
    ///
    /// If you are setting a string-valued target and want to set the action
    /// name at the same time, you can use
    /// gtk_actionable_set_detailed_action_name ().
    extern fn gtk_actionable_set_action_target(p_actionable: *Actionable, p_format_string: [*:0]const u8, ...) void;
    pub const setActionTarget = gtk_actionable_set_action_target;

    /// Sets the target value of an actionable widget.
    ///
    /// If `target_value` is `NULL` then the target value is unset.
    ///
    /// The target value has two purposes.  First, it is used as the
    /// parameter to activation of the action associated with the
    /// `gtk.Actionable` widget. Second, it is used to determine if the widget
    /// should be rendered as “active” — the widget is active if the state
    /// is equal to the given target.
    ///
    /// Consider the example of associating a set of buttons with a `gio.Action`
    /// with string state in a typical “radio button” situation.  Each button
    /// will be associated with the same action, but with a different target
    /// value for that action.  Clicking on a particular button will activate
    /// the action with the target of that button, which will typically cause
    /// the action’s state to change to that value.  Since the action’s state
    /// is now equal to the target value of the button, the button will now
    /// be rendered as active (and the other buttons, with different targets,
    /// rendered inactive).
    extern fn gtk_actionable_set_action_target_value(p_actionable: *Actionable, p_target_value: ?*glib.Variant) void;
    pub const setActionTargetValue = gtk_actionable_set_action_target_value;

    /// Sets the action-name and associated string target value of an
    /// actionable widget.
    ///
    /// `detailed_action_name` is a string in the format accepted by
    /// `gio.actionParseDetailedName`.
    ///
    /// (Note that prior to version 3.22.25,
    /// this function is only usable for actions with a simple "s" target, and
    /// `detailed_action_name` must be of the form `"action::target"` where
    /// `action` is the action name and `target` is the string to use
    /// as the target.)
    extern fn gtk_actionable_set_detailed_action_name(p_actionable: *Actionable, p_detailed_action_name: [*:0]const u8) void;
    pub const setDetailedActionName = gtk_actionable_set_detailed_action_name;

    extern fn gtk_actionable_get_type() usize;
    pub const getGObjectType = gtk_actionable_get_type;

    extern fn g_object_ref(p_self: *gtk.Actionable) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Actionable) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Actionable, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Activatable widgets can be connected to a `gtk.Action` and reflects
/// the state of its action. A `gtk.Activatable` can also provide feedback
/// through its action, as they are responsible for activating their
/// related actions.
///
/// # Implementing GtkActivatable
///
/// When extending a class that is already `gtk.Activatable`; it is only
/// necessary to implement the `gtk.Activatable`->`sync_action_properties`
/// and `gtk.Activatable`->`update` methods and chain up to the parent
/// implementation, however when introducing
/// a new `gtk.Activatable` class; the `gtk.Activatable.properties.related`-action and
/// `gtk.Activatable.properties.use`-action-appearance properties need to be handled by
/// the implementor. Handling these properties is mostly a matter of installing
/// the action pointer and boolean flag on your instance, and calling
/// `gtk.Activatable.doSetRelatedAction` and
/// `gtk.Activatable.syncActionProperties` at the appropriate times.
///
/// ## A class fragment implementing
///
/// ```
///
/// enum {
/// ...
///
/// PROP_ACTIVATABLE_RELATED_ACTION,
/// PROP_ACTIVATABLE_USE_ACTION_APPEARANCE
/// }
///
/// struct _FooBarPrivate
/// {
///
///   ...
///
///   GtkAction      *action;
///   gboolean        use_action_appearance;
/// };
///
/// ...
///
/// static void foo_bar_activatable_interface_init         (GtkActivatableIface  *iface);
/// static void foo_bar_activatable_update                 (GtkActivatable       *activatable,
///                                    GtkAction            *action,
///                                    const gchar          *property_name);
/// static void foo_bar_activatable_sync_action_properties (GtkActivatable       *activatable,
///                                    GtkAction            *action);
/// ...
///
///
/// static void
/// foo_bar_class_init (FooBarClass *klass)
/// {
///
///   ...
///
///   g_object_class_override_property (gobject_class, PROP_ACTIVATABLE_RELATED_ACTION, "related-action");
///   g_object_class_override_property (gobject_class, PROP_ACTIVATABLE_USE_ACTION_APPEARANCE, "use-action-appearance");
///
///   ...
/// }
///
///
/// static void
/// foo_bar_activatable_interface_init (GtkActivatableIface  *iface)
/// {
///   iface->update = foo_bar_activatable_update;
///   iface->sync_action_properties = foo_bar_activatable_sync_action_properties;
/// }
///
/// ... Break the reference using `gtk.Activatable.doSetRelatedAction`...
///
/// static void
/// foo_bar_dispose (GObject *object)
/// {
///   FooBar *bar = FOO_BAR (object);
///   FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
///
///   ...
///
///   if (priv->action)
///     {
///       gtk_activatable_do_set_related_action (GTK_ACTIVATABLE (bar), NULL);
///       priv->action = NULL;
///     }
///   G_OBJECT_CLASS (foo_bar_parent_class)->dispose (object);
/// }
///
/// ... Handle the “related-action” and “use-action-appearance” properties ...
///
/// static void
/// foo_bar_set_property (GObject         *object,
///                       guint            prop_id,
///                       const GValue    *value,
///                       GParamSpec      *pspec)
/// {
///   FooBar *bar = FOO_BAR (object);
///   FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
///
///   switch (prop_id)
///     {
///
///       ...
///
///     case PROP_ACTIVATABLE_RELATED_ACTION:
///       foo_bar_set_related_action (bar, g_value_get_object (value));
///       break;
///     case PROP_ACTIVATABLE_USE_ACTION_APPEARANCE:
///       foo_bar_set_use_action_appearance (bar, g_value_get_boolean (value));
///       break;
///     default:
///       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
///       break;
///     }
/// }
///
/// static void
/// foo_bar_get_property (GObject         *object,
///                          guint            prop_id,
///                          GValue          *value,
///                          GParamSpec      *pspec)
/// {
///   FooBar *bar = FOO_BAR (object);
///   FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
///
///   switch (prop_id)
///     {
///
///       ...
///
///     case PROP_ACTIVATABLE_RELATED_ACTION:
///       g_value_set_object (value, priv->action);
///       break;
///     case PROP_ACTIVATABLE_USE_ACTION_APPEARANCE:
///       g_value_set_boolean (value, priv->use_action_appearance);
///       break;
///     default:
///       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
///       break;
///     }
/// }
///
///
/// static void
/// foo_bar_set_use_action_appearance (FooBar   *bar,
///                    gboolean  use_appearance)
/// {
///   FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
///
///   if (priv->use_action_appearance != use_appearance)
///     {
///       priv->use_action_appearance = use_appearance;
///
///       gtk_activatable_sync_action_properties (GTK_ACTIVATABLE (bar), priv->action);
///     }
/// }
///
/// ... call `gtk.Activatable.doSetRelatedAction` and then assign the action pointer,
/// no need to reference the action here since `gtk.Activatable.doSetRelatedAction` already
/// holds a reference here for you...
/// static void
/// foo_bar_set_related_action (FooBar    *bar,
///                 GtkAction *action)
/// {
///   FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
///
///   if (priv->action == action)
///     return;
///
///   gtk_activatable_do_set_related_action (GTK_ACTIVATABLE (bar), action);
///
///   priv->action = action;
/// }
///
/// ... Selectively reset and update activatable depending on the use-action-appearance property ...
/// static void
/// gtk_button_activatable_sync_action_properties (GtkActivatable       *activatable,
///                                           GtkAction            *action)
/// {
///   GtkButtonPrivate *priv = GTK_BUTTON_GET_PRIVATE (activatable);
///
///   if (!action)
///     return;
///
///   if (gtk_action_is_visible (action))
///     gtk_widget_show (GTK_WIDGET (activatable));
///   else
///     gtk_widget_hide (GTK_WIDGET (activatable));
///
///   gtk_widget_set_sensitive (GTK_WIDGET (activatable), gtk_action_is_sensitive (action));
///
///   ...
///
///   if (priv->use_action_appearance)
///     {
///       if (gtk_action_get_stock_id (action))
///     foo_bar_set_stock (button, gtk_action_get_stock_id (action));
///       else if (gtk_action_get_label (action))
///     foo_bar_set_label (button, gtk_action_get_label (action));
///
///       ...
///
///     }
/// }
///
/// static void
/// foo_bar_activatable_update (GtkActivatable       *activatable,
///                    GtkAction            *action,
///                    const gchar          *property_name)
/// {
///   FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (activatable);
///
///   if (strcmp (property_name, "visible") == 0)
///     {
///       if (gtk_action_is_visible (action))
///     gtk_widget_show (GTK_WIDGET (activatable));
///       else
///     gtk_widget_hide (GTK_WIDGET (activatable));
///     }
///   else if (strcmp (property_name, "sensitive") == 0)
///     gtk_widget_set_sensitive (GTK_WIDGET (activatable), gtk_action_is_sensitive (action));
///
///   ...
///
///   if (!priv->use_action_appearance)
///     return;
///
///   if (strcmp (property_name, "stock-id") == 0)
///     foo_bar_set_stock (button, gtk_action_get_stock_id (action));
///   else if (strcmp (property_name, "label") == 0)
///     foo_bar_set_label (button, gtk_action_get_label (action));
///
///   ...
/// }
/// ```
pub const Activatable = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gtk.ActivatableIface;
    pub const virtual_methods = struct {
        /// This is called to update the activatable completely, this is called
        /// internally when the `gtk.Activatable.properties.related`-action property is set
        /// or unset and by the implementing class when
        /// `gtk.Activatable.properties.use`-action-appearance changes.
        pub const sync_action_properties = struct {
            pub fn call(p_class: anytype, p_activatable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action: ?*gtk.Action) void {
                return gobject.ext.as(Activatable.Iface, p_class).f_sync_action_properties.?(gobject.ext.as(Activatable, p_activatable), p_action);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_activatable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action: ?*gtk.Action) callconv(.c) void) void {
                gobject.ext.as(Activatable.Iface, p_class).f_sync_action_properties = @ptrCast(p_implementation);
            }
        };

        /// Called to update the activatable when its related action’s properties change.
        /// You must check the `gtk.Activatable.properties.use`-action-appearance property only apply action
        /// properties that are meant to effect the appearance accordingly.
        pub const update = struct {
            pub fn call(p_class: anytype, p_activatable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action: *gtk.Action, p_property_name: [*:0]const u8) void {
                return gobject.ext.as(Activatable.Iface, p_class).f_update.?(gobject.ext.as(Activatable, p_activatable), p_action, p_property_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_activatable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action: *gtk.Action, p_property_name: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(Activatable.Iface, p_class).f_update = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The action that this activatable will activate and receive
        /// updates from for various states and possibly appearance.
        ///
        /// > `gtk.Activatable` implementors need to handle the this property and
        /// > call `gtk.Activatable.doSetRelatedAction` when it changes.
        pub const related_action = struct {
            pub const name = "related-action";

            pub const Type = ?*gtk.Action;
        };

        /// Whether this activatable should reset its layout
        /// and appearance when setting the related action or when
        /// the action changes appearance.
        ///
        /// See the `gtk.Action` documentation directly to find which properties
        /// should be ignored by the `gtk.Activatable` when this property is `FALSE`.
        ///
        /// > `gtk.Activatable` implementors need to handle this property
        /// > and call `gtk.Activatable.syncActionProperties` on the activatable
        /// > widget when it changes.
        pub const use_action_appearance = struct {
            pub const name = "use-action-appearance";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// This is a utility function for `gtk.Activatable` implementors.
    ///
    /// When implementing `gtk.Activatable` you must call this when
    /// handling changes of the `gtk.Activatable.properties.related`-action, and
    /// you must also use this to break references in `gobject.Object`->`dispose`.
    ///
    /// This function adds a reference to the currently set related
    /// action for you, it also makes sure the `gtk.Activatable`->`update`
    /// method is called when the related `gtk.Action` properties change
    /// and registers to the action’s proxy list.
    ///
    /// > Be careful to call this before setting the local
    /// > copy of the `gtk.Action` property, since this function uses
    /// > `gtk.Activatable.getRelatedAction` to retrieve the
    /// > previous action.
    extern fn gtk_activatable_do_set_related_action(p_activatable: *Activatable, p_action: *gtk.Action) void;
    pub const doSetRelatedAction = gtk_activatable_do_set_related_action;

    /// Gets the related `gtk.Action` for `activatable`.
    extern fn gtk_activatable_get_related_action(p_activatable: *Activatable) *gtk.Action;
    pub const getRelatedAction = gtk_activatable_get_related_action;

    /// Gets whether this activatable should reset its layout
    /// and appearance when setting the related action or when
    /// the action changes appearance.
    extern fn gtk_activatable_get_use_action_appearance(p_activatable: *Activatable) c_int;
    pub const getUseActionAppearance = gtk_activatable_get_use_action_appearance;

    /// Sets the related action on the `activatable` object.
    ///
    /// > `gtk.Activatable` implementors need to handle the `gtk.Activatable.properties.related`-action
    /// > property and call `gtk.Activatable.doSetRelatedAction` when it changes.
    extern fn gtk_activatable_set_related_action(p_activatable: *Activatable, p_action: *gtk.Action) void;
    pub const setRelatedAction = gtk_activatable_set_related_action;

    /// Sets whether this activatable should reset its layout and appearance
    /// when setting the related action or when the action changes appearance
    ///
    /// > `gtk.Activatable` implementors need to handle the
    /// > `gtk.Activatable.properties.use`-action-appearance property and call
    /// > `gtk.Activatable.syncActionProperties` to update `activatable`
    /// > if needed.
    extern fn gtk_activatable_set_use_action_appearance(p_activatable: *Activatable, p_use_appearance: c_int) void;
    pub const setUseActionAppearance = gtk_activatable_set_use_action_appearance;

    /// This is called to update the activatable completely, this is called
    /// internally when the `gtk.Activatable.properties.related`-action property is set
    /// or unset and by the implementing class when
    /// `gtk.Activatable.properties.use`-action-appearance changes.
    extern fn gtk_activatable_sync_action_properties(p_activatable: *Activatable, p_action: ?*gtk.Action) void;
    pub const syncActionProperties = gtk_activatable_sync_action_properties;

    extern fn gtk_activatable_get_type() usize;
    pub const getGObjectType = gtk_activatable_get_type;

    extern fn g_object_ref(p_self: *gtk.Activatable) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Activatable) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Activatable, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.AppChooser` is an interface that can be implemented by widgets which
/// allow the user to choose an application (typically for the purpose of
/// opening a file). The main objects that implement this interface are
/// `gtk.AppChooserWidget`, `gtk.AppChooserDialog` and `gtk.AppChooserButton`.
///
/// Applications are represented by GIO `gio.AppInfo` objects here.
/// GIO has a concept of recommended and fallback applications for a
/// given content type. Recommended applications are those that claim
/// to handle the content type itself, while fallback also includes
/// applications that handle a more generic content type. GIO also
/// knows the default and last-used application for a given content
/// type. The `gtk.AppChooserWidget` provides detailed control over
/// whether the shown list of applications should include default,
/// recommended or fallback applications.
///
/// To obtain the application that has been selected in a `gtk.AppChooser`,
/// use `gtk.AppChooser.getAppInfo`.
pub const AppChooser = opaque {
    pub const Prerequisites = [_]type{gtk.Widget};
    pub const Iface = opaque {
        pub const Instance = AppChooser;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The content type of the `gtk.AppChooser` object.
        ///
        /// See [GContentType][gio-GContentType]
        /// for more information about content types.
        pub const content_type = struct {
            pub const name = "content-type";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Returns the currently selected application.
    extern fn gtk_app_chooser_get_app_info(p_self: *AppChooser) ?*gio.AppInfo;
    pub const getAppInfo = gtk_app_chooser_get_app_info;

    /// Returns the current value of the `gtk.AppChooser.properties.content`-type property.
    extern fn gtk_app_chooser_get_content_type(p_self: *AppChooser) [*:0]u8;
    pub const getContentType = gtk_app_chooser_get_content_type;

    /// Reloads the list of applications.
    extern fn gtk_app_chooser_refresh(p_self: *AppChooser) void;
    pub const refresh = gtk_app_chooser_refresh;

    extern fn gtk_app_chooser_get_type() usize;
    pub const getGObjectType = gtk_app_chooser_get_type;

    extern fn g_object_ref(p_self: *gtk.AppChooser) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.AppChooser) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *AppChooser, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkBuildable allows objects to extend and customize their deserialization
/// from [GtkBuilder UI descriptions][BUILDER-UI].
/// The interface includes methods for setting names and properties of objects,
/// parsing custom tags and constructing child objects.
///
/// The GtkBuildable interface is implemented by all widgets and
/// many of the non-widget objects that are provided by GTK+. The
/// main user of this interface is `gtk.Builder`. There should be
/// very little need for applications to call any of these functions directly.
///
/// An object only needs to implement this interface if it needs to extend the
/// `gtk.Builder` format or run any extra routines at deserialization time.
pub const Buildable = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gtk.BuildableIface;
    pub const virtual_methods = struct {
        /// Adds a child to `buildable`. `type` is an optional string
        /// describing how the child should be added.
        pub const add_child = struct {
            pub fn call(p_class: anytype, p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder, p_child: *gobject.Object, p_type: ?[*:0]const u8) void {
                return gobject.ext.as(Buildable.Iface, p_class).f_add_child.?(gobject.ext.as(Buildable, p_buildable), p_builder, p_child, p_type);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder, p_child: *gobject.Object, p_type: ?[*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(Buildable.Iface, p_class).f_add_child = @ptrCast(p_implementation);
            }
        };

        /// Constructs a child of `buildable` with the name `name`.
        ///
        /// `gtk.Builder` calls this function if a “constructor” has been
        /// specified in the UI definition.
        pub const construct_child = struct {
            pub fn call(p_class: anytype, p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder, p_name: [*:0]const u8) *gobject.Object {
                return gobject.ext.as(Buildable.Iface, p_class).f_construct_child.?(gobject.ext.as(Buildable, p_buildable), p_builder, p_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder, p_name: [*:0]const u8) callconv(.c) *gobject.Object) void {
                gobject.ext.as(Buildable.Iface, p_class).f_construct_child = @ptrCast(p_implementation);
            }
        };

        /// This is similar to `gtk.Buildable.parserFinished` but is
        /// called once for each custom tag handled by the `buildable`.
        pub const custom_finished = struct {
            pub fn call(p_class: anytype, p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder, p_child: ?*gobject.Object, p_tagname: [*:0]const u8, p_data: ?*anyopaque) void {
                return gobject.ext.as(Buildable.Iface, p_class).f_custom_finished.?(gobject.ext.as(Buildable, p_buildable), p_builder, p_child, p_tagname, p_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder, p_child: ?*gobject.Object, p_tagname: [*:0]const u8, p_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Buildable.Iface, p_class).f_custom_finished = @ptrCast(p_implementation);
            }
        };

        /// This is called at the end of each custom element handled by
        /// the buildable.
        pub const custom_tag_end = struct {
            pub fn call(p_class: anytype, p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder, p_child: ?*gobject.Object, p_tagname: [*:0]const u8, p_data: ?*anyopaque) void {
                return gobject.ext.as(Buildable.Iface, p_class).f_custom_tag_end.?(gobject.ext.as(Buildable, p_buildable), p_builder, p_child, p_tagname, p_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder, p_child: ?*gobject.Object, p_tagname: [*:0]const u8, p_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Buildable.Iface, p_class).f_custom_tag_end = @ptrCast(p_implementation);
            }
        };

        /// This is called for each unknown element under `<child>`.
        pub const custom_tag_start = struct {
            pub fn call(p_class: anytype, p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder, p_child: ?*gobject.Object, p_tagname: [*:0]const u8, p_parser: *glib.MarkupParser, p_data: ?*anyopaque) c_int {
                return gobject.ext.as(Buildable.Iface, p_class).f_custom_tag_start.?(gobject.ext.as(Buildable, p_buildable), p_builder, p_child, p_tagname, p_parser, p_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder, p_child: ?*gobject.Object, p_tagname: [*:0]const u8, p_parser: *glib.MarkupParser, p_data: ?*anyopaque) callconv(.c) c_int) void {
                gobject.ext.as(Buildable.Iface, p_class).f_custom_tag_start = @ptrCast(p_implementation);
            }
        };

        /// Get the internal child called `childname` of the `buildable` object.
        pub const get_internal_child = struct {
            pub fn call(p_class: anytype, p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder, p_childname: [*:0]const u8) *gobject.Object {
                return gobject.ext.as(Buildable.Iface, p_class).f_get_internal_child.?(gobject.ext.as(Buildable, p_buildable), p_builder, p_childname);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder, p_childname: [*:0]const u8) callconv(.c) *gobject.Object) void {
                gobject.ext.as(Buildable.Iface, p_class).f_get_internal_child = @ptrCast(p_implementation);
            }
        };

        /// Gets the name of the `buildable` object.
        ///
        /// `gtk.Builder` sets the name based on the
        /// [GtkBuilder UI definition][BUILDER-UI]
        /// used to construct the `buildable`.
        pub const get_name = struct {
            pub fn call(p_class: anytype, p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]const u8 {
                return gobject.ext.as(Buildable.Iface, p_class).f_get_name.?(gobject.ext.as(Buildable, p_buildable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]const u8) void {
                gobject.ext.as(Buildable.Iface, p_class).f_get_name = @ptrCast(p_implementation);
            }
        };

        /// Called when the builder finishes the parsing of a
        /// [GtkBuilder UI definition][BUILDER-UI].
        /// Note that this will be called once for each time
        /// `gtk.Builder.addFromFile` or `gtk.Builder.addFromString`
        /// is called on a builder.
        pub const parser_finished = struct {
            pub fn call(p_class: anytype, p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder) void {
                return gobject.ext.as(Buildable.Iface, p_class).f_parser_finished.?(gobject.ext.as(Buildable, p_buildable), p_builder);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder) callconv(.c) void) void {
                gobject.ext.as(Buildable.Iface, p_class).f_parser_finished = @ptrCast(p_implementation);
            }
        };

        /// Sets the property name `name` to `value` on the `buildable` object.
        pub const set_buildable_property = struct {
            pub fn call(p_class: anytype, p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder, p_name: [*:0]const u8, p_value: *const gobject.Value) void {
                return gobject.ext.as(Buildable.Iface, p_class).f_set_buildable_property.?(gobject.ext.as(Buildable, p_buildable), p_builder, p_name, p_value);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *gtk.Builder, p_name: [*:0]const u8, p_value: *const gobject.Value) callconv(.c) void) void {
                gobject.ext.as(Buildable.Iface, p_class).f_set_buildable_property = @ptrCast(p_implementation);
            }
        };

        /// Sets the name of the `buildable` object.
        pub const set_name = struct {
            pub fn call(p_class: anytype, p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_name: [*:0]const u8) void {
                return gobject.ext.as(Buildable.Iface, p_class).f_set_name.?(gobject.ext.as(Buildable, p_buildable), p_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_buildable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_name: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(Buildable.Iface, p_class).f_set_name = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Adds a child to `buildable`. `type` is an optional string
    /// describing how the child should be added.
    extern fn gtk_buildable_add_child(p_buildable: *Buildable, p_builder: *gtk.Builder, p_child: *gobject.Object, p_type: ?[*:0]const u8) void;
    pub const addChild = gtk_buildable_add_child;

    /// Constructs a child of `buildable` with the name `name`.
    ///
    /// `gtk.Builder` calls this function if a “constructor” has been
    /// specified in the UI definition.
    extern fn gtk_buildable_construct_child(p_buildable: *Buildable, p_builder: *gtk.Builder, p_name: [*:0]const u8) *gobject.Object;
    pub const constructChild = gtk_buildable_construct_child;

    /// This is similar to `gtk.Buildable.parserFinished` but is
    /// called once for each custom tag handled by the `buildable`.
    extern fn gtk_buildable_custom_finished(p_buildable: *Buildable, p_builder: *gtk.Builder, p_child: ?*gobject.Object, p_tagname: [*:0]const u8, p_data: ?*anyopaque) void;
    pub const customFinished = gtk_buildable_custom_finished;

    /// This is called at the end of each custom element handled by
    /// the buildable.
    extern fn gtk_buildable_custom_tag_end(p_buildable: *Buildable, p_builder: *gtk.Builder, p_child: ?*gobject.Object, p_tagname: [*:0]const u8, p_data: ?*anyopaque) void;
    pub const customTagEnd = gtk_buildable_custom_tag_end;

    /// This is called for each unknown element under `<child>`.
    extern fn gtk_buildable_custom_tag_start(p_buildable: *Buildable, p_builder: *gtk.Builder, p_child: ?*gobject.Object, p_tagname: [*:0]const u8, p_parser: *glib.MarkupParser, p_data: ?*anyopaque) c_int;
    pub const customTagStart = gtk_buildable_custom_tag_start;

    /// Get the internal child called `childname` of the `buildable` object.
    extern fn gtk_buildable_get_internal_child(p_buildable: *Buildable, p_builder: *gtk.Builder, p_childname: [*:0]const u8) *gobject.Object;
    pub const getInternalChild = gtk_buildable_get_internal_child;

    /// Gets the name of the `buildable` object.
    ///
    /// `gtk.Builder` sets the name based on the
    /// [GtkBuilder UI definition][BUILDER-UI]
    /// used to construct the `buildable`.
    extern fn gtk_buildable_get_name(p_buildable: *Buildable) [*:0]const u8;
    pub const getName = gtk_buildable_get_name;

    /// Called when the builder finishes the parsing of a
    /// [GtkBuilder UI definition][BUILDER-UI].
    /// Note that this will be called once for each time
    /// `gtk.Builder.addFromFile` or `gtk.Builder.addFromString`
    /// is called on a builder.
    extern fn gtk_buildable_parser_finished(p_buildable: *Buildable, p_builder: *gtk.Builder) void;
    pub const parserFinished = gtk_buildable_parser_finished;

    /// Sets the property name `name` to `value` on the `buildable` object.
    extern fn gtk_buildable_set_buildable_property(p_buildable: *Buildable, p_builder: *gtk.Builder, p_name: [*:0]const u8, p_value: *const gobject.Value) void;
    pub const setBuildableProperty = gtk_buildable_set_buildable_property;

    /// Sets the name of the `buildable` object.
    extern fn gtk_buildable_set_name(p_buildable: *Buildable, p_name: [*:0]const u8) void;
    pub const setName = gtk_buildable_set_name;

    extern fn gtk_buildable_get_type() usize;
    pub const getGObjectType = gtk_buildable_get_type;

    extern fn g_object_ref(p_self: *gtk.Buildable) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Buildable) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Buildable, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellAccessibleParent = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gtk.CellAccessibleParentIface;
    pub const virtual_methods = struct {
        pub const activate = struct {
            pub fn call(p_class: anytype, p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) void {
                return gobject.ext.as(CellAccessibleParent.Iface, p_class).f_activate.?(gobject.ext.as(CellAccessibleParent, p_parent), p_cell);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) callconv(.c) void) void {
                gobject.ext.as(CellAccessibleParent.Iface, p_class).f_activate = @ptrCast(p_implementation);
            }
        };

        pub const edit = struct {
            pub fn call(p_class: anytype, p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) void {
                return gobject.ext.as(CellAccessibleParent.Iface, p_class).f_edit.?(gobject.ext.as(CellAccessibleParent, p_parent), p_cell);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) callconv(.c) void) void {
                gobject.ext.as(CellAccessibleParent.Iface, p_class).f_edit = @ptrCast(p_implementation);
            }
        };

        pub const expand_collapse = struct {
            pub fn call(p_class: anytype, p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) void {
                return gobject.ext.as(CellAccessibleParent.Iface, p_class).f_expand_collapse.?(gobject.ext.as(CellAccessibleParent, p_parent), p_cell);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) callconv(.c) void) void {
                gobject.ext.as(CellAccessibleParent.Iface, p_class).f_expand_collapse = @ptrCast(p_implementation);
            }
        };

        pub const get_cell_area = struct {
            pub fn call(p_class: anytype, p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible, p_cell_rect: *gdk.Rectangle) void {
                return gobject.ext.as(CellAccessibleParent.Iface, p_class).f_get_cell_area.?(gobject.ext.as(CellAccessibleParent, p_parent), p_cell, p_cell_rect);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible, p_cell_rect: *gdk.Rectangle) callconv(.c) void) void {
                gobject.ext.as(CellAccessibleParent.Iface, p_class).f_get_cell_area = @ptrCast(p_implementation);
            }
        };

        pub const get_cell_extents = struct {
            pub fn call(p_class: anytype, p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible, p_x: *c_int, p_y: *c_int, p_width: *c_int, p_height: *c_int, p_coord_type: atk.CoordType) void {
                return gobject.ext.as(CellAccessibleParent.Iface, p_class).f_get_cell_extents.?(gobject.ext.as(CellAccessibleParent, p_parent), p_cell, p_x, p_y, p_width, p_height, p_coord_type);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible, p_x: *c_int, p_y: *c_int, p_width: *c_int, p_height: *c_int, p_coord_type: atk.CoordType) callconv(.c) void) void {
                gobject.ext.as(CellAccessibleParent.Iface, p_class).f_get_cell_extents = @ptrCast(p_implementation);
            }
        };

        pub const get_cell_position = struct {
            pub fn call(p_class: anytype, p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible, p_row: *c_int, p_column: *c_int) void {
                return gobject.ext.as(CellAccessibleParent.Iface, p_class).f_get_cell_position.?(gobject.ext.as(CellAccessibleParent, p_parent), p_cell, p_row, p_column);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible, p_row: *c_int, p_column: *c_int) callconv(.c) void) void {
                gobject.ext.as(CellAccessibleParent.Iface, p_class).f_get_cell_position = @ptrCast(p_implementation);
            }
        };

        pub const get_child_index = struct {
            pub fn call(p_class: anytype, p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) c_int {
                return gobject.ext.as(CellAccessibleParent.Iface, p_class).f_get_child_index.?(gobject.ext.as(CellAccessibleParent, p_parent), p_cell);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) callconv(.c) c_int) void {
                gobject.ext.as(CellAccessibleParent.Iface, p_class).f_get_child_index = @ptrCast(p_implementation);
            }
        };

        pub const get_column_header_cells = struct {
            pub fn call(p_class: anytype, p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) *glib.PtrArray {
                return gobject.ext.as(CellAccessibleParent.Iface, p_class).f_get_column_header_cells.?(gobject.ext.as(CellAccessibleParent, p_parent), p_cell);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) callconv(.c) *glib.PtrArray) void {
                gobject.ext.as(CellAccessibleParent.Iface, p_class).f_get_column_header_cells = @ptrCast(p_implementation);
            }
        };

        pub const get_renderer_state = struct {
            pub fn call(p_class: anytype, p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) gtk.CellRendererState {
                return gobject.ext.as(CellAccessibleParent.Iface, p_class).f_get_renderer_state.?(gobject.ext.as(CellAccessibleParent, p_parent), p_cell);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) callconv(.c) gtk.CellRendererState) void {
                gobject.ext.as(CellAccessibleParent.Iface, p_class).f_get_renderer_state = @ptrCast(p_implementation);
            }
        };

        pub const get_row_header_cells = struct {
            pub fn call(p_class: anytype, p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) *glib.PtrArray {
                return gobject.ext.as(CellAccessibleParent.Iface, p_class).f_get_row_header_cells.?(gobject.ext.as(CellAccessibleParent, p_parent), p_cell);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) callconv(.c) *glib.PtrArray) void {
                gobject.ext.as(CellAccessibleParent.Iface, p_class).f_get_row_header_cells = @ptrCast(p_implementation);
            }
        };

        pub const grab_focus = struct {
            pub fn call(p_class: anytype, p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) c_int {
                return gobject.ext.as(CellAccessibleParent.Iface, p_class).f_grab_focus.?(gobject.ext.as(CellAccessibleParent, p_parent), p_cell);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible) callconv(.c) c_int) void {
                gobject.ext.as(CellAccessibleParent.Iface, p_class).f_grab_focus = @ptrCast(p_implementation);
            }
        };

        pub const update_relationset = struct {
            pub fn call(p_class: anytype, p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible, p_relationset: *atk.RelationSet) void {
                return gobject.ext.as(CellAccessibleParent.Iface, p_class).f_update_relationset.?(gobject.ext.as(CellAccessibleParent, p_parent), p_cell, p_relationset);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellAccessible, p_relationset: *atk.RelationSet) callconv(.c) void) void {
                gobject.ext.as(CellAccessibleParent.Iface, p_class).f_update_relationset = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn gtk_cell_accessible_parent_activate(p_parent: *CellAccessibleParent, p_cell: *gtk.CellAccessible) void;
    pub const activate = gtk_cell_accessible_parent_activate;

    extern fn gtk_cell_accessible_parent_edit(p_parent: *CellAccessibleParent, p_cell: *gtk.CellAccessible) void;
    pub const edit = gtk_cell_accessible_parent_edit;

    extern fn gtk_cell_accessible_parent_expand_collapse(p_parent: *CellAccessibleParent, p_cell: *gtk.CellAccessible) void;
    pub const expandCollapse = gtk_cell_accessible_parent_expand_collapse;

    extern fn gtk_cell_accessible_parent_get_cell_area(p_parent: *CellAccessibleParent, p_cell: *gtk.CellAccessible, p_cell_rect: *gdk.Rectangle) void;
    pub const getCellArea = gtk_cell_accessible_parent_get_cell_area;

    extern fn gtk_cell_accessible_parent_get_cell_extents(p_parent: *CellAccessibleParent, p_cell: *gtk.CellAccessible, p_x: *c_int, p_y: *c_int, p_width: *c_int, p_height: *c_int, p_coord_type: atk.CoordType) void;
    pub const getCellExtents = gtk_cell_accessible_parent_get_cell_extents;

    extern fn gtk_cell_accessible_parent_get_cell_position(p_parent: *CellAccessibleParent, p_cell: *gtk.CellAccessible, p_row: *c_int, p_column: *c_int) void;
    pub const getCellPosition = gtk_cell_accessible_parent_get_cell_position;

    extern fn gtk_cell_accessible_parent_get_child_index(p_parent: *CellAccessibleParent, p_cell: *gtk.CellAccessible) c_int;
    pub const getChildIndex = gtk_cell_accessible_parent_get_child_index;

    extern fn gtk_cell_accessible_parent_get_column_header_cells(p_parent: *CellAccessibleParent, p_cell: *gtk.CellAccessible) *glib.PtrArray;
    pub const getColumnHeaderCells = gtk_cell_accessible_parent_get_column_header_cells;

    extern fn gtk_cell_accessible_parent_get_renderer_state(p_parent: *CellAccessibleParent, p_cell: *gtk.CellAccessible) gtk.CellRendererState;
    pub const getRendererState = gtk_cell_accessible_parent_get_renderer_state;

    extern fn gtk_cell_accessible_parent_get_row_header_cells(p_parent: *CellAccessibleParent, p_cell: *gtk.CellAccessible) *glib.PtrArray;
    pub const getRowHeaderCells = gtk_cell_accessible_parent_get_row_header_cells;

    extern fn gtk_cell_accessible_parent_grab_focus(p_parent: *CellAccessibleParent, p_cell: *gtk.CellAccessible) c_int;
    pub const grabFocus = gtk_cell_accessible_parent_grab_focus;

    extern fn gtk_cell_accessible_parent_update_relationset(p_parent: *CellAccessibleParent, p_cell: *gtk.CellAccessible, p_relationset: *atk.RelationSet) void;
    pub const updateRelationset = gtk_cell_accessible_parent_update_relationset;

    extern fn gtk_cell_accessible_parent_get_type() usize;
    pub const getGObjectType = gtk_cell_accessible_parent_get_type;

    extern fn g_object_ref(p_self: *gtk.CellAccessibleParent) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellAccessibleParent) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellAccessibleParent, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.CellEditable` interface must be implemented for widgets to be usable
/// to edit the contents of a `gtk.TreeView` cell. It provides a way to specify how
/// temporary widgets should be configured for editing, get the new value, etc.
pub const CellEditable = opaque {
    pub const Prerequisites = [_]type{gtk.Widget};
    pub const Iface = gtk.CellEditableIface;
    pub const virtual_methods = struct {
        /// Emits the `gtk.CellEditable.signals.editing`-done signal.
        pub const editing_done = struct {
            pub fn call(p_class: anytype, p_cell_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(CellEditable.Iface, p_class).f_editing_done.?(gobject.ext.as(CellEditable, p_cell_editable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(CellEditable.Iface, p_class).f_editing_done = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gtk.CellEditable.signals.remove`-widget signal.
        pub const remove_widget = struct {
            pub fn call(p_class: anytype, p_cell_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(CellEditable.Iface, p_class).f_remove_widget.?(gobject.ext.as(CellEditable, p_cell_editable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(CellEditable.Iface, p_class).f_remove_widget = @ptrCast(p_implementation);
            }
        };

        /// Begins editing on a `cell_editable`.
        ///
        /// The `gtk.CellRenderer` for the cell creates and returns a `gtk.CellEditable` from
        /// `gtk.CellRenderer.startEditing`, configured for the `gtk.CellRenderer` type.
        ///
        /// `gtk.CellEditable.startEditing` can then set up `cell_editable` suitably for
        /// editing a cell, e.g. making the Esc key emit `gtk.CellEditable.signals.editing`-done.
        ///
        /// Note that the `cell_editable` is created on-demand for the current edit; its
        /// lifetime is temporary and does not persist across other edits and/or cells.
        pub const start_editing = struct {
            pub fn call(p_class: anytype, p_cell_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: ?*gdk.Event) void {
                return gobject.ext.as(CellEditable.Iface, p_class).f_start_editing.?(gobject.ext.as(CellEditable, p_cell_editable), p_event);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: ?*gdk.Event) callconv(.c) void) void {
                gobject.ext.as(CellEditable.Iface, p_class).f_start_editing = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Indicates whether editing on the cell has been canceled.
        pub const editing_canceled = struct {
            pub const name = "editing-canceled";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// This signal is a sign for the cell renderer to update its
        /// value from the `cell_editable`.
        ///
        /// Implementations of `gtk.CellEditable` are responsible for
        /// emitting this signal when they are done editing, e.g.
        /// `gtk.Entry` emits this signal when the user presses Enter. Typical things to
        /// do in a handler for ::editing-done are to capture the edited value,
        /// disconnect the `cell_editable` from signals on the `gtk.CellRenderer`, etc.
        ///
        /// `gtk.CellEditable.editingDone` is a convenience method
        /// for emitting `gtk.CellEditable.signals.editing`-done.
        pub const editing_done = struct {
            pub const name = "editing-done";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(CellEditable, p_instance))),
                    gobject.signalLookup("editing-done", CellEditable.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is meant to indicate that the cell is finished
        /// editing, and the `cell_editable` widget is being removed and may
        /// subsequently be destroyed.
        ///
        /// Implementations of `gtk.CellEditable` are responsible for
        /// emitting this signal when they are done editing. It must
        /// be emitted after the `gtk.CellEditable.signals.editing`-done signal,
        /// to give the cell renderer a chance to update the cell's value
        /// before the widget is removed.
        ///
        /// `gtk.CellEditable.removeWidget` is a convenience method
        /// for emitting `gtk.CellEditable.signals.remove`-widget.
        pub const remove_widget = struct {
            pub const name = "remove-widget";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(CellEditable, p_instance))),
                    gobject.signalLookup("remove-widget", CellEditable.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Emits the `gtk.CellEditable.signals.editing`-done signal.
    extern fn gtk_cell_editable_editing_done(p_cell_editable: *CellEditable) void;
    pub const editingDone = gtk_cell_editable_editing_done;

    /// Emits the `gtk.CellEditable.signals.remove`-widget signal.
    extern fn gtk_cell_editable_remove_widget(p_cell_editable: *CellEditable) void;
    pub const removeWidget = gtk_cell_editable_remove_widget;

    /// Begins editing on a `cell_editable`.
    ///
    /// The `gtk.CellRenderer` for the cell creates and returns a `gtk.CellEditable` from
    /// `gtk.CellRenderer.startEditing`, configured for the `gtk.CellRenderer` type.
    ///
    /// `gtk.CellEditable.startEditing` can then set up `cell_editable` suitably for
    /// editing a cell, e.g. making the Esc key emit `gtk.CellEditable.signals.editing`-done.
    ///
    /// Note that the `cell_editable` is created on-demand for the current edit; its
    /// lifetime is temporary and does not persist across other edits and/or cells.
    extern fn gtk_cell_editable_start_editing(p_cell_editable: *CellEditable, p_event: ?*gdk.Event) void;
    pub const startEditing = gtk_cell_editable_start_editing;

    extern fn gtk_cell_editable_get_type() usize;
    pub const getGObjectType = gtk_cell_editable_get_type;

    extern fn g_object_ref(p_self: *gtk.CellEditable) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellEditable) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellEditable, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.CellLayout` is an interface to be implemented by all objects which
/// want to provide a `gtk.TreeViewColumn` like API for packing cells,
/// setting attributes and data funcs.
///
/// One of the notable features provided by implementations of
/// GtkCellLayout are attributes. Attributes let you set the properties
/// in flexible ways. They can just be set to constant values like regular
/// properties. But they can also be mapped to a column of the underlying
/// tree model with `gtk.CellLayout.setAttributes`, which means that the value
/// of the attribute can change from cell to cell as they are rendered by
/// the cell renderer. Finally, it is possible to specify a function with
/// `gtk.CellLayout.setCellDataFunc` that is called to determine the
/// value of the attribute for each cell that is rendered.
///
/// # GtkCellLayouts as GtkBuildable
///
/// Implementations of GtkCellLayout which also implement the GtkBuildable
/// interface (`gtk.CellView`, `gtk.IconView`, `gtk.ComboBox`,
/// `gtk.EntryCompletion`, `gtk.TreeViewColumn`) accept GtkCellRenderer objects
/// as `<child>` elements in UI definitions. They support a custom `<attributes>`
/// element for their children, which can contain multiple `<attribute>`
/// elements. Each `<attribute>` element has a name attribute which specifies
/// a property of the cell renderer; the content of the element is the
/// attribute value.
///
/// This is an example of a UI definition fragment specifying attributes:
///
/// ```
/// <object class="GtkCellView">
///   <child>
///     <object class="GtkCellRendererText"/>
///     <attributes>
///       <attribute name="text">0</attribute>
///     </attributes>
///   </child>
/// </object>
/// ```
///
/// Furthermore for implementations of GtkCellLayout that use a `gtk.CellArea`
/// to lay out cells (all GtkCellLayouts in GTK+ use a GtkCellArea)
/// [cell properties][cell-properties] can also be defined in the format by
/// specifying the custom `<cell-packing>` attribute which can contain multiple
/// `<property>` elements defined in the normal way.
///
/// Here is a UI definition fragment specifying cell properties:
///
/// ```
/// <object class="GtkTreeViewColumn">
///   <child>
///     <object class="GtkCellRendererText"/>
///     <cell-packing>
///       <property name="align">True</property>
///       <property name="expand">False</property>
///     </cell-packing>
///   </child>
/// </object>
/// ```
///
/// # Subclassing GtkCellLayout implementations
///
/// When subclassing a widget that implements `gtk.CellLayout` like
/// `gtk.IconView` or `gtk.ComboBox`, there are some considerations related
/// to the fact that these widgets internally use a `gtk.CellArea`.
/// The cell area is exposed as a construct-only property by these
/// widgets. This means that it is possible to e.g. do
///
/// ```
/// combo = g_object_new (GTK_TYPE_COMBO_BOX, "cell-area", my_cell_area, NULL);
/// ```
///
/// to use a custom cell area with a combo box. But construct properties
/// are only initialized after instance `init`
/// functions have run, which means that using functions which rely on
/// the existence of the cell area in your subclass’ `init` function will
/// cause the default cell area to be instantiated. In this case, a provided
/// construct property value will be ignored (with a warning, to alert
/// you to the problem).
///
/// ```
/// static void
/// my_combo_box_init (MyComboBox *b)
/// {
///   GtkCellRenderer *cell;
///
///   cell = gtk_cell_renderer_pixbuf_new ();
///   // The following call causes the default cell area for combo boxes,
///   // a GtkCellAreaBox, to be instantiated
///   gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (b), cell, FALSE);
///   ...
/// }
///
/// GtkWidget *
/// my_combo_box_new (GtkCellArea *area)
/// {
///   // This call is going to cause a warning about area being ignored
///   return g_object_new (MY_TYPE_COMBO_BOX, "cell-area", area, NULL);
/// }
/// ```
///
/// If supporting alternative cell areas with your derived widget is
/// not important, then this does not have to concern you. If you want
/// to support alternative cell areas, you can do so by moving the
/// problematic calls out of `init` and into a `constructor`
/// for your class.
pub const CellLayout = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gtk.CellLayoutIface;
    pub const virtual_methods = struct {
        /// Adds an attribute mapping to the list in `cell_layout`.
        ///
        /// The `column` is the column of the model to get a value from, and the
        /// `attribute` is the parameter on `cell` to be set from the value. So for
        /// example if column 2 of the model contains strings, you could have the
        /// “text” attribute of a `gtk.CellRendererText` get its values from column 2.
        pub const add_attribute = struct {
            pub fn call(p_class: anytype, p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellRenderer, p_attribute: [*:0]const u8, p_column: c_int) void {
                return gobject.ext.as(CellLayout.Iface, p_class).f_add_attribute.?(gobject.ext.as(CellLayout, p_cell_layout), p_cell, p_attribute, p_column);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellRenderer, p_attribute: [*:0]const u8, p_column: c_int) callconv(.c) void) void {
                gobject.ext.as(CellLayout.Iface, p_class).f_add_attribute = @ptrCast(p_implementation);
            }
        };

        /// Unsets all the mappings on all renderers on `cell_layout` and
        /// removes all renderers from `cell_layout`.
        pub const clear = struct {
            pub fn call(p_class: anytype, p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(CellLayout.Iface, p_class).f_clear.?(gobject.ext.as(CellLayout, p_cell_layout));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(CellLayout.Iface, p_class).f_clear = @ptrCast(p_implementation);
            }
        };

        /// Clears all existing attributes previously set with
        /// `gtk.CellLayout.setAttributes`.
        pub const clear_attributes = struct {
            pub fn call(p_class: anytype, p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellRenderer) void {
                return gobject.ext.as(CellLayout.Iface, p_class).f_clear_attributes.?(gobject.ext.as(CellLayout, p_cell_layout), p_cell);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellRenderer) callconv(.c) void) void {
                gobject.ext.as(CellLayout.Iface, p_class).f_clear_attributes = @ptrCast(p_implementation);
            }
        };

        /// Returns the underlying `gtk.CellArea` which might be `cell_layout`
        /// if called on a `gtk.CellArea` or might be `NULL` if no `gtk.CellArea`
        /// is used by `cell_layout`.
        pub const get_area = struct {
            pub fn call(p_class: anytype, p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*gtk.CellArea {
                return gobject.ext.as(CellLayout.Iface, p_class).f_get_area.?(gobject.ext.as(CellLayout, p_cell_layout));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*gtk.CellArea) void {
                gobject.ext.as(CellLayout.Iface, p_class).f_get_area = @ptrCast(p_implementation);
            }
        };

        /// Returns the cell renderers which have been added to `cell_layout`.
        pub const get_cells = struct {
            pub fn call(p_class: anytype, p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *glib.List {
                return gobject.ext.as(CellLayout.Iface, p_class).f_get_cells.?(gobject.ext.as(CellLayout, p_cell_layout));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *glib.List) void {
                gobject.ext.as(CellLayout.Iface, p_class).f_get_cells = @ptrCast(p_implementation);
            }
        };

        /// Adds the `cell` to the end of `cell_layout`. If `expand` is `FALSE`, then the
        /// `cell` is allocated no more space than it needs. Any unused space is
        /// divided evenly between cells for which `expand` is `TRUE`.
        ///
        /// Note that reusing the same cell renderer is not supported.
        pub const pack_end = struct {
            pub fn call(p_class: anytype, p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellRenderer, p_expand: c_int) void {
                return gobject.ext.as(CellLayout.Iface, p_class).f_pack_end.?(gobject.ext.as(CellLayout, p_cell_layout), p_cell, p_expand);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellRenderer, p_expand: c_int) callconv(.c) void) void {
                gobject.ext.as(CellLayout.Iface, p_class).f_pack_end = @ptrCast(p_implementation);
            }
        };

        /// Packs the `cell` into the beginning of `cell_layout`. If `expand` is `FALSE`,
        /// then the `cell` is allocated no more space than it needs. Any unused space
        /// is divided evenly between cells for which `expand` is `TRUE`.
        ///
        /// Note that reusing the same cell renderer is not supported.
        pub const pack_start = struct {
            pub fn call(p_class: anytype, p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellRenderer, p_expand: c_int) void {
                return gobject.ext.as(CellLayout.Iface, p_class).f_pack_start.?(gobject.ext.as(CellLayout, p_cell_layout), p_cell, p_expand);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellRenderer, p_expand: c_int) callconv(.c) void) void {
                gobject.ext.as(CellLayout.Iface, p_class).f_pack_start = @ptrCast(p_implementation);
            }
        };

        /// Re-inserts `cell` at `position`.
        ///
        /// Note that `cell` has already to be packed into `cell_layout`
        /// for this to function properly.
        pub const reorder = struct {
            pub fn call(p_class: anytype, p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellRenderer, p_position: c_int) void {
                return gobject.ext.as(CellLayout.Iface, p_class).f_reorder.?(gobject.ext.as(CellLayout, p_cell_layout), p_cell, p_position);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellRenderer, p_position: c_int) callconv(.c) void) void {
                gobject.ext.as(CellLayout.Iface, p_class).f_reorder = @ptrCast(p_implementation);
            }
        };

        /// Sets the `gtk.CellLayoutDataFunc` to use for `cell_layout`.
        ///
        /// This function is used instead of the standard attributes mapping
        /// for setting the column value, and should set the value of `cell_layout`’s
        /// cell renderer(s) as appropriate.
        ///
        /// `func` may be `NULL` to remove a previously set function.
        pub const set_cell_data_func = struct {
            pub fn call(p_class: anytype, p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellRenderer, p_func: ?gtk.CellLayoutDataFunc, p_func_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void {
                return gobject.ext.as(CellLayout.Iface, p_class).f_set_cell_data_func.?(gobject.ext.as(CellLayout, p_cell_layout), p_cell, p_func, p_func_data, p_destroy);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cell_layout: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cell: *gtk.CellRenderer, p_func: ?gtk.CellLayoutDataFunc, p_func_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) callconv(.c) void) void {
                gobject.ext.as(CellLayout.Iface, p_class).f_set_cell_data_func = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Adds an attribute mapping to the list in `cell_layout`.
    ///
    /// The `column` is the column of the model to get a value from, and the
    /// `attribute` is the parameter on `cell` to be set from the value. So for
    /// example if column 2 of the model contains strings, you could have the
    /// “text” attribute of a `gtk.CellRendererText` get its values from column 2.
    extern fn gtk_cell_layout_add_attribute(p_cell_layout: *CellLayout, p_cell: *gtk.CellRenderer, p_attribute: [*:0]const u8, p_column: c_int) void;
    pub const addAttribute = gtk_cell_layout_add_attribute;

    /// Unsets all the mappings on all renderers on `cell_layout` and
    /// removes all renderers from `cell_layout`.
    extern fn gtk_cell_layout_clear(p_cell_layout: *CellLayout) void;
    pub const clear = gtk_cell_layout_clear;

    /// Clears all existing attributes previously set with
    /// `gtk.CellLayout.setAttributes`.
    extern fn gtk_cell_layout_clear_attributes(p_cell_layout: *CellLayout, p_cell: *gtk.CellRenderer) void;
    pub const clearAttributes = gtk_cell_layout_clear_attributes;

    /// Returns the underlying `gtk.CellArea` which might be `cell_layout`
    /// if called on a `gtk.CellArea` or might be `NULL` if no `gtk.CellArea`
    /// is used by `cell_layout`.
    extern fn gtk_cell_layout_get_area(p_cell_layout: *CellLayout) ?*gtk.CellArea;
    pub const getArea = gtk_cell_layout_get_area;

    /// Returns the cell renderers which have been added to `cell_layout`.
    extern fn gtk_cell_layout_get_cells(p_cell_layout: *CellLayout) *glib.List;
    pub const getCells = gtk_cell_layout_get_cells;

    /// Adds the `cell` to the end of `cell_layout`. If `expand` is `FALSE`, then the
    /// `cell` is allocated no more space than it needs. Any unused space is
    /// divided evenly between cells for which `expand` is `TRUE`.
    ///
    /// Note that reusing the same cell renderer is not supported.
    extern fn gtk_cell_layout_pack_end(p_cell_layout: *CellLayout, p_cell: *gtk.CellRenderer, p_expand: c_int) void;
    pub const packEnd = gtk_cell_layout_pack_end;

    /// Packs the `cell` into the beginning of `cell_layout`. If `expand` is `FALSE`,
    /// then the `cell` is allocated no more space than it needs. Any unused space
    /// is divided evenly between cells for which `expand` is `TRUE`.
    ///
    /// Note that reusing the same cell renderer is not supported.
    extern fn gtk_cell_layout_pack_start(p_cell_layout: *CellLayout, p_cell: *gtk.CellRenderer, p_expand: c_int) void;
    pub const packStart = gtk_cell_layout_pack_start;

    /// Re-inserts `cell` at `position`.
    ///
    /// Note that `cell` has already to be packed into `cell_layout`
    /// for this to function properly.
    extern fn gtk_cell_layout_reorder(p_cell_layout: *CellLayout, p_cell: *gtk.CellRenderer, p_position: c_int) void;
    pub const reorder = gtk_cell_layout_reorder;

    /// Sets the attributes in list as the attributes of `cell_layout`.
    ///
    /// The attributes should be in attribute/column order, as in
    /// `gtk.CellLayout.addAttribute`. All existing attributes are
    /// removed, and replaced with the new attributes.
    extern fn gtk_cell_layout_set_attributes(p_cell_layout: *CellLayout, p_cell: *gtk.CellRenderer, ...) void;
    pub const setAttributes = gtk_cell_layout_set_attributes;

    /// Sets the `gtk.CellLayoutDataFunc` to use for `cell_layout`.
    ///
    /// This function is used instead of the standard attributes mapping
    /// for setting the column value, and should set the value of `cell_layout`’s
    /// cell renderer(s) as appropriate.
    ///
    /// `func` may be `NULL` to remove a previously set function.
    extern fn gtk_cell_layout_set_cell_data_func(p_cell_layout: *CellLayout, p_cell: *gtk.CellRenderer, p_func: ?gtk.CellLayoutDataFunc, p_func_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setCellDataFunc = gtk_cell_layout_set_cell_data_func;

    extern fn gtk_cell_layout_get_type() usize;
    pub const getGObjectType = gtk_cell_layout_get_type;

    extern fn g_object_ref(p_self: *gtk.CellLayout) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.CellLayout) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CellLayout, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.ColorChooser` is an interface that is implemented by widgets
/// for choosing colors. Depending on the situation, colors may be
/// allowed to have alpha (translucency).
///
/// In GTK+, the main widgets that implement this interface are
/// `gtk.ColorChooserWidget`, `gtk.ColorChooserDialog` and `gtk.ColorButton`.
pub const ColorChooser = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gtk.ColorChooserInterface;
    pub const virtual_methods = struct {
        /// Adds a palette to the color chooser. If `orientation` is horizontal,
        /// the colors are grouped in rows, with `colors_per_line` colors
        /// in each row. If `horizontal` is `FALSE`, the colors are grouped
        /// in columns instead.
        ///
        /// The default color palette of `gtk.ColorChooserWidget` has
        /// 27 colors, organized in columns of 3 colors. The default gray
        /// palette has 9 grays in a single row.
        ///
        /// The layout of the color chooser widget works best when the
        /// palettes have 9-10 columns.
        ///
        /// Calling this function for the first time has the
        /// side effect of removing the default color and gray palettes
        /// from the color chooser.
        ///
        /// If `colors` is `NULL`, removes all previously added palettes.
        pub const add_palette = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_orientation: gtk.Orientation, p_colors_per_line: c_int, p_n_colors: c_int, p_colors: ?[*]gdk.RGBA) void {
                return gobject.ext.as(ColorChooser.Iface, p_class).f_add_palette.?(gobject.ext.as(ColorChooser, p_chooser), p_orientation, p_colors_per_line, p_n_colors, p_colors);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_orientation: gtk.Orientation, p_colors_per_line: c_int, p_n_colors: c_int, p_colors: ?[*]gdk.RGBA) callconv(.c) void) void {
                gobject.ext.as(ColorChooser.Iface, p_class).f_add_palette = @ptrCast(p_implementation);
            }
        };

        pub const color_activated = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_color: *const gdk.RGBA) void {
                return gobject.ext.as(ColorChooser.Iface, p_class).f_color_activated.?(gobject.ext.as(ColorChooser, p_chooser), p_color);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_color: *const gdk.RGBA) callconv(.c) void) void {
                gobject.ext.as(ColorChooser.Iface, p_class).f_color_activated = @ptrCast(p_implementation);
            }
        };

        /// Gets the currently-selected color.
        pub const get_rgba = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_color: *gdk.RGBA) void {
                return gobject.ext.as(ColorChooser.Iface, p_class).f_get_rgba.?(gobject.ext.as(ColorChooser, p_chooser), p_color);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_color: *gdk.RGBA) callconv(.c) void) void {
                gobject.ext.as(ColorChooser.Iface, p_class).f_get_rgba = @ptrCast(p_implementation);
            }
        };

        /// Sets the color.
        pub const set_rgba = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_color: *const gdk.RGBA) void {
                return gobject.ext.as(ColorChooser.Iface, p_class).f_set_rgba.?(gobject.ext.as(ColorChooser, p_chooser), p_color);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_color: *const gdk.RGBA) callconv(.c) void) void {
                gobject.ext.as(ColorChooser.Iface, p_class).f_set_rgba = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The ::rgba property contains the currently selected color,
        /// as a `gdk.RGBA` struct. The property can be set to change
        /// the current selection programmatically.
        pub const rgba = struct {
            pub const name = "rgba";

            pub const Type = ?*gdk.RGBA;
        };

        /// When ::use-alpha is `TRUE`, colors may have alpha (translucency)
        /// information. When it is `FALSE`, the `gdk.RGBA` struct obtained
        /// via the `gtk.ColorChooser.properties.rgba` property will be forced to have
        /// alpha == 1.
        ///
        /// Implementations are expected to show alpha by rendering the color
        /// over a non-uniform background (like a checkerboard pattern).
        pub const use_alpha = struct {
            pub const name = "use-alpha";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted when a color is activated from the color chooser.
        /// This usually happens when the user clicks a color swatch,
        /// or a color is selected and the user presses one of the keys
        /// Space, Shift+Space, Return or Enter.
        pub const color_activated = struct {
            pub const name = "color-activated";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_color: *gdk.RGBA, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ColorChooser, p_instance))),
                    gobject.signalLookup("color-activated", ColorChooser.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Adds a palette to the color chooser. If `orientation` is horizontal,
    /// the colors are grouped in rows, with `colors_per_line` colors
    /// in each row. If `horizontal` is `FALSE`, the colors are grouped
    /// in columns instead.
    ///
    /// The default color palette of `gtk.ColorChooserWidget` has
    /// 27 colors, organized in columns of 3 colors. The default gray
    /// palette has 9 grays in a single row.
    ///
    /// The layout of the color chooser widget works best when the
    /// palettes have 9-10 columns.
    ///
    /// Calling this function for the first time has the
    /// side effect of removing the default color and gray palettes
    /// from the color chooser.
    ///
    /// If `colors` is `NULL`, removes all previously added palettes.
    extern fn gtk_color_chooser_add_palette(p_chooser: *ColorChooser, p_orientation: gtk.Orientation, p_colors_per_line: c_int, p_n_colors: c_int, p_colors: ?[*]gdk.RGBA) void;
    pub const addPalette = gtk_color_chooser_add_palette;

    /// Gets the currently-selected color.
    extern fn gtk_color_chooser_get_rgba(p_chooser: *ColorChooser, p_color: *gdk.RGBA) void;
    pub const getRgba = gtk_color_chooser_get_rgba;

    /// Returns whether the color chooser shows the alpha channel.
    extern fn gtk_color_chooser_get_use_alpha(p_chooser: *ColorChooser) c_int;
    pub const getUseAlpha = gtk_color_chooser_get_use_alpha;

    /// Sets the color.
    extern fn gtk_color_chooser_set_rgba(p_chooser: *ColorChooser, p_color: *const gdk.RGBA) void;
    pub const setRgba = gtk_color_chooser_set_rgba;

    /// Sets whether or not the color chooser should use the alpha channel.
    extern fn gtk_color_chooser_set_use_alpha(p_chooser: *ColorChooser, p_use_alpha: c_int) void;
    pub const setUseAlpha = gtk_color_chooser_set_use_alpha;

    extern fn gtk_color_chooser_get_type() usize;
    pub const getGObjectType = gtk_color_chooser_get_type;

    extern fn g_object_ref(p_self: *gtk.ColorChooser) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ColorChooser) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ColorChooser, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Editable` interface is an interface which should be implemented by
/// text editing widgets, such as `gtk.Entry` and `gtk.SpinButton`. It contains functions
/// for generically manipulating an editable widget, a large number of action
/// signals used for key bindings, and several signals that an application can
/// connect to to modify the behavior of a widget.
///
/// As an example of the latter usage, by connecting
/// the following handler to `gtk.Editable.signals.insert`-text, an application
/// can convert all entry into a widget into uppercase.
///
/// ## Forcing entry to uppercase.
///
/// ```
/// `include` <ctype.h>;
///
/// void
/// insert_text_handler (GtkEditable *editable,
///                      const gchar *text,
///                      gint         length,
///                      gint        *position,
///                      gpointer     data)
/// {
///   gchar *result = g_utf8_strup (text, length);
///
///   g_signal_handlers_block_by_func (editable,
///                                (gpointer) insert_text_handler, data);
///   gtk_editable_insert_text (editable, result, length, position);
///   g_signal_handlers_unblock_by_func (editable,
///                                      (gpointer) insert_text_handler, data);
///
///   g_signal_stop_emission_by_name (editable, "insert_text");
///
///   g_free (result);
/// }
/// ```
pub const Editable = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gtk.EditableInterface;
    pub const virtual_methods = struct {
        pub const changed = struct {
            pub fn call(p_class: anytype, p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Editable.Iface, p_class).f_changed.?(gobject.ext.as(Editable, p_editable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Editable.Iface, p_class).f_changed = @ptrCast(p_implementation);
            }
        };

        /// Deletes a sequence of characters. The characters that are deleted are
        /// those characters at positions from `start_pos` up to, but not including
        /// `end_pos`. If `end_pos` is negative, then the characters deleted
        /// are those from `start_pos` to the end of the text.
        ///
        /// Note that the positions are specified in characters, not bytes.
        pub const delete_text = struct {
            pub fn call(p_class: anytype, p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_start_pos: c_int, p_end_pos: c_int) void {
                return gobject.ext.as(Editable.Iface, p_class).f_delete_text.?(gobject.ext.as(Editable, p_editable), p_start_pos, p_end_pos);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_start_pos: c_int, p_end_pos: c_int) callconv(.c) void) void {
                gobject.ext.as(Editable.Iface, p_class).f_delete_text = @ptrCast(p_implementation);
            }
        };

        /// Deletes a sequence of characters. The characters that are deleted are
        /// those characters at positions from `start_pos` up to, but not including
        /// `end_pos`. If `end_pos` is negative, then the characters deleted
        /// are those from `start_pos` to the end of the text.
        ///
        /// Note that the positions are specified in characters, not bytes.
        pub const do_delete_text = struct {
            pub fn call(p_class: anytype, p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_start_pos: c_int, p_end_pos: c_int) void {
                return gobject.ext.as(Editable.Iface, p_class).f_do_delete_text.?(gobject.ext.as(Editable, p_editable), p_start_pos, p_end_pos);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_start_pos: c_int, p_end_pos: c_int) callconv(.c) void) void {
                gobject.ext.as(Editable.Iface, p_class).f_do_delete_text = @ptrCast(p_implementation);
            }
        };

        /// Inserts `new_text_length` bytes of `new_text` into the contents of the
        /// widget, at position `position`.
        ///
        /// Note that the position is in characters, not in bytes.
        /// The function updates `position` to point after the newly inserted text.
        pub const do_insert_text = struct {
            pub fn call(p_class: anytype, p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_new_text: [*:0]const u8, p_new_text_length: c_int, p_position: *c_int) void {
                return gobject.ext.as(Editable.Iface, p_class).f_do_insert_text.?(gobject.ext.as(Editable, p_editable), p_new_text, p_new_text_length, p_position);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_new_text: [*:0]const u8, p_new_text_length: c_int, p_position: *c_int) callconv(.c) void) void {
                gobject.ext.as(Editable.Iface, p_class).f_do_insert_text = @ptrCast(p_implementation);
            }
        };

        /// Retrieves a sequence of characters. The characters that are retrieved
        /// are those characters at positions from `start_pos` up to, but not
        /// including `end_pos`. If `end_pos` is negative, then the characters
        /// retrieved are those characters from `start_pos` to the end of the text.
        ///
        /// Note that positions are specified in characters, not bytes.
        pub const get_chars = struct {
            pub fn call(p_class: anytype, p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_start_pos: c_int, p_end_pos: c_int) [*:0]u8 {
                return gobject.ext.as(Editable.Iface, p_class).f_get_chars.?(gobject.ext.as(Editable, p_editable), p_start_pos, p_end_pos);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_start_pos: c_int, p_end_pos: c_int) callconv(.c) [*:0]u8) void {
                gobject.ext.as(Editable.Iface, p_class).f_get_chars = @ptrCast(p_implementation);
            }
        };

        /// Retrieves the current position of the cursor relative to the start
        /// of the content of the editable.
        ///
        /// Note that this position is in characters, not in bytes.
        pub const get_position = struct {
            pub fn call(p_class: anytype, p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Editable.Iface, p_class).f_get_position.?(gobject.ext.as(Editable, p_editable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Editable.Iface, p_class).f_get_position = @ptrCast(p_implementation);
            }
        };

        /// Retrieves the selection bound of the editable. start_pos will be filled
        /// with the start of the selection and `end_pos` with end. If no text was
        /// selected both will be identical and `FALSE` will be returned.
        ///
        /// Note that positions are specified in characters, not bytes.
        pub const get_selection_bounds = struct {
            pub fn call(p_class: anytype, p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_start_pos: ?*c_int, p_end_pos: ?*c_int) c_int {
                return gobject.ext.as(Editable.Iface, p_class).f_get_selection_bounds.?(gobject.ext.as(Editable, p_editable), p_start_pos, p_end_pos);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_start_pos: ?*c_int, p_end_pos: ?*c_int) callconv(.c) c_int) void {
                gobject.ext.as(Editable.Iface, p_class).f_get_selection_bounds = @ptrCast(p_implementation);
            }
        };

        /// Inserts `new_text_length` bytes of `new_text` into the contents of the
        /// widget, at position `position`.
        ///
        /// Note that the position is in characters, not in bytes.
        /// The function updates `position` to point after the newly inserted text.
        pub const insert_text = struct {
            pub fn call(p_class: anytype, p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_new_text: [*:0]const u8, p_new_text_length: c_int, p_position: *c_int) void {
                return gobject.ext.as(Editable.Iface, p_class).f_insert_text.?(gobject.ext.as(Editable, p_editable), p_new_text, p_new_text_length, p_position);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_new_text: [*:0]const u8, p_new_text_length: c_int, p_position: *c_int) callconv(.c) void) void {
                gobject.ext.as(Editable.Iface, p_class).f_insert_text = @ptrCast(p_implementation);
            }
        };

        /// Sets the cursor position in the editable to the given value.
        ///
        /// The cursor is displayed before the character with the given (base 0)
        /// index in the contents of the editable. The value must be less than or
        /// equal to the number of characters in the editable. A value of -1
        /// indicates that the position should be set after the last character
        /// of the editable. Note that `position` is in characters, not in bytes.
        pub const set_position = struct {
            pub fn call(p_class: anytype, p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_position: c_int) void {
                return gobject.ext.as(Editable.Iface, p_class).f_set_position.?(gobject.ext.as(Editable, p_editable), p_position);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_position: c_int) callconv(.c) void) void {
                gobject.ext.as(Editable.Iface, p_class).f_set_position = @ptrCast(p_implementation);
            }
        };

        /// Selects a region of text. The characters that are selected are
        /// those characters at positions from `start_pos` up to, but not
        /// including `end_pos`. If `end_pos` is negative, then the
        /// characters selected are those characters from `start_pos` to
        /// the end of the text.
        ///
        /// Note that positions are specified in characters, not bytes.
        pub const set_selection_bounds = struct {
            pub fn call(p_class: anytype, p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_start_pos: c_int, p_end_pos: c_int) void {
                return gobject.ext.as(Editable.Iface, p_class).f_set_selection_bounds.?(gobject.ext.as(Editable, p_editable), p_start_pos, p_end_pos);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_editable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_start_pos: c_int, p_end_pos: c_int) callconv(.c) void) void {
                gobject.ext.as(Editable.Iface, p_class).f_set_selection_bounds = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// The ::changed signal is emitted at the end of a single
        /// user-visible operation on the contents of the `gtk.Editable`.
        ///
        /// E.g., a paste operation that replaces the contents of the
        /// selection will cause only one signal emission (even though it
        /// is implemented by first deleting the selection, then inserting
        /// the new content, and may cause multiple ::notify::text signals
        /// to be emitted).
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Editable, p_instance))),
                    gobject.signalLookup("changed", Editable.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when text is deleted from
        /// the widget by the user. The default handler for
        /// this signal will normally be responsible for deleting
        /// the text, so by connecting to this signal and then
        /// stopping the signal with `gobject.signalStopEmission`, it
        /// is possible to modify the range of deleted text, or
        /// prevent it from being deleted entirely. The `start_pos`
        /// and `end_pos` parameters are interpreted as for
        /// `gtk.Editable.deleteText`.
        pub const delete_text = struct {
            pub const name = "delete-text";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_start_pos: c_int, p_end_pos: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Editable, p_instance))),
                    gobject.signalLookup("delete-text", Editable.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when text is inserted into
        /// the widget by the user. The default handler for
        /// this signal will normally be responsible for inserting
        /// the text, so by connecting to this signal and then
        /// stopping the signal with `gobject.signalStopEmission`, it
        /// is possible to modify the inserted text, or prevent
        /// it from being inserted entirely.
        pub const insert_text = struct {
            pub const name = "insert-text";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_new_text: [*:0]u8, p_new_text_length: c_int, p_position: *c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Editable, p_instance))),
                    gobject.signalLookup("insert-text", Editable.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Copies the contents of the currently selected content in the editable and
    /// puts it on the clipboard.
    extern fn gtk_editable_copy_clipboard(p_editable: *Editable) void;
    pub const copyClipboard = gtk_editable_copy_clipboard;

    /// Removes the contents of the currently selected content in the editable and
    /// puts it on the clipboard.
    extern fn gtk_editable_cut_clipboard(p_editable: *Editable) void;
    pub const cutClipboard = gtk_editable_cut_clipboard;

    /// Deletes the currently selected text of the editable.
    /// This call doesn’t do anything if there is no selected text.
    extern fn gtk_editable_delete_selection(p_editable: *Editable) void;
    pub const deleteSelection = gtk_editable_delete_selection;

    /// Deletes a sequence of characters. The characters that are deleted are
    /// those characters at positions from `start_pos` up to, but not including
    /// `end_pos`. If `end_pos` is negative, then the characters deleted
    /// are those from `start_pos` to the end of the text.
    ///
    /// Note that the positions are specified in characters, not bytes.
    extern fn gtk_editable_delete_text(p_editable: *Editable, p_start_pos: c_int, p_end_pos: c_int) void;
    pub const deleteText = gtk_editable_delete_text;

    /// Retrieves a sequence of characters. The characters that are retrieved
    /// are those characters at positions from `start_pos` up to, but not
    /// including `end_pos`. If `end_pos` is negative, then the characters
    /// retrieved are those characters from `start_pos` to the end of the text.
    ///
    /// Note that positions are specified in characters, not bytes.
    extern fn gtk_editable_get_chars(p_editable: *Editable, p_start_pos: c_int, p_end_pos: c_int) [*:0]u8;
    pub const getChars = gtk_editable_get_chars;

    /// Retrieves whether `editable` is editable. See
    /// `gtk.Editable.setEditable`.
    extern fn gtk_editable_get_editable(p_editable: *Editable) c_int;
    pub const getEditable = gtk_editable_get_editable;

    /// Retrieves the current position of the cursor relative to the start
    /// of the content of the editable.
    ///
    /// Note that this position is in characters, not in bytes.
    extern fn gtk_editable_get_position(p_editable: *Editable) c_int;
    pub const getPosition = gtk_editable_get_position;

    /// Retrieves the selection bound of the editable. start_pos will be filled
    /// with the start of the selection and `end_pos` with end. If no text was
    /// selected both will be identical and `FALSE` will be returned.
    ///
    /// Note that positions are specified in characters, not bytes.
    extern fn gtk_editable_get_selection_bounds(p_editable: *Editable, p_start_pos: ?*c_int, p_end_pos: ?*c_int) c_int;
    pub const getSelectionBounds = gtk_editable_get_selection_bounds;

    /// Inserts `new_text_length` bytes of `new_text` into the contents of the
    /// widget, at position `position`.
    ///
    /// Note that the position is in characters, not in bytes.
    /// The function updates `position` to point after the newly inserted text.
    extern fn gtk_editable_insert_text(p_editable: *Editable, p_new_text: [*:0]const u8, p_new_text_length: c_int, p_position: *c_int) void;
    pub const insertText = gtk_editable_insert_text;

    /// Pastes the content of the clipboard to the current position of the
    /// cursor in the editable.
    extern fn gtk_editable_paste_clipboard(p_editable: *Editable) void;
    pub const pasteClipboard = gtk_editable_paste_clipboard;

    /// Selects a region of text. The characters that are selected are
    /// those characters at positions from `start_pos` up to, but not
    /// including `end_pos`. If `end_pos` is negative, then the
    /// characters selected are those characters from `start_pos` to
    /// the end of the text.
    ///
    /// Note that positions are specified in characters, not bytes.
    extern fn gtk_editable_select_region(p_editable: *Editable, p_start_pos: c_int, p_end_pos: c_int) void;
    pub const selectRegion = gtk_editable_select_region;

    /// Determines if the user can edit the text in the editable
    /// widget or not.
    extern fn gtk_editable_set_editable(p_editable: *Editable, p_is_editable: c_int) void;
    pub const setEditable = gtk_editable_set_editable;

    /// Sets the cursor position in the editable to the given value.
    ///
    /// The cursor is displayed before the character with the given (base 0)
    /// index in the contents of the editable. The value must be less than or
    /// equal to the number of characters in the editable. A value of -1
    /// indicates that the position should be set after the last character
    /// of the editable. Note that `position` is in characters, not in bytes.
    extern fn gtk_editable_set_position(p_editable: *Editable, p_position: c_int) void;
    pub const setPosition = gtk_editable_set_position;

    extern fn gtk_editable_get_type() usize;
    pub const getGObjectType = gtk_editable_get_type;

    extern fn g_object_ref(p_self: *gtk.Editable) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Editable) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Editable, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.FileChooser` is an interface that can be implemented by file
/// selection widgets.  In GTK+, the main objects that implement this
/// interface are `gtk.FileChooserWidget`, `gtk.FileChooserDialog`, and
/// `gtk.FileChooserButton`.  You do not need to write an object that
/// implements the `gtk.FileChooser` interface unless you are trying to
/// adapt an existing file selector to expose a standard programming
/// interface.
///
/// `gtk.FileChooser` allows for shortcuts to various places in the filesystem.
/// In the default implementation these are displayed in the left pane. It
/// may be a bit confusing at first that these shortcuts come from various
/// sources and in various flavours, so lets explain the terminology here:
///
/// - Bookmarks: are created by the user, by dragging folders from the
///   right pane to the left pane, or by using the “Add”. Bookmarks
///   can be renamed and deleted by the user.
///
/// - Shortcuts: can be provided by the application. For example, a Paint
///   program may want to add a shortcut for a Clipart folder. Shortcuts
///   cannot be modified by the user.
///
/// - Volumes: are provided by the underlying filesystem abstraction. They are
///   the “roots” of the filesystem.
///
/// # File Names and Encodings
///
/// When the user is finished selecting files in a
/// `gtk.FileChooser`, your program can get the selected names
/// either as filenames or as URIs.  For URIs, the normal escaping
/// rules are applied if the URI contains non-ASCII characters.
/// However, filenames are always returned in
/// the character set specified by the
/// `G_FILENAME_ENCODING` environment variable.
/// Please see the GLib documentation for more details about this
/// variable.
///
/// This means that while you can pass the result of
/// `gtk.FileChooser.getFilename` to `glib.open` or `glib.fopen`,
/// you may not be able to directly set it as the text of a
/// `gtk.Label` widget unless you convert it first to UTF-8,
/// which all GTK+ widgets expect. You should use `glib.filenameToUtf8`
/// to convert filenames into strings that can be passed to GTK+
/// widgets.
///
/// # Adding a Preview Widget
///
/// You can add a custom preview widget to a file chooser and then
/// get notification about when the preview needs to be updated.
/// To install a preview widget, use
/// `gtk.FileChooser.setPreviewWidget`.  Then, connect to the
/// `gtk.FileChooser.signals.update`-preview signal to get notified when
/// you need to update the contents of the preview.
///
/// Your callback should use
/// `gtk.FileChooser.getPreviewFilename` to see what needs
/// previewing.  Once you have generated the preview for the
/// corresponding file, you must call
/// `gtk.FileChooser.setPreviewWidgetActive` with a boolean
/// flag that indicates whether your callback could successfully
/// generate a preview.
///
/// ## Example: Using a Preview Widget
/// ```
/// {
///   GtkImage *preview;
///
///   ...
///
///   preview = gtk_image_new ();
///
///   gtk_file_chooser_set_preview_widget (my_file_chooser, preview);
///   g_signal_connect (my_file_chooser, "update-preview",
///             G_CALLBACK (update_preview_cb), preview);
/// }
///
/// static void
/// update_preview_cb (GtkFileChooser *file_chooser, gpointer data)
/// {
///   GtkWidget *preview;
///   char *filename;
///   GdkPixbuf *pixbuf;
///   gboolean have_preview;
///
///   preview = GTK_WIDGET (data);
///   filename = gtk_file_chooser_get_preview_filename (file_chooser);
///
///   pixbuf = gdk_pixbuf_new_from_file_at_size (filename, 128, 128, NULL);
///   have_preview = (pixbuf != NULL);
///   g_free (filename);
///
///   gtk_image_set_from_pixbuf (GTK_IMAGE (preview), pixbuf);
///   if (pixbuf)
///     g_object_unref (pixbuf);
///
///   gtk_file_chooser_set_preview_widget_active (file_chooser, have_preview);
/// }
/// ```
///
/// # Adding Extra Widgets
///
/// You can add extra widgets to a file chooser to provide options
/// that are not present in the default design.  For example, you
/// can add a toggle button to give the user the option to open a
/// file in read-only mode.  You can use
/// `gtk.FileChooser.setExtraWidget` to insert additional
/// widgets in a file chooser.
///
/// An example for adding extra widgets:
/// ```
///
///   GtkWidget *toggle;
///
///   ...
///
///   toggle = gtk_check_button_new_with_label ("Open file read-only");
///   gtk_widget_show (toggle);
///   gtk_file_chooser_set_extra_widget (my_file_chooser, toggle);
/// }
/// ```
///
/// If you want to set more than one extra widget in the file
/// chooser, you can a container such as a `gtk.Box` or a `gtk.Grid`
/// and include your widgets in it.  Then, set the container as
/// the whole extra widget.
pub const FileChooser = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = opaque {
        pub const Instance = FileChooser;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const action = struct {
            pub const name = "action";

            pub const Type = gtk.FileChooserAction;
        };

        /// Whether a file chooser not in `GTK_FILE_CHOOSER_ACTION_OPEN` mode
        /// will offer the user to create new folders.
        pub const create_folders = struct {
            pub const name = "create-folders";

            pub const Type = c_int;
        };

        /// Whether a file chooser in `GTK_FILE_CHOOSER_ACTION_SAVE` mode
        /// will present an overwrite confirmation dialog if the user
        /// selects a file name that already exists.
        pub const do_overwrite_confirmation = struct {
            pub const name = "do-overwrite-confirmation";

            pub const Type = c_int;
        };

        pub const extra_widget = struct {
            pub const name = "extra-widget";

            pub const Type = ?*gtk.Widget;
        };

        pub const filter = struct {
            pub const name = "filter";

            pub const Type = ?*gtk.FileFilter;
        };

        pub const local_only = struct {
            pub const name = "local-only";

            pub const Type = c_int;
        };

        pub const preview_widget = struct {
            pub const name = "preview-widget";

            pub const Type = ?*gtk.Widget;
        };

        pub const preview_widget_active = struct {
            pub const name = "preview-widget-active";

            pub const Type = c_int;
        };

        pub const select_multiple = struct {
            pub const name = "select-multiple";

            pub const Type = c_int;
        };

        pub const show_hidden = struct {
            pub const name = "show-hidden";

            pub const Type = c_int;
        };

        pub const use_preview_label = struct {
            pub const name = "use-preview-label";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// This signal gets emitted whenever it is appropriate to present a
        /// confirmation dialog when the user has selected a file name that
        /// already exists.  The signal only gets emitted when the file
        /// chooser is in `GTK_FILE_CHOOSER_ACTION_SAVE` mode.
        ///
        /// Most applications just need to turn on the
        /// `gtk.FileChooser.properties.do`-overwrite-confirmation property (or call the
        /// `gtk.FileChooser.setDoOverwriteConfirmation` function), and
        /// they will automatically get a stock confirmation dialog.
        /// Applications which need to customize this behavior should do
        /// that, and also connect to the `gtk.FileChooser.signals.confirm`-overwrite
        /// signal.
        ///
        /// A signal handler for this signal must return a
        /// `gtk.FileChooserConfirmation` value, which indicates the action to
        /// take.  If the handler determines that the user wants to select a
        /// different filename, it should return
        /// `GTK_FILE_CHOOSER_CONFIRMATION_SELECT_AGAIN`.  If it determines
        /// that the user is satisfied with his choice of file name, it
        /// should return `GTK_FILE_CHOOSER_CONFIRMATION_ACCEPT_FILENAME`.
        /// On the other hand, if it determines that the stock confirmation
        /// dialog should be used, it should return
        /// `GTK_FILE_CHOOSER_CONFIRMATION_CONFIRM`. The following example
        /// illustrates this.
        ///
        /// ## Custom confirmation
        ///
        /// ```
        /// static GtkFileChooserConfirmation
        /// confirm_overwrite_callback (GtkFileChooser *chooser, gpointer data)
        /// {
        ///   char *uri;
        ///
        ///   uri = gtk_file_chooser_get_uri (chooser);
        ///
        ///   if (is_uri_read_only (uri))
        ///     {
        ///       if (user_wants_to_replace_read_only_file (uri))
        ///         return GTK_FILE_CHOOSER_CONFIRMATION_ACCEPT_FILENAME;
        ///       else
        ///         return GTK_FILE_CHOOSER_CONFIRMATION_SELECT_AGAIN;
        ///     } else
        ///       return GTK_FILE_CHOOSER_CONFIRMATION_CONFIRM; // fall back to the default dialog
        /// }
        ///
        /// ...
        ///
        /// chooser = gtk_file_chooser_dialog_new (...);
        ///
        /// gtk_file_chooser_set_do_overwrite_confirmation (GTK_FILE_CHOOSER (dialog), TRUE);
        /// g_signal_connect (chooser, "confirm-overwrite",
        ///                   G_CALLBACK (confirm_overwrite_callback), NULL);
        ///
        /// if (gtk_dialog_run (chooser) == GTK_RESPONSE_ACCEPT)
        ///         save_to_file (gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (chooser));
        ///
        /// gtk_widget_destroy (chooser);
        /// ```
        pub const confirm_overwrite = struct {
            pub const name = "confirm-overwrite";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) gtk.FileChooserConfirmation, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooser, p_instance))),
                    gobject.signalLookup("confirm-overwrite", FileChooser.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when the current folder in a `gtk.FileChooser`
        /// changes.  This can happen due to the user performing some action that
        /// changes folders, such as selecting a bookmark or visiting a folder on the
        /// file list.  It can also happen as a result of calling a function to
        /// explicitly change the current folder in a file chooser.
        ///
        /// Normally you do not need to connect to this signal, unless you need to keep
        /// track of which folder a file chooser is showing.
        ///
        /// See also:  `gtk.FileChooser.setCurrentFolder`,
        /// `gtk.FileChooser.getCurrentFolder`,
        /// `gtk.FileChooser.setCurrentFolderUri`,
        /// `gtk.FileChooser.getCurrentFolderUri`.
        pub const current_folder_changed = struct {
            pub const name = "current-folder-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooser, p_instance))),
                    gobject.signalLookup("current-folder-changed", FileChooser.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when the user "activates" a file in the file
        /// chooser.  This can happen by double-clicking on a file in the file list, or
        /// by pressing `Enter`.
        ///
        /// Normally you do not need to connect to this signal.  It is used internally
        /// by `gtk.FileChooserDialog` to know when to activate the default button in the
        /// dialog.
        ///
        /// See also: `gtk.FileChooser.getFilename`,
        /// `gtk.FileChooser.getFilenames`, `gtk.FileChooser.getUri`,
        /// `gtk.FileChooser.getUris`.
        pub const file_activated = struct {
            pub const name = "file-activated";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooser, p_instance))),
                    gobject.signalLookup("file-activated", FileChooser.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when there is a change in the set of selected files
        /// in a `gtk.FileChooser`.  This can happen when the user modifies the selection
        /// with the mouse or the keyboard, or when explicitly calling functions to
        /// change the selection.
        ///
        /// Normally you do not need to connect to this signal, as it is easier to wait
        /// for the file chooser to finish running, and then to get the list of
        /// selected files using the functions mentioned below.
        ///
        /// See also: `gtk.FileChooser.selectFilename`,
        /// `gtk.FileChooser.unselectFilename`, `gtk.FileChooser.getFilename`,
        /// `gtk.FileChooser.getFilenames`, `gtk.FileChooser.selectUri`,
        /// `gtk.FileChooser.unselectUri`, `gtk.FileChooser.getUri`,
        /// `gtk.FileChooser.getUris`.
        pub const selection_changed = struct {
            pub const name = "selection-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooser, p_instance))),
                    gobject.signalLookup("selection-changed", FileChooser.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when the preview in a file chooser should be
        /// regenerated.  For example, this can happen when the currently selected file
        /// changes.  You should use this signal if you want your file chooser to have
        /// a preview widget.
        ///
        /// Once you have installed a preview widget with
        /// `gtk.FileChooser.setPreviewWidget`, you should update it when this
        /// signal is emitted.  You can use the functions
        /// `gtk.FileChooser.getPreviewFilename` or
        /// `gtk.FileChooser.getPreviewUri` to get the name of the file to preview.
        /// Your widget may not be able to preview all kinds of files; your callback
        /// must call `gtk.FileChooser.setPreviewWidgetActive` to inform the file
        /// chooser about whether the preview was generated successfully or not.
        ///
        /// Please see the example code in
        /// [Using a Preview Widget][gtkfilechooser-preview].
        ///
        /// See also: `gtk.FileChooser.setPreviewWidget`,
        /// `gtk.FileChooser.setPreviewWidgetActive`,
        /// `gtk.FileChooser.setUsePreviewLabel`,
        /// `gtk.FileChooser.getPreviewFilename`,
        /// `gtk.FileChooser.getPreviewUri`.
        pub const update_preview = struct {
            pub const name = "update-preview";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileChooser, p_instance))),
                    gobject.signalLookup("update-preview", FileChooser.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Adds a 'choice' to the file chooser. This is typically implemented
    /// as a combobox or, for boolean choices, as a checkbutton. You can select
    /// a value using `gtk.FileChooser.setChoice` before the dialog is shown,
    /// and you can obtain the user-selected value in the ::response signal handler
    /// using `gtk.FileChooser.getChoice`.
    ///
    /// Compare `gtk.FileChooser.setExtraWidget`.
    extern fn gtk_file_chooser_add_choice(p_chooser: *FileChooser, p_id: [*:0]const u8, p_label: [*:0]const u8, p_options: ?[*][*:0]const u8, p_option_labels: ?[*][*:0]const u8) void;
    pub const addChoice = gtk_file_chooser_add_choice;

    /// Adds `filter` to the list of filters that the user can select between.
    /// When a filter is selected, only files that are passed by that
    /// filter are displayed.
    ///
    /// Note that the `chooser` takes ownership of the filter, so you have to
    /// ref and sink it if you want to keep a reference.
    extern fn gtk_file_chooser_add_filter(p_chooser: *FileChooser, p_filter: *gtk.FileFilter) void;
    pub const addFilter = gtk_file_chooser_add_filter;

    /// Adds a folder to be displayed with the shortcut folders in a file chooser.
    /// Note that shortcut folders do not get saved, as they are provided by the
    /// application.  For example, you can use this to add a
    /// “/usr/share/mydrawprogram/Clipart” folder to the volume list.
    extern fn gtk_file_chooser_add_shortcut_folder(p_chooser: *FileChooser, p_folder: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const addShortcutFolder = gtk_file_chooser_add_shortcut_folder;

    /// Adds a folder URI to be displayed with the shortcut folders in a file
    /// chooser.  Note that shortcut folders do not get saved, as they are provided
    /// by the application.  For example, you can use this to add a
    /// “file:///usr/share/mydrawprogram/Clipart” folder to the volume list.
    extern fn gtk_file_chooser_add_shortcut_folder_uri(p_chooser: *FileChooser, p_uri: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const addShortcutFolderUri = gtk_file_chooser_add_shortcut_folder_uri;

    /// Gets the type of operation that the file chooser is performing; see
    /// `gtk.FileChooser.setAction`.
    extern fn gtk_file_chooser_get_action(p_chooser: *FileChooser) gtk.FileChooserAction;
    pub const getAction = gtk_file_chooser_get_action;

    /// Gets the currently selected option in the 'choice' with the given ID.
    extern fn gtk_file_chooser_get_choice(p_chooser: *FileChooser, p_id: [*:0]const u8) [*:0]const u8;
    pub const getChoice = gtk_file_chooser_get_choice;

    /// Gets whether file choser will offer to create new folders.
    /// See `gtk.FileChooser.setCreateFolders`.
    extern fn gtk_file_chooser_get_create_folders(p_chooser: *FileChooser) c_int;
    pub const getCreateFolders = gtk_file_chooser_get_create_folders;

    /// Gets the current folder of `chooser` as a local filename.
    /// See `gtk.FileChooser.setCurrentFolder`.
    ///
    /// Note that this is the folder that the file chooser is currently displaying
    /// (e.g. "/home/username/Documents"), which is not the same
    /// as the currently-selected folder if the chooser is in
    /// `GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER` mode
    /// (e.g. "/home/username/Documents/selected-folder/".  To get the
    /// currently-selected folder in that mode, use `gtk.FileChooser.getUri` as the
    /// usual way to get the selection.
    extern fn gtk_file_chooser_get_current_folder(p_chooser: *FileChooser) ?[*:0]u8;
    pub const getCurrentFolder = gtk_file_chooser_get_current_folder;

    /// Gets the current folder of `chooser` as `gio.File`.
    /// See `gtk.FileChooser.getCurrentFolderUri`.
    extern fn gtk_file_chooser_get_current_folder_file(p_chooser: *FileChooser) ?*gio.File;
    pub const getCurrentFolderFile = gtk_file_chooser_get_current_folder_file;

    /// Gets the current folder of `chooser` as an URI.
    /// See `gtk.FileChooser.setCurrentFolderUri`.
    ///
    /// Note that this is the folder that the file chooser is currently displaying
    /// (e.g. "file:///home/username/Documents"), which is not the same
    /// as the currently-selected folder if the chooser is in
    /// `GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER` mode
    /// (e.g. "file:///home/username/Documents/selected-folder/".  To get the
    /// currently-selected folder in that mode, use `gtk.FileChooser.getUri` as the
    /// usual way to get the selection.
    extern fn gtk_file_chooser_get_current_folder_uri(p_chooser: *FileChooser) ?[*:0]u8;
    pub const getCurrentFolderUri = gtk_file_chooser_get_current_folder_uri;

    /// Gets the current name in the file selector, as entered by the user in the
    /// text entry for “Name”.
    ///
    /// This is meant to be used in save dialogs, to get the currently typed filename
    /// when the file itself does not exist yet.  For example, an application that
    /// adds a custom extra widget to the file chooser for “file format” may want to
    /// change the extension of the typed filename based on the chosen format, say,
    /// from “.jpg” to “.png”.
    extern fn gtk_file_chooser_get_current_name(p_chooser: *FileChooser) [*:0]u8;
    pub const getCurrentName = gtk_file_chooser_get_current_name;

    /// Queries whether a file chooser is set to confirm for overwriting when the user
    /// types a file name that already exists.
    extern fn gtk_file_chooser_get_do_overwrite_confirmation(p_chooser: *FileChooser) c_int;
    pub const getDoOverwriteConfirmation = gtk_file_chooser_get_do_overwrite_confirmation;

    /// Gets the current extra widget; see
    /// `gtk.FileChooser.setExtraWidget`.
    extern fn gtk_file_chooser_get_extra_widget(p_chooser: *FileChooser) ?*gtk.Widget;
    pub const getExtraWidget = gtk_file_chooser_get_extra_widget;

    /// Gets the `gio.File` for the currently selected file in
    /// the file selector. If multiple files are selected,
    /// one of the files will be returned at random.
    ///
    /// If the file chooser is in folder mode, this function returns the selected
    /// folder.
    extern fn gtk_file_chooser_get_file(p_chooser: *FileChooser) *gio.File;
    pub const getFile = gtk_file_chooser_get_file;

    /// Gets the filename for the currently selected file in
    /// the file selector. The filename is returned as an absolute path. If
    /// multiple files are selected, one of the filenames will be returned at
    /// random.
    ///
    /// If the file chooser is in folder mode, this function returns the selected
    /// folder.
    extern fn gtk_file_chooser_get_filename(p_chooser: *FileChooser) ?[*:0]u8;
    pub const getFilename = gtk_file_chooser_get_filename;

    /// Lists all the selected files and subfolders in the current folder of
    /// `chooser`. The returned names are full absolute paths. If files in the current
    /// folder cannot be represented as local filenames they will be ignored. (See
    /// `gtk.FileChooser.getUris`)
    extern fn gtk_file_chooser_get_filenames(p_chooser: *FileChooser) *glib.SList;
    pub const getFilenames = gtk_file_chooser_get_filenames;

    /// Lists all the selected files and subfolders in the current folder of `chooser`
    /// as `gio.File`. An internal function, see `gtk.FileChooser.getUris`.
    extern fn gtk_file_chooser_get_files(p_chooser: *FileChooser) *glib.SList;
    pub const getFiles = gtk_file_chooser_get_files;

    /// Gets the current filter; see `gtk.FileChooser.setFilter`.
    extern fn gtk_file_chooser_get_filter(p_chooser: *FileChooser) ?*gtk.FileFilter;
    pub const getFilter = gtk_file_chooser_get_filter;

    /// Gets whether only local files can be selected in the
    /// file selector. See `gtk.FileChooser.setLocalOnly`
    extern fn gtk_file_chooser_get_local_only(p_chooser: *FileChooser) c_int;
    pub const getLocalOnly = gtk_file_chooser_get_local_only;

    /// Gets the `gio.File` that should be previewed in a custom preview
    /// Internal function, see `gtk.FileChooser.getPreviewUri`.
    extern fn gtk_file_chooser_get_preview_file(p_chooser: *FileChooser) ?*gio.File;
    pub const getPreviewFile = gtk_file_chooser_get_preview_file;

    /// Gets the filename that should be previewed in a custom preview
    /// widget. See `gtk.FileChooser.setPreviewWidget`.
    extern fn gtk_file_chooser_get_preview_filename(p_chooser: *FileChooser) ?[*:0]u8;
    pub const getPreviewFilename = gtk_file_chooser_get_preview_filename;

    /// Gets the URI that should be previewed in a custom preview
    /// widget. See `gtk.FileChooser.setPreviewWidget`.
    extern fn gtk_file_chooser_get_preview_uri(p_chooser: *FileChooser) ?[*:0]u8;
    pub const getPreviewUri = gtk_file_chooser_get_preview_uri;

    /// Gets the current preview widget; see
    /// `gtk.FileChooser.setPreviewWidget`.
    extern fn gtk_file_chooser_get_preview_widget(p_chooser: *FileChooser) ?*gtk.Widget;
    pub const getPreviewWidget = gtk_file_chooser_get_preview_widget;

    /// Gets whether the preview widget set by `gtk.FileChooser.setPreviewWidget`
    /// should be shown for the current filename. See
    /// `gtk.FileChooser.setPreviewWidgetActive`.
    extern fn gtk_file_chooser_get_preview_widget_active(p_chooser: *FileChooser) c_int;
    pub const getPreviewWidgetActive = gtk_file_chooser_get_preview_widget_active;

    /// Gets whether multiple files can be selected in the file
    /// selector. See `gtk.FileChooser.setSelectMultiple`.
    extern fn gtk_file_chooser_get_select_multiple(p_chooser: *FileChooser) c_int;
    pub const getSelectMultiple = gtk_file_chooser_get_select_multiple;

    /// Gets whether hidden files and folders are displayed in the file selector.
    /// See `gtk.FileChooser.setShowHidden`.
    extern fn gtk_file_chooser_get_show_hidden(p_chooser: *FileChooser) c_int;
    pub const getShowHidden = gtk_file_chooser_get_show_hidden;

    /// Gets the URI for the currently selected file in
    /// the file selector. If multiple files are selected,
    /// one of the filenames will be returned at random.
    ///
    /// If the file chooser is in folder mode, this function returns the selected
    /// folder.
    extern fn gtk_file_chooser_get_uri(p_chooser: *FileChooser) ?[*:0]u8;
    pub const getUri = gtk_file_chooser_get_uri;

    /// Lists all the selected files and subfolders in the current folder of
    /// `chooser`. The returned names are full absolute URIs.
    extern fn gtk_file_chooser_get_uris(p_chooser: *FileChooser) *glib.SList;
    pub const getUris = gtk_file_chooser_get_uris;

    /// Gets whether a stock label should be drawn with the name of the previewed
    /// file.  See `gtk.FileChooser.setUsePreviewLabel`.
    extern fn gtk_file_chooser_get_use_preview_label(p_chooser: *FileChooser) c_int;
    pub const getUsePreviewLabel = gtk_file_chooser_get_use_preview_label;

    /// Lists the current set of user-selectable filters; see
    /// `gtk.FileChooser.addFilter`, `gtk.FileChooser.removeFilter`.
    extern fn gtk_file_chooser_list_filters(p_chooser: *FileChooser) *glib.SList;
    pub const listFilters = gtk_file_chooser_list_filters;

    /// Queries the list of shortcut folders in the file chooser, as set by
    /// `gtk.FileChooser.addShortcutFolderUri`.
    extern fn gtk_file_chooser_list_shortcut_folder_uris(p_chooser: *FileChooser) ?*glib.SList;
    pub const listShortcutFolderUris = gtk_file_chooser_list_shortcut_folder_uris;

    /// Queries the list of shortcut folders in the file chooser, as set by
    /// `gtk.FileChooser.addShortcutFolder`.
    extern fn gtk_file_chooser_list_shortcut_folders(p_chooser: *FileChooser) ?*glib.SList;
    pub const listShortcutFolders = gtk_file_chooser_list_shortcut_folders;

    /// Removes a 'choice' that has been added with `gtk.FileChooser.addChoice`.
    extern fn gtk_file_chooser_remove_choice(p_chooser: *FileChooser, p_id: [*:0]const u8) void;
    pub const removeChoice = gtk_file_chooser_remove_choice;

    /// Removes `filter` from the list of filters that the user can select between.
    extern fn gtk_file_chooser_remove_filter(p_chooser: *FileChooser, p_filter: *gtk.FileFilter) void;
    pub const removeFilter = gtk_file_chooser_remove_filter;

    /// Removes a folder from a file chooser’s list of shortcut folders.
    extern fn gtk_file_chooser_remove_shortcut_folder(p_chooser: *FileChooser, p_folder: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const removeShortcutFolder = gtk_file_chooser_remove_shortcut_folder;

    /// Removes a folder URI from a file chooser’s list of shortcut folders.
    extern fn gtk_file_chooser_remove_shortcut_folder_uri(p_chooser: *FileChooser, p_uri: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const removeShortcutFolderUri = gtk_file_chooser_remove_shortcut_folder_uri;

    /// Selects all the files in the current folder of a file chooser.
    extern fn gtk_file_chooser_select_all(p_chooser: *FileChooser) void;
    pub const selectAll = gtk_file_chooser_select_all;

    /// Selects the file referred to by `file`. An internal function. See
    /// `_gtk_file_chooser_select_uri`.
    extern fn gtk_file_chooser_select_file(p_chooser: *FileChooser, p_file: *gio.File, p_error: ?*?*glib.Error) c_int;
    pub const selectFile = gtk_file_chooser_select_file;

    /// Selects a filename. If the file name isn’t in the current
    /// folder of `chooser`, then the current folder of `chooser` will
    /// be changed to the folder containing `filename`.
    extern fn gtk_file_chooser_select_filename(p_chooser: *FileChooser, p_filename: [*:0]const u8) c_int;
    pub const selectFilename = gtk_file_chooser_select_filename;

    /// Selects the file to by `uri`. If the URI doesn’t refer to a
    /// file in the current folder of `chooser`, then the current folder of
    /// `chooser` will be changed to the folder containing `filename`.
    extern fn gtk_file_chooser_select_uri(p_chooser: *FileChooser, p_uri: [*:0]const u8) c_int;
    pub const selectUri = gtk_file_chooser_select_uri;

    /// Sets the type of operation that the chooser is performing; the
    /// user interface is adapted to suit the selected action. For example,
    /// an option to create a new folder might be shown if the action is
    /// `GTK_FILE_CHOOSER_ACTION_SAVE` but not if the action is
    /// `GTK_FILE_CHOOSER_ACTION_OPEN`.
    extern fn gtk_file_chooser_set_action(p_chooser: *FileChooser, p_action: gtk.FileChooserAction) void;
    pub const setAction = gtk_file_chooser_set_action;

    /// Selects an option in a 'choice' that has been added with
    /// `gtk.FileChooser.addChoice`. For a boolean choice, the
    /// possible options are "true" and "false".
    extern fn gtk_file_chooser_set_choice(p_chooser: *FileChooser, p_id: [*:0]const u8, p_option: [*:0]const u8) void;
    pub const setChoice = gtk_file_chooser_set_choice;

    /// Sets whether file choser will offer to create new folders.
    /// This is only relevant if the action is not set to be
    /// `GTK_FILE_CHOOSER_ACTION_OPEN`.
    extern fn gtk_file_chooser_set_create_folders(p_chooser: *FileChooser, p_create_folders: c_int) void;
    pub const setCreateFolders = gtk_file_chooser_set_create_folders;

    /// Sets the current folder for `chooser` from a local filename.
    /// The user will be shown the full contents of the current folder,
    /// plus user interface elements for navigating to other folders.
    ///
    /// In general, you should not use this function.  See the
    /// [section on setting up a file chooser dialog][gtkfilechooserdialog-setting-up]
    /// for the rationale behind this.
    extern fn gtk_file_chooser_set_current_folder(p_chooser: *FileChooser, p_filename: [*:0]const u8) c_int;
    pub const setCurrentFolder = gtk_file_chooser_set_current_folder;

    /// Sets the current folder for `chooser` from a `gio.File`.
    /// Internal function, see `gtk.FileChooser.setCurrentFolderUri`.
    extern fn gtk_file_chooser_set_current_folder_file(p_chooser: *FileChooser, p_file: *gio.File, p_error: ?*?*glib.Error) c_int;
    pub const setCurrentFolderFile = gtk_file_chooser_set_current_folder_file;

    /// Sets the current folder for `chooser` from an URI.
    /// The user will be shown the full contents of the current folder,
    /// plus user interface elements for navigating to other folders.
    ///
    /// In general, you should not use this function.  See the
    /// [section on setting up a file chooser dialog][gtkfilechooserdialog-setting-up]
    /// for the rationale behind this.
    extern fn gtk_file_chooser_set_current_folder_uri(p_chooser: *FileChooser, p_uri: [*:0]const u8) c_int;
    pub const setCurrentFolderUri = gtk_file_chooser_set_current_folder_uri;

    /// Sets the current name in the file selector, as if entered
    /// by the user. Note that the name passed in here is a UTF-8
    /// string rather than a filename. This function is meant for
    /// such uses as a suggested name in a “Save As...” dialog.  You can
    /// pass “Untitled.doc” or a similarly suitable suggestion for the `name`.
    ///
    /// If you want to preselect a particular existing file, you should use
    /// `gtk.FileChooser.setFilename` or `gtk.FileChooser.setUri` instead.
    /// Please see the documentation for those functions for an example of using
    /// `gtk.FileChooser.setCurrentName` as well.
    extern fn gtk_file_chooser_set_current_name(p_chooser: *FileChooser, p_name: [*:0]const u8) void;
    pub const setCurrentName = gtk_file_chooser_set_current_name;

    /// Sets whether a file chooser in `GTK_FILE_CHOOSER_ACTION_SAVE` mode will present
    /// a confirmation dialog if the user types a file name that already exists.  This
    /// is `FALSE` by default.
    ///
    /// If set to `TRUE`, the `chooser` will emit the
    /// `gtk.FileChooser.signals.confirm`-overwrite signal when appropriate.
    ///
    /// If all you need is the stock confirmation dialog, set this property to `TRUE`.
    /// You can override the way confirmation is done by actually handling the
    /// `gtk.FileChooser.signals.confirm`-overwrite signal; please refer to its documentation
    /// for the details.
    extern fn gtk_file_chooser_set_do_overwrite_confirmation(p_chooser: *FileChooser, p_do_overwrite_confirmation: c_int) void;
    pub const setDoOverwriteConfirmation = gtk_file_chooser_set_do_overwrite_confirmation;

    /// Sets an application-supplied widget to provide extra options to the user.
    extern fn gtk_file_chooser_set_extra_widget(p_chooser: *FileChooser, p_extra_widget: *gtk.Widget) void;
    pub const setExtraWidget = gtk_file_chooser_set_extra_widget;

    /// Sets `file` as the current filename for the file chooser, by changing
    /// to the file’s parent folder and actually selecting the file in list.  If
    /// the `chooser` is in `GTK_FILE_CHOOSER_ACTION_SAVE` mode, the file’s base name
    /// will also appear in the dialog’s file name entry.
    ///
    /// If the file name isn’t in the current folder of `chooser`, then the current
    /// folder of `chooser` will be changed to the folder containing `filename`. This
    /// is equivalent to a sequence of `gtk.FileChooser.unselectAll` followed by
    /// `gtk.FileChooser.selectFilename`.
    ///
    /// Note that the file must exist, or nothing will be done except
    /// for the directory change.
    ///
    /// If you are implementing a save dialog,
    /// you should use this function if you already have a file name to which the
    /// user may save; for example, when the user opens an existing file and then
    /// does Save As...  If you don’t have
    /// a file name already — for example, if the user just created a new
    /// file and is saving it for the first time, do not call this function.
    /// Instead, use something similar to this:
    /// ```
    /// if (document_is_new)
    ///   {
    ///     // the user just created a new document
    ///     gtk_file_chooser_set_current_folder_file (chooser, default_file_for_saving);
    ///     gtk_file_chooser_set_current_name (chooser, "Untitled document");
    ///   }
    /// else
    ///   {
    ///     // the user edited an existing document
    ///     gtk_file_chooser_set_file (chooser, existing_file);
    ///   }
    /// ```
    extern fn gtk_file_chooser_set_file(p_chooser: *FileChooser, p_file: *gio.File, p_error: ?*?*glib.Error) c_int;
    pub const setFile = gtk_file_chooser_set_file;

    /// Sets `filename` as the current filename for the file chooser, by changing to
    /// the file’s parent folder and actually selecting the file in list; all other
    /// files will be unselected.  If the `chooser` is in
    /// `GTK_FILE_CHOOSER_ACTION_SAVE` mode, the file’s base name will also appear in
    /// the dialog’s file name entry.
    ///
    /// Note that the file must exist, or nothing will be done except
    /// for the directory change.
    ///
    /// You should use this function only when implementing a save
    /// dialog for which you already have a file name to which
    /// the user may save.  For example, when the user opens an existing file and
    /// then does Save As... to save a copy or
    /// a modified version.  If you don’t have a file name already — for
    /// example, if the user just created a new file and is saving it for the first
    /// time, do not call this function.  Instead, use something similar to this:
    /// ```
    /// if (document_is_new)
    ///   {
    ///     // the user just created a new document
    ///     gtk_file_chooser_set_current_name (chooser, "Untitled document");
    ///   }
    /// else
    ///   {
    ///     // the user edited an existing document
    ///     gtk_file_chooser_set_filename (chooser, existing_filename);
    ///   }
    /// ```
    ///
    /// In the first case, the file chooser will present the user with useful suggestions
    /// as to where to save his new file.  In the second case, the file’s existing location
    /// is already known, so the file chooser will use it.
    extern fn gtk_file_chooser_set_filename(p_chooser: *FileChooser, p_filename: [*:0]const u8) c_int;
    pub const setFilename = gtk_file_chooser_set_filename;

    /// Sets the current filter; only the files that pass the
    /// filter will be displayed. If the user-selectable list of filters
    /// is non-empty, then the filter should be one of the filters
    /// in that list. Setting the current filter when the list of
    /// filters is empty is useful if you want to restrict the displayed
    /// set of files without letting the user change it.
    extern fn gtk_file_chooser_set_filter(p_chooser: *FileChooser, p_filter: *gtk.FileFilter) void;
    pub const setFilter = gtk_file_chooser_set_filter;

    /// Sets whether only local files can be selected in the
    /// file selector. If `local_only` is `TRUE` (the default),
    /// then the selected file or files are guaranteed to be
    /// accessible through the operating systems native file
    /// system and therefore the application only
    /// needs to worry about the filename functions in
    /// `gtk.FileChooser`, like `gtk.FileChooser.getFilename`,
    /// rather than the URI functions like
    /// `gtk.FileChooser.getUri`,
    ///
    /// On some systems non-native files may still be
    /// available using the native filesystem via a userspace
    /// filesystem (FUSE).
    extern fn gtk_file_chooser_set_local_only(p_chooser: *FileChooser, p_local_only: c_int) void;
    pub const setLocalOnly = gtk_file_chooser_set_local_only;

    /// Sets an application-supplied widget to use to display a custom preview
    /// of the currently selected file. To implement a preview, after setting the
    /// preview widget, you connect to the `gtk.FileChooser.signals.update`-preview
    /// signal, and call `gtk.FileChooser.getPreviewFilename` or
    /// `gtk.FileChooser.getPreviewUri` on each change. If you can
    /// display a preview of the new file, update your widget and
    /// set the preview active using `gtk.FileChooser.setPreviewWidgetActive`.
    /// Otherwise, set the preview inactive.
    ///
    /// When there is no application-supplied preview widget, or the
    /// application-supplied preview widget is not active, the file chooser
    /// will display no preview at all.
    extern fn gtk_file_chooser_set_preview_widget(p_chooser: *FileChooser, p_preview_widget: *gtk.Widget) void;
    pub const setPreviewWidget = gtk_file_chooser_set_preview_widget;

    /// Sets whether the preview widget set by
    /// `gtk.FileChooser.setPreviewWidget` should be shown for the
    /// current filename. When `active` is set to false, the file chooser
    /// may display an internally generated preview of the current file
    /// or it may display no preview at all. See
    /// `gtk.FileChooser.setPreviewWidget` for more details.
    extern fn gtk_file_chooser_set_preview_widget_active(p_chooser: *FileChooser, p_active: c_int) void;
    pub const setPreviewWidgetActive = gtk_file_chooser_set_preview_widget_active;

    /// Sets whether multiple files can be selected in the file selector.  This is
    /// only relevant if the action is set to be `GTK_FILE_CHOOSER_ACTION_OPEN` or
    /// `GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER`.
    extern fn gtk_file_chooser_set_select_multiple(p_chooser: *FileChooser, p_select_multiple: c_int) void;
    pub const setSelectMultiple = gtk_file_chooser_set_select_multiple;

    /// Sets whether hidden files and folders are displayed in the file selector.
    extern fn gtk_file_chooser_set_show_hidden(p_chooser: *FileChooser, p_show_hidden: c_int) void;
    pub const setShowHidden = gtk_file_chooser_set_show_hidden;

    /// Sets the file referred to by `uri` as the current file for the file chooser,
    /// by changing to the URI’s parent folder and actually selecting the URI in the
    /// list.  If the `chooser` is `GTK_FILE_CHOOSER_ACTION_SAVE` mode, the URI’s base
    /// name will also appear in the dialog’s file name entry.
    ///
    /// Note that the URI must exist, or nothing will be done except for the
    /// directory change.
    ///
    /// You should use this function only when implementing a save
    /// dialog for which you already have a file name to which
    /// the user may save.  For example, when the user opens an existing file and then
    /// does Save As... to save a copy or a
    /// modified version.  If you don’t have a file name already — for example,
    /// if the user just created a new file and is saving it for the first time, do
    /// not call this function.  Instead, use something similar to this:
    /// ```
    /// if (document_is_new)
    ///   {
    ///     // the user just created a new document
    ///     gtk_file_chooser_set_current_name (chooser, "Untitled document");
    ///   }
    /// else
    ///   {
    ///     // the user edited an existing document
    ///     gtk_file_chooser_set_uri (chooser, existing_uri);
    ///   }
    /// ```
    ///
    ///
    /// In the first case, the file chooser will present the user with useful suggestions
    /// as to where to save his new file.  In the second case, the file’s existing location
    /// is already known, so the file chooser will use it.
    extern fn gtk_file_chooser_set_uri(p_chooser: *FileChooser, p_uri: [*:0]const u8) c_int;
    pub const setUri = gtk_file_chooser_set_uri;

    /// Sets whether the file chooser should display a stock label with the name of
    /// the file that is being previewed; the default is `TRUE`.  Applications that
    /// want to draw the whole preview area themselves should set this to `FALSE` and
    /// display the name themselves in their preview widget.
    ///
    /// See also: `gtk.FileChooser.setPreviewWidget`
    extern fn gtk_file_chooser_set_use_preview_label(p_chooser: *FileChooser, p_use_label: c_int) void;
    pub const setUsePreviewLabel = gtk_file_chooser_set_use_preview_label;

    /// Unselects all the files in the current folder of a file chooser.
    extern fn gtk_file_chooser_unselect_all(p_chooser: *FileChooser) void;
    pub const unselectAll = gtk_file_chooser_unselect_all;

    /// Unselects the file referred to by `file`. If the file is not in the current
    /// directory, does not exist, or is otherwise not currently selected, does nothing.
    extern fn gtk_file_chooser_unselect_file(p_chooser: *FileChooser, p_file: *gio.File) void;
    pub const unselectFile = gtk_file_chooser_unselect_file;

    /// Unselects a currently selected filename. If the filename
    /// is not in the current directory, does not exist, or
    /// is otherwise not currently selected, does nothing.
    extern fn gtk_file_chooser_unselect_filename(p_chooser: *FileChooser, p_filename: [*:0]const u8) void;
    pub const unselectFilename = gtk_file_chooser_unselect_filename;

    /// Unselects the file referred to by `uri`. If the file
    /// is not in the current directory, does not exist, or
    /// is otherwise not currently selected, does nothing.
    extern fn gtk_file_chooser_unselect_uri(p_chooser: *FileChooser, p_uri: [*:0]const u8) void;
    pub const unselectUri = gtk_file_chooser_unselect_uri;

    extern fn gtk_file_chooser_get_type() usize;
    pub const getGObjectType = gtk_file_chooser_get_type;

    extern fn g_object_ref(p_self: *gtk.FileChooser) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FileChooser) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FileChooser, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.FontChooser` is an interface that can be implemented by widgets
/// displaying the list of fonts. In GTK+, the main objects
/// that implement this interface are `gtk.FontChooserWidget`,
/// `gtk.FontChooserDialog` and `gtk.FontButton`. The GtkFontChooser interface
/// has been introducted in GTK+ 3.2.
pub const FontChooser = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gtk.FontChooserIface;
    pub const virtual_methods = struct {
        pub const font_activated = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_fontname: [*:0]const u8) void {
                return gobject.ext.as(FontChooser.Iface, p_class).f_font_activated.?(gobject.ext.as(FontChooser, p_chooser), p_fontname);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_fontname: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(FontChooser.Iface, p_class).f_font_activated = @ptrCast(p_implementation);
            }
        };

        /// Gets the `pango.FontFace` representing the selected font group
        /// details (i.e. family, slant, weight, width, etc).
        ///
        /// If the selected font is not installed, returns `NULL`.
        pub const get_font_face = struct {
            pub fn call(p_class: anytype, p_fontchooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*pango.FontFace {
                return gobject.ext.as(FontChooser.Iface, p_class).f_get_font_face.?(gobject.ext.as(FontChooser, p_fontchooser));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_fontchooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*pango.FontFace) void {
                gobject.ext.as(FontChooser.Iface, p_class).f_get_font_face = @ptrCast(p_implementation);
            }
        };

        /// Gets the `pango.FontFamily` representing the selected font family.
        /// Font families are a collection of font faces.
        ///
        /// If the selected font is not installed, returns `NULL`.
        pub const get_font_family = struct {
            pub fn call(p_class: anytype, p_fontchooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*pango.FontFamily {
                return gobject.ext.as(FontChooser.Iface, p_class).f_get_font_family.?(gobject.ext.as(FontChooser, p_fontchooser));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_fontchooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*pango.FontFamily) void {
                gobject.ext.as(FontChooser.Iface, p_class).f_get_font_family = @ptrCast(p_implementation);
            }
        };

        /// Gets the custom font map of this font chooser widget,
        /// or `NULL` if it does not have one.
        pub const get_font_map = struct {
            pub fn call(p_class: anytype, p_fontchooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*pango.FontMap {
                return gobject.ext.as(FontChooser.Iface, p_class).f_get_font_map.?(gobject.ext.as(FontChooser, p_fontchooser));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_fontchooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*pango.FontMap) void {
                gobject.ext.as(FontChooser.Iface, p_class).f_get_font_map = @ptrCast(p_implementation);
            }
        };

        /// The selected font size.
        pub const get_font_size = struct {
            pub fn call(p_class: anytype, p_fontchooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(FontChooser.Iface, p_class).f_get_font_size.?(gobject.ext.as(FontChooser, p_fontchooser));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_fontchooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(FontChooser.Iface, p_class).f_get_font_size = @ptrCast(p_implementation);
            }
        };

        /// Adds a filter function that decides which fonts to display
        /// in the font chooser.
        pub const set_filter_func = struct {
            pub fn call(p_class: anytype, p_fontchooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_filter: ?gtk.FontFilterFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void {
                return gobject.ext.as(FontChooser.Iface, p_class).f_set_filter_func.?(gobject.ext.as(FontChooser, p_fontchooser), p_filter, p_user_data, p_destroy);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_fontchooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_filter: ?gtk.FontFilterFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) callconv(.c) void) void {
                gobject.ext.as(FontChooser.Iface, p_class).f_set_filter_func = @ptrCast(p_implementation);
            }
        };

        /// Sets a custom font map to use for this font chooser widget.
        /// A custom font map can be used to present application-specific
        /// fonts instead of or in addition to the normal system fonts.
        ///
        /// ```
        /// FcConfig *config;
        /// PangoFontMap *fontmap;
        ///
        /// config = FcInitLoadConfigAndFonts ();
        /// FcConfigAppFontAddFile (config, my_app_font_file);
        ///
        /// fontmap = pango_cairo_font_map_new_for_font_type (CAIRO_FONT_TYPE_FT);
        /// pango_fc_font_map_set_config (PANGO_FC_FONT_MAP (fontmap), config);
        ///
        /// gtk_font_chooser_set_font_map (font_chooser, fontmap);
        /// ```
        ///
        /// Note that other GTK+ widgets will only be able to use the application-specific
        /// font if it is present in the font map they use:
        ///
        /// ```
        /// context = gtk_widget_get_pango_context (label);
        /// pango_context_set_font_map (context, fontmap);
        /// ```
        pub const set_font_map = struct {
            pub fn call(p_class: anytype, p_fontchooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_fontmap: ?*pango.FontMap) void {
                return gobject.ext.as(FontChooser.Iface, p_class).f_set_font_map.?(gobject.ext.as(FontChooser, p_fontchooser), p_fontmap);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_fontchooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_fontmap: ?*pango.FontMap) callconv(.c) void) void {
                gobject.ext.as(FontChooser.Iface, p_class).f_set_font_map = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The font description as a string, e.g. "Sans Italic 12".
        pub const font = struct {
            pub const name = "font";

            pub const Type = ?[*:0]u8;
        };

        /// The font description as a `pango.FontDescription`.
        pub const font_desc = struct {
            pub const name = "font-desc";

            pub const Type = ?*pango.FontDescription;
        };

        /// The selected font features, in a format that is compatible with
        /// CSS and with Pango attributes.
        pub const font_features = struct {
            pub const name = "font-features";

            pub const Type = ?[*:0]u8;
        };

        /// The language for which the `gtk.FontChooser.properties.font`-features were
        /// selected, in a format that is compatible with CSS and with Pango
        /// attributes.
        pub const language = struct {
            pub const name = "language";

            pub const Type = ?[*:0]u8;
        };

        /// The level of granularity to offer for selecting fonts.
        pub const level = struct {
            pub const name = "level";

            pub const Type = gtk.FontChooserLevel;
        };

        /// The string with which to preview the font.
        pub const preview_text = struct {
            pub const name = "preview-text";

            pub const Type = ?[*:0]u8;
        };

        /// Whether to show an entry to change the preview text.
        pub const show_preview_entry = struct {
            pub const name = "show-preview-entry";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted when a font is activated.
        /// This usually happens when the user double clicks an item,
        /// or an item is selected and the user presses one of the keys
        /// Space, Shift+Space, Return or Enter.
        pub const font_activated = struct {
            pub const name = "font-activated";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_fontname: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FontChooser, p_instance))),
                    gobject.signalLookup("font-activated", FontChooser.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Gets the currently-selected font name.
    ///
    /// Note that this can be a different string than what you set with
    /// `gtk.FontChooser.setFont`, as the font chooser widget may
    /// normalize font names and thus return a string with a different
    /// structure. For example, “Helvetica Italic Bold 12” could be
    /// normalized to “Helvetica Bold Italic 12”.
    ///
    /// Use `pango.FontDescription.equal` if you want to compare two
    /// font descriptions.
    extern fn gtk_font_chooser_get_font(p_fontchooser: *FontChooser) ?[*:0]u8;
    pub const getFont = gtk_font_chooser_get_font;

    /// Gets the currently-selected font.
    ///
    /// Note that this can be a different string than what you set with
    /// `gtk.FontChooser.setFont`, as the font chooser widget may
    /// normalize font names and thus return a string with a different
    /// structure. For example, “Helvetica Italic Bold 12” could be
    /// normalized to “Helvetica Bold Italic 12”.
    ///
    /// Use `pango.FontDescription.equal` if you want to compare two
    /// font descriptions.
    extern fn gtk_font_chooser_get_font_desc(p_fontchooser: *FontChooser) ?*pango.FontDescription;
    pub const getFontDesc = gtk_font_chooser_get_font_desc;

    /// Gets the `pango.FontFace` representing the selected font group
    /// details (i.e. family, slant, weight, width, etc).
    ///
    /// If the selected font is not installed, returns `NULL`.
    extern fn gtk_font_chooser_get_font_face(p_fontchooser: *FontChooser) ?*pango.FontFace;
    pub const getFontFace = gtk_font_chooser_get_font_face;

    /// Gets the `pango.FontFamily` representing the selected font family.
    /// Font families are a collection of font faces.
    ///
    /// If the selected font is not installed, returns `NULL`.
    extern fn gtk_font_chooser_get_font_family(p_fontchooser: *FontChooser) ?*pango.FontFamily;
    pub const getFontFamily = gtk_font_chooser_get_font_family;

    /// Gets the currently-selected font features.
    extern fn gtk_font_chooser_get_font_features(p_fontchooser: *FontChooser) [*:0]u8;
    pub const getFontFeatures = gtk_font_chooser_get_font_features;

    /// Gets the custom font map of this font chooser widget,
    /// or `NULL` if it does not have one.
    extern fn gtk_font_chooser_get_font_map(p_fontchooser: *FontChooser) ?*pango.FontMap;
    pub const getFontMap = gtk_font_chooser_get_font_map;

    /// The selected font size.
    extern fn gtk_font_chooser_get_font_size(p_fontchooser: *FontChooser) c_int;
    pub const getFontSize = gtk_font_chooser_get_font_size;

    /// Gets the language that is used for font features.
    extern fn gtk_font_chooser_get_language(p_fontchooser: *FontChooser) [*:0]u8;
    pub const getLanguage = gtk_font_chooser_get_language;

    /// Returns the current level of granularity for selecting fonts.
    extern fn gtk_font_chooser_get_level(p_fontchooser: *FontChooser) gtk.FontChooserLevel;
    pub const getLevel = gtk_font_chooser_get_level;

    /// Gets the text displayed in the preview area.
    extern fn gtk_font_chooser_get_preview_text(p_fontchooser: *FontChooser) [*:0]u8;
    pub const getPreviewText = gtk_font_chooser_get_preview_text;

    /// Returns whether the preview entry is shown or not.
    extern fn gtk_font_chooser_get_show_preview_entry(p_fontchooser: *FontChooser) c_int;
    pub const getShowPreviewEntry = gtk_font_chooser_get_show_preview_entry;

    /// Adds a filter function that decides which fonts to display
    /// in the font chooser.
    extern fn gtk_font_chooser_set_filter_func(p_fontchooser: *FontChooser, p_filter: ?gtk.FontFilterFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setFilterFunc = gtk_font_chooser_set_filter_func;

    /// Sets the currently-selected font.
    extern fn gtk_font_chooser_set_font(p_fontchooser: *FontChooser, p_fontname: [*:0]const u8) void;
    pub const setFont = gtk_font_chooser_set_font;

    /// Sets the currently-selected font from `font_desc`.
    extern fn gtk_font_chooser_set_font_desc(p_fontchooser: *FontChooser, p_font_desc: *const pango.FontDescription) void;
    pub const setFontDesc = gtk_font_chooser_set_font_desc;

    /// Sets a custom font map to use for this font chooser widget.
    /// A custom font map can be used to present application-specific
    /// fonts instead of or in addition to the normal system fonts.
    ///
    /// ```
    /// FcConfig *config;
    /// PangoFontMap *fontmap;
    ///
    /// config = FcInitLoadConfigAndFonts ();
    /// FcConfigAppFontAddFile (config, my_app_font_file);
    ///
    /// fontmap = pango_cairo_font_map_new_for_font_type (CAIRO_FONT_TYPE_FT);
    /// pango_fc_font_map_set_config (PANGO_FC_FONT_MAP (fontmap), config);
    ///
    /// gtk_font_chooser_set_font_map (font_chooser, fontmap);
    /// ```
    ///
    /// Note that other GTK+ widgets will only be able to use the application-specific
    /// font if it is present in the font map they use:
    ///
    /// ```
    /// context = gtk_widget_get_pango_context (label);
    /// pango_context_set_font_map (context, fontmap);
    /// ```
    extern fn gtk_font_chooser_set_font_map(p_fontchooser: *FontChooser, p_fontmap: ?*pango.FontMap) void;
    pub const setFontMap = gtk_font_chooser_set_font_map;

    /// Sets the language to use for font features.
    extern fn gtk_font_chooser_set_language(p_fontchooser: *FontChooser, p_language: [*:0]const u8) void;
    pub const setLanguage = gtk_font_chooser_set_language;

    /// Sets the desired level of granularity for selecting fonts.
    extern fn gtk_font_chooser_set_level(p_fontchooser: *FontChooser, p_level: gtk.FontChooserLevel) void;
    pub const setLevel = gtk_font_chooser_set_level;

    /// Sets the text displayed in the preview area.
    /// The `text` is used to show how the selected font looks.
    extern fn gtk_font_chooser_set_preview_text(p_fontchooser: *FontChooser, p_text: [*:0]const u8) void;
    pub const setPreviewText = gtk_font_chooser_set_preview_text;

    /// Shows or hides the editable preview entry.
    extern fn gtk_font_chooser_set_show_preview_entry(p_fontchooser: *FontChooser, p_show_preview_entry: c_int) void;
    pub const setShowPreviewEntry = gtk_font_chooser_set_show_preview_entry;

    extern fn gtk_font_chooser_get_type() usize;
    pub const getGObjectType = gtk_font_chooser_get_type;

    extern fn g_object_ref(p_self: *gtk.FontChooser) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.FontChooser) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FontChooser, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.Orientable` interface is implemented by all widgets that can be
/// oriented horizontally or vertically. Historically, such widgets have been
/// realized as subclasses of a common base class (e.g `gtk.Box`/`gtk.HBox`/`gtk.VBox`
/// or `gtk.Scale`/`gtk.HScale`/`gtk.VScale`). `gtk.Orientable` is more flexible in that
/// it allows the orientation to be changed at runtime, allowing the widgets
/// to “flip”.
///
/// `gtk.Orientable` was introduced in GTK+ 2.16.
pub const Orientable = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gtk.OrientableIface;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The orientation of the orientable.
        pub const orientation = struct {
            pub const name = "orientation";

            pub const Type = gtk.Orientation;
        };
    };

    pub const signals = struct {};

    /// Retrieves the orientation of the `orientable`.
    extern fn gtk_orientable_get_orientation(p_orientable: *Orientable) gtk.Orientation;
    pub const getOrientation = gtk_orientable_get_orientation;

    /// Sets the orientation of the `orientable`.
    extern fn gtk_orientable_set_orientation(p_orientable: *Orientable, p_orientation: gtk.Orientation) void;
    pub const setOrientation = gtk_orientable_set_orientation;

    extern fn gtk_orientable_get_type() usize;
    pub const getGObjectType = gtk_orientable_get_type;

    extern fn g_object_ref(p_self: *gtk.Orientable) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Orientable) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Orientable, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PrintOperationPreview = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gtk.PrintOperationPreviewIface;
    pub const virtual_methods = struct {
        /// Ends a preview.
        ///
        /// This function must be called to finish a custom print preview.
        pub const end_preview = struct {
            pub fn call(p_class: anytype, p_preview: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(PrintOperationPreview.Iface, p_class).f_end_preview.?(gobject.ext.as(PrintOperationPreview, p_preview));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_preview: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(PrintOperationPreview.Iface, p_class).f_end_preview = @ptrCast(p_implementation);
            }
        };

        pub const got_page_size = struct {
            pub fn call(p_class: anytype, p_preview: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.PrintContext, p_page_setup: *gtk.PageSetup) void {
                return gobject.ext.as(PrintOperationPreview.Iface, p_class).f_got_page_size.?(gobject.ext.as(PrintOperationPreview, p_preview), p_context, p_page_setup);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_preview: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.PrintContext, p_page_setup: *gtk.PageSetup) callconv(.c) void) void {
                gobject.ext.as(PrintOperationPreview.Iface, p_class).f_got_page_size = @ptrCast(p_implementation);
            }
        };

        /// Returns whether the given page is included in the set of pages that
        /// have been selected for printing.
        pub const is_selected = struct {
            pub fn call(p_class: anytype, p_preview: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_page_nr: c_int) c_int {
                return gobject.ext.as(PrintOperationPreview.Iface, p_class).f_is_selected.?(gobject.ext.as(PrintOperationPreview, p_preview), p_page_nr);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_preview: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_page_nr: c_int) callconv(.c) c_int) void {
                gobject.ext.as(PrintOperationPreview.Iface, p_class).f_is_selected = @ptrCast(p_implementation);
            }
        };

        pub const ready = struct {
            pub fn call(p_class: anytype, p_preview: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.PrintContext) void {
                return gobject.ext.as(PrintOperationPreview.Iface, p_class).f_ready.?(gobject.ext.as(PrintOperationPreview, p_preview), p_context);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_preview: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_context: *gtk.PrintContext) callconv(.c) void) void {
                gobject.ext.as(PrintOperationPreview.Iface, p_class).f_ready = @ptrCast(p_implementation);
            }
        };

        /// Renders a page to the preview, using the print context that
        /// was passed to the `gtk.PrintOperation.signals.preview` handler together
        /// with `preview`.
        ///
        /// A custom iprint preview should use this function in its ::expose
        /// handler to render the currently selected page.
        ///
        /// Note that this function requires a suitable cairo context to
        /// be associated with the print context.
        pub const render_page = struct {
            pub fn call(p_class: anytype, p_preview: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_page_nr: c_int) void {
                return gobject.ext.as(PrintOperationPreview.Iface, p_class).f_render_page.?(gobject.ext.as(PrintOperationPreview, p_preview), p_page_nr);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_preview: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_page_nr: c_int) callconv(.c) void) void {
                gobject.ext.as(PrintOperationPreview.Iface, p_class).f_render_page = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// The ::got-page-size signal is emitted once for each page
        /// that gets rendered to the preview.
        ///
        /// A handler for this signal should update the `context`
        /// according to `page_setup` and set up a suitable cairo
        /// context, using `gtk.PrintContext.setCairoContext`.
        pub const got_page_size = struct {
            pub const name = "got-page-size";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gtk.PrintContext, p_page_setup: *gtk.PageSetup, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PrintOperationPreview, p_instance))),
                    gobject.signalLookup("got-page-size", PrintOperationPreview.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::ready signal gets emitted once per preview operation,
        /// before the first page is rendered.
        ///
        /// A handler for this signal can be used for setup tasks.
        pub const ready = struct {
            pub const name = "ready";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_context: *gtk.PrintContext, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(PrintOperationPreview, p_instance))),
                    gobject.signalLookup("ready", PrintOperationPreview.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Ends a preview.
    ///
    /// This function must be called to finish a custom print preview.
    extern fn gtk_print_operation_preview_end_preview(p_preview: *PrintOperationPreview) void;
    pub const endPreview = gtk_print_operation_preview_end_preview;

    /// Returns whether the given page is included in the set of pages that
    /// have been selected for printing.
    extern fn gtk_print_operation_preview_is_selected(p_preview: *PrintOperationPreview, p_page_nr: c_int) c_int;
    pub const isSelected = gtk_print_operation_preview_is_selected;

    /// Renders a page to the preview, using the print context that
    /// was passed to the `gtk.PrintOperation.signals.preview` handler together
    /// with `preview`.
    ///
    /// A custom iprint preview should use this function in its ::expose
    /// handler to render the currently selected page.
    ///
    /// Note that this function requires a suitable cairo context to
    /// be associated with the print context.
    extern fn gtk_print_operation_preview_render_page(p_preview: *PrintOperationPreview, p_page_nr: c_int) void;
    pub const renderPage = gtk_print_operation_preview_render_page;

    extern fn gtk_print_operation_preview_get_type() usize;
    pub const getGObjectType = gtk_print_operation_preview_get_type;

    extern fn g_object_ref(p_self: *gtk.PrintOperationPreview) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.PrintOperationPreview) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *PrintOperationPreview, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.RecentChooser` is an interface that can be implemented by widgets
/// displaying the list of recently used files.  In GTK+, the main objects
/// that implement this interface are `gtk.RecentChooserWidget`,
/// `gtk.RecentChooserDialog` and `gtk.RecentChooserMenu`.
///
/// Recently used files are supported since GTK+ 2.10.
pub const RecentChooser = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gtk.RecentChooserIface;
    pub const virtual_methods = struct {
        /// Adds `filter` to the list of `gtk.RecentFilter` objects held by `chooser`.
        ///
        /// If no previous filter objects were defined, this function will call
        /// `gtk.RecentChooser.setFilter`.
        pub const add_filter = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_filter: *gtk.RecentFilter) void {
                return gobject.ext.as(RecentChooser.Iface, p_class).f_add_filter.?(gobject.ext.as(RecentChooser, p_chooser), p_filter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_filter: *gtk.RecentFilter) callconv(.c) void) void {
                gobject.ext.as(RecentChooser.Iface, p_class).f_add_filter = @ptrCast(p_implementation);
            }
        };

        /// Gets the URI currently selected by `chooser`.
        pub const get_current_uri = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]u8 {
                return gobject.ext.as(RecentChooser.Iface, p_class).f_get_current_uri.?(gobject.ext.as(RecentChooser, p_chooser));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]u8) void {
                gobject.ext.as(RecentChooser.Iface, p_class).f_get_current_uri = @ptrCast(p_implementation);
            }
        };

        /// Gets the list of recently used resources in form of `gtk.RecentInfo` objects.
        ///
        /// The return value of this function is affected by the “sort-type” and
        /// “limit” properties of `chooser`.
        pub const get_items = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *glib.List {
                return gobject.ext.as(RecentChooser.Iface, p_class).f_get_items.?(gobject.ext.as(RecentChooser, p_chooser));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *glib.List) void {
                gobject.ext.as(RecentChooser.Iface, p_class).f_get_items = @ptrCast(p_implementation);
            }
        };

        /// Gets the `gtk.RecentManager` used by chooser.
        pub const get_recent_manager = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gtk.RecentManager {
                return gobject.ext.as(RecentChooser.Iface, p_class).f_get_recent_manager.?(gobject.ext.as(RecentChooser, p_chooser));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gtk.RecentManager) void {
                gobject.ext.as(RecentChooser.Iface, p_class).f_get_recent_manager = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the user “activates” a recent
        ///    item in the recent chooser.
        pub const item_activated = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(RecentChooser.Iface, p_class).f_item_activated.?(gobject.ext.as(RecentChooser, p_chooser));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(RecentChooser.Iface, p_class).f_item_activated = @ptrCast(p_implementation);
            }
        };

        /// Gets the `gtk.RecentFilter` objects held by `chooser`.
        pub const list_filters = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *glib.SList {
                return gobject.ext.as(RecentChooser.Iface, p_class).f_list_filters.?(gobject.ext.as(RecentChooser, p_chooser));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *glib.SList) void {
                gobject.ext.as(RecentChooser.Iface, p_class).f_list_filters = @ptrCast(p_implementation);
            }
        };

        /// Removes `filter` from the list of `gtk.RecentFilter` objects held by `chooser`.
        pub const remove_filter = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_filter: *gtk.RecentFilter) void {
                return gobject.ext.as(RecentChooser.Iface, p_class).f_remove_filter.?(gobject.ext.as(RecentChooser, p_chooser), p_filter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_filter: *gtk.RecentFilter) callconv(.c) void) void {
                gobject.ext.as(RecentChooser.Iface, p_class).f_remove_filter = @ptrCast(p_implementation);
            }
        };

        /// Selects all the items inside `chooser`, if the `chooser` supports
        /// multiple selection.
        pub const select_all = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(RecentChooser.Iface, p_class).f_select_all.?(gobject.ext.as(RecentChooser, p_chooser));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(RecentChooser.Iface, p_class).f_select_all = @ptrCast(p_implementation);
            }
        };

        /// Selects `uri` inside `chooser`.
        pub const select_uri = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(RecentChooser.Iface, p_class).f_select_uri.?(gobject.ext.as(RecentChooser, p_chooser), p_uri, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(RecentChooser.Iface, p_class).f_select_uri = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when there is a change in the
        ///    set of selected recently used resources.
        pub const selection_changed = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(RecentChooser.Iface, p_class).f_selection_changed.?(gobject.ext.as(RecentChooser, p_chooser));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(RecentChooser.Iface, p_class).f_selection_changed = @ptrCast(p_implementation);
            }
        };

        /// Sets `uri` as the current URI for `chooser`.
        pub const set_current_uri = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(RecentChooser.Iface, p_class).f_set_current_uri.?(gobject.ext.as(RecentChooser, p_chooser), p_uri, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(RecentChooser.Iface, p_class).f_set_current_uri = @ptrCast(p_implementation);
            }
        };

        /// Sets the comparison function used when sorting to be `sort_func`.  If
        /// the `chooser` has the sort type set to `GTK_RECENT_SORT_CUSTOM` then
        /// the chooser will sort using this function.
        ///
        /// To the comparison function will be passed two `gtk.RecentInfo` structs and
        /// `sort_data`;  `sort_func` should return a positive integer if the first
        /// item comes before the second, zero if the two items are equal and
        /// a negative integer if the first item comes after the second.
        pub const set_sort_func = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_sort_func: gtk.RecentSortFunc, p_sort_data: ?*anyopaque, p_data_destroy: ?glib.DestroyNotify) void {
                return gobject.ext.as(RecentChooser.Iface, p_class).f_set_sort_func.?(gobject.ext.as(RecentChooser, p_chooser), p_sort_func, p_sort_data, p_data_destroy);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_sort_func: gtk.RecentSortFunc, p_sort_data: ?*anyopaque, p_data_destroy: ?glib.DestroyNotify) callconv(.c) void) void {
                gobject.ext.as(RecentChooser.Iface, p_class).f_set_sort_func = @ptrCast(p_implementation);
            }
        };

        /// Unselects all the items inside `chooser`.
        pub const unselect_all = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(RecentChooser.Iface, p_class).f_unselect_all.?(gobject.ext.as(RecentChooser, p_chooser));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(RecentChooser.Iface, p_class).f_unselect_all = @ptrCast(p_implementation);
            }
        };

        /// Unselects `uri` inside `chooser`.
        pub const unselect_uri = struct {
            pub fn call(p_class: anytype, p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8) void {
                return gobject.ext.as(RecentChooser.Iface, p_class).f_unselect_uri.?(gobject.ext.as(RecentChooser, p_chooser), p_uri);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_chooser: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(RecentChooser.Iface, p_class).f_unselect_uri = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The `gtk.RecentFilter` object to be used when displaying
        /// the recently used resources.
        pub const filter = struct {
            pub const name = "filter";

            pub const Type = ?*gtk.RecentFilter;
        };

        /// The maximum number of recently used resources to be displayed,
        /// or -1 to display all items.
        pub const limit = struct {
            pub const name = "limit";

            pub const Type = c_int;
        };

        /// Whether this `gtk.RecentChooser` should display only local (file:)
        /// resources.
        pub const local_only = struct {
            pub const name = "local-only";

            pub const Type = c_int;
        };

        /// The `gtk.RecentManager` instance used by the `gtk.RecentChooser` to
        /// display the list of recently used resources.
        pub const recent_manager = struct {
            pub const name = "recent-manager";

            pub const Type = ?*gtk.RecentManager;
        };

        /// Allow the user to select multiple resources.
        pub const select_multiple = struct {
            pub const name = "select-multiple";

            pub const Type = c_int;
        };

        /// Whether this `gtk.RecentChooser` should display an icon near the item.
        pub const show_icons = struct {
            pub const name = "show-icons";

            pub const Type = c_int;
        };

        /// Whether this `gtk.RecentChooser` should display the recently used resources
        /// even if not present anymore. Setting this to `FALSE` will perform a
        /// potentially expensive check on every local resource (every remote
        /// resource will always be displayed).
        pub const show_not_found = struct {
            pub const name = "show-not-found";

            pub const Type = c_int;
        };

        pub const show_private = struct {
            pub const name = "show-private";

            pub const Type = c_int;
        };

        /// Whether this `gtk.RecentChooser` should display a tooltip containing the
        /// full path of the recently used resources.
        pub const show_tips = struct {
            pub const name = "show-tips";

            pub const Type = c_int;
        };

        /// Sorting order to be used when displaying the recently used resources.
        pub const sort_type = struct {
            pub const name = "sort-type";

            pub const Type = gtk.RecentSortType;
        };
    };

    pub const signals = struct {
        /// This signal is emitted when the user "activates" a recent item
        /// in the recent chooser.  This can happen by double-clicking on an item
        /// in the recently used resources list, or by pressing
        /// `Enter`.
        pub const item_activated = struct {
            pub const name = "item-activated";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(RecentChooser, p_instance))),
                    gobject.signalLookup("item-activated", RecentChooser.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when there is a change in the set of
        /// selected recently used resources.  This can happen when a user
        /// modifies the selection with the mouse or the keyboard, or when
        /// explicitly calling functions to change the selection.
        pub const selection_changed = struct {
            pub const name = "selection-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(RecentChooser, p_instance))),
                    gobject.signalLookup("selection-changed", RecentChooser.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Adds `filter` to the list of `gtk.RecentFilter` objects held by `chooser`.
    ///
    /// If no previous filter objects were defined, this function will call
    /// `gtk.RecentChooser.setFilter`.
    extern fn gtk_recent_chooser_add_filter(p_chooser: *RecentChooser, p_filter: *gtk.RecentFilter) void;
    pub const addFilter = gtk_recent_chooser_add_filter;

    /// Gets the `gtk.RecentInfo` currently selected by `chooser`.
    extern fn gtk_recent_chooser_get_current_item(p_chooser: *RecentChooser) *gtk.RecentInfo;
    pub const getCurrentItem = gtk_recent_chooser_get_current_item;

    /// Gets the URI currently selected by `chooser`.
    extern fn gtk_recent_chooser_get_current_uri(p_chooser: *RecentChooser) [*:0]u8;
    pub const getCurrentUri = gtk_recent_chooser_get_current_uri;

    /// Gets the `gtk.RecentFilter` object currently used by `chooser` to affect
    /// the display of the recently used resources.
    extern fn gtk_recent_chooser_get_filter(p_chooser: *RecentChooser) *gtk.RecentFilter;
    pub const getFilter = gtk_recent_chooser_get_filter;

    /// Gets the list of recently used resources in form of `gtk.RecentInfo` objects.
    ///
    /// The return value of this function is affected by the “sort-type” and
    /// “limit” properties of `chooser`.
    extern fn gtk_recent_chooser_get_items(p_chooser: *RecentChooser) *glib.List;
    pub const getItems = gtk_recent_chooser_get_items;

    /// Gets the number of items returned by `gtk.RecentChooser.getItems`
    /// and `gtk.RecentChooser.getUris`.
    extern fn gtk_recent_chooser_get_limit(p_chooser: *RecentChooser) c_int;
    pub const getLimit = gtk_recent_chooser_get_limit;

    /// Gets whether only local resources should be shown in the recently used
    /// resources selector.  See `gtk.RecentChooser.setLocalOnly`
    extern fn gtk_recent_chooser_get_local_only(p_chooser: *RecentChooser) c_int;
    pub const getLocalOnly = gtk_recent_chooser_get_local_only;

    /// Gets whether `chooser` can select multiple items.
    extern fn gtk_recent_chooser_get_select_multiple(p_chooser: *RecentChooser) c_int;
    pub const getSelectMultiple = gtk_recent_chooser_get_select_multiple;

    /// Retrieves whether `chooser` should show an icon near the resource.
    extern fn gtk_recent_chooser_get_show_icons(p_chooser: *RecentChooser) c_int;
    pub const getShowIcons = gtk_recent_chooser_get_show_icons;

    /// Retrieves whether `chooser` should show the recently used resources that
    /// were not found.
    extern fn gtk_recent_chooser_get_show_not_found(p_chooser: *RecentChooser) c_int;
    pub const getShowNotFound = gtk_recent_chooser_get_show_not_found;

    /// Returns whether `chooser` should display recently used resources
    /// registered as private.
    extern fn gtk_recent_chooser_get_show_private(p_chooser: *RecentChooser) c_int;
    pub const getShowPrivate = gtk_recent_chooser_get_show_private;

    /// Gets whether `chooser` should display tooltips containing the full path
    /// of a recently user resource.
    extern fn gtk_recent_chooser_get_show_tips(p_chooser: *RecentChooser) c_int;
    pub const getShowTips = gtk_recent_chooser_get_show_tips;

    /// Gets the value set by `gtk.RecentChooser.setSortType`.
    extern fn gtk_recent_chooser_get_sort_type(p_chooser: *RecentChooser) gtk.RecentSortType;
    pub const getSortType = gtk_recent_chooser_get_sort_type;

    /// Gets the URI of the recently used resources.
    ///
    /// The return value of this function is affected by the “sort-type” and “limit”
    /// properties of `chooser`.
    ///
    /// Since the returned array is `NULL` terminated, `length` may be `NULL`.
    extern fn gtk_recent_chooser_get_uris(p_chooser: *RecentChooser, p_length: ?*usize) [*:null]?[*:0]u8;
    pub const getUris = gtk_recent_chooser_get_uris;

    /// Gets the `gtk.RecentFilter` objects held by `chooser`.
    extern fn gtk_recent_chooser_list_filters(p_chooser: *RecentChooser) *glib.SList;
    pub const listFilters = gtk_recent_chooser_list_filters;

    /// Removes `filter` from the list of `gtk.RecentFilter` objects held by `chooser`.
    extern fn gtk_recent_chooser_remove_filter(p_chooser: *RecentChooser, p_filter: *gtk.RecentFilter) void;
    pub const removeFilter = gtk_recent_chooser_remove_filter;

    /// Selects all the items inside `chooser`, if the `chooser` supports
    /// multiple selection.
    extern fn gtk_recent_chooser_select_all(p_chooser: *RecentChooser) void;
    pub const selectAll = gtk_recent_chooser_select_all;

    /// Selects `uri` inside `chooser`.
    extern fn gtk_recent_chooser_select_uri(p_chooser: *RecentChooser, p_uri: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const selectUri = gtk_recent_chooser_select_uri;

    /// Sets `uri` as the current URI for `chooser`.
    extern fn gtk_recent_chooser_set_current_uri(p_chooser: *RecentChooser, p_uri: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const setCurrentUri = gtk_recent_chooser_set_current_uri;

    /// Sets `filter` as the current `gtk.RecentFilter` object used by `chooser`
    /// to affect the displayed recently used resources.
    extern fn gtk_recent_chooser_set_filter(p_chooser: *RecentChooser, p_filter: ?*gtk.RecentFilter) void;
    pub const setFilter = gtk_recent_chooser_set_filter;

    /// Sets the number of items that should be returned by
    /// `gtk.RecentChooser.getItems` and `gtk.RecentChooser.getUris`.
    extern fn gtk_recent_chooser_set_limit(p_chooser: *RecentChooser, p_limit: c_int) void;
    pub const setLimit = gtk_recent_chooser_set_limit;

    /// Sets whether only local resources, that is resources using the file:// URI
    /// scheme, should be shown in the recently used resources selector.  If
    /// `local_only` is `TRUE` (the default) then the shown resources are guaranteed
    /// to be accessible through the operating system native file system.
    extern fn gtk_recent_chooser_set_local_only(p_chooser: *RecentChooser, p_local_only: c_int) void;
    pub const setLocalOnly = gtk_recent_chooser_set_local_only;

    /// Sets whether `chooser` can select multiple items.
    extern fn gtk_recent_chooser_set_select_multiple(p_chooser: *RecentChooser, p_select_multiple: c_int) void;
    pub const setSelectMultiple = gtk_recent_chooser_set_select_multiple;

    /// Sets whether `chooser` should show an icon near the resource when
    /// displaying it.
    extern fn gtk_recent_chooser_set_show_icons(p_chooser: *RecentChooser, p_show_icons: c_int) void;
    pub const setShowIcons = gtk_recent_chooser_set_show_icons;

    /// Sets whether `chooser` should display the recently used resources that
    /// it didn’t find.  This only applies to local resources.
    extern fn gtk_recent_chooser_set_show_not_found(p_chooser: *RecentChooser, p_show_not_found: c_int) void;
    pub const setShowNotFound = gtk_recent_chooser_set_show_not_found;

    /// Whether to show recently used resources marked registered as private.
    extern fn gtk_recent_chooser_set_show_private(p_chooser: *RecentChooser, p_show_private: c_int) void;
    pub const setShowPrivate = gtk_recent_chooser_set_show_private;

    /// Sets whether to show a tooltips containing the full path of each
    /// recently used resource in a `gtk.RecentChooser` widget.
    extern fn gtk_recent_chooser_set_show_tips(p_chooser: *RecentChooser, p_show_tips: c_int) void;
    pub const setShowTips = gtk_recent_chooser_set_show_tips;

    /// Sets the comparison function used when sorting to be `sort_func`.  If
    /// the `chooser` has the sort type set to `GTK_RECENT_SORT_CUSTOM` then
    /// the chooser will sort using this function.
    ///
    /// To the comparison function will be passed two `gtk.RecentInfo` structs and
    /// `sort_data`;  `sort_func` should return a positive integer if the first
    /// item comes before the second, zero if the two items are equal and
    /// a negative integer if the first item comes after the second.
    extern fn gtk_recent_chooser_set_sort_func(p_chooser: *RecentChooser, p_sort_func: gtk.RecentSortFunc, p_sort_data: ?*anyopaque, p_data_destroy: ?glib.DestroyNotify) void;
    pub const setSortFunc = gtk_recent_chooser_set_sort_func;

    /// Changes the sorting order of the recently used resources list displayed by
    /// `chooser`.
    extern fn gtk_recent_chooser_set_sort_type(p_chooser: *RecentChooser, p_sort_type: gtk.RecentSortType) void;
    pub const setSortType = gtk_recent_chooser_set_sort_type;

    /// Unselects all the items inside `chooser`.
    extern fn gtk_recent_chooser_unselect_all(p_chooser: *RecentChooser) void;
    pub const unselectAll = gtk_recent_chooser_unselect_all;

    /// Unselects `uri` inside `chooser`.
    extern fn gtk_recent_chooser_unselect_uri(p_chooser: *RecentChooser, p_uri: [*:0]const u8) void;
    pub const unselectUri = gtk_recent_chooser_unselect_uri;

    extern fn gtk_recent_chooser_get_type() usize;
    pub const getGObjectType = gtk_recent_chooser_get_type;

    extern fn g_object_ref(p_self: *gtk.RecentChooser) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.RecentChooser) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RecentChooser, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.Scrollable` is an interface that is implemented by widgets with native
/// scrolling ability.
///
/// To implement this interface you should override the
/// `gtk.Scrollable.properties.hadjustment` and `gtk.Scrollable.properties.vadjustment` properties.
///
/// ## Creating a scrollable widget
///
/// All scrollable widgets should do the following.
///
/// - When a parent widget sets the scrollable child widget’s adjustments,
///   the widget should populate the adjustments’
///   `gtk.Adjustment.properties.lower`, `gtk.Adjustment.properties.upper`,
///   `gtk.Adjustment.properties.step`-increment, `gtk.Adjustment.properties.page`-increment and
///   `gtk.Adjustment.properties.page`-size properties and connect to the
///   `gtk.Adjustment.signals.value`-changed signal.
///
/// - Because its preferred size is the size for a fully expanded widget,
///   the scrollable widget must be able to cope with underallocations.
///   This means that it must accept any value passed to its
///   `gtk.WidgetClass.virtual_methods.size_allocate` function.
///
/// - When the parent allocates space to the scrollable child widget,
///   the widget should update the adjustments’ properties with new values.
///
/// - When any of the adjustments emits the `gtk.Adjustment.signals.value`-changed signal,
///   the scrollable widget should scroll its contents.
pub const Scrollable = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gtk.ScrollableInterface;
    pub const virtual_methods = struct {
        /// Returns the size of a non-scrolling border around the
        /// outside of the scrollable. An example for this would
        /// be treeview headers. GTK+ can use this information to
        /// display overlayed graphics, like the overshoot indication,
        /// at the right position.
        pub const get_border = struct {
            pub fn call(p_class: anytype, p_scrollable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_border: *gtk.Border) c_int {
                return gobject.ext.as(Scrollable.Iface, p_class).f_get_border.?(gobject.ext.as(Scrollable, p_scrollable), p_border);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_scrollable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_border: *gtk.Border) callconv(.c) c_int) void {
                gobject.ext.as(Scrollable.Iface, p_class).f_get_border = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Horizontal `gtk.Adjustment` of the scrollable widget. This adjustment is
        /// shared between the scrollable widget and its parent.
        pub const hadjustment = struct {
            pub const name = "hadjustment";

            pub const Type = ?*gtk.Adjustment;
        };

        /// Determines whether horizontal scrolling should start once the scrollable
        /// widget is allocated less than its minimum width or less than its natural width.
        pub const hscroll_policy = struct {
            pub const name = "hscroll-policy";

            pub const Type = gtk.ScrollablePolicy;
        };

        /// Verical `gtk.Adjustment` of the scrollable widget. This adjustment is shared
        /// between the scrollable widget and its parent.
        pub const vadjustment = struct {
            pub const name = "vadjustment";

            pub const Type = ?*gtk.Adjustment;
        };

        /// Determines whether vertical scrolling should start once the scrollable
        /// widget is allocated less than its minimum height or less than its natural height.
        pub const vscroll_policy = struct {
            pub const name = "vscroll-policy";

            pub const Type = gtk.ScrollablePolicy;
        };
    };

    pub const signals = struct {};

    /// Returns the size of a non-scrolling border around the
    /// outside of the scrollable. An example for this would
    /// be treeview headers. GTK+ can use this information to
    /// display overlayed graphics, like the overshoot indication,
    /// at the right position.
    extern fn gtk_scrollable_get_border(p_scrollable: *Scrollable, p_border: *gtk.Border) c_int;
    pub const getBorder = gtk_scrollable_get_border;

    /// Retrieves the `gtk.Adjustment` used for horizontal scrolling.
    extern fn gtk_scrollable_get_hadjustment(p_scrollable: *Scrollable) *gtk.Adjustment;
    pub const getHadjustment = gtk_scrollable_get_hadjustment;

    /// Gets the horizontal `gtk.ScrollablePolicy`.
    extern fn gtk_scrollable_get_hscroll_policy(p_scrollable: *Scrollable) gtk.ScrollablePolicy;
    pub const getHscrollPolicy = gtk_scrollable_get_hscroll_policy;

    /// Retrieves the `gtk.Adjustment` used for vertical scrolling.
    extern fn gtk_scrollable_get_vadjustment(p_scrollable: *Scrollable) *gtk.Adjustment;
    pub const getVadjustment = gtk_scrollable_get_vadjustment;

    /// Gets the vertical `gtk.ScrollablePolicy`.
    extern fn gtk_scrollable_get_vscroll_policy(p_scrollable: *Scrollable) gtk.ScrollablePolicy;
    pub const getVscrollPolicy = gtk_scrollable_get_vscroll_policy;

    /// Sets the horizontal adjustment of the `gtk.Scrollable`.
    extern fn gtk_scrollable_set_hadjustment(p_scrollable: *Scrollable, p_hadjustment: ?*gtk.Adjustment) void;
    pub const setHadjustment = gtk_scrollable_set_hadjustment;

    /// Sets the `gtk.ScrollablePolicy` to determine whether
    /// horizontal scrolling should start below the minimum width or
    /// below the natural width.
    extern fn gtk_scrollable_set_hscroll_policy(p_scrollable: *Scrollable, p_policy: gtk.ScrollablePolicy) void;
    pub const setHscrollPolicy = gtk_scrollable_set_hscroll_policy;

    /// Sets the vertical adjustment of the `gtk.Scrollable`.
    extern fn gtk_scrollable_set_vadjustment(p_scrollable: *Scrollable, p_vadjustment: ?*gtk.Adjustment) void;
    pub const setVadjustment = gtk_scrollable_set_vadjustment;

    /// Sets the `gtk.ScrollablePolicy` to determine whether
    /// vertical scrolling should start below the minimum height or
    /// below the natural height.
    extern fn gtk_scrollable_set_vscroll_policy(p_scrollable: *Scrollable, p_policy: gtk.ScrollablePolicy) void;
    pub const setVscrollPolicy = gtk_scrollable_set_vscroll_policy;

    extern fn gtk_scrollable_get_type() usize;
    pub const getGObjectType = gtk_scrollable_get_type;

    extern fn g_object_ref(p_self: *gtk.Scrollable) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.Scrollable) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Scrollable, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkStyleProvider is an interface used to provide style information to a `gtk.StyleContext`.
/// See `gtk.StyleContext.addProvider` and `gtk.StyleContext.addProviderForScreen`.
pub const StyleProvider = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gtk.StyleProviderIface;
    pub const virtual_methods = struct {
        /// Returns the `gtk.IconFactory` defined to be in use for `path`, or `NULL` if none
        /// is defined.
        pub const get_icon_factory = struct {
            pub fn call(p_class: anytype, p_provider: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.WidgetPath) ?*gtk.IconFactory {
                return gobject.ext.as(StyleProvider.Iface, p_class).f_get_icon_factory.?(gobject.ext.as(StyleProvider, p_provider), p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_provider: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.WidgetPath) callconv(.c) ?*gtk.IconFactory) void {
                gobject.ext.as(StyleProvider.Iface, p_class).f_get_icon_factory = @ptrCast(p_implementation);
            }
        };

        /// Returns the style settings affecting a widget defined by `path`, or `NULL` if
        /// `provider` doesn’t contemplate styling `path`.
        pub const get_style = struct {
            pub fn call(p_class: anytype, p_provider: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.WidgetPath) ?*gtk.StyleProperties {
                return gobject.ext.as(StyleProvider.Iface, p_class).f_get_style.?(gobject.ext.as(StyleProvider, p_provider), p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_provider: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.WidgetPath) callconv(.c) ?*gtk.StyleProperties) void {
                gobject.ext.as(StyleProvider.Iface, p_class).f_get_style = @ptrCast(p_implementation);
            }
        };

        /// Looks up a widget style property as defined by `provider` for
        /// the widget represented by `path`.
        pub const get_style_property = struct {
            pub fn call(p_class: anytype, p_provider: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.WidgetPath, p_state: gtk.StateFlags, p_pspec: *gobject.ParamSpec, p_value: *gobject.Value) c_int {
                return gobject.ext.as(StyleProvider.Iface, p_class).f_get_style_property.?(gobject.ext.as(StyleProvider, p_provider), p_path, p_state, p_pspec, p_value);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_provider: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.WidgetPath, p_state: gtk.StateFlags, p_pspec: *gobject.ParamSpec, p_value: *gobject.Value) callconv(.c) c_int) void {
                gobject.ext.as(StyleProvider.Iface, p_class).f_get_style_property = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Returns the `gtk.IconFactory` defined to be in use for `path`, or `NULL` if none
    /// is defined.
    extern fn gtk_style_provider_get_icon_factory(p_provider: *StyleProvider, p_path: *gtk.WidgetPath) ?*gtk.IconFactory;
    pub const getIconFactory = gtk_style_provider_get_icon_factory;

    /// Returns the style settings affecting a widget defined by `path`, or `NULL` if
    /// `provider` doesn’t contemplate styling `path`.
    extern fn gtk_style_provider_get_style(p_provider: *StyleProvider, p_path: *gtk.WidgetPath) ?*gtk.StyleProperties;
    pub const getStyle = gtk_style_provider_get_style;

    /// Looks up a widget style property as defined by `provider` for
    /// the widget represented by `path`.
    extern fn gtk_style_provider_get_style_property(p_provider: *StyleProvider, p_path: *gtk.WidgetPath, p_state: gtk.StateFlags, p_pspec: *gobject.ParamSpec, p_value: *gobject.Value) c_int;
    pub const getStyleProperty = gtk_style_provider_get_style_property;

    extern fn gtk_style_provider_get_type() usize;
    pub const getGObjectType = gtk_style_provider_get_type;

    extern fn g_object_ref(p_self: *gtk.StyleProvider) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.StyleProvider) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *StyleProvider, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.ToolShell` interface allows container widgets to provide additional
/// information when embedding `gtk.ToolItem` widgets.
pub const ToolShell = opaque {
    pub const Prerequisites = [_]type{gtk.Widget};
    pub const Iface = gtk.ToolShellIface;
    pub const virtual_methods = struct {
        /// Retrieves the current ellipsize mode for the tool shell. Tool items must not
        /// call this function directly, but rely on `gtk.ToolItem.getEllipsizeMode`
        /// instead.
        pub const get_ellipsize_mode = struct {
            pub fn call(p_class: anytype, p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) pango.EllipsizeMode {
                return gobject.ext.as(ToolShell.Iface, p_class).f_get_ellipsize_mode.?(gobject.ext.as(ToolShell, p_shell));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) pango.EllipsizeMode) void {
                gobject.ext.as(ToolShell.Iface, p_class).f_get_ellipsize_mode = @ptrCast(p_implementation);
            }
        };

        /// mandatory implementation of `gtk.ToolShell.getIconSize`.
        pub const get_icon_size = struct {
            pub fn call(p_class: anytype, p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) gtk.IconSize {
                return gobject.ext.as(ToolShell.Iface, p_class).f_get_icon_size.?(gobject.ext.as(ToolShell, p_shell));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) gtk.IconSize) void {
                gobject.ext.as(ToolShell.Iface, p_class).f_get_icon_size = @ptrCast(p_implementation);
            }
        };

        /// Retrieves the current orientation for the tool shell. Tool items must not
        /// call this function directly, but rely on `gtk.ToolItem.getOrientation`
        /// instead.
        pub const get_orientation = struct {
            pub fn call(p_class: anytype, p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) gtk.Orientation {
                return gobject.ext.as(ToolShell.Iface, p_class).f_get_orientation.?(gobject.ext.as(ToolShell, p_shell));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) gtk.Orientation) void {
                gobject.ext.as(ToolShell.Iface, p_class).f_get_orientation = @ptrCast(p_implementation);
            }
        };

        /// Returns the relief style of buttons on `shell`. Tool items must not call this
        /// function directly, but rely on `gtk.ToolItem.getReliefStyle` instead.
        pub const get_relief_style = struct {
            pub fn call(p_class: anytype, p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) gtk.ReliefStyle {
                return gobject.ext.as(ToolShell.Iface, p_class).f_get_relief_style.?(gobject.ext.as(ToolShell, p_shell));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) gtk.ReliefStyle) void {
                gobject.ext.as(ToolShell.Iface, p_class).f_get_relief_style = @ptrCast(p_implementation);
            }
        };

        /// Retrieves whether the tool shell has text, icons, or both. Tool items must
        /// not call this function directly, but rely on `gtk.ToolItem.getToolbarStyle`
        /// instead.
        pub const get_style = struct {
            pub fn call(p_class: anytype, p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) gtk.ToolbarStyle {
                return gobject.ext.as(ToolShell.Iface, p_class).f_get_style.?(gobject.ext.as(ToolShell, p_shell));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) gtk.ToolbarStyle) void {
                gobject.ext.as(ToolShell.Iface, p_class).f_get_style = @ptrCast(p_implementation);
            }
        };

        /// Retrieves the current text alignment for the tool shell. Tool items must not
        /// call this function directly, but rely on `gtk.ToolItem.getTextAlignment`
        /// instead.
        pub const get_text_alignment = struct {
            pub fn call(p_class: anytype, p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) f32 {
                return gobject.ext.as(ToolShell.Iface, p_class).f_get_text_alignment.?(gobject.ext.as(ToolShell, p_shell));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) f32) void {
                gobject.ext.as(ToolShell.Iface, p_class).f_get_text_alignment = @ptrCast(p_implementation);
            }
        };

        /// Retrieves the current text orientation for the tool shell. Tool items must not
        /// call this function directly, but rely on `gtk.ToolItem.getTextOrientation`
        /// instead.
        pub const get_text_orientation = struct {
            pub fn call(p_class: anytype, p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) gtk.Orientation {
                return gobject.ext.as(ToolShell.Iface, p_class).f_get_text_orientation.?(gobject.ext.as(ToolShell, p_shell));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) gtk.Orientation) void {
                gobject.ext.as(ToolShell.Iface, p_class).f_get_text_orientation = @ptrCast(p_implementation);
            }
        };

        /// Retrieves the current text size group for the tool shell. Tool items must not
        /// call this function directly, but rely on `gtk.ToolItem.getTextSizeGroup`
        /// instead.
        pub const get_text_size_group = struct {
            pub fn call(p_class: anytype, p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gtk.SizeGroup {
                return gobject.ext.as(ToolShell.Iface, p_class).f_get_text_size_group.?(gobject.ext.as(ToolShell, p_shell));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gtk.SizeGroup) void {
                gobject.ext.as(ToolShell.Iface, p_class).f_get_text_size_group = @ptrCast(p_implementation);
            }
        };

        /// Calling this function signals the tool shell that the overflow menu item for
        /// tool items have changed. If there is an overflow menu and if it is visible
        /// when this function it called, the menu will be rebuilt.
        ///
        /// Tool items must not call this function directly, but rely on
        /// `gtk.ToolItem.rebuildMenu` instead.
        pub const rebuild_menu = struct {
            pub fn call(p_class: anytype, p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ToolShell.Iface, p_class).f_rebuild_menu.?(gobject.ext.as(ToolShell, p_shell));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_shell: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ToolShell.Iface, p_class).f_rebuild_menu = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Retrieves the current ellipsize mode for the tool shell. Tool items must not
    /// call this function directly, but rely on `gtk.ToolItem.getEllipsizeMode`
    /// instead.
    extern fn gtk_tool_shell_get_ellipsize_mode(p_shell: *ToolShell) pango.EllipsizeMode;
    pub const getEllipsizeMode = gtk_tool_shell_get_ellipsize_mode;

    /// Retrieves the icon size for the tool shell. Tool items must not call this
    /// function directly, but rely on `gtk.ToolItem.getIconSize` instead.
    extern fn gtk_tool_shell_get_icon_size(p_shell: *ToolShell) c_int;
    pub const getIconSize = gtk_tool_shell_get_icon_size;

    /// Retrieves the current orientation for the tool shell. Tool items must not
    /// call this function directly, but rely on `gtk.ToolItem.getOrientation`
    /// instead.
    extern fn gtk_tool_shell_get_orientation(p_shell: *ToolShell) gtk.Orientation;
    pub const getOrientation = gtk_tool_shell_get_orientation;

    /// Returns the relief style of buttons on `shell`. Tool items must not call this
    /// function directly, but rely on `gtk.ToolItem.getReliefStyle` instead.
    extern fn gtk_tool_shell_get_relief_style(p_shell: *ToolShell) gtk.ReliefStyle;
    pub const getReliefStyle = gtk_tool_shell_get_relief_style;

    /// Retrieves whether the tool shell has text, icons, or both. Tool items must
    /// not call this function directly, but rely on `gtk.ToolItem.getToolbarStyle`
    /// instead.
    extern fn gtk_tool_shell_get_style(p_shell: *ToolShell) gtk.ToolbarStyle;
    pub const getStyle = gtk_tool_shell_get_style;

    /// Retrieves the current text alignment for the tool shell. Tool items must not
    /// call this function directly, but rely on `gtk.ToolItem.getTextAlignment`
    /// instead.
    extern fn gtk_tool_shell_get_text_alignment(p_shell: *ToolShell) f32;
    pub const getTextAlignment = gtk_tool_shell_get_text_alignment;

    /// Retrieves the current text orientation for the tool shell. Tool items must not
    /// call this function directly, but rely on `gtk.ToolItem.getTextOrientation`
    /// instead.
    extern fn gtk_tool_shell_get_text_orientation(p_shell: *ToolShell) gtk.Orientation;
    pub const getTextOrientation = gtk_tool_shell_get_text_orientation;

    /// Retrieves the current text size group for the tool shell. Tool items must not
    /// call this function directly, but rely on `gtk.ToolItem.getTextSizeGroup`
    /// instead.
    extern fn gtk_tool_shell_get_text_size_group(p_shell: *ToolShell) *gtk.SizeGroup;
    pub const getTextSizeGroup = gtk_tool_shell_get_text_size_group;

    /// Calling this function signals the tool shell that the overflow menu item for
    /// tool items have changed. If there is an overflow menu and if it is visible
    /// when this function it called, the menu will be rebuilt.
    ///
    /// Tool items must not call this function directly, but rely on
    /// `gtk.ToolItem.rebuildMenu` instead.
    extern fn gtk_tool_shell_rebuild_menu(p_shell: *ToolShell) void;
    pub const rebuildMenu = gtk_tool_shell_rebuild_menu;

    extern fn gtk_tool_shell_get_type() usize;
    pub const getGObjectType = gtk_tool_shell_get_type;

    extern fn g_object_ref(p_self: *gtk.ToolShell) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.ToolShell) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ToolShell, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeDragDest = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gtk.TreeDragDestIface;
    pub const virtual_methods = struct {
        /// Asks the `gtk.TreeDragDest` to insert a row before the path `dest`,
        /// deriving the contents of the row from `selection_data`. If `dest` is
        /// outside the tree so that inserting before it is impossible, `FALSE`
        /// will be returned. Also, `FALSE` may be returned if the new row is
        /// not created for some model-specific reason.  Should robustly handle
        /// a `dest` no longer found in the model!
        pub const drag_data_received = struct {
            pub fn call(p_class: anytype, p_drag_dest: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_dest: *gtk.TreePath, p_selection_data: *gtk.SelectionData) c_int {
                return gobject.ext.as(TreeDragDest.Iface, p_class).f_drag_data_received.?(gobject.ext.as(TreeDragDest, p_drag_dest), p_dest, p_selection_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drag_dest: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_dest: *gtk.TreePath, p_selection_data: *gtk.SelectionData) callconv(.c) c_int) void {
                gobject.ext.as(TreeDragDest.Iface, p_class).f_drag_data_received = @ptrCast(p_implementation);
            }
        };

        /// Determines whether a drop is possible before the given `dest_path`,
        /// at the same depth as `dest_path`. i.e., can we drop the data in
        /// `selection_data` at that location. `dest_path` does not have to
        /// exist; the return value will almost certainly be `FALSE` if the
        /// parent of `dest_path` doesn’t exist, though.
        pub const row_drop_possible = struct {
            pub fn call(p_class: anytype, p_drag_dest: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_dest_path: *gtk.TreePath, p_selection_data: *gtk.SelectionData) c_int {
                return gobject.ext.as(TreeDragDest.Iface, p_class).f_row_drop_possible.?(gobject.ext.as(TreeDragDest, p_drag_dest), p_dest_path, p_selection_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drag_dest: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_dest_path: *gtk.TreePath, p_selection_data: *gtk.SelectionData) callconv(.c) c_int) void {
                gobject.ext.as(TreeDragDest.Iface, p_class).f_row_drop_possible = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Asks the `gtk.TreeDragDest` to insert a row before the path `dest`,
    /// deriving the contents of the row from `selection_data`. If `dest` is
    /// outside the tree so that inserting before it is impossible, `FALSE`
    /// will be returned. Also, `FALSE` may be returned if the new row is
    /// not created for some model-specific reason.  Should robustly handle
    /// a `dest` no longer found in the model!
    extern fn gtk_tree_drag_dest_drag_data_received(p_drag_dest: *TreeDragDest, p_dest: *gtk.TreePath, p_selection_data: *gtk.SelectionData) c_int;
    pub const dragDataReceived = gtk_tree_drag_dest_drag_data_received;

    /// Determines whether a drop is possible before the given `dest_path`,
    /// at the same depth as `dest_path`. i.e., can we drop the data in
    /// `selection_data` at that location. `dest_path` does not have to
    /// exist; the return value will almost certainly be `FALSE` if the
    /// parent of `dest_path` doesn’t exist, though.
    extern fn gtk_tree_drag_dest_row_drop_possible(p_drag_dest: *TreeDragDest, p_dest_path: *gtk.TreePath, p_selection_data: *gtk.SelectionData) c_int;
    pub const rowDropPossible = gtk_tree_drag_dest_row_drop_possible;

    extern fn gtk_tree_drag_dest_get_type() usize;
    pub const getGObjectType = gtk_tree_drag_dest_get_type;

    extern fn g_object_ref(p_self: *gtk.TreeDragDest) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TreeDragDest) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TreeDragDest, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeDragSource = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gtk.TreeDragSourceIface;
    pub const virtual_methods = struct {
        /// Asks the `gtk.TreeDragSource` to delete the row at `path`, because
        /// it was moved somewhere else via drag-and-drop. Returns `FALSE`
        /// if the deletion fails because `path` no longer exists, or for
        /// some model-specific reason. Should robustly handle a `path` no
        /// longer found in the model!
        pub const drag_data_delete = struct {
            pub fn call(p_class: anytype, p_drag_source: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath) c_int {
                return gobject.ext.as(TreeDragSource.Iface, p_class).f_drag_data_delete.?(gobject.ext.as(TreeDragSource, p_drag_source), p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drag_source: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath) callconv(.c) c_int) void {
                gobject.ext.as(TreeDragSource.Iface, p_class).f_drag_data_delete = @ptrCast(p_implementation);
            }
        };

        /// Asks the `gtk.TreeDragSource` to fill in `selection_data` with a
        /// representation of the row at `path`. `selection_data`->target gives
        /// the required type of the data.  Should robustly handle a `path` no
        /// longer found in the model!
        pub const drag_data_get = struct {
            pub fn call(p_class: anytype, p_drag_source: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath, p_selection_data: *gtk.SelectionData) c_int {
                return gobject.ext.as(TreeDragSource.Iface, p_class).f_drag_data_get.?(gobject.ext.as(TreeDragSource, p_drag_source), p_path, p_selection_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drag_source: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath, p_selection_data: *gtk.SelectionData) callconv(.c) c_int) void {
                gobject.ext.as(TreeDragSource.Iface, p_class).f_drag_data_get = @ptrCast(p_implementation);
            }
        };

        /// Asks the `gtk.TreeDragSource` whether a particular row can be used as
        /// the source of a DND operation. If the source doesn’t implement
        /// this interface, the row is assumed draggable.
        pub const row_draggable = struct {
            pub fn call(p_class: anytype, p_drag_source: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath) c_int {
                return gobject.ext.as(TreeDragSource.Iface, p_class).f_row_draggable.?(gobject.ext.as(TreeDragSource, p_drag_source), p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drag_source: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath) callconv(.c) c_int) void {
                gobject.ext.as(TreeDragSource.Iface, p_class).f_row_draggable = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Asks the `gtk.TreeDragSource` to delete the row at `path`, because
    /// it was moved somewhere else via drag-and-drop. Returns `FALSE`
    /// if the deletion fails because `path` no longer exists, or for
    /// some model-specific reason. Should robustly handle a `path` no
    /// longer found in the model!
    extern fn gtk_tree_drag_source_drag_data_delete(p_drag_source: *TreeDragSource, p_path: *gtk.TreePath) c_int;
    pub const dragDataDelete = gtk_tree_drag_source_drag_data_delete;

    /// Asks the `gtk.TreeDragSource` to fill in `selection_data` with a
    /// representation of the row at `path`. `selection_data`->target gives
    /// the required type of the data.  Should robustly handle a `path` no
    /// longer found in the model!
    extern fn gtk_tree_drag_source_drag_data_get(p_drag_source: *TreeDragSource, p_path: *gtk.TreePath, p_selection_data: *gtk.SelectionData) c_int;
    pub const dragDataGet = gtk_tree_drag_source_drag_data_get;

    /// Asks the `gtk.TreeDragSource` whether a particular row can be used as
    /// the source of a DND operation. If the source doesn’t implement
    /// this interface, the row is assumed draggable.
    extern fn gtk_tree_drag_source_row_draggable(p_drag_source: *TreeDragSource, p_path: *gtk.TreePath) c_int;
    pub const rowDraggable = gtk_tree_drag_source_row_draggable;

    extern fn gtk_tree_drag_source_get_type() usize;
    pub const getGObjectType = gtk_tree_drag_source_get_type;

    extern fn g_object_ref(p_self: *gtk.TreeDragSource) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TreeDragSource) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TreeDragSource, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.TreeModel` interface defines a generic tree interface for
/// use by the `gtk.TreeView` widget. It is an abstract interface, and
/// is designed to be usable with any appropriate data structure. The
/// programmer just has to implement this interface on their own data
/// type for it to be viewable by a `gtk.TreeView` widget.
///
/// The model is represented as a hierarchical tree of strongly-typed,
/// columned data. In other words, the model can be seen as a tree where
/// every node has different values depending on which column is being
/// queried. The type of data found in a column is determined by using
/// the GType system (ie. `G_TYPE_INT`, `GTK_TYPE_BUTTON`, `G_TYPE_POINTER`,
/// etc). The types are homogeneous per column across all nodes. It is
/// important to note that this interface only provides a way of examining
/// a model and observing changes. The implementation of each individual
/// model decides how and if changes are made.
///
/// In order to make life simpler for programmers who do not need to
/// write their own specialized model, two generic models are provided
/// — the `gtk.TreeStore` and the `gtk.ListStore`. To use these, the
/// developer simply pushes data into these models as necessary. These
/// models provide the data structure as well as all appropriate tree
/// interfaces. As a result, implementing drag and drop, sorting, and
/// storing data is trivial. For the vast majority of trees and lists,
/// these two models are sufficient.
///
/// Models are accessed on a node/column level of granularity. One can
/// query for the value of a model at a certain node and a certain
/// column on that node. There are two structures used to reference a
/// particular node in a model. They are the `gtk.TreePath`-struct and
/// the `gtk.TreeIter`-struct (“iter” is short for iterator). Most of the
/// interface consists of operations on a `gtk.TreeIter`-struct.
///
/// A path is essentially a potential node. It is a location on a model
/// that may or may not actually correspond to a node on a specific
/// model. The `gtk.TreePath`-struct can be converted into either an
/// array of unsigned integers or a string. The string form is a list
/// of numbers separated by a colon. Each number refers to the offset
/// at that level. Thus, the path `0` refers to the root
/// node and the path `2:4` refers to the fifth child of
/// the third node.
///
/// By contrast, a `gtk.TreeIter`-struct is a reference to a specific node on
/// a specific model. It is a generic struct with an integer and three
/// generic pointers. These are filled in by the model in a model-specific
/// way. One can convert a path to an iterator by calling
/// `gtk.TreeModel.getIter`. These iterators are the primary way
/// of accessing a model and are similar to the iterators used by
/// `gtk.TextBuffer`. They are generally statically allocated on the
/// stack and only used for a short time. The model interface defines
/// a set of operations using them for navigating the model.
///
/// It is expected that models fill in the iterator with private data.
/// For example, the `gtk.ListStore` model, which is internally a simple
/// linked list, stores a list node in one of the pointers. The
/// `gtk.TreeModelSort` stores an array and an offset in two of the
/// pointers. Additionally, there is an integer field. This field is
/// generally filled with a unique stamp per model. This stamp is for
/// catching errors resulting from using invalid iterators with a model.
///
/// The lifecycle of an iterator can be a little confusing at first.
/// Iterators are expected to always be valid for as long as the model
/// is unchanged (and doesn’t emit a signal). The model is considered
/// to own all outstanding iterators and nothing needs to be done to
/// free them from the user’s point of view. Additionally, some models
/// guarantee that an iterator is valid for as long as the node it refers
/// to is valid (most notably the `gtk.TreeStore` and `gtk.ListStore`).
/// Although generally uninteresting, as one always has to allow for
/// the case where iterators do not persist beyond a signal, some very
/// important performance enhancements were made in the sort model.
/// As a result, the `GTK_TREE_MODEL_ITERS_PERSIST` flag was added to
/// indicate this behavior.
///
/// To help show some common operation of a model, some examples are
/// provided. The first example shows three ways of getting the iter at
/// the location `3:2:5`. While the first method shown is
/// easier, the second is much more common, as you often get paths from
/// callbacks.
///
/// ## Acquiring a
///
/// ```
/// // Three ways of getting the iter pointing to the location
/// GtkTreePath *path;
/// GtkTreeIter iter;
/// GtkTreeIter parent_iter;
///
/// // get the iterator from a string
/// gtk_tree_model_get_iter_from_string (model,
///                                      &iter,
///                                      "3:2:5");
///
/// // get the iterator from a path
/// path = gtk_tree_path_new_from_string ("3:2:5");
/// gtk_tree_model_get_iter (model, &iter, path);
/// gtk_tree_path_free (path);
///
/// // walk the tree to find the iterator
/// gtk_tree_model_iter_nth_child (model, &iter,
///                                NULL, 3);
/// parent_iter = iter;
/// gtk_tree_model_iter_nth_child (model, &iter,
///                                &parent_iter, 2);
/// parent_iter = iter;
/// gtk_tree_model_iter_nth_child (model, &iter,
///                                &parent_iter, 5);
/// ```
///
/// This second example shows a quick way of iterating through a list
/// and getting a string and an integer from each row. The
/// `populate_model` function used below is not
/// shown, as it is specific to the `gtk.ListStore`. For information on
/// how to write such a function, see the `gtk.ListStore` documentation.
///
/// ## Reading data from a
///
/// ```
/// enum
/// {
///   STRING_COLUMN,
///   INT_COLUMN,
///   N_COLUMNS
/// };
///
/// ...
///
/// GtkTreeModel *list_store;
/// GtkTreeIter iter;
/// gboolean valid;
/// gint row_count = 0;
///
/// // make a new list_store
/// list_store = gtk_list_store_new (N_COLUMNS,
///                                  G_TYPE_STRING,
///                                  G_TYPE_INT);
///
/// // Fill the list store with data
/// populate_model (list_store);
///
/// // Get the first iter in the list, check it is valid and walk
/// // through the list, reading each row.
///
/// valid = gtk_tree_model_get_iter_first (list_store,
///                                        &iter);
/// while (valid)
///  {
///    gchar *str_data;
///    gint   int_data;
///
///    // Make sure you terminate calls to `gtk.TreeModel.get` with a “-1” value
///    gtk_tree_model_get (list_store, &iter,
///                        STRING_COLUMN, &str_data,
///                        INT_COLUMN, &int_data,
///                        -1);
///
///    // Do something with the data
///    g_print ("Row `d`: (`s`,`d`)\n",
///             row_count, str_data, int_data);
///    g_free (str_data);
///
///    valid = gtk_tree_model_iter_next (list_store,
///                                      &iter);
///    row_count++;
///  }
/// ```
///
/// The `gtk.TreeModel` interface contains two methods for reference
/// counting: `gtk.TreeModel.refNode` and `gtk.TreeModel.unrefNode`.
/// These two methods are optional to implement. The reference counting
/// is meant as a way for views to let models know when nodes are being
/// displayed. `gtk.TreeView` will take a reference on a node when it is
/// visible, which means the node is either in the toplevel or expanded.
/// Being displayed does not mean that the node is currently directly
/// visible to the user in the viewport. Based on this reference counting
/// scheme a caching model, for example, can decide whether or not to cache
/// a node based on the reference count. A file-system based model would
/// not want to keep the entire file hierarchy in memory, but just the
/// folders that are currently expanded in every current view.
///
/// When working with reference counting, the following rules must be taken
/// into account:
///
/// - Never take a reference on a node without owning a reference on its parent.
///   This means that all parent nodes of a referenced node must be referenced
///   as well.
///
/// - Outstanding references on a deleted node are not released. This is not
///   possible because the node has already been deleted by the time the
///   row-deleted signal is received.
///
/// - Models are not obligated to emit a signal on rows of which none of its
///   siblings are referenced. To phrase this differently, signals are only
///   required for levels in which nodes are referenced. For the root level
///   however, signals must be emitted at all times (however the root level
///   is always referenced when any view is attached).
pub const TreeModel = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gtk.TreeModelIface;
    pub const virtual_methods = struct {
        /// Returns the type of the column.
        pub const get_column_type = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_index_: c_int) usize {
                return gobject.ext.as(TreeModel.Iface, p_class).f_get_column_type.?(gobject.ext.as(TreeModel, p_tree_model), p_index_);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_index_: c_int) callconv(.c) usize) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_get_column_type = @ptrCast(p_implementation);
            }
        };

        /// Returns a set of flags supported by this interface.
        ///
        /// The flags are a bitwise combination of `gtk.TreeModelFlags`.
        /// The flags supported should not change during the lifetime
        /// of the `tree_model`.
        pub const get_flags = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) gtk.TreeModelFlags {
                return gobject.ext.as(TreeModel.Iface, p_class).f_get_flags.?(gobject.ext.as(TreeModel, p_tree_model));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) gtk.TreeModelFlags) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_get_flags = @ptrCast(p_implementation);
            }
        };

        /// Sets `iter` to a valid iterator pointing to `path`.  If `path` does
        /// not exist, `iter` is set to an invalid iterator and `FALSE` is returned.
        pub const get_iter = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) c_int {
                return gobject.ext.as(TreeModel.Iface, p_class).f_get_iter.?(gobject.ext.as(TreeModel, p_tree_model), p_iter, p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) callconv(.c) c_int) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_get_iter = @ptrCast(p_implementation);
            }
        };

        /// Returns the number of columns supported by `tree_model`.
        pub const get_n_columns = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(TreeModel.Iface, p_class).f_get_n_columns.?(gobject.ext.as(TreeModel, p_tree_model));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_get_n_columns = @ptrCast(p_implementation);
            }
        };

        /// Returns a newly-created `gtk.TreePath`-struct referenced by `iter`.
        ///
        /// This path should be freed with `gtk.TreePath.free`.
        pub const get_path = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter) *gtk.TreePath {
                return gobject.ext.as(TreeModel.Iface, p_class).f_get_path.?(gobject.ext.as(TreeModel, p_tree_model), p_iter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter) callconv(.c) *gtk.TreePath) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_get_path = @ptrCast(p_implementation);
            }
        };

        /// Initializes and sets `value` to that at `column`.
        ///
        /// When done with `value`, `gobject.Value.unset` needs to be called
        /// to free any allocated memory.
        pub const get_value = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_column: c_int, p_value: *gobject.Value) void {
                return gobject.ext.as(TreeModel.Iface, p_class).f_get_value.?(gobject.ext.as(TreeModel, p_tree_model), p_iter, p_column, p_value);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_column: c_int, p_value: *gobject.Value) callconv(.c) void) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_get_value = @ptrCast(p_implementation);
            }
        };

        /// Sets `iter` to point to the first child of `parent`.
        ///
        /// If `parent` has no children, `FALSE` is returned and `iter` is
        /// set to be invalid. `parent` will remain a valid node after this
        /// function has been called.
        ///
        /// If `parent` is `NULL` returns the first node, equivalent to
        /// `gtk_tree_model_get_iter_first (tree_model, iter);`
        pub const iter_children = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_parent: ?*gtk.TreeIter) c_int {
                return gobject.ext.as(TreeModel.Iface, p_class).f_iter_children.?(gobject.ext.as(TreeModel, p_tree_model), p_iter, p_parent);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_parent: ?*gtk.TreeIter) callconv(.c) c_int) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_iter_children = @ptrCast(p_implementation);
            }
        };

        /// Returns `TRUE` if `iter` has children, `FALSE` otherwise.
        pub const iter_has_child = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter) c_int {
                return gobject.ext.as(TreeModel.Iface, p_class).f_iter_has_child.?(gobject.ext.as(TreeModel, p_tree_model), p_iter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter) callconv(.c) c_int) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_iter_has_child = @ptrCast(p_implementation);
            }
        };

        /// Returns the number of children that `iter` has.
        ///
        /// As a special case, if `iter` is `NULL`, then the number
        /// of toplevel nodes is returned.
        pub const iter_n_children = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: ?*gtk.TreeIter) c_int {
                return gobject.ext.as(TreeModel.Iface, p_class).f_iter_n_children.?(gobject.ext.as(TreeModel, p_tree_model), p_iter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: ?*gtk.TreeIter) callconv(.c) c_int) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_iter_n_children = @ptrCast(p_implementation);
            }
        };

        /// Sets `iter` to point to the node following it at the current level.
        ///
        /// If there is no next `iter`, `FALSE` is returned and `iter` is set
        /// to be invalid.
        pub const iter_next = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter) c_int {
                return gobject.ext.as(TreeModel.Iface, p_class).f_iter_next.?(gobject.ext.as(TreeModel, p_tree_model), p_iter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter) callconv(.c) c_int) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_iter_next = @ptrCast(p_implementation);
            }
        };

        /// Sets `iter` to be the child of `parent`, using the given index.
        ///
        /// The first index is 0. If `n` is too big, or `parent` has no children,
        /// `iter` is set to an invalid iterator and `FALSE` is returned. `parent`
        /// will remain a valid node after this function has been called. As a
        /// special case, if `parent` is `NULL`, then the `n`-th root node
        /// is set.
        pub const iter_nth_child = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_parent: ?*gtk.TreeIter, p_n: c_int) c_int {
                return gobject.ext.as(TreeModel.Iface, p_class).f_iter_nth_child.?(gobject.ext.as(TreeModel, p_tree_model), p_iter, p_parent, p_n);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_parent: ?*gtk.TreeIter, p_n: c_int) callconv(.c) c_int) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_iter_nth_child = @ptrCast(p_implementation);
            }
        };

        /// Sets `iter` to be the parent of `child`.
        ///
        /// If `child` is at the toplevel, and doesn’t have a parent, then
        /// `iter` is set to an invalid iterator and `FALSE` is returned.
        /// `child` will remain a valid node after this function has been
        /// called.
        ///
        /// `iter` will be initialized before the lookup is performed, so `child`
        /// and `iter` cannot point to the same memory location.
        pub const iter_parent = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_child: *gtk.TreeIter) c_int {
                return gobject.ext.as(TreeModel.Iface, p_class).f_iter_parent.?(gobject.ext.as(TreeModel, p_tree_model), p_iter, p_child);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter, p_child: *gtk.TreeIter) callconv(.c) c_int) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_iter_parent = @ptrCast(p_implementation);
            }
        };

        /// Sets `iter` to point to the previous node at the current level.
        ///
        /// If there is no previous `iter`, `FALSE` is returned and `iter` is
        /// set to be invalid.
        pub const iter_previous = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter) c_int {
                return gobject.ext.as(TreeModel.Iface, p_class).f_iter_previous.?(gobject.ext.as(TreeModel, p_tree_model), p_iter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter) callconv(.c) c_int) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_iter_previous = @ptrCast(p_implementation);
            }
        };

        /// Lets the tree ref the node.
        ///
        /// This is an optional method for models to implement.
        /// To be more specific, models may ignore this call as it exists
        /// primarily for performance reasons.
        ///
        /// This function is primarily meant as a way for views to let
        /// caching models know when nodes are being displayed (and hence,
        /// whether or not to cache that node). Being displayed means a node
        /// is in an expanded branch, regardless of whether the node is currently
        /// visible in the viewport. For example, a file-system based model
        /// would not want to keep the entire file-hierarchy in memory,
        /// just the sections that are currently being displayed by
        /// every current view.
        ///
        /// A model should be expected to be able to get an iter independent
        /// of its reffed state.
        pub const ref_node = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter) void {
                return gobject.ext.as(TreeModel.Iface, p_class).f_ref_node.?(gobject.ext.as(TreeModel, p_tree_model), p_iter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter) callconv(.c) void) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_ref_node = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gtk.TreeModel.signals.row`-changed signal on `tree_model`.
        pub const row_changed = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter) void {
                return gobject.ext.as(TreeModel.Iface, p_class).f_row_changed.?(gobject.ext.as(TreeModel, p_tree_model), p_path, p_iter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter) callconv(.c) void) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_row_changed = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gtk.TreeModel.signals.row`-deleted signal on `tree_model`.
        ///
        /// This should be called by models after a row has been removed.
        /// The location pointed to by `path` should be the location that
        /// the row previously was at. It may not be a valid location anymore.
        ///
        /// Nodes that are deleted are not unreffed, this means that any
        /// outstanding references on the deleted node should not be released.
        pub const row_deleted = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath) void {
                return gobject.ext.as(TreeModel.Iface, p_class).f_row_deleted.?(gobject.ext.as(TreeModel, p_tree_model), p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath) callconv(.c) void) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_row_deleted = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gtk.TreeModel.signals.row`-has-child-toggled signal on
        /// `tree_model`. This should be called by models after the child
        /// state of a node changes.
        pub const row_has_child_toggled = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter) void {
                return gobject.ext.as(TreeModel.Iface, p_class).f_row_has_child_toggled.?(gobject.ext.as(TreeModel, p_tree_model), p_path, p_iter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter) callconv(.c) void) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_row_has_child_toggled = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gtk.TreeModel.signals.row`-inserted signal on `tree_model`.
        pub const row_inserted = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter) void {
                return gobject.ext.as(TreeModel.Iface, p_class).f_row_inserted.?(gobject.ext.as(TreeModel, p_tree_model), p_path, p_iter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter) callconv(.c) void) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_row_inserted = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gtk.TreeModel.signals.rows`-reordered signal on `tree_model`.
        ///
        /// This should be called by models when their rows have been
        /// reordered.
        pub const rows_reordered = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter, p_new_order: *c_int) void {
                return gobject.ext.as(TreeModel.Iface, p_class).f_rows_reordered.?(gobject.ext.as(TreeModel, p_tree_model), p_path, p_iter, p_new_order);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter, p_new_order: *c_int) callconv(.c) void) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_rows_reordered = @ptrCast(p_implementation);
            }
        };

        /// Lets the tree unref the node.
        ///
        /// This is an optional method for models to implement.
        /// To be more specific, models may ignore this call as it exists
        /// primarily for performance reasons. For more information on what
        /// this means, see `gtk.TreeModel.refNode`.
        ///
        /// Please note that nodes that are deleted are not unreffed.
        pub const unref_node = struct {
            pub fn call(p_class: anytype, p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter) void {
                return gobject.ext.as(TreeModel.Iface, p_class).f_unref_node.?(gobject.ext.as(TreeModel, p_tree_model), p_iter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_tree_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_iter: *gtk.TreeIter) callconv(.c) void) void {
                gobject.ext.as(TreeModel.Iface, p_class).f_unref_node = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// This signal is emitted when a row in the model has changed.
        pub const row_changed = struct {
            pub const name = "row-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_path: *gtk.TreePath, p_iter: *gtk.TreeIter, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeModel, p_instance))),
                    gobject.signalLookup("row-changed", TreeModel.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when a row has been deleted.
        ///
        /// Note that no iterator is passed to the signal handler,
        /// since the row is already deleted.
        ///
        /// This should be called by models after a row has been removed.
        /// The location pointed to by `path` should be the location that
        /// the row previously was at. It may not be a valid location anymore.
        pub const row_deleted = struct {
            pub const name = "row-deleted";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_path: *gtk.TreePath, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeModel, p_instance))),
                    gobject.signalLookup("row-deleted", TreeModel.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when a row has gotten the first child
        /// row or lost its last child row.
        pub const row_has_child_toggled = struct {
            pub const name = "row-has-child-toggled";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_path: *gtk.TreePath, p_iter: *gtk.TreeIter, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeModel, p_instance))),
                    gobject.signalLookup("row-has-child-toggled", TreeModel.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when a new row has been inserted in
        /// the model.
        ///
        /// Note that the row may still be empty at this point, since
        /// it is a common pattern to first insert an empty row, and
        /// then fill it with the desired values.
        pub const row_inserted = struct {
            pub const name = "row-inserted";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_path: *gtk.TreePath, p_iter: *gtk.TreeIter, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeModel, p_instance))),
                    gobject.signalLookup("row-inserted", TreeModel.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when the children of a node in the
        /// `gtk.TreeModel` have been reordered.
        ///
        /// Note that this signal is not emitted
        /// when rows are reordered by DND, since this is implemented
        /// by removing and then reinserting the row.
        pub const rows_reordered = struct {
            pub const name = "rows-reordered";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_path: *gtk.TreePath, p_iter: *gtk.TreeIter, p_new_order: ?*anyopaque, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeModel, p_instance))),
                    gobject.signalLookup("rows-reordered", TreeModel.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gtk.TreeModel`, with `child_model` as the child_model
    /// and `root` as the virtual root.
    extern fn gtk_tree_model_filter_new(p_child_model: *TreeModel, p_root: ?*gtk.TreePath) *gtk.TreeModel;
    pub const filterNew = gtk_tree_model_filter_new;

    /// Calls func on each node in model in a depth-first fashion.
    ///
    /// If `func` returns `TRUE`, then the tree ceases to be walked,
    /// and `gtk.TreeModel.foreach` returns.
    extern fn gtk_tree_model_foreach(p_model: *TreeModel, p_func: gtk.TreeModelForeachFunc, p_user_data: ?*anyopaque) void;
    pub const foreach = gtk_tree_model_foreach;

    /// Gets the value of one or more cells in the row referenced by `iter`.
    /// The variable argument list should contain integer column numbers,
    /// each column number followed by a place to store the value being
    /// retrieved.  The list is terminated by a -1. For example, to get a
    /// value from column 0 with type `G_TYPE_STRING`, you would
    /// write: `gtk_tree_model_get (model, iter, 0, &place_string_here, -1)`,
    /// where `place_string_here` is a `gchararray`
    /// to be filled with the string.
    ///
    /// Returned values with type `G_TYPE_OBJECT` have to be unreferenced,
    /// values with type `G_TYPE_STRING` or `G_TYPE_BOXED` have to be freed.
    /// Other values are passed by value.
    extern fn gtk_tree_model_get(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter, ...) void;
    pub const get = gtk_tree_model_get;

    /// Returns the type of the column.
    extern fn gtk_tree_model_get_column_type(p_tree_model: *TreeModel, p_index_: c_int) usize;
    pub const getColumnType = gtk_tree_model_get_column_type;

    /// Returns a set of flags supported by this interface.
    ///
    /// The flags are a bitwise combination of `gtk.TreeModelFlags`.
    /// The flags supported should not change during the lifetime
    /// of the `tree_model`.
    extern fn gtk_tree_model_get_flags(p_tree_model: *TreeModel) gtk.TreeModelFlags;
    pub const getFlags = gtk_tree_model_get_flags;

    /// Sets `iter` to a valid iterator pointing to `path`.  If `path` does
    /// not exist, `iter` is set to an invalid iterator and `FALSE` is returned.
    extern fn gtk_tree_model_get_iter(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) c_int;
    pub const getIter = gtk_tree_model_get_iter;

    /// Initializes `iter` with the first iterator in the tree
    /// (the one at the path "0") and returns `TRUE`. Returns
    /// `FALSE` if the tree is empty.
    extern fn gtk_tree_model_get_iter_first(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter) c_int;
    pub const getIterFirst = gtk_tree_model_get_iter_first;

    /// Sets `iter` to a valid iterator pointing to `path_string`, if it
    /// exists. Otherwise, `iter` is left invalid and `FALSE` is returned.
    extern fn gtk_tree_model_get_iter_from_string(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter, p_path_string: [*:0]const u8) c_int;
    pub const getIterFromString = gtk_tree_model_get_iter_from_string;

    /// Returns the number of columns supported by `tree_model`.
    extern fn gtk_tree_model_get_n_columns(p_tree_model: *TreeModel) c_int;
    pub const getNColumns = gtk_tree_model_get_n_columns;

    /// Returns a newly-created `gtk.TreePath`-struct referenced by `iter`.
    ///
    /// This path should be freed with `gtk.TreePath.free`.
    extern fn gtk_tree_model_get_path(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter) *gtk.TreePath;
    pub const getPath = gtk_tree_model_get_path;

    /// Generates a string representation of the iter.
    ///
    /// This string is a “:” separated list of numbers.
    /// For example, “4:10:0:3” would be an acceptable
    /// return value for this string.
    extern fn gtk_tree_model_get_string_from_iter(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter) [*:0]u8;
    pub const getStringFromIter = gtk_tree_model_get_string_from_iter;

    /// See `gtk.TreeModel.get`, this version takes a va_list
    /// for language bindings to use.
    extern fn gtk_tree_model_get_valist(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter, p_var_args: std.builtin.VaList) void;
    pub const getValist = gtk_tree_model_get_valist;

    /// Initializes and sets `value` to that at `column`.
    ///
    /// When done with `value`, `gobject.Value.unset` needs to be called
    /// to free any allocated memory.
    extern fn gtk_tree_model_get_value(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter, p_column: c_int, p_value: *gobject.Value) void;
    pub const getValue = gtk_tree_model_get_value;

    /// Sets `iter` to point to the first child of `parent`.
    ///
    /// If `parent` has no children, `FALSE` is returned and `iter` is
    /// set to be invalid. `parent` will remain a valid node after this
    /// function has been called.
    ///
    /// If `parent` is `NULL` returns the first node, equivalent to
    /// `gtk_tree_model_get_iter_first (tree_model, iter);`
    extern fn gtk_tree_model_iter_children(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter, p_parent: ?*gtk.TreeIter) c_int;
    pub const iterChildren = gtk_tree_model_iter_children;

    /// Returns `TRUE` if `iter` has children, `FALSE` otherwise.
    extern fn gtk_tree_model_iter_has_child(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter) c_int;
    pub const iterHasChild = gtk_tree_model_iter_has_child;

    /// Returns the number of children that `iter` has.
    ///
    /// As a special case, if `iter` is `NULL`, then the number
    /// of toplevel nodes is returned.
    extern fn gtk_tree_model_iter_n_children(p_tree_model: *TreeModel, p_iter: ?*gtk.TreeIter) c_int;
    pub const iterNChildren = gtk_tree_model_iter_n_children;

    /// Sets `iter` to point to the node following it at the current level.
    ///
    /// If there is no next `iter`, `FALSE` is returned and `iter` is set
    /// to be invalid.
    extern fn gtk_tree_model_iter_next(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter) c_int;
    pub const iterNext = gtk_tree_model_iter_next;

    /// Sets `iter` to be the child of `parent`, using the given index.
    ///
    /// The first index is 0. If `n` is too big, or `parent` has no children,
    /// `iter` is set to an invalid iterator and `FALSE` is returned. `parent`
    /// will remain a valid node after this function has been called. As a
    /// special case, if `parent` is `NULL`, then the `n`-th root node
    /// is set.
    extern fn gtk_tree_model_iter_nth_child(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter, p_parent: ?*gtk.TreeIter, p_n: c_int) c_int;
    pub const iterNthChild = gtk_tree_model_iter_nth_child;

    /// Sets `iter` to be the parent of `child`.
    ///
    /// If `child` is at the toplevel, and doesn’t have a parent, then
    /// `iter` is set to an invalid iterator and `FALSE` is returned.
    /// `child` will remain a valid node after this function has been
    /// called.
    ///
    /// `iter` will be initialized before the lookup is performed, so `child`
    /// and `iter` cannot point to the same memory location.
    extern fn gtk_tree_model_iter_parent(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter, p_child: *gtk.TreeIter) c_int;
    pub const iterParent = gtk_tree_model_iter_parent;

    /// Sets `iter` to point to the previous node at the current level.
    ///
    /// If there is no previous `iter`, `FALSE` is returned and `iter` is
    /// set to be invalid.
    extern fn gtk_tree_model_iter_previous(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter) c_int;
    pub const iterPrevious = gtk_tree_model_iter_previous;

    /// Lets the tree ref the node.
    ///
    /// This is an optional method for models to implement.
    /// To be more specific, models may ignore this call as it exists
    /// primarily for performance reasons.
    ///
    /// This function is primarily meant as a way for views to let
    /// caching models know when nodes are being displayed (and hence,
    /// whether or not to cache that node). Being displayed means a node
    /// is in an expanded branch, regardless of whether the node is currently
    /// visible in the viewport. For example, a file-system based model
    /// would not want to keep the entire file-hierarchy in memory,
    /// just the sections that are currently being displayed by
    /// every current view.
    ///
    /// A model should be expected to be able to get an iter independent
    /// of its reffed state.
    extern fn gtk_tree_model_ref_node(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter) void;
    pub const refNode = gtk_tree_model_ref_node;

    /// Emits the `gtk.TreeModel.signals.row`-changed signal on `tree_model`.
    extern fn gtk_tree_model_row_changed(p_tree_model: *TreeModel, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter) void;
    pub const rowChanged = gtk_tree_model_row_changed;

    /// Emits the `gtk.TreeModel.signals.row`-deleted signal on `tree_model`.
    ///
    /// This should be called by models after a row has been removed.
    /// The location pointed to by `path` should be the location that
    /// the row previously was at. It may not be a valid location anymore.
    ///
    /// Nodes that are deleted are not unreffed, this means that any
    /// outstanding references on the deleted node should not be released.
    extern fn gtk_tree_model_row_deleted(p_tree_model: *TreeModel, p_path: *gtk.TreePath) void;
    pub const rowDeleted = gtk_tree_model_row_deleted;

    /// Emits the `gtk.TreeModel.signals.row`-has-child-toggled signal on
    /// `tree_model`. This should be called by models after the child
    /// state of a node changes.
    extern fn gtk_tree_model_row_has_child_toggled(p_tree_model: *TreeModel, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter) void;
    pub const rowHasChildToggled = gtk_tree_model_row_has_child_toggled;

    /// Emits the `gtk.TreeModel.signals.row`-inserted signal on `tree_model`.
    extern fn gtk_tree_model_row_inserted(p_tree_model: *TreeModel, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter) void;
    pub const rowInserted = gtk_tree_model_row_inserted;

    /// Emits the `gtk.TreeModel.signals.rows`-reordered signal on `tree_model`.
    ///
    /// This should be called by models when their rows have been
    /// reordered.
    extern fn gtk_tree_model_rows_reordered(p_tree_model: *TreeModel, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter, p_new_order: *c_int) void;
    pub const rowsReordered = gtk_tree_model_rows_reordered;

    /// Emits the `gtk.TreeModel.signals.rows`-reordered signal on `tree_model`.
    ///
    /// This should be called by models when their rows have been
    /// reordered.
    extern fn gtk_tree_model_rows_reordered_with_length(p_tree_model: *TreeModel, p_path: *gtk.TreePath, p_iter: ?*gtk.TreeIter, p_new_order: [*]c_int, p_length: c_int) void;
    pub const rowsReorderedWithLength = gtk_tree_model_rows_reordered_with_length;

    /// Lets the tree unref the node.
    ///
    /// This is an optional method for models to implement.
    /// To be more specific, models may ignore this call as it exists
    /// primarily for performance reasons. For more information on what
    /// this means, see `gtk.TreeModel.refNode`.
    ///
    /// Please note that nodes that are deleted are not unreffed.
    extern fn gtk_tree_model_unref_node(p_tree_model: *TreeModel, p_iter: *gtk.TreeIter) void;
    pub const unrefNode = gtk_tree_model_unref_node;

    extern fn gtk_tree_model_get_type() usize;
    pub const getGObjectType = gtk_tree_model_get_type;

    extern fn g_object_ref(p_self: *gtk.TreeModel) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TreeModel) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TreeModel, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.TreeSortable` is an interface to be implemented by tree models which
/// support sorting. The `gtk.TreeView` uses the methods provided by this interface
/// to sort the model.
pub const TreeSortable = opaque {
    pub const Prerequisites = [_]type{gtk.TreeModel};
    pub const Iface = gtk.TreeSortableIface;
    pub const virtual_methods = struct {
        /// Fills in `sort_column_id` and `order` with the current sort column and the
        /// order. It returns `TRUE` unless the `sort_column_id` is
        /// `GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID` or
        /// `GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID`.
        pub const get_sort_column_id = struct {
            pub fn call(p_class: anytype, p_sortable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_sort_column_id: *c_int, p_order: *gtk.SortType) c_int {
                return gobject.ext.as(TreeSortable.Iface, p_class).f_get_sort_column_id.?(gobject.ext.as(TreeSortable, p_sortable), p_sort_column_id, p_order);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_sortable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_sort_column_id: *c_int, p_order: *gtk.SortType) callconv(.c) c_int) void {
                gobject.ext.as(TreeSortable.Iface, p_class).f_get_sort_column_id = @ptrCast(p_implementation);
            }
        };

        /// Returns `TRUE` if the model has a default sort function. This is used
        /// primarily by GtkTreeViewColumns in order to determine if a model can
        /// go back to the default state, or not.
        pub const has_default_sort_func = struct {
            pub fn call(p_class: anytype, p_sortable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(TreeSortable.Iface, p_class).f_has_default_sort_func.?(gobject.ext.as(TreeSortable, p_sortable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_sortable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(TreeSortable.Iface, p_class).f_has_default_sort_func = @ptrCast(p_implementation);
            }
        };

        /// Sets the default comparison function used when sorting to be `sort_func`.
        /// If the current sort column id of `sortable` is
        /// `GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID`, then the model will sort using
        /// this function.
        ///
        /// If `sort_func` is `NULL`, then there will be no default comparison function.
        /// This means that once the model  has been sorted, it can’t go back to the
        /// default state. In this case, when the current sort column id of `sortable`
        /// is `GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID`, the model will be unsorted.
        pub const set_default_sort_func = struct {
            pub fn call(p_class: anytype, p_sortable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_sort_func: gtk.TreeIterCompareFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void {
                return gobject.ext.as(TreeSortable.Iface, p_class).f_set_default_sort_func.?(gobject.ext.as(TreeSortable, p_sortable), p_sort_func, p_user_data, p_destroy);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_sortable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_sort_func: gtk.TreeIterCompareFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) callconv(.c) void) void {
                gobject.ext.as(TreeSortable.Iface, p_class).f_set_default_sort_func = @ptrCast(p_implementation);
            }
        };

        /// Sets the current sort column to be `sort_column_id`. The `sortable` will
        /// resort itself to reflect this change, after emitting a
        /// `gtk.TreeSortable.signals.sort`-column-changed signal. `sort_column_id` may either be
        /// a regular column id, or one of the following special values:
        ///
        /// - `GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID`: the default sort function
        ///   will be used, if it is set
        ///
        /// - `GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID`: no sorting will occur
        pub const set_sort_column_id = struct {
            pub fn call(p_class: anytype, p_sortable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_sort_column_id: c_int, p_order: gtk.SortType) void {
                return gobject.ext.as(TreeSortable.Iface, p_class).f_set_sort_column_id.?(gobject.ext.as(TreeSortable, p_sortable), p_sort_column_id, p_order);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_sortable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_sort_column_id: c_int, p_order: gtk.SortType) callconv(.c) void) void {
                gobject.ext.as(TreeSortable.Iface, p_class).f_set_sort_column_id = @ptrCast(p_implementation);
            }
        };

        /// Sets the comparison function used when sorting to be `sort_func`. If the
        /// current sort column id of `sortable` is the same as `sort_column_id`, then
        /// the model will sort using this function.
        pub const set_sort_func = struct {
            pub fn call(p_class: anytype, p_sortable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_sort_column_id: c_int, p_sort_func: gtk.TreeIterCompareFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void {
                return gobject.ext.as(TreeSortable.Iface, p_class).f_set_sort_func.?(gobject.ext.as(TreeSortable, p_sortable), p_sort_column_id, p_sort_func, p_user_data, p_destroy);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_sortable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_sort_column_id: c_int, p_sort_func: gtk.TreeIterCompareFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) callconv(.c) void) void {
                gobject.ext.as(TreeSortable.Iface, p_class).f_set_sort_func = @ptrCast(p_implementation);
            }
        };

        /// Emits a `gtk.TreeSortable.signals.sort`-column-changed signal on `sortable`.
        pub const sort_column_changed = struct {
            pub fn call(p_class: anytype, p_sortable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(TreeSortable.Iface, p_class).f_sort_column_changed.?(gobject.ext.as(TreeSortable, p_sortable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_sortable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(TreeSortable.Iface, p_class).f_sort_column_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// The ::sort-column-changed signal is emitted when the sort column
        /// or sort order of `sortable` is changed. The signal is emitted before
        /// the contents of `sortable` are resorted.
        pub const sort_column_changed = struct {
            pub const name = "sort-column-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TreeSortable, p_instance))),
                    gobject.signalLookup("sort-column-changed", TreeSortable.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Fills in `sort_column_id` and `order` with the current sort column and the
    /// order. It returns `TRUE` unless the `sort_column_id` is
    /// `GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID` or
    /// `GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID`.
    extern fn gtk_tree_sortable_get_sort_column_id(p_sortable: *TreeSortable, p_sort_column_id: *c_int, p_order: *gtk.SortType) c_int;
    pub const getSortColumnId = gtk_tree_sortable_get_sort_column_id;

    /// Returns `TRUE` if the model has a default sort function. This is used
    /// primarily by GtkTreeViewColumns in order to determine if a model can
    /// go back to the default state, or not.
    extern fn gtk_tree_sortable_has_default_sort_func(p_sortable: *TreeSortable) c_int;
    pub const hasDefaultSortFunc = gtk_tree_sortable_has_default_sort_func;

    /// Sets the default comparison function used when sorting to be `sort_func`.
    /// If the current sort column id of `sortable` is
    /// `GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID`, then the model will sort using
    /// this function.
    ///
    /// If `sort_func` is `NULL`, then there will be no default comparison function.
    /// This means that once the model  has been sorted, it can’t go back to the
    /// default state. In this case, when the current sort column id of `sortable`
    /// is `GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID`, the model will be unsorted.
    extern fn gtk_tree_sortable_set_default_sort_func(p_sortable: *TreeSortable, p_sort_func: gtk.TreeIterCompareFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setDefaultSortFunc = gtk_tree_sortable_set_default_sort_func;

    /// Sets the current sort column to be `sort_column_id`. The `sortable` will
    /// resort itself to reflect this change, after emitting a
    /// `gtk.TreeSortable.signals.sort`-column-changed signal. `sort_column_id` may either be
    /// a regular column id, or one of the following special values:
    ///
    /// - `GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID`: the default sort function
    ///   will be used, if it is set
    ///
    /// - `GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID`: no sorting will occur
    extern fn gtk_tree_sortable_set_sort_column_id(p_sortable: *TreeSortable, p_sort_column_id: c_int, p_order: gtk.SortType) void;
    pub const setSortColumnId = gtk_tree_sortable_set_sort_column_id;

    /// Sets the comparison function used when sorting to be `sort_func`. If the
    /// current sort column id of `sortable` is the same as `sort_column_id`, then
    /// the model will sort using this function.
    extern fn gtk_tree_sortable_set_sort_func(p_sortable: *TreeSortable, p_sort_column_id: c_int, p_sort_func: gtk.TreeIterCompareFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const setSortFunc = gtk_tree_sortable_set_sort_func;

    /// Emits a `gtk.TreeSortable.signals.sort`-column-changed signal on `sortable`.
    extern fn gtk_tree_sortable_sort_column_changed(p_sortable: *TreeSortable) void;
    pub const sortColumnChanged = gtk_tree_sortable_sort_column_changed;

    extern fn gtk_tree_sortable_get_type() usize;
    pub const getGObjectType = gtk_tree_sortable_get_type;

    extern fn g_object_ref(p_self: *gtk.TreeSortable) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gtk.TreeSortable) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TreeSortable, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AboutDialogClass = extern struct {
    pub const Instance = gtk.AboutDialog;

    f_parent_class: gtk.DialogClass,
    f_activate_link: ?*const fn (p_dialog: *gtk.AboutDialog, p_uri: [*:0]const u8) callconv(.c) c_int,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *AboutDialogClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AboutDialogPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AccelGroupClass = extern struct {
    pub const Instance = gtk.AccelGroup;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    /// Signal emitted when an entry is added to or removed
    ///    from the accel group.
    f_accel_changed: ?*const fn (p_accel_group: *gtk.AccelGroup, p_keyval: c_uint, p_modifier: gdk.ModifierType, p_accel_closure: *gobject.Closure) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *AccelGroupClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AccelGroupEntry = extern struct {
    f_key: gtk.AccelKey,
    f_closure: ?*gobject.Closure,
    f_accel_path_quark: glib.Quark,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AccelGroupPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AccelKey = extern struct {
    /// The accelerator keyval
    f_accel_key: c_uint,
    /// The accelerator modifiers
    f_accel_mods: gdk.ModifierType,
    bitfields0: packed struct(c_uint) {
        /// The accelerator flags
        f_accel_flags: u16,
        _: u16,
    },

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AccelLabelClass = extern struct {
    pub const Instance = gtk.AccelLabel;

    f_parent_class: gtk.LabelClass,
    f_signal_quote1: ?[*:0]u8,
    f_signal_quote2: ?[*:0]u8,
    f_mod_name_shift: ?[*:0]u8,
    f_mod_name_control: ?[*:0]u8,
    f_mod_name_alt: ?[*:0]u8,
    f_mod_separator: ?[*:0]u8,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *AccelLabelClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AccelLabelPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AccelMapClass = opaque {
    pub const Instance = gtk.AccelMap;

    pub fn as(p_instance: *AccelMapClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AccessibleClass = extern struct {
    pub const Instance = gtk.Accessible;

    f_parent_class: atk.ObjectClass,
    f_connect_widget_destroyed: ?*const fn (p_accessible: *gtk.Accessible) callconv(.c) void,
    f_widget_set: ?*const fn (p_accessible: *gtk.Accessible) callconv(.c) void,
    f_widget_unset: ?*const fn (p_accessible: *gtk.Accessible) callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *AccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ActionBarClass = extern struct {
    pub const Instance = gtk.ActionBar;

    f_parent_class: gtk.BinClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ActionBarClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ActionBarPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ActionClass = extern struct {
    pub const Instance = gtk.Action;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    /// Signal emitted when the action is activated.
    f_activate: ?*const fn (p_action: *gtk.Action) callconv(.c) void,
    f_menu_item_type: usize,
    f_toolbar_item_type: usize,
    f_create_menu_item: ?*const fn (p_action: *gtk.Action) callconv(.c) *gtk.Widget,
    f_create_tool_item: ?*const fn (p_action: *gtk.Action) callconv(.c) *gtk.Widget,
    f_connect_proxy: ?*const fn (p_action: *gtk.Action, p_proxy: *gtk.Widget) callconv(.c) void,
    f_disconnect_proxy: ?*const fn (p_action: *gtk.Action, p_proxy: *gtk.Widget) callconv(.c) void,
    f_create_menu: ?*const fn (p_action: *gtk.Action) callconv(.c) *gtk.Widget,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ActionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.ActionEntry` structs are used with `gtk.ActionGroup.addActions` to
/// construct actions.
pub const ActionEntry = extern struct {
    /// The name of the action.
    f_name: ?[*:0]const u8,
    /// The stock id for the action, or the name of an icon from the
    ///  icon theme.
    f_stock_id: ?[*:0]const u8,
    /// The label for the action. This field should typically be marked
    ///  for translation, see `gtk.ActionGroup.setTranslationDomain`. If
    ///  `label` is `NULL`, the label of the stock item with id `stock_id` is used.
    f_label: ?[*:0]const u8,
    /// The accelerator for the action, in the format understood by
    ///  `gtk.acceleratorParse`.
    f_accelerator: ?[*:0]const u8,
    /// The tooltip for the action. This field should typically be
    ///  marked for translation, see `gtk.ActionGroup.setTranslationDomain`.
    f_tooltip: ?[*:0]const u8,
    /// The function to call when the action is activated.
    f_callback: ?gobject.Callback,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ActionGroupClass = extern struct {
    pub const Instance = gtk.ActionGroup;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    /// Looks up an action in the action group by name.
    f_get_action: ?*const fn (p_action_group: *gtk.ActionGroup, p_action_name: [*:0]const u8) callconv(.c) *gtk.Action,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ActionGroupClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ActionGroupPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ActionPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The interface vtable for `gtk.Actionable`.
pub const ActionableInterface = extern struct {
    pub const Instance = gtk.Actionable;

    f_g_iface: gobject.TypeInterface,
    /// virtual function for `gtk.Actionable.getActionName`
    f_get_action_name: ?*const fn (p_actionable: *gtk.Actionable) callconv(.c) ?[*:0]const u8,
    /// virtual function for `gtk.Actionable.setActionName`
    f_set_action_name: ?*const fn (p_actionable: *gtk.Actionable, p_action_name: ?[*:0]const u8) callconv(.c) void,
    /// virtual function for `gtk.Actionable.getActionTargetValue`
    f_get_action_target_value: ?*const fn (p_actionable: *gtk.Actionable) callconv(.c) *glib.Variant,
    /// virtual function for `gtk.Actionable.setActionTargetValue`
    f_set_action_target_value: ?*const fn (p_actionable: *gtk.Actionable, p_target_value: ?*glib.Variant) callconv(.c) void,

    pub fn as(p_instance: *ActionableInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// > This method can be called with a `NULL` action at times.
pub const ActivatableIface = extern struct {
    pub const Instance = gtk.Activatable;

    f_g_iface: gobject.TypeInterface,
    /// Called to update the activatable when its related action’s properties change.
    /// You must check the `gtk.Activatable.properties.use`-action-appearance property only apply action
    /// properties that are meant to effect the appearance accordingly.
    f_update: ?*const fn (p_activatable: *gtk.Activatable, p_action: *gtk.Action, p_property_name: [*:0]const u8) callconv(.c) void,
    /// Called to update the activatable completely, this is called internally when
    /// `gtk.Activatable.properties.related`-action property is set or unset and by the implementor when
    /// `gtk.Activatable.properties.use`-action-appearance changes.
    f_sync_action_properties: ?*const fn (p_activatable: *gtk.Activatable, p_action: ?*gtk.Action) callconv(.c) void,

    pub fn as(p_instance: *ActivatableIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AdjustmentClass = extern struct {
    pub const Instance = gtk.Adjustment;

    f_parent_class: gobject.InitiallyUnownedClass,
    f_changed: ?*const fn (p_adjustment: *gtk.Adjustment) callconv(.c) void,
    f_value_changed: ?*const fn (p_adjustment: *gtk.Adjustment) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *AdjustmentClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AdjustmentPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AlignmentClass = extern struct {
    pub const Instance = gtk.Alignment;

    /// The parent class.
    f_parent_class: gtk.BinClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *AlignmentClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AlignmentPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AppChooserButtonClass = extern struct {
    pub const Instance = gtk.AppChooserButton;

    /// The parent class.
    f_parent_class: gtk.ComboBoxClass,
    /// Signal emitted when a custom item,
    ///    previously added with `gtk.AppChooserButton.appendCustomItem`,
    ///    is activated from the dropdown menu.
    f_custom_item_activated: ?*const fn (p_self: *gtk.AppChooserButton, p_item_name: [*:0]const u8) callconv(.c) void,
    f_padding: [16]*anyopaque,

    pub fn as(p_instance: *AppChooserButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AppChooserButtonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AppChooserDialogClass = extern struct {
    pub const Instance = gtk.AppChooserDialog;

    /// The parent class.
    f_parent_class: gtk.DialogClass,
    f_padding: [16]*anyopaque,

    pub fn as(p_instance: *AppChooserDialogClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AppChooserDialogPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AppChooserWidgetClass = extern struct {
    pub const Instance = gtk.AppChooserWidget;

    /// The parent class.
    f_parent_class: gtk.BoxClass,
    /// Signal emitted when an application item is
    ///    selected from the widget’s list.
    f_application_selected: ?*const fn (p_self: *gtk.AppChooserWidget, p_app_info: *gio.AppInfo) callconv(.c) void,
    /// Signal emitted when an application item is
    ///    activated from the widget’s list.
    f_application_activated: ?*const fn (p_self: *gtk.AppChooserWidget, p_app_info: *gio.AppInfo) callconv(.c) void,
    /// Signal emitted when a context menu is about to
    ///    popup over an application item.
    f_populate_popup: ?*const fn (p_self: *gtk.AppChooserWidget, p_menu: *gtk.Menu, p_app_info: *gio.AppInfo) callconv(.c) void,
    f_padding: [16]*anyopaque,

    pub fn as(p_instance: *AppChooserWidgetClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AppChooserWidgetPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ApplicationClass = extern struct {
    pub const Instance = gtk.Application;

    /// The parent class.
    f_parent_class: gio.ApplicationClass,
    /// Signal emitted when a `gtk.Window` is added to
    ///    application through `gtk.Application.addWindow`.
    f_window_added: ?*const fn (p_application: *gtk.Application, p_window: *gtk.Window) callconv(.c) void,
    /// Signal emitted when a `gtk.Window` is removed from
    ///    application, either as a side-effect of being destroyed or
    ///    explicitly through `gtk.Application.removeWindow`.
    f_window_removed: ?*const fn (p_application: *gtk.Application, p_window: *gtk.Window) callconv(.c) void,
    f_padding: [12]*anyopaque,

    pub fn as(p_instance: *ApplicationClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ApplicationPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ApplicationWindowClass = extern struct {
    pub const Instance = gtk.ApplicationWindow;

    /// The parent class.
    f_parent_class: gtk.WindowClass,
    f_padding: [14]*anyopaque,

    pub fn as(p_instance: *ApplicationWindowClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ApplicationWindowPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ArrowAccessibleClass = extern struct {
    pub const Instance = gtk.ArrowAccessible;

    f_parent_class: gtk.WidgetAccessibleClass,

    pub fn as(p_instance: *ArrowAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ArrowAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ArrowClass = extern struct {
    pub const Instance = gtk.Arrow;

    f_parent_class: gtk.MiscClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ArrowClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ArrowPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AspectFrameClass = extern struct {
    pub const Instance = gtk.AspectFrame;

    /// The parent class.
    f_parent_class: gtk.FrameClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *AspectFrameClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AspectFramePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AssistantClass = extern struct {
    pub const Instance = gtk.Assistant;

    /// The parent class.
    f_parent_class: gtk.WindowClass,
    /// Signal emitted when a new page is set as the assistant’s current page, before making the new page visible.
    f_prepare: ?*const fn (p_assistant: *gtk.Assistant, p_page: *gtk.Widget) callconv(.c) void,
    /// Signal emitted when the apply button is clicked.
    f_apply: ?*const fn (p_assistant: *gtk.Assistant) callconv(.c) void,
    /// Signal emitted either when the close button or last page apply button is clicked.
    f_close: ?*const fn (p_assistant: *gtk.Assistant) callconv(.c) void,
    /// Signal emitted when the cancel button is clicked.
    f_cancel: ?*const fn (p_assistant: *gtk.Assistant) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *AssistantClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AssistantPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const BinClass = extern struct {
    pub const Instance = gtk.Bin;

    /// The parent class.
    f_parent_class: gtk.ContainerClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *BinClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const BinPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.BindingArg` holds the data associated with
/// an argument for a key binding signal emission as
/// stored in `gtk.BindingSignal`.
pub const BindingArg = extern struct {
    /// implementation detail
    f_arg_type: usize,
    anon0: extern union {
        f_long_data: c_long,
        f_double_data: f64,
        f_string_data: ?[*:0]u8,
    },

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Each key binding element of a binding sets binding list is
/// represented by a GtkBindingEntry.
pub const BindingEntry = extern struct {
    /// key value to match
    f_keyval: c_uint,
    /// key modifiers to match
    f_modifiers: gdk.ModifierType,
    /// binding set this entry belongs to
    f_binding_set: ?*gtk.BindingSet,
    bitfields0: packed struct(c_uint) {
        /// implementation detail
        f_destroyed: u1,
        /// implementation detail
        f_in_emission: u1,
        /// implementation detail
        f_marks_unbound: u1,
        _: u29,
    },
    /// linked list of entries maintained by binding set
    f_set_next: ?*gtk.BindingEntry,
    /// implementation detail
    f_hash_next: ?*gtk.BindingEntry,
    /// action signals of this entry
    f_signals: ?*gtk.BindingSignal,

    /// Override or install a new key binding for `keyval` with `modifiers` on
    /// `binding_set`. When the binding is activated, `signal_name` will be
    /// emitted on the target widget, with `n_args` `Varargs` used as
    /// arguments.
    ///
    /// Each argument to the signal must be passed as a pair of varargs: the
    /// `gobject.Type` of the argument, followed by the argument value (which must
    /// be of the given type). There must be `n_args` pairs in total.
    ///
    /// ## Adding a Key Binding
    ///
    /// ```
    /// GtkBindingSet *binding_set;
    /// GdkModifierType modmask = GDK_CONTROL_MASK;
    /// int count = 1;
    /// gtk_binding_entry_add_signal (binding_set,
    ///                               GDK_KEY_space,
    ///                               modmask,
    ///                               "move-cursor", 2,
    ///                               GTK_TYPE_MOVEMENT_STEP, GTK_MOVEMENT_PAGES,
    ///                               G_TYPE_INT, count,
    ///                               G_TYPE_BOOLEAN, FALSE);
    /// ```
    extern fn gtk_binding_entry_add_signal(p_binding_set: *gtk.BindingSet, p_keyval: c_uint, p_modifiers: gdk.ModifierType, p_signal_name: [*:0]const u8, p_n_args: c_uint, ...) void;
    pub const addSignal = gtk_binding_entry_add_signal;

    /// Parses a signal description from `signal_desc` and incorporates
    /// it into `binding_set`.
    ///
    /// Signal descriptions may either bind a key combination to
    /// one or more signals:
    /// ```
    ///   bind "key" {
    ///     "signalname" (param, ...)
    ///     ...
    ///   }
    /// ```
    ///
    /// Or they may also unbind a key combination:
    /// ```
    ///   unbind "key"
    /// ```
    ///
    /// Key combinations must be in a format that can be parsed by
    /// `gtk.acceleratorParse`.
    extern fn gtk_binding_entry_add_signal_from_string(p_binding_set: *gtk.BindingSet, p_signal_desc: [*:0]const u8) glib.TokenType;
    pub const addSignalFromString = gtk_binding_entry_add_signal_from_string;

    /// Override or install a new key binding for `keyval` with `modifiers` on
    /// `binding_set`.
    extern fn gtk_binding_entry_add_signall(p_binding_set: *gtk.BindingSet, p_keyval: c_uint, p_modifiers: gdk.ModifierType, p_signal_name: [*:0]const u8, p_binding_args: *glib.SList) void;
    pub const addSignall = gtk_binding_entry_add_signall;

    /// Remove a binding previously installed via
    /// `gtk.BindingEntry.addSignal` on `binding_set`.
    extern fn gtk_binding_entry_remove(p_binding_set: *gtk.BindingSet, p_keyval: c_uint, p_modifiers: gdk.ModifierType) void;
    pub const remove = gtk_binding_entry_remove;

    /// Install a binding on `binding_set` which causes key lookups
    /// to be aborted, to prevent bindings from lower priority sets
    /// to be activated.
    extern fn gtk_binding_entry_skip(p_binding_set: *gtk.BindingSet, p_keyval: c_uint, p_modifiers: gdk.ModifierType) void;
    pub const skip = gtk_binding_entry_skip;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A binding set maintains a list of activatable key bindings.
/// A single binding set can match multiple types of widgets.
/// Similar to style contexts, can be matched by any information contained
/// in a widgets `gtk.WidgetPath`. When a binding within a set is matched upon
/// activation, an action signal is emitted on the target widget to carry out
/// the actual activation.
pub const BindingSet = extern struct {
    /// unique name of this binding set
    f_set_name: ?[*:0]u8,
    /// unused
    f_priority: c_int,
    /// unused
    f_widget_path_pspecs: ?*glib.SList,
    /// unused
    f_widget_class_pspecs: ?*glib.SList,
    /// unused
    f_class_branch_pspecs: ?*glib.SList,
    /// the key binding entries in this binding set
    f_entries: ?*gtk.BindingEntry,
    /// implementation detail
    f_current: ?*gtk.BindingEntry,
    bitfields0: packed struct(c_uint) {
        /// whether this binding set stems from a CSS file and is reset upon theme changes
        f_parsed: u1,
        _: u31,
    },

    /// This function returns the binding set named after the type name of
    /// the passed in class structure. New binding sets are created on
    /// demand by this function.
    extern fn gtk_binding_set_by_class(p_object_class: ?*anyopaque) *gtk.BindingSet;
    pub const byClass = gtk_binding_set_by_class;

    /// Find a binding set by its globally unique name.
    ///
    /// The `set_name` can either be a name used for `gtk.bindingSetNew`
    /// or the type name of a class used in `gtk.bindingSetByClass`.
    extern fn gtk_binding_set_find(p_set_name: [*:0]const u8) ?*gtk.BindingSet;
    pub const find = gtk_binding_set_find;

    /// GTK+ maintains a global list of binding sets. Each binding set has
    /// a unique name which needs to be specified upon creation.
    extern fn gtk_binding_set_new(p_set_name: [*:0]const u8) *gtk.BindingSet;
    pub const new = gtk_binding_set_new;

    /// Find a key binding matching `keyval` and `modifiers` within
    /// `binding_set` and activate the binding on `object`.
    extern fn gtk_binding_set_activate(p_binding_set: *BindingSet, p_keyval: c_uint, p_modifiers: gdk.ModifierType, p_object: *gobject.Object) c_int;
    pub const activate = gtk_binding_set_activate;

    /// This function was used internally by the GtkRC parsing mechanism
    /// to assign match patterns to `gtk.BindingSet` structures.
    ///
    /// In GTK+ 3, these match patterns are unused.
    extern fn gtk_binding_set_add_path(p_binding_set: *BindingSet, p_path_type: gtk.PathType, p_path_pattern: [*:0]const u8, p_priority: gtk.PathPriorityType) void;
    pub const addPath = gtk_binding_set_add_path;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkBindingSignal stores the necessary information to
/// activate a widget in response to a key press via a signal
/// emission.
pub const BindingSignal = extern struct {
    /// implementation detail
    f_next: ?*gtk.BindingSignal,
    /// the action signal to be emitted
    f_signal_name: ?[*:0]u8,
    /// number of arguments specified for the signal
    f_n_args: c_uint,
    /// the arguments specified for the signal
    f_args: ?[*]gtk.BindingArg,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const BooleanCellAccessibleClass = extern struct {
    pub const Instance = gtk.BooleanCellAccessible;

    f_parent_class: gtk.RendererCellAccessibleClass,

    pub fn as(p_instance: *BooleanCellAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const BooleanCellAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A struct that specifies a border around a rectangular area
/// that can be of different width on each side.
pub const Border = extern struct {
    /// The width of the left border
    f_left: i16,
    /// The width of the right border
    f_right: i16,
    /// The width of the top border
    f_top: i16,
    /// The width of the bottom border
    f_bottom: i16,

    /// Allocates a new `gtk.Border`-struct and initializes its elements to zero.
    extern fn gtk_border_new() *gtk.Border;
    pub const new = gtk_border_new;

    /// Copies a `gtk.Border`-struct.
    extern fn gtk_border_copy(p_border_: *const Border) *gtk.Border;
    pub const copy = gtk_border_copy;

    /// Frees a `gtk.Border`-struct.
    extern fn gtk_border_free(p_border_: *Border) void;
    pub const free = gtk_border_free;

    extern fn gtk_border_get_type() usize;
    pub const getGObjectType = gtk_border_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const BoxClass = extern struct {
    pub const Instance = gtk.Box;

    /// The parent class.
    f_parent_class: gtk.ContainerClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *BoxClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const BoxPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.BuildableIface` interface contains method that are
/// necessary to allow `gtk.Builder` to construct an object from
/// a `gtk.Builder` UI definition.
pub const BuildableIface = extern struct {
    pub const Instance = gtk.Buildable;

    /// the parent class
    f_g_iface: gobject.TypeInterface,
    /// Stores the name attribute given in the GtkBuilder UI definition.
    ///  `gtk.Widget` stores the name as object data. Implement this method if your
    ///  object has some notion of “name” and it makes sense to map the XML name
    ///  attribute to it.
    f_set_name: ?*const fn (p_buildable: *gtk.Buildable, p_name: [*:0]const u8) callconv(.c) void,
    /// The getter corresponding to `set_name`. Implement this
    ///  if you implement `set_name`.
    f_get_name: ?*const fn (p_buildable: *gtk.Buildable) callconv(.c) [*:0]const u8,
    /// Adds a child. The `type` parameter can be used to
    ///  differentiate the kind of child. `gtk.Container` implements this
    ///  to add add a child widget to the container, `gtk.Notebook` uses
    ///  the `type` to distinguish between page labels (of type "page-label")
    ///  and normal children.
    f_add_child: ?*const fn (p_buildable: *gtk.Buildable, p_builder: *gtk.Builder, p_child: *gobject.Object, p_type: ?[*:0]const u8) callconv(.c) void,
    /// Sets a property of a buildable object.
    ///  It is normally not necessary to implement this, `gobject.Object.setProperty`
    ///  is used by default. `gtk.Window` implements this to delay showing itself
    ///  (i.e. setting the `gtk.Widget.properties.visible` property) until the whole interface
    ///  is created.
    f_set_buildable_property: ?*const fn (p_buildable: *gtk.Buildable, p_builder: *gtk.Builder, p_name: [*:0]const u8, p_value: *const gobject.Value) callconv(.c) void,
    /// Constructs a child of a buildable that has been
    ///  specified as “constructor” in the UI definition. `gtk.UIManager` implements
    ///  this to reference to a widget created in a `<ui>` tag which is outside
    ///  of the normal GtkBuilder UI definition hierarchy.  A reference to the
    ///  constructed object is returned and becomes owned by the caller.
    f_construct_child: ?*const fn (p_buildable: *gtk.Buildable, p_builder: *gtk.Builder, p_name: [*:0]const u8) callconv(.c) *gobject.Object,
    /// Implement this if the buildable needs to parse
    ///  content below `<child>`. To handle an element, the implementation
    ///  must fill in the `parser` and `user_data` and return `TRUE`.
    ///  `gtk.Widget` implements this to parse keyboard accelerators specified
    ///  in `<accelerator>` elements. `gtk.Container` implements it to map
    ///  properties defined via `<packing>` elements to child properties.
    ///  Note that `user_data` must be freed in `custom_tag_end` or `custom_finished`.
    f_custom_tag_start: ?*const fn (p_buildable: *gtk.Buildable, p_builder: *gtk.Builder, p_child: ?*gobject.Object, p_tagname: [*:0]const u8, p_parser: *glib.MarkupParser, p_data: ?*anyopaque) callconv(.c) c_int,
    /// Called for the end tag of each custom element that is
    ///  handled by the buildable (see `custom_tag_start`).
    f_custom_tag_end: ?*const fn (p_buildable: *gtk.Buildable, p_builder: *gtk.Builder, p_child: ?*gobject.Object, p_tagname: [*:0]const u8, p_data: ?*anyopaque) callconv(.c) void,
    /// Called for each custom tag handled by the buildable
    ///  when the builder finishes parsing (see `custom_tag_start`)
    f_custom_finished: ?*const fn (p_buildable: *gtk.Buildable, p_builder: *gtk.Builder, p_child: ?*gobject.Object, p_tagname: [*:0]const u8, p_data: ?*anyopaque) callconv(.c) void,
    /// Called when a builder finishes the parsing
    ///  of a UI definition. It is normally not necessary to implement this,
    ///  unless you need to perform special cleanup actions. `gtk.Window` sets
    ///  the `gtk.Widget.properties.visible` property here.
    f_parser_finished: ?*const fn (p_buildable: *gtk.Buildable, p_builder: *gtk.Builder) callconv(.c) void,
    /// Returns an internal child of a buildable.
    ///  `gtk.Dialog` implements this to give access to its `vbox`, making
    ///  it possible to add children to the vbox in a UI definition.
    ///  Implement this if the buildable has internal children that may
    ///  need to be accessed from a UI definition.
    f_get_internal_child: ?*const fn (p_buildable: *gtk.Buildable, p_builder: *gtk.Builder, p_childname: [*:0]const u8) callconv(.c) *gobject.Object,

    pub fn as(p_instance: *BuildableIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const BuilderClass = extern struct {
    pub const Instance = gtk.Builder;

    f_parent_class: gobject.ObjectClass,
    f_get_type_from_name: ?*const fn (p_builder: *gtk.Builder, p_type_name: [*:0]const u8) callconv(.c) usize,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,
    f__gtk_reserved7: ?*const fn () callconv(.c) void,
    f__gtk_reserved8: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *BuilderClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const BuilderPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ButtonAccessibleClass = extern struct {
    pub const Instance = gtk.ButtonAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *ButtonAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ButtonAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ButtonBoxClass = extern struct {
    pub const Instance = gtk.ButtonBox;

    /// The parent class.
    f_parent_class: gtk.BoxClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ButtonBoxClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ButtonBoxPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ButtonClass = extern struct {
    pub const Instance = gtk.Button;

    /// The parent class.
    f_parent_class: gtk.BinClass,
    /// Signal emitted when the button is pressed. Deprecated: 2.8.
    f_pressed: ?*const fn (p_button: *gtk.Button) callconv(.c) void,
    /// Signal emitted when the button is released. Deprecated: 2.8.
    f_released: ?*const fn (p_button: *gtk.Button) callconv(.c) void,
    /// Signal emitted when the button has been activated (pressed and released).
    f_clicked: ?*const fn (p_button: *gtk.Button) callconv(.c) void,
    /// Signal emitted when the pointer enters the button. Deprecated: 2.8.
    f_enter: ?*const fn (p_button: *gtk.Button) callconv(.c) void,
    /// Signal emitted when the pointer leaves the button. Deprecated: 2.8.
    f_leave: ?*const fn (p_button: *gtk.Button) callconv(.c) void,
    /// Signal that causes the button to animate press then
    ///    release. Applications should never connect to this signal, but use
    ///    the `clicked` signal.
    f_activate: ?*const fn (p_button: *gtk.Button) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ButtonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CalendarClass = extern struct {
    pub const Instance = gtk.Calendar;

    f_parent_class: gtk.WidgetClass,
    f_month_changed: ?*const fn (p_calendar: *gtk.Calendar) callconv(.c) void,
    f_day_selected: ?*const fn (p_calendar: *gtk.Calendar) callconv(.c) void,
    f_day_selected_double_click: ?*const fn (p_calendar: *gtk.Calendar) callconv(.c) void,
    f_prev_month: ?*const fn (p_calendar: *gtk.Calendar) callconv(.c) void,
    f_next_month: ?*const fn (p_calendar: *gtk.Calendar) callconv(.c) void,
    f_prev_year: ?*const fn (p_calendar: *gtk.Calendar) callconv(.c) void,
    f_next_year: ?*const fn (p_calendar: *gtk.Calendar) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CalendarClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CalendarPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellAccessibleClass = extern struct {
    pub const Instance = gtk.CellAccessible;

    f_parent_class: gtk.AccessibleClass,
    f_update_cache: ?*const fn (p_cell: *gtk.CellAccessible, p_emit_signal: c_int) callconv(.c) void,

    pub fn as(p_instance: *CellAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellAccessibleParentIface = extern struct {
    pub const Instance = gtk.CellAccessibleParent;

    f_parent: gobject.TypeInterface,
    f_get_cell_extents: ?*const fn (p_parent: *gtk.CellAccessibleParent, p_cell: *gtk.CellAccessible, p_x: *c_int, p_y: *c_int, p_width: *c_int, p_height: *c_int, p_coord_type: atk.CoordType) callconv(.c) void,
    f_get_cell_area: ?*const fn (p_parent: *gtk.CellAccessibleParent, p_cell: *gtk.CellAccessible, p_cell_rect: *gdk.Rectangle) callconv(.c) void,
    f_grab_focus: ?*const fn (p_parent: *gtk.CellAccessibleParent, p_cell: *gtk.CellAccessible) callconv(.c) c_int,
    f_get_child_index: ?*const fn (p_parent: *gtk.CellAccessibleParent, p_cell: *gtk.CellAccessible) callconv(.c) c_int,
    f_get_renderer_state: ?*const fn (p_parent: *gtk.CellAccessibleParent, p_cell: *gtk.CellAccessible) callconv(.c) gtk.CellRendererState,
    f_expand_collapse: ?*const fn (p_parent: *gtk.CellAccessibleParent, p_cell: *gtk.CellAccessible) callconv(.c) void,
    f_activate: ?*const fn (p_parent: *gtk.CellAccessibleParent, p_cell: *gtk.CellAccessible) callconv(.c) void,
    f_edit: ?*const fn (p_parent: *gtk.CellAccessibleParent, p_cell: *gtk.CellAccessible) callconv(.c) void,
    f_update_relationset: ?*const fn (p_parent: *gtk.CellAccessibleParent, p_cell: *gtk.CellAccessible, p_relationset: *atk.RelationSet) callconv(.c) void,
    f_get_cell_position: ?*const fn (p_parent: *gtk.CellAccessibleParent, p_cell: *gtk.CellAccessible, p_row: *c_int, p_column: *c_int) callconv(.c) void,
    f_get_column_header_cells: ?*const fn (p_parent: *gtk.CellAccessibleParent, p_cell: *gtk.CellAccessible) callconv(.c) *glib.PtrArray,
    f_get_row_header_cells: ?*const fn (p_parent: *gtk.CellAccessibleParent, p_cell: *gtk.CellAccessible) callconv(.c) *glib.PtrArray,

    pub fn as(p_instance: *CellAccessibleParentIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellAreaBoxClass = extern struct {
    pub const Instance = gtk.CellAreaBox;

    f_parent_class: gtk.CellAreaClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CellAreaBoxClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellAreaBoxPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellAreaClass = extern struct {
    pub const Instance = gtk.CellArea;

    f_parent_class: gobject.InitiallyUnownedClass,
    /// adds a `gtk.CellRenderer` to the area.
    f_add: ?*const fn (p_area: *gtk.CellArea, p_renderer: *gtk.CellRenderer) callconv(.c) void,
    /// removes a `gtk.CellRenderer` from the area.
    f_remove: ?*const fn (p_area: *gtk.CellArea, p_renderer: *gtk.CellRenderer) callconv(.c) void,
    /// calls the `gtk.CellCallback` function on every `gtk.CellRenderer` in
    ///     the area with the provided user data until the callback returns `TRUE`.
    f_foreach: ?*const fn (p_area: *gtk.CellArea, p_callback: gtk.CellCallback, p_callback_data: ?*anyopaque) callconv(.c) void,
    /// Calls the `gtk.CellAllocCallback` function on every
    ///     `gtk.CellRenderer` in the area with the allocated area for the cell
    ///     and the provided user data until the callback returns `TRUE`.
    f_foreach_alloc: ?*const fn (p_area: *gtk.CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_cell_area: *const gdk.Rectangle, p_background_area: *const gdk.Rectangle, p_callback: gtk.CellAllocCallback, p_callback_data: ?*anyopaque) callconv(.c) void,
    /// Handle an event in the area, this is generally used to activate
    ///     a cell at the event location for button events but can also be used
    ///     to generically pass events to `GtkWidgets` drawn onto the area.
    f_event: ?*const fn (p_area: *gtk.CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_event: *gdk.Event, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) callconv(.c) c_int,
    /// Actually render the area’s cells to the specified rectangle,
    ///     `background_area` should be correctly distributed to the cells
    ///     corresponding background areas.
    f_render: ?*const fn (p_area: *gtk.CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_cr: *cairo.Context, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState, p_paint_focus: c_int) callconv(.c) void,
    /// Apply the cell attributes to the cells. This is
    ///     implemented as a signal and generally `gtk.CellArea` subclasses don't
    ///     need to implement it since it is handled by the base class.
    f_apply_attributes: ?*const fn (p_area: *gtk.CellArea, p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_is_expander: c_int, p_is_expanded: c_int) callconv(.c) void,
    /// Creates and returns a class specific `gtk.CellAreaContext`
    ///     to store cell alignment and allocation details for a said `gtk.CellArea`
    ///     class.
    f_create_context: ?*const fn (p_area: *gtk.CellArea) callconv(.c) *gtk.CellAreaContext,
    /// Creates a new `gtk.CellAreaContext` in the same state as
    ///     the passed `context` with any cell alignment data and allocations intact.
    f_copy_context: ?*const fn (p_area: *gtk.CellArea, p_context: *gtk.CellAreaContext) callconv(.c) *gtk.CellAreaContext,
    /// This allows an area to tell its layouting widget whether
    ///     it prefers to be allocated in `GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH` or
    ///     `GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT` mode.
    f_get_request_mode: ?*const fn (p_area: *gtk.CellArea) callconv(.c) gtk.SizeRequestMode,
    /// Calculates the minimum and natural width of the
    ///     areas cells with the current attributes applied while considering
    ///     the particular layouting details of the said `gtk.CellArea`. While
    ///     requests are performed over a series of rows, alignments and overall
    ///     minimum and natural sizes should be stored in the corresponding
    ///     `gtk.CellAreaContext`.
    f_get_preferred_width: ?*const fn (p_area: *gtk.CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) callconv(.c) void,
    /// Calculates the minimum and natural height
    ///     for the area if the passed `context` would be allocated the given width.
    ///     When implementing this virtual method it is safe to assume that `context`
    ///     has already stored the aligned cell widths for every `gtk.TreeModel` row
    ///     that `context` will be allocated for since this information was stored
    ///     at `gtk.CellAreaClass.virtual_methods.get_preferred_width` time. This virtual method
    ///     should also store any necessary alignments of cell heights for the
    ///     case that the context is allocated a height.
    f_get_preferred_height_for_width: ?*const fn (p_area: *gtk.CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) callconv(.c) void,
    /// Calculates the minimum and natural height of the
    ///     areas cells with the current attributes applied. Essentially this is
    ///     the same as `gtk.CellAreaClass.virtual_methods.get_preferred_width` only for areas
    ///     that are being requested as `GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT`.
    f_get_preferred_height: ?*const fn (p_area: *gtk.CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) callconv(.c) void,
    /// Calculates the minimum and natural width
    ///     for the area if the passed `context` would be allocated the given
    ///     height. The same as `gtk.CellAreaClass.virtual_methods.get_preferred_height_for_width`
    ///     only for handling requests in the `GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT`
    ///     mode.
    f_get_preferred_width_for_height: ?*const fn (p_area: *gtk.CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) callconv(.c) void,
    /// This should be implemented to handle changes in child
    ///     cell properties for a given `gtk.CellRenderer` that were previously
    ///     installed on the `gtk.CellAreaClass` with `gtk.CellAreaClass.installCellProperty`.
    f_set_cell_property: ?*const fn (p_area: *gtk.CellArea, p_renderer: *gtk.CellRenderer, p_property_id: c_uint, p_value: *const gobject.Value, p_pspec: *gobject.ParamSpec) callconv(.c) void,
    /// This should be implemented to report the values of
    ///     child cell properties for a given child `gtk.CellRenderer`.
    f_get_cell_property: ?*const fn (p_area: *gtk.CellArea, p_renderer: *gtk.CellRenderer, p_property_id: c_uint, p_value: *gobject.Value, p_pspec: *gobject.ParamSpec) callconv(.c) void,
    /// This virtual method should be implemented to navigate focus from
    ///     cell to cell inside the `gtk.CellArea`. The `gtk.CellArea` should move
    ///     focus from cell to cell inside the area and return `FALSE` if focus
    ///     logically leaves the area with the following exceptions: When the
    ///     area contains no activatable cells, the entire area recieves focus.
    ///     Focus should not be given to cells that are actually “focus siblings”
    ///     of other sibling cells (see `gtk.CellArea.getFocusFromSibling`).
    ///     Focus is set by calling `gtk.CellArea.setFocusCell`.
    f_focus: ?*const fn (p_area: *gtk.CellArea, p_direction: gtk.DirectionType) callconv(.c) c_int,
    /// Returns whether the `gtk.CellArea` can respond to
    ///     `gtk.CellAreaClass.virtual_methods.activate`, usually this does not need to be
    ///     implemented since the base class takes care of this however it can
    ///     be enhanced if the `gtk.CellArea` subclass can handle activation in
    ///     other ways than activating its `GtkCellRenderers`.
    f_is_activatable: ?*const fn (p_area: *gtk.CellArea) callconv(.c) c_int,
    /// This is called when the layouting widget rendering the
    ///     `gtk.CellArea` activates the focus cell (see `gtk.CellArea.getFocusCell`).
    f_activate: ?*const fn (p_area: *gtk.CellArea, p_context: *gtk.CellAreaContext, p_widget: *gtk.Widget, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState, p_edit_only: c_int) callconv(.c) c_int,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,
    f__gtk_reserved7: ?*const fn () callconv(.c) void,
    f__gtk_reserved8: ?*const fn () callconv(.c) void,

    /// Finds a cell property of a cell area class by name.
    extern fn gtk_cell_area_class_find_cell_property(p_aclass: *CellAreaClass, p_property_name: [*:0]const u8) *gobject.ParamSpec;
    pub const findCellProperty = gtk_cell_area_class_find_cell_property;

    /// Installs a cell property on a cell area class.
    extern fn gtk_cell_area_class_install_cell_property(p_aclass: *CellAreaClass, p_property_id: c_uint, p_pspec: *gobject.ParamSpec) void;
    pub const installCellProperty = gtk_cell_area_class_install_cell_property;

    /// Returns all cell properties of a cell area class.
    extern fn gtk_cell_area_class_list_cell_properties(p_aclass: *CellAreaClass, p_n_properties: *c_uint) [*]*gobject.ParamSpec;
    pub const listCellProperties = gtk_cell_area_class_list_cell_properties;

    pub fn as(p_instance: *CellAreaClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellAreaContextClass = extern struct {
    pub const Instance = gtk.CellAreaContext;

    f_parent_class: gobject.ObjectClass,
    /// This tells the context that an allocation width or height
    ///     (or both) have been decided for a group of rows. The context should
    ///     store any allocations for internally aligned cells at this point so
    ///     that they dont need to be recalculated at `gtk.CellArea.render` time.
    f_allocate: ?*const fn (p_context: *gtk.CellAreaContext, p_width: c_int, p_height: c_int) callconv(.c) void,
    /// Clear any previously stored information about requested and
    ///     allocated sizes for the context.
    f_reset: ?*const fn (p_context: *gtk.CellAreaContext) callconv(.c) void,
    /// Returns the aligned height for the given
    ///     width that context must store while collecting sizes for it’s rows.
    f_get_preferred_height_for_width: ?*const fn (p_context: *gtk.CellAreaContext, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) callconv(.c) void,
    /// Returns the aligned width for the given
    ///     height that context must store while collecting sizes for it’s rows.
    f_get_preferred_width_for_height: ?*const fn (p_context: *gtk.CellAreaContext, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CellAreaContextClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellAreaContextPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellAreaPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellEditableIface = extern struct {
    pub const Instance = gtk.CellEditable;

    f_g_iface: gobject.TypeInterface,
    /// Signal is a sign for the cell renderer to update its
    ///    value from the cell_editable.
    f_editing_done: ?*const fn (p_cell_editable: *gtk.CellEditable) callconv(.c) void,
    /// Signal is meant to indicate that the cell is
    ///    finished editing, and the widget may now be destroyed.
    f_remove_widget: ?*const fn (p_cell_editable: *gtk.CellEditable) callconv(.c) void,
    /// Begins editing on a cell_editable.
    f_start_editing: ?*const fn (p_cell_editable: *gtk.CellEditable, p_event: ?*gdk.Event) callconv(.c) void,

    pub fn as(p_instance: *CellEditableIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellLayoutIface = extern struct {
    pub const Instance = gtk.CellLayout;

    f_g_iface: gobject.TypeInterface,
    /// Packs the cell into the beginning of cell_layout.
    f_pack_start: ?*const fn (p_cell_layout: *gtk.CellLayout, p_cell: *gtk.CellRenderer, p_expand: c_int) callconv(.c) void,
    /// Adds the cell to the end of cell_layout.
    f_pack_end: ?*const fn (p_cell_layout: *gtk.CellLayout, p_cell: *gtk.CellRenderer, p_expand: c_int) callconv(.c) void,
    /// Unsets all the mappings on all renderers on cell_layout and
    ///    removes all renderers from cell_layout.
    f_clear: ?*const fn (p_cell_layout: *gtk.CellLayout) callconv(.c) void,
    /// Adds an attribute mapping to the list in
    ///    cell_layout.
    f_add_attribute: ?*const fn (p_cell_layout: *gtk.CellLayout, p_cell: *gtk.CellRenderer, p_attribute: [*:0]const u8, p_column: c_int) callconv(.c) void,
    /// Sets the `gtk.CellLayoutDataFunc` to use for
    ///    cell_layout.
    f_set_cell_data_func: ?*const fn (p_cell_layout: *gtk.CellLayout, p_cell: *gtk.CellRenderer, p_func: ?gtk.CellLayoutDataFunc, p_func_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) callconv(.c) void,
    /// Clears all existing attributes previously set
    ///    with `gtk.CellLayout.setAttributes`.
    f_clear_attributes: ?*const fn (p_cell_layout: *gtk.CellLayout, p_cell: *gtk.CellRenderer) callconv(.c) void,
    /// Re-inserts cell at position.
    f_reorder: ?*const fn (p_cell_layout: *gtk.CellLayout, p_cell: *gtk.CellRenderer, p_position: c_int) callconv(.c) void,
    /// Get the cell renderers which have been added to
    ///    cell_layout.
    f_get_cells: ?*const fn (p_cell_layout: *gtk.CellLayout) callconv(.c) *glib.List,
    /// Get the underlying `gtk.CellArea` which might be
    ///    cell_layout if called on a `gtk.CellArea` or might be NULL if no
    ///    `gtk.CellArea` is used by cell_layout.
    f_get_area: ?*const fn (p_cell_layout: *gtk.CellLayout) callconv(.c) ?*gtk.CellArea,

    pub fn as(p_instance: *CellLayoutIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererAccelClass = extern struct {
    pub const Instance = gtk.CellRendererAccel;

    f_parent_class: gtk.CellRendererTextClass,
    f_accel_edited: ?*const fn (p_accel: *gtk.CellRendererAccel, p_path_string: [*:0]const u8, p_accel_key: c_uint, p_accel_mods: gdk.ModifierType, p_hardware_keycode: c_uint) callconv(.c) void,
    f_accel_cleared: ?*const fn (p_accel: *gtk.CellRendererAccel, p_path_string: [*:0]const u8) callconv(.c) void,
    f__gtk_reserved0: ?*const fn () callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CellRendererAccelClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererAccelPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererClass = extern struct {
    pub const Instance = gtk.CellRenderer;

    f_parent_class: gobject.InitiallyUnownedClass,
    /// Called to gets whether the cell renderer prefers
    ///    a height-for-width layout or a width-for-height layout.
    f_get_request_mode: ?*const fn (p_cell: *gtk.CellRenderer) callconv(.c) gtk.SizeRequestMode,
    /// Called to get a renderer’s natural width.
    f_get_preferred_width: ?*const fn (p_cell: *gtk.CellRenderer, p_widget: *gtk.Widget, p_minimum_size: ?*c_int, p_natural_size: ?*c_int) callconv(.c) void,
    /// Called to get a renderer’s natural height for width.
    f_get_preferred_height_for_width: ?*const fn (p_cell: *gtk.CellRenderer, p_widget: *gtk.Widget, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) callconv(.c) void,
    /// Called to get a renderer’s natural height.
    f_get_preferred_height: ?*const fn (p_cell: *gtk.CellRenderer, p_widget: *gtk.Widget, p_minimum_size: ?*c_int, p_natural_size: ?*c_int) callconv(.c) void,
    /// Called to get a renderer’s natural width for height.
    f_get_preferred_width_for_height: ?*const fn (p_cell: *gtk.CellRenderer, p_widget: *gtk.Widget, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) callconv(.c) void,
    /// Called to get the aligned area used by `cell` inside `cell_area`.
    f_get_aligned_area: ?*const fn (p_cell: *gtk.CellRenderer, p_widget: *gtk.Widget, p_flags: gtk.CellRendererState, p_cell_area: *const gdk.Rectangle, p_aligned_area: *gdk.Rectangle) callconv(.c) void,
    /// Called to get the width and height needed to render the cell. Deprecated: 3.0.
    f_get_size: ?*const fn (p_cell: *gtk.CellRenderer, p_widget: *gtk.Widget, p_cell_area: ?*const gdk.Rectangle, p_x_offset: ?*c_int, p_y_offset: ?*c_int, p_width: ?*c_int, p_height: ?*c_int) callconv(.c) void,
    /// Called to render the content of the `gtk.CellRenderer`.
    f_render: ?*const fn (p_cell: *gtk.CellRenderer, p_cr: *cairo.Context, p_widget: *gtk.Widget, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) callconv(.c) void,
    /// Called to activate the content of the `gtk.CellRenderer`.
    f_activate: ?*const fn (p_cell: *gtk.CellRenderer, p_event: *gdk.Event, p_widget: *gtk.Widget, p_path: [*:0]const u8, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) callconv(.c) c_int,
    /// Called to initiate editing the content of the `gtk.CellRenderer`.
    f_start_editing: ?*const fn (p_cell: *gtk.CellRenderer, p_event: ?*gdk.Event, p_widget: *gtk.Widget, p_path: [*:0]const u8, p_background_area: *const gdk.Rectangle, p_cell_area: *const gdk.Rectangle, p_flags: gtk.CellRendererState) callconv(.c) ?*gtk.CellEditable,
    /// Signal gets emitted when the user cancels the process of editing a cell.
    f_editing_canceled: ?*const fn (p_cell: *gtk.CellRenderer) callconv(.c) void,
    /// Signal gets emitted when a cell starts to be edited.
    f_editing_started: ?*const fn (p_cell: *gtk.CellRenderer, p_editable: *gtk.CellEditable, p_path: [*:0]const u8) callconv(.c) void,
    f_priv: ?*gtk.CellRendererClassPrivate,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    /// Sets the type to be used for creating accessibles for cells rendered by
    /// cell renderers of `renderer_class`. Note that multiple accessibles will
    /// be created.
    ///
    /// This function should only be called from class init functions of cell
    /// renderers.
    extern fn gtk_cell_renderer_class_set_accessible_type(p_renderer_class: *CellRendererClass, p_type: usize) void;
    pub const setAccessibleType = gtk_cell_renderer_class_set_accessible_type;

    pub fn as(p_instance: *CellRendererClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererClassPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererComboClass = extern struct {
    pub const Instance = gtk.CellRendererCombo;

    f_parent: gtk.CellRendererTextClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CellRendererComboClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererComboPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererPixbufClass = extern struct {
    pub const Instance = gtk.CellRendererPixbuf;

    f_parent_class: gtk.CellRendererClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CellRendererPixbufClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererPixbufPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererProgressClass = extern struct {
    pub const Instance = gtk.CellRendererProgress;

    f_parent_class: gtk.CellRendererClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CellRendererProgressClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererProgressPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererSpinClass = extern struct {
    pub const Instance = gtk.CellRendererSpin;

    f_parent: gtk.CellRendererTextClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CellRendererSpinClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererSpinPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererSpinnerClass = extern struct {
    pub const Instance = gtk.CellRendererSpinner;

    f_parent_class: gtk.CellRendererClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CellRendererSpinnerClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererSpinnerPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererTextClass = extern struct {
    pub const Instance = gtk.CellRendererText;

    f_parent_class: gtk.CellRendererClass,
    f_edited: ?*const fn (p_cell_renderer_text: *gtk.CellRendererText, p_path: [*:0]const u8, p_new_text: [*:0]const u8) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CellRendererTextClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererTextPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererToggleClass = extern struct {
    pub const Instance = gtk.CellRendererToggle;

    f_parent_class: gtk.CellRendererClass,
    f_toggled: ?*const fn (p_cell_renderer_toggle: *gtk.CellRendererToggle, p_path: [*:0]const u8) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CellRendererToggleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellRendererTogglePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellViewClass = extern struct {
    pub const Instance = gtk.CellView;

    /// The parent class.
    f_parent_class: gtk.WidgetClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CellViewClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CellViewPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CheckButtonClass = extern struct {
    pub const Instance = gtk.CheckButton;

    f_parent_class: gtk.ToggleButtonClass,
    f_draw_indicator: ?*const fn (p_check_button: *gtk.CheckButton, p_cr: *cairo.Context) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CheckButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CheckMenuItemAccessibleClass = extern struct {
    pub const Instance = gtk.CheckMenuItemAccessible;

    f_parent_class: gtk.MenuItemAccessibleClass,

    pub fn as(p_instance: *CheckMenuItemAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CheckMenuItemAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CheckMenuItemClass = extern struct {
    pub const Instance = gtk.CheckMenuItem;

    /// The parent class.
    f_parent_class: gtk.MenuItemClass,
    /// Signal emitted when the state of the check box is changed.
    f_toggled: ?*const fn (p_check_menu_item: *gtk.CheckMenuItem) callconv(.c) void,
    /// Called to draw the check indicator.
    f_draw_indicator: ?*const fn (p_check_menu_item: *gtk.CheckMenuItem, p_cr: *cairo.Context) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CheckMenuItemClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CheckMenuItemPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ColorButtonClass = extern struct {
    pub const Instance = gtk.ColorButton;

    f_parent_class: gtk.ButtonClass,
    f_color_set: ?*const fn (p_cp: *gtk.ColorButton) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ColorButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ColorButtonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ColorChooserDialogClass = extern struct {
    pub const Instance = gtk.ColorChooserDialog;

    f_parent_class: gtk.DialogClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ColorChooserDialogClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ColorChooserDialogPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ColorChooserInterface = extern struct {
    pub const Instance = gtk.ColorChooser;

    f_base_interface: gobject.TypeInterface,
    f_get_rgba: ?*const fn (p_chooser: *gtk.ColorChooser, p_color: *gdk.RGBA) callconv(.c) void,
    f_set_rgba: ?*const fn (p_chooser: *gtk.ColorChooser, p_color: *const gdk.RGBA) callconv(.c) void,
    f_add_palette: ?*const fn (p_chooser: *gtk.ColorChooser, p_orientation: gtk.Orientation, p_colors_per_line: c_int, p_n_colors: c_int, p_colors: ?[*]gdk.RGBA) callconv(.c) void,
    f_color_activated: ?*const fn (p_chooser: *gtk.ColorChooser, p_color: *const gdk.RGBA) callconv(.c) void,
    f_padding: [12]*anyopaque,

    pub fn as(p_instance: *ColorChooserInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ColorChooserWidgetClass = extern struct {
    pub const Instance = gtk.ColorChooserWidget;

    /// The parent class.
    f_parent_class: gtk.BoxClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,
    f__gtk_reserved7: ?*const fn () callconv(.c) void,
    f__gtk_reserved8: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ColorChooserWidgetClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ColorChooserWidgetPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ColorSelectionClass = extern struct {
    pub const Instance = gtk.ColorSelection;

    /// The parent class.
    f_parent_class: gtk.BoxClass,
    f_color_changed: ?*const fn (p_color_selection: *gtk.ColorSelection) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ColorSelectionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ColorSelectionDialogClass = extern struct {
    pub const Instance = gtk.ColorSelectionDialog;

    f_parent_class: gtk.DialogClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ColorSelectionDialogClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ColorSelectionDialogPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ColorSelectionPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ComboBoxAccessibleClass = extern struct {
    pub const Instance = gtk.ComboBoxAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *ComboBoxAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ComboBoxAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ComboBoxClass = extern struct {
    pub const Instance = gtk.ComboBox;

    /// The parent class.
    f_parent_class: gtk.BinClass,
    /// Signal is emitted when the active item is changed.
    f_changed: ?*const fn (p_combo_box: *gtk.ComboBox) callconv(.c) void,
    /// Signal which allows you to change how the text
    ///    displayed in a combo box’s entry is displayed.
    f_format_entry_text: ?*const fn (p_combo_box: *gtk.ComboBox, p_path: [*:0]const u8) callconv(.c) [*:0]u8,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ComboBoxClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ComboBoxPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ComboBoxTextClass = extern struct {
    pub const Instance = gtk.ComboBoxText;

    f_parent_class: gtk.ComboBoxClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ComboBoxTextClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ComboBoxTextPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ContainerAccessibleClass = extern struct {
    pub const Instance = gtk.ContainerAccessible;

    f_parent_class: gtk.WidgetAccessibleClass,
    f_add_gtk: ?*const fn (p_container: *gtk.Container, p_widget: *gtk.Widget, p_data: *anyopaque) callconv(.c) c_int,
    f_remove_gtk: ?*const fn (p_container: *gtk.Container, p_widget: *gtk.Widget, p_data: *anyopaque) callconv(.c) c_int,

    pub fn as(p_instance: *ContainerAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ContainerAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ContainerCellAccessibleClass = extern struct {
    pub const Instance = gtk.ContainerCellAccessible;

    f_parent_class: gtk.CellAccessibleClass,

    pub fn as(p_instance: *ContainerCellAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ContainerCellAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Base class for containers.
pub const ContainerClass = extern struct {
    pub const Instance = gtk.Container;

    /// The parent class.
    f_parent_class: gtk.WidgetClass,
    /// Signal emitted when a widget is added to container.
    f_add: ?*const fn (p_container: *gtk.Container, p_widget: *gtk.Widget) callconv(.c) void,
    /// Signal emitted when a widget is removed from container.
    f_remove: ?*const fn (p_container: *gtk.Container, p_widget: *gtk.Widget) callconv(.c) void,
    /// Signal emitted when a size recalculation is needed.
    f_check_resize: ?*const fn (p_container: *gtk.Container) callconv(.c) void,
    /// Invokes callback on each child of container. The callback handler
    ///    may remove the child.
    f_forall: ?*const fn (p_container: *gtk.Container, p_include_internals: c_int, p_callback: gtk.Callback, p_callback_data: ?*anyopaque) callconv(.c) void,
    /// Sets the focused child of container.
    f_set_focus_child: ?*const fn (p_container: *gtk.Container, p_child: ?*gtk.Widget) callconv(.c) void,
    /// Returns the type of the children supported by the container.
    f_child_type: ?*const fn (p_container: *gtk.Container) callconv(.c) usize,
    /// Gets a widget’s composite name. Deprecated: 3.10.
    f_composite_name: ?*const fn (p_container: *gtk.Container, p_child: *gtk.Widget) callconv(.c) [*:0]u8,
    /// Set a property on a child of container.
    f_set_child_property: ?*const fn (p_container: *gtk.Container, p_child: *gtk.Widget, p_property_id: c_uint, p_value: *const gobject.Value, p_pspec: *gobject.ParamSpec) callconv(.c) void,
    /// Get a property from a child of container.
    f_get_child_property: ?*const fn (p_container: *gtk.Container, p_child: *gtk.Widget, p_property_id: c_uint, p_value: *gobject.Value, p_pspec: *gobject.ParamSpec) callconv(.c) void,
    /// Get path representing entire widget hierarchy
    ///    from the toplevel down to and including `child`.
    f_get_path_for_child: ?*const fn (p_container: *gtk.Container, p_child: *gtk.Widget) callconv(.c) *gtk.WidgetPath,
    bitfields0: packed struct(c_uint) {
        f__handle_border_width: u1,
        _: u31,
    },
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,
    f__gtk_reserved7: ?*const fn () callconv(.c) void,
    f__gtk_reserved8: ?*const fn () callconv(.c) void,

    /// Finds a child property of a container class by name.
    extern fn gtk_container_class_find_child_property(p_cclass: *ContainerClass, p_property_name: [*:0]const u8) ?*gobject.ParamSpec;
    pub const findChildProperty = gtk_container_class_find_child_property;

    /// Modifies a subclass of `gtk.ContainerClass` to automatically add and
    /// remove the border-width setting on GtkContainer.  This allows the
    /// subclass to ignore the border width in its size request and
    /// allocate methods. The intent is for a subclass to invoke this
    /// in its class_init function.
    ///
    /// `gtk.ContainerClass.handleBorderWidth` is necessary because it
    /// would break API too badly to make this behavior the default. So
    /// subclasses must “opt in” to the parent class handling border_width
    /// for them.
    extern fn gtk_container_class_handle_border_width(p_klass: *ContainerClass) void;
    pub const handleBorderWidth = gtk_container_class_handle_border_width;

    /// Installs child properties on a container class.
    extern fn gtk_container_class_install_child_properties(p_cclass: *ContainerClass, p_n_pspecs: c_uint, p_pspecs: [*]*gobject.ParamSpec) void;
    pub const installChildProperties = gtk_container_class_install_child_properties;

    /// Installs a child property on a container class.
    extern fn gtk_container_class_install_child_property(p_cclass: *ContainerClass, p_property_id: c_uint, p_pspec: *gobject.ParamSpec) void;
    pub const installChildProperty = gtk_container_class_install_child_property;

    /// Returns all child properties of a container class.
    extern fn gtk_container_class_list_child_properties(p_cclass: *ContainerClass, p_n_properties: *c_uint) [*]*gobject.ParamSpec;
    pub const listChildProperties = gtk_container_class_list_child_properties;

    pub fn as(p_instance: *ContainerClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ContainerPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CssProviderClass = extern struct {
    pub const Instance = gtk.CssProvider;

    f_parent_class: gobject.ObjectClass,
    f_parsing_error: ?*const fn (p_provider: *gtk.CssProvider, p_section: *gtk.CssSection, p_error: *const glib.Error) callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CssProviderClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CssProviderPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Defines a part of a CSS document. Because sections are nested into
/// one another, you can use `gtk.CssSection.getParent` to get the
/// containing region.
pub const CssSection = opaque {
    /// Returns the line in the CSS document where this section end.
    /// The line number is 0-indexed, so the first line of the document
    /// will return 0.
    /// This value may change in future invocations of this function if
    /// `section` is not yet parsed completely. This will for example
    /// happen in the GtkCssProvider::parsing-error signal.
    /// The end position and line may be identical to the start
    /// position and line for sections which failed to parse anything
    /// successfully.
    extern fn gtk_css_section_get_end_line(p_section: *const CssSection) c_uint;
    pub const getEndLine = gtk_css_section_get_end_line;

    /// Returns the offset in bytes from the start of the current line
    /// returned via `gtk.CssSection.getEndLine`.
    /// This value may change in future invocations of this function if
    /// `section` is not yet parsed completely. This will for example
    /// happen in the GtkCssProvider::parsing-error signal.
    /// The end position and line may be identical to the start
    /// position and line for sections which failed to parse anything
    /// successfully.
    extern fn gtk_css_section_get_end_position(p_section: *const CssSection) c_uint;
    pub const getEndPosition = gtk_css_section_get_end_position;

    /// Gets the file that `section` was parsed from. If no such file exists,
    /// for example because the CSS was loaded via
    /// `gtk_css_provider_load_from_data``gtk.CssProvider.loadFromData`, then `NULL` is returned.
    extern fn gtk_css_section_get_file(p_section: *const CssSection) *gio.File;
    pub const getFile = gtk_css_section_get_file;

    /// Gets the parent section for the given `section`. The parent section is
    /// the section that contains this `section`. A special case are sections of
    /// type `GTK_CSS_SECTION_DOCUMENT`. Their parent will either be `NULL`
    /// if they are the original CSS document that was loaded by
    /// `gtk.CssProvider.loadFromFile` or a section of type
    /// `GTK_CSS_SECTION_IMPORT` if it was loaded with an import rule from
    /// a different file.
    extern fn gtk_css_section_get_parent(p_section: *const CssSection) ?*gtk.CssSection;
    pub const getParent = gtk_css_section_get_parent;

    /// Gets the type of information that `section` describes.
    extern fn gtk_css_section_get_section_type(p_section: *const CssSection) gtk.CssSectionType;
    pub const getSectionType = gtk_css_section_get_section_type;

    /// Returns the line in the CSS document where this section starts.
    /// The line number is 0-indexed, so the first line of the document
    /// will return 0.
    extern fn gtk_css_section_get_start_line(p_section: *const CssSection) c_uint;
    pub const getStartLine = gtk_css_section_get_start_line;

    /// Returns the offset in bytes from the start of the current line
    /// returned via `gtk.CssSection.getStartLine`.
    extern fn gtk_css_section_get_start_position(p_section: *const CssSection) c_uint;
    pub const getStartPosition = gtk_css_section_get_start_position;

    /// Increments the reference count on `section`.
    extern fn gtk_css_section_ref(p_section: *CssSection) *gtk.CssSection;
    pub const ref = gtk_css_section_ref;

    /// Decrements the reference count on `section`, freeing the
    /// structure if the reference count reaches 0.
    extern fn gtk_css_section_unref(p_section: *CssSection) void;
    pub const unref = gtk_css_section_unref;

    extern fn gtk_css_section_get_type() usize;
    pub const getGObjectType = gtk_css_section_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const DialogClass = extern struct {
    pub const Instance = gtk.Dialog;

    /// The parent class.
    f_parent_class: gtk.WindowClass,
    /// Signal emitted when an action widget is activated.
    f_response: ?*const fn (p_dialog: *gtk.Dialog, p_response_id: c_int) callconv(.c) void,
    /// Signal emitted when the user uses a keybinding to close the dialog.
    f_close: ?*const fn (p_dialog: *gtk.Dialog) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *DialogClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const DialogPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const DrawingAreaClass = extern struct {
    pub const Instance = gtk.DrawingArea;

    f_parent_class: gtk.WidgetClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *DrawingAreaClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EditableInterface = extern struct {
    pub const Instance = gtk.Editable;

    f_base_iface: gobject.TypeInterface,
    f_insert_text: ?*const fn (p_editable: *gtk.Editable, p_new_text: [*:0]const u8, p_new_text_length: c_int, p_position: *c_int) callconv(.c) void,
    f_delete_text: ?*const fn (p_editable: *gtk.Editable, p_start_pos: c_int, p_end_pos: c_int) callconv(.c) void,
    f_changed: ?*const fn (p_editable: *gtk.Editable) callconv(.c) void,
    f_do_insert_text: ?*const fn (p_editable: *gtk.Editable, p_new_text: [*:0]const u8, p_new_text_length: c_int, p_position: *c_int) callconv(.c) void,
    f_do_delete_text: ?*const fn (p_editable: *gtk.Editable, p_start_pos: c_int, p_end_pos: c_int) callconv(.c) void,
    f_get_chars: ?*const fn (p_editable: *gtk.Editable, p_start_pos: c_int, p_end_pos: c_int) callconv(.c) [*:0]u8,
    f_set_selection_bounds: ?*const fn (p_editable: *gtk.Editable, p_start_pos: c_int, p_end_pos: c_int) callconv(.c) void,
    f_get_selection_bounds: ?*const fn (p_editable: *gtk.Editable, p_start_pos: ?*c_int, p_end_pos: ?*c_int) callconv(.c) c_int,
    f_set_position: ?*const fn (p_editable: *gtk.Editable, p_position: c_int) callconv(.c) void,
    f_get_position: ?*const fn (p_editable: *gtk.Editable) callconv(.c) c_int,

    pub fn as(p_instance: *EditableInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EntryAccessibleClass = extern struct {
    pub const Instance = gtk.EntryAccessible;

    f_parent_class: gtk.WidgetAccessibleClass,

    pub fn as(p_instance: *EntryAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EntryAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EntryBufferClass = extern struct {
    pub const Instance = gtk.EntryBuffer;

    f_parent_class: gobject.ObjectClass,
    f_inserted_text: ?*const fn (p_buffer: *gtk.EntryBuffer, p_position: c_uint, p_chars: [*:0]const u8, p_n_chars: c_uint) callconv(.c) void,
    f_deleted_text: ?*const fn (p_buffer: *gtk.EntryBuffer, p_position: c_uint, p_n_chars: c_uint) callconv(.c) void,
    f_get_text: ?*const fn (p_buffer: *gtk.EntryBuffer, p_n_bytes: *usize) callconv(.c) [*:0]const u8,
    f_get_length: ?*const fn (p_buffer: *gtk.EntryBuffer) callconv(.c) c_uint,
    f_insert_text: ?*const fn (p_buffer: *gtk.EntryBuffer, p_position: c_uint, p_chars: [*:0]const u8, p_n_chars: c_uint) callconv(.c) c_uint,
    f_delete_text: ?*const fn (p_buffer: *gtk.EntryBuffer, p_position: c_uint, p_n_chars: c_uint) callconv(.c) c_uint,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,
    f__gtk_reserved7: ?*const fn () callconv(.c) void,
    f__gtk_reserved8: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *EntryBufferClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EntryBufferPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gtk.Entry`. All virtual functions have a default
/// implementation. Derived classes may set the virtual function pointers for the
/// signal handlers to `NULL`, but must keep `get_text_area_size` and
/// `get_frame_size` non-`NULL`; either use the default implementation, or provide
/// a custom one.
pub const EntryClass = extern struct {
    pub const Instance = gtk.Entry;

    /// The parent class.
    f_parent_class: gtk.WidgetClass,
    /// Class handler for the `gtk.Entry.signals.populate`-popup signal. If
    ///   non-`NULL`, this will be called to add additional entries to the context
    ///   menu when it is displayed.
    f_populate_popup: ?*const fn (p_entry: *gtk.Entry, p_popup: *gtk.Widget) callconv(.c) void,
    /// Class handler for the `gtk.Entry.signals.activate` signal. The default
    ///   implementation calls `gtk.Window.activateDefault` on the entry’s top-level
    ///   window.
    f_activate: ?*const fn (p_entry: *gtk.Entry) callconv(.c) void,
    /// Class handler for the `gtk.Entry.signals.move`-cursor signal. The
    ///   default implementation specifies the standard `gtk.Entry` cursor movement
    ///   behavior.
    f_move_cursor: ?*const fn (p_entry: *gtk.Entry, p_step: gtk.MovementStep, p_count: c_int, p_extend_selection: c_int) callconv(.c) void,
    /// Class handler for the `gtk.Entry.signals.insert`-at-cursor signal.
    ///   The default implementation inserts text at the cursor.
    f_insert_at_cursor: ?*const fn (p_entry: *gtk.Entry, p_str: [*:0]const u8) callconv(.c) void,
    /// Class handler for the `gtk.Entry.signals.delete`-from-cursor
    ///   signal. The default implementation deletes the selection or the specified
    ///   number of characters or words.
    f_delete_from_cursor: ?*const fn (p_entry: *gtk.Entry, p_type: gtk.DeleteType, p_count: c_int) callconv(.c) void,
    /// Class handler for the `gtk.Entry.signals.backspace` signal. The default
    ///   implementation deletes the selection or a single character or word.
    f_backspace: ?*const fn (p_entry: *gtk.Entry) callconv(.c) void,
    /// Class handler for the `gtk.Entry.signals.cut`-clipboard signal. The
    ///   default implementation cuts the selection, if one exists.
    f_cut_clipboard: ?*const fn (p_entry: *gtk.Entry) callconv(.c) void,
    /// Class handler for the `gtk.Entry.signals.copy`-clipboard signal. The
    ///   default implementation copies the selection, if one exists.
    f_copy_clipboard: ?*const fn (p_entry: *gtk.Entry) callconv(.c) void,
    /// Class handler for the `gtk.Entry.signals.paste`-clipboard signal.
    ///   The default implementation pastes at the current cursor position or over
    ///   the current selection if one exists.
    f_paste_clipboard: ?*const fn (p_entry: *gtk.Entry) callconv(.c) void,
    /// Class handler for the `gtk.Entry.signals.toggle`-overwrite signal.
    ///   The default implementation toggles overwrite mode and blinks the cursor.
    f_toggle_overwrite: ?*const fn (p_entry: *gtk.Entry) callconv(.c) void,
    /// Calculate the size of the text area, which is its
    ///   allocated width and requested height, minus space for margins and borders.
    ///   This virtual function must be non-`NULL`.
    f_get_text_area_size: ?*const fn (p_entry: *gtk.Entry, p_x: *c_int, p_y: *c_int, p_width: *c_int, p_height: *c_int) callconv(.c) void,
    /// Calculate the size of the text area frame, which is its
    ///   allocated width and requested height, minus space for margins and borders,
    ///   and taking baseline and text height into account. This virtual function
    ///   must be non-`NULL`.
    f_get_frame_size: ?*const fn (p_entry: *gtk.Entry, p_x: *c_int, p_y: *c_int, p_width: *c_int, p_height: *c_int) callconv(.c) void,
    f_insert_emoji: ?*const fn (p_entry: *gtk.Entry) callconv(.c) void,
    f_toggle_direction: ?*const fn (p_entry: *gtk.Entry) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *EntryClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EntryCompletionClass = extern struct {
    pub const Instance = gtk.EntryCompletion;

    f_parent_class: gobject.ObjectClass,
    f_match_selected: ?*const fn (p_completion: *gtk.EntryCompletion, p_model: *gtk.TreeModel, p_iter: *gtk.TreeIter) callconv(.c) c_int,
    f_action_activated: ?*const fn (p_completion: *gtk.EntryCompletion, p_index_: c_int) callconv(.c) void,
    f_insert_prefix: ?*const fn (p_completion: *gtk.EntryCompletion, p_prefix: [*:0]const u8) callconv(.c) c_int,
    f_cursor_on_match: ?*const fn (p_completion: *gtk.EntryCompletion, p_model: *gtk.TreeModel, p_iter: *gtk.TreeIter) callconv(.c) c_int,
    f_no_matches: ?*const fn (p_completion: *gtk.EntryCompletion) callconv(.c) void,
    f__gtk_reserved0: ?*const fn () callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *EntryCompletionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EntryCompletionPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EntryPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EventBoxClass = extern struct {
    pub const Instance = gtk.EventBox;

    /// The parent class.
    f_parent_class: gtk.BinClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *EventBoxClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EventBoxPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EventControllerClass = opaque {
    pub const Instance = gtk.EventController;

    pub fn as(p_instance: *EventControllerClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EventControllerKeyClass = opaque {
    pub const Instance = gtk.EventControllerKey;

    pub fn as(p_instance: *EventControllerKeyClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EventControllerMotionClass = opaque {
    pub const Instance = gtk.EventControllerMotion;

    pub fn as(p_instance: *EventControllerMotionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EventControllerScrollClass = opaque {
    pub const Instance = gtk.EventControllerScroll;

    pub fn as(p_instance: *EventControllerScrollClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ExpanderAccessibleClass = extern struct {
    pub const Instance = gtk.ExpanderAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *ExpanderAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ExpanderAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ExpanderClass = extern struct {
    pub const Instance = gtk.Expander;

    /// The parent class.
    f_parent_class: gtk.BinClass,
    /// Keybinding signal is emitted when the user hits the Enter key.
    f_activate: ?*const fn (p_expander: *gtk.Expander) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ExpanderClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ExpanderPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileChooserButtonClass = extern struct {
    pub const Instance = gtk.FileChooserButton;

    /// The parent class.
    f_parent_class: gtk.BoxClass,
    /// Signal emitted when the user selects a file.
    f_file_set: ?*const fn (p_fc: *gtk.FileChooserButton) callconv(.c) void,
    f___gtk_reserved1: ?*const fn () callconv(.c) void,
    f___gtk_reserved2: ?*const fn () callconv(.c) void,
    f___gtk_reserved3: ?*const fn () callconv(.c) void,
    f___gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FileChooserButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileChooserButtonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileChooserDialogClass = extern struct {
    pub const Instance = gtk.FileChooserDialog;

    f_parent_class: gtk.DialogClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FileChooserDialogClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileChooserDialogPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileChooserNativeClass = extern struct {
    pub const Instance = gtk.FileChooserNative;

    f_parent_class: gtk.NativeDialogClass,

    pub fn as(p_instance: *FileChooserNativeClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileChooserWidgetAccessibleClass = extern struct {
    pub const Instance = gtk.FileChooserWidgetAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *FileChooserWidgetAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileChooserWidgetAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileChooserWidgetClass = extern struct {
    pub const Instance = gtk.FileChooserWidget;

    /// The parent class.
    f_parent_class: gtk.BoxClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FileChooserWidgetClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileChooserWidgetPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.FileFilterInfo`-struct is used to pass information about the
/// tested file to `gtk.FileFilter.filter`.
pub const FileFilterInfo = extern struct {
    /// Flags indicating which of the following fields need
    ///   are filled
    f_contains: gtk.FileFilterFlags,
    /// the filename of the file being tested
    f_filename: ?[*:0]const u8,
    /// the URI for the file being tested
    f_uri: ?[*:0]const u8,
    /// the string that will be used to display the file
    ///   in the file chooser
    f_display_name: ?[*:0]const u8,
    /// the mime type of the file
    f_mime_type: ?[*:0]const u8,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FixedChild = extern struct {
    f_widget: ?*gtk.Widget,
    f_x: c_int,
    f_y: c_int,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FixedClass = extern struct {
    pub const Instance = gtk.Fixed;

    f_parent_class: gtk.ContainerClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FixedClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FixedPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FlowBoxAccessibleClass = extern struct {
    pub const Instance = gtk.FlowBoxAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *FlowBoxAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FlowBoxAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FlowBoxChildAccessibleClass = extern struct {
    pub const Instance = gtk.FlowBoxChildAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *FlowBoxChildAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FlowBoxChildClass = extern struct {
    pub const Instance = gtk.FlowBoxChild;

    f_parent_class: gtk.BinClass,
    f_activate: ?*const fn (p_child: *gtk.FlowBoxChild) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FlowBoxChildClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FlowBoxClass = extern struct {
    pub const Instance = gtk.FlowBox;

    f_parent_class: gtk.ContainerClass,
    f_child_activated: ?*const fn (p_box: *gtk.FlowBox, p_child: *gtk.FlowBoxChild) callconv(.c) void,
    f_selected_children_changed: ?*const fn (p_box: *gtk.FlowBox) callconv(.c) void,
    f_activate_cursor_child: ?*const fn (p_box: *gtk.FlowBox) callconv(.c) void,
    f_toggle_cursor_child: ?*const fn (p_box: *gtk.FlowBox) callconv(.c) void,
    f_move_cursor: ?*const fn (p_box: *gtk.FlowBox, p_step: gtk.MovementStep, p_count: c_int) callconv(.c) c_int,
    f_select_all: ?*const fn (p_box: *gtk.FlowBox) callconv(.c) void,
    f_unselect_all: ?*const fn (p_box: *gtk.FlowBox) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FlowBoxClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FontButtonClass = extern struct {
    pub const Instance = gtk.FontButton;

    f_parent_class: gtk.ButtonClass,
    f_font_set: ?*const fn (p_gfp: *gtk.FontButton) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FontButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FontButtonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FontChooserDialogClass = extern struct {
    pub const Instance = gtk.FontChooserDialog;

    /// The parent class.
    f_parent_class: gtk.DialogClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FontChooserDialogClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FontChooserDialogPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FontChooserIface = extern struct {
    pub const Instance = gtk.FontChooser;

    f_base_iface: gobject.TypeInterface,
    f_get_font_family: ?*const fn (p_fontchooser: *gtk.FontChooser) callconv(.c) ?*pango.FontFamily,
    f_get_font_face: ?*const fn (p_fontchooser: *gtk.FontChooser) callconv(.c) ?*pango.FontFace,
    f_get_font_size: ?*const fn (p_fontchooser: *gtk.FontChooser) callconv(.c) c_int,
    f_set_filter_func: ?*const fn (p_fontchooser: *gtk.FontChooser, p_filter: ?gtk.FontFilterFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) callconv(.c) void,
    f_font_activated: ?*const fn (p_chooser: *gtk.FontChooser, p_fontname: [*:0]const u8) callconv(.c) void,
    f_set_font_map: ?*const fn (p_fontchooser: *gtk.FontChooser, p_fontmap: ?*pango.FontMap) callconv(.c) void,
    f_get_font_map: ?*const fn (p_fontchooser: *gtk.FontChooser) callconv(.c) ?*pango.FontMap,
    f_padding: [10]*anyopaque,

    pub fn as(p_instance: *FontChooserIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FontChooserWidgetClass = extern struct {
    pub const Instance = gtk.FontChooserWidget;

    /// The parent class.
    f_parent_class: gtk.BoxClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,
    f__gtk_reserved7: ?*const fn () callconv(.c) void,
    f__gtk_reserved8: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FontChooserWidgetClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FontChooserWidgetPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FontSelectionClass = extern struct {
    pub const Instance = gtk.FontSelection;

    f_parent_class: gtk.BoxClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FontSelectionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FontSelectionDialogClass = extern struct {
    pub const Instance = gtk.FontSelectionDialog;

    f_parent_class: gtk.DialogClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FontSelectionDialogClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FontSelectionDialogPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FontSelectionPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FrameAccessibleClass = extern struct {
    pub const Instance = gtk.FrameAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *FrameAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FrameAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FrameClass = extern struct {
    pub const Instance = gtk.Frame;

    /// The parent class.
    f_parent_class: gtk.BinClass,
    f_compute_child_allocation: ?*const fn (p_frame: *gtk.Frame, p_allocation: *gtk.Allocation) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FrameClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FramePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `GtkGLAreaClass` structure contains only private data.
pub const GLAreaClass = extern struct {
    pub const Instance = gtk.GLArea;

    f_parent_class: gtk.WidgetClass,
    /// class closure for the `gtk.GLArea.signals.render` signal
    f_render: ?*const fn (p_area: *gtk.GLArea, p_context: *gdk.GLContext) callconv(.c) c_int,
    /// class closeure for the `gtk.GLArea.signals.resize` signal
    f_resize: ?*const fn (p_area: *gtk.GLArea, p_width: c_int, p_height: c_int) callconv(.c) void,
    /// class closure for the `gtk.GLArea.signals.create`-context signal
    f_create_context: ?*const fn (p_area: *gtk.GLArea) callconv(.c) *gdk.GLContext,
    f__padding: [6]*anyopaque,

    pub fn as(p_instance: *GLAreaClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const GestureClass = opaque {
    pub const Instance = gtk.Gesture;

    pub fn as(p_instance: *GestureClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const GestureDragClass = opaque {
    pub const Instance = gtk.GestureDrag;

    pub fn as(p_instance: *GestureDragClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const GestureLongPressClass = opaque {
    pub const Instance = gtk.GestureLongPress;

    pub fn as(p_instance: *GestureLongPressClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const GestureMultiPressClass = opaque {
    pub const Instance = gtk.GestureMultiPress;

    pub fn as(p_instance: *GestureMultiPressClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const GesturePanClass = opaque {
    pub const Instance = gtk.GesturePan;

    pub fn as(p_instance: *GesturePanClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const GestureRotateClass = opaque {
    pub const Instance = gtk.GestureRotate;

    pub fn as(p_instance: *GestureRotateClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const GestureSingleClass = opaque {
    pub const Instance = gtk.GestureSingle;

    pub fn as(p_instance: *GestureSingleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const GestureStylusClass = opaque {
    pub const Instance = gtk.GestureStylus;

    pub fn as(p_instance: *GestureStylusClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const GestureSwipeClass = opaque {
    pub const Instance = gtk.GestureSwipe;

    pub fn as(p_instance: *GestureSwipeClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const GestureZoomClass = opaque {
    pub const Instance = gtk.GestureZoom;

    pub fn as(p_instance: *GestureZoomClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkGradient is a boxed type that represents a gradient.
/// It is the result of parsing a
/// [gradient expression][gtkcssprovider-gradients].
/// To obtain the gradient represented by a GtkGradient, it has to
/// be resolved with `gtk.Gradient.resolve`, which replaces all
/// symbolic color references by the colors they refer to (in a given
/// context) and constructs a `cairo.Pattern` value.
///
/// It is not normally necessary to deal directly with `GtkGradients`,
/// since they are mostly used behind the scenes by `gtk.StyleContext` and
/// `gtk.CssProvider`.
///
/// `gtk.Gradient` is deprecated. It was used internally by GTK’s CSS engine
/// to represent gradients. As its handling is not conforming to modern
/// web standards, it is not used anymore. If you want to use gradients in
/// your own code, please use Cairo directly.
pub const Gradient = opaque {
    /// Creates a new linear gradient along the line defined by (x0, y0) and (x1, y1). Before using the gradient
    /// a number of stop colors must be added through `gtk.Gradient.addColorStop`.
    extern fn gtk_gradient_new_linear(p_x0: f64, p_y0: f64, p_x1: f64, p_y1: f64) *gtk.Gradient;
    pub const newLinear = gtk_gradient_new_linear;

    /// Creates a new radial gradient along the two circles defined by (x0, y0, radius0) and
    /// (x1, y1, radius1). Before using the gradient a number of stop colors must be added
    /// through `gtk.Gradient.addColorStop`.
    extern fn gtk_gradient_new_radial(p_x0: f64, p_y0: f64, p_radius0: f64, p_x1: f64, p_y1: f64, p_radius1: f64) *gtk.Gradient;
    pub const newRadial = gtk_gradient_new_radial;

    /// Adds a stop color to `gradient`.
    extern fn gtk_gradient_add_color_stop(p_gradient: *Gradient, p_offset: f64, p_color: *gtk.SymbolicColor) void;
    pub const addColorStop = gtk_gradient_add_color_stop;

    /// Increases the reference count of `gradient`.
    extern fn gtk_gradient_ref(p_gradient: *Gradient) *gtk.Gradient;
    pub const ref = gtk_gradient_ref;

    /// If `gradient` is resolvable, `resolved_gradient` will be filled in
    /// with the resolved gradient as a cairo_pattern_t, and `TRUE` will
    /// be returned. Generally, if `gradient` can’t be resolved, it is
    /// due to it being defined on top of a named color that doesn't
    /// exist in `props`.
    extern fn gtk_gradient_resolve(p_gradient: *Gradient, p_props: *gtk.StyleProperties, p_resolved_gradient: **cairo.Pattern) c_int;
    pub const resolve = gtk_gradient_resolve;

    extern fn gtk_gradient_resolve_for_context(p_gradient: *Gradient, p_context: *gtk.StyleContext) *cairo.Pattern;
    pub const resolveForContext = gtk_gradient_resolve_for_context;

    /// Creates a string representation for `gradient` that is suitable
    /// for using in GTK CSS files.
    extern fn gtk_gradient_to_string(p_gradient: *Gradient) [*:0]u8;
    pub const toString = gtk_gradient_to_string;

    /// Decreases the reference count of `gradient`, freeing its memory
    /// if the reference count reaches 0.
    extern fn gtk_gradient_unref(p_gradient: *Gradient) void;
    pub const unref = gtk_gradient_unref;

    extern fn gtk_gradient_get_type() usize;
    pub const getGObjectType = gtk_gradient_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const GridClass = extern struct {
    pub const Instance = gtk.Grid;

    /// The parent class.
    f_parent_class: gtk.ContainerClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,
    f__gtk_reserved7: ?*const fn () callconv(.c) void,
    f__gtk_reserved8: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *GridClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const GridPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HBoxClass = extern struct {
    pub const Instance = gtk.HBox;

    f_parent_class: gtk.BoxClass,

    pub fn as(p_instance: *HBoxClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HButtonBoxClass = extern struct {
    pub const Instance = gtk.HButtonBox;

    f_parent_class: gtk.ButtonBoxClass,

    pub fn as(p_instance: *HButtonBoxClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HPanedClass = extern struct {
    pub const Instance = gtk.HPaned;

    f_parent_class: gtk.PanedClass,

    pub fn as(p_instance: *HPanedClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HSVClass = extern struct {
    pub const Instance = gtk.HSV;

    f_parent_class: gtk.WidgetClass,
    f_changed: ?*const fn (p_hsv: *gtk.HSV) callconv(.c) void,
    f_move: ?*const fn (p_hsv: *gtk.HSV, p_type: gtk.DirectionType) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *HSVClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HSVPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HScaleClass = extern struct {
    pub const Instance = gtk.HScale;

    f_parent_class: gtk.ScaleClass,

    pub fn as(p_instance: *HScaleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HScrollbarClass = extern struct {
    pub const Instance = gtk.HScrollbar;

    f_parent_class: gtk.ScrollbarClass,

    pub fn as(p_instance: *HScrollbarClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HSeparatorClass = extern struct {
    pub const Instance = gtk.HSeparator;

    f_parent_class: gtk.SeparatorClass,

    pub fn as(p_instance: *HSeparatorClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HandleBoxClass = extern struct {
    pub const Instance = gtk.HandleBox;

    /// The parent class.
    f_parent_class: gtk.BinClass,
    /// Signal emitted when the contents of the handlebox
    ///    are reattached to the main window. Deprecated: 3.4.
    f_child_attached: ?*const fn (p_handle_box: *gtk.HandleBox, p_child: *gtk.Widget) callconv(.c) void,
    /// Signal emitted when the contents of the handlebox
    ///    are detached from the main window. Deprecated: 3.4.
    f_child_detached: ?*const fn (p_handle_box: *gtk.HandleBox, p_child: *gtk.Widget) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *HandleBoxClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HandleBoxPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HeaderBarAccessibleClass = extern struct {
    pub const Instance = gtk.HeaderBarAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *HeaderBarAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HeaderBarAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HeaderBarClass = extern struct {
    pub const Instance = gtk.HeaderBar;

    f_parent_class: gtk.ContainerClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *HeaderBarClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const HeaderBarPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IMContextClass = extern struct {
    pub const Instance = gtk.IMContext;

    f_parent_class: gobject.ObjectClass,
    /// Default handler of the `gtk.IMContext.signals.preedit`-start signal.
    f_preedit_start: ?*const fn (p_context: *gtk.IMContext) callconv(.c) void,
    /// Default handler of the `gtk.IMContext.signals.preedit`-end signal.
    f_preedit_end: ?*const fn (p_context: *gtk.IMContext) callconv(.c) void,
    /// Default handler of the `gtk.IMContext.signals.preedit`-changed
    ///   signal.
    f_preedit_changed: ?*const fn (p_context: *gtk.IMContext) callconv(.c) void,
    /// Default handler of the `gtk.IMContext.signals.commit` signal.
    f_commit: ?*const fn (p_context: *gtk.IMContext, p_str: [*:0]const u8) callconv(.c) void,
    /// Default handler of the
    ///   `gtk.IMContext.signals.retrieve`-surrounding signal.
    f_retrieve_surrounding: ?*const fn (p_context: *gtk.IMContext) callconv(.c) c_int,
    /// Default handler of the
    ///   `gtk.IMContext.signals.delete`-surrounding signal.
    f_delete_surrounding: ?*const fn (p_context: *gtk.IMContext, p_offset: c_int, p_n_chars: c_int) callconv(.c) c_int,
    /// Called via `gtk.IMContext.setClientWindow` when the
    ///   input window where the entered text will appear changes. Override this to
    ///   keep track of the current input window, for instance for the purpose of
    ///   positioning a status display of your input method.
    f_set_client_window: ?*const fn (p_context: *gtk.IMContext, p_window: ?*gdk.Window) callconv(.c) void,
    /// Called via `gtk.IMContext.getPreeditString` to
    ///   retrieve the text currently being preedited for display at the cursor
    ///   position. Any input method which composes complex characters or any
    ///   other compositions from multiple sequential key presses should override
    ///   this method to provide feedback.
    f_get_preedit_string: ?*const fn (p_context: *gtk.IMContext, p_str: *[*:0]u8, p_attrs: **pango.AttrList, p_cursor_pos: *c_int) callconv(.c) void,
    /// Called via `gtk.IMContext.filterKeypress` on every
    ///   key press or release event. Every non-trivial input method needs to
    ///   override this in order to implement the mapping from key events to text.
    ///   A return value of `TRUE` indicates to the caller that the event was
    ///   consumed by the input method. In that case, the `gtk.IMContext.signals.commit`
    ///   signal should be emitted upon completion of a key sequence to pass the
    ///   resulting text back to the input widget. Alternatively, `FALSE` may be
    ///   returned to indicate that the event wasn’t handled by the input method.
    ///   If a builtin mapping exists for the key, it is used to produce a
    ///   character.
    f_filter_keypress: ?*const fn (p_context: *gtk.IMContext, p_event: *gdk.EventKey) callconv(.c) c_int,
    /// Called via `gtk.IMContext.focusIn` when the input widget
    ///   has gained focus. May be overridden to keep track of the current focus.
    f_focus_in: ?*const fn (p_context: *gtk.IMContext) callconv(.c) void,
    /// Called via `gtk.IMContext.focusOut` when the input widget
    ///   has lost focus. May be overridden to keep track of the current focus.
    f_focus_out: ?*const fn (p_context: *gtk.IMContext) callconv(.c) void,
    /// Called via `gtk.IMContext.reset` to signal a change such as a
    ///   change in cursor position. An input method that implements preediting
    ///   should override this method to clear the preedit state on reset.
    f_reset: ?*const fn (p_context: *gtk.IMContext) callconv(.c) void,
    /// Called via `gtk.IMContext.setCursorLocation`
    ///   to inform the input method of the current cursor location relative to
    ///   the client window. May be overridden to implement the display of popup
    ///   windows at the cursor position.
    f_set_cursor_location: ?*const fn (p_context: *gtk.IMContext, p_area: *gdk.Rectangle) callconv(.c) void,
    /// Called via `gtk.IMContext.setUsePreedit` to control
    ///   the use of the preedit string. Override this to display feedback by some
    ///   other means if turned off.
    f_set_use_preedit: ?*const fn (p_context: *gtk.IMContext, p_use_preedit: c_int) callconv(.c) void,
    /// Called via `gtk.IMContext.setSurrounding` in response
    ///   to signal `gtk.IMContext.signals.retrieve`-surrounding to update the input
    ///   method’s idea of the context around the cursor. It is not necessary to
    ///   override this method even with input methods which implement
    ///   context-dependent behavior. The base implementation is sufficient for
    ///   `gtk.IMContext.getSurrounding` to work.
    f_set_surrounding: ?*const fn (p_context: *gtk.IMContext, p_text: [*:0]const u8, p_len: c_int, p_cursor_index: c_int) callconv(.c) void,
    /// Called via `gtk.IMContext.getSurrounding` to update
    ///   the context around the cursor location. It is not necessary to override
    ///   this method even with input methods which implement context-dependent
    ///   behavior. The base implementation emits
    ///   `gtk.IMContext.signals.retrieve`-surrounding and records the context received
    ///   by the subsequent invocation of `get_surrounding`.
    f_get_surrounding: ?*const fn (p_context: *gtk.IMContext, p_text: *[*:0]u8, p_cursor_index: *c_int) callconv(.c) c_int,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *IMContextClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Bookkeeping information about a loadable input method.
pub const IMContextInfo = extern struct {
    /// The unique identification string of the input method.
    f_context_id: ?[*:0]const u8,
    /// The human-readable name of the input method.
    f_context_name: ?[*:0]const u8,
    /// Translation domain to be used with `dgettext`
    f_domain: ?[*:0]const u8,
    /// Name of locale directory for use with `bindtextdomain`
    f_domain_dirname: ?[*:0]const u8,
    /// A colon-separated list of locales where this input method
    ///   should be the default. The asterisk “*” sets the default for all locales.
    f_default_locales: ?[*:0]const u8,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IMContextSimpleClass = extern struct {
    pub const Instance = gtk.IMContextSimple;

    f_parent_class: gtk.IMContextClass,

    pub fn as(p_instance: *IMContextSimpleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IMContextSimplePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IMMulticontextClass = extern struct {
    pub const Instance = gtk.IMMulticontext;

    f_parent_class: gtk.IMContextClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *IMMulticontextClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IMMulticontextPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IconFactoryClass = extern struct {
    pub const Instance = gtk.IconFactory;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *IconFactoryClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IconFactoryPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IconInfoClass = opaque {
    pub const Instance = gtk.IconInfo;

    pub fn as(p_instance: *IconInfoClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IconSet = opaque {
    /// Creates a new `gtk.IconSet`. A `gtk.IconSet` represents a single icon
    /// in various sizes and widget states. It can provide a `gdkpixbuf.Pixbuf`
    /// for a given size and state on request, and automatically caches
    /// some of the rendered `gdkpixbuf.Pixbuf` objects.
    ///
    /// Normally you would use `gtk.Widget.renderIconPixbuf` instead of
    /// using `gtk.IconSet` directly. The one case where you’d use
    /// `gtk.IconSet` is to create application-specific icon sets to place in
    /// a `gtk.IconFactory`.
    extern fn gtk_icon_set_new() *gtk.IconSet;
    pub const new = gtk_icon_set_new;

    /// Creates a new `gtk.IconSet` with `pixbuf` as the default/fallback
    /// source image. If you don’t add any additional `gtk.IconSource` to the
    /// icon set, all variants of the icon will be created from `pixbuf`,
    /// using scaling, pixelation, etc. as required to adjust the icon size
    /// or make the icon look insensitive/prelighted.
    extern fn gtk_icon_set_new_from_pixbuf(p_pixbuf: *gdkpixbuf.Pixbuf) *gtk.IconSet;
    pub const newFromPixbuf = gtk_icon_set_new_from_pixbuf;

    /// Icon sets have a list of `gtk.IconSource`, which they use as base
    /// icons for rendering icons in different states and sizes. Icons are
    /// scaled, made to look insensitive, etc. in
    /// `gtk.IconSet.renderIcon`, but `gtk.IconSet` needs base images to
    /// work with. The base images and when to use them are described by
    /// a `gtk.IconSource`.
    ///
    /// This function copies `source`, so you can reuse the same source immediately
    /// without affecting the icon set.
    ///
    /// An example of when you’d use this function: a web browser’s "Back
    /// to Previous Page" icon might point in a different direction in
    /// Hebrew and in English; it might look different when insensitive;
    /// and it might change size depending on toolbar mode (small/large
    /// icons). So a single icon set would contain all those variants of
    /// the icon, and you might add a separate source for each one.
    ///
    /// You should nearly always add a “default” icon source with all
    /// fields wildcarded, which will be used as a fallback if no more
    /// specific source matches. `gtk.IconSet` always prefers more specific
    /// icon sources to more generic icon sources. The order in which you
    /// add the sources to the icon set does not matter.
    ///
    /// `gtk.IconSet.newFromPixbuf` creates a new icon set with a
    /// default icon source based on the given pixbuf.
    extern fn gtk_icon_set_add_source(p_icon_set: *IconSet, p_source: *const gtk.IconSource) void;
    pub const addSource = gtk_icon_set_add_source;

    /// Copies `icon_set` by value.
    extern fn gtk_icon_set_copy(p_icon_set: *IconSet) *gtk.IconSet;
    pub const copy = gtk_icon_set_copy;

    /// Obtains a list of icon sizes this icon set can render. The returned
    /// array must be freed with `glib.free`.
    extern fn gtk_icon_set_get_sizes(p_icon_set: *IconSet, p_sizes: *[*]c_int, p_n_sizes: *c_int) void;
    pub const getSizes = gtk_icon_set_get_sizes;

    /// Increments the reference count on `icon_set`.
    extern fn gtk_icon_set_ref(p_icon_set: *IconSet) *gtk.IconSet;
    pub const ref = gtk_icon_set_ref;

    /// Renders an icon using `gtk.Style.renderIcon`. In most cases,
    /// `gtk.Widget.renderIcon` is better, since it automatically provides
    /// most of the arguments from the current widget settings.  This
    /// function never returns `NULL`; if the icon can’t be rendered
    /// (perhaps because an image file fails to load), a default "missing
    /// image" icon will be returned instead.
    extern fn gtk_icon_set_render_icon(p_icon_set: *IconSet, p_style: ?*gtk.Style, p_direction: gtk.TextDirection, p_state: gtk.StateType, p_size: c_int, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8) *gdkpixbuf.Pixbuf;
    pub const renderIcon = gtk_icon_set_render_icon;

    /// Renders an icon using `gtk.renderIconPixbuf`. In most cases,
    /// `gtk.Widget.renderIconPixbuf` is better, since it automatically provides
    /// most of the arguments from the current widget settings.  This
    /// function never returns `NULL`; if the icon can’t be rendered
    /// (perhaps because an image file fails to load), a default "missing
    /// image" icon will be returned instead.
    extern fn gtk_icon_set_render_icon_pixbuf(p_icon_set: *IconSet, p_context: *gtk.StyleContext, p_size: c_int) *gdkpixbuf.Pixbuf;
    pub const renderIconPixbuf = gtk_icon_set_render_icon_pixbuf;

    /// Renders an icon using `gtk.renderIconPixbuf` and converts it to a
    /// cairo surface.
    ///
    /// This function never returns `NULL`; if the icon can’t be rendered
    /// (perhaps because an image file fails to load), a default "missing
    /// image" icon will be returned instead.
    extern fn gtk_icon_set_render_icon_surface(p_icon_set: *IconSet, p_context: *gtk.StyleContext, p_size: c_int, p_scale: c_int, p_for_window: ?*gdk.Window) *cairo.Surface;
    pub const renderIconSurface = gtk_icon_set_render_icon_surface;

    /// Decrements the reference count on `icon_set`, and frees memory
    /// if the reference count reaches 0.
    extern fn gtk_icon_set_unref(p_icon_set: *IconSet) void;
    pub const unref = gtk_icon_set_unref;

    extern fn gtk_icon_set_get_type() usize;
    pub const getGObjectType = gtk_icon_set_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IconSource = opaque {
    /// Creates a new `gtk.IconSource`. A `gtk.IconSource` contains a `gdkpixbuf.Pixbuf` (or
    /// image filename) that serves as the base image for one or more of the
    /// icons in a `gtk.IconSet`, along with a specification for which icons in the
    /// icon set will be based on that pixbuf or image file. An icon set contains
    /// a set of icons that represent “the same” logical concept in different states,
    /// different global text directions, and different sizes.
    ///
    /// So for example a web browser’s “Back to Previous Page” icon might
    /// point in a different direction in Hebrew and in English; it might
    /// look different when insensitive; and it might change size depending
    /// on toolbar mode (small/large icons). So a single icon set would
    /// contain all those variants of the icon. `gtk.IconSet` contains a list
    /// of `gtk.IconSource` from which it can derive specific icon variants in
    /// the set.
    ///
    /// In the simplest case, `gtk.IconSet` contains one source pixbuf from
    /// which it derives all variants. The convenience function
    /// `gtk.IconSet.newFromPixbuf` handles this case; if you only have
    /// one source pixbuf, just use that function.
    ///
    /// If you want to use a different base pixbuf for different icon
    /// variants, you create multiple icon sources, mark which variants
    /// they’ll be used to create, and add them to the icon set with
    /// `gtk.IconSet.addSource`.
    ///
    /// By default, the icon source has all parameters wildcarded. That is,
    /// the icon source will be used as the base icon for any desired text
    /// direction, widget state, or icon size.
    extern fn gtk_icon_source_new() *gtk.IconSource;
    pub const new = gtk_icon_source_new;

    /// Creates a copy of `source`; mostly useful for language bindings.
    extern fn gtk_icon_source_copy(p_source: *const IconSource) *gtk.IconSource;
    pub const copy = gtk_icon_source_copy;

    /// Frees a dynamically-allocated icon source, along with its
    /// filename, size, and pixbuf fields if those are not `NULL`.
    extern fn gtk_icon_source_free(p_source: *IconSource) void;
    pub const free = gtk_icon_source_free;

    /// Obtains the text direction this icon source applies to. The return
    /// value is only useful/meaningful if the text direction is not
    /// wildcarded.
    extern fn gtk_icon_source_get_direction(p_source: *const IconSource) gtk.TextDirection;
    pub const getDirection = gtk_icon_source_get_direction;

    /// Gets the value set by `gtk.IconSource.setDirectionWildcarded`.
    extern fn gtk_icon_source_get_direction_wildcarded(p_source: *const IconSource) c_int;
    pub const getDirectionWildcarded = gtk_icon_source_get_direction_wildcarded;

    /// Retrieves the source filename, or `NULL` if none is set. The
    /// filename is not a copy, and should not be modified or expected to
    /// persist beyond the lifetime of the icon source.
    extern fn gtk_icon_source_get_filename(p_source: *const IconSource) [*:0]const u8;
    pub const getFilename = gtk_icon_source_get_filename;

    /// Retrieves the source icon name, or `NULL` if none is set. The
    /// icon_name is not a copy, and should not be modified or expected to
    /// persist beyond the lifetime of the icon source.
    extern fn gtk_icon_source_get_icon_name(p_source: *const IconSource) [*:0]const u8;
    pub const getIconName = gtk_icon_source_get_icon_name;

    /// Retrieves the source pixbuf, or `NULL` if none is set.
    /// In addition, if a filename source is in use, this
    /// function in some cases will return the pixbuf from
    /// loaded from the filename. This is, for example, true
    /// for the GtkIconSource passed to the `gtk.Style` `render_icon`
    /// virtual function. The reference count on the pixbuf is
    /// not incremented.
    extern fn gtk_icon_source_get_pixbuf(p_source: *const IconSource) *gdkpixbuf.Pixbuf;
    pub const getPixbuf = gtk_icon_source_get_pixbuf;

    /// Obtains the icon size this source applies to. The return value
    /// is only useful/meaningful if the icon size is not wildcarded.
    extern fn gtk_icon_source_get_size(p_source: *const IconSource) c_int;
    pub const getSize = gtk_icon_source_get_size;

    /// Gets the value set by `gtk.IconSource.setSizeWildcarded`.
    extern fn gtk_icon_source_get_size_wildcarded(p_source: *const IconSource) c_int;
    pub const getSizeWildcarded = gtk_icon_source_get_size_wildcarded;

    /// Obtains the widget state this icon source applies to. The return
    /// value is only useful/meaningful if the widget state is not
    /// wildcarded.
    extern fn gtk_icon_source_get_state(p_source: *const IconSource) gtk.StateType;
    pub const getState = gtk_icon_source_get_state;

    /// Gets the value set by `gtk.IconSource.setStateWildcarded`.
    extern fn gtk_icon_source_get_state_wildcarded(p_source: *const IconSource) c_int;
    pub const getStateWildcarded = gtk_icon_source_get_state_wildcarded;

    /// Sets the text direction this icon source is intended to be used
    /// with.
    ///
    /// Setting the text direction on an icon source makes no difference
    /// if the text direction is wildcarded. Therefore, you should usually
    /// call `gtk.IconSource.setDirectionWildcarded` to un-wildcard it
    /// in addition to calling this function.
    extern fn gtk_icon_source_set_direction(p_source: *IconSource, p_direction: gtk.TextDirection) void;
    pub const setDirection = gtk_icon_source_set_direction;

    /// If the text direction is wildcarded, this source can be used
    /// as the base image for an icon in any `gtk.TextDirection`.
    /// If the text direction is not wildcarded, then the
    /// text direction the icon source applies to should be set
    /// with `gtk.IconSource.setDirection`, and the icon source
    /// will only be used with that text direction.
    ///
    /// `gtk.IconSet` prefers non-wildcarded sources (exact matches) over
    /// wildcarded sources, and will use an exact match when possible.
    extern fn gtk_icon_source_set_direction_wildcarded(p_source: *IconSource, p_setting: c_int) void;
    pub const setDirectionWildcarded = gtk_icon_source_set_direction_wildcarded;

    /// Sets the name of an image file to use as a base image when creating
    /// icon variants for `gtk.IconSet`. The filename must be absolute.
    extern fn gtk_icon_source_set_filename(p_source: *IconSource, p_filename: [*:0]const u8) void;
    pub const setFilename = gtk_icon_source_set_filename;

    /// Sets the name of an icon to look up in the current icon theme
    /// to use as a base image when creating icon variants for `gtk.IconSet`.
    extern fn gtk_icon_source_set_icon_name(p_source: *IconSource, p_icon_name: ?[*:0]const u8) void;
    pub const setIconName = gtk_icon_source_set_icon_name;

    /// Sets a pixbuf to use as a base image when creating icon variants
    /// for `gtk.IconSet`.
    extern fn gtk_icon_source_set_pixbuf(p_source: *IconSource, p_pixbuf: *gdkpixbuf.Pixbuf) void;
    pub const setPixbuf = gtk_icon_source_set_pixbuf;

    /// Sets the icon size this icon source is intended to be used
    /// with.
    ///
    /// Setting the icon size on an icon source makes no difference
    /// if the size is wildcarded. Therefore, you should usually
    /// call `gtk.IconSource.setSizeWildcarded` to un-wildcard it
    /// in addition to calling this function.
    extern fn gtk_icon_source_set_size(p_source: *IconSource, p_size: c_int) void;
    pub const setSize = gtk_icon_source_set_size;

    /// If the icon size is wildcarded, this source can be used as the base
    /// image for an icon of any size.  If the size is not wildcarded, then
    /// the size the source applies to should be set with
    /// `gtk.IconSource.setSize` and the icon source will only be used
    /// with that specific size.
    ///
    /// `gtk.IconSet` prefers non-wildcarded sources (exact matches) over
    /// wildcarded sources, and will use an exact match when possible.
    ///
    /// `gtk.IconSet` will normally scale wildcarded source images to produce
    /// an appropriate icon at a given size, but will not change the size
    /// of source images that match exactly.
    extern fn gtk_icon_source_set_size_wildcarded(p_source: *IconSource, p_setting: c_int) void;
    pub const setSizeWildcarded = gtk_icon_source_set_size_wildcarded;

    /// Sets the widget state this icon source is intended to be used
    /// with.
    ///
    /// Setting the widget state on an icon source makes no difference
    /// if the state is wildcarded. Therefore, you should usually
    /// call `gtk.IconSource.setStateWildcarded` to un-wildcard it
    /// in addition to calling this function.
    extern fn gtk_icon_source_set_state(p_source: *IconSource, p_state: gtk.StateType) void;
    pub const setState = gtk_icon_source_set_state;

    /// If the widget state is wildcarded, this source can be used as the
    /// base image for an icon in any `gtk.StateType`.  If the widget state
    /// is not wildcarded, then the state the source applies to should be
    /// set with `gtk.IconSource.setState` and the icon source will
    /// only be used with that specific state.
    ///
    /// `gtk.IconSet` prefers non-wildcarded sources (exact matches) over
    /// wildcarded sources, and will use an exact match when possible.
    ///
    /// `gtk.IconSet` will normally transform wildcarded source images to
    /// produce an appropriate icon for a given state, for example
    /// lightening an image on prelight, but will not modify source images
    /// that match exactly.
    extern fn gtk_icon_source_set_state_wildcarded(p_source: *IconSource, p_setting: c_int) void;
    pub const setStateWildcarded = gtk_icon_source_set_state_wildcarded;

    extern fn gtk_icon_source_get_type() usize;
    pub const getGObjectType = gtk_icon_source_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IconThemeClass = extern struct {
    pub const Instance = gtk.IconTheme;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    /// Signal emitted when the current icon theme is switched or
    ///    GTK+ detects that a change has occurred in the contents of the
    ///    current icon theme.
    f_changed: ?*const fn (p_icon_theme: *gtk.IconTheme) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *IconThemeClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IconThemePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IconViewAccessibleClass = extern struct {
    pub const Instance = gtk.IconViewAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *IconViewAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IconViewAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IconViewClass = extern struct {
    pub const Instance = gtk.IconView;

    f_parent_class: gtk.ContainerClass,
    f_item_activated: ?*const fn (p_icon_view: *gtk.IconView, p_path: *gtk.TreePath) callconv(.c) void,
    f_selection_changed: ?*const fn (p_icon_view: *gtk.IconView) callconv(.c) void,
    f_select_all: ?*const fn (p_icon_view: *gtk.IconView) callconv(.c) void,
    f_unselect_all: ?*const fn (p_icon_view: *gtk.IconView) callconv(.c) void,
    f_select_cursor_item: ?*const fn (p_icon_view: *gtk.IconView) callconv(.c) void,
    f_toggle_cursor_item: ?*const fn (p_icon_view: *gtk.IconView) callconv(.c) void,
    f_move_cursor: ?*const fn (p_icon_view: *gtk.IconView, p_step: gtk.MovementStep, p_count: c_int) callconv(.c) c_int,
    f_activate_cursor_item: ?*const fn (p_icon_view: *gtk.IconView) callconv(.c) c_int,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *IconViewClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IconViewPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ImageAccessibleClass = extern struct {
    pub const Instance = gtk.ImageAccessible;

    f_parent_class: gtk.WidgetAccessibleClass,

    pub fn as(p_instance: *ImageAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ImageAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ImageCellAccessibleClass = extern struct {
    pub const Instance = gtk.ImageCellAccessible;

    f_parent_class: gtk.RendererCellAccessibleClass,

    pub fn as(p_instance: *ImageCellAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ImageCellAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ImageClass = extern struct {
    pub const Instance = gtk.Image;

    f_parent_class: gtk.MiscClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ImageClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ImageMenuItemClass = extern struct {
    pub const Instance = gtk.ImageMenuItem;

    /// The parent class.
    f_parent_class: gtk.MenuItemClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ImageMenuItemClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ImageMenuItemPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ImagePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const InfoBarClass = extern struct {
    pub const Instance = gtk.InfoBar;

    f_parent_class: gtk.BoxClass,
    f_response: ?*const fn (p_info_bar: *gtk.InfoBar, p_response_id: c_int) callconv(.c) void,
    f_close: ?*const fn (p_info_bar: *gtk.InfoBar) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *InfoBarClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const InfoBarPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const InvisibleClass = extern struct {
    pub const Instance = gtk.Invisible;

    f_parent_class: gtk.WidgetClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *InvisibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const InvisiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LabelAccessibleClass = extern struct {
    pub const Instance = gtk.LabelAccessible;

    f_parent_class: gtk.WidgetAccessibleClass,

    pub fn as(p_instance: *LabelAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LabelAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LabelClass = extern struct {
    pub const Instance = gtk.Label;

    f_parent_class: gtk.MiscClass,
    f_move_cursor: ?*const fn (p_label: *gtk.Label, p_step: gtk.MovementStep, p_count: c_int, p_extend_selection: c_int) callconv(.c) void,
    f_copy_clipboard: ?*const fn (p_label: *gtk.Label) callconv(.c) void,
    f_populate_popup: ?*const fn (p_label: *gtk.Label, p_menu: *gtk.Menu) callconv(.c) void,
    f_activate_link: ?*const fn (p_label: *gtk.Label, p_uri: [*:0]const u8) callconv(.c) c_int,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,
    f__gtk_reserved7: ?*const fn () callconv(.c) void,
    f__gtk_reserved8: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *LabelClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LabelPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LabelSelectionInfo = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LayoutClass = extern struct {
    pub const Instance = gtk.Layout;

    f_parent_class: gtk.ContainerClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *LayoutClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LayoutPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LevelBarAccessibleClass = extern struct {
    pub const Instance = gtk.LevelBarAccessible;

    f_parent_class: gtk.WidgetAccessibleClass,

    pub fn as(p_instance: *LevelBarAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LevelBarAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LevelBarClass = extern struct {
    pub const Instance = gtk.LevelBar;

    f_parent_class: gtk.WidgetClass,
    f_offset_changed: ?*const fn (p_self: *gtk.LevelBar, p_name: [*:0]const u8) callconv(.c) void,
    f_padding: [16]*anyopaque,

    pub fn as(p_instance: *LevelBarClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LevelBarPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LinkButtonAccessibleClass = extern struct {
    pub const Instance = gtk.LinkButtonAccessible;

    f_parent_class: gtk.ButtonAccessibleClass,

    pub fn as(p_instance: *LinkButtonAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LinkButtonAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.LinkButtonClass` contains only
/// private data.
pub const LinkButtonClass = extern struct {
    pub const Instance = gtk.LinkButton;

    f_parent_class: gtk.ButtonClass,
    /// class handler for the `gtk.LinkButton.signals.activate`-link signal
    f_activate_link: ?*const fn (p_button: *gtk.LinkButton) callconv(.c) c_int,
    f__gtk_padding1: ?*const fn () callconv(.c) void,
    f__gtk_padding2: ?*const fn () callconv(.c) void,
    f__gtk_padding3: ?*const fn () callconv(.c) void,
    f__gtk_padding4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *LinkButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LinkButtonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ListBoxAccessibleClass = extern struct {
    pub const Instance = gtk.ListBoxAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *ListBoxAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ListBoxAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ListBoxClass = extern struct {
    pub const Instance = gtk.ListBox;

    /// The parent class.
    f_parent_class: gtk.ContainerClass,
    /// Class handler for the `gtk.ListBox.signals.row`-selected signal
    f_row_selected: ?*const fn (p_box: *gtk.ListBox, p_row: *gtk.ListBoxRow) callconv(.c) void,
    /// Class handler for the `gtk.ListBox.signals.row`-activated signal
    f_row_activated: ?*const fn (p_box: *gtk.ListBox, p_row: *gtk.ListBoxRow) callconv(.c) void,
    /// Class handler for the `gtk.ListBox.signals.activate`-cursor-row signal
    f_activate_cursor_row: ?*const fn (p_box: *gtk.ListBox) callconv(.c) void,
    /// Class handler for the `gtk.ListBox.signals.toggle`-cursor-row signal
    f_toggle_cursor_row: ?*const fn (p_box: *gtk.ListBox) callconv(.c) void,
    /// Class handler for the `gtk.ListBox.signals.move`-cursor signal
    f_move_cursor: ?*const fn (p_box: *gtk.ListBox, p_step: gtk.MovementStep, p_count: c_int) callconv(.c) void,
    /// Class handler for the `gtk.ListBox.signals.selected`-rows-changed signal
    f_selected_rows_changed: ?*const fn (p_box: *gtk.ListBox) callconv(.c) void,
    /// Class handler for the `gtk.ListBox.signals.select`-all signal
    f_select_all: ?*const fn (p_box: *gtk.ListBox) callconv(.c) void,
    /// Class handler for the `gtk.ListBox.signals.unselect`-all signal
    f_unselect_all: ?*const fn (p_box: *gtk.ListBox) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ListBoxClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ListBoxRowAccessibleClass = extern struct {
    pub const Instance = gtk.ListBoxRowAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *ListBoxRowAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ListBoxRowClass = extern struct {
    pub const Instance = gtk.ListBoxRow;

    /// The parent class.
    f_parent_class: gtk.BinClass,
    f_activate: ?*const fn (p_row: *gtk.ListBoxRow) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ListBoxRowClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ListStoreClass = extern struct {
    pub const Instance = gtk.ListStore;

    f_parent_class: gobject.ObjectClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ListStoreClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ListStorePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LockButtonAccessibleClass = extern struct {
    pub const Instance = gtk.LockButtonAccessible;

    f_parent_class: gtk.ButtonAccessibleClass,

    pub fn as(p_instance: *LockButtonAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LockButtonAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LockButtonClass = extern struct {
    pub const Instance = gtk.LockButton;

    /// The parent class.
    f_parent_class: gtk.ButtonClass,
    f_reserved0: ?*const fn () callconv(.c) void,
    f_reserved1: ?*const fn () callconv(.c) void,
    f_reserved2: ?*const fn () callconv(.c) void,
    f_reserved3: ?*const fn () callconv(.c) void,
    f_reserved4: ?*const fn () callconv(.c) void,
    f_reserved5: ?*const fn () callconv(.c) void,
    f_reserved6: ?*const fn () callconv(.c) void,
    f_reserved7: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *LockButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const LockButtonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuAccessibleClass = extern struct {
    pub const Instance = gtk.MenuAccessible;

    f_parent_class: gtk.MenuShellAccessibleClass,

    pub fn as(p_instance: *MenuAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuBarClass = extern struct {
    pub const Instance = gtk.MenuBar;

    f_parent_class: gtk.MenuShellClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *MenuBarClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuBarPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuButtonAccessibleClass = extern struct {
    pub const Instance = gtk.MenuButtonAccessible;

    f_parent_class: gtk.ToggleButtonAccessibleClass,

    pub fn as(p_instance: *MenuButtonAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuButtonAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuButtonClass = extern struct {
    pub const Instance = gtk.MenuButton;

    f_parent_class: gtk.ToggleButtonClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *MenuButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuButtonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuClass = extern struct {
    pub const Instance = gtk.Menu;

    f_parent_class: gtk.MenuShellClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *MenuClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuItemAccessibleClass = extern struct {
    pub const Instance = gtk.MenuItemAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *MenuItemAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuItemAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuItemClass = extern struct {
    pub const Instance = gtk.MenuItem;

    /// The parent class.
    f_parent_class: gtk.BinClass,
    bitfields0: packed struct(c_uint) {
        /// If `TRUE`, then we should always
        ///    hide the menu when the `gtk.MenuItem` is activated. Otherwise,
        ///    it is up to the caller.
        f_hide_on_activate: u1,
        _: u31,
    },
    /// Signal emitted when the item is activated.
    f_activate: ?*const fn (p_menu_item: *gtk.MenuItem) callconv(.c) void,
    /// Signal emitted when the item is activated, but also
    ///    if the menu item has a submenu.
    f_activate_item: ?*const fn (p_menu_item: *gtk.MenuItem) callconv(.c) void,
    f_toggle_size_request: ?*const fn (p_menu_item: *gtk.MenuItem, p_requisition: *c_int) callconv(.c) void,
    f_toggle_size_allocate: ?*const fn (p_menu_item: *gtk.MenuItem, p_allocation: c_int) callconv(.c) void,
    /// Sets `text` on the `gtk.MenuItem` label
    f_set_label: ?*const fn (p_menu_item: *gtk.MenuItem, p_label: [*:0]const u8) callconv(.c) void,
    /// Gets `text` from the `gtk.MenuItem` label
    f_get_label: ?*const fn (p_menu_item: *gtk.MenuItem) callconv(.c) [*:0]const u8,
    /// Signal emitted when the item is selected.
    f_select: ?*const fn (p_menu_item: *gtk.MenuItem) callconv(.c) void,
    /// Signal emitted when the item is deselected.
    f_deselect: ?*const fn (p_menu_item: *gtk.MenuItem) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *MenuItemClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuItemPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuShellAccessibleClass = extern struct {
    pub const Instance = gtk.MenuShellAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *MenuShellAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuShellAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuShellClass = extern struct {
    pub const Instance = gtk.MenuShell;

    f_parent_class: gtk.ContainerClass,
    bitfields0: packed struct(c_uint) {
        f_submenu_placement: u1,
        _: u31,
    },
    f_deactivate: ?*const fn (p_menu_shell: *gtk.MenuShell) callconv(.c) void,
    f_selection_done: ?*const fn (p_menu_shell: *gtk.MenuShell) callconv(.c) void,
    f_move_current: ?*const fn (p_menu_shell: *gtk.MenuShell, p_direction: gtk.MenuDirectionType) callconv(.c) void,
    f_activate_current: ?*const fn (p_menu_shell: *gtk.MenuShell, p_force_hide: c_int) callconv(.c) void,
    f_cancel: ?*const fn (p_menu_shell: *gtk.MenuShell) callconv(.c) void,
    f_select_item: ?*const fn (p_menu_shell: *gtk.MenuShell, p_menu_item: *gtk.Widget) callconv(.c) void,
    f_insert: ?*const fn (p_menu_shell: *gtk.MenuShell, p_child: *gtk.Widget, p_position: c_int) callconv(.c) void,
    f_get_popup_delay: ?*const fn (p_menu_shell: *gtk.MenuShell) callconv(.c) c_int,
    f_move_selected: ?*const fn (p_menu_shell: *gtk.MenuShell, p_distance: c_int) callconv(.c) c_int,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *MenuShellClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuShellPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuToolButtonClass = extern struct {
    pub const Instance = gtk.MenuToolButton;

    /// The parent class.
    f_parent_class: gtk.ToolButtonClass,
    /// Signal emitted before the menu is shown.
    f_show_menu: ?*const fn (p_button: *gtk.MenuToolButton) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *MenuToolButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuToolButtonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MessageDialogClass = extern struct {
    pub const Instance = gtk.MessageDialog;

    f_parent_class: gtk.DialogClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *MessageDialogClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MessageDialogPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MiscClass = extern struct {
    pub const Instance = gtk.Misc;

    f_parent_class: gtk.WidgetClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *MiscClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MiscPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MountOperationClass = extern struct {
    pub const Instance = gtk.MountOperation;

    /// The parent class.
    f_parent_class: gio.MountOperationClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *MountOperationClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MountOperationPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NativeDialogClass = extern struct {
    pub const Instance = gtk.NativeDialog;

    f_parent_class: gobject.ObjectClass,
    f_response: ?*const fn (p_self: *gtk.NativeDialog, p_response_id: c_int) callconv(.c) void,
    f_show: ?*const fn (p_self: *gtk.NativeDialog) callconv(.c) void,
    f_hide: ?*const fn (p_self: *gtk.NativeDialog) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *NativeDialogClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NotebookAccessibleClass = extern struct {
    pub const Instance = gtk.NotebookAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *NotebookAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NotebookAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NotebookClass = extern struct {
    pub const Instance = gtk.Notebook;

    f_parent_class: gtk.ContainerClass,
    f_switch_page: ?*const fn (p_notebook: *gtk.Notebook, p_page: *gtk.Widget, p_page_num: c_uint) callconv(.c) void,
    f_select_page: ?*const fn (p_notebook: *gtk.Notebook, p_move_focus: c_int) callconv(.c) c_int,
    f_focus_tab: ?*const fn (p_notebook: *gtk.Notebook, p_type: gtk.NotebookTab) callconv(.c) c_int,
    f_change_current_page: ?*const fn (p_notebook: *gtk.Notebook, p_offset: c_int) callconv(.c) c_int,
    f_move_focus_out: ?*const fn (p_notebook: *gtk.Notebook, p_direction: gtk.DirectionType) callconv(.c) void,
    f_reorder_tab: ?*const fn (p_notebook: *gtk.Notebook, p_direction: gtk.DirectionType, p_move_to_last: c_int) callconv(.c) c_int,
    f_insert_page: ?*const fn (p_notebook: *gtk.Notebook, p_child: *gtk.Widget, p_tab_label: *gtk.Widget, p_menu_label: *gtk.Widget, p_position: c_int) callconv(.c) c_int,
    f_create_window: ?*const fn (p_notebook: *gtk.Notebook, p_page: *gtk.Widget, p_x: c_int, p_y: c_int) callconv(.c) *gtk.Notebook,
    f_page_reordered: ?*const fn (p_notebook: *gtk.Notebook, p_child: *gtk.Widget, p_page_num: c_uint) callconv(.c) void,
    f_page_removed: ?*const fn (p_notebook: *gtk.Notebook, p_child: *gtk.Widget, p_page_num: c_uint) callconv(.c) void,
    f_page_added: ?*const fn (p_notebook: *gtk.Notebook, p_child: *gtk.Widget, p_page_num: c_uint) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,
    f__gtk_reserved7: ?*const fn () callconv(.c) void,
    f__gtk_reserved8: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *NotebookClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NotebookPageAccessibleClass = extern struct {
    pub const Instance = gtk.NotebookPageAccessible;

    f_parent_class: atk.ObjectClass,

    pub fn as(p_instance: *NotebookPageAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NotebookPageAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NotebookPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NumerableIconClass = extern struct {
    pub const Instance = gtk.NumerableIcon;

    f_parent_class: gio.EmblemedIconClass,
    f_padding: [16]*anyopaque,

    pub fn as(p_instance: *NumerableIconClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NumerableIconPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const OffscreenWindowClass = extern struct {
    pub const Instance = gtk.OffscreenWindow;

    /// The parent class.
    f_parent_class: gtk.WindowClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *OffscreenWindowClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const OrientableIface = extern struct {
    pub const Instance = gtk.Orientable;

    f_base_iface: gobject.TypeInterface,

    pub fn as(p_instance: *OrientableIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const OverlayClass = extern struct {
    pub const Instance = gtk.Overlay;

    /// The parent class.
    f_parent_class: gtk.BinClass,
    /// Signal emitted to determine the position and
    ///    size of any overlay child widgets.
    f_get_child_position: ?*const fn (p_overlay: *gtk.Overlay, p_widget: *gtk.Widget, p_allocation: *gtk.Allocation) callconv(.c) c_int,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,
    f__gtk_reserved7: ?*const fn () callconv(.c) void,
    f__gtk_reserved8: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *OverlayClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const OverlayPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Struct defining a pad action entry.
pub const PadActionEntry = extern struct {
    /// the type of pad feature that will trigger this action entry.
    f_type: gtk.PadActionType,
    /// the 0-indexed button/ring/strip number that will trigger this action
    ///   entry.
    f_index: c_int,
    /// the mode that will trigger this action entry, or -1 for all modes.
    f_mode: c_int,
    /// Human readable description of this action entry, this string should
    ///   be deemed user-visible.
    f_label: ?[*:0]u8,
    /// action name that will be activated in the `gio.ActionGroup`.
    f_action_name: ?[*:0]u8,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PadControllerClass = opaque {
    pub const Instance = gtk.PadController;

    pub fn as(p_instance: *PadControllerClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// See also `gtk.PrintSettings.setPageRanges`.
pub const PageRange = extern struct {
    /// start of page range.
    f_start: c_int,
    /// end of page range.
    f_end: c_int,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PanedAccessibleClass = extern struct {
    pub const Instance = gtk.PanedAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *PanedAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PanedAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PanedClass = extern struct {
    pub const Instance = gtk.Paned;

    f_parent_class: gtk.ContainerClass,
    f_cycle_child_focus: ?*const fn (p_paned: *gtk.Paned, p_reverse: c_int) callconv(.c) c_int,
    f_toggle_handle_focus: ?*const fn (p_paned: *gtk.Paned) callconv(.c) c_int,
    f_move_handle: ?*const fn (p_paned: *gtk.Paned, p_scroll: gtk.ScrollType) callconv(.c) c_int,
    f_cycle_handle_focus: ?*const fn (p_paned: *gtk.Paned, p_reverse: c_int) callconv(.c) c_int,
    f_accept_position: ?*const fn (p_paned: *gtk.Paned) callconv(.c) c_int,
    f_cancel_position: ?*const fn (p_paned: *gtk.Paned) callconv(.c) c_int,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *PanedClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PanedPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkPaperSize handles paper sizes. It uses the standard called
/// [PWG 5101.1-2002 PWG: Standard for Media Standardized Names](http://www.pwg.org/standards.html)
/// to name the paper sizes (and to get the data for the page sizes).
/// In addition to standard paper sizes, GtkPaperSize allows to
/// construct custom paper sizes with arbitrary dimensions.
///
/// The `gtk.PaperSize` object stores not only the dimensions (width
/// and height) of a paper size and its name, it also provides
/// default [print margins][print-margins].
///
/// Printing support has been added in GTK+ 2.10.
pub const PaperSize = opaque {
    /// Returns the name of the default paper size, which
    /// depends on the current locale.
    extern fn gtk_paper_size_get_default() [*:0]const u8;
    pub const getDefault = gtk_paper_size_get_default;

    /// Creates a list of known paper sizes.
    extern fn gtk_paper_size_get_paper_sizes(p_include_custom: c_int) *glib.List;
    pub const getPaperSizes = gtk_paper_size_get_paper_sizes;

    /// Creates a new `gtk.PaperSize` object by parsing a
    /// [PWG 5101.1-2002](ftp://ftp.pwg.org/pub/pwg/candidates/cs-pwgmsn10-20020226-5101.1.pdf)
    /// paper name.
    ///
    /// If `name` is `NULL`, the default paper size is returned,
    /// see `gtk.paperSizeGetDefault`.
    extern fn gtk_paper_size_new(p_name: ?[*:0]const u8) *gtk.PaperSize;
    pub const new = gtk_paper_size_new;

    /// Creates a new `gtk.PaperSize` object with the
    /// given parameters.
    extern fn gtk_paper_size_new_custom(p_name: [*:0]const u8, p_display_name: [*:0]const u8, p_width: f64, p_height: f64, p_unit: gtk.Unit) *gtk.PaperSize;
    pub const newCustom = gtk_paper_size_new_custom;

    /// Deserialize a paper size from an a{sv} variant in
    /// the format produced by `gtk.PaperSize.toGvariant`.
    extern fn gtk_paper_size_new_from_gvariant(p_variant: *glib.Variant) *gtk.PaperSize;
    pub const newFromGvariant = gtk_paper_size_new_from_gvariant;

    /// Creates a new `gtk.PaperSize` object by using
    /// IPP information.
    ///
    /// If `ipp_name` is not a recognized paper name,
    /// `width` and `height` are used to
    /// construct a custom `gtk.PaperSize` object.
    extern fn gtk_paper_size_new_from_ipp(p_ipp_name: [*:0]const u8, p_width: f64, p_height: f64) *gtk.PaperSize;
    pub const newFromIpp = gtk_paper_size_new_from_ipp;

    /// Reads a paper size from the group `group_name` in the key file
    /// `key_file`.
    extern fn gtk_paper_size_new_from_key_file(p_key_file: *glib.KeyFile, p_group_name: ?[*:0]const u8, p_error: ?*?*glib.Error) ?*gtk.PaperSize;
    pub const newFromKeyFile = gtk_paper_size_new_from_key_file;

    /// Creates a new `gtk.PaperSize` object by using
    /// PPD information.
    ///
    /// If `ppd_name` is not a recognized PPD paper name,
    /// `ppd_display_name`, `width` and `height` are used to
    /// construct a custom `gtk.PaperSize` object.
    extern fn gtk_paper_size_new_from_ppd(p_ppd_name: [*:0]const u8, p_ppd_display_name: [*:0]const u8, p_width: f64, p_height: f64) *gtk.PaperSize;
    pub const newFromPpd = gtk_paper_size_new_from_ppd;

    /// Copies an existing `gtk.PaperSize`.
    extern fn gtk_paper_size_copy(p_other: *PaperSize) *gtk.PaperSize;
    pub const copy = gtk_paper_size_copy;

    /// Free the given `gtk.PaperSize` object.
    extern fn gtk_paper_size_free(p_size: *PaperSize) void;
    pub const free = gtk_paper_size_free;

    /// Gets the default bottom margin for the `gtk.PaperSize`.
    extern fn gtk_paper_size_get_default_bottom_margin(p_size: *PaperSize, p_unit: gtk.Unit) f64;
    pub const getDefaultBottomMargin = gtk_paper_size_get_default_bottom_margin;

    /// Gets the default left margin for the `gtk.PaperSize`.
    extern fn gtk_paper_size_get_default_left_margin(p_size: *PaperSize, p_unit: gtk.Unit) f64;
    pub const getDefaultLeftMargin = gtk_paper_size_get_default_left_margin;

    /// Gets the default right margin for the `gtk.PaperSize`.
    extern fn gtk_paper_size_get_default_right_margin(p_size: *PaperSize, p_unit: gtk.Unit) f64;
    pub const getDefaultRightMargin = gtk_paper_size_get_default_right_margin;

    /// Gets the default top margin for the `gtk.PaperSize`.
    extern fn gtk_paper_size_get_default_top_margin(p_size: *PaperSize, p_unit: gtk.Unit) f64;
    pub const getDefaultTopMargin = gtk_paper_size_get_default_top_margin;

    /// Gets the human-readable name of the `gtk.PaperSize`.
    extern fn gtk_paper_size_get_display_name(p_size: *PaperSize) [*:0]const u8;
    pub const getDisplayName = gtk_paper_size_get_display_name;

    /// Gets the paper height of the `gtk.PaperSize`, in
    /// units of `unit`.
    extern fn gtk_paper_size_get_height(p_size: *PaperSize, p_unit: gtk.Unit) f64;
    pub const getHeight = gtk_paper_size_get_height;

    /// Gets the name of the `gtk.PaperSize`.
    extern fn gtk_paper_size_get_name(p_size: *PaperSize) [*:0]const u8;
    pub const getName = gtk_paper_size_get_name;

    /// Gets the PPD name of the `gtk.PaperSize`, which
    /// may be `NULL`.
    extern fn gtk_paper_size_get_ppd_name(p_size: *PaperSize) [*:0]const u8;
    pub const getPpdName = gtk_paper_size_get_ppd_name;

    /// Gets the paper width of the `gtk.PaperSize`, in
    /// units of `unit`.
    extern fn gtk_paper_size_get_width(p_size: *PaperSize, p_unit: gtk.Unit) f64;
    pub const getWidth = gtk_paper_size_get_width;

    /// Returns `TRUE` if `size` is not a standard paper size.
    extern fn gtk_paper_size_is_custom(p_size: *PaperSize) c_int;
    pub const isCustom = gtk_paper_size_is_custom;

    /// Compares two `gtk.PaperSize` objects.
    extern fn gtk_paper_size_is_equal(p_size1: *PaperSize, p_size2: *gtk.PaperSize) c_int;
    pub const isEqual = gtk_paper_size_is_equal;

    /// Returns `TRUE` if `size` is an IPP standard paper size.
    extern fn gtk_paper_size_is_ipp(p_size: *PaperSize) c_int;
    pub const isIpp = gtk_paper_size_is_ipp;

    /// Changes the dimensions of a `size` to `width` x `height`.
    extern fn gtk_paper_size_set_size(p_size: *PaperSize, p_width: f64, p_height: f64, p_unit: gtk.Unit) void;
    pub const setSize = gtk_paper_size_set_size;

    /// Serialize a paper size to an a{sv} variant.
    extern fn gtk_paper_size_to_gvariant(p_paper_size: *PaperSize) *glib.Variant;
    pub const toGvariant = gtk_paper_size_to_gvariant;

    /// This function adds the paper size from `size` to `key_file`.
    extern fn gtk_paper_size_to_key_file(p_size: *PaperSize, p_key_file: *glib.KeyFile, p_group_name: [*:0]const u8) void;
    pub const toKeyFile = gtk_paper_size_to_key_file;

    extern fn gtk_paper_size_get_type() usize;
    pub const getGObjectType = gtk_paper_size_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PlacesSidebarClass = opaque {
    pub const Instance = gtk.PlacesSidebar;

    pub fn as(p_instance: *PlacesSidebarClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PlugAccessibleClass = extern struct {
    pub const Instance = gtk.PlugAccessible;

    f_parent_class: gtk.WindowAccessibleClass,

    pub fn as(p_instance: *PlugAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PlugAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PlugClass = extern struct {
    pub const Instance = gtk.Plug;

    f_parent_class: gtk.WindowClass,
    f_embedded: ?*const fn (p_plug: *gtk.Plug) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *PlugClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PlugPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PopoverAccessibleClass = extern struct {
    pub const Instance = gtk.PopoverAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *PopoverAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PopoverClass = extern struct {
    pub const Instance = gtk.Popover;

    f_parent_class: gtk.BinClass,
    f_closed: ?*const fn (p_popover: *gtk.Popover) callconv(.c) void,
    f_reserved: [10]*anyopaque,

    pub fn as(p_instance: *PopoverClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PopoverMenuClass = extern struct {
    pub const Instance = gtk.PopoverMenu;

    f_parent_class: gtk.PopoverClass,
    f_reserved: [10]*anyopaque,

    pub fn as(p_instance: *PopoverMenuClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PopoverPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PrintOperationClass = extern struct {
    pub const Instance = gtk.PrintOperation;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    /// Signal emitted when the print operation run has finished
    ///    doing everything required for printing.
    f_done: ?*const fn (p_operation: *gtk.PrintOperation, p_result: gtk.PrintOperationResult) callconv(.c) void,
    /// Signal emitted after the user has finished changing
    ///    print settings in the dialog, before the actual rendering starts.
    f_begin_print: ?*const fn (p_operation: *gtk.PrintOperation, p_context: *gtk.PrintContext) callconv(.c) void,
    /// Signal emitted after the “begin-print” signal, but
    ///    before the actual rendering starts.
    f_paginate: ?*const fn (p_operation: *gtk.PrintOperation, p_context: *gtk.PrintContext) callconv(.c) c_int,
    /// Emitted once for every page that is printed,
    ///    to give the application a chance to modify the page setup.
    f_request_page_setup: ?*const fn (p_operation: *gtk.PrintOperation, p_context: *gtk.PrintContext, p_page_nr: c_int, p_setup: *gtk.PageSetup) callconv(.c) void,
    /// Signal emitted for every page that is printed.
    f_draw_page: ?*const fn (p_operation: *gtk.PrintOperation, p_context: *gtk.PrintContext, p_page_nr: c_int) callconv(.c) void,
    /// Signal emitted after all pages have been rendered.
    f_end_print: ?*const fn (p_operation: *gtk.PrintOperation, p_context: *gtk.PrintContext) callconv(.c) void,
    /// Emitted at between the various phases of the print
    ///    operation.
    f_status_changed: ?*const fn (p_operation: *gtk.PrintOperation) callconv(.c) void,
    /// Signal emitted when displaying the print dialog.
    f_create_custom_widget: ?*const fn (p_operation: *gtk.PrintOperation) callconv(.c) *gtk.Widget,
    /// Signal emitted right before “begin-print” if
    ///    you added a custom widget in the “create-custom-widget” handler.
    f_custom_widget_apply: ?*const fn (p_operation: *gtk.PrintOperation, p_widget: *gtk.Widget) callconv(.c) void,
    /// Signal emitted when a preview is requested from the
    ///    native dialog.
    f_preview: ?*const fn (p_operation: *gtk.PrintOperation, p_preview: *gtk.PrintOperationPreview, p_context: *gtk.PrintContext, p_parent: *gtk.Window) callconv(.c) c_int,
    /// Emitted after change of selected printer.
    f_update_custom_widget: ?*const fn (p_operation: *gtk.PrintOperation, p_widget: *gtk.Widget, p_setup: *gtk.PageSetup, p_settings: *gtk.PrintSettings) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,
    f__gtk_reserved7: ?*const fn () callconv(.c) void,
    f__gtk_reserved8: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *PrintOperationClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PrintOperationPreviewIface = extern struct {
    pub const Instance = gtk.PrintOperationPreview;

    f_g_iface: gobject.TypeInterface,
    f_ready: ?*const fn (p_preview: *gtk.PrintOperationPreview, p_context: *gtk.PrintContext) callconv(.c) void,
    f_got_page_size: ?*const fn (p_preview: *gtk.PrintOperationPreview, p_context: *gtk.PrintContext, p_page_setup: *gtk.PageSetup) callconv(.c) void,
    f_render_page: ?*const fn (p_preview: *gtk.PrintOperationPreview, p_page_nr: c_int) callconv(.c) void,
    f_is_selected: ?*const fn (p_preview: *gtk.PrintOperationPreview, p_page_nr: c_int) callconv(.c) c_int,
    f_end_preview: ?*const fn (p_preview: *gtk.PrintOperationPreview) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,
    f__gtk_reserved7: ?*const fn () callconv(.c) void,
    f__gtk_reserved8: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *PrintOperationPreviewIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PrintOperationPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ProgressBarAccessibleClass = extern struct {
    pub const Instance = gtk.ProgressBarAccessible;

    f_parent_class: gtk.WidgetAccessibleClass,

    pub fn as(p_instance: *ProgressBarAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ProgressBarAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ProgressBarClass = extern struct {
    pub const Instance = gtk.ProgressBar;

    f_parent_class: gtk.WidgetClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ProgressBarClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ProgressBarPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RadioActionClass = extern struct {
    pub const Instance = gtk.RadioAction;

    f_parent_class: gtk.ToggleActionClass,
    f_changed: ?*const fn (p_action: *gtk.RadioAction, p_current: *gtk.RadioAction) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *RadioActionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.RadioActionEntry` structs are used with
/// `gtk.ActionGroup.addRadioActions` to construct groups of radio actions.
pub const RadioActionEntry = extern struct {
    /// The name of the action.
    f_name: ?[*:0]const u8,
    /// The stock id for the action, or the name of an icon from the
    ///  icon theme.
    f_stock_id: ?[*:0]const u8,
    /// The label for the action. This field should typically be marked
    ///  for translation, see `gtk.ActionGroup.setTranslationDomain`.
    f_label: ?[*:0]const u8,
    /// The accelerator for the action, in the format understood by
    ///  `gtk.acceleratorParse`.
    f_accelerator: ?[*:0]const u8,
    /// The tooltip for the action. This field should typically be
    ///  marked for translation, see `gtk.ActionGroup.setTranslationDomain`.
    f_tooltip: ?[*:0]const u8,
    /// The value to set on the radio action. See
    ///  `gtk.RadioAction.getCurrentValue`.
    f_value: c_int,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RadioActionPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RadioButtonAccessibleClass = extern struct {
    pub const Instance = gtk.RadioButtonAccessible;

    f_parent_class: gtk.ToggleButtonAccessibleClass,

    pub fn as(p_instance: *RadioButtonAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RadioButtonAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RadioButtonClass = extern struct {
    pub const Instance = gtk.RadioButton;

    f_parent_class: gtk.CheckButtonClass,
    f_group_changed: ?*const fn (p_radio_button: *gtk.RadioButton) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *RadioButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RadioButtonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RadioMenuItemAccessibleClass = extern struct {
    pub const Instance = gtk.RadioMenuItemAccessible;

    f_parent_class: gtk.CheckMenuItemAccessibleClass,

    pub fn as(p_instance: *RadioMenuItemAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RadioMenuItemAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RadioMenuItemClass = extern struct {
    pub const Instance = gtk.RadioMenuItem;

    f_parent_class: gtk.CheckMenuItemClass,
    f_group_changed: ?*const fn (p_radio_menu_item: *gtk.RadioMenuItem) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *RadioMenuItemClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RadioMenuItemPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RadioToolButtonClass = extern struct {
    pub const Instance = gtk.RadioToolButton;

    f_parent_class: gtk.ToggleToolButtonClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *RadioToolButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RangeAccessibleClass = extern struct {
    pub const Instance = gtk.RangeAccessible;

    f_parent_class: gtk.WidgetAccessibleClass,

    pub fn as(p_instance: *RangeAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RangeAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RangeClass = extern struct {
    pub const Instance = gtk.Range;

    f_parent_class: gtk.WidgetClass,
    f_slider_detail: ?[*:0]u8,
    f_stepper_detail: ?[*:0]u8,
    f_value_changed: ?*const fn (p_range: *gtk.Range) callconv(.c) void,
    f_adjust_bounds: ?*const fn (p_range: *gtk.Range, p_new_value: f64) callconv(.c) void,
    f_move_slider: ?*const fn (p_range: *gtk.Range, p_scroll: gtk.ScrollType) callconv(.c) void,
    f_get_range_border: ?*const fn (p_range: *gtk.Range, p_border_: *gtk.Border) callconv(.c) void,
    f_change_value: ?*const fn (p_range: *gtk.Range, p_scroll: gtk.ScrollType, p_new_value: f64) callconv(.c) c_int,
    f_get_range_size_request: ?*const fn (p_range: *gtk.Range, p_orientation: gtk.Orientation, p_minimum: *c_int, p_natural: *c_int) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *RangeClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RangePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RcContext = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Deprecated
pub const RcProperty = extern struct {
    /// quark-ified type identifier
    f_type_name: glib.Quark,
    /// quark-ified property identifier like
    ///   “GtkScrollbar::spacing”
    f_property_name: glib.Quark,
    /// field similar to one found in `gtk.SettingsValue`
    f_origin: ?[*:0]u8,
    /// field similar to one found in `gtk.SettingsValue`
    f_value: gobject.Value,

    /// A `gtk.RcPropertyParser` for use with `gtk.Settings.installPropertyParser`
    /// or `gtk.WidgetClass.installStylePropertyParser` which parses
    /// borders in the form
    /// `"{ left, right, top, bottom }"` for integers
    /// left, right, top and bottom.
    extern fn gtk_rc_property_parse_border(p_pspec: *const gobject.ParamSpec, p_gstring: *const glib.String, p_property_value: *gobject.Value) c_int;
    pub const parseBorder = gtk_rc_property_parse_border;

    /// A `gtk.RcPropertyParser` for use with `gtk.Settings.installPropertyParser`
    /// or `gtk.WidgetClass.installStylePropertyParser` which parses a
    /// color given either by its name or in the form
    /// `{ red, green, blue }` where red, green and
    /// blue are integers between 0 and 65535 or floating-point numbers
    /// between 0 and 1.
    extern fn gtk_rc_property_parse_color(p_pspec: *const gobject.ParamSpec, p_gstring: *const glib.String, p_property_value: *gobject.Value) c_int;
    pub const parseColor = gtk_rc_property_parse_color;

    /// A `gtk.RcPropertyParser` for use with `gtk.Settings.installPropertyParser`
    /// or `gtk.WidgetClass.installStylePropertyParser` which parses a single
    /// enumeration value.
    ///
    /// The enumeration value can be specified by its name, its nickname or
    /// its numeric value. For consistency with flags parsing, the value
    /// may be surrounded by parentheses.
    extern fn gtk_rc_property_parse_enum(p_pspec: *const gobject.ParamSpec, p_gstring: *const glib.String, p_property_value: *gobject.Value) c_int;
    pub const parseEnum = gtk_rc_property_parse_enum;

    /// A `gtk.RcPropertyParser` for use with `gtk.Settings.installPropertyParser`
    /// or `gtk.WidgetClass.installStylePropertyParser` which parses flags.
    ///
    /// Flags can be specified by their name, their nickname or
    /// numerically. Multiple flags can be specified in the form
    /// `"( flag1 | flag2 | ... )"`.
    extern fn gtk_rc_property_parse_flags(p_pspec: *const gobject.ParamSpec, p_gstring: *const glib.String, p_property_value: *gobject.Value) c_int;
    pub const parseFlags = gtk_rc_property_parse_flags;

    /// A `gtk.RcPropertyParser` for use with `gtk.Settings.installPropertyParser`
    /// or `gtk.WidgetClass.installStylePropertyParser` which parses a
    /// requisition in the form
    /// `"{ width, height }"` for integers `width` and `height`.
    extern fn gtk_rc_property_parse_requisition(p_pspec: *const gobject.ParamSpec, p_gstring: *const glib.String, p_property_value: *gobject.Value) c_int;
    pub const parseRequisition = gtk_rc_property_parse_requisition;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RcStyleClass = extern struct {
    pub const Instance = gtk.RcStyle;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    f_create_rc_style: ?*const fn (p_rc_style: *gtk.RcStyle) callconv(.c) *gtk.RcStyle,
    f_parse: ?*const fn (p_rc_style: *gtk.RcStyle, p_settings: *gtk.Settings, p_scanner: *glib.Scanner) callconv(.c) c_uint,
    f_merge: ?*const fn (p_dest: *gtk.RcStyle, p_src: *gtk.RcStyle) callconv(.c) void,
    f_create_style: ?*const fn (p_rc_style: *gtk.RcStyle) callconv(.c) *gtk.Style,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *RcStyleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RecentActionClass = extern struct {
    pub const Instance = gtk.RecentAction;

    f_parent_class: gtk.ActionClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *RecentActionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RecentActionPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RecentChooserDialogClass = extern struct {
    pub const Instance = gtk.RecentChooserDialog;

    f_parent_class: gtk.DialogClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *RecentChooserDialogClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RecentChooserDialogPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RecentChooserIface = extern struct {
    pub const Instance = gtk.RecentChooser;

    f_base_iface: gobject.TypeInterface,
    /// Sets uri as the current URI for chooser.
    f_set_current_uri: ?*const fn (p_chooser: *gtk.RecentChooser, p_uri: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Gets the URI currently selected by chooser.
    f_get_current_uri: ?*const fn (p_chooser: *gtk.RecentChooser) callconv(.c) [*:0]u8,
    /// Selects uri inside chooser.
    f_select_uri: ?*const fn (p_chooser: *gtk.RecentChooser, p_uri: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Unselects uri inside chooser.
    f_unselect_uri: ?*const fn (p_chooser: *gtk.RecentChooser, p_uri: [*:0]const u8) callconv(.c) void,
    /// Selects all the items inside chooser, if the chooser
    ///    supports multiple selection.
    f_select_all: ?*const fn (p_chooser: *gtk.RecentChooser) callconv(.c) void,
    /// Unselects all the items inside chooser.
    f_unselect_all: ?*const fn (p_chooser: *gtk.RecentChooser) callconv(.c) void,
    /// Gets the list of recently used resources in form of
    ///    `gtk.RecentInfo` objects.
    f_get_items: ?*const fn (p_chooser: *gtk.RecentChooser) callconv(.c) *glib.List,
    /// Gets the `gtk.RecentManager` used by chooser.
    f_get_recent_manager: ?*const fn (p_chooser: *gtk.RecentChooser) callconv(.c) *gtk.RecentManager,
    /// Adds filter to the list of `gtk.RecentFilter` objects
    ///    held by chooser.
    f_add_filter: ?*const fn (p_chooser: *gtk.RecentChooser, p_filter: *gtk.RecentFilter) callconv(.c) void,
    /// Removes filter from the list of `gtk.RecentFilter`
    ///    objects held by chooser.
    f_remove_filter: ?*const fn (p_chooser: *gtk.RecentChooser, p_filter: *gtk.RecentFilter) callconv(.c) void,
    /// Gets the `gtk.RecentFilter` objects held by chooser.
    f_list_filters: ?*const fn (p_chooser: *gtk.RecentChooser) callconv(.c) *glib.SList,
    /// Sets the comparison function used when sorting to
    ///    be sort_func.
    f_set_sort_func: ?*const fn (p_chooser: *gtk.RecentChooser, p_sort_func: gtk.RecentSortFunc, p_sort_data: ?*anyopaque, p_data_destroy: ?glib.DestroyNotify) callconv(.c) void,
    /// Signal emitted when the user “activates” a recent
    ///    item in the recent chooser.
    f_item_activated: ?*const fn (p_chooser: *gtk.RecentChooser) callconv(.c) void,
    /// Signal emitted when there is a change in the
    ///    set of selected recently used resources.
    f_selection_changed: ?*const fn (p_chooser: *gtk.RecentChooser) callconv(.c) void,

    pub fn as(p_instance: *RecentChooserIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RecentChooserMenuClass = extern struct {
    pub const Instance = gtk.RecentChooserMenu;

    f_parent_class: gtk.MenuClass,
    f_gtk_recent1: ?*const fn () callconv(.c) void,
    f_gtk_recent2: ?*const fn () callconv(.c) void,
    f_gtk_recent3: ?*const fn () callconv(.c) void,
    f_gtk_recent4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *RecentChooserMenuClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RecentChooserMenuPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RecentChooserWidgetClass = extern struct {
    pub const Instance = gtk.RecentChooserWidget;

    f_parent_class: gtk.BoxClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *RecentChooserWidgetClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RecentChooserWidgetPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Meta-data to be passed to `gtk.RecentManager.addFull` when
/// registering a recently used resource.
pub const RecentData = extern struct {
    /// a UTF-8 encoded string, containing the name of the recently
    ///   used resource to be displayed, or `NULL`;
    f_display_name: ?[*:0]u8,
    /// a UTF-8 encoded string, containing a short description of
    ///   the resource, or `NULL`;
    f_description: ?[*:0]u8,
    /// the MIME type of the resource;
    f_mime_type: ?[*:0]u8,
    /// the name of the application that is registering this recently
    ///   used resource;
    f_app_name: ?[*:0]u8,
    /// command line used to launch this resource; may contain the
    ///   “\%f” and “\%u” escape characters which will be expanded
    ///   to the resource file path and URI respectively when the command line
    ///   is retrieved;
    f_app_exec: ?[*:0]u8,
    /// a vector of strings containing
    ///   groups names;
    f_groups: ?[*][*:0]u8,
    /// whether this resource should be displayed only by the
    ///   applications that have registered it or not.
    f_is_private: c_int,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkRecentFilterInfo struct is used
/// to pass information about the tested file to `gtk.RecentFilter.filter`.
pub const RecentFilterInfo = extern struct {
    /// `gtk.RecentFilterFlags` to indicate which fields are set.
    f_contains: gtk.RecentFilterFlags,
    /// The URI of the file being tested.
    f_uri: ?[*:0]const u8,
    /// The string that will be used to display
    ///    the file in the recent chooser.
    f_display_name: ?[*:0]const u8,
    /// MIME type of the file.
    f_mime_type: ?[*:0]const u8,
    /// The list of
    ///    applications that have registered the file.
    f_applications: ?[*][*:0]const u8,
    /// The groups to which
    ///    the file belongs to.
    f_groups: ?[*][*:0]const u8,
    /// The number of days elapsed since the file has been
    ///    registered.
    f_age: c_int,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.RecentInfo`-struct contains private data only, and should
/// be accessed using the provided API.
///
/// `gtk.RecentInfo` constains all the meta-data
/// associated with an entry in the recently used files list.
pub const RecentInfo = opaque {
    /// Creates a `gio.AppInfo` for the specified `gtk.RecentInfo`
    extern fn gtk_recent_info_create_app_info(p_info: *RecentInfo, p_app_name: ?[*:0]const u8, p_error: ?*?*glib.Error) ?*gio.AppInfo;
    pub const createAppInfo = gtk_recent_info_create_app_info;

    /// Checks whether the resource pointed by `info` still exists.
    /// At the moment this check is done only on resources pointing
    /// to local files.
    extern fn gtk_recent_info_exists(p_info: *RecentInfo) c_int;
    pub const exists = gtk_recent_info_exists;

    /// Gets the timestamp (seconds from system’s Epoch) when the resource
    /// was added to the recently used resources list.
    extern fn gtk_recent_info_get_added(p_info: *RecentInfo) std.posix.time_t;
    pub const getAdded = gtk_recent_info_get_added;

    /// Gets the number of days elapsed since the last update
    /// of the resource pointed by `info`.
    extern fn gtk_recent_info_get_age(p_info: *RecentInfo) c_int;
    pub const getAge = gtk_recent_info_get_age;

    /// Gets the data regarding the application that has registered the resource
    /// pointed by `info`.
    ///
    /// If the command line contains any escape characters defined inside the
    /// storage specification, they will be expanded.
    extern fn gtk_recent_info_get_application_info(p_info: *RecentInfo, p_app_name: [*:0]const u8, p_app_exec: *[*:0]const u8, p_count: *c_uint, p_time_: *std.posix.time_t) c_int;
    pub const getApplicationInfo = gtk_recent_info_get_application_info;

    /// Retrieves the list of applications that have registered this resource.
    extern fn gtk_recent_info_get_applications(p_info: *RecentInfo, p_length: ?*usize) [*:null]?[*:0]u8;
    pub const getApplications = gtk_recent_info_get_applications;

    /// Gets the (short) description of the resource.
    extern fn gtk_recent_info_get_description(p_info: *RecentInfo) [*:0]const u8;
    pub const getDescription = gtk_recent_info_get_description;

    /// Gets the name of the resource. If none has been defined, the basename
    /// of the resource is obtained.
    extern fn gtk_recent_info_get_display_name(p_info: *RecentInfo) [*:0]const u8;
    pub const getDisplayName = gtk_recent_info_get_display_name;

    /// Retrieves the icon associated to the resource MIME type.
    extern fn gtk_recent_info_get_gicon(p_info: *RecentInfo) ?*gio.Icon;
    pub const getGicon = gtk_recent_info_get_gicon;

    /// Returns all groups registered for the recently used item `info`.
    /// The array of returned group names will be `NULL` terminated, so
    /// length might optionally be `NULL`.
    extern fn gtk_recent_info_get_groups(p_info: *RecentInfo, p_length: ?*usize) [*:null]?[*:0]u8;
    pub const getGroups = gtk_recent_info_get_groups;

    /// Retrieves the icon of size `size` associated to the resource MIME type.
    extern fn gtk_recent_info_get_icon(p_info: *RecentInfo, p_size: c_int) ?*gdkpixbuf.Pixbuf;
    pub const getIcon = gtk_recent_info_get_icon;

    /// Gets the MIME type of the resource.
    extern fn gtk_recent_info_get_mime_type(p_info: *RecentInfo) [*:0]const u8;
    pub const getMimeType = gtk_recent_info_get_mime_type;

    /// Gets the timestamp (seconds from system’s Epoch) when the meta-data
    /// for the resource was last modified.
    extern fn gtk_recent_info_get_modified(p_info: *RecentInfo) std.posix.time_t;
    pub const getModified = gtk_recent_info_get_modified;

    /// Gets the value of the “private” flag. Resources in the recently used
    /// list that have this flag set to `TRUE` should only be displayed by the
    /// applications that have registered them.
    extern fn gtk_recent_info_get_private_hint(p_info: *RecentInfo) c_int;
    pub const getPrivateHint = gtk_recent_info_get_private_hint;

    /// Computes a valid UTF-8 string that can be used as the
    /// name of the item in a menu or list. For example, calling
    /// this function on an item that refers to
    /// “file:///foo/bar.txt” will yield “bar.txt”.
    extern fn gtk_recent_info_get_short_name(p_info: *RecentInfo) [*:0]u8;
    pub const getShortName = gtk_recent_info_get_short_name;

    /// Gets the URI of the resource.
    extern fn gtk_recent_info_get_uri(p_info: *RecentInfo) [*:0]const u8;
    pub const getUri = gtk_recent_info_get_uri;

    /// Gets a displayable version of the resource’s URI. If the resource
    /// is local, it returns a local path; if the resource is not local,
    /// it returns the UTF-8 encoded content of `gtk.RecentInfo.getUri`.
    extern fn gtk_recent_info_get_uri_display(p_info: *RecentInfo) ?[*:0]u8;
    pub const getUriDisplay = gtk_recent_info_get_uri_display;

    /// Gets the timestamp (seconds from system’s Epoch) when the meta-data
    /// for the resource was last visited.
    extern fn gtk_recent_info_get_visited(p_info: *RecentInfo) std.posix.time_t;
    pub const getVisited = gtk_recent_info_get_visited;

    /// Checks whether an application registered this resource using `app_name`.
    extern fn gtk_recent_info_has_application(p_info: *RecentInfo, p_app_name: [*:0]const u8) c_int;
    pub const hasApplication = gtk_recent_info_has_application;

    /// Checks whether `group_name` appears inside the groups
    /// registered for the recently used item `info`.
    extern fn gtk_recent_info_has_group(p_info: *RecentInfo, p_group_name: [*:0]const u8) c_int;
    pub const hasGroup = gtk_recent_info_has_group;

    /// Checks whether the resource is local or not by looking at the
    /// scheme of its URI.
    extern fn gtk_recent_info_is_local(p_info: *RecentInfo) c_int;
    pub const isLocal = gtk_recent_info_is_local;

    /// Gets the name of the last application that have registered the
    /// recently used resource represented by `info`.
    extern fn gtk_recent_info_last_application(p_info: *RecentInfo) [*:0]u8;
    pub const lastApplication = gtk_recent_info_last_application;

    /// Checks whether two `gtk.RecentInfo`-struct point to the same
    /// resource.
    extern fn gtk_recent_info_match(p_info_a: *RecentInfo, p_info_b: *gtk.RecentInfo) c_int;
    pub const match = gtk_recent_info_match;

    /// Increases the reference count of `recent_info` by one.
    extern fn gtk_recent_info_ref(p_info: *RecentInfo) *gtk.RecentInfo;
    pub const ref = gtk_recent_info_ref;

    /// Decreases the reference count of `info` by one. If the reference
    /// count reaches zero, `info` is deallocated, and the memory freed.
    extern fn gtk_recent_info_unref(p_info: *RecentInfo) void;
    pub const unref = gtk_recent_info_unref;

    extern fn gtk_recent_info_get_type() usize;
    pub const getGObjectType = gtk_recent_info_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.RecentManagerClass` contains only private data.
pub const RecentManagerClass = extern struct {
    pub const Instance = gtk.RecentManager;

    f_parent_class: gobject.ObjectClass,
    f_changed: ?*const fn (p_manager: *gtk.RecentManager) callconv(.c) void,
    f__gtk_recent1: ?*const fn () callconv(.c) void,
    f__gtk_recent2: ?*const fn () callconv(.c) void,
    f__gtk_recent3: ?*const fn () callconv(.c) void,
    f__gtk_recent4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *RecentManagerClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RecentManagerPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RendererCellAccessibleClass = extern struct {
    pub const Instance = gtk.RendererCellAccessible;

    f_parent_class: gtk.CellAccessibleClass,

    pub fn as(p_instance: *RendererCellAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RendererCellAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Represents a request of a screen object in a given orientation. These
/// are primarily used in container implementations when allocating a natural
/// size for children calling. See `gtk.distributeNaturalAllocation`.
pub const RequestedSize = extern struct {
    /// A client pointer
    f_data: ?*anyopaque,
    /// The minimum size needed for allocation in a given orientation
    f_minimum_size: c_int,
    /// The natural size for allocation in a given orientation
    f_natural_size: c_int,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.Requisition`-struct represents the desired size of a widget. See
/// [GtkWidget’s geometry management section][geometry-management] for
/// more information.
pub const Requisition = extern struct {
    /// the widget’s desired width
    f_width: c_int,
    /// the widget’s desired height
    f_height: c_int,

    /// Allocates a new `gtk.Requisition`-struct and initializes its elements to zero.
    extern fn gtk_requisition_new() *gtk.Requisition;
    pub const new = gtk_requisition_new;

    /// Copies a `gtk.Requisition`.
    extern fn gtk_requisition_copy(p_requisition: *const Requisition) *gtk.Requisition;
    pub const copy = gtk_requisition_copy;

    /// Frees a `gtk.Requisition`.
    extern fn gtk_requisition_free(p_requisition: *Requisition) void;
    pub const free = gtk_requisition_free;

    extern fn gtk_requisition_get_type() usize;
    pub const getGObjectType = gtk_requisition_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const RevealerClass = extern struct {
    pub const Instance = gtk.Revealer;

    /// The parent class.
    f_parent_class: gtk.BinClass,

    pub fn as(p_instance: *RevealerClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScaleAccessibleClass = extern struct {
    pub const Instance = gtk.ScaleAccessible;

    f_parent_class: gtk.RangeAccessibleClass,

    pub fn as(p_instance: *ScaleAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScaleAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScaleButtonAccessibleClass = extern struct {
    pub const Instance = gtk.ScaleButtonAccessible;

    f_parent_class: gtk.ButtonAccessibleClass,

    pub fn as(p_instance: *ScaleButtonAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScaleButtonAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScaleButtonClass = extern struct {
    pub const Instance = gtk.ScaleButton;

    f_parent_class: gtk.ButtonClass,
    f_value_changed: ?*const fn (p_button: *gtk.ScaleButton, p_value: f64) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ScaleButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScaleButtonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScaleClass = extern struct {
    pub const Instance = gtk.Scale;

    f_parent_class: gtk.RangeClass,
    f_format_value: ?*const fn (p_scale: *gtk.Scale, p_value: f64) callconv(.c) [*:0]u8,
    f_draw_value: ?*const fn (p_scale: *gtk.Scale) callconv(.c) void,
    f_get_layout_offsets: ?*const fn (p_scale: *gtk.Scale, p_x: ?*c_int, p_y: ?*c_int) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ScaleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScalePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScrollableInterface = extern struct {
    pub const Instance = gtk.Scrollable;

    f_base_iface: gobject.TypeInterface,
    f_get_border: ?*const fn (p_scrollable: *gtk.Scrollable, p_border: *gtk.Border) callconv(.c) c_int,

    pub fn as(p_instance: *ScrollableInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScrollbarClass = extern struct {
    pub const Instance = gtk.Scrollbar;

    f_parent_class: gtk.RangeClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ScrollbarClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScrolledWindowAccessibleClass = extern struct {
    pub const Instance = gtk.ScrolledWindowAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *ScrolledWindowAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScrolledWindowAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScrolledWindowClass = extern struct {
    pub const Instance = gtk.ScrolledWindow;

    /// The parent class.
    f_parent_class: gtk.BinClass,
    f_scrollbar_spacing: c_int,
    /// Keybinding signal which gets emitted when a
    ///    keybinding that scrolls is pressed.
    f_scroll_child: ?*const fn (p_scrolled_window: *gtk.ScrolledWindow, p_scroll: gtk.ScrollType, p_horizontal: c_int) callconv(.c) c_int,
    /// Keybinding signal which gets emitted when focus is
    ///    moved away from the scrolled window by a keybinding.
    f_move_focus_out: ?*const fn (p_scrolled_window: *gtk.ScrolledWindow, p_direction: gtk.DirectionType) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ScrolledWindowClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScrolledWindowPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SearchBarClass = extern struct {
    pub const Instance = gtk.SearchBar;

    /// The parent class.
    f_parent_class: gtk.BinClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SearchBarClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SearchEntryClass = extern struct {
    pub const Instance = gtk.SearchEntry;

    f_parent_class: gtk.EntryClass,
    f_search_changed: ?*const fn (p_entry: *gtk.SearchEntry) callconv(.c) void,
    f_next_match: ?*const fn (p_entry: *gtk.SearchEntry) callconv(.c) void,
    f_previous_match: ?*const fn (p_entry: *gtk.SearchEntry) callconv(.c) void,
    f_stop_search: ?*const fn (p_entry: *gtk.SearchEntry) callconv(.c) void,

    pub fn as(p_instance: *SearchEntryClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SelectionData = opaque {
    /// Makes a copy of a `gtk.SelectionData`-struct and its data.
    extern fn gtk_selection_data_copy(p_data: *const SelectionData) *gtk.SelectionData;
    pub const copy = gtk_selection_data_copy;

    /// Frees a `gtk.SelectionData`-struct returned from
    /// `gtk.SelectionData.copy`.
    extern fn gtk_selection_data_free(p_data: *SelectionData) void;
    pub const free = gtk_selection_data_free;

    /// Retrieves the raw data of the selection.
    extern fn gtk_selection_data_get_data(p_selection_data: *const SelectionData) [*]const u8;
    pub const getData = gtk_selection_data_get_data;

    /// Retrieves the data type of the selection.
    extern fn gtk_selection_data_get_data_type(p_selection_data: *const SelectionData) gdk.Atom;
    pub const getDataType = gtk_selection_data_get_data_type;

    /// Retrieves the raw data of the selection along with its length.
    extern fn gtk_selection_data_get_data_with_length(p_selection_data: *const SelectionData, p_length: *c_int) [*]const u8;
    pub const getDataWithLength = gtk_selection_data_get_data_with_length;

    /// Retrieves the display of the selection.
    extern fn gtk_selection_data_get_display(p_selection_data: *const SelectionData) *gdk.Display;
    pub const getDisplay = gtk_selection_data_get_display;

    /// Retrieves the format of the selection.
    extern fn gtk_selection_data_get_format(p_selection_data: *const SelectionData) c_int;
    pub const getFormat = gtk_selection_data_get_format;

    /// Retrieves the length of the raw data of the selection.
    extern fn gtk_selection_data_get_length(p_selection_data: *const SelectionData) c_int;
    pub const getLength = gtk_selection_data_get_length;

    /// Gets the contents of the selection data as a `gdkpixbuf.Pixbuf`.
    extern fn gtk_selection_data_get_pixbuf(p_selection_data: *const SelectionData) ?*gdkpixbuf.Pixbuf;
    pub const getPixbuf = gtk_selection_data_get_pixbuf;

    /// Retrieves the selection `gdk.Atom` of the selection data.
    extern fn gtk_selection_data_get_selection(p_selection_data: *const SelectionData) gdk.Atom;
    pub const getSelection = gtk_selection_data_get_selection;

    /// Retrieves the target of the selection.
    extern fn gtk_selection_data_get_target(p_selection_data: *const SelectionData) gdk.Atom;
    pub const getTarget = gtk_selection_data_get_target;

    /// Gets the contents of `selection_data` as an array of targets.
    /// This can be used to interpret the results of getting
    /// the standard TARGETS target that is always supplied for
    /// any selection.
    extern fn gtk_selection_data_get_targets(p_selection_data: *const SelectionData, p_targets: *[*]gdk.Atom, p_n_atoms: *c_int) c_int;
    pub const getTargets = gtk_selection_data_get_targets;

    /// Gets the contents of the selection data as a UTF-8 string.
    extern fn gtk_selection_data_get_text(p_selection_data: *const SelectionData) ?[*:0]u8;
    pub const getText = gtk_selection_data_get_text;

    /// Gets the contents of the selection data as array of URIs.
    ///
    /// Since 3.24.37, this may involve using the FileTransfer
    /// portal to send files between sandboxed apps.
    extern fn gtk_selection_data_get_uris(p_selection_data: *const SelectionData) [*][*:0]u8;
    pub const getUris = gtk_selection_data_get_uris;

    /// Stores new data into a `gtk.SelectionData` object. Should
    /// only be called from a selection handler callback.
    /// Zero-terminates the stored data.
    extern fn gtk_selection_data_set(p_selection_data: *SelectionData, p_type: gdk.Atom, p_format: c_int, p_data: [*]const u8, p_length: c_int) void;
    pub const set = gtk_selection_data_set;

    /// Sets the contents of the selection from a `gdkpixbuf.Pixbuf`
    /// The pixbuf is converted to the form determined by
    /// `selection_data`->target.
    extern fn gtk_selection_data_set_pixbuf(p_selection_data: *SelectionData, p_pixbuf: *gdkpixbuf.Pixbuf) c_int;
    pub const setPixbuf = gtk_selection_data_set_pixbuf;

    /// Sets the contents of the selection from a UTF-8 encoded string.
    /// The string is converted to the form determined by
    /// `selection_data`->target.
    extern fn gtk_selection_data_set_text(p_selection_data: *SelectionData, p_str: [*:0]const u8, p_len: c_int) c_int;
    pub const setText = gtk_selection_data_set_text;

    /// Sets the contents of the selection from a list of URIs.
    /// The string is converted to the form determined by
    /// `selection_data`->target.
    ///
    /// Since 3.24.37, this may involve using the FileTransfer
    /// portal to send files between sandboxed apps.
    extern fn gtk_selection_data_set_uris(p_selection_data: *SelectionData, p_uris: [*][*:0]u8) c_int;
    pub const setUris = gtk_selection_data_set_uris;

    /// Given a `gtk.SelectionData` object holding a list of targets,
    /// determines if any of the targets in `targets` can be used to
    /// provide a `gdkpixbuf.Pixbuf`.
    extern fn gtk_selection_data_targets_include_image(p_selection_data: *const SelectionData, p_writable: c_int) c_int;
    pub const targetsIncludeImage = gtk_selection_data_targets_include_image;

    /// Given a `gtk.SelectionData` object holding a list of targets,
    /// determines if any of the targets in `targets` can be used to
    /// provide rich text.
    extern fn gtk_selection_data_targets_include_rich_text(p_selection_data: *const SelectionData, p_buffer: *gtk.TextBuffer) c_int;
    pub const targetsIncludeRichText = gtk_selection_data_targets_include_rich_text;

    /// Given a `gtk.SelectionData` object holding a list of targets,
    /// determines if any of the targets in `targets` can be used to
    /// provide text.
    extern fn gtk_selection_data_targets_include_text(p_selection_data: *const SelectionData) c_int;
    pub const targetsIncludeText = gtk_selection_data_targets_include_text;

    /// Given a `gtk.SelectionData` object holding a list of targets,
    /// determines if any of the targets in `targets` can be used to
    /// provide a list or URIs.
    extern fn gtk_selection_data_targets_include_uri(p_selection_data: *const SelectionData) c_int;
    pub const targetsIncludeUri = gtk_selection_data_targets_include_uri;

    extern fn gtk_selection_data_get_type() usize;
    pub const getGObjectType = gtk_selection_data_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SeparatorClass = extern struct {
    pub const Instance = gtk.Separator;

    f_parent_class: gtk.WidgetClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SeparatorClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SeparatorMenuItemClass = extern struct {
    pub const Instance = gtk.SeparatorMenuItem;

    /// The parent class.
    f_parent_class: gtk.MenuItemClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SeparatorMenuItemClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SeparatorPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SeparatorToolItemClass = extern struct {
    pub const Instance = gtk.SeparatorToolItem;

    /// The parent class.
    f_parent_class: gtk.ToolItemClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SeparatorToolItemClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SeparatorToolItemPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SettingsClass = extern struct {
    pub const Instance = gtk.Settings;

    f_parent_class: gobject.ObjectClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SettingsClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SettingsPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SettingsValue = extern struct {
    /// Origin should be something like “filename:linenumber” for
    ///    rc files, or e.g. “XProperty” for other sources.
    f_origin: ?[*:0]u8,
    /// Valid types are LONG, DOUBLE and STRING corresponding to
    ///    the token parsed, or a GSTRING holding an unparsed statement
    f_value: gobject.Value,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ShortcutLabelClass = opaque {
    pub const Instance = gtk.ShortcutLabel;

    pub fn as(p_instance: *ShortcutLabelClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ShortcutsGroupClass = opaque {
    pub const Instance = gtk.ShortcutsGroup;

    pub fn as(p_instance: *ShortcutsGroupClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ShortcutsSectionClass = opaque {
    pub const Instance = gtk.ShortcutsSection;

    pub fn as(p_instance: *ShortcutsSectionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ShortcutsShortcutClass = opaque {
    pub const Instance = gtk.ShortcutsShortcut;

    pub fn as(p_instance: *ShortcutsShortcutClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ShortcutsWindowClass = extern struct {
    pub const Instance = gtk.ShortcutsWindow;

    f_parent_class: gtk.WindowClass,
    f_close: ?*const fn (p_self: *gtk.ShortcutsWindow) callconv(.c) void,
    f_search: ?*const fn (p_self: *gtk.ShortcutsWindow) callconv(.c) void,

    pub fn as(p_instance: *ShortcutsWindowClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SizeGroupClass = extern struct {
    pub const Instance = gtk.SizeGroup;

    f_parent_class: gobject.ObjectClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SizeGroupClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SizeGroupPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SocketAccessibleClass = extern struct {
    pub const Instance = gtk.SocketAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *SocketAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SocketAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SocketClass = extern struct {
    pub const Instance = gtk.Socket;

    f_parent_class: gtk.ContainerClass,
    f_plug_added: ?*const fn (p_socket_: *gtk.Socket) callconv(.c) void,
    f_plug_removed: ?*const fn (p_socket_: *gtk.Socket) callconv(.c) c_int,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SocketClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SocketPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SpinButtonAccessibleClass = extern struct {
    pub const Instance = gtk.SpinButtonAccessible;

    f_parent_class: gtk.EntryAccessibleClass,

    pub fn as(p_instance: *SpinButtonAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SpinButtonAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SpinButtonClass = extern struct {
    pub const Instance = gtk.SpinButton;

    f_parent_class: gtk.EntryClass,
    f_input: ?*const fn (p_spin_button: *gtk.SpinButton, p_new_value: *f64) callconv(.c) c_int,
    f_output: ?*const fn (p_spin_button: *gtk.SpinButton) callconv(.c) c_int,
    f_value_changed: ?*const fn (p_spin_button: *gtk.SpinButton) callconv(.c) void,
    f_change_value: ?*const fn (p_spin_button: *gtk.SpinButton, p_scroll: gtk.ScrollType) callconv(.c) void,
    f_wrapped: ?*const fn (p_spin_button: *gtk.SpinButton) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SpinButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SpinButtonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SpinnerAccessibleClass = extern struct {
    pub const Instance = gtk.SpinnerAccessible;

    f_parent_class: gtk.WidgetAccessibleClass,

    pub fn as(p_instance: *SpinnerAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SpinnerAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SpinnerClass = extern struct {
    pub const Instance = gtk.Spinner;

    f_parent_class: gtk.WidgetClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SpinnerClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SpinnerPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StackAccessibleClass = extern struct {
    pub const Instance = gtk.StackAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *StackAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StackClass = extern struct {
    pub const Instance = gtk.Stack;

    f_parent_class: gtk.ContainerClass,

    pub fn as(p_instance: *StackClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StackSidebarClass = extern struct {
    pub const Instance = gtk.StackSidebar;

    f_parent_class: gtk.BinClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *StackSidebarClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StackSidebarPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StackSwitcherClass = extern struct {
    pub const Instance = gtk.StackSwitcher;

    f_parent_class: gtk.BoxClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *StackSwitcherClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StatusIconClass = extern struct {
    pub const Instance = gtk.StatusIcon;

    f_parent_class: gobject.ObjectClass,
    f_activate: ?*const fn (p_status_icon: *gtk.StatusIcon) callconv(.c) void,
    f_popup_menu: ?*const fn (p_status_icon: *gtk.StatusIcon, p_button: c_uint, p_activate_time: u32) callconv(.c) void,
    f_size_changed: ?*const fn (p_status_icon: *gtk.StatusIcon, p_size: c_int) callconv(.c) c_int,
    f_button_press_event: ?*const fn (p_status_icon: *gtk.StatusIcon, p_event: *gdk.EventButton) callconv(.c) c_int,
    f_button_release_event: ?*const fn (p_status_icon: *gtk.StatusIcon, p_event: *gdk.EventButton) callconv(.c) c_int,
    f_scroll_event: ?*const fn (p_status_icon: *gtk.StatusIcon, p_event: *gdk.EventScroll) callconv(.c) c_int,
    f_query_tooltip: ?*const fn (p_status_icon: *gtk.StatusIcon, p_x: c_int, p_y: c_int, p_keyboard_mode: c_int, p_tooltip: *gtk.Tooltip) callconv(.c) c_int,
    f___gtk_reserved1: ?*const fn () callconv(.c) void,
    f___gtk_reserved2: ?*const fn () callconv(.c) void,
    f___gtk_reserved3: ?*const fn () callconv(.c) void,
    f___gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *StatusIconClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StatusIconPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StatusbarAccessibleClass = extern struct {
    pub const Instance = gtk.StatusbarAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *StatusbarAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StatusbarAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StatusbarClass = extern struct {
    pub const Instance = gtk.Statusbar;

    f_parent_class: gtk.BoxClass,
    f_reserved: ?*anyopaque,
    f_text_pushed: ?*const fn (p_statusbar: *gtk.Statusbar, p_context_id: c_uint, p_text: [*:0]const u8) callconv(.c) void,
    f_text_popped: ?*const fn (p_statusbar: *gtk.Statusbar, p_context_id: c_uint, p_text: [*:0]const u8) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *StatusbarClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StatusbarPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StockItem = extern struct {
    /// Identifier.
    f_stock_id: ?[*:0]u8,
    /// User visible label.
    f_label: ?[*:0]u8,
    /// Modifier type for keyboard accelerator
    f_modifier: gdk.ModifierType,
    /// Keyboard accelerator
    f_keyval: c_uint,
    /// Translation domain of the menu or toolbar item
    f_translation_domain: ?[*:0]u8,

    /// Copies a stock item, mostly useful for language bindings and not in applications.
    extern fn gtk_stock_item_copy(p_item: *const StockItem) *gtk.StockItem;
    pub const copy = gtk_stock_item_copy;

    /// Frees a stock item allocated on the heap, such as one returned by
    /// `gtk.StockItem.copy`. Also frees the fields inside the stock item,
    /// if they are not `NULL`.
    extern fn gtk_stock_item_free(p_item: *StockItem) void;
    pub const free = gtk_stock_item_free;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StyleClass = extern struct {
    pub const Instance = gtk.Style;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    f_realize: ?*const fn (p_style: *gtk.Style) callconv(.c) void,
    f_unrealize: ?*const fn (p_style: *gtk.Style) callconv(.c) void,
    f_copy: ?*const fn (p_style: *gtk.Style, p_src: *gtk.Style) callconv(.c) void,
    f_clone: ?*const fn (p_style: *gtk.Style) callconv(.c) *gtk.Style,
    f_init_from_rc: ?*const fn (p_style: *gtk.Style, p_rc_style: *gtk.RcStyle) callconv(.c) void,
    f_set_background: ?*const fn (p_style: *gtk.Style, p_window: *gdk.Window, p_state_type: gtk.StateType) callconv(.c) void,
    f_render_icon: ?*const fn (p_style: *gtk.Style, p_source: *const gtk.IconSource, p_direction: gtk.TextDirection, p_state: gtk.StateType, p_size: c_int, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8) callconv(.c) *gdkpixbuf.Pixbuf,
    f_draw_hline: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x1: c_int, p_x2: c_int, p_y: c_int) callconv(.c) void,
    f_draw_vline: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_y1_: c_int, p_y2_: c_int, p_x: c_int) callconv(.c) void,
    f_draw_shadow: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void,
    f_draw_arrow: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_arrow_type: gtk.ArrowType, p_fill: c_int, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void,
    f_draw_diamond: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void,
    f_draw_box: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void,
    f_draw_flat_box: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void,
    f_draw_check: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void,
    f_draw_option: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void,
    f_draw_tab: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void,
    f_draw_shadow_gap: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_gap_side: gtk.PositionType, p_gap_x: c_int, p_gap_width: c_int) callconv(.c) void,
    f_draw_box_gap: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_gap_side: gtk.PositionType, p_gap_x: c_int, p_gap_width: c_int) callconv(.c) void,
    f_draw_extension: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_gap_side: gtk.PositionType) callconv(.c) void,
    f_draw_focus: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void,
    f_draw_slider: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_orientation: gtk.Orientation) callconv(.c) void,
    f_draw_handle: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_orientation: gtk.Orientation) callconv(.c) void,
    f_draw_expander: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_expander_style: gtk.ExpanderStyle) callconv(.c) void,
    f_draw_layout: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_use_text: c_int, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_x: c_int, p_y: c_int, p_layout: *pango.Layout) callconv(.c) void,
    f_draw_resize_grip: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_edge: gdk.WindowEdge, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void,
    f_draw_spinner: ?*const fn (p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: *gtk.Widget, p_detail: [*:0]const u8, p_step: c_uint, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,
    f__gtk_reserved7: ?*const fn () callconv(.c) void,
    f__gtk_reserved8: ?*const fn () callconv(.c) void,
    f__gtk_reserved9: ?*const fn () callconv(.c) void,
    f__gtk_reserved10: ?*const fn () callconv(.c) void,
    f__gtk_reserved11: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *StyleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StyleContextClass = extern struct {
    pub const Instance = gtk.StyleContext;

    f_parent_class: gobject.ObjectClass,
    f_changed: ?*const fn (p_context: *gtk.StyleContext) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *StyleContextClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StyleContextPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StylePropertiesClass = extern struct {
    pub const Instance = gtk.StyleProperties;

    f_parent_class: gobject.ObjectClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *StylePropertiesClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StylePropertiesPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const StyleProviderIface = extern struct {
    pub const Instance = gtk.StyleProvider;

    f_g_iface: gobject.TypeInterface,
    /// Gets a set of style information that applies to a widget path.
    f_get_style: ?*const fn (p_provider: *gtk.StyleProvider, p_path: *gtk.WidgetPath) callconv(.c) ?*gtk.StyleProperties,
    /// Gets the value of a widget style property that applies to a widget path.
    f_get_style_property: ?*const fn (p_provider: *gtk.StyleProvider, p_path: *gtk.WidgetPath, p_state: gtk.StateFlags, p_pspec: *gobject.ParamSpec, p_value: *gobject.Value) callconv(.c) c_int,
    /// Gets the icon factory that applies to a widget path.
    f_get_icon_factory: ?*const fn (p_provider: *gtk.StyleProvider, p_path: *gtk.WidgetPath) callconv(.c) ?*gtk.IconFactory,

    pub fn as(p_instance: *StyleProviderIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SwitchAccessibleClass = extern struct {
    pub const Instance = gtk.SwitchAccessible;

    f_parent_class: gtk.WidgetAccessibleClass,

    pub fn as(p_instance: *SwitchAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SwitchAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SwitchClass = extern struct {
    pub const Instance = gtk.Switch;

    /// The parent class.
    f_parent_class: gtk.WidgetClass,
    /// An action signal and emitting it causes the switch to animate.
    f_activate: ?*const fn (p_sw: *gtk.Switch) callconv(.c) void,
    /// Class handler for the ::state-set signal.
    f_state_set: ?*const fn (p_sw: *gtk.Switch, p_state: c_int) callconv(.c) c_int,
    f__switch_padding_1: ?*const fn () callconv(.c) void,
    f__switch_padding_2: ?*const fn () callconv(.c) void,
    f__switch_padding_3: ?*const fn () callconv(.c) void,
    f__switch_padding_4: ?*const fn () callconv(.c) void,
    f__switch_padding_5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SwitchClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SwitchPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkSymbolicColor is a boxed type that represents a symbolic color.
/// It is the result of parsing a
/// [color expression][gtkcssprovider-symbolic-colors].
/// To obtain the color represented by a GtkSymbolicColor, it has to
/// be resolved with `gtk.SymbolicColor.resolve`, which replaces all
/// symbolic color references by the colors they refer to (in a given
/// context) and evaluates mix, shade and other expressions, resulting
/// in a `gdk.RGBA` value.
///
/// It is not normally necessary to deal directly with `GtkSymbolicColors`,
/// since they are mostly used behind the scenes by `gtk.StyleContext` and
/// `gtk.CssProvider`.
///
/// `gtk.SymbolicColor` is deprecated. Symbolic colors are considered an
/// implementation detail of GTK+.
pub const SymbolicColor = opaque {
    /// Creates a symbolic color by modifying the relative alpha
    /// value of `color`. A factor < 1.0 would resolve to a more
    /// transparent color, while > 1.0 would resolve to a more
    /// opaque color.
    extern fn gtk_symbolic_color_new_alpha(p_color: *gtk.SymbolicColor, p_factor: f64) *gtk.SymbolicColor;
    pub const newAlpha = gtk_symbolic_color_new_alpha;

    /// Creates a symbolic color pointing to a literal color.
    extern fn gtk_symbolic_color_new_literal(p_color: *const gdk.RGBA) *gtk.SymbolicColor;
    pub const newLiteral = gtk_symbolic_color_new_literal;

    /// Creates a symbolic color defined as a mix of another
    /// two colors. a mix factor of 0 would resolve to `color1`,
    /// while a factor of 1 would resolve to `color2`.
    extern fn gtk_symbolic_color_new_mix(p_color1: *gtk.SymbolicColor, p_color2: *gtk.SymbolicColor, p_factor: f64) *gtk.SymbolicColor;
    pub const newMix = gtk_symbolic_color_new_mix;

    /// Creates a symbolic color pointing to an unresolved named
    /// color. See `gtk.StyleContext.lookupColor` and
    /// `gtk.StyleProperties.lookupColor`.
    extern fn gtk_symbolic_color_new_name(p_name: [*:0]const u8) *gtk.SymbolicColor;
    pub const newName = gtk_symbolic_color_new_name;

    /// Creates a symbolic color defined as a shade of
    /// another color. A factor > 1.0 would resolve to
    /// a brighter color, while < 1.0 would resolve to
    /// a darker color.
    extern fn gtk_symbolic_color_new_shade(p_color: *gtk.SymbolicColor, p_factor: f64) *gtk.SymbolicColor;
    pub const newShade = gtk_symbolic_color_new_shade;

    /// Creates a symbolic color based on the current win32
    /// theme.
    ///
    /// Note that while this call is available on all platforms
    /// the actual value returned is not reliable on non-win32
    /// platforms.
    extern fn gtk_symbolic_color_new_win32(p_theme_class: [*:0]const u8, p_id: c_int) *gtk.SymbolicColor;
    pub const newWin32 = gtk_symbolic_color_new_win32;

    /// Increases the reference count of `color`
    extern fn gtk_symbolic_color_ref(p_color: *SymbolicColor) *gtk.SymbolicColor;
    pub const ref = gtk_symbolic_color_ref;

    /// If `color` is resolvable, `resolved_color` will be filled in
    /// with the resolved color, and `TRUE` will be returned. Generally,
    /// if `color` can’t be resolved, it is due to it being defined on
    /// top of a named color that doesn’t exist in `props`.
    ///
    /// When `props` is `NULL`, resolving of named colors will fail, so if
    /// your `color` is or references such a color, this function will
    /// return `FALSE`.
    extern fn gtk_symbolic_color_resolve(p_color: *SymbolicColor, p_props: ?*gtk.StyleProperties, p_resolved_color: *gdk.RGBA) c_int;
    pub const resolve = gtk_symbolic_color_resolve;

    /// Converts the given `color` to a string representation. This is useful
    /// both for debugging and for serialization of strings. The format of
    /// the string may change between different versions of GTK, but it is
    /// guaranteed that the GTK css parser is able to read the string and
    /// create the same symbolic color from it.
    extern fn gtk_symbolic_color_to_string(p_color: *SymbolicColor) [*:0]u8;
    pub const toString = gtk_symbolic_color_to_string;

    /// Decreases the reference count of `color`, freeing its memory if the
    /// reference count reaches 0.
    extern fn gtk_symbolic_color_unref(p_color: *SymbolicColor) void;
    pub const unref = gtk_symbolic_color_unref;

    extern fn gtk_symbolic_color_get_type() usize;
    pub const getGObjectType = gtk_symbolic_color_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TableChild = extern struct {
    f_widget: ?*gtk.Widget,
    f_left_attach: u16,
    f_right_attach: u16,
    f_top_attach: u16,
    f_bottom_attach: u16,
    f_xpadding: u16,
    f_ypadding: u16,
    bitfields0: packed struct(c_uint) {
        f_xexpand: u1,
        f_yexpand: u1,
        f_xshrink: u1,
        f_yshrink: u1,
        f_xfill: u1,
        f_yfill: u1,
        _: u26,
    },

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TableClass = extern struct {
    pub const Instance = gtk.Table;

    f_parent_class: gtk.ContainerClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *TableClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TablePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TableRowCol = extern struct {
    f_requisition: u16,
    f_allocation: u16,
    f_spacing: u16,
    bitfields0: packed struct(c_uint) {
        f_need_expand: u1,
        f_need_shrink: u1,
        f_expand: u1,
        f_shrink: u1,
        f_empty: u1,
        _: u27,
    },

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.TargetEntry` represents a single type of
/// data than can be supplied for by a widget for a selection
/// or for supplied or received during drag-and-drop.
pub const TargetEntry = extern struct {
    /// a string representation of the target type
    f_target: ?[*:0]u8,
    /// `gtk.TargetFlags` for DND
    f_flags: c_uint,
    /// an application-assigned integer ID which will
    ///     get passed as a parameter to e.g the `gtk.Widget.signals.selection`-get
    ///     signal. It allows the application to identify the target
    ///     type without extensive string compares.
    f_info: c_uint,

    /// Makes a new `gtk.TargetEntry`.
    extern fn gtk_target_entry_new(p_target: [*:0]const u8, p_flags: c_uint, p_info: c_uint) *gtk.TargetEntry;
    pub const new = gtk_target_entry_new;

    /// Makes a copy of a `gtk.TargetEntry` and its data.
    extern fn gtk_target_entry_copy(p_data: *TargetEntry) *gtk.TargetEntry;
    pub const copy = gtk_target_entry_copy;

    /// Frees a `gtk.TargetEntry` returned from
    /// `gtk.TargetEntry.new` or `gtk.TargetEntry.copy`.
    extern fn gtk_target_entry_free(p_data: *TargetEntry) void;
    pub const free = gtk_target_entry_free;

    extern fn gtk_target_entry_get_type() usize;
    pub const getGObjectType = gtk_target_entry_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.TargetList`-struct is a reference counted list
/// of `gtk.TargetPair` and should be treated as
/// opaque.
pub const TargetList = opaque {
    /// Creates a new `gtk.TargetList` from an array of `gtk.TargetEntry`.
    extern fn gtk_target_list_new(p_targets: ?[*]const gtk.TargetEntry, p_ntargets: c_uint) *gtk.TargetList;
    pub const new = gtk_target_list_new;

    /// Appends another target to a `gtk.TargetList`.
    extern fn gtk_target_list_add(p_list: *TargetList, p_target: gdk.Atom, p_flags: c_uint, p_info: c_uint) void;
    pub const add = gtk_target_list_add;

    /// Appends the image targets supported by `gtk.SelectionData` to
    /// the target list. All targets are added with the same `info`.
    extern fn gtk_target_list_add_image_targets(p_list: *TargetList, p_info: c_uint, p_writable: c_int) void;
    pub const addImageTargets = gtk_target_list_add_image_targets;

    /// Appends the rich text targets registered with
    /// `gtk.TextBuffer.registerSerializeFormat` or
    /// `gtk.TextBuffer.registerDeserializeFormat` to the target list. All
    /// targets are added with the same `info`.
    extern fn gtk_target_list_add_rich_text_targets(p_list: *TargetList, p_info: c_uint, p_deserializable: c_int, p_buffer: *gtk.TextBuffer) void;
    pub const addRichTextTargets = gtk_target_list_add_rich_text_targets;

    /// Prepends a table of `gtk.TargetEntry` to a target list.
    extern fn gtk_target_list_add_table(p_list: *TargetList, p_targets: [*]const gtk.TargetEntry, p_ntargets: c_uint) void;
    pub const addTable = gtk_target_list_add_table;

    /// Appends the text targets supported by `gtk.SelectionData` to
    /// the target list. All targets are added with the same `info`.
    extern fn gtk_target_list_add_text_targets(p_list: *TargetList, p_info: c_uint) void;
    pub const addTextTargets = gtk_target_list_add_text_targets;

    /// Appends the URI targets supported by `gtk.SelectionData` to
    /// the target list. All targets are added with the same `info`.
    ///
    /// Since 3.24.37, this includes the application/vnd.portal.files
    /// target when possible, to allow sending files between sandboxed
    /// apps via the FileTransfer portal.
    extern fn gtk_target_list_add_uri_targets(p_list: *TargetList, p_info: c_uint) void;
    pub const addUriTargets = gtk_target_list_add_uri_targets;

    /// Looks up a given target in a `gtk.TargetList`.
    extern fn gtk_target_list_find(p_list: *TargetList, p_target: gdk.Atom, p_info: ?*c_uint) c_int;
    pub const find = gtk_target_list_find;

    /// Increases the reference count of a `gtk.TargetList` by one.
    extern fn gtk_target_list_ref(p_list: *TargetList) *gtk.TargetList;
    pub const ref = gtk_target_list_ref;

    /// Removes a target from a target list.
    extern fn gtk_target_list_remove(p_list: *TargetList, p_target: gdk.Atom) void;
    pub const remove = gtk_target_list_remove;

    /// Decreases the reference count of a `gtk.TargetList` by one.
    /// If the resulting reference count is zero, frees the list.
    extern fn gtk_target_list_unref(p_list: *TargetList) void;
    pub const unref = gtk_target_list_unref;

    extern fn gtk_target_list_get_type() usize;
    pub const getGObjectType = gtk_target_list_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.TargetPair` is used to represent the same
/// information as a table of `gtk.TargetEntry`, but in
/// an efficient form.
pub const TargetPair = extern struct {
    /// `gdk.Atom` representation of the target type
    f_target: ?gdk.Atom,
    /// `gtk.TargetFlags` for DND
    f_flags: c_uint,
    /// an application-assigned integer ID which will
    ///     get passed as a parameter to e.g the `gtk.Widget.signals.selection`-get
    ///     signal. It allows the application to identify the target
    ///     type without extensive string compares.
    f_info: c_uint,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TearoffMenuItemClass = extern struct {
    pub const Instance = gtk.TearoffMenuItem;

    /// The parent class.
    f_parent_class: gtk.MenuItemClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *TearoffMenuItemClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TearoffMenuItemPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextAppearance = extern struct {
    /// Background `gdk.Color`.
    f_bg_color: gdk.Color,
    /// Foreground `gdk.Color`.
    f_fg_color: gdk.Color,
    /// Super/subscript rise, can be negative.
    f_rise: c_int,
    bitfields0: packed struct(c_uint) {
        /// `pango.Underline`
        f_underline: u4,
        /// Strikethrough style
        f_strikethrough: u1,
        /// Whether to use background-related values; this is
        ///   irrelevant for the values struct when in a tag, but is used for
        ///   the composite values struct; it’s true if any of the tags being
        ///   composited had background stuff set.
        f_draw_bg: u1,
        /// This are only used when we are actually laying
        ///   out and rendering a paragraph; not when a `gtk.TextAppearance` is
        ///   part of a `gtk.TextAttributes`.
        f_inside_selection: u1,
        /// This are only used when we are actually laying
        ///   out and rendering a paragraph; not when a `gtk.TextAppearance` is
        ///   part of a `gtk.TextAttributes`.
        f_is_text: u1,
        _: u24,
    },
    anon0: extern union {
        f_rgba: [2]*gdk.RGBA,
        f_padding: [4]c_uint,
    },

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Using `gtk.TextAttributes` directly should rarely be necessary.
/// It’s primarily useful with `gtk.TextIter.getAttributes`.
/// As with most GTK+ structs, the fields in this struct should only
/// be read, never modified directly.
pub const TextAttributes = extern struct {
    f_refcount: c_uint,
    /// `gtk.TextAppearance` for text.
    f_appearance: gtk.TextAppearance,
    /// `gtk.Justification` for text.
    f_justification: gtk.Justification,
    /// `gtk.TextDirection` for text.
    f_direction: gtk.TextDirection,
    /// `pango.FontDescription` for text.
    f_font: ?*pango.FontDescription,
    /// Font scale factor.
    f_font_scale: f64,
    /// Width of the left margin in pixels.
    f_left_margin: c_int,
    /// Width of the right margin in pixels.
    f_right_margin: c_int,
    /// Amount to indent the paragraph, in pixels.
    f_indent: c_int,
    /// Pixels of blank space above paragraphs.
    f_pixels_above_lines: c_int,
    /// Pixels of blank space below paragraphs.
    f_pixels_below_lines: c_int,
    /// Pixels of blank space between wrapped lines in
    ///   a paragraph.
    f_pixels_inside_wrap: c_int,
    /// Custom `pango.TabArray` for this text.
    f_tabs: ?*pango.TabArray,
    /// `gtk.WrapMode` for text.
    f_wrap_mode: gtk.WrapMode,
    /// `pango.Language` for text.
    f_language: ?*pango.Language,
    f_pg_bg_color: ?*gdk.Color,
    bitfields0: packed struct(c_uint) {
        /// Hide the text.
        f_invisible: u1,
        /// Background is fit to full line height rather than
        ///    baseline +/- ascent/descent (font height).
        f_bg_full_height: u1,
        /// Can edit this text.
        f_editable: u1,
        /// Whether to disable font fallback.
        f_no_fallback: u1,
        _: u28,
    },
    f_pg_bg_rgba: ?*gdk.RGBA,
    /// Extra space to insert between graphemes, in Pango units
    f_letter_spacing: c_int,
    anon0: extern union {
        f_font_features: ?[*:0]u8,
        f_padding: [2]c_uint,
    },

    /// Creates a `gtk.TextAttributes`, which describes
    /// a set of properties on some text.
    extern fn gtk_text_attributes_new() *gtk.TextAttributes;
    pub const new = gtk_text_attributes_new;

    /// Copies `src` and returns a new `gtk.TextAttributes`.
    extern fn gtk_text_attributes_copy(p_src: *TextAttributes) *gtk.TextAttributes;
    pub const copy = gtk_text_attributes_copy;

    /// Copies the values from `src` to `dest` so that `dest` has
    /// the same values as `src`. Frees existing values in `dest`.
    extern fn gtk_text_attributes_copy_values(p_src: *TextAttributes, p_dest: *gtk.TextAttributes) void;
    pub const copyValues = gtk_text_attributes_copy_values;

    /// Increments the reference count on `values`.
    extern fn gtk_text_attributes_ref(p_values: *TextAttributes) *gtk.TextAttributes;
    pub const ref = gtk_text_attributes_ref;

    /// Decrements the reference count on `values`, freeing the structure
    /// if the reference count reaches 0.
    extern fn gtk_text_attributes_unref(p_values: *TextAttributes) void;
    pub const unref = gtk_text_attributes_unref;

    extern fn gtk_text_attributes_get_type() usize;
    pub const getGObjectType = gtk_text_attributes_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextBTree = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextBufferClass = extern struct {
    pub const Instance = gtk.TextBuffer;

    /// The object class structure needs to be the first.
    f_parent_class: gobject.ObjectClass,
    /// The class handler for the `gtk.TextBuffer.signals.insert`-text signal.
    f_insert_text: ?*const fn (p_buffer: *gtk.TextBuffer, p_pos: *gtk.TextIter, p_new_text: [*:0]const u8, p_new_text_length: c_int) callconv(.c) void,
    /// The class handler for the `gtk.TextBuffer.signals.insert`-pixbuf
    ///   signal.
    f_insert_pixbuf: ?*const fn (p_buffer: *gtk.TextBuffer, p_iter: *gtk.TextIter, p_pixbuf: *gdkpixbuf.Pixbuf) callconv(.c) void,
    /// The class handler for the
    ///   `gtk.TextBuffer.signals.insert`-child-anchor signal.
    f_insert_child_anchor: ?*const fn (p_buffer: *gtk.TextBuffer, p_iter: *gtk.TextIter, p_anchor: *gtk.TextChildAnchor) callconv(.c) void,
    /// The class handler for the `gtk.TextBuffer.signals.delete`-range signal.
    f_delete_range: ?*const fn (p_buffer: *gtk.TextBuffer, p_start: *gtk.TextIter, p_end: *gtk.TextIter) callconv(.c) void,
    /// The class handler for the `gtk.TextBuffer.signals.changed` signal.
    f_changed: ?*const fn (p_buffer: *gtk.TextBuffer) callconv(.c) void,
    /// The class handler for the `gtk.TextBuffer.signals.modified`-changed
    ///   signal.
    f_modified_changed: ?*const fn (p_buffer: *gtk.TextBuffer) callconv(.c) void,
    /// The class handler for the `gtk.TextBuffer.signals.mark`-set signal.
    f_mark_set: ?*const fn (p_buffer: *gtk.TextBuffer, p_location: *const gtk.TextIter, p_mark: *gtk.TextMark) callconv(.c) void,
    /// The class handler for the `gtk.TextBuffer.signals.mark`-deleted signal.
    f_mark_deleted: ?*const fn (p_buffer: *gtk.TextBuffer, p_mark: *gtk.TextMark) callconv(.c) void,
    /// The class handler for the `gtk.TextBuffer.signals.apply`-tag signal.
    f_apply_tag: ?*const fn (p_buffer: *gtk.TextBuffer, p_tag: *gtk.TextTag, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter) callconv(.c) void,
    /// The class handler for the `gtk.TextBuffer.signals.remove`-tag signal.
    f_remove_tag: ?*const fn (p_buffer: *gtk.TextBuffer, p_tag: *gtk.TextTag, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter) callconv(.c) void,
    /// The class handler for the
    ///   `gtk.TextBuffer.signals.begin`-user-action signal.
    f_begin_user_action: ?*const fn (p_buffer: *gtk.TextBuffer) callconv(.c) void,
    /// The class handler for the `gtk.TextBuffer.signals.end`-user-action
    ///   signal.
    f_end_user_action: ?*const fn (p_buffer: *gtk.TextBuffer) callconv(.c) void,
    /// The class handler for the `gtk.TextBuffer.signals.paste`-done signal.
    f_paste_done: ?*const fn (p_buffer: *gtk.TextBuffer, p_clipboard: *gtk.Clipboard) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *TextBufferClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextBufferPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextCellAccessibleClass = extern struct {
    pub const Instance = gtk.TextCellAccessible;

    f_parent_class: gtk.RendererCellAccessibleClass,

    pub fn as(p_instance: *TextCellAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextCellAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextChildAnchorClass = extern struct {
    pub const Instance = gtk.TextChildAnchor;

    f_parent_class: gobject.ObjectClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *TextChildAnchorClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// You may wish to begin by reading the
/// [text widget conceptual overview](TextWidget.html)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
pub const TextIter = extern struct {
    f_dummy1: ?*anyopaque,
    f_dummy2: ?*anyopaque,
    f_dummy3: c_int,
    f_dummy4: c_int,
    f_dummy5: c_int,
    f_dummy6: c_int,
    f_dummy7: c_int,
    f_dummy8: c_int,
    f_dummy9: ?*anyopaque,
    f_dummy10: ?*anyopaque,
    f_dummy11: c_int,
    f_dummy12: c_int,
    f_dummy13: c_int,
    f_dummy14: ?*anyopaque,

    /// Assigns the value of `other` to `iter`.  This function
    /// is not useful in applications, because iterators can be assigned
    /// with `GtkTextIter i = j;`. The
    /// function is used by language bindings.
    extern fn gtk_text_iter_assign(p_iter: *TextIter, p_other: *const gtk.TextIter) void;
    pub const assign = gtk_text_iter_assign;

    /// Moves backward by one character offset. Returns `TRUE` if movement
    /// was possible; if `iter` was the first in the buffer (character
    /// offset 0), `gtk.TextIter.backwardChar` returns `FALSE` for convenience when
    /// writing loops.
    extern fn gtk_text_iter_backward_char(p_iter: *TextIter) c_int;
    pub const backwardChar = gtk_text_iter_backward_char;

    /// Moves `count` characters backward, if possible (if `count` would move
    /// past the start or end of the buffer, moves to the start or end of
    /// the buffer).  The return value indicates whether the iterator moved
    /// onto a dereferenceable position; if the iterator didn’t move, or
    /// moved onto the end iterator, then `FALSE` is returned. If `count` is 0,
    /// the function does nothing and returns `FALSE`.
    extern fn gtk_text_iter_backward_chars(p_iter: *TextIter, p_count: c_int) c_int;
    pub const backwardChars = gtk_text_iter_backward_chars;

    /// Like `gtk.TextIter.forwardCursorPosition`, but moves backward.
    extern fn gtk_text_iter_backward_cursor_position(p_iter: *TextIter) c_int;
    pub const backwardCursorPosition = gtk_text_iter_backward_cursor_position;

    /// Moves up to `count` cursor positions. See
    /// `gtk.TextIter.forwardCursorPosition` for details.
    extern fn gtk_text_iter_backward_cursor_positions(p_iter: *TextIter, p_count: c_int) c_int;
    pub const backwardCursorPositions = gtk_text_iter_backward_cursor_positions;

    /// Same as `gtk.TextIter.forwardFindChar`, but goes backward from `iter`.
    extern fn gtk_text_iter_backward_find_char(p_iter: *TextIter, p_pred: gtk.TextCharPredicate, p_user_data: ?*anyopaque, p_limit: ?*const gtk.TextIter) c_int;
    pub const backwardFindChar = gtk_text_iter_backward_find_char;

    /// Moves `iter` to the start of the previous line. Returns `TRUE` if
    /// `iter` could be moved; i.e. if `iter` was at character offset 0, this
    /// function returns `FALSE`. Therefore if `iter` was already on line 0,
    /// but not at the start of the line, `iter` is snapped to the start of
    /// the line and the function returns `TRUE`. (Note that this implies that
    /// in a loop calling this function, the line number may not change on
    /// every iteration, if your first iteration is on line 0.)
    extern fn gtk_text_iter_backward_line(p_iter: *TextIter) c_int;
    pub const backwardLine = gtk_text_iter_backward_line;

    /// Moves `count` lines backward, if possible (if `count` would move
    /// past the start or end of the buffer, moves to the start or end of
    /// the buffer).  The return value indicates whether the iterator moved
    /// onto a dereferenceable position; if the iterator didn’t move, or
    /// moved onto the end iterator, then `FALSE` is returned. If `count` is 0,
    /// the function does nothing and returns `FALSE`. If `count` is negative,
    /// moves forward by 0 - `count` lines.
    extern fn gtk_text_iter_backward_lines(p_iter: *TextIter, p_count: c_int) c_int;
    pub const backwardLines = gtk_text_iter_backward_lines;

    /// Same as `gtk.TextIter.forwardSearch`, but moves backward.
    ///
    /// `match_end` will never be set to a `gtk.TextIter` located after `iter`, even if
    /// there is a possible `match_start` before or at `iter`.
    extern fn gtk_text_iter_backward_search(p_iter: *const TextIter, p_str: [*:0]const u8, p_flags: gtk.TextSearchFlags, p_match_start: ?*gtk.TextIter, p_match_end: ?*gtk.TextIter, p_limit: ?*const gtk.TextIter) c_int;
    pub const backwardSearch = gtk_text_iter_backward_search;

    /// Moves backward to the previous sentence start; if `iter` is already at
    /// the start of a sentence, moves backward to the next one.  Sentence
    /// boundaries are determined by Pango and should be correct for nearly
    /// any language (if not, the correct fix would be to the Pango text
    /// boundary algorithms).
    extern fn gtk_text_iter_backward_sentence_start(p_iter: *TextIter) c_int;
    pub const backwardSentenceStart = gtk_text_iter_backward_sentence_start;

    /// Calls `gtk.TextIter.backwardSentenceStart` up to `count` times,
    /// or until it returns `FALSE`. If `count` is negative, moves forward
    /// instead of backward.
    extern fn gtk_text_iter_backward_sentence_starts(p_iter: *TextIter, p_count: c_int) c_int;
    pub const backwardSentenceStarts = gtk_text_iter_backward_sentence_starts;

    /// Moves backward to the next toggle (on or off) of the
    /// `gtk.TextTag` `tag`, or to the next toggle of any tag if
    /// `tag` is `NULL`. If no matching tag toggles are found,
    /// returns `FALSE`, otherwise `TRUE`. Does not return toggles
    /// located at `iter`, only toggles before `iter`. Sets `iter`
    /// to the location of the toggle, or the start of the buffer
    /// if no toggle is found.
    extern fn gtk_text_iter_backward_to_tag_toggle(p_iter: *TextIter, p_tag: ?*gtk.TextTag) c_int;
    pub const backwardToTagToggle = gtk_text_iter_backward_to_tag_toggle;

    /// Moves `iter` forward to the previous visible cursor position. See
    /// `gtk.TextIter.backwardCursorPosition` for details.
    extern fn gtk_text_iter_backward_visible_cursor_position(p_iter: *TextIter) c_int;
    pub const backwardVisibleCursorPosition = gtk_text_iter_backward_visible_cursor_position;

    /// Moves up to `count` visible cursor positions. See
    /// `gtk.TextIter.backwardCursorPosition` for details.
    extern fn gtk_text_iter_backward_visible_cursor_positions(p_iter: *TextIter, p_count: c_int) c_int;
    pub const backwardVisibleCursorPositions = gtk_text_iter_backward_visible_cursor_positions;

    /// Moves `iter` to the start of the previous visible line. Returns `TRUE` if
    /// `iter` could be moved; i.e. if `iter` was at character offset 0, this
    /// function returns `FALSE`. Therefore if `iter` was already on line 0,
    /// but not at the start of the line, `iter` is snapped to the start of
    /// the line and the function returns `TRUE`. (Note that this implies that
    /// in a loop calling this function, the line number may not change on
    /// every iteration, if your first iteration is on line 0.)
    extern fn gtk_text_iter_backward_visible_line(p_iter: *TextIter) c_int;
    pub const backwardVisibleLine = gtk_text_iter_backward_visible_line;

    /// Moves `count` visible lines backward, if possible (if `count` would move
    /// past the start or end of the buffer, moves to the start or end of
    /// the buffer).  The return value indicates whether the iterator moved
    /// onto a dereferenceable position; if the iterator didn’t move, or
    /// moved onto the end iterator, then `FALSE` is returned. If `count` is 0,
    /// the function does nothing and returns `FALSE`. If `count` is negative,
    /// moves forward by 0 - `count` lines.
    extern fn gtk_text_iter_backward_visible_lines(p_iter: *TextIter, p_count: c_int) c_int;
    pub const backwardVisibleLines = gtk_text_iter_backward_visible_lines;

    /// Moves backward to the previous visible word start. (If `iter` is currently
    /// on a word start, moves backward to the next one after that.) Word breaks
    /// are determined by Pango and should be correct for nearly any
    /// language (if not, the correct fix would be to the Pango word break
    /// algorithms).
    extern fn gtk_text_iter_backward_visible_word_start(p_iter: *TextIter) c_int;
    pub const backwardVisibleWordStart = gtk_text_iter_backward_visible_word_start;

    /// Calls `gtk.TextIter.backwardVisibleWordStart` up to `count` times.
    extern fn gtk_text_iter_backward_visible_word_starts(p_iter: *TextIter, p_count: c_int) c_int;
    pub const backwardVisibleWordStarts = gtk_text_iter_backward_visible_word_starts;

    /// Moves backward to the previous word start. (If `iter` is currently on a
    /// word start, moves backward to the next one after that.) Word breaks
    /// are determined by Pango and should be correct for nearly any
    /// language (if not, the correct fix would be to the Pango word break
    /// algorithms).
    extern fn gtk_text_iter_backward_word_start(p_iter: *TextIter) c_int;
    pub const backwardWordStart = gtk_text_iter_backward_word_start;

    /// Calls `gtk.TextIter.backwardWordStart` up to `count` times.
    extern fn gtk_text_iter_backward_word_starts(p_iter: *TextIter, p_count: c_int) c_int;
    pub const backwardWordStarts = gtk_text_iter_backward_word_starts;

    /// Returns `TRUE` if `tag` is toggled on at exactly this point. If `tag`
    /// is `NULL`, returns `TRUE` if any tag is toggled on at this point.
    ///
    /// Note that if `gtk.TextIter.beginsTag` returns `TRUE`, it means that `iter` is
    /// at the beginning of the tagged range, and that the
    /// character at `iter` is inside the tagged range. In other
    /// words, unlike `gtk.TextIter.endsTag`, if `gtk.TextIter.beginsTag` returns
    /// `TRUE`, `gtk.TextIter.hasTag` will also return `TRUE` for the same
    /// parameters.
    extern fn gtk_text_iter_begins_tag(p_iter: *const TextIter, p_tag: ?*gtk.TextTag) c_int;
    pub const beginsTag = gtk_text_iter_begins_tag;

    /// Considering the default editability of the buffer, and tags that
    /// affect editability, determines whether text inserted at `iter` would
    /// be editable. If text inserted at `iter` would be editable then the
    /// user should be allowed to insert text at `iter`.
    /// `gtk.TextBuffer.insertInteractive` uses this function to decide
    /// whether insertions are allowed at a given position.
    extern fn gtk_text_iter_can_insert(p_iter: *const TextIter, p_default_editability: c_int) c_int;
    pub const canInsert = gtk_text_iter_can_insert;

    /// A `qsort`-style function that returns negative if `lhs` is less than
    /// `rhs`, positive if `lhs` is greater than `rhs`, and 0 if they’re equal.
    /// Ordering is in character offset order, i.e. the first character in the buffer
    /// is less than the second character in the buffer.
    extern fn gtk_text_iter_compare(p_lhs: *const TextIter, p_rhs: *const gtk.TextIter) c_int;
    pub const compare = gtk_text_iter_compare;

    /// Creates a dynamically-allocated copy of an iterator. This function
    /// is not useful in applications, because iterators can be copied with a
    /// simple assignment (`GtkTextIter i = j;`). The
    /// function is used by language bindings.
    extern fn gtk_text_iter_copy(p_iter: *const TextIter) *gtk.TextIter;
    pub const copy = gtk_text_iter_copy;

    /// Returns whether the character at `iter` is within an editable region
    /// of text.  Non-editable text is “locked” and can’t be changed by the
    /// user via `gtk.TextView`. This function is simply a convenience
    /// wrapper around `gtk.TextIter.getAttributes`. If no tags applied
    /// to this text affect editability, `default_setting` will be returned.
    ///
    /// You don’t want to use this function to decide whether text can be
    /// inserted at `iter`, because for insertion you don’t want to know
    /// whether the char at `iter` is inside an editable range, you want to
    /// know whether a new character inserted at `iter` would be inside an
    /// editable range. Use `gtk.TextIter.canInsert` to handle this
    /// case.
    extern fn gtk_text_iter_editable(p_iter: *const TextIter, p_default_setting: c_int) c_int;
    pub const editable = gtk_text_iter_editable;

    /// Returns `TRUE` if `iter` points to the start of the paragraph
    /// delimiter characters for a line (delimiters will be either a
    /// newline, a carriage return, a carriage return followed by a
    /// newline, or a Unicode paragraph separator character). Note that an
    /// iterator pointing to the \n of a \r\n pair will not be counted as
    /// the end of a line, the line ends before the \r. The end iterator is
    /// considered to be at the end of a line, even though there are no
    /// paragraph delimiter chars there.
    extern fn gtk_text_iter_ends_line(p_iter: *const TextIter) c_int;
    pub const endsLine = gtk_text_iter_ends_line;

    /// Determines whether `iter` ends a sentence.  Sentence boundaries are
    /// determined by Pango and should be correct for nearly any language
    /// (if not, the correct fix would be to the Pango text boundary
    /// algorithms).
    extern fn gtk_text_iter_ends_sentence(p_iter: *const TextIter) c_int;
    pub const endsSentence = gtk_text_iter_ends_sentence;

    /// Returns `TRUE` if `tag` is toggled off at exactly this point. If `tag`
    /// is `NULL`, returns `TRUE` if any tag is toggled off at this point.
    ///
    /// Note that if `gtk.TextIter.endsTag` returns `TRUE`, it means that `iter` is
    /// at the end of the tagged range, but that the character
    /// at `iter` is outside the tagged range. In other words,
    /// unlike `gtk.TextIter.startsTag`, if `gtk.TextIter.endsTag` returns `TRUE`,
    /// `gtk.TextIter.hasTag` will return `FALSE` for the same parameters.
    extern fn gtk_text_iter_ends_tag(p_iter: *const TextIter, p_tag: ?*gtk.TextTag) c_int;
    pub const endsTag = gtk_text_iter_ends_tag;

    /// Determines whether `iter` ends a natural-language word.  Word breaks
    /// are determined by Pango and should be correct for nearly any
    /// language (if not, the correct fix would be to the Pango word break
    /// algorithms).
    extern fn gtk_text_iter_ends_word(p_iter: *const TextIter) c_int;
    pub const endsWord = gtk_text_iter_ends_word;

    /// Tests whether two iterators are equal, using the fastest possible
    /// mechanism. This function is very fast; you can expect it to perform
    /// better than e.g. getting the character offset for each iterator and
    /// comparing the offsets yourself. Also, it’s a bit faster than
    /// `gtk.TextIter.compare`.
    extern fn gtk_text_iter_equal(p_lhs: *const TextIter, p_rhs: *const gtk.TextIter) c_int;
    pub const equal = gtk_text_iter_equal;

    /// Moves `iter` forward by one character offset. Note that images
    /// embedded in the buffer occupy 1 character slot, so
    /// `gtk.TextIter.forwardChar` may actually move onto an image instead
    /// of a character, if you have images in your buffer.  If `iter` is the
    /// end iterator or one character before it, `iter` will now point at
    /// the end iterator, and `gtk.TextIter.forwardChar` returns `FALSE` for
    /// convenience when writing loops.
    extern fn gtk_text_iter_forward_char(p_iter: *TextIter) c_int;
    pub const forwardChar = gtk_text_iter_forward_char;

    /// Moves `count` characters if possible (if `count` would move past the
    /// start or end of the buffer, moves to the start or end of the
    /// buffer). The return value indicates whether the new position of
    /// `iter` is different from its original position, and dereferenceable
    /// (the last iterator in the buffer is not dereferenceable). If `count`
    /// is 0, the function does nothing and returns `FALSE`.
    extern fn gtk_text_iter_forward_chars(p_iter: *TextIter, p_count: c_int) c_int;
    pub const forwardChars = gtk_text_iter_forward_chars;

    /// Moves `iter` forward by a single cursor position. Cursor positions
    /// are (unsurprisingly) positions where the cursor can appear. Perhaps
    /// surprisingly, there may not be a cursor position between all
    /// characters. The most common example for European languages would be
    /// a carriage return/newline sequence. For some Unicode characters,
    /// the equivalent of say the letter “a” with an accent mark will be
    /// represented as two characters, first the letter then a "combining
    /// mark" that causes the accent to be rendered; so the cursor can’t go
    /// between those two characters. See also the `pango.LogAttr`-struct and
    /// `pango.@"break"` function.
    extern fn gtk_text_iter_forward_cursor_position(p_iter: *TextIter) c_int;
    pub const forwardCursorPosition = gtk_text_iter_forward_cursor_position;

    /// Moves up to `count` cursor positions. See
    /// `gtk.TextIter.forwardCursorPosition` for details.
    extern fn gtk_text_iter_forward_cursor_positions(p_iter: *TextIter, p_count: c_int) c_int;
    pub const forwardCursorPositions = gtk_text_iter_forward_cursor_positions;

    /// Advances `iter`, calling `pred` on each character. If
    /// `pred` returns `TRUE`, returns `TRUE` and stops scanning.
    /// If `pred` never returns `TRUE`, `iter` is set to `limit` if
    /// `limit` is non-`NULL`, otherwise to the end iterator.
    extern fn gtk_text_iter_forward_find_char(p_iter: *TextIter, p_pred: gtk.TextCharPredicate, p_user_data: ?*anyopaque, p_limit: ?*const gtk.TextIter) c_int;
    pub const forwardFindChar = gtk_text_iter_forward_find_char;

    /// Moves `iter` to the start of the next line. If the iter is already on the
    /// last line of the buffer, moves the iter to the end of the current line.
    /// If after the operation, the iter is at the end of the buffer and not
    /// dereferencable, returns `FALSE`. Otherwise, returns `TRUE`.
    extern fn gtk_text_iter_forward_line(p_iter: *TextIter) c_int;
    pub const forwardLine = gtk_text_iter_forward_line;

    /// Moves `count` lines forward, if possible (if `count` would move
    /// past the start or end of the buffer, moves to the start or end of
    /// the buffer).  The return value indicates whether the iterator moved
    /// onto a dereferenceable position; if the iterator didn’t move, or
    /// moved onto the end iterator, then `FALSE` is returned. If `count` is 0,
    /// the function does nothing and returns `FALSE`. If `count` is negative,
    /// moves backward by 0 - `count` lines.
    extern fn gtk_text_iter_forward_lines(p_iter: *TextIter, p_count: c_int) c_int;
    pub const forwardLines = gtk_text_iter_forward_lines;

    /// Searches forward for `str`. Any match is returned by setting
    /// `match_start` to the first character of the match and `match_end` to the
    /// first character after the match. The search will not continue past
    /// `limit`. Note that a search is a linear or O(n) operation, so you
    /// may wish to use `limit` to avoid locking up your UI on large
    /// buffers.
    ///
    /// `match_start` will never be set to a `gtk.TextIter` located before `iter`, even if
    /// there is a possible `match_end` after or at `iter`.
    extern fn gtk_text_iter_forward_search(p_iter: *const TextIter, p_str: [*:0]const u8, p_flags: gtk.TextSearchFlags, p_match_start: ?*gtk.TextIter, p_match_end: ?*gtk.TextIter, p_limit: ?*const gtk.TextIter) c_int;
    pub const forwardSearch = gtk_text_iter_forward_search;

    /// Moves forward to the next sentence end. (If `iter` is at the end of
    /// a sentence, moves to the next end of sentence.)  Sentence
    /// boundaries are determined by Pango and should be correct for nearly
    /// any language (if not, the correct fix would be to the Pango text
    /// boundary algorithms).
    extern fn gtk_text_iter_forward_sentence_end(p_iter: *TextIter) c_int;
    pub const forwardSentenceEnd = gtk_text_iter_forward_sentence_end;

    /// Calls `gtk.TextIter.forwardSentenceEnd` `count` times (or until
    /// `gtk.TextIter.forwardSentenceEnd` returns `FALSE`). If `count` is
    /// negative, moves backward instead of forward.
    extern fn gtk_text_iter_forward_sentence_ends(p_iter: *TextIter, p_count: c_int) c_int;
    pub const forwardSentenceEnds = gtk_text_iter_forward_sentence_ends;

    /// Moves `iter` forward to the “end iterator,” which points one past the last
    /// valid character in the buffer. `gtk.TextIter.getChar` called on the
    /// end iterator returns 0, which is convenient for writing loops.
    extern fn gtk_text_iter_forward_to_end(p_iter: *TextIter) void;
    pub const forwardToEnd = gtk_text_iter_forward_to_end;

    /// Moves the iterator to point to the paragraph delimiter characters,
    /// which will be either a newline, a carriage return, a carriage
    /// return/newline in sequence, or the Unicode paragraph separator
    /// character. If the iterator is already at the paragraph delimiter
    /// characters, moves to the paragraph delimiter characters for the
    /// next line. If `iter` is on the last line in the buffer, which does
    /// not end in paragraph delimiters, moves to the end iterator (end of
    /// the last line), and returns `FALSE`.
    extern fn gtk_text_iter_forward_to_line_end(p_iter: *TextIter) c_int;
    pub const forwardToLineEnd = gtk_text_iter_forward_to_line_end;

    /// Moves forward to the next toggle (on or off) of the
    /// `gtk.TextTag` `tag`, or to the next toggle of any tag if
    /// `tag` is `NULL`. If no matching tag toggles are found,
    /// returns `FALSE`, otherwise `TRUE`. Does not return toggles
    /// located at `iter`, only toggles after `iter`. Sets `iter` to
    /// the location of the toggle, or to the end of the buffer
    /// if no toggle is found.
    extern fn gtk_text_iter_forward_to_tag_toggle(p_iter: *TextIter, p_tag: ?*gtk.TextTag) c_int;
    pub const forwardToTagToggle = gtk_text_iter_forward_to_tag_toggle;

    /// Moves `iter` forward to the next visible cursor position. See
    /// `gtk.TextIter.forwardCursorPosition` for details.
    extern fn gtk_text_iter_forward_visible_cursor_position(p_iter: *TextIter) c_int;
    pub const forwardVisibleCursorPosition = gtk_text_iter_forward_visible_cursor_position;

    /// Moves up to `count` visible cursor positions. See
    /// `gtk.TextIter.forwardCursorPosition` for details.
    extern fn gtk_text_iter_forward_visible_cursor_positions(p_iter: *TextIter, p_count: c_int) c_int;
    pub const forwardVisibleCursorPositions = gtk_text_iter_forward_visible_cursor_positions;

    /// Moves `iter` to the start of the next visible line. Returns `TRUE` if there
    /// was a next line to move to, and `FALSE` if `iter` was simply moved to
    /// the end of the buffer and is now not dereferenceable, or if `iter` was
    /// already at the end of the buffer.
    extern fn gtk_text_iter_forward_visible_line(p_iter: *TextIter) c_int;
    pub const forwardVisibleLine = gtk_text_iter_forward_visible_line;

    /// Moves `count` visible lines forward, if possible (if `count` would move
    /// past the start or end of the buffer, moves to the start or end of
    /// the buffer).  The return value indicates whether the iterator moved
    /// onto a dereferenceable position; if the iterator didn’t move, or
    /// moved onto the end iterator, then `FALSE` is returned. If `count` is 0,
    /// the function does nothing and returns `FALSE`. If `count` is negative,
    /// moves backward by 0 - `count` lines.
    extern fn gtk_text_iter_forward_visible_lines(p_iter: *TextIter, p_count: c_int) c_int;
    pub const forwardVisibleLines = gtk_text_iter_forward_visible_lines;

    /// Moves forward to the next visible word end. (If `iter` is currently on a
    /// word end, moves forward to the next one after that.) Word breaks
    /// are determined by Pango and should be correct for nearly any
    /// language (if not, the correct fix would be to the Pango word break
    /// algorithms).
    extern fn gtk_text_iter_forward_visible_word_end(p_iter: *TextIter) c_int;
    pub const forwardVisibleWordEnd = gtk_text_iter_forward_visible_word_end;

    /// Calls `gtk.TextIter.forwardVisibleWordEnd` up to `count` times.
    extern fn gtk_text_iter_forward_visible_word_ends(p_iter: *TextIter, p_count: c_int) c_int;
    pub const forwardVisibleWordEnds = gtk_text_iter_forward_visible_word_ends;

    /// Moves forward to the next word end. (If `iter` is currently on a
    /// word end, moves forward to the next one after that.) Word breaks
    /// are determined by Pango and should be correct for nearly any
    /// language (if not, the correct fix would be to the Pango word break
    /// algorithms).
    extern fn gtk_text_iter_forward_word_end(p_iter: *TextIter) c_int;
    pub const forwardWordEnd = gtk_text_iter_forward_word_end;

    /// Calls `gtk.TextIter.forwardWordEnd` up to `count` times.
    extern fn gtk_text_iter_forward_word_ends(p_iter: *TextIter, p_count: c_int) c_int;
    pub const forwardWordEnds = gtk_text_iter_forward_word_ends;

    /// Free an iterator allocated on the heap. This function
    /// is intended for use in language bindings, and is not
    /// especially useful for applications, because iterators can
    /// simply be allocated on the stack.
    extern fn gtk_text_iter_free(p_iter: *TextIter) void;
    pub const free = gtk_text_iter_free;

    /// Computes the effect of any tags applied to this spot in the
    /// text. The `values` parameter should be initialized to the default
    /// settings you wish to use if no tags are in effect. You’d typically
    /// obtain the defaults from `gtk.TextView.getDefaultAttributes`.
    ///
    /// `gtk.TextIter.getAttributes` will modify `values`, applying the
    /// effects of any tags present at `iter`. If any tags affected `values`,
    /// the function returns `TRUE`.
    extern fn gtk_text_iter_get_attributes(p_iter: *const TextIter, p_values: *gtk.TextAttributes) c_int;
    pub const getAttributes = gtk_text_iter_get_attributes;

    /// Returns the `gtk.TextBuffer` this iterator is associated with.
    extern fn gtk_text_iter_get_buffer(p_iter: *const TextIter) *gtk.TextBuffer;
    pub const getBuffer = gtk_text_iter_get_buffer;

    /// Returns the number of bytes in the line containing `iter`,
    /// including the paragraph delimiters.
    extern fn gtk_text_iter_get_bytes_in_line(p_iter: *const TextIter) c_int;
    pub const getBytesInLine = gtk_text_iter_get_bytes_in_line;

    /// The Unicode character at this iterator is returned.  (Equivalent to
    /// operator* on a C++ iterator.)  If the element at this iterator is a
    /// non-character element, such as an image embedded in the buffer, the
    /// Unicode “unknown” character 0xFFFC is returned. If invoked on
    /// the end iterator, zero is returned; zero is not a valid Unicode character.
    /// So you can write a loop which ends when `gtk.TextIter.getChar`
    /// returns 0.
    extern fn gtk_text_iter_get_char(p_iter: *const TextIter) u32;
    pub const getChar = gtk_text_iter_get_char;

    /// Returns the number of characters in the line containing `iter`,
    /// including the paragraph delimiters.
    extern fn gtk_text_iter_get_chars_in_line(p_iter: *const TextIter) c_int;
    pub const getCharsInLine = gtk_text_iter_get_chars_in_line;

    /// If the location at `iter` contains a child anchor, the
    /// anchor is returned (with no new reference count added). Otherwise,
    /// `NULL` is returned.
    extern fn gtk_text_iter_get_child_anchor(p_iter: *const TextIter) *gtk.TextChildAnchor;
    pub const getChildAnchor = gtk_text_iter_get_child_anchor;

    /// A convenience wrapper around `gtk.TextIter.getAttributes`,
    /// which returns the language in effect at `iter`. If no tags affecting
    /// language apply to `iter`, the return value is identical to that of
    /// `gtk.getDefaultLanguage`.
    extern fn gtk_text_iter_get_language(p_iter: *const TextIter) *pango.Language;
    pub const getLanguage = gtk_text_iter_get_language;

    /// Returns the line number containing the iterator. Lines in
    /// a `gtk.TextBuffer` are numbered beginning with 0 for the first
    /// line in the buffer.
    extern fn gtk_text_iter_get_line(p_iter: *const TextIter) c_int;
    pub const getLine = gtk_text_iter_get_line;

    /// Returns the byte index of the iterator, counting
    /// from the start of a newline-terminated line.
    /// Remember that `gtk.TextBuffer` encodes text in
    /// UTF-8, and that characters can require a variable
    /// number of bytes to represent.
    extern fn gtk_text_iter_get_line_index(p_iter: *const TextIter) c_int;
    pub const getLineIndex = gtk_text_iter_get_line_index;

    /// Returns the character offset of the iterator,
    /// counting from the start of a newline-terminated line.
    /// The first character on the line has offset 0.
    extern fn gtk_text_iter_get_line_offset(p_iter: *const TextIter) c_int;
    pub const getLineOffset = gtk_text_iter_get_line_offset;

    /// Returns a list of all `gtk.TextMark` at this location. Because marks
    /// are not iterable (they don’t take up any "space" in the buffer,
    /// they are just marks in between iterable locations), multiple marks
    /// can exist in the same place. The returned list is not in any
    /// meaningful order.
    extern fn gtk_text_iter_get_marks(p_iter: *const TextIter) *glib.SList;
    pub const getMarks = gtk_text_iter_get_marks;

    /// Returns the character offset of an iterator.
    /// Each character in a `gtk.TextBuffer` has an offset,
    /// starting with 0 for the first character in the buffer.
    /// Use `gtk.TextBuffer.getIterAtOffset` to convert an
    /// offset back into an iterator.
    extern fn gtk_text_iter_get_offset(p_iter: *const TextIter) c_int;
    pub const getOffset = gtk_text_iter_get_offset;

    /// If the element at `iter` is a pixbuf, the pixbuf is returned
    /// (with no new reference count added). Otherwise,
    /// `NULL` is returned.
    extern fn gtk_text_iter_get_pixbuf(p_iter: *const TextIter) *gdkpixbuf.Pixbuf;
    pub const getPixbuf = gtk_text_iter_get_pixbuf;

    /// Returns the text in the given range. A “slice” is an array of
    /// characters encoded in UTF-8 format, including the Unicode “unknown”
    /// character 0xFFFC for iterable non-character elements in the buffer,
    /// such as images.  Because images are encoded in the slice, byte and
    /// character offsets in the returned array will correspond to byte
    /// offsets in the text buffer. Note that 0xFFFC can occur in normal
    /// text as well, so it is not a reliable indicator that a pixbuf or
    /// widget is in the buffer.
    extern fn gtk_text_iter_get_slice(p_start: *const TextIter, p_end: *const gtk.TextIter) [*:0]u8;
    pub const getSlice = gtk_text_iter_get_slice;

    /// Returns a list of tags that apply to `iter`, in ascending order of
    /// priority (highest-priority tags are last). The `gtk.TextTag` in the
    /// list don’t have a reference added, but you have to free the list
    /// itself.
    extern fn gtk_text_iter_get_tags(p_iter: *const TextIter) *glib.SList;
    pub const getTags = gtk_text_iter_get_tags;

    /// Returns text in the given range.  If the range
    /// contains non-text elements such as images, the character and byte
    /// offsets in the returned string will not correspond to character and
    /// byte offsets in the buffer. If you want offsets to correspond, see
    /// `gtk.TextIter.getSlice`.
    extern fn gtk_text_iter_get_text(p_start: *const TextIter, p_end: *const gtk.TextIter) [*:0]u8;
    pub const getText = gtk_text_iter_get_text;

    /// Returns a list of `gtk.TextTag` that are toggled on or off at this
    /// point.  (If `toggled_on` is `TRUE`, the list contains tags that are
    /// toggled on.) If a tag is toggled on at `iter`, then some non-empty
    /// range of characters following `iter` has that tag applied to it.  If
    /// a tag is toggled off, then some non-empty range following `iter`
    /// does not have the tag applied to it.
    extern fn gtk_text_iter_get_toggled_tags(p_iter: *const TextIter, p_toggled_on: c_int) *glib.SList;
    pub const getToggledTags = gtk_text_iter_get_toggled_tags;

    /// Returns the number of bytes from the start of the
    /// line to the given `iter`, not counting bytes that
    /// are invisible due to tags with the “invisible” flag
    /// toggled on.
    extern fn gtk_text_iter_get_visible_line_index(p_iter: *const TextIter) c_int;
    pub const getVisibleLineIndex = gtk_text_iter_get_visible_line_index;

    /// Returns the offset in characters from the start of the
    /// line to the given `iter`, not counting characters that
    /// are invisible due to tags with the “invisible” flag
    /// toggled on.
    extern fn gtk_text_iter_get_visible_line_offset(p_iter: *const TextIter) c_int;
    pub const getVisibleLineOffset = gtk_text_iter_get_visible_line_offset;

    /// Like `gtk.TextIter.getSlice`, but invisible text is not included.
    /// Invisible text is usually invisible because a `gtk.TextTag` with the
    /// “invisible” attribute turned on has been applied to it.
    extern fn gtk_text_iter_get_visible_slice(p_start: *const TextIter, p_end: *const gtk.TextIter) [*:0]u8;
    pub const getVisibleSlice = gtk_text_iter_get_visible_slice;

    /// Like `gtk.TextIter.getText`, but invisible text is not included.
    /// Invisible text is usually invisible because a `gtk.TextTag` with the
    /// “invisible” attribute turned on has been applied to it.
    extern fn gtk_text_iter_get_visible_text(p_start: *const TextIter, p_end: *const gtk.TextIter) [*:0]u8;
    pub const getVisibleText = gtk_text_iter_get_visible_text;

    /// Returns `TRUE` if `iter` points to a character that is part of a range tagged
    /// with `tag`. See also `gtk.TextIter.startsTag` and `gtk.TextIter.endsTag`.
    extern fn gtk_text_iter_has_tag(p_iter: *const TextIter, p_tag: *gtk.TextTag) c_int;
    pub const hasTag = gtk_text_iter_has_tag;

    /// Checks whether `iter` falls in the range [`start`, `end`).
    /// `start` and `end` must be in ascending order.
    extern fn gtk_text_iter_in_range(p_iter: *const TextIter, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter) c_int;
    pub const inRange = gtk_text_iter_in_range;

    /// Determines whether `iter` is inside a sentence (as opposed to in
    /// between two sentences, e.g. after a period and before the first
    /// letter of the next sentence).  Sentence boundaries are determined
    /// by Pango and should be correct for nearly any language (if not, the
    /// correct fix would be to the Pango text boundary algorithms).
    extern fn gtk_text_iter_inside_sentence(p_iter: *const TextIter) c_int;
    pub const insideSentence = gtk_text_iter_inside_sentence;

    /// Determines whether the character pointed by `iter` is part of a
    /// natural-language word (as opposed to say inside some whitespace).  Word
    /// breaks are determined by Pango and should be correct for nearly any language
    /// (if not, the correct fix would be to the Pango word break algorithms).
    ///
    /// Note that if `gtk.TextIter.startsWord` returns `TRUE`, then this function
    /// returns `TRUE` too, since `iter` points to the first character of the word.
    extern fn gtk_text_iter_inside_word(p_iter: *const TextIter) c_int;
    pub const insideWord = gtk_text_iter_inside_word;

    /// See `gtk.TextIter.forwardCursorPosition` or `pango.LogAttr` or
    /// `pango.@"break"` for details on what a cursor position is.
    extern fn gtk_text_iter_is_cursor_position(p_iter: *const TextIter) c_int;
    pub const isCursorPosition = gtk_text_iter_is_cursor_position;

    /// Returns `TRUE` if `iter` is the end iterator, i.e. one past the last
    /// dereferenceable iterator in the buffer. `gtk.TextIter.isEnd` is
    /// the most efficient way to check whether an iterator is the end
    /// iterator.
    extern fn gtk_text_iter_is_end(p_iter: *const TextIter) c_int;
    pub const isEnd = gtk_text_iter_is_end;

    /// Returns `TRUE` if `iter` is the first iterator in the buffer, that is
    /// if `iter` has a character offset of 0.
    extern fn gtk_text_iter_is_start(p_iter: *const TextIter) c_int;
    pub const isStart = gtk_text_iter_is_start;

    /// Swaps the value of `first` and `second` if `second` comes before
    /// `first` in the buffer. That is, ensures that `first` and `second` are
    /// in sequence. Most text buffer functions that take a range call this
    /// automatically on your behalf, so there’s no real reason to call it yourself
    /// in those cases. There are some exceptions, such as `gtk.TextIter.inRange`,
    /// that expect a pre-sorted range.
    extern fn gtk_text_iter_order(p_first: *TextIter, p_second: *gtk.TextIter) void;
    pub const order = gtk_text_iter_order;

    /// Moves iterator `iter` to the start of the line `line_number`.  If
    /// `line_number` is negative or larger than the number of lines in the
    /// buffer, moves `iter` to the start of the last line in the buffer.
    extern fn gtk_text_iter_set_line(p_iter: *TextIter, p_line_number: c_int) void;
    pub const setLine = gtk_text_iter_set_line;

    /// Same as `gtk.TextIter.setLineOffset`, but works with a
    /// byte index. The given byte index must be at
    /// the start of a character, it can’t be in the middle of a UTF-8
    /// encoded character.
    extern fn gtk_text_iter_set_line_index(p_iter: *TextIter, p_byte_on_line: c_int) void;
    pub const setLineIndex = gtk_text_iter_set_line_index;

    /// Moves `iter` within a line, to a new character
    /// (not byte) offset. The given character offset must be less than or
    /// equal to the number of characters in the line; if equal, `iter`
    /// moves to the start of the next line. See
    /// `gtk.TextIter.setLineIndex` if you have a byte index rather than
    /// a character offset.
    extern fn gtk_text_iter_set_line_offset(p_iter: *TextIter, p_char_on_line: c_int) void;
    pub const setLineOffset = gtk_text_iter_set_line_offset;

    /// Sets `iter` to point to `char_offset`. `char_offset` counts from the start
    /// of the entire text buffer, starting with 0.
    extern fn gtk_text_iter_set_offset(p_iter: *TextIter, p_char_offset: c_int) void;
    pub const setOffset = gtk_text_iter_set_offset;

    /// Like `gtk.TextIter.setLineIndex`, but the index is in visible
    /// bytes, i.e. text with a tag making it invisible is not counted
    /// in the index.
    extern fn gtk_text_iter_set_visible_line_index(p_iter: *TextIter, p_byte_on_line: c_int) void;
    pub const setVisibleLineIndex = gtk_text_iter_set_visible_line_index;

    /// Like `gtk.TextIter.setLineOffset`, but the offset is in visible
    /// characters, i.e. text with a tag making it invisible is not
    /// counted in the offset.
    extern fn gtk_text_iter_set_visible_line_offset(p_iter: *TextIter, p_char_on_line: c_int) void;
    pub const setVisibleLineOffset = gtk_text_iter_set_visible_line_offset;

    /// Returns `TRUE` if `iter` begins a paragraph,
    /// i.e. if `gtk.TextIter.getLineOffset` would return 0.
    /// However this function is potentially more efficient than
    /// `gtk.TextIter.getLineOffset` because it doesn’t have to compute
    /// the offset, it just has to see whether it’s 0.
    extern fn gtk_text_iter_starts_line(p_iter: *const TextIter) c_int;
    pub const startsLine = gtk_text_iter_starts_line;

    /// Determines whether `iter` begins a sentence.  Sentence boundaries are
    /// determined by Pango and should be correct for nearly any language
    /// (if not, the correct fix would be to the Pango text boundary
    /// algorithms).
    extern fn gtk_text_iter_starts_sentence(p_iter: *const TextIter) c_int;
    pub const startsSentence = gtk_text_iter_starts_sentence;

    /// Returns `TRUE` if `tag` is toggled on at exactly this point. If `tag`
    /// is `NULL`, returns `TRUE` if any tag is toggled on at this point.
    ///
    /// Note that if `gtk.TextIter.startsTag` returns `TRUE`, it means that `iter` is
    /// at the beginning of the tagged range, and that the
    /// character at `iter` is inside the tagged range. In other
    /// words, unlike `gtk.TextIter.endsTag`, if `gtk.TextIter.startsTag` returns
    /// `TRUE`, `gtk.TextIter.hasTag` will also return `TRUE` for the same
    /// parameters.
    extern fn gtk_text_iter_starts_tag(p_iter: *const TextIter, p_tag: ?*gtk.TextTag) c_int;
    pub const startsTag = gtk_text_iter_starts_tag;

    /// Determines whether `iter` begins a natural-language word.  Word
    /// breaks are determined by Pango and should be correct for nearly any
    /// language (if not, the correct fix would be to the Pango word break
    /// algorithms).
    extern fn gtk_text_iter_starts_word(p_iter: *const TextIter) c_int;
    pub const startsWord = gtk_text_iter_starts_word;

    /// This is equivalent to (`gtk.TextIter.startsTag` ||
    /// `gtk.TextIter.endsTag`), i.e. it tells you whether a range with
    /// `tag` applied to it begins or ends at `iter`.
    extern fn gtk_text_iter_toggles_tag(p_iter: *const TextIter, p_tag: ?*gtk.TextTag) c_int;
    pub const togglesTag = gtk_text_iter_toggles_tag;

    extern fn gtk_text_iter_get_type() usize;
    pub const getGObjectType = gtk_text_iter_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextMarkClass = extern struct {
    pub const Instance = gtk.TextMark;

    f_parent_class: gobject.ObjectClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *TextMarkClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextTagClass = extern struct {
    pub const Instance = gtk.TextTag;

    f_parent_class: gobject.ObjectClass,
    f_event: ?*const fn (p_tag: *gtk.TextTag, p_event_object: *gobject.Object, p_event: *gdk.Event, p_iter: *const gtk.TextIter) callconv(.c) c_int,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *TextTagClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextTagPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextTagTableClass = extern struct {
    pub const Instance = gtk.TextTagTable;

    f_parent_class: gobject.ObjectClass,
    f_tag_changed: ?*const fn (p_table: *gtk.TextTagTable, p_tag: *gtk.TextTag, p_size_changed: c_int) callconv(.c) void,
    f_tag_added: ?*const fn (p_table: *gtk.TextTagTable, p_tag: *gtk.TextTag) callconv(.c) void,
    f_tag_removed: ?*const fn (p_table: *gtk.TextTagTable, p_tag: *gtk.TextTag) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *TextTagTableClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextTagTablePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextViewAccessibleClass = extern struct {
    pub const Instance = gtk.TextViewAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *TextViewAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextViewAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextViewClass = extern struct {
    pub const Instance = gtk.TextView;

    /// The object class structure needs to be the first
    f_parent_class: gtk.ContainerClass,
    /// The class handler for the `gtk.TextView.signals.populate`-popup
    ///   signal.
    f_populate_popup: ?*const fn (p_text_view: *gtk.TextView, p_popup: *gtk.Widget) callconv(.c) void,
    /// The class handler for the `gtk.TextView.signals.move`-cursor
    ///   keybinding signal.
    f_move_cursor: ?*const fn (p_text_view: *gtk.TextView, p_step: gtk.MovementStep, p_count: c_int, p_extend_selection: c_int) callconv(.c) void,
    /// The class handler for the `gtk.TextView.signals.set`-anchor
    ///   keybinding signal.
    f_set_anchor: ?*const fn (p_text_view: *gtk.TextView) callconv(.c) void,
    /// The class handler for the `gtk.TextView.signals.insert`-at-cursor
    ///   keybinding signal.
    f_insert_at_cursor: ?*const fn (p_text_view: *gtk.TextView, p_str: [*:0]const u8) callconv(.c) void,
    /// The class handler for the `gtk.TextView.signals.delete`-from-cursor
    ///   keybinding signal.
    f_delete_from_cursor: ?*const fn (p_text_view: *gtk.TextView, p_type: gtk.DeleteType, p_count: c_int) callconv(.c) void,
    /// The class handler for the `gtk.TextView.signals.backspace`
    ///   keybinding signal.
    f_backspace: ?*const fn (p_text_view: *gtk.TextView) callconv(.c) void,
    /// The class handler for the `gtk.TextView.signals.cut`-clipboard
    ///   keybinding signal
    f_cut_clipboard: ?*const fn (p_text_view: *gtk.TextView) callconv(.c) void,
    /// The class handler for the `GtkTextview.signals.copy`-clipboard
    ///   keybinding signal.
    f_copy_clipboard: ?*const fn (p_text_view: *gtk.TextView) callconv(.c) void,
    /// The class handler for the `gtk.TextView.signals.paste`-clipboard
    ///   keybinding signal.
    f_paste_clipboard: ?*const fn (p_text_view: *gtk.TextView) callconv(.c) void,
    /// The class handler for the `gtk.TextView.signals.toggle`-overwrite
    ///   keybinding signal.
    f_toggle_overwrite: ?*const fn (p_text_view: *gtk.TextView) callconv(.c) void,
    /// The create_buffer vfunc is called to create a `gtk.TextBuffer`
    ///   for the text view. The default implementation is to just call
    ///   `gtk.TextBuffer.new`. Since: 3.10
    f_create_buffer: ?*const fn (p_text_view: *gtk.TextView) callconv(.c) *gtk.TextBuffer,
    /// The draw_layer vfunc is called before and after the text
    ///   view is drawing its own text. Applications can override this vfunc
    ///   in a subclass to draw customized content underneath or above the
    ///   text. In the `GTK_TEXT_VIEW_LAYER_BELOW_TEXT` and `GTK_TEXT_VIEW_LAYER_ABOVE_TEXT`
    ///   the drawing is done in the buffer coordinate space, but the older (deprecated)
    ///   layers `GTK_TEXT_VIEW_LAYER_BELOW` and `GTK_TEXT_VIEW_LAYER_ABOVE` work in viewport
    ///   coordinates, which makes them unnecessarily hard to use. Since: 3.14
    f_draw_layer: ?*const fn (p_text_view: *gtk.TextView, p_layer: gtk.TextViewLayer, p_cr: *cairo.Context) callconv(.c) void,
    /// The class handler for the `gtk.TextView.signals.extend`-selection
    ///   signal. Since 3.16
    f_extend_selection: ?*const fn (p_text_view: *gtk.TextView, p_granularity: gtk.TextExtendSelection, p_location: *const gtk.TextIter, p_start: *gtk.TextIter, p_end: *gtk.TextIter) callconv(.c) c_int,
    f_insert_emoji: ?*const fn (p_text_view: *gtk.TextView) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *TextViewClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TextViewPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ThemeEngine = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Base class for theming engines.
pub const ThemingEngineClass = extern struct {
    pub const Instance = gtk.ThemingEngine;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    /// Renders a line between two points.
    f_render_line: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_x0: f64, p_y0: f64, p_x1: f64, p_y1: f64) callconv(.c) void,
    /// Renders the background area of a widget region.
    f_render_background: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void,
    /// Renders the frame around a widget area.
    f_render_frame: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void,
    /// Renders the frame around a widget area with a gap in it.
    f_render_frame_gap: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64, p_gap_side: gtk.PositionType, p_xy0_gap: f64, p_xy1_gap: f64) callconv(.c) void,
    /// Renders a extension to a box, usually a notebook tab.
    f_render_extension: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64, p_gap_side: gtk.PositionType) callconv(.c) void,
    /// Renders a checkmark, as in `gtk.CheckButton`.
    f_render_check: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void,
    /// Renders an option, as in `gtk.RadioButton`.
    f_render_option: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void,
    /// Renders an arrow pointing to a certain direction.
    f_render_arrow: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_angle: f64, p_x: f64, p_y: f64, p_size: f64) callconv(.c) void,
    /// Renders an element what will expose/expand part of
    ///                   the UI, as in `gtk.Expander`.
    f_render_expander: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void,
    /// Renders the focus indicator.
    f_render_focus: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void,
    /// Renders a `pango.Layout`
    f_render_layout: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_layout: *pango.Layout) callconv(.c) void,
    /// Renders a slider control, as in `gtk.Scale`.
    f_render_slider: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64, p_orientation: gtk.Orientation) callconv(.c) void,
    /// Renders a handle to drag UI elements, as in `gtk.Paned`.
    f_render_handle: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void,
    /// Renders an area displaying activity, such as in `gtk.Spinner`,
    ///                   or `gtk.ProgressBar`.
    f_render_activity: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) callconv(.c) void,
    /// Renders an icon as a `gdkpixbuf.Pixbuf`.
    f_render_icon_pixbuf: ?*const fn (p_engine: *gtk.ThemingEngine, p_source: *const gtk.IconSource, p_size: gtk.IconSize) callconv(.c) *gdkpixbuf.Pixbuf,
    /// Renders an icon given as a `gdkpixbuf.Pixbuf`.
    f_render_icon: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_pixbuf: *gdkpixbuf.Pixbuf, p_x: f64, p_y: f64) callconv(.c) void,
    /// Renders an icon given as a `cairo.Surface`.
    f_render_icon_surface: ?*const fn (p_engine: *gtk.ThemingEngine, p_cr: *cairo.Context, p_surface: *cairo.Surface, p_x: f64, p_y: f64) callconv(.c) void,
    f_padding: [14]*anyopaque,

    pub fn as(p_instance: *ThemingEngineClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ThemingEnginePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToggleActionClass = extern struct {
    pub const Instance = gtk.ToggleAction;

    f_parent_class: gtk.ActionClass,
    f_toggled: ?*const fn (p_action: *gtk.ToggleAction) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ToggleActionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gtk.ToggleActionEntry` structs are used with
/// `gtk.ActionGroup.addToggleActions` to construct toggle actions.
pub const ToggleActionEntry = extern struct {
    /// The name of the action.
    f_name: ?[*:0]const u8,
    /// The stock id for the action, or the name of an icon from the
    ///  icon theme.
    f_stock_id: ?[*:0]const u8,
    /// The label for the action. This field should typically be marked
    ///  for translation, see `gtk.ActionGroup.setTranslationDomain`.
    f_label: ?[*:0]const u8,
    /// The accelerator for the action, in the format understood by
    ///  `gtk.acceleratorParse`.
    f_accelerator: ?[*:0]const u8,
    /// The tooltip for the action. This field should typically be
    ///  marked for translation, see `gtk.ActionGroup.setTranslationDomain`.
    f_tooltip: ?[*:0]const u8,
    /// The function to call when the action is activated.
    f_callback: ?gobject.Callback,
    /// The initial state of the toggle action.
    f_is_active: c_int,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToggleActionPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToggleButtonAccessibleClass = extern struct {
    pub const Instance = gtk.ToggleButtonAccessible;

    f_parent_class: gtk.ButtonAccessibleClass,

    pub fn as(p_instance: *ToggleButtonAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToggleButtonAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToggleButtonClass = extern struct {
    pub const Instance = gtk.ToggleButton;

    f_parent_class: gtk.ButtonClass,
    f_toggled: ?*const fn (p_toggle_button: *gtk.ToggleButton) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ToggleButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToggleButtonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToggleToolButtonClass = extern struct {
    pub const Instance = gtk.ToggleToolButton;

    /// The parent class.
    f_parent_class: gtk.ToolButtonClass,
    /// Signal emitted whenever the toggle tool button changes state.
    f_toggled: ?*const fn (p_button: *gtk.ToggleToolButton) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ToggleToolButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToggleToolButtonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToolButtonClass = extern struct {
    pub const Instance = gtk.ToolButton;

    /// The parent class.
    f_parent_class: gtk.ToolItemClass,
    f_button_type: usize,
    /// Signal emitted when the tool button is clicked with the
    ///    mouse or activated with the keyboard.
    f_clicked: ?*const fn (p_tool_item: *gtk.ToolButton) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ToolButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToolButtonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToolItemClass = extern struct {
    pub const Instance = gtk.ToolItem;

    /// The parent class.
    f_parent_class: gtk.BinClass,
    /// Signal emitted when the toolbar needs
    ///    information from tool_item about whether the item should appear in
    ///    the toolbar overflow menu.
    f_create_menu_proxy: ?*const fn (p_tool_item: *gtk.ToolItem) callconv(.c) c_int,
    /// Signal emitted when some property of the
    ///    toolbar that the item is a child of changes.
    f_toolbar_reconfigured: ?*const fn (p_tool_item: *gtk.ToolItem) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ToolItemClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToolItemGroupClass = extern struct {
    pub const Instance = gtk.ToolItemGroup;

    /// The parent class.
    f_parent_class: gtk.ContainerClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ToolItemGroupClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToolItemGroupPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToolItemPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToolPaletteClass = extern struct {
    pub const Instance = gtk.ToolPalette;

    /// The parent class.
    f_parent_class: gtk.ContainerClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ToolPaletteClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToolPalettePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Virtual function table for the `gtk.ToolShell` interface.
pub const ToolShellIface = extern struct {
    pub const Instance = gtk.ToolShell;

    f_g_iface: gobject.TypeInterface,
    /// mandatory implementation of `gtk.ToolShell.getIconSize`.
    f_get_icon_size: ?*const fn (p_shell: *gtk.ToolShell) callconv(.c) gtk.IconSize,
    /// mandatory implementation of `gtk.ToolShell.getOrientation`.
    f_get_orientation: ?*const fn (p_shell: *gtk.ToolShell) callconv(.c) gtk.Orientation,
    /// mandatory implementation of `gtk.ToolShell.getStyle`.
    f_get_style: ?*const fn (p_shell: *gtk.ToolShell) callconv(.c) gtk.ToolbarStyle,
    /// optional implementation of `gtk.ToolShell.getReliefStyle`.
    f_get_relief_style: ?*const fn (p_shell: *gtk.ToolShell) callconv(.c) gtk.ReliefStyle,
    /// optional implementation of `gtk.ToolShell.rebuildMenu`.
    f_rebuild_menu: ?*const fn (p_shell: *gtk.ToolShell) callconv(.c) void,
    /// optional implementation of `gtk.ToolShell.getTextOrientation`.
    f_get_text_orientation: ?*const fn (p_shell: *gtk.ToolShell) callconv(.c) gtk.Orientation,
    /// optional implementation of `gtk.ToolShell.getTextAlignment`.
    f_get_text_alignment: ?*const fn (p_shell: *gtk.ToolShell) callconv(.c) f32,
    /// optional implementation of `gtk.ToolShell.getEllipsizeMode`.
    f_get_ellipsize_mode: ?*const fn (p_shell: *gtk.ToolShell) callconv(.c) pango.EllipsizeMode,
    /// optional implementation of `gtk.ToolShell.getTextSizeGroup`.
    f_get_text_size_group: ?*const fn (p_shell: *gtk.ToolShell) callconv(.c) *gtk.SizeGroup,

    pub fn as(p_instance: *ToolShellIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToolbarClass = extern struct {
    pub const Instance = gtk.Toolbar;

    f_parent_class: gtk.ContainerClass,
    f_orientation_changed: ?*const fn (p_toolbar: *gtk.Toolbar, p_orientation: gtk.Orientation) callconv(.c) void,
    f_style_changed: ?*const fn (p_toolbar: *gtk.Toolbar, p_style: gtk.ToolbarStyle) callconv(.c) void,
    f_popup_context_menu: ?*const fn (p_toolbar: *gtk.Toolbar, p_x: c_int, p_y: c_int, p_button_number: c_int) callconv(.c) c_int,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ToolbarClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToolbarPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToplevelAccessibleClass = extern struct {
    pub const Instance = gtk.ToplevelAccessible;

    f_parent_class: atk.ObjectClass,

    pub fn as(p_instance: *ToplevelAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ToplevelAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeDragDestIface = extern struct {
    pub const Instance = gtk.TreeDragDest;

    f_g_iface: gobject.TypeInterface,
    /// Asks the `gtk.TreeDragDest` to insert a row
    ///    before the path dest, deriving the contents of the row from
    ///    selection_data.
    f_drag_data_received: ?*const fn (p_drag_dest: *gtk.TreeDragDest, p_dest: *gtk.TreePath, p_selection_data: *gtk.SelectionData) callconv(.c) c_int,
    /// Determines whether a drop is possible before
    ///    the given dest_path, at the same depth as dest_path.
    f_row_drop_possible: ?*const fn (p_drag_dest: *gtk.TreeDragDest, p_dest_path: *gtk.TreePath, p_selection_data: *gtk.SelectionData) callconv(.c) c_int,

    pub fn as(p_instance: *TreeDragDestIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeDragSourceIface = extern struct {
    pub const Instance = gtk.TreeDragSource;

    f_g_iface: gobject.TypeInterface,
    /// Asks the `gtk.TreeDragSource` whether a particular
    ///    row can be used as the source of a DND operation.
    f_row_draggable: ?*const fn (p_drag_source: *gtk.TreeDragSource, p_path: *gtk.TreePath) callconv(.c) c_int,
    /// Asks the `gtk.TreeDragSource` to fill in
    ///    selection_data with a representation of the row at path.
    f_drag_data_get: ?*const fn (p_drag_source: *gtk.TreeDragSource, p_path: *gtk.TreePath, p_selection_data: *gtk.SelectionData) callconv(.c) c_int,
    /// Asks the `gtk.TreeDragSource` to delete the row at
    ///    path, because it was moved somewhere else via drag-and-drop.
    f_drag_data_delete: ?*const fn (p_drag_source: *gtk.TreeDragSource, p_path: *gtk.TreePath) callconv(.c) c_int,

    pub fn as(p_instance: *TreeDragSourceIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.TreeIter` is the primary structure
/// for accessing a `gtk.TreeModel`. Models are expected to put a unique
/// integer in the `stamp` member, and put
/// model-specific data in the three `user_data`
/// members.
pub const TreeIter = extern struct {
    /// a unique stamp to catch invalid iterators
    f_stamp: c_int,
    /// model-specific data
    f_user_data: ?*anyopaque,
    /// model-specific data
    f_user_data2: ?*anyopaque,
    /// model-specific data
    f_user_data3: ?*anyopaque,

    /// Creates a dynamically allocated tree iterator as a copy of `iter`.
    ///
    /// This function is not intended for use in applications,
    /// because you can just copy the structs by value
    /// (`GtkTreeIter new_iter = iter;`).
    /// You must free this iter with `gtk.TreeIter.free`.
    extern fn gtk_tree_iter_copy(p_iter: *TreeIter) *gtk.TreeIter;
    pub const copy = gtk_tree_iter_copy;

    /// Frees an iterator that has been allocated by `gtk.TreeIter.copy`.
    ///
    /// This function is mainly used for language bindings.
    extern fn gtk_tree_iter_free(p_iter: *TreeIter) void;
    pub const free = gtk_tree_iter_free;

    extern fn gtk_tree_iter_get_type() usize;
    pub const getGObjectType = gtk_tree_iter_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeModelFilterClass = extern struct {
    pub const Instance = gtk.TreeModelFilter;

    f_parent_class: gobject.ObjectClass,
    f_visible: ?*const fn (p_self: *gtk.TreeModelFilter, p_child_model: *gtk.TreeModel, p_iter: *gtk.TreeIter) callconv(.c) c_int,
    f_modify: ?*const fn (p_self: *gtk.TreeModelFilter, p_child_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_value: *gobject.Value, p_column: c_int) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *TreeModelFilterClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeModelFilterPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeModelIface = extern struct {
    pub const Instance = gtk.TreeModel;

    f_g_iface: gobject.TypeInterface,
    /// Signal emitted when a row in the model has changed.
    f_row_changed: ?*const fn (p_tree_model: *gtk.TreeModel, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter) callconv(.c) void,
    /// Signal emitted when a new row has been inserted in
    ///    the model.
    f_row_inserted: ?*const fn (p_tree_model: *gtk.TreeModel, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter) callconv(.c) void,
    /// Signal emitted when a row has gotten the
    ///    first child row or lost its last child row.
    f_row_has_child_toggled: ?*const fn (p_tree_model: *gtk.TreeModel, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter) callconv(.c) void,
    /// Signal emitted when a row has been deleted.
    f_row_deleted: ?*const fn (p_tree_model: *gtk.TreeModel, p_path: *gtk.TreePath) callconv(.c) void,
    /// Signal emitted when the children of a node in the
    ///    GtkTreeModel have been reordered.
    f_rows_reordered: ?*const fn (p_tree_model: *gtk.TreeModel, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter, p_new_order: *c_int) callconv(.c) void,
    /// Get `gtk.TreeModelFlags` supported by this interface.
    f_get_flags: ?*const fn (p_tree_model: *gtk.TreeModel) callconv(.c) gtk.TreeModelFlags,
    /// Get the number of columns supported by the model.
    f_get_n_columns: ?*const fn (p_tree_model: *gtk.TreeModel) callconv(.c) c_int,
    /// Get the type of the column.
    f_get_column_type: ?*const fn (p_tree_model: *gtk.TreeModel, p_index_: c_int) callconv(.c) usize,
    /// Sets iter to a valid iterator pointing to path.
    f_get_iter: ?*const fn (p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) callconv(.c) c_int,
    /// Gets a newly-created `gtk.TreePath` referenced by iter.
    f_get_path: ?*const fn (p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter) callconv(.c) *gtk.TreePath,
    /// Initializes and sets value to that at column.
    f_get_value: ?*const fn (p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_column: c_int, p_value: *gobject.Value) callconv(.c) void,
    /// Sets iter to point to the node following it at the
    ///    current level.
    f_iter_next: ?*const fn (p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter) callconv(.c) c_int,
    /// Sets iter to point to the previous node at the
    ///    current level.
    f_iter_previous: ?*const fn (p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter) callconv(.c) c_int,
    /// Sets iter to point to the first child of parent.
    f_iter_children: ?*const fn (p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_parent: ?*gtk.TreeIter) callconv(.c) c_int,
    /// `TRUE` if iter has children, `FALSE` otherwise.
    f_iter_has_child: ?*const fn (p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter) callconv(.c) c_int,
    /// Gets the number of children that iter has.
    f_iter_n_children: ?*const fn (p_tree_model: *gtk.TreeModel, p_iter: ?*gtk.TreeIter) callconv(.c) c_int,
    /// Sets iter to be the child of parent, using the
    ///    given index.
    f_iter_nth_child: ?*const fn (p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_parent: ?*gtk.TreeIter, p_n: c_int) callconv(.c) c_int,
    /// Sets iter to be the parent of child.
    f_iter_parent: ?*const fn (p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_child: *gtk.TreeIter) callconv(.c) c_int,
    /// Lets the tree ref the node.
    f_ref_node: ?*const fn (p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter) callconv(.c) void,
    /// Lets the tree unref the node.
    f_unref_node: ?*const fn (p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter) callconv(.c) void,

    pub fn as(p_instance: *TreeModelIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeModelSortClass = extern struct {
    pub const Instance = gtk.TreeModelSort;

    f_parent_class: gobject.ObjectClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *TreeModelSortClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeModelSortPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreePath = opaque {
    /// Creates a new `gtk.TreePath`-struct.
    /// This refers to a row.
    extern fn gtk_tree_path_new() *gtk.TreePath;
    pub const new = gtk_tree_path_new;

    /// Creates a new `gtk.TreePath`-struct.
    ///
    /// The string representation of this path is “0”.
    extern fn gtk_tree_path_new_first() *gtk.TreePath;
    pub const newFirst = gtk_tree_path_new_first;

    /// Creates a new path with `first_index` and `varargs` as indices.
    extern fn gtk_tree_path_new_from_indices(p_first_index: c_int, ...) *gtk.TreePath;
    pub const newFromIndices = gtk_tree_path_new_from_indices;

    /// Creates a new path with the given `indices` array of `length`.
    extern fn gtk_tree_path_new_from_indicesv(p_indices: [*]c_int, p_length: usize) *gtk.TreePath;
    pub const newFromIndicesv = gtk_tree_path_new_from_indicesv;

    /// Creates a new `gtk.TreePath`-struct initialized to `path`.
    ///
    /// `path` is expected to be a colon separated list of numbers.
    /// For example, the string “10:4:0” would create a path of depth
    /// 3 pointing to the 11th child of the root node, the 5th
    /// child of that 11th child, and the 1st child of that 5th child.
    /// If an invalid path string is passed in, `NULL` is returned.
    extern fn gtk_tree_path_new_from_string(p_path: [*:0]const u8) *gtk.TreePath;
    pub const newFromString = gtk_tree_path_new_from_string;

    /// Appends a new index to a path.
    ///
    /// As a result, the depth of the path is increased.
    extern fn gtk_tree_path_append_index(p_path: *TreePath, p_index_: c_int) void;
    pub const appendIndex = gtk_tree_path_append_index;

    /// Compares two paths.
    ///
    /// If `a` appears before `b` in a tree, then -1 is returned.
    /// If `b` appears before `a`, then 1 is returned.
    /// If the two nodes are equal, then 0 is returned.
    extern fn gtk_tree_path_compare(p_a: *const TreePath, p_b: *const gtk.TreePath) c_int;
    pub const compare = gtk_tree_path_compare;

    /// Creates a new `gtk.TreePath`-struct as a copy of `path`.
    extern fn gtk_tree_path_copy(p_path: *const TreePath) *gtk.TreePath;
    pub const copy = gtk_tree_path_copy;

    /// Moves `path` to point to the first child of the current path.
    extern fn gtk_tree_path_down(p_path: *TreePath) void;
    pub const down = gtk_tree_path_down;

    /// Frees `path`. If `path` is `NULL`, it simply returns.
    extern fn gtk_tree_path_free(p_path: ?*TreePath) void;
    pub const free = gtk_tree_path_free;

    /// Returns the current depth of `path`.
    extern fn gtk_tree_path_get_depth(p_path: *TreePath) c_int;
    pub const getDepth = gtk_tree_path_get_depth;

    /// Returns the current indices of `path`.
    ///
    /// This is an array of integers, each representing a node in a tree.
    /// This value should not be freed.
    ///
    /// The length of the array can be obtained with `gtk.TreePath.getDepth`.
    extern fn gtk_tree_path_get_indices(p_path: *TreePath) *c_int;
    pub const getIndices = gtk_tree_path_get_indices;

    /// Returns the current indices of `path`.
    ///
    /// This is an array of integers, each representing a node in a tree.
    /// It also returns the number of elements in the array.
    /// The array should not be freed.
    extern fn gtk_tree_path_get_indices_with_depth(p_path: *TreePath, p_depth: ?*c_int) [*]c_int;
    pub const getIndicesWithDepth = gtk_tree_path_get_indices_with_depth;

    /// Returns `TRUE` if `descendant` is a descendant of `path`.
    extern fn gtk_tree_path_is_ancestor(p_path: *TreePath, p_descendant: *gtk.TreePath) c_int;
    pub const isAncestor = gtk_tree_path_is_ancestor;

    /// Returns `TRUE` if `path` is a descendant of `ancestor`.
    extern fn gtk_tree_path_is_descendant(p_path: *TreePath, p_ancestor: *gtk.TreePath) c_int;
    pub const isDescendant = gtk_tree_path_is_descendant;

    /// Moves the `path` to point to the next node at the current depth.
    extern fn gtk_tree_path_next(p_path: *TreePath) void;
    pub const next = gtk_tree_path_next;

    /// Prepends a new index to a path.
    ///
    /// As a result, the depth of the path is increased.
    extern fn gtk_tree_path_prepend_index(p_path: *TreePath, p_index_: c_int) void;
    pub const prependIndex = gtk_tree_path_prepend_index;

    /// Moves the `path` to point to the previous node at the
    /// current depth, if it exists.
    extern fn gtk_tree_path_prev(p_path: *TreePath) c_int;
    pub const prev = gtk_tree_path_prev;

    /// Generates a string representation of the path.
    ///
    /// This string is a “:” separated list of numbers.
    /// For example, “4:10:0:3” would be an acceptable
    /// return value for this string.
    extern fn gtk_tree_path_to_string(p_path: *TreePath) [*:0]u8;
    pub const toString = gtk_tree_path_to_string;

    /// Moves the `path` to point to its parent node, if it has a parent.
    extern fn gtk_tree_path_up(p_path: *TreePath) c_int;
    pub const up = gtk_tree_path_up;

    extern fn gtk_tree_path_get_type() usize;
    pub const getGObjectType = gtk_tree_path_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A GtkTreeRowReference tracks model changes so that it always refers to the
/// same row (a `gtk.TreePath` refers to a position, not a fixed row). Create a
/// new GtkTreeRowReference with `gtk.TreeRowReference.new`.
pub const TreeRowReference = opaque {
    /// Lets a set of row reference created by
    /// `gtk.TreeRowReference.newProxy` know that the
    /// model emitted the `gtk.TreeModel.signals.row`-deleted signal.
    extern fn gtk_tree_row_reference_deleted(p_proxy: *gobject.Object, p_path: *gtk.TreePath) void;
    pub const deleted = gtk_tree_row_reference_deleted;

    /// Lets a set of row reference created by
    /// `gtk.TreeRowReference.newProxy` know that the
    /// model emitted the `gtk.TreeModel.signals.row`-inserted signal.
    extern fn gtk_tree_row_reference_inserted(p_proxy: *gobject.Object, p_path: *gtk.TreePath) void;
    pub const inserted = gtk_tree_row_reference_inserted;

    /// Lets a set of row reference created by
    /// `gtk.TreeRowReference.newProxy` know that the
    /// model emitted the `gtk.TreeModel.signals.rows`-reordered signal.
    extern fn gtk_tree_row_reference_reordered(p_proxy: *gobject.Object, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter, p_new_order: [*]c_int) void;
    pub const reordered = gtk_tree_row_reference_reordered;

    /// Creates a row reference based on `path`.
    ///
    /// This reference will keep pointing to the node pointed to
    /// by `path`, so long as it exists. Any changes that occur on `model` are
    /// propagated, and the path is updated appropriately. If
    /// `path` isn’t a valid path in `model`, then `NULL` is returned.
    extern fn gtk_tree_row_reference_new(p_model: *gtk.TreeModel, p_path: *gtk.TreePath) *gtk.TreeRowReference;
    pub const new = gtk_tree_row_reference_new;

    /// You do not need to use this function.
    ///
    /// Creates a row reference based on `path`.
    ///
    /// This reference will keep pointing to the node pointed to
    /// by `path`, so long as it exists. If `path` isn’t a valid
    /// path in `model`, then `NULL` is returned. However, unlike
    /// references created with `gtk.TreeRowReference.new`, it
    /// does not listen to the model for changes. The creator of
    /// the row reference must do this explicitly using
    /// `gtk.treeRowReferenceInserted`, `gtk.treeRowReferenceDeleted`,
    /// `gtk.treeRowReferenceReordered`.
    ///
    /// These functions must be called exactly once per proxy when the
    /// corresponding signal on the model is emitted. This single call
    /// updates all row references for that proxy. Since built-in GTK+
    /// objects like `gtk.TreeView` already use this mechanism internally,
    /// using them as the proxy object will produce unpredictable results.
    /// Further more, passing the same object as `model` and `proxy`
    /// doesn’t work for reasons of internal implementation.
    ///
    /// This type of row reference is primarily meant by structures that
    /// need to carefully monitor exactly when a row reference updates
    /// itself, and is not generally needed by most applications.
    extern fn gtk_tree_row_reference_new_proxy(p_proxy: *gobject.Object, p_model: *gtk.TreeModel, p_path: *gtk.TreePath) *gtk.TreeRowReference;
    pub const newProxy = gtk_tree_row_reference_new_proxy;

    /// Copies a `gtk.TreeRowReference`.
    extern fn gtk_tree_row_reference_copy(p_reference: *TreeRowReference) *gtk.TreeRowReference;
    pub const copy = gtk_tree_row_reference_copy;

    /// Free’s `reference`. `reference` may be `NULL`
    extern fn gtk_tree_row_reference_free(p_reference: ?*TreeRowReference) void;
    pub const free = gtk_tree_row_reference_free;

    /// Returns the model that the row reference is monitoring.
    extern fn gtk_tree_row_reference_get_model(p_reference: *TreeRowReference) *gtk.TreeModel;
    pub const getModel = gtk_tree_row_reference_get_model;

    /// Returns a path that the row reference currently points to,
    /// or `NULL` if the path pointed to is no longer valid.
    extern fn gtk_tree_row_reference_get_path(p_reference: *TreeRowReference) ?*gtk.TreePath;
    pub const getPath = gtk_tree_row_reference_get_path;

    /// Returns `TRUE` if the `reference` is non-`NULL` and refers to
    /// a current valid path.
    extern fn gtk_tree_row_reference_valid(p_reference: ?*TreeRowReference) c_int;
    pub const valid = gtk_tree_row_reference_valid;

    extern fn gtk_tree_row_reference_get_type() usize;
    pub const getGObjectType = gtk_tree_row_reference_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeSelectionClass = extern struct {
    pub const Instance = gtk.TreeSelection;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    /// Signal emitted whenever the selection has (possibly) changed.
    f_changed: ?*const fn (p_selection: *gtk.TreeSelection) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *TreeSelectionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeSelectionPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeSortableIface = extern struct {
    pub const Instance = gtk.TreeSortable;

    f_g_iface: gobject.TypeInterface,
    /// Signal emitted when the sort column or sort
    ///    order of sortable is changed.
    f_sort_column_changed: ?*const fn (p_sortable: *gtk.TreeSortable) callconv(.c) void,
    /// Fills in sort_column_id and order with the
    ///    current sort column and the order.
    f_get_sort_column_id: ?*const fn (p_sortable: *gtk.TreeSortable, p_sort_column_id: *c_int, p_order: *gtk.SortType) callconv(.c) c_int,
    /// Sets the current sort column to be
    ///    sort_column_id.
    f_set_sort_column_id: ?*const fn (p_sortable: *gtk.TreeSortable, p_sort_column_id: c_int, p_order: gtk.SortType) callconv(.c) void,
    /// Sets the comparison function used when sorting to
    ///    be sort_func.
    f_set_sort_func: ?*const fn (p_sortable: *gtk.TreeSortable, p_sort_column_id: c_int, p_sort_func: gtk.TreeIterCompareFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) callconv(.c) void,
    /// Sets the default comparison function used
    ///    when sorting to be sort_func.
    f_set_default_sort_func: ?*const fn (p_sortable: *gtk.TreeSortable, p_sort_func: gtk.TreeIterCompareFunc, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) callconv(.c) void,
    /// `TRUE` if the model has a default sort
    /// function.
    f_has_default_sort_func: ?*const fn (p_sortable: *gtk.TreeSortable) callconv(.c) c_int,

    pub fn as(p_instance: *TreeSortableIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeStoreClass = extern struct {
    pub const Instance = gtk.TreeStore;

    f_parent_class: gobject.ObjectClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *TreeStoreClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeStorePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeViewAccessibleClass = extern struct {
    pub const Instance = gtk.TreeViewAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *TreeViewAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeViewAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeViewClass = extern struct {
    pub const Instance = gtk.TreeView;

    f_parent_class: gtk.ContainerClass,
    f_row_activated: ?*const fn (p_tree_view: *gtk.TreeView, p_path: *gtk.TreePath, p_column: *gtk.TreeViewColumn) callconv(.c) void,
    f_test_expand_row: ?*const fn (p_tree_view: *gtk.TreeView, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) callconv(.c) c_int,
    f_test_collapse_row: ?*const fn (p_tree_view: *gtk.TreeView, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) callconv(.c) c_int,
    f_row_expanded: ?*const fn (p_tree_view: *gtk.TreeView, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) callconv(.c) void,
    f_row_collapsed: ?*const fn (p_tree_view: *gtk.TreeView, p_iter: *gtk.TreeIter, p_path: *gtk.TreePath) callconv(.c) void,
    f_columns_changed: ?*const fn (p_tree_view: *gtk.TreeView) callconv(.c) void,
    f_cursor_changed: ?*const fn (p_tree_view: *gtk.TreeView) callconv(.c) void,
    f_move_cursor: ?*const fn (p_tree_view: *gtk.TreeView, p_step: gtk.MovementStep, p_count: c_int) callconv(.c) c_int,
    f_select_all: ?*const fn (p_tree_view: *gtk.TreeView) callconv(.c) c_int,
    f_unselect_all: ?*const fn (p_tree_view: *gtk.TreeView) callconv(.c) c_int,
    f_select_cursor_row: ?*const fn (p_tree_view: *gtk.TreeView, p_start_editing: c_int) callconv(.c) c_int,
    f_toggle_cursor_row: ?*const fn (p_tree_view: *gtk.TreeView) callconv(.c) c_int,
    f_expand_collapse_cursor_row: ?*const fn (p_tree_view: *gtk.TreeView, p_logical: c_int, p_expand: c_int, p_open_all: c_int) callconv(.c) c_int,
    f_select_cursor_parent: ?*const fn (p_tree_view: *gtk.TreeView) callconv(.c) c_int,
    f_start_interactive_search: ?*const fn (p_tree_view: *gtk.TreeView) callconv(.c) c_int,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,
    f__gtk_reserved5: ?*const fn () callconv(.c) void,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,
    f__gtk_reserved7: ?*const fn () callconv(.c) void,
    f__gtk_reserved8: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *TreeViewClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeViewColumnClass = extern struct {
    pub const Instance = gtk.TreeViewColumn;

    f_parent_class: gobject.InitiallyUnownedClass,
    f_clicked: ?*const fn (p_tree_column: *gtk.TreeViewColumn) callconv(.c) void,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *TreeViewColumnClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeViewColumnPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TreeViewPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UIManagerClass = extern struct {
    pub const Instance = gtk.UIManager;

    f_parent_class: gobject.ObjectClass,
    f_add_widget: ?*const fn (p_manager: *gtk.UIManager, p_widget: *gtk.Widget) callconv(.c) void,
    f_actions_changed: ?*const fn (p_manager: *gtk.UIManager) callconv(.c) void,
    f_connect_proxy: ?*const fn (p_manager: *gtk.UIManager, p_action: *gtk.Action, p_proxy: *gtk.Widget) callconv(.c) void,
    f_disconnect_proxy: ?*const fn (p_manager: *gtk.UIManager, p_action: *gtk.Action, p_proxy: *gtk.Widget) callconv(.c) void,
    f_pre_activate: ?*const fn (p_manager: *gtk.UIManager, p_action: *gtk.Action) callconv(.c) void,
    f_post_activate: ?*const fn (p_manager: *gtk.UIManager, p_action: *gtk.Action) callconv(.c) void,
    f_get_widget: ?*const fn (p_manager: *gtk.UIManager, p_path: [*:0]const u8) callconv(.c) *gtk.Widget,
    f_get_action: ?*const fn (p_manager: *gtk.UIManager, p_path: [*:0]const u8) callconv(.c) *gtk.Action,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *UIManagerClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UIManagerPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const VBoxClass = extern struct {
    pub const Instance = gtk.VBox;

    f_parent_class: gtk.BoxClass,

    pub fn as(p_instance: *VBoxClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const VButtonBoxClass = extern struct {
    pub const Instance = gtk.VButtonBox;

    f_parent_class: gtk.ButtonBoxClass,

    pub fn as(p_instance: *VButtonBoxClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const VPanedClass = extern struct {
    pub const Instance = gtk.VPaned;

    f_parent_class: gtk.PanedClass,

    pub fn as(p_instance: *VPanedClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const VScaleClass = extern struct {
    pub const Instance = gtk.VScale;

    f_parent_class: gtk.ScaleClass,

    pub fn as(p_instance: *VScaleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const VScrollbarClass = extern struct {
    pub const Instance = gtk.VScrollbar;

    f_parent_class: gtk.ScrollbarClass,

    pub fn as(p_instance: *VScrollbarClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const VSeparatorClass = extern struct {
    pub const Instance = gtk.VSeparator;

    f_parent_class: gtk.SeparatorClass,

    pub fn as(p_instance: *VSeparatorClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ViewportClass = extern struct {
    pub const Instance = gtk.Viewport;

    /// The parent class.
    f_parent_class: gtk.BinClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ViewportClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ViewportPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const VolumeButtonClass = extern struct {
    pub const Instance = gtk.VolumeButton;

    f_parent_class: gtk.ScaleButtonClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *VolumeButtonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const WidgetAccessibleClass = extern struct {
    pub const Instance = gtk.WidgetAccessible;

    f_parent_class: gtk.AccessibleClass,
    f_notify_gtk: ?*const fn (p_object: *gobject.Object, p_pspec: *gobject.ParamSpec) callconv(.c) void,

    pub fn as(p_instance: *WidgetAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const WidgetAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const WidgetClass = extern struct {
    pub const Instance = gtk.Widget;

    /// The object class structure needs to be the first
    ///   element in the widget class structure in order for the class mechanism
    ///   to work correctly. This allows a GtkWidgetClass pointer to be cast to
    ///   a GObjectClass pointer.
    f_parent_class: gobject.InitiallyUnownedClass,
    /// The signal to emit when a widget of this class is
    ///   activated, `gtk.Widget.activate` handles the emission.
    ///   Implementation of this signal is optional.
    f_activate_signal: c_uint,
    /// Seldomly overidden.
    f_dispatch_child_properties_changed: ?*const fn (p_widget: *gtk.Widget, p_n_pspecs: c_uint, p_pspecs: **gobject.ParamSpec) callconv(.c) void,
    /// Signals that all holders of a reference to the widget
    ///   should release the reference that they hold.
    f_destroy: ?*const fn (p_widget: *gtk.Widget) callconv(.c) void,
    /// Signal emitted when widget is shown
    f_show: ?*const fn (p_widget: *gtk.Widget) callconv(.c) void,
    /// Recursively shows a widget, and any child widgets (if the widget is
    /// a container).
    f_show_all: ?*const fn (p_widget: *gtk.Widget) callconv(.c) void,
    /// Signal emitted when widget is hidden.
    f_hide: ?*const fn (p_widget: *gtk.Widget) callconv(.c) void,
    /// Signal emitted when widget is going to be mapped, that is
    ///   when the widget is visible (which is controlled with
    ///   `gtk.Widget.setVisible`) and all its parents up to the toplevel
    ///   widget are also visible.
    f_map: ?*const fn (p_widget: *gtk.Widget) callconv(.c) void,
    /// Signal emitted when widget is going to be unmapped, which
    ///   means that either it or any of its parents up to the toplevel
    ///   widget have been set as hidden.
    f_unmap: ?*const fn (p_widget: *gtk.Widget) callconv(.c) void,
    /// Signal emitted when widget is associated with a
    ///   `gdk.Window`, which means that `gtk.Widget.realize` has been called or
    ///   the widget has been mapped (that is, it is going to be drawn).
    f_realize: ?*const fn (p_widget: *gtk.Widget) callconv(.c) void,
    /// Signal emitted when the GdkWindow associated with
    ///   widget is destroyed, which means that `gtk.Widget.unrealize` has
    ///   been called or the widget has been unmapped (that is, it is going
    ///   to be hidden).
    f_unrealize: ?*const fn (p_widget: *gtk.Widget) callconv(.c) void,
    /// Signal emitted to get the widget allocation.
    f_size_allocate: ?*const fn (p_widget: *gtk.Widget, p_allocation: *gtk.Allocation) callconv(.c) void,
    /// Signal emitted when the widget state
    ///   changes. Deprecated: 3.0
    f_state_changed: ?*const fn (p_widget: *gtk.Widget, p_previous_state: gtk.StateType) callconv(.c) void,
    /// Signal emitted when the widget state changes,
    ///   see `gtk.Widget.getStateFlags`.
    f_state_flags_changed: ?*const fn (p_widget: *gtk.Widget, p_previous_state_flags: gtk.StateFlags) callconv(.c) void,
    /// Signal emitted when a new parent has been set on a
    ///   widget.
    f_parent_set: ?*const fn (p_widget: *gtk.Widget, p_previous_parent: *gtk.Widget) callconv(.c) void,
    /// Signal emitted when the anchored state of a
    ///   widget changes.
    f_hierarchy_changed: ?*const fn (p_widget: *gtk.Widget, p_previous_toplevel: *gtk.Widget) callconv(.c) void,
    /// Signal emitted when a new style has been set on a
    /// widget. Deprecated: 3.0
    f_style_set: ?*const fn (p_widget: *gtk.Widget, p_previous_style: *gtk.Style) callconv(.c) void,
    /// Signal emitted when the text direction of a
    ///   widget changes.
    f_direction_changed: ?*const fn (p_widget: *gtk.Widget, p_previous_direction: gtk.TextDirection) callconv(.c) void,
    /// Signal emitted when a widget becomes shadowed by a
    ///   GTK+ grab (not a pointer or keyboard grab) on another widget, or
    ///   when it becomes unshadowed due to a grab being removed.
    f_grab_notify: ?*const fn (p_widget: *gtk.Widget, p_was_grabbed: c_int) callconv(.c) void,
    /// Signal emitted for each child property that has
    ///   changed on an object.
    f_child_notify: ?*const fn (p_widget: *gtk.Widget, p_child_property: *gobject.ParamSpec) callconv(.c) void,
    /// Signal emitted when a widget is supposed to render itself.
    f_draw: ?*const fn (p_widget: *gtk.Widget, p_cr: *cairo.Context) callconv(.c) c_int,
    /// This allows a widget to tell its parent container whether
    ///   it prefers to be allocated in `GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH` or
    ///   `GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT` mode.
    ///   `GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH` means the widget prefers to have
    ///   `gtk.WidgetClass.virtual_methods.get_preferred_width` called and then
    ///   `gtk.WidgetClass.virtual_methods.get_preferred_height_for_width`.
    ///   `GTK_SIZE_REQUEST_CONSTANT_SIZE` disables any height-for-width or
    ///   width-for-height geometry management for a said widget and is the
    ///   default return.
    ///   It’s important to note (as described below) that any widget
    ///   which trades height-for-width or width-for-height must respond properly
    ///   to both of the virtual methods `gtk.WidgetClass.virtual_methods.get_preferred_height_for_width`
    ///   and `gtk.WidgetClass.virtual_methods.get_preferred_width_for_height` since it might be
    ///   queried in either `gtk.SizeRequestMode` by its parent container.
    f_get_request_mode: ?*const fn (p_widget: *gtk.Widget) callconv(.c) gtk.SizeRequestMode,
    /// This is called by containers to obtain the minimum
    ///   and natural height of a widget. A widget that does not actually trade
    ///   any height for width or width for height only has to implement these
    ///   two virtual methods (`gtk.WidgetClass.virtual_methods.get_preferred_width` and
    ///   `gtk.WidgetClass.virtual_methods.get_preferred_height`).
    f_get_preferred_height: ?*const fn (p_widget: *gtk.Widget, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) callconv(.c) void,
    /// This is analogous to
    ///   `gtk.WidgetClass.virtual_methods.get_preferred_height_for_width` except that it
    ///   operates in the oposite orientation. It’s rare that a widget actually
    ///   does `GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT` requests but this can happen
    ///   when, for example, a widget or container gets additional columns to
    ///   compensate for a smaller allocated height.
    f_get_preferred_width_for_height: ?*const fn (p_widget: *gtk.Widget, p_height: c_int, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) callconv(.c) void,
    /// This is called by containers to obtain the minimum
    ///   and natural width of a widget. A widget will never be allocated a width
    ///   less than its minimum and will only ever be allocated a width greater
    ///   than the natural width once all of the said widget’s siblings have
    ///   received their natural widths.
    ///   Furthermore, a widget will only ever be allocated a width greater than
    ///   its natural width if it was configured to receive extra expand space
    ///   from its parent container.
    f_get_preferred_width: ?*const fn (p_widget: *gtk.Widget, p_minimum_width: ?*c_int, p_natural_width: ?*c_int) callconv(.c) void,
    /// This is similar to
    ///   `gtk.WidgetClass.virtual_methods.get_preferred_height` except that it is passed a
    ///   contextual width to request height for. By implementing this virtual
    ///   method it is possible for a `gtk.Label` to tell its parent how much height
    ///   would be required if the label were to be allocated a said width.
    f_get_preferred_height_for_width: ?*const fn (p_widget: *gtk.Widget, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int) callconv(.c) void,
    /// Activates the `widget` if `group_cycling` is
    ///   `FALSE`, and just grabs the focus if `group_cycling` is `TRUE`.
    f_mnemonic_activate: ?*const fn (p_widget: *gtk.Widget, p_group_cycling: c_int) callconv(.c) c_int,
    /// Causes `widget` to have the keyboard focus for the
    ///   `gtk.Window` it’s inside.
    f_grab_focus: ?*const fn (p_widget: *gtk.Widget) callconv(.c) void,
    f_focus: ?*const fn (p_widget: *gtk.Widget, p_direction: gtk.DirectionType) callconv(.c) c_int,
    /// Signal emitted when a change of focus is requested
    f_move_focus: ?*const fn (p_widget: *gtk.Widget, p_direction: gtk.DirectionType) callconv(.c) void,
    /// Signal emitted if keyboard navigation fails.
    f_keynav_failed: ?*const fn (p_widget: *gtk.Widget, p_direction: gtk.DirectionType) callconv(.c) c_int,
    /// The GTK+ main loop will emit three signals for each GDK
    ///   event delivered to a widget: one generic ::event signal, another,
    ///   more specific, signal that matches the type of event delivered
    ///   (e.g. "key-press-event") and finally a generic "event-after"
    ///   signal.
    f_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.Event) callconv(.c) c_int,
    /// Signal will be emitted when a button
    ///   (typically from a mouse) is pressed.
    f_button_press_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventButton) callconv(.c) c_int,
    /// Signal will be emitted when a button
    ///   (typically from a mouse) is released.
    f_button_release_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventButton) callconv(.c) c_int,
    /// Signal emitted when a button in the 4 to 7 range is
    ///   pressed.
    f_scroll_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventScroll) callconv(.c) c_int,
    /// Signal emitted when the pointer moves over
    ///   the widget’s `gdk.Window`.
    f_motion_notify_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventMotion) callconv(.c) c_int,
    /// Signal emitted if a user requests that a toplevel
    ///   window is closed.
    f_delete_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventAny) callconv(.c) c_int,
    /// Signal is emitted when a `gdk.Window` is destroyed.
    f_destroy_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventAny) callconv(.c) c_int,
    /// Signal emitted when a key is pressed.
    f_key_press_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventKey) callconv(.c) c_int,
    /// Signal is emitted when a key is released.
    f_key_release_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventKey) callconv(.c) c_int,
    /// Signal event will be emitted when the pointer
    ///   enters the widget’s window.
    f_enter_notify_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventCrossing) callconv(.c) c_int,
    /// Will be emitted when the pointer leaves the
    ///   widget’s window.
    f_leave_notify_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventCrossing) callconv(.c) c_int,
    /// Signal will be emitted when the size, position or
    ///   stacking of the widget’s window has changed.
    f_configure_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventConfigure) callconv(.c) c_int,
    /// Signal emitted when the keyboard focus enters the
    /// widget’s window.
    f_focus_in_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventFocus) callconv(.c) c_int,
    /// Signal emitted when the keyboard focus leaves the
    /// widget’s window.
    f_focus_out_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventFocus) callconv(.c) c_int,
    /// Signal emitted when the widget’s window is mapped.
    f_map_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventAny) callconv(.c) c_int,
    /// Signal will be emitted when the widget’s window is
    ///   unmapped.
    f_unmap_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventAny) callconv(.c) c_int,
    /// Signal will be emitted when a property on
    ///   the widget’s window has been changed or deleted.
    f_property_notify_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventProperty) callconv(.c) c_int,
    /// Signal will be emitted when the the
    ///   widget’s window has lost ownership of a selection.
    f_selection_clear_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventSelection) callconv(.c) c_int,
    /// Signal will be emitted when another
    ///   client requests ownership of the selection owned by the widget's
    ///   window.
    f_selection_request_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventSelection) callconv(.c) c_int,
    f_selection_notify_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventSelection) callconv(.c) c_int,
    f_proximity_in_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventProximity) callconv(.c) c_int,
    f_proximity_out_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventProximity) callconv(.c) c_int,
    /// Signal emitted when the widget’s window is
    ///   obscured or unobscured.
    f_visibility_notify_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventVisibility) callconv(.c) c_int,
    /// Signal emitted when the state of the toplevel
    ///   window associated to the widget changes.
    f_window_state_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventWindowState) callconv(.c) c_int,
    /// Signal emitted when a redirected window belonging to
    ///   widget gets drawn into.
    f_damage_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventExpose) callconv(.c) c_int,
    /// Signal emitted when a pointer or keyboard grab
    ///   on a window belonging to widget gets broken.
    f_grab_broken_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventGrabBroken) callconv(.c) c_int,
    f_selection_get: ?*const fn (p_widget: *gtk.Widget, p_selection_data: *gtk.SelectionData, p_info: c_uint, p_time_: c_uint) callconv(.c) void,
    f_selection_received: ?*const fn (p_widget: *gtk.Widget, p_selection_data: *gtk.SelectionData, p_time_: c_uint) callconv(.c) void,
    /// Signal emitted on the drag source when a drag is
    ///   started.
    f_drag_begin: ?*const fn (p_widget: *gtk.Widget, p_context: *gdk.DragContext) callconv(.c) void,
    /// Signal emitted on the drag source when a drag is
    ///   finished.
    f_drag_end: ?*const fn (p_widget: *gtk.Widget, p_context: *gdk.DragContext) callconv(.c) void,
    /// Signal emitted on the drag source when the drop
    ///   site requests the data which is dragged.
    f_drag_data_get: ?*const fn (p_widget: *gtk.Widget, p_context: *gdk.DragContext, p_selection_data: *gtk.SelectionData, p_info: c_uint, p_time_: c_uint) callconv(.c) void,
    /// Signal emitted on the drag source when a drag
    ///   with the action `GDK_ACTION_MOVE` is successfully completed.
    f_drag_data_delete: ?*const fn (p_widget: *gtk.Widget, p_context: *gdk.DragContext) callconv(.c) void,
    /// Signal emitted on the drop site when the cursor leaves
    ///   the widget.
    f_drag_leave: ?*const fn (p_widget: *gtk.Widget, p_context: *gdk.DragContext, p_time_: c_uint) callconv(.c) void,
    /// signal emitted on the drop site when the user moves
    ///   the cursor over the widget during a drag.
    f_drag_motion: ?*const fn (p_widget: *gtk.Widget, p_context: *gdk.DragContext, p_x: c_int, p_y: c_int, p_time_: c_uint) callconv(.c) c_int,
    /// Signal emitted on the drop site when the user drops the
    ///   data onto the widget.
    f_drag_drop: ?*const fn (p_widget: *gtk.Widget, p_context: *gdk.DragContext, p_x: c_int, p_y: c_int, p_time_: c_uint) callconv(.c) c_int,
    /// Signal emitted on the drop site when the
    ///   dragged data has been received.
    f_drag_data_received: ?*const fn (p_widget: *gtk.Widget, p_context: *gdk.DragContext, p_x: c_int, p_y: c_int, p_selection_data: *gtk.SelectionData, p_info: c_uint, p_time_: c_uint) callconv(.c) void,
    /// Signal emitted on the drag source when a drag has
    ///   failed.
    f_drag_failed: ?*const fn (p_widget: *gtk.Widget, p_context: *gdk.DragContext, p_result: gtk.DragResult) callconv(.c) c_int,
    /// Signal emitted whenever a widget should pop up a
    ///   context menu.
    f_popup_menu: ?*const fn (p_widget: *gtk.Widget) callconv(.c) c_int,
    f_show_help: ?*const fn (p_widget: *gtk.Widget, p_help_type: gtk.WidgetHelpType) callconv(.c) c_int,
    /// Returns the accessible object that describes the
    ///   widget to an assistive technology.
    f_get_accessible: ?*const fn (p_widget: *gtk.Widget) callconv(.c) *atk.Object,
    /// Signal emitted when the screen of a widget has
    ///   changed.
    f_screen_changed: ?*const fn (p_widget: *gtk.Widget, p_previous_screen: *gdk.Screen) callconv(.c) void,
    /// Signal allows applications and derived widgets
    ///   to override the default GtkWidget handling for determining whether
    ///   an accelerator can be activated.
    f_can_activate_accel: ?*const fn (p_widget: *gtk.Widget, p_signal_id: c_uint) callconv(.c) c_int,
    /// Signal emitted when the composited status of
    ///   widgets screen changes. See `gdk.Screen.isComposited`.
    f_composited_changed: ?*const fn (p_widget: *gtk.Widget) callconv(.c) void,
    /// Signal emitted when “has-tooltip” is `TRUE` and the
    ///   hover timeout has expired with the cursor hovering “above”
    ///   widget; or emitted when widget got focus in keyboard mode.
    f_query_tooltip: ?*const fn (p_widget: *gtk.Widget, p_x: c_int, p_y: c_int, p_keyboard_tooltip: c_int, p_tooltip: *gtk.Tooltip) callconv(.c) c_int,
    /// Computes whether a container should give this
    ///   widget extra space when possible.
    f_compute_expand: ?*const fn (p_widget: *gtk.Widget, p_hexpand_p: *c_int, p_vexpand_p: *c_int) callconv(.c) void,
    /// Convert an initial size request from a widget's
    ///   `gtk.SizeRequestMode` virtual method implementations into a size request to
    ///   be used by parent containers in laying out the widget.
    ///   adjust_size_request adjusts from a child widget's
    ///   original request to what a parent container should
    ///   use for layout. The `for_size` argument will be -1 if the request should
    ///   not be for a particular size in the opposing orientation, i.e. if the
    ///   request is not height-for-width or width-for-height. If `for_size` is
    ///   greater than -1, it is the proposed allocation in the opposing
    ///   orientation that we need the request for. Implementations of
    ///   adjust_size_request should chain up to the default implementation,
    ///   which applies `gtk.Widget`’s margin properties and imposes any values
    ///   from `gtk.Widget.setSizeRequest`. Chaining up should be last,
    ///   after your subclass adjusts the request, so
    ///   `gtk.Widget` can apply constraints and add the margin properly.
    f_adjust_size_request: ?*const fn (p_widget: *gtk.Widget, p_orientation: gtk.Orientation, p_minimum_size: *c_int, p_natural_size: *c_int) callconv(.c) void,
    /// Convert an initial size allocation assigned
    ///   by a `gtk.Container` using `gtk.Widget.sizeAllocate`, into an actual
    ///   size allocation to be used by the widget. adjust_size_allocation
    ///   adjusts to a child widget’s actual allocation
    ///   from what a parent container computed for the
    ///   child. The adjusted allocation must be entirely within the original
    ///   allocation. In any custom implementation, chain up to the default
    ///   `gtk.Widget` implementation of this method, which applies the margin
    ///   and alignment properties of `gtk.Widget`. Chain up
    ///   before performing your own adjustments so your
    ///   own adjustments remove more allocation after the `gtk.Widget` base
    ///   class has already removed margin and alignment. The natural size
    ///   passed in should be adjusted in the same way as the allocated size,
    ///   which allows adjustments to perform alignments or other changes
    ///   based on natural size.
    f_adjust_size_allocation: ?*const fn (p_widget: *gtk.Widget, p_orientation: gtk.Orientation, p_minimum_size: *c_int, p_natural_size: *c_int, p_allocated_pos: *c_int, p_allocated_size: *c_int) callconv(.c) void,
    /// Signal emitted when the GtkStyleContext of a widget
    ///   is changed.
    f_style_updated: ?*const fn (p_widget: *gtk.Widget) callconv(.c) void,
    /// Signal emitted when a touch event happens
    f_touch_event: ?*const fn (p_widget: *gtk.Widget, p_event: *gdk.EventTouch) callconv(.c) c_int,
    f_get_preferred_height_and_baseline_for_width: ?*const fn (p_widget: *gtk.Widget, p_width: c_int, p_minimum_height: ?*c_int, p_natural_height: ?*c_int, p_minimum_baseline: ?*c_int, p_natural_baseline: ?*c_int) callconv(.c) void,
    f_adjust_baseline_request: ?*const fn (p_widget: *gtk.Widget, p_minimum_baseline: *c_int, p_natural_baseline: *c_int) callconv(.c) void,
    f_adjust_baseline_allocation: ?*const fn (p_widget: *gtk.Widget, p_baseline: *c_int) callconv(.c) void,
    /// Invalidates the area of widget defined by
    ///   region by calling `gdk.Window.invalidateRegion` on the widget's
    ///   window and all its child windows.
    f_queue_draw_region: ?*const fn (p_widget: *gtk.Widget, p_region: *const cairo.Region) callconv(.c) void,
    f_priv: ?*gtk.WidgetClassPrivate,
    f__gtk_reserved6: ?*const fn () callconv(.c) void,
    f__gtk_reserved7: ?*const fn () callconv(.c) void,

    /// Declares a `callback_symbol` to handle `callback_name` from the template XML
    /// defined for `widget_type`. See `gtk.Builder.addCallbackSymbol`.
    ///
    /// Note that this must be called from a composite widget classes class
    /// initializer after calling `gtk.WidgetClass.setTemplate`.
    extern fn gtk_widget_class_bind_template_callback_full(p_widget_class: *WidgetClass, p_callback_name: [*:0]const u8, p_callback_symbol: gobject.Callback) void;
    pub const bindTemplateCallbackFull = gtk_widget_class_bind_template_callback_full;

    /// Automatically assign an object declared in the class template XML to be set to a location
    /// on a freshly built instance’s private data, or alternatively accessible via `gtk.Widget.getTemplateChild`.
    ///
    /// The struct can point either into the public instance, then you should use G_STRUCT_OFFSET(WidgetType, member)
    /// for `struct_offset`,  or in the private struct, then you should use G_PRIVATE_OFFSET(WidgetType, member).
    ///
    /// An explicit strong reference will be held automatically for the duration of your
    /// instance’s life cycle, it will be released automatically when `gobject.ObjectClass.virtual_methods.dispose` runs
    /// on your instance and if a `struct_offset` that is != 0 is specified, then the automatic location
    /// in your instance public or private data will be set to `NULL`. You can however access an automated child
    /// pointer the first time your classes `gobject.ObjectClass.virtual_methods.dispose` runs, or alternatively in
    /// `gtk.WidgetClass.virtual_methods.destroy`.
    ///
    /// If `internal_child` is specified, `gtk.BuildableIface.virtual_methods.get_internal_child` will be automatically
    /// implemented by the `gtk.Widget` class so there is no need to implement it manually.
    ///
    /// The wrapper macros `gtk_widget_class_bind_template_child`, `gtk_widget_class_bind_template_child_internal`,
    /// `gtk_widget_class_bind_template_child_private` and `gtk_widget_class_bind_template_child_internal_private`
    /// might be more convenient to use.
    ///
    /// Note that this must be called from a composite widget classes class
    /// initializer after calling `gtk.WidgetClass.setTemplate`.
    extern fn gtk_widget_class_bind_template_child_full(p_widget_class: *WidgetClass, p_name: [*:0]const u8, p_internal_child: c_int, p_struct_offset: isize) void;
    pub const bindTemplateChildFull = gtk_widget_class_bind_template_child_full;

    /// Finds a style property of a widget class by name.
    extern fn gtk_widget_class_find_style_property(p_klass: *WidgetClass, p_property_name: [*:0]const u8) *gobject.ParamSpec;
    pub const findStyleProperty = gtk_widget_class_find_style_property;

    /// Gets the name used by this class for matching in CSS code. See
    /// `gtk.WidgetClass.setCssName` for details.
    extern fn gtk_widget_class_get_css_name(p_widget_class: *WidgetClass) [*:0]const u8;
    pub const getCssName = gtk_widget_class_get_css_name;

    /// Installs a style property on a widget class. The parser for the
    /// style property is determined by the value type of `pspec`.
    extern fn gtk_widget_class_install_style_property(p_klass: *WidgetClass, p_pspec: *gobject.ParamSpec) void;
    pub const installStyleProperty = gtk_widget_class_install_style_property;

    /// Installs a style property on a widget class.
    extern fn gtk_widget_class_install_style_property_parser(p_klass: *WidgetClass, p_pspec: *gobject.ParamSpec, p_parser: gtk.RcPropertyParser) void;
    pub const installStylePropertyParser = gtk_widget_class_install_style_property_parser;

    /// Returns all style properties of a widget class.
    extern fn gtk_widget_class_list_style_properties(p_klass: *WidgetClass, p_n_properties: *c_uint) [*]*gobject.ParamSpec;
    pub const listStyleProperties = gtk_widget_class_list_style_properties;

    /// Sets the default `atk.Role` to be set on accessibles created for
    /// widgets of `widget_class`. Accessibles may decide to not honor this
    /// setting if their role reporting is more refined. Calls to
    /// `gtk.WidgetClass.setAccessibleType` will reset this value.
    ///
    /// In cases where you want more fine-grained control over the role of
    /// accessibles created for `widget_class`, you should provide your own
    /// accessible type and use `gtk.WidgetClass.setAccessibleType`
    /// instead.
    ///
    /// If `role` is `ATK_ROLE_INVALID`, the default role will not be changed
    /// and the accessible’s default role will be used instead.
    ///
    /// This function should only be called from class init functions of widgets.
    extern fn gtk_widget_class_set_accessible_role(p_widget_class: *WidgetClass, p_role: atk.Role) void;
    pub const setAccessibleRole = gtk_widget_class_set_accessible_role;

    /// Sets the type to be used for creating accessibles for widgets of
    /// `widget_class`. The given `type` must be a subtype of the type used for
    /// accessibles of the parent class.
    ///
    /// This function should only be called from class init functions of widgets.
    extern fn gtk_widget_class_set_accessible_type(p_widget_class: *WidgetClass, p_type: usize) void;
    pub const setAccessibleType = gtk_widget_class_set_accessible_type;

    /// For use in language bindings, this will override the default `gtk.BuilderConnectFunc` to be
    /// used when parsing GtkBuilder XML from this class’s template data.
    ///
    /// Note that this must be called from a composite widget classes class
    /// initializer after calling `gtk.WidgetClass.setTemplate`.
    extern fn gtk_widget_class_set_connect_func(p_widget_class: *WidgetClass, p_connect_func: gtk.BuilderConnectFunc, p_connect_data: ?*anyopaque, p_connect_data_destroy: ?glib.DestroyNotify) void;
    pub const setConnectFunc = gtk_widget_class_set_connect_func;

    /// Sets the name to be used for CSS matching of widgets.
    ///
    /// If this function is not called for a given class, the name
    /// of the parent class is used.
    extern fn gtk_widget_class_set_css_name(p_widget_class: *WidgetClass, p_name: [*:0]const u8) void;
    pub const setCssName = gtk_widget_class_set_css_name;

    /// This should be called at class initialization time to specify
    /// the GtkBuilder XML to be used to extend a widget.
    ///
    /// For convenience, `gtk.WidgetClass.setTemplateFromResource` is also provided.
    ///
    /// Note that any class that installs templates must call `gtk.Widget.initTemplate`
    /// in the widget’s instance initializer.
    extern fn gtk_widget_class_set_template(p_widget_class: *WidgetClass, p_template_bytes: *glib.Bytes) void;
    pub const setTemplate = gtk_widget_class_set_template;

    /// A convenience function to call `gtk.WidgetClass.setTemplate`.
    ///
    /// Note that any class that installs templates must call `gtk.Widget.initTemplate`
    /// in the widget’s instance initializer.
    extern fn gtk_widget_class_set_template_from_resource(p_widget_class: *WidgetClass, p_resource_name: [*:0]const u8) void;
    pub const setTemplateFromResource = gtk_widget_class_set_template_from_resource;

    pub fn as(p_instance: *WidgetClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const WidgetClassPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkWidgetPath is a boxed type that represents a widget hierarchy from
/// the topmost widget, typically a toplevel, to any child. This widget
/// path abstraction is used in `gtk.StyleContext` on behalf of the real
/// widget in order to query style information.
///
/// If you are using GTK+ widgets, you probably will not need to use
/// this API directly, as there is `gtk.Widget.getPath`, and the style
/// context returned by `gtk.Widget.getStyleContext` will be automatically
/// updated on widget hierarchy changes.
///
/// The widget path generation is generally simple:
///
/// ## Defining a button within a window
///
/// ```
/// {
///   GtkWidgetPath *path;
///
///   path = gtk_widget_path_new ();
///   gtk_widget_path_append_type (path, GTK_TYPE_WINDOW);
///   gtk_widget_path_append_type (path, GTK_TYPE_BUTTON);
/// }
/// ```
///
/// Although more complex information, such as widget names, or
/// different classes (property that may be used by other widget
/// types) and intermediate regions may be included:
///
/// ## Defining the first tab widget in a notebook
///
/// ```
/// {
///   GtkWidgetPath *path;
///   guint pos;
///
///   path = gtk_widget_path_new ();
///
///   pos = gtk_widget_path_append_type (path, GTK_TYPE_NOTEBOOK);
///   gtk_widget_path_iter_add_region (path, pos, "tab", GTK_REGION_EVEN | GTK_REGION_FIRST);
///
///   pos = gtk_widget_path_append_type (path, GTK_TYPE_LABEL);
///   gtk_widget_path_iter_set_name (path, pos, "first tab label");
/// }
/// ```
///
/// All this information will be used to match the style information
/// that applies to the described widget.
pub const WidgetPath = opaque {
    /// Returns an empty widget path.
    extern fn gtk_widget_path_new() *gtk.WidgetPath;
    pub const new = gtk_widget_path_new;

    /// Appends the data from `widget` to the widget hierarchy represented
    /// by `path`. This function is a shortcut for adding information from
    /// `widget` to the given `path`. This includes setting the name or
    /// adding the style classes from `widget`.
    extern fn gtk_widget_path_append_for_widget(p_path: *WidgetPath, p_widget: *gtk.Widget) c_int;
    pub const appendForWidget = gtk_widget_path_append_for_widget;

    /// Appends a widget type to the widget hierarchy represented by `path`.
    extern fn gtk_widget_path_append_type(p_path: *WidgetPath, p_type: usize) c_int;
    pub const appendType = gtk_widget_path_append_type;

    /// Appends a widget type with all its siblings to the widget hierarchy
    /// represented by `path`. Using this function instead of
    /// `gtk.WidgetPath.appendType` will allow the CSS theming to use
    /// sibling matches in selectors and apply :nth-`child` pseudo classes.
    /// In turn, it requires a lot more care in widget implementations as
    /// widgets need to make sure to call `gtk.Widget.resetStyle` on all
    /// involved widgets when the `siblings` path changes.
    extern fn gtk_widget_path_append_with_siblings(p_path: *WidgetPath, p_siblings: *gtk.WidgetPath, p_sibling_index: c_uint) c_int;
    pub const appendWithSiblings = gtk_widget_path_append_with_siblings;

    /// Returns a copy of `path`
    extern fn gtk_widget_path_copy(p_path: *const WidgetPath) *gtk.WidgetPath;
    pub const copy = gtk_widget_path_copy;

    /// Decrements the reference count on `path`, freeing the structure
    /// if the reference count reaches 0.
    extern fn gtk_widget_path_free(p_path: *WidgetPath) void;
    pub const free = gtk_widget_path_free;

    /// Returns the topmost object type, that is, the object type this path
    /// is representing.
    extern fn gtk_widget_path_get_object_type(p_path: *const WidgetPath) usize;
    pub const getObjectType = gtk_widget_path_get_object_type;

    /// Returns `TRUE` if any of the parents of the widget represented
    /// in `path` is of type `type`, or any subtype of it.
    extern fn gtk_widget_path_has_parent(p_path: *const WidgetPath, p_type: usize) c_int;
    pub const hasParent = gtk_widget_path_has_parent;

    /// Returns `TRUE` if the widget type represented by this path
    /// is `type`, or a subtype of it.
    extern fn gtk_widget_path_is_type(p_path: *const WidgetPath, p_type: usize) c_int;
    pub const isType = gtk_widget_path_is_type;

    /// Adds the class `name` to the widget at position `pos` in
    /// the hierarchy defined in `path`. See
    /// `gtk.StyleContext.addClass`.
    extern fn gtk_widget_path_iter_add_class(p_path: *WidgetPath, p_pos: c_int, p_name: [*:0]const u8) void;
    pub const iterAddClass = gtk_widget_path_iter_add_class;

    /// Adds the region `name` to the widget at position `pos` in
    /// the hierarchy defined in `path`. See
    /// `gtk.StyleContext.addRegion`.
    ///
    /// Region names must only contain lowercase letters
    /// and “-”, starting always with a lowercase letter.
    extern fn gtk_widget_path_iter_add_region(p_path: *WidgetPath, p_pos: c_int, p_name: [*:0]const u8, p_flags: gtk.RegionFlags) void;
    pub const iterAddRegion = gtk_widget_path_iter_add_region;

    /// Removes all classes from the widget at position `pos` in the
    /// hierarchy defined in `path`.
    extern fn gtk_widget_path_iter_clear_classes(p_path: *WidgetPath, p_pos: c_int) void;
    pub const iterClearClasses = gtk_widget_path_iter_clear_classes;

    /// Removes all regions from the widget at position `pos` in the
    /// hierarchy defined in `path`.
    extern fn gtk_widget_path_iter_clear_regions(p_path: *WidgetPath, p_pos: c_int) void;
    pub const iterClearRegions = gtk_widget_path_iter_clear_regions;

    /// Returns the name corresponding to the widget found at
    /// the position `pos` in the widget hierarchy defined by
    /// `path`
    extern fn gtk_widget_path_iter_get_name(p_path: *const WidgetPath, p_pos: c_int) ?[*:0]const u8;
    pub const iterGetName = gtk_widget_path_iter_get_name;

    /// Returns the object name that is at position `pos` in the widget
    /// hierarchy defined in `path`.
    extern fn gtk_widget_path_iter_get_object_name(p_path: *const WidgetPath, p_pos: c_int) ?[*:0]const u8;
    pub const iterGetObjectName = gtk_widget_path_iter_get_object_name;

    /// Returns the object `gobject.Type` that is at position `pos` in the widget
    /// hierarchy defined in `path`.
    extern fn gtk_widget_path_iter_get_object_type(p_path: *const WidgetPath, p_pos: c_int) usize;
    pub const iterGetObjectType = gtk_widget_path_iter_get_object_type;

    /// Returns the index into the list of siblings for the element at `pos` as
    /// returned by `gtk.WidgetPath.iterGetSiblings`. If that function would
    /// return `NULL` because the element at `pos` has no siblings, this function
    /// will return 0.
    extern fn gtk_widget_path_iter_get_sibling_index(p_path: *const WidgetPath, p_pos: c_int) c_uint;
    pub const iterGetSiblingIndex = gtk_widget_path_iter_get_sibling_index;

    /// Returns the list of siblings for the element at `pos`. If the element
    /// was not added with siblings, `NULL` is returned.
    extern fn gtk_widget_path_iter_get_siblings(p_path: *const WidgetPath, p_pos: c_int) *const gtk.WidgetPath;
    pub const iterGetSiblings = gtk_widget_path_iter_get_siblings;

    /// Returns the state flags corresponding to the widget found at
    /// the position `pos` in the widget hierarchy defined by
    /// `path`
    extern fn gtk_widget_path_iter_get_state(p_path: *const WidgetPath, p_pos: c_int) gtk.StateFlags;
    pub const iterGetState = gtk_widget_path_iter_get_state;

    /// Returns `TRUE` if the widget at position `pos` has the class `name`
    /// defined, `FALSE` otherwise.
    extern fn gtk_widget_path_iter_has_class(p_path: *const WidgetPath, p_pos: c_int, p_name: [*:0]const u8) c_int;
    pub const iterHasClass = gtk_widget_path_iter_has_class;

    /// Returns `TRUE` if the widget at position `pos` has the name `name`,
    /// `FALSE` otherwise.
    extern fn gtk_widget_path_iter_has_name(p_path: *const WidgetPath, p_pos: c_int, p_name: [*:0]const u8) c_int;
    pub const iterHasName = gtk_widget_path_iter_has_name;

    /// See `gtk.WidgetPath.iterHasClass`. This is a version that operates
    /// with GQuarks.
    extern fn gtk_widget_path_iter_has_qclass(p_path: *const WidgetPath, p_pos: c_int, p_qname: glib.Quark) c_int;
    pub const iterHasQclass = gtk_widget_path_iter_has_qclass;

    /// See `gtk.WidgetPath.iterHasName`. This is a version
    /// that operates on `GQuarks`.
    extern fn gtk_widget_path_iter_has_qname(p_path: *const WidgetPath, p_pos: c_int, p_qname: glib.Quark) c_int;
    pub const iterHasQname = gtk_widget_path_iter_has_qname;

    /// See `gtk.WidgetPath.iterHasRegion`. This is a version that operates
    /// with GQuarks.
    extern fn gtk_widget_path_iter_has_qregion(p_path: *const WidgetPath, p_pos: c_int, p_qname: glib.Quark, p_flags: *gtk.RegionFlags) c_int;
    pub const iterHasQregion = gtk_widget_path_iter_has_qregion;

    /// Returns `TRUE` if the widget at position `pos` has the class `name`
    /// defined, `FALSE` otherwise.
    extern fn gtk_widget_path_iter_has_region(p_path: *const WidgetPath, p_pos: c_int, p_name: [*:0]const u8, p_flags: *gtk.RegionFlags) c_int;
    pub const iterHasRegion = gtk_widget_path_iter_has_region;

    /// Returns a list with all the class names defined for the widget
    /// at position `pos` in the hierarchy defined in `path`.
    extern fn gtk_widget_path_iter_list_classes(p_path: *const WidgetPath, p_pos: c_int) *glib.SList;
    pub const iterListClasses = gtk_widget_path_iter_list_classes;

    /// Returns a list with all the region names defined for the widget
    /// at position `pos` in the hierarchy defined in `path`.
    extern fn gtk_widget_path_iter_list_regions(p_path: *const WidgetPath, p_pos: c_int) *glib.SList;
    pub const iterListRegions = gtk_widget_path_iter_list_regions;

    /// Removes the class `name` from the widget at position `pos` in
    /// the hierarchy defined in `path`.
    extern fn gtk_widget_path_iter_remove_class(p_path: *WidgetPath, p_pos: c_int, p_name: [*:0]const u8) void;
    pub const iterRemoveClass = gtk_widget_path_iter_remove_class;

    /// Removes the region `name` from the widget at position `pos` in
    /// the hierarchy defined in `path`.
    extern fn gtk_widget_path_iter_remove_region(p_path: *WidgetPath, p_pos: c_int, p_name: [*:0]const u8) void;
    pub const iterRemoveRegion = gtk_widget_path_iter_remove_region;

    /// Sets the widget name for the widget found at position `pos`
    /// in the widget hierarchy defined by `path`.
    extern fn gtk_widget_path_iter_set_name(p_path: *WidgetPath, p_pos: c_int, p_name: [*:0]const u8) void;
    pub const iterSetName = gtk_widget_path_iter_set_name;

    /// Sets the object name for a given position in the widget hierarchy
    /// defined by `path`.
    ///
    /// When set, the object name overrides the object type when matching
    /// CSS.
    extern fn gtk_widget_path_iter_set_object_name(p_path: *WidgetPath, p_pos: c_int, p_name: ?[*:0]const u8) void;
    pub const iterSetObjectName = gtk_widget_path_iter_set_object_name;

    /// Sets the object type for a given position in the widget hierarchy
    /// defined by `path`.
    extern fn gtk_widget_path_iter_set_object_type(p_path: *WidgetPath, p_pos: c_int, p_type: usize) void;
    pub const iterSetObjectType = gtk_widget_path_iter_set_object_type;

    /// Sets the widget name for the widget found at position `pos`
    /// in the widget hierarchy defined by `path`.
    ///
    /// If you want to update just a single state flag, you need to do
    /// this manually, as this function updates all state flags.
    ///
    /// ## Setting a flag
    ///
    /// ```
    /// gtk_widget_path_iter_set_state (path, pos, gtk_widget_path_iter_get_state (path, pos) | flag);
    /// ```
    ///
    /// ## Unsetting a flag
    ///
    /// ```
    /// gtk_widget_path_iter_set_state (path, pos, gtk_widget_path_iter_get_state (path, pos) & ~flag);
    /// ```
    extern fn gtk_widget_path_iter_set_state(p_path: *WidgetPath, p_pos: c_int, p_state: gtk.StateFlags) void;
    pub const iterSetState = gtk_widget_path_iter_set_state;

    /// Returns the number of `gtk.Widget` `GTypes` between the represented
    /// widget and its topmost container.
    extern fn gtk_widget_path_length(p_path: *const WidgetPath) c_int;
    pub const length = gtk_widget_path_length;

    /// Prepends a widget type to the widget hierachy represented by `path`.
    extern fn gtk_widget_path_prepend_type(p_path: *WidgetPath, p_type: usize) void;
    pub const prependType = gtk_widget_path_prepend_type;

    /// Increments the reference count on `path`.
    extern fn gtk_widget_path_ref(p_path: *WidgetPath) *gtk.WidgetPath;
    pub const ref = gtk_widget_path_ref;

    /// Dumps the widget path into a string representation. It tries to match
    /// the CSS style as closely as possible (Note that there might be paths
    /// that cannot be represented in CSS).
    ///
    /// The main use of this code is for debugging purposes, so that you can
    /// `glib.print` the path or dump it in a gdb session.
    extern fn gtk_widget_path_to_string(p_path: *const WidgetPath) [*:0]u8;
    pub const toString = gtk_widget_path_to_string;

    /// Decrements the reference count on `path`, freeing the structure
    /// if the reference count reaches 0.
    extern fn gtk_widget_path_unref(p_path: *WidgetPath) void;
    pub const unref = gtk_widget_path_unref;

    extern fn gtk_widget_path_get_type() usize;
    pub const getGObjectType = gtk_widget_path_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const WidgetPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const WindowAccessibleClass = extern struct {
    pub const Instance = gtk.WindowAccessible;

    f_parent_class: gtk.ContainerAccessibleClass,

    pub fn as(p_instance: *WindowAccessibleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const WindowAccessiblePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const WindowClass = extern struct {
    pub const Instance = gtk.Window;

    /// The parent class.
    f_parent_class: gtk.BinClass,
    /// Sets child as the focus widget for the window.
    f_set_focus: ?*const fn (p_window: *gtk.Window, p_focus: ?*gtk.Widget) callconv(.c) void,
    /// Activates the current focused widget within the window.
    f_activate_focus: ?*const fn (p_window: *gtk.Window) callconv(.c) void,
    /// Activates the default widget for the window.
    f_activate_default: ?*const fn (p_window: *gtk.Window) callconv(.c) void,
    /// Signal gets emitted when the set of accelerators or
    ///   mnemonics that are associated with window changes.
    f_keys_changed: ?*const fn (p_window: *gtk.Window) callconv(.c) void,
    /// Class handler for the `gtk.Window.signals.enable`-debugging
    ///   keybinding signal. Since: 3.14
    f_enable_debugging: ?*const fn (p_window: *gtk.Window, p_toggle: c_int) callconv(.c) c_int,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *WindowClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const WindowGeometryInfo = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const WindowGroupClass = extern struct {
    pub const Instance = gtk.WindowGroup;

    f_parent_class: gobject.ObjectClass,
    f__gtk_reserved1: ?*const fn () callconv(.c) void,
    f__gtk_reserved2: ?*const fn () callconv(.c) void,
    f__gtk_reserved3: ?*const fn () callconv(.c) void,
    f__gtk_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *WindowGroupClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const WindowGroupPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const WindowPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-Gtk-MountOperationHandler.top_of_page">org.Gtk.MountOperationHandler</link>.
pub const _MountOperationHandler = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-Gtk-MountOperationHandler.top_of_page">org.Gtk.MountOperationHandler</link>.
pub const _MountOperationHandlerIface = extern struct {
    /// The parent interface.
    f_parent_iface: gobject.TypeInterface,
    /// Handler for the `gtk._MountOperationHandler.signals.handle`-ask-password signal.
    f_handle_ask_password: ?*const fn (p_object: *anyopaque, p_invocation: *gio.DBusMethodInvocation, p_arg_id: [*:0]const u8, p_arg_message: [*:0]const u8, p_arg_icon_name: [*:0]const u8, p_arg_default_user: [*:0]const u8, p_arg_default_domain: [*:0]const u8, p_arg_flags: c_uint) callconv(.c) c_int,
    /// Handler for the `gtk._MountOperationHandler.signals.handle`-ask-question signal.
    f_handle_ask_question: ?*const fn (p_object: *anyopaque, p_invocation: *gio.DBusMethodInvocation, p_arg_id: [*:0]const u8, p_arg_message: [*:0]const u8, p_arg_icon_name: [*:0]const u8, p_arg_choices: *const [*:0]const u8) callconv(.c) c_int,
    /// Handler for the `gtk._MountOperationHandler.signals.handle`-close signal.
    f_handle_close: ?*const fn (p_object: *anyopaque, p_invocation: *gio.DBusMethodInvocation) callconv(.c) c_int,
    /// Handler for the `gtk._MountOperationHandler.signals.handle`-show-processes signal.
    f_handle_show_processes: ?*const fn (p_object: *anyopaque, p_invocation: *gio.DBusMethodInvocation, p_arg_id: [*:0]const u8, p_arg_message: [*:0]const u8, p_arg_icon_name: [*:0]const u8, p_arg_application_pids: *glib.Variant, p_arg_choices: *const [*:0]const u8) callconv(.c) c_int,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk._MountOperationHandlerProxy` structure contains only private data and should only be accessed using the provided API.
pub const _MountOperationHandlerProxy = extern struct {
    f_parent_instance: gio.DBusProxy,
    f_priv: ?*anyopaque,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gtk._MountOperationHandlerProxy`.
pub const _MountOperationHandlerProxyClass = extern struct {
    /// The parent class.
    f_parent_class: gio.DBusProxyClass,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const _MountOperationHandlerProxyPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk._MountOperationHandlerSkeleton` structure contains only private data and should only be accessed using the provided API.
pub const _MountOperationHandlerSkeleton = extern struct {
    f_parent_instance: gio.DBusInterfaceSkeleton,
    f_priv: ?*anyopaque,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gtk._MountOperationHandlerSkeleton`.
pub const _MountOperationHandlerSkeletonClass = extern struct {
    /// The parent class.
    f_parent_class: gio.DBusInterfaceSkeletonClass,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const _MountOperationHandlerSkeletonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Controls how a widget deals with extra space in a single (x or y)
/// dimension.
///
/// Alignment only matters if the widget receives a “too large” allocation,
/// for example if you packed the widget with the `gtk.Widget.properties.expand`
/// flag inside a `gtk.Box`, then the widget might get extra space.  If
/// you have for example a 16x16 icon inside a 32x32 space, the icon
/// could be scaled and stretched, it could be centered, or it could be
/// positioned to one side of the space.
///
/// Note that in horizontal context `GTK_ALIGN_START` and `GTK_ALIGN_END`
/// are interpreted relative to text direction.
///
/// GTK_ALIGN_BASELINE support for it is optional for containers and widgets, and
/// it is only supported for vertical alignment.  When its not supported by
/// a child or a container it is treated as `GTK_ALIGN_FILL`.
pub const Align = enum(c_int) {
    fill = 0,
    start = 1,
    end = 2,
    center = 3,
    baseline = 4,
    _,

    extern fn gtk_align_get_type() usize;
    pub const getGObjectType = gtk_align_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used to specify the placement of scroll arrows in scrolling menus.
pub const ArrowPlacement = enum(c_int) {
    both = 0,
    start = 1,
    end = 2,
    _,

    extern fn gtk_arrow_placement_get_type() usize;
    pub const getGObjectType = gtk_arrow_placement_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used to indicate the direction in which an arrow should point.
pub const ArrowType = enum(c_int) {
    up = 0,
    down = 1,
    left = 2,
    right = 3,
    none = 4,
    _,

    extern fn gtk_arrow_type_get_type() usize;
    pub const getGObjectType = gtk_arrow_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// An enum for determining the page role inside the `gtk.Assistant`. It's
/// used to handle buttons sensitivity and visibility.
///
/// Note that an assistant needs to end its page flow with a page of type
/// `GTK_ASSISTANT_PAGE_CONFIRM`, `GTK_ASSISTANT_PAGE_SUMMARY` or
/// `GTK_ASSISTANT_PAGE_PROGRESS` to be correct.
///
/// The Cancel button will only be shown if the page isn’t “committed”.
/// See `gtk.Assistant.commit` for details.
pub const AssistantPageType = enum(c_int) {
    content = 0,
    intro = 1,
    confirm = 2,
    summary = 3,
    progress = 4,
    custom = 5,
    _,

    extern fn gtk_assistant_page_type_get_type() usize;
    pub const getGObjectType = gtk_assistant_page_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Whenever a container has some form of natural row it may align
/// children in that row along a common typographical baseline. If
/// the amount of verical space in the row is taller than the total
/// requested height of the baseline-aligned children then it can use a
/// `gtk.BaselinePosition` to select where to put the baseline inside the
/// extra availible space.
pub const BaselinePosition = enum(c_int) {
    top = 0,
    center = 1,
    bottom = 2,
    _,

    extern fn gtk_baseline_position_get_type() usize;
    pub const getGObjectType = gtk_baseline_position_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes how the border of a UI element should be rendered.
pub const BorderStyle = enum(c_int) {
    none = 0,
    solid = 1,
    inset = 2,
    outset = 3,
    hidden = 4,
    dotted = 5,
    dashed = 6,
    double = 7,
    groove = 8,
    ridge = 9,
    _,

    extern fn gtk_border_style_get_type() usize;
    pub const getGObjectType = gtk_border_style_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Error codes that identify various errors that can occur while using
/// `gtk.Builder`.
pub const BuilderError = enum(c_int) {
    invalid_type_function = 0,
    unhandled_tag = 1,
    missing_attribute = 2,
    invalid_attribute = 3,
    invalid_tag = 4,
    missing_property_value = 5,
    invalid_value = 6,
    version_mismatch = 7,
    duplicate_id = 8,
    object_type_refused = 9,
    template_mismatch = 10,
    invalid_property = 11,
    invalid_signal = 12,
    invalid_id = 13,
    _,

    extern fn gtk_builder_error_quark() glib.Quark;
    pub const quark = gtk_builder_error_quark;

    extern fn gtk_builder_error_get_type() usize;
    pub const getGObjectType = gtk_builder_error_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used to dictate the style that a `gtk.ButtonBox` uses to layout the buttons it
/// contains.
pub const ButtonBoxStyle = enum(c_int) {
    spread = 1,
    edge = 2,
    start = 3,
    end = 4,
    center = 5,
    expand = 6,
    _,

    extern fn gtk_button_box_style_get_type() usize;
    pub const getGObjectType = gtk_button_box_style_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The role specifies the desired appearance of a `gtk.ModelButton`.
pub const ButtonRole = enum(c_int) {
    normal = 0,
    check = 1,
    radio = 2,
    _,

    extern fn gtk_button_role_get_type() usize;
    pub const getGObjectType = gtk_button_role_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Prebuilt sets of buttons for the dialog. If
/// none of these choices are appropriate, simply use `GTK_BUTTONS_NONE`
/// then call `gtk.Dialog.addButtons`.
///
/// > Please note that `GTK_BUTTONS_OK`, `GTK_BUTTONS_YES_NO`
/// > and `GTK_BUTTONS_OK_CANCEL` are discouraged by the
/// > [GNOME Human Interface Guidelines](http://library.gnome.org/devel/hig-book/stable/).
pub const ButtonsType = enum(c_int) {
    none = 0,
    ok = 1,
    close = 2,
    cancel = 3,
    yes_no = 4,
    ok_cancel = 5,
    _,

    extern fn gtk_buttons_type_get_type() usize;
    pub const getGObjectType = gtk_buttons_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Determines if the edited accelerators are GTK+ accelerators. If
/// they are, consumed modifiers are suppressed, only accelerators
/// accepted by GTK+ are allowed, and the accelerators are rendered
/// in the same way as they are in menus.
pub const CellRendererAccelMode = enum(c_int) {
    gtk = 0,
    other = 1,
    _,

    extern fn gtk_cell_renderer_accel_mode_get_type() usize;
    pub const getGObjectType = gtk_cell_renderer_accel_mode_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Identifies how the user can interact with a particular cell.
pub const CellRendererMode = enum(c_int) {
    inert = 0,
    activatable = 1,
    editable = 2,
    _,

    extern fn gtk_cell_renderer_mode_get_type() usize;
    pub const getGObjectType = gtk_cell_renderer_mode_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Specifies which corner a child widget should be placed in when packed into
/// a `gtk.ScrolledWindow`. This is effectively the opposite of where the scroll
/// bars are placed.
pub const CornerType = enum(c_int) {
    top_left = 0,
    bottom_left = 1,
    top_right = 2,
    bottom_right = 3,
    _,

    extern fn gtk_corner_type_get_type() usize;
    pub const getGObjectType = gtk_corner_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Error codes for `GTK_CSS_PROVIDER_ERROR`.
pub const CssProviderError = enum(c_int) {
    failed = 0,
    syntax = 1,
    import = 2,
    name = 3,
    deprecated = 4,
    unknown_value = 5,
    _,

    extern fn gtk_css_provider_error_quark() glib.Quark;
    pub const quark = gtk_css_provider_error_quark;

    extern fn gtk_css_provider_error_get_type() usize;
    pub const getGObjectType = gtk_css_provider_error_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The different types of sections indicate parts of a CSS document as
/// parsed by GTK’s CSS parser. They are oriented towards the
/// [CSS Grammar](http://www.w3.org/TR/CSS21/grammar.html),
/// but may contain extensions.
///
/// More types might be added in the future as the parser incorporates
/// more features.
pub const CssSectionType = enum(c_int) {
    document = 0,
    import = 1,
    color_definition = 2,
    binding_set = 3,
    ruleset = 4,
    selector = 5,
    declaration = 6,
    value = 7,
    keyframes = 8,
    _,

    extern fn gtk_css_section_type_get_type() usize;
    pub const getGObjectType = gtk_css_section_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// See also: `gtk.Entry.signals.delete`-from-cursor.
pub const DeleteType = enum(c_int) {
    chars = 0,
    word_ends = 1,
    words = 2,
    display_lines = 3,
    display_line_ends = 4,
    paragraph_ends = 5,
    paragraphs = 6,
    whitespace = 7,
    _,

    extern fn gtk_delete_type_get_type() usize;
    pub const getGObjectType = gtk_delete_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Focus movement types.
pub const DirectionType = enum(c_int) {
    tab_forward = 0,
    tab_backward = 1,
    up = 2,
    down = 3,
    left = 4,
    right = 5,
    _,

    extern fn gtk_direction_type_get_type() usize;
    pub const getGObjectType = gtk_direction_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Gives an indication why a drag operation failed.
/// The value can by obtained by connecting to the
/// `gtk.Widget.signals.drag`-failed signal.
pub const DragResult = enum(c_int) {
    success = 0,
    no_target = 1,
    user_cancelled = 2,
    timeout_expired = 3,
    grab_broken = 4,
    @"error" = 5,
    _,

    extern fn gtk_drag_result_get_type() usize;
    pub const getGObjectType = gtk_drag_result_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Specifies the side of the entry at which an icon is placed.
pub const EntryIconPosition = enum(c_int) {
    primary = 0,
    secondary = 1,
    _,

    extern fn gtk_entry_icon_position_get_type() usize;
    pub const getGObjectType = gtk_entry_icon_position_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes the state of a `gdk.EventSequence` in a `gtk.Gesture`.
pub const EventSequenceState = enum(c_int) {
    none = 0,
    claimed = 1,
    denied = 2,
    _,

    extern fn gtk_event_sequence_state_get_type() usize;
    pub const getGObjectType = gtk_event_sequence_state_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used to specify the style of the expanders drawn by a `gtk.TreeView`.
pub const ExpanderStyle = enum(c_int) {
    collapsed = 0,
    semi_collapsed = 1,
    semi_expanded = 2,
    expanded = 3,
    _,

    extern fn gtk_expander_style_get_type() usize;
    pub const getGObjectType = gtk_expander_style_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes whether a `gtk.FileChooser` is being used to open existing files
/// or to save to a possibly new file.
pub const FileChooserAction = enum(c_int) {
    open = 0,
    save = 1,
    select_folder = 2,
    create_folder = 3,
    _,

    extern fn gtk_file_chooser_action_get_type() usize;
    pub const getGObjectType = gtk_file_chooser_action_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used as a return value of handlers for the
/// `gtk.FileChooser.signals.confirm`-overwrite signal of a `gtk.FileChooser`. This
/// value determines whether the file chooser will present the stock
/// confirmation dialog, accept the user’s choice of a filename, or
/// let the user choose another filename.
pub const FileChooserConfirmation = enum(c_int) {
    confirm = 0,
    accept_filename = 1,
    select_again = 2,
    _,

    extern fn gtk_file_chooser_confirmation_get_type() usize;
    pub const getGObjectType = gtk_file_chooser_confirmation_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// These identify the various errors that can occur while calling
/// `gtk.FileChooser` functions.
pub const FileChooserError = enum(c_int) {
    nonexistent = 0,
    bad_filename = 1,
    already_exists = 2,
    incomplete_hostname = 3,
    _,

    /// Registers an error quark for `gtk.FileChooser` if necessary.
    extern fn gtk_file_chooser_error_quark() glib.Quark;
    pub const quark = gtk_file_chooser_error_quark;

    extern fn gtk_file_chooser_error_get_type() usize;
    pub const getGObjectType = gtk_file_chooser_error_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Style for input method preedit. See also
/// `gtk.Settings.properties.gtk`-im-preedit-style
pub const IMPreeditStyle = enum(c_int) {
    nothing = 0,
    callback = 1,
    none = 2,
    _,

    extern fn gtk_im_preedit_style_get_type() usize;
    pub const getGObjectType = gtk_im_preedit_style_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Style for input method status. See also
/// `gtk.Settings.properties.gtk`-im-status-style
pub const IMStatusStyle = enum(c_int) {
    nothing = 0,
    callback = 1,
    none = 2,
    _,

    extern fn gtk_im_status_style_get_type() usize;
    pub const getGObjectType = gtk_im_status_style_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Built-in stock icon sizes.
pub const IconSize = enum(c_int) {
    invalid = 0,
    menu = 1,
    small_toolbar = 2,
    large_toolbar = 3,
    button = 4,
    dnd = 5,
    dialog = 6,
    _,

    /// Looks up the icon size associated with `name`.
    extern fn gtk_icon_size_from_name(p_name: [*:0]const u8) c_int;
    pub const fromName = gtk_icon_size_from_name;

    /// Gets the canonical name of the given icon size. The returned string
    /// is statically allocated and should not be freed.
    extern fn gtk_icon_size_get_name(p_size: c_int) [*:0]const u8;
    pub const getName = gtk_icon_size_get_name;

    /// Obtains the pixel size of a semantic icon size `size`:
    /// `GTK_ICON_SIZE_MENU`, `GTK_ICON_SIZE_BUTTON`, etc.  This function
    /// isn’t normally needed, `gtk.IconTheme.loadIcon` is the usual
    /// way to get an icon for rendering, then just look at the size of
    /// the rendered pixbuf. The rendered pixbuf may not even correspond to
    /// the width/height returned by `gtk.iconSizeLookup`, because themes
    /// are free to render the pixbuf however they like, including changing
    /// the usual size.
    extern fn gtk_icon_size_lookup(p_size: c_int, p_width: ?*c_int, p_height: ?*c_int) c_int;
    pub const lookup = gtk_icon_size_lookup;

    /// Obtains the pixel size of a semantic icon size, possibly
    /// modified by user preferences for a particular
    /// `gtk.Settings`. Normally `size` would be
    /// `GTK_ICON_SIZE_MENU`, `GTK_ICON_SIZE_BUTTON`, etc.  This function
    /// isn’t normally needed, `gtk.Widget.renderIconPixbuf` is the usual
    /// way to get an icon for rendering, then just look at the size of
    /// the rendered pixbuf. The rendered pixbuf may not even correspond to
    /// the width/height returned by `gtk.iconSizeLookup`, because themes
    /// are free to render the pixbuf however they like, including changing
    /// the usual size.
    extern fn gtk_icon_size_lookup_for_settings(p_settings: *gtk.Settings, p_size: c_int, p_width: ?*c_int, p_height: ?*c_int) c_int;
    pub const lookupForSettings = gtk_icon_size_lookup_for_settings;

    /// Registers a new icon size, along the same lines as `GTK_ICON_SIZE_MENU`,
    /// etc. Returns the integer value for the size.
    extern fn gtk_icon_size_register(p_name: [*:0]const u8, p_width: c_int, p_height: c_int) c_int;
    pub const register = gtk_icon_size_register;

    /// Registers `alias` as another name for `target`.
    /// So calling `gtk.iconSizeFromName` with `alias` as argument
    /// will return `target`.
    extern fn gtk_icon_size_register_alias(p_alias: [*:0]const u8, p_target: c_int) void;
    pub const registerAlias = gtk_icon_size_register_alias;

    extern fn gtk_icon_size_get_type() usize;
    pub const getGObjectType = gtk_icon_size_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Error codes for GtkIconTheme operations.
pub const IconThemeError = enum(c_int) {
    not_found = 0,
    failed = 1,
    _,

    extern fn gtk_icon_theme_error_quark() glib.Quark;
    pub const quark = gtk_icon_theme_error_quark;

    extern fn gtk_icon_theme_error_get_type() usize;
    pub const getGObjectType = gtk_icon_theme_error_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// An enum for determining where a dropped item goes.
pub const IconViewDropPosition = enum(c_int) {
    no_drop = 0,
    drop_into = 1,
    drop_left = 2,
    drop_right = 3,
    drop_above = 4,
    drop_below = 5,
    _,

    extern fn gtk_icon_view_drop_position_get_type() usize;
    pub const getGObjectType = gtk_icon_view_drop_position_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes the image data representation used by a `gtk.Image`. If you
/// want to get the image from the widget, you can only get the
/// currently-stored representation. e.g.  if the
/// `gtk.Image.getStorageType` returns `GTK_IMAGE_PIXBUF`, then you can
/// call `gtk.Image.getPixbuf` but not `gtk.Image.getStock`.  For empty
/// images, you can request any storage type (call any of the "get"
/// functions), but they will all return `NULL` values.
pub const ImageType = enum(c_int) {
    empty = 0,
    pixbuf = 1,
    stock = 2,
    icon_set = 3,
    animation = 4,
    icon_name = 5,
    gicon = 6,
    surface = 7,
    _,

    extern fn gtk_image_type_get_type() usize;
    pub const getGObjectType = gtk_image_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes primary purpose of the input widget. This information is
/// useful for on-screen keyboards and similar input methods to decide
/// which keys should be presented to the user.
///
/// Note that the purpose is not meant to impose a totally strict rule
/// about allowed characters, and does not replace input validation.
/// It is fine for an on-screen keyboard to let the user override the
/// character set restriction that is expressed by the purpose. The
/// application is expected to validate the entry contents, even if
/// it specified a purpose.
///
/// The difference between `GTK_INPUT_PURPOSE_DIGITS` and
/// `GTK_INPUT_PURPOSE_NUMBER` is that the former accepts only digits
/// while the latter also some punctuation (like commas or points, plus,
/// minus) and “e” or “E” as in 3.14E+000.
///
/// This enumeration may be extended in the future; input methods should
/// interpret unknown values as “free form”.
pub const InputPurpose = enum(c_int) {
    free_form = 0,
    alpha = 1,
    digits = 2,
    number = 3,
    phone = 4,
    url = 5,
    email = 6,
    name = 7,
    password = 8,
    pin = 9,
    terminal = 10,
    _,

    extern fn gtk_input_purpose_get_type() usize;
    pub const getGObjectType = gtk_input_purpose_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used for justifying the text inside a `gtk.Label` widget. (See also
/// `gtk.Alignment`).
pub const Justification = enum(c_int) {
    left = 0,
    right = 1,
    center = 2,
    fill = 3,
    _,

    extern fn gtk_justification_get_type() usize;
    pub const getGObjectType = gtk_justification_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes how `gtk.LevelBar` contents should be rendered.
/// Note that this enumeration could be extended with additional modes
/// in the future.
pub const LevelBarMode = enum(c_int) {
    continuous = 0,
    discrete = 1,
    _,

    extern fn gtk_level_bar_mode_get_type() usize;
    pub const getGObjectType = gtk_level_bar_mode_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The type of license for an application.
///
/// This enumeration can be expanded at later date.
pub const License = enum(c_int) {
    unknown = 0,
    custom = 1,
    gpl_2_0 = 2,
    gpl_3_0 = 3,
    lgpl_2_1 = 4,
    lgpl_3_0 = 5,
    bsd = 6,
    mit_x11 = 7,
    artistic = 8,
    gpl_2_0_only = 9,
    gpl_3_0_only = 10,
    lgpl_2_1_only = 11,
    lgpl_3_0_only = 12,
    agpl_3_0 = 13,
    agpl_3_0_only = 14,
    bsd_3 = 15,
    apache_2_0 = 16,
    mpl_2_0 = 17,
    _,

    extern fn gtk_license_get_type() usize;
    pub const getGObjectType = gtk_license_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// An enumeration representing directional movements within a menu.
pub const MenuDirectionType = enum(c_int) {
    parent = 0,
    child = 1,
    next = 2,
    prev = 3,
    _,

    extern fn gtk_menu_direction_type_get_type() usize;
    pub const getGObjectType = gtk_menu_direction_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The type of message being displayed in the dialog.
pub const MessageType = enum(c_int) {
    info = 0,
    warning = 1,
    question = 2,
    @"error" = 3,
    other = 4,
    _,

    extern fn gtk_message_type_get_type() usize;
    pub const getGObjectType = gtk_message_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MovementStep = enum(c_int) {
    logical_positions = 0,
    visual_positions = 1,
    words = 2,
    display_lines = 3,
    display_line_ends = 4,
    paragraphs = 5,
    paragraph_ends = 6,
    pages = 7,
    buffer_ends = 8,
    horizontal_pages = 9,
    _,

    extern fn gtk_movement_step_get_type() usize;
    pub const getGObjectType = gtk_movement_step_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NotebookTab = enum(c_int) {
    first = 0,
    last = 1,
    _,

    extern fn gtk_notebook_tab_get_type() usize;
    pub const getGObjectType = gtk_notebook_tab_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used to determine the layout of pages on a sheet when printing
/// multiple pages per sheet.
pub const NumberUpLayout = enum(c_int) {
    lrtb = 0,
    lrbt = 1,
    rltb = 2,
    rlbt = 3,
    tblr = 4,
    tbrl = 5,
    btlr = 6,
    btrl = 7,
    _,

    extern fn gtk_number_up_layout_get_type() usize;
    pub const getGObjectType = gtk_number_up_layout_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Represents the orientation of widgets and other objects which can be switched
/// between horizontal and vertical orientation on the fly, like `gtk.Toolbar` or
/// `gtk.GesturePan`.
pub const Orientation = enum(c_int) {
    horizontal = 0,
    vertical = 1,
    _,

    extern fn gtk_orientation_get_type() usize;
    pub const getGObjectType = gtk_orientation_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Determines how widgets should be packed inside menubars
/// and menuitems contained in menubars.
pub const PackDirection = enum(c_int) {
    ltr = 0,
    rtl = 1,
    ttb = 2,
    btt = 3,
    _,

    extern fn gtk_pack_direction_get_type() usize;
    pub const getGObjectType = gtk_pack_direction_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Represents the packing location `gtk.Box` children. (See: `gtk.VBox`,
/// `gtk.HBox`, and `gtk.ButtonBox`).
pub const PackType = enum(c_int) {
    start = 0,
    end = 1,
    _,

    extern fn gtk_pack_type_get_type() usize;
    pub const getGObjectType = gtk_pack_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The type of a pad action.
pub const PadActionType = enum(c_int) {
    button = 0,
    ring = 1,
    strip = 2,
    _,

    extern fn gtk_pad_action_type_get_type() usize;
    pub const getGObjectType = gtk_pad_action_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// See also `gtk.PrintSettings.setOrientation`.
pub const PageOrientation = enum(c_int) {
    portrait = 0,
    landscape = 1,
    reverse_portrait = 2,
    reverse_landscape = 3,
    _,

    extern fn gtk_page_orientation_get_type() usize;
    pub const getGObjectType = gtk_page_orientation_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// See also `gtk_print_job_set_page_set`.
pub const PageSet = enum(c_int) {
    all = 0,
    even = 1,
    odd = 2,
    _,

    extern fn gtk_page_set_get_type() usize;
    pub const getGObjectType = gtk_page_set_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes the panning direction of a `gtk.GesturePan`
pub const PanDirection = enum(c_int) {
    left = 0,
    right = 1,
    up = 2,
    down = 3,
    _,

    extern fn gtk_pan_direction_get_type() usize;
    pub const getGObjectType = gtk_pan_direction_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Priorities for path lookups.
/// See also `gtk.BindingSet.addPath`.
pub const PathPriorityType = enum(c_int) {
    lowest = 0,
    gtk = 4,
    application = 8,
    theme = 10,
    rc = 12,
    highest = 15,
    _,

    extern fn gtk_path_priority_type_get_type() usize;
    pub const getGObjectType = gtk_path_priority_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Widget path types.
/// See also `gtk.BindingSet.addPath`.
pub const PathType = enum(c_int) {
    widget = 0,
    widget_class = 1,
    class = 2,
    _,

    extern fn gtk_path_type_get_type() usize;
    pub const getGObjectType = gtk_path_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Determines how the size should be computed to achieve the one of the
/// visibility mode for the scrollbars.
pub const PolicyType = enum(c_int) {
    always = 0,
    automatic = 1,
    never = 2,
    external = 3,
    _,

    extern fn gtk_policy_type_get_type() usize;
    pub const getGObjectType = gtk_policy_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes constraints to positioning of popovers. More values
/// may be added to this enumeration in the future.
pub const PopoverConstraint = enum(c_int) {
    none = 0,
    window = 1,
    _,

    extern fn gtk_popover_constraint_get_type() usize;
    pub const getGObjectType = gtk_popover_constraint_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes which edge of a widget a certain feature is positioned at, e.g. the
/// tabs of a `gtk.Notebook`, the handle of a `gtk.HandleBox` or the label of a
/// `gtk.Scale`.
pub const PositionType = enum(c_int) {
    left = 0,
    right = 1,
    top = 2,
    bottom = 3,
    _,

    extern fn gtk_position_type_get_type() usize;
    pub const getGObjectType = gtk_position_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// See also `gtk.PrintSettings.setDuplex`.
pub const PrintDuplex = enum(c_int) {
    simplex = 0,
    horizontal = 1,
    vertical = 2,
    _,

    extern fn gtk_print_duplex_get_type() usize;
    pub const getGObjectType = gtk_print_duplex_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Error codes that identify various errors that can occur while
/// using the GTK+ printing support.
pub const PrintError = enum(c_int) {
    general = 0,
    internal_error = 1,
    nomem = 2,
    invalid_file = 3,
    _,

    /// Registers an error quark for `gtk.PrintOperation` if necessary.
    extern fn gtk_print_error_quark() glib.Quark;
    pub const quark = gtk_print_error_quark;

    extern fn gtk_print_error_get_type() usize;
    pub const getGObjectType = gtk_print_error_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `action` parameter to `gtk.PrintOperation.run`
/// determines what action the print operation should perform.
pub const PrintOperationAction = enum(c_int) {
    print_dialog = 0,
    print = 1,
    preview = 2,
    @"export" = 3,
    _,

    extern fn gtk_print_operation_action_get_type() usize;
    pub const getGObjectType = gtk_print_operation_action_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A value of this type is returned by `gtk.PrintOperation.run`.
pub const PrintOperationResult = enum(c_int) {
    @"error" = 0,
    apply = 1,
    cancel = 2,
    in_progress = 3,
    _,

    extern fn gtk_print_operation_result_get_type() usize;
    pub const getGObjectType = gtk_print_operation_result_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// See also `gtk_print_job_set_pages`
pub const PrintPages = enum(c_int) {
    all = 0,
    current = 1,
    ranges = 2,
    selection = 3,
    _,

    extern fn gtk_print_pages_get_type() usize;
    pub const getGObjectType = gtk_print_pages_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// See also `gtk.PrintSettings.setQuality`.
pub const PrintQuality = enum(c_int) {
    low = 0,
    normal = 1,
    high = 2,
    draft = 3,
    _,

    extern fn gtk_print_quality_get_type() usize;
    pub const getGObjectType = gtk_print_quality_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The status gives a rough indication of the completion of a running
/// print operation.
pub const PrintStatus = enum(c_int) {
    initial = 0,
    preparing = 1,
    generating_data = 2,
    sending_data = 3,
    pending = 4,
    pending_issue = 5,
    printing = 6,
    finished = 7,
    finished_aborted = 8,
    _,

    extern fn gtk_print_status_get_type() usize;
    pub const getGObjectType = gtk_print_status_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes the stage at which events are fed into a `gtk.EventController`.
pub const PropagationPhase = enum(c_int) {
    none = 0,
    capture = 1,
    bubble = 2,
    target = 3,
    _,

    extern fn gtk_propagation_phase_get_type() usize;
    pub const getGObjectType = gtk_propagation_phase_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.RcTokenType` enumeration represents the tokens
/// in the RC file. It is exposed so that theme engines
/// can reuse these tokens when parsing the theme-engine
/// specific portions of a RC file.
pub const RcTokenType = enum(c_int) {
    invalid = 270,
    include = 271,
    normal = 272,
    active = 273,
    prelight = 274,
    selected = 275,
    insensitive = 276,
    fg = 277,
    bg = 278,
    text = 279,
    base = 280,
    xthickness = 281,
    ythickness = 282,
    font = 283,
    fontset = 284,
    font_name = 285,
    bg_pixmap = 286,
    pixmap_path = 287,
    style = 288,
    binding = 289,
    bind = 290,
    widget = 291,
    widget_class = 292,
    class = 293,
    lowest = 294,
    gtk = 295,
    application = 296,
    theme = 297,
    rc = 298,
    highest = 299,
    engine = 300,
    module_path = 301,
    im_module_path = 302,
    im_module_file = 303,
    stock = 304,
    ltr = 305,
    rtl = 306,
    color = 307,
    unbind = 308,
    last = 309,
    _,

    extern fn gtk_rc_token_type_get_type() usize;
    pub const getGObjectType = gtk_rc_token_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// These identify the various errors that can occur while calling
/// `gtk.RecentChooser` functions.
pub const RecentChooserError = enum(c_int) {
    not_found = 0,
    invalid_uri = 1,
    _,

    extern fn gtk_recent_chooser_error_quark() glib.Quark;
    pub const quark = gtk_recent_chooser_error_quark;

    extern fn gtk_recent_chooser_error_get_type() usize;
    pub const getGObjectType = gtk_recent_chooser_error_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Error codes for `gtk.RecentManager` operations
pub const RecentManagerError = enum(c_int) {
    not_found = 0,
    invalid_uri = 1,
    invalid_encoding = 2,
    not_registered = 3,
    read = 4,
    write = 5,
    unknown = 6,
    _,

    extern fn gtk_recent_manager_error_quark() glib.Quark;
    pub const quark = gtk_recent_manager_error_quark;

    extern fn gtk_recent_manager_error_get_type() usize;
    pub const getGObjectType = gtk_recent_manager_error_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used to specify the sorting method to be applyed to the recently
/// used resource list.
pub const RecentSortType = enum(c_int) {
    none = 0,
    mru = 1,
    lru = 2,
    custom = 3,
    _,

    extern fn gtk_recent_sort_type_get_type() usize;
    pub const getGObjectType = gtk_recent_sort_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Indicated the relief to be drawn around a `gtk.Button`.
pub const ReliefStyle = enum(c_int) {
    normal = 0,
    half = 1,
    none = 2,
    _,

    extern fn gtk_relief_style_get_type() usize;
    pub const getGObjectType = gtk_relief_style_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ResizeMode = enum(c_int) {
    parent = 0,
    queue = 1,
    immediate = 2,
    _,

    extern fn gtk_resize_mode_get_type() usize;
    pub const getGObjectType = gtk_resize_mode_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Predefined values for use as response ids in `gtk.Dialog.addButton`.
/// All predefined values are negative; GTK+ leaves values of 0 or greater for
/// application-defined response ids.
pub const ResponseType = enum(c_int) {
    none = -1,
    reject = -2,
    accept = -3,
    delete_event = -4,
    ok = -5,
    cancel = -6,
    close = -7,
    yes = -8,
    no = -9,
    apply = -10,
    help = -11,
    _,

    extern fn gtk_response_type_get_type() usize;
    pub const getGObjectType = gtk_response_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// These enumeration values describe the possible transitions
/// when the child of a `gtk.Revealer` widget is shown or hidden.
pub const RevealerTransitionType = enum(c_int) {
    none = 0,
    crossfade = 1,
    slide_right = 2,
    slide_left = 3,
    slide_up = 4,
    slide_down = 5,
    _,

    extern fn gtk_revealer_transition_type_get_type() usize;
    pub const getGObjectType = gtk_revealer_transition_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ScrollStep = enum(c_int) {
    steps = 0,
    pages = 1,
    ends = 2,
    horizontal_steps = 3,
    horizontal_pages = 4,
    horizontal_ends = 5,
    _,

    extern fn gtk_scroll_step_get_type() usize;
    pub const getGObjectType = gtk_scroll_step_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Scrolling types.
pub const ScrollType = enum(c_int) {
    none = 0,
    jump = 1,
    step_backward = 2,
    step_forward = 3,
    page_backward = 4,
    page_forward = 5,
    step_up = 6,
    step_down = 7,
    page_up = 8,
    page_down = 9,
    step_left = 10,
    step_right = 11,
    page_left = 12,
    page_right = 13,
    start = 14,
    end = 15,
    _,

    extern fn gtk_scroll_type_get_type() usize;
    pub const getGObjectType = gtk_scroll_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Defines the policy to be used in a scrollable widget when updating
/// the scrolled window adjustments in a given orientation.
pub const ScrollablePolicy = enum(c_int) {
    minimum = 0,
    natural = 1,
    _,

    extern fn gtk_scrollable_policy_get_type() usize;
    pub const getGObjectType = gtk_scrollable_policy_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used to control what selections users are allowed to make.
pub const SelectionMode = enum(c_int) {
    none = 0,
    single = 1,
    browse = 2,
    multiple = 3,
    _,

    extern fn gtk_selection_mode_get_type() usize;
    pub const getGObjectType = gtk_selection_mode_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Determines how GTK+ handles the sensitivity of stepper arrows
/// at the end of range widgets.
pub const SensitivityType = enum(c_int) {
    auto = 0,
    on = 1,
    off = 2,
    _,

    extern fn gtk_sensitivity_type_get_type() usize;
    pub const getGObjectType = gtk_sensitivity_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used to change the appearance of an outline typically provided by a `gtk.Frame`.
///
/// Note that many themes do not differentiate the appearance of the
/// various shadow types: Either their is no visible shadow (`GTK_SHADOW_NONE`),
/// or there is (any other value).
pub const ShadowType = enum(c_int) {
    none = 0,
    in = 1,
    out = 2,
    etched_in = 3,
    etched_out = 4,
    _,

    extern fn gtk_shadow_type_get_type() usize;
    pub const getGObjectType = gtk_shadow_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GtkShortcutType specifies the kind of shortcut that is being described.
/// More values may be added to this enumeration over time.
pub const ShortcutType = enum(c_int) {
    accelerator = 0,
    gesture_pinch = 1,
    gesture_stretch = 2,
    gesture_rotate_clockwise = 3,
    gesture_rotate_counterclockwise = 4,
    gesture_two_finger_swipe_left = 5,
    gesture_two_finger_swipe_right = 6,
    gesture = 7,
    _,

    extern fn gtk_shortcut_type_get_type() usize;
    pub const getGObjectType = gtk_shortcut_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The mode of the size group determines the directions in which the size
/// group affects the requested sizes of its component widgets.
pub const SizeGroupMode = enum(c_int) {
    none = 0,
    horizontal = 1,
    vertical = 2,
    both = 3,
    _,

    extern fn gtk_size_group_mode_get_type() usize;
    pub const getGObjectType = gtk_size_group_mode_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Specifies a preference for height-for-width or
/// width-for-height geometry management.
pub const SizeRequestMode = enum(c_int) {
    height_for_width = 0,
    width_for_height = 1,
    constant_size = 2,
    _,

    extern fn gtk_size_request_mode_get_type() usize;
    pub const getGObjectType = gtk_size_request_mode_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Determines the direction of a sort.
pub const SortType = enum(c_int) {
    ascending = 0,
    descending = 1,
    _,

    extern fn gtk_sort_type_get_type() usize;
    pub const getGObjectType = gtk_sort_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The spin button update policy determines whether the spin button displays
/// values even if they are outside the bounds of its adjustment.
/// See `gtk.SpinButton.setUpdatePolicy`.
pub const SpinButtonUpdatePolicy = enum(c_int) {
    always = 0,
    if_valid = 1,
    _,

    extern fn gtk_spin_button_update_policy_get_type() usize;
    pub const getGObjectType = gtk_spin_button_update_policy_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The values of the GtkSpinType enumeration are used to specify the
/// change to make in `gtk.SpinButton.spin`.
pub const SpinType = enum(c_int) {
    step_forward = 0,
    step_backward = 1,
    page_forward = 2,
    page_backward = 3,
    home = 4,
    end = 5,
    user_defined = 6,
    _,

    extern fn gtk_spin_type_get_type() usize;
    pub const getGObjectType = gtk_spin_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// These enumeration values describe the possible transitions
/// between pages in a `gtk.Stack` widget.
///
/// New values may be added to this enumeration over time.
pub const StackTransitionType = enum(c_int) {
    none = 0,
    crossfade = 1,
    slide_right = 2,
    slide_left = 3,
    slide_up = 4,
    slide_down = 5,
    slide_left_right = 6,
    slide_up_down = 7,
    over_up = 8,
    over_down = 9,
    over_left = 10,
    over_right = 11,
    under_up = 12,
    under_down = 13,
    under_left = 14,
    under_right = 15,
    over_up_down = 16,
    over_down_up = 17,
    over_left_right = 18,
    over_right_left = 19,
    _,

    extern fn gtk_stack_transition_type_get_type() usize;
    pub const getGObjectType = gtk_stack_transition_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// This type indicates the current state of a widget; the state determines how
/// the widget is drawn. The `gtk.StateType` enumeration is also used to
/// identify different colors in a `gtk.Style` for drawing, so states can be
/// used for subparts of a widget as well as entire widgets.
pub const StateType = enum(c_int) {
    normal = 0,
    active = 1,
    prelight = 2,
    selected = 3,
    insensitive = 4,
    inconsistent = 5,
    focused = 6,
    _,

    extern fn gtk_state_type_get_type() usize;
    pub const getGObjectType = gtk_state_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// These values are used as “info” for the targets contained in the
/// lists returned by `gtk.TextBuffer.getCopyTargetList` and
/// `gtk.TextBuffer.getPasteTargetList`.
///
/// The values counts down from `-1` to avoid clashes
/// with application added drag destinations which usually start at 0.
pub const TextBufferTargetInfo = enum(c_int) {
    buffer_contents = -1,
    rich_text = -2,
    text = -3,
    _,

    extern fn gtk_text_buffer_target_info_get_type() usize;
    pub const getGObjectType = gtk_text_buffer_target_info_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Reading directions for text.
pub const TextDirection = enum(c_int) {
    none = 0,
    ltr = 1,
    rtl = 2,
    _,

    extern fn gtk_text_direction_get_type() usize;
    pub const getGObjectType = gtk_text_direction_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Granularity types that extend the text selection. Use the
/// `gtk.TextView.signals.extend`-selection signal to customize the selection.
pub const TextExtendSelection = enum(c_int) {
    word = 0,
    line = 1,
    _,

    extern fn gtk_text_extend_selection_get_type() usize;
    pub const getGObjectType = gtk_text_extend_selection_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used to reference the layers of `gtk.TextView` for the purpose of customized
/// drawing with the ::draw_layer vfunc.
pub const TextViewLayer = enum(c_int) {
    below = 0,
    above = 1,
    below_text = 2,
    above_text = 3,
    _,

    extern fn gtk_text_view_layer_get_type() usize;
    pub const getGObjectType = gtk_text_view_layer_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used to reference the parts of `gtk.TextView`.
pub const TextWindowType = enum(c_int) {
    private = 0,
    widget = 1,
    text = 2,
    left = 3,
    right = 4,
    top = 5,
    bottom = 6,
    _,

    extern fn gtk_text_window_type_get_type() usize;
    pub const getGObjectType = gtk_text_window_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Whether spacers are vertical lines or just blank.
pub const ToolbarSpaceStyle = enum(c_int) {
    empty = 0,
    line = 1,
    _,

    extern fn gtk_toolbar_space_style_get_type() usize;
    pub const getGObjectType = gtk_toolbar_space_style_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used to customize the appearance of a `gtk.Toolbar`. Note that
/// setting the toolbar style overrides the user’s preferences
/// for the default toolbar style.  Note that if the button has only
/// a label set and GTK_TOOLBAR_ICONS is used, the label will be
/// visible, and vice versa.
pub const ToolbarStyle = enum(c_int) {
    icons = 0,
    text = 1,
    both = 2,
    both_horiz = 3,
    _,

    extern fn gtk_toolbar_style_get_type() usize;
    pub const getGObjectType = gtk_toolbar_style_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The sizing method the column uses to determine its width.  Please note
/// that `GTK_TREE_VIEW_COLUMN_AUTOSIZE` are inefficient for large views, and
/// can make columns appear choppy.
pub const TreeViewColumnSizing = enum(c_int) {
    grow_only = 0,
    autosize = 1,
    fixed = 2,
    _,

    extern fn gtk_tree_view_column_sizing_get_type() usize;
    pub const getGObjectType = gtk_tree_view_column_sizing_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// An enum for determining where a dropped row goes.
pub const TreeViewDropPosition = enum(c_int) {
    before = 0,
    after = 1,
    into_or_before = 2,
    into_or_after = 3,
    _,

    extern fn gtk_tree_view_drop_position_get_type() usize;
    pub const getGObjectType = gtk_tree_view_drop_position_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used to indicate which grid lines to draw in a tree view.
pub const TreeViewGridLines = enum(c_int) {
    none = 0,
    horizontal = 1,
    vertical = 2,
    both = 3,
    _,

    extern fn gtk_tree_view_grid_lines_get_type() usize;
    pub const getGObjectType = gtk_tree_view_grid_lines_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// See also `gtk.PrintSettings.setPaperWidth`.
pub const Unit = enum(c_int) {
    none = 0,
    points = 1,
    inch = 2,
    mm = 3,
    _,

    extern fn gtk_unit_get_type() usize;
    pub const getGObjectType = gtk_unit_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Kinds of widget-specific help. Used by the ::show-help signal.
pub const WidgetHelpType = enum(c_int) {
    tooltip = 0,
    whats_this = 1,
    _,

    extern fn gtk_widget_help_type_get_type() usize;
    pub const getGObjectType = gtk_widget_help_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Window placement can be influenced using this enumeration. Note that
/// using `GTK_WIN_POS_CENTER_ALWAYS` is almost always a bad idea.
/// It won’t necessarily work well with all window managers or on all windowing systems.
pub const WindowPosition = enum(c_int) {
    none = 0,
    center = 1,
    mouse = 2,
    center_always = 3,
    center_on_parent = 4,
    _,

    extern fn gtk_window_position_get_type() usize;
    pub const getGObjectType = gtk_window_position_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gtk.Window` can be one of these types. Most things you’d consider a
/// “window” should have type `GTK_WINDOW_TOPLEVEL`; windows with this type
/// are managed by the window manager and have a frame by default (call
/// `gtk.Window.setDecorated` to toggle the frame).  Windows with type
/// `GTK_WINDOW_POPUP` are ignored by the window manager; window manager
/// keybindings won’t work on them, the window manager won’t decorate the
/// window with a frame, many GTK+ features that rely on the window
/// manager will not work (e.g. resize grips and
/// maximization/minimization). `GTK_WINDOW_POPUP` is used to implement
/// widgets such as `gtk.Menu` or tooltips that you normally don’t think of
/// as windows per se. Nearly all windows should be `GTK_WINDOW_TOPLEVEL`.
/// In particular, do not use `GTK_WINDOW_POPUP` just to turn off
/// the window borders; use `gtk.Window.setDecorated` for that.
pub const WindowType = enum(c_int) {
    toplevel = 0,
    popup = 1,
    _,

    extern fn gtk_window_type_get_type() usize;
    pub const getGObjectType = gtk_window_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes a type of line wrapping.
pub const WrapMode = enum(c_int) {
    none = 0,
    char = 1,
    word = 2,
    word_char = 3,
    _,

    extern fn gtk_wrap_mode_get_type() usize;
    pub const getGObjectType = gtk_wrap_mode_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Accelerator flags used with `gtk.AccelGroup.connect`.
pub const AccelFlags = packed struct(c_uint) {
    visible: bool = false,
    locked: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_visible: AccelFlags = @bitCast(@as(c_uint, 1));
    pub const flags_locked: AccelFlags = @bitCast(@as(c_uint, 2));
    pub const flags_mask: AccelFlags = @bitCast(@as(c_uint, 7));
    extern fn gtk_accel_flags_get_type() usize;
    pub const getGObjectType = gtk_accel_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Types of user actions that may be blocked by `gtk.Application.inhibit`.
pub const ApplicationInhibitFlags = packed struct(c_uint) {
    logout: bool = false,
    @"switch": bool = false,
    @"suspend": bool = false,
    idle: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_logout: ApplicationInhibitFlags = @bitCast(@as(c_uint, 1));
    pub const flags_switch: ApplicationInhibitFlags = @bitCast(@as(c_uint, 2));
    pub const flags_suspend: ApplicationInhibitFlags = @bitCast(@as(c_uint, 4));
    pub const flags_idle: ApplicationInhibitFlags = @bitCast(@as(c_uint, 8));
    extern fn gtk_application_inhibit_flags_get_type() usize;
    pub const getGObjectType = gtk_application_inhibit_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Denotes the expansion properties that a widget will have when it (or its
/// parent) is resized.
pub const AttachOptions = packed struct(c_uint) {
    expand: bool = false,
    shrink: bool = false,
    fill: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_expand: AttachOptions = @bitCast(@as(c_uint, 1));
    pub const flags_shrink: AttachOptions = @bitCast(@as(c_uint, 2));
    pub const flags_fill: AttachOptions = @bitCast(@as(c_uint, 4));
    extern fn gtk_attach_options_get_type() usize;
    pub const getGObjectType = gtk_attach_options_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// These options can be used to influence the display and behaviour of a `gtk.Calendar`.
pub const CalendarDisplayOptions = packed struct(c_uint) {
    show_heading: bool = false,
    show_day_names: bool = false,
    no_month_change: bool = false,
    show_week_numbers: bool = false,
    _padding4: bool = false,
    show_details: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_show_heading: CalendarDisplayOptions = @bitCast(@as(c_uint, 1));
    pub const flags_show_day_names: CalendarDisplayOptions = @bitCast(@as(c_uint, 2));
    pub const flags_no_month_change: CalendarDisplayOptions = @bitCast(@as(c_uint, 4));
    pub const flags_show_week_numbers: CalendarDisplayOptions = @bitCast(@as(c_uint, 8));
    pub const flags_show_details: CalendarDisplayOptions = @bitCast(@as(c_uint, 32));
    extern fn gtk_calendar_display_options_get_type() usize;
    pub const getGObjectType = gtk_calendar_display_options_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Tells how a cell is to be rendered.
pub const CellRendererState = packed struct(c_uint) {
    selected: bool = false,
    prelit: bool = false,
    insensitive: bool = false,
    sorted: bool = false,
    focused: bool = false,
    expandable: bool = false,
    expanded: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_selected: CellRendererState = @bitCast(@as(c_uint, 1));
    pub const flags_prelit: CellRendererState = @bitCast(@as(c_uint, 2));
    pub const flags_insensitive: CellRendererState = @bitCast(@as(c_uint, 4));
    pub const flags_sorted: CellRendererState = @bitCast(@as(c_uint, 8));
    pub const flags_focused: CellRendererState = @bitCast(@as(c_uint, 16));
    pub const flags_expandable: CellRendererState = @bitCast(@as(c_uint, 32));
    pub const flags_expanded: CellRendererState = @bitCast(@as(c_uint, 64));
    extern fn gtk_cell_renderer_state_get_type() usize;
    pub const getGObjectType = gtk_cell_renderer_state_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const DebugFlag = packed struct(c_uint) {
    misc: bool = false,
    plugsocket: bool = false,
    text: bool = false,
    tree: bool = false,
    updates: bool = false,
    keybindings: bool = false,
    multihead: bool = false,
    modules: bool = false,
    geometry: bool = false,
    icontheme: bool = false,
    printing: bool = false,
    builder: bool = false,
    size_request: bool = false,
    no_css_cache: bool = false,
    baselines: bool = false,
    pixel_cache: bool = false,
    no_pixel_cache: bool = false,
    interactive: bool = false,
    touchscreen: bool = false,
    actions: bool = false,
    resize: bool = false,
    layout: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_misc: DebugFlag = @bitCast(@as(c_uint, 1));
    pub const flags_plugsocket: DebugFlag = @bitCast(@as(c_uint, 2));
    pub const flags_text: DebugFlag = @bitCast(@as(c_uint, 4));
    pub const flags_tree: DebugFlag = @bitCast(@as(c_uint, 8));
    pub const flags_updates: DebugFlag = @bitCast(@as(c_uint, 16));
    pub const flags_keybindings: DebugFlag = @bitCast(@as(c_uint, 32));
    pub const flags_multihead: DebugFlag = @bitCast(@as(c_uint, 64));
    pub const flags_modules: DebugFlag = @bitCast(@as(c_uint, 128));
    pub const flags_geometry: DebugFlag = @bitCast(@as(c_uint, 256));
    pub const flags_icontheme: DebugFlag = @bitCast(@as(c_uint, 512));
    pub const flags_printing: DebugFlag = @bitCast(@as(c_uint, 1024));
    pub const flags_builder: DebugFlag = @bitCast(@as(c_uint, 2048));
    pub const flags_size_request: DebugFlag = @bitCast(@as(c_uint, 4096));
    pub const flags_no_css_cache: DebugFlag = @bitCast(@as(c_uint, 8192));
    pub const flags_baselines: DebugFlag = @bitCast(@as(c_uint, 16384));
    pub const flags_pixel_cache: DebugFlag = @bitCast(@as(c_uint, 32768));
    pub const flags_no_pixel_cache: DebugFlag = @bitCast(@as(c_uint, 65536));
    pub const flags_interactive: DebugFlag = @bitCast(@as(c_uint, 131072));
    pub const flags_touchscreen: DebugFlag = @bitCast(@as(c_uint, 262144));
    pub const flags_actions: DebugFlag = @bitCast(@as(c_uint, 524288));
    pub const flags_resize: DebugFlag = @bitCast(@as(c_uint, 1048576));
    pub const flags_layout: DebugFlag = @bitCast(@as(c_uint, 2097152));
    extern fn gtk_debug_flag_get_type() usize;
    pub const getGObjectType = gtk_debug_flag_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.DestDefaults` enumeration specifies the various
/// types of action that will be taken on behalf
/// of the user for a drag destination site.
pub const DestDefaults = packed struct(c_uint) {
    motion: bool = false,
    highlight: bool = false,
    drop: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_motion: DestDefaults = @bitCast(@as(c_uint, 1));
    pub const flags_highlight: DestDefaults = @bitCast(@as(c_uint, 2));
    pub const flags_drop: DestDefaults = @bitCast(@as(c_uint, 4));
    pub const flags_all: DestDefaults = @bitCast(@as(c_uint, 7));
    extern fn gtk_dest_defaults_get_type() usize;
    pub const getGObjectType = gtk_dest_defaults_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used to influence dialog construction.
pub const DialogFlags = packed struct(c_uint) {
    modal: bool = false,
    destroy_with_parent: bool = false,
    use_header_bar: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_modal: DialogFlags = @bitCast(@as(c_uint, 1));
    pub const flags_destroy_with_parent: DialogFlags = @bitCast(@as(c_uint, 2));
    pub const flags_use_header_bar: DialogFlags = @bitCast(@as(c_uint, 4));
    extern fn gtk_dialog_flags_get_type() usize;
    pub const getGObjectType = gtk_dialog_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes the behavior of a `gtk.EventControllerScroll`.
pub const EventControllerScrollFlags = packed struct(c_uint) {
    vertical: bool = false,
    horizontal: bool = false,
    discrete: bool = false,
    kinetic: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: EventControllerScrollFlags = @bitCast(@as(c_uint, 0));
    pub const flags_vertical: EventControllerScrollFlags = @bitCast(@as(c_uint, 1));
    pub const flags_horizontal: EventControllerScrollFlags = @bitCast(@as(c_uint, 2));
    pub const flags_discrete: EventControllerScrollFlags = @bitCast(@as(c_uint, 4));
    pub const flags_kinetic: EventControllerScrollFlags = @bitCast(@as(c_uint, 8));
    pub const flags_both_axes: EventControllerScrollFlags = @bitCast(@as(c_uint, 3));
    extern fn gtk_event_controller_scroll_flags_get_type() usize;
    pub const getGObjectType = gtk_event_controller_scroll_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// These flags indicate what parts of a `gtk.FileFilterInfo` struct
/// are filled or need to be filled.
pub const FileFilterFlags = packed struct(c_uint) {
    filename: bool = false,
    uri: bool = false,
    display_name: bool = false,
    mime_type: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_filename: FileFilterFlags = @bitCast(@as(c_uint, 1));
    pub const flags_uri: FileFilterFlags = @bitCast(@as(c_uint, 2));
    pub const flags_display_name: FileFilterFlags = @bitCast(@as(c_uint, 4));
    pub const flags_mime_type: FileFilterFlags = @bitCast(@as(c_uint, 8));
    extern fn gtk_file_filter_flags_get_type() usize;
    pub const getGObjectType = gtk_file_filter_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// This enumeration specifies the granularity of font selection
/// that is desired in a font chooser.
///
/// This enumeration may be extended in the future; applications should
/// ignore unknown values.
pub const FontChooserLevel = packed struct(c_uint) {
    style: bool = false,
    size: bool = false,
    variations: bool = false,
    features: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_family: FontChooserLevel = @bitCast(@as(c_uint, 0));
    pub const flags_style: FontChooserLevel = @bitCast(@as(c_uint, 1));
    pub const flags_size: FontChooserLevel = @bitCast(@as(c_uint, 2));
    pub const flags_variations: FontChooserLevel = @bitCast(@as(c_uint, 4));
    pub const flags_features: FontChooserLevel = @bitCast(@as(c_uint, 8));
    extern fn gtk_font_chooser_level_get_type() usize;
    pub const getGObjectType = gtk_font_chooser_level_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used to specify options for `gtk.IconTheme.lookupIcon`
pub const IconLookupFlags = packed struct(c_uint) {
    no_svg: bool = false,
    force_svg: bool = false,
    use_builtin: bool = false,
    generic_fallback: bool = false,
    force_size: bool = false,
    force_regular: bool = false,
    force_symbolic: bool = false,
    dir_ltr: bool = false,
    dir_rtl: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_no_svg: IconLookupFlags = @bitCast(@as(c_uint, 1));
    pub const flags_force_svg: IconLookupFlags = @bitCast(@as(c_uint, 2));
    pub const flags_use_builtin: IconLookupFlags = @bitCast(@as(c_uint, 4));
    pub const flags_generic_fallback: IconLookupFlags = @bitCast(@as(c_uint, 8));
    pub const flags_force_size: IconLookupFlags = @bitCast(@as(c_uint, 16));
    pub const flags_force_regular: IconLookupFlags = @bitCast(@as(c_uint, 32));
    pub const flags_force_symbolic: IconLookupFlags = @bitCast(@as(c_uint, 64));
    pub const flags_dir_ltr: IconLookupFlags = @bitCast(@as(c_uint, 128));
    pub const flags_dir_rtl: IconLookupFlags = @bitCast(@as(c_uint, 256));
    extern fn gtk_icon_lookup_flags_get_type() usize;
    pub const getGObjectType = gtk_icon_lookup_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes hints that might be taken into account by input methods
/// or applications. Note that input methods may already tailor their
/// behaviour according to the `gtk.InputPurpose` of the entry.
///
/// Some common sense is expected when using these flags - mixing
/// `GTK_INPUT_HINT_LOWERCASE` with any of the uppercase hints makes no sense.
///
/// This enumeration may be extended in the future; input methods should
/// ignore unknown values.
pub const InputHints = packed struct(c_uint) {
    spellcheck: bool = false,
    no_spellcheck: bool = false,
    word_completion: bool = false,
    lowercase: bool = false,
    uppercase_chars: bool = false,
    uppercase_words: bool = false,
    uppercase_sentences: bool = false,
    inhibit_osk: bool = false,
    vertical_writing: bool = false,
    emoji: bool = false,
    no_emoji: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: InputHints = @bitCast(@as(c_uint, 0));
    pub const flags_spellcheck: InputHints = @bitCast(@as(c_uint, 1));
    pub const flags_no_spellcheck: InputHints = @bitCast(@as(c_uint, 2));
    pub const flags_word_completion: InputHints = @bitCast(@as(c_uint, 4));
    pub const flags_lowercase: InputHints = @bitCast(@as(c_uint, 8));
    pub const flags_uppercase_chars: InputHints = @bitCast(@as(c_uint, 16));
    pub const flags_uppercase_words: InputHints = @bitCast(@as(c_uint, 32));
    pub const flags_uppercase_sentences: InputHints = @bitCast(@as(c_uint, 64));
    pub const flags_inhibit_osk: InputHints = @bitCast(@as(c_uint, 128));
    pub const flags_vertical_writing: InputHints = @bitCast(@as(c_uint, 256));
    pub const flags_emoji: InputHints = @bitCast(@as(c_uint, 512));
    pub const flags_no_emoji: InputHints = @bitCast(@as(c_uint, 1024));
    extern fn gtk_input_hints_get_type() usize;
    pub const getGObjectType = gtk_input_hints_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes how a rendered element connects to adjacent elements.
pub const JunctionSides = packed struct(c_uint) {
    corner_topleft: bool = false,
    corner_topright: bool = false,
    corner_bottomleft: bool = false,
    corner_bottomright: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: JunctionSides = @bitCast(@as(c_uint, 0));
    pub const flags_corner_topleft: JunctionSides = @bitCast(@as(c_uint, 1));
    pub const flags_corner_topright: JunctionSides = @bitCast(@as(c_uint, 2));
    pub const flags_corner_bottomleft: JunctionSides = @bitCast(@as(c_uint, 4));
    pub const flags_corner_bottomright: JunctionSides = @bitCast(@as(c_uint, 8));
    pub const flags_top: JunctionSides = @bitCast(@as(c_uint, 3));
    pub const flags_bottom: JunctionSides = @bitCast(@as(c_uint, 12));
    pub const flags_left: JunctionSides = @bitCast(@as(c_uint, 5));
    pub const flags_right: JunctionSides = @bitCast(@as(c_uint, 10));
    extern fn gtk_junction_sides_get_type() usize;
    pub const getGObjectType = gtk_junction_sides_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// These flags serve two purposes.  First, the application can call `gtk.PlacesSidebar.setOpenFlags`
/// using these flags as a bitmask.  This tells the sidebar that the application is able to open
/// folders selected from the sidebar in various ways, for example, in new tabs or in new windows in
/// addition to the normal mode.
///
/// Second, when one of these values gets passed back to the application in the
/// `gtk.PlacesSidebar.signals.open`-location signal, it means that the application should
/// open the selected location in the normal way, in a new tab, or in a new
/// window.  The sidebar takes care of determining the desired way to open the location,
/// based on the modifier keys that the user is pressing at the time the selection is made.
///
/// If the application never calls `gtk.PlacesSidebar.setOpenFlags`, then the sidebar will only
/// use `GTK_PLACES_OPEN_NORMAL` in the `gtk.PlacesSidebar.signals.open`-location signal.  This is the
/// default mode of operation.
pub const PlacesOpenFlags = packed struct(c_uint) {
    normal: bool = false,
    new_tab: bool = false,
    new_window: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_normal: PlacesOpenFlags = @bitCast(@as(c_uint, 1));
    pub const flags_new_tab: PlacesOpenFlags = @bitCast(@as(c_uint, 2));
    pub const flags_new_window: PlacesOpenFlags = @bitCast(@as(c_uint, 4));
    extern fn gtk_places_open_flags_get_type() usize;
    pub const getGObjectType = gtk_places_open_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Deprecated
pub const RcFlags = packed struct(c_uint) {
    fg: bool = false,
    bg: bool = false,
    text: bool = false,
    base: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_fg: RcFlags = @bitCast(@as(c_uint, 1));
    pub const flags_bg: RcFlags = @bitCast(@as(c_uint, 2));
    pub const flags_text: RcFlags = @bitCast(@as(c_uint, 4));
    pub const flags_base: RcFlags = @bitCast(@as(c_uint, 8));
    extern fn gtk_rc_flags_get_type() usize;
    pub const getGObjectType = gtk_rc_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// These flags indicate what parts of a `gtk.RecentFilterInfo` struct
/// are filled or need to be filled.
pub const RecentFilterFlags = packed struct(c_uint) {
    uri: bool = false,
    display_name: bool = false,
    mime_type: bool = false,
    application: bool = false,
    group: bool = false,
    age: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_uri: RecentFilterFlags = @bitCast(@as(c_uint, 1));
    pub const flags_display_name: RecentFilterFlags = @bitCast(@as(c_uint, 2));
    pub const flags_mime_type: RecentFilterFlags = @bitCast(@as(c_uint, 4));
    pub const flags_application: RecentFilterFlags = @bitCast(@as(c_uint, 8));
    pub const flags_group: RecentFilterFlags = @bitCast(@as(c_uint, 16));
    pub const flags_age: RecentFilterFlags = @bitCast(@as(c_uint, 32));
    extern fn gtk_recent_filter_flags_get_type() usize;
    pub const getGObjectType = gtk_recent_filter_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes a region within a widget.
pub const RegionFlags = packed struct(c_uint) {
    even: bool = false,
    odd: bool = false,
    first: bool = false,
    last: bool = false,
    only: bool = false,
    sorted: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_even: RegionFlags = @bitCast(@as(c_uint, 1));
    pub const flags_odd: RegionFlags = @bitCast(@as(c_uint, 2));
    pub const flags_first: RegionFlags = @bitCast(@as(c_uint, 4));
    pub const flags_last: RegionFlags = @bitCast(@as(c_uint, 8));
    pub const flags_only: RegionFlags = @bitCast(@as(c_uint, 16));
    pub const flags_sorted: RegionFlags = @bitCast(@as(c_uint, 32));
    extern fn gtk_region_flags_get_type() usize;
    pub const getGObjectType = gtk_region_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes a widget state. Widget states are used to match the widget
/// against CSS pseudo-classes. Note that GTK extends the regular CSS
/// classes and sometimes uses different names.
pub const StateFlags = packed struct(c_uint) {
    active: bool = false,
    prelight: bool = false,
    selected: bool = false,
    insensitive: bool = false,
    inconsistent: bool = false,
    focused: bool = false,
    backdrop: bool = false,
    dir_ltr: bool = false,
    dir_rtl: bool = false,
    link: bool = false,
    visited: bool = false,
    checked: bool = false,
    drop_active: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_normal: StateFlags = @bitCast(@as(c_uint, 0));
    pub const flags_active: StateFlags = @bitCast(@as(c_uint, 1));
    pub const flags_prelight: StateFlags = @bitCast(@as(c_uint, 2));
    pub const flags_selected: StateFlags = @bitCast(@as(c_uint, 4));
    pub const flags_insensitive: StateFlags = @bitCast(@as(c_uint, 8));
    pub const flags_inconsistent: StateFlags = @bitCast(@as(c_uint, 16));
    pub const flags_focused: StateFlags = @bitCast(@as(c_uint, 32));
    pub const flags_backdrop: StateFlags = @bitCast(@as(c_uint, 64));
    pub const flags_dir_ltr: StateFlags = @bitCast(@as(c_uint, 128));
    pub const flags_dir_rtl: StateFlags = @bitCast(@as(c_uint, 256));
    pub const flags_link: StateFlags = @bitCast(@as(c_uint, 512));
    pub const flags_visited: StateFlags = @bitCast(@as(c_uint, 1024));
    pub const flags_checked: StateFlags = @bitCast(@as(c_uint, 2048));
    pub const flags_drop_active: StateFlags = @bitCast(@as(c_uint, 4096));
    extern fn gtk_state_flags_get_type() usize;
    pub const getGObjectType = gtk_state_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags that modify the behavior of `gtk.StyleContext.toString`.
/// New values may be added to this enumeration.
pub const StyleContextPrintFlags = packed struct(c_uint) {
    recurse: bool = false,
    show_style: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: StyleContextPrintFlags = @bitCast(@as(c_uint, 0));
    pub const flags_recurse: StyleContextPrintFlags = @bitCast(@as(c_uint, 1));
    pub const flags_show_style: StyleContextPrintFlags = @bitCast(@as(c_uint, 2));
    extern fn gtk_style_context_print_flags_get_type() usize;
    pub const getGObjectType = gtk_style_context_print_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gtk.TargetFlags` enumeration is used to specify
/// constraints on a `gtk.TargetEntry`.
pub const TargetFlags = packed struct(c_uint) {
    same_app: bool = false,
    same_widget: bool = false,
    other_app: bool = false,
    other_widget: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_same_app: TargetFlags = @bitCast(@as(c_uint, 1));
    pub const flags_same_widget: TargetFlags = @bitCast(@as(c_uint, 2));
    pub const flags_other_app: TargetFlags = @bitCast(@as(c_uint, 4));
    pub const flags_other_widget: TargetFlags = @bitCast(@as(c_uint, 8));
    extern fn gtk_target_flags_get_type() usize;
    pub const getGObjectType = gtk_target_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags affecting how a search is done.
///
/// If neither `GTK_TEXT_SEARCH_VISIBLE_ONLY` nor `GTK_TEXT_SEARCH_TEXT_ONLY` are
/// enabled, the match must be exact; the special 0xFFFC character will match
/// embedded pixbufs or child widgets.
pub const TextSearchFlags = packed struct(c_uint) {
    visible_only: bool = false,
    text_only: bool = false,
    case_insensitive: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_visible_only: TextSearchFlags = @bitCast(@as(c_uint, 1));
    pub const flags_text_only: TextSearchFlags = @bitCast(@as(c_uint, 2));
    pub const flags_case_insensitive: TextSearchFlags = @bitCast(@as(c_uint, 4));
    extern fn gtk_text_search_flags_get_type() usize;
    pub const getGObjectType = gtk_text_search_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used to specify the supported drag targets.
pub const ToolPaletteDragTargets = packed struct(c_uint) {
    items: bool = false,
    groups: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_items: ToolPaletteDragTargets = @bitCast(@as(c_uint, 1));
    pub const flags_groups: ToolPaletteDragTargets = @bitCast(@as(c_uint, 2));
    extern fn gtk_tool_palette_drag_targets_get_type() usize;
    pub const getGObjectType = gtk_tool_palette_drag_targets_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// These flags indicate various properties of a `gtk.TreeModel`.
///
/// They are returned by `gtk.TreeModel.getFlags`, and must be
/// static for the lifetime of the object. A more complete description
/// of `GTK_TREE_MODEL_ITERS_PERSIST` can be found in the overview of
/// this section.
pub const TreeModelFlags = packed struct(c_uint) {
    iters_persist: bool = false,
    list_only: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_iters_persist: TreeModelFlags = @bitCast(@as(c_uint, 1));
    pub const flags_list_only: TreeModelFlags = @bitCast(@as(c_uint, 2));
    extern fn gtk_tree_model_flags_get_type() usize;
    pub const getGObjectType = gtk_tree_model_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// These enumeration values are used by `gtk.UIManager.addUi` to determine
/// what UI element to create.
pub const UIManagerItemType = packed struct(c_uint) {
    menubar: bool = false,
    menu: bool = false,
    toolbar: bool = false,
    placeholder: bool = false,
    popup: bool = false,
    menuitem: bool = false,
    toolitem: bool = false,
    separator: bool = false,
    accelerator: bool = false,
    popup_with_accels: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_auto: UIManagerItemType = @bitCast(@as(c_uint, 0));
    pub const flags_menubar: UIManagerItemType = @bitCast(@as(c_uint, 1));
    pub const flags_menu: UIManagerItemType = @bitCast(@as(c_uint, 2));
    pub const flags_toolbar: UIManagerItemType = @bitCast(@as(c_uint, 4));
    pub const flags_placeholder: UIManagerItemType = @bitCast(@as(c_uint, 8));
    pub const flags_popup: UIManagerItemType = @bitCast(@as(c_uint, 16));
    pub const flags_menuitem: UIManagerItemType = @bitCast(@as(c_uint, 32));
    pub const flags_toolitem: UIManagerItemType = @bitCast(@as(c_uint, 64));
    pub const flags_separator: UIManagerItemType = @bitCast(@as(c_uint, 128));
    pub const flags_accelerator: UIManagerItemType = @bitCast(@as(c_uint, 256));
    pub const flags_popup_with_accels: UIManagerItemType = @bitCast(@as(c_uint, 512));
    extern fn gtk_ui_manager_item_type_get_type() usize;
    pub const getGObjectType = gtk_ui_manager_item_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Finds the first accelerator in any `gtk.AccelGroup` attached
/// to `object` that matches `accel_key` and `accel_mods`, and
/// activates that accelerator.
extern fn gtk_accel_groups_activate(p_object: *gobject.Object, p_accel_key: c_uint, p_accel_mods: gdk.ModifierType) c_int;
pub const accelGroupsActivate = gtk_accel_groups_activate;

/// Gets a list of all accel groups which are attached to `object`.
extern fn gtk_accel_groups_from_object(p_object: *gobject.Object) *glib.SList;
pub const accelGroupsFromObject = gtk_accel_groups_from_object;

/// Gets the modifier mask.
///
/// The modifier mask determines which modifiers are considered significant
/// for keyboard accelerators. See `gtk.acceleratorSetDefaultModMask`.
extern fn gtk_accelerator_get_default_mod_mask() gdk.ModifierType;
pub const acceleratorGetDefaultModMask = gtk_accelerator_get_default_mod_mask;

/// Converts an accelerator keyval and modifier mask into a string
/// which can be used to represent the accelerator to the user.
extern fn gtk_accelerator_get_label(p_accelerator_key: c_uint, p_accelerator_mods: gdk.ModifierType) [*:0]u8;
pub const acceleratorGetLabel = gtk_accelerator_get_label;

/// Converts an accelerator keyval and modifier mask
/// into a (possibly translated) string that can be displayed to
/// a user, similarly to `gtk.acceleratorGetLabel`, but handling
/// keycodes.
///
/// This is only useful for system-level components, applications
/// should use `gtk.acceleratorParse` instead.
extern fn gtk_accelerator_get_label_with_keycode(p_display: ?*gdk.Display, p_accelerator_key: c_uint, p_keycode: c_uint, p_accelerator_mods: gdk.ModifierType) [*:0]u8;
pub const acceleratorGetLabelWithKeycode = gtk_accelerator_get_label_with_keycode;

/// Converts an accelerator keyval and modifier mask into a string
/// parseable by `gtk.acceleratorParse`. For example, if you pass in
/// `GDK_KEY_q` and `GDK_CONTROL_MASK`, this function returns “<Control>q”.
///
/// If you need to display accelerators in the user interface,
/// see `gtk.acceleratorGetLabel`.
extern fn gtk_accelerator_name(p_accelerator_key: c_uint, p_accelerator_mods: gdk.ModifierType) [*:0]u8;
pub const acceleratorName = gtk_accelerator_name;

/// Converts an accelerator keyval and modifier mask
/// into a string parseable by `gtk.acceleratorParseWithKeycode`,
/// similarly to `gtk.acceleratorName` but handling keycodes.
/// This is only useful for system-level components, applications
/// should use `gtk.acceleratorParse` instead.
extern fn gtk_accelerator_name_with_keycode(p_display: ?*gdk.Display, p_accelerator_key: c_uint, p_keycode: c_uint, p_accelerator_mods: gdk.ModifierType) [*:0]u8;
pub const acceleratorNameWithKeycode = gtk_accelerator_name_with_keycode;

/// Parses a string representing an accelerator. The format looks like
/// `<Control>a` or `<Shift><Alt>F1` or `<Release>z` (the last one is
/// for key release).
///
/// The parser is fairly liberal and allows lower or upper case, and also
/// abbreviations such as `<Ctl>` and `<Ctrl>`. Key names are parsed using
/// `gdk.keyvalFromName`. For character keys the name is not the symbol,
/// but the lowercase name, e.g. one would use `<Ctrl>minus` instead of
/// `<Ctrl>-`.
///
/// If the parse fails, `accelerator_key` and `accelerator_mods` will
/// be set to 0 (zero).
extern fn gtk_accelerator_parse(p_accelerator: [*:0]const u8, p_accelerator_key: ?*c_uint, p_accelerator_mods: ?*gdk.ModifierType) void;
pub const acceleratorParse = gtk_accelerator_parse;

/// Parses a string representing an accelerator, similarly to
/// `gtk.acceleratorParse` but handles keycodes as well. This is only
/// useful for system-level components, applications should use
/// `gtk.acceleratorParse` instead.
///
/// If `accelerator_codes` is given and the result stored in it is non-`NULL`,
/// the result must be freed with `glib.free`.
///
/// If a keycode is present in the accelerator and no `accelerator_codes`
/// is given, the parse will fail.
///
/// If the parse fails, `accelerator_key`, `accelerator_mods` and
/// `accelerator_codes` will be set to 0 (zero).
extern fn gtk_accelerator_parse_with_keycode(p_accelerator: [*:0]const u8, p_accelerator_key: ?*c_uint, p_accelerator_codes: ?*[*]c_uint, p_accelerator_mods: ?*gdk.ModifierType) void;
pub const acceleratorParseWithKeycode = gtk_accelerator_parse_with_keycode;

/// Sets the modifiers that will be considered significant for keyboard
/// accelerators. The default mod mask depends on the GDK backend in use,
/// but will typically include `GDK_CONTROL_MASK` | `GDK_SHIFT_MASK` |
/// `GDK_MOD1_MASK` | `GDK_SUPER_MASK` | `GDK_HYPER_MASK` | `GDK_META_MASK`.
/// In other words, Control, Shift, Alt, Super, Hyper and Meta. Other
/// modifiers will by default be ignored by `gtk.AccelGroup`.
///
/// You must include at least the three modifiers Control, Shift
/// and Alt in any value you pass to this function.
///
/// The default mod mask should be changed on application startup,
/// before using any accelerator groups.
extern fn gtk_accelerator_set_default_mod_mask(p_default_mod_mask: gdk.ModifierType) void;
pub const acceleratorSetDefaultModMask = gtk_accelerator_set_default_mod_mask;

/// Determines whether a given keyval and modifier mask constitute
/// a valid keyboard accelerator. For example, the `GDK_KEY_a` keyval
/// plus `GDK_CONTROL_MASK` is valid - this is a “Ctrl+a” accelerator.
/// But, you can't, for instance, use the `GDK_KEY_Control_L` keyval
/// as an accelerator.
extern fn gtk_accelerator_valid(p_keyval: c_uint, p_modifiers: gdk.ModifierType) c_int;
pub const acceleratorValid = gtk_accelerator_valid;

/// Returns `TRUE` if dialogs are expected to use an alternative
/// button order on the screen `screen`. See
/// `gtk.Dialog.setAlternativeButtonOrder` for more details
/// about alternative button order.
///
/// If you need to use this function, you should probably connect
/// to the ::notify:gtk-alternative-button-order signal on the
/// `gtk.Settings` object associated to `screen`, in order to be
/// notified if the button order setting changes.
extern fn gtk_alternative_dialog_button_order(p_screen: ?*gdk.Screen) c_int;
pub const alternativeDialogButtonOrder = gtk_alternative_dialog_button_order;

/// Find a key binding matching `keyval` and `modifiers` and activate the
/// binding on `object`.
extern fn gtk_bindings_activate(p_object: *gobject.Object, p_keyval: c_uint, p_modifiers: gdk.ModifierType) c_int;
pub const bindingsActivate = gtk_bindings_activate;

/// Looks up key bindings for `object` to find one matching
/// `event`, and if one was found, activate it.
extern fn gtk_bindings_activate_event(p_object: *gobject.Object, p_event: *gdk.EventKey) c_int;
pub const bindingsActivateEvent = gtk_bindings_activate_event;

/// This function is supposed to be called in `gtk.Widget.signals.draw`
/// implementations for widgets that support multiple windows.
/// `cr` must be untransformed from invoking of the draw function.
/// This function will return `TRUE` if the contents of the given
/// `window` are supposed to be drawn and `FALSE` otherwise. Note
/// that when the drawing was not initiated by the windowing
/// system this function will return `TRUE` for all windows, so
/// you need to draw the bottommost window first. Also, do not
/// use “else if” statements to check which window should be drawn.
extern fn gtk_cairo_should_draw_window(p_cr: *cairo.Context, p_window: *gdk.Window) c_int;
pub const cairoShouldDrawWindow = gtk_cairo_should_draw_window;

/// Transforms the given cairo context `cr` that from `widget`-relative
/// coordinates to `window`-relative coordinates.
/// If the `widget`’s window is not an ancestor of `window`, no
/// modification will be applied.
///
/// This is the inverse to the transformation GTK applies when
/// preparing an expose event to be emitted with the `gtk.Widget.signals.draw`
/// signal. It is intended to help porting multiwindow widgets from
/// GTK+ 2 to the rendering architecture of GTK+ 3.
extern fn gtk_cairo_transform_to_window(p_cr: *cairo.Context, p_widget: *gtk.Widget, p_window: *gdk.Window) void;
pub const cairoTransformToWindow = gtk_cairo_transform_to_window;

/// Checks that the GTK+ library in use is compatible with the
/// given version. Generally you would pass in the constants
/// `GTK_MAJOR_VERSION`, `GTK_MINOR_VERSION`, `GTK_MICRO_VERSION`
/// as the three arguments to this function; that produces
/// a check that the library in use is compatible with
/// the version of GTK+ the application or module was compiled
/// against.
///
/// Compatibility is defined by two things: first the version
/// of the running library is newer than the version
/// `required_major`.required_minor.`required_micro`. Second
/// the running library must be binary compatible with the
/// version `required_major`.required_minor.`required_micro`
/// (same major version.)
///
/// This function is primarily for GTK+ modules; the module
/// can call this function to check that it wasn’t loaded
/// into an incompatible version of GTK+. However, such a
/// check isn’t completely reliable, since the module may be
/// linked against an old version of GTK+ and calling the
/// old version of `gtk.checkVersion`, but still get loaded
/// into an application using a newer version of GTK+.
extern fn gtk_check_version(p_required_major: c_uint, p_required_minor: c_uint, p_required_micro: c_uint) ?[*:0]const u8;
pub const checkVersion = gtk_check_version;

/// Adds a GTK+ grab on `device`, so all the events on `device` and its
/// associated pointer or keyboard (if any) are delivered to `widget`.
/// If the `block_others` parameter is `TRUE`, any other devices will be
/// unable to interact with `widget` during the grab.
extern fn gtk_device_grab_add(p_widget: *gtk.Widget, p_device: *gdk.Device, p_block_others: c_int) void;
pub const deviceGrabAdd = gtk_device_grab_add;

/// Removes a device grab from the given widget.
///
/// You have to pair calls to `gtk.deviceGrabAdd` and
/// `gtk.deviceGrabRemove`.
extern fn gtk_device_grab_remove(p_widget: *gtk.Widget, p_device: *gdk.Device) void;
pub const deviceGrabRemove = gtk_device_grab_remove;

/// Prevents `gtk.init`, `gtk.initCheck`, `gtk.initWithArgs` and
/// `gtk.parseArgs` from automatically
/// calling `setlocale (LC_ALL, "")`. You would
/// want to use this function if you wanted to set the locale for
/// your program to something other than the user’s locale, or if
/// you wanted to set different values for different locale categories.
///
/// Most programs should not need to call this function.
extern fn gtk_disable_setlocale() void;
pub const disableSetlocale = gtk_disable_setlocale;

/// Distributes `extra_space` to child `sizes` by bringing smaller
/// children up to natural size first.
///
/// The remaining space will be added to the `minimum_size` member of the
/// GtkRequestedSize struct. If all sizes reach their natural size then
/// the remaining space is returned.
extern fn gtk_distribute_natural_allocation(p_extra_space: c_int, p_n_requested_sizes: c_uint, p_sizes: *gtk.RequestedSize) c_int;
pub const distributeNaturalAllocation = gtk_distribute_natural_allocation;

/// Cancels an ongoing drag operation on the source side.
///
/// If you want to be able to cancel a drag operation in this way,
/// you need to keep a pointer to the drag context, either from an
/// explicit call to `gtk.Widget.dragBeginWithCoordinates`, or by
/// connecting to `gtk.Widget.signals.drag`-begin.
///
/// If `context` does not refer to an ongoing drag operation, this
/// function does nothing.
///
/// If a drag is cancelled in this way, the `result` argument of
/// `gtk.Widget.signals.drag`-failed is set to `GTK_DRAG_RESULT_ERROR`.
extern fn gtk_drag_cancel(p_context: *gdk.DragContext) void;
pub const dragCancel = gtk_drag_cancel;

/// Informs the drag source that the drop is finished, and
/// that the data of the drag will no longer be required.
extern fn gtk_drag_finish(p_context: *gdk.DragContext, p_success: c_int, p_del: c_int, p_time_: u32) void;
pub const dragFinish = gtk_drag_finish;

/// Determines the source widget for a drag.
extern fn gtk_drag_get_source_widget(p_context: *gdk.DragContext) ?*gtk.Widget;
pub const dragGetSourceWidget = gtk_drag_get_source_widget;

/// Sets the icon for a particular drag to the default
/// icon.
extern fn gtk_drag_set_icon_default(p_context: *gdk.DragContext) void;
pub const dragSetIconDefault = gtk_drag_set_icon_default;

/// Sets the icon for a given drag from the given `icon`.
/// See the documentation for `gtk.dragSetIconName`
/// for more details about using icons in drag and drop.
extern fn gtk_drag_set_icon_gicon(p_context: *gdk.DragContext, p_icon: *gio.Icon, p_hot_x: c_int, p_hot_y: c_int) void;
pub const dragSetIconGicon = gtk_drag_set_icon_gicon;

/// Sets the icon for a given drag from a named themed icon. See
/// the docs for `gtk.IconTheme` for more details. Note that the
/// size of the icon depends on the icon theme (the icon is
/// loaded at the symbolic size `GTK_ICON_SIZE_DND`), thus
/// `hot_x` and `hot_y` have to be used with care.
extern fn gtk_drag_set_icon_name(p_context: *gdk.DragContext, p_icon_name: [*:0]const u8, p_hot_x: c_int, p_hot_y: c_int) void;
pub const dragSetIconName = gtk_drag_set_icon_name;

/// Sets `pixbuf` as the icon for a given drag.
extern fn gtk_drag_set_icon_pixbuf(p_context: *gdk.DragContext, p_pixbuf: *gdkpixbuf.Pixbuf, p_hot_x: c_int, p_hot_y: c_int) void;
pub const dragSetIconPixbuf = gtk_drag_set_icon_pixbuf;

/// Sets the icon for a given drag from a stock ID.
extern fn gtk_drag_set_icon_stock(p_context: *gdk.DragContext, p_stock_id: [*:0]const u8, p_hot_x: c_int, p_hot_y: c_int) void;
pub const dragSetIconStock = gtk_drag_set_icon_stock;

/// Sets `surface` as the icon for a given drag. GTK+ retains
/// references for the arguments, and will release them when
/// they are no longer needed.
///
/// To position the surface relative to the mouse, use
/// `cairo_surface_set_device_offset` on `surface`. The mouse
/// cursor will be positioned at the (0,0) coordinate of the
/// surface.
extern fn gtk_drag_set_icon_surface(p_context: *gdk.DragContext, p_surface: *cairo.Surface) void;
pub const dragSetIconSurface = gtk_drag_set_icon_surface;

/// Changes the icon for drag operation to a given widget.
/// GTK+ will not destroy the widget, so if you don’t want
/// it to persist, you should connect to the “drag-end”
/// signal and destroy it yourself.
extern fn gtk_drag_set_icon_widget(p_context: *gdk.DragContext, p_widget: *gtk.Widget, p_hot_x: c_int, p_hot_y: c_int) void;
pub const dragSetIconWidget = gtk_drag_set_icon_widget;

/// Draws a text caret on `cr` at `location`. This is not a style function
/// but merely a convenience function for drawing the standard cursor shape.
extern fn gtk_draw_insertion_cursor(p_widget: *gtk.Widget, p_cr: *cairo.Context, p_location: *const gdk.Rectangle, p_is_primary: c_int, p_direction: gtk.TextDirection, p_draw_arrow: c_int) void;
pub const drawInsertionCursor = gtk_draw_insertion_cursor;

/// Checks if any events are pending.
///
/// This can be used to update the UI and invoke timeouts etc.
/// while doing some time intensive computation.
///
/// ## Updating the UI during a long computation
///
/// ```
///  // computation going on...
///
///  while (gtk_events_pending ())
///    gtk_main_iteration ();
///
///  // ...computation continued
/// ```
extern fn gtk_events_pending() c_int;
pub const eventsPending = gtk_events_pending;

/// Analogical to `gtk.@"true"`, this function does nothing
/// but always returns `FALSE`.
extern fn gtk_false() c_int;
pub const @"false" = gtk_false;

/// Returns the binary age as passed to `libtool`
/// when building the GTK+ library the process is running against.
/// If `libtool` means nothing to you, don't
/// worry about it.
extern fn gtk_get_binary_age() c_uint;
pub const getBinaryAge = gtk_get_binary_age;

/// Obtains a copy of the event currently being processed by GTK+.
///
/// For example, if you are handling a `gtk.Button.signals.clicked` signal,
/// the current event will be the `gdk.EventButton` that triggered
/// the ::clicked signal.
extern fn gtk_get_current_event() ?*gdk.Event;
pub const getCurrentEvent = gtk_get_current_event;

/// If there is a current event and it has a device, return that
/// device, otherwise return `NULL`.
extern fn gtk_get_current_event_device() ?*gdk.Device;
pub const getCurrentEventDevice = gtk_get_current_event_device;

/// If there is a current event and it has a state field, place
/// that state field in `state` and return `TRUE`, otherwise return
/// `FALSE`.
extern fn gtk_get_current_event_state(p_state: *gdk.ModifierType) c_int;
pub const getCurrentEventState = gtk_get_current_event_state;

/// If there is a current event and it has a timestamp,
/// return that timestamp, otherwise return `GDK_CURRENT_TIME`.
extern fn gtk_get_current_event_time() u32;
pub const getCurrentEventTime = gtk_get_current_event_time;

/// Returns the GTK+ debug flags.
///
/// This function is intended for GTK+ modules that want
/// to adjust their debug output based on GTK+ debug flags.
extern fn gtk_get_debug_flags() c_uint;
pub const getDebugFlags = gtk_get_debug_flags;

/// Returns the `pango.Language` for the default language currently in
/// effect. (Note that this can change over the life of an
/// application.) The default language is derived from the current
/// locale. It determines, for example, whether GTK+ uses the
/// right-to-left or left-to-right text direction.
///
/// This function is equivalent to `pango.languageGetDefault`.
/// See that function for details.
extern fn gtk_get_default_language() *pango.Language;
pub const getDefaultLanguage = gtk_get_default_language;

/// If `event` is `NULL` or the event was not associated with any widget,
/// returns `NULL`, otherwise returns the widget that received the event
/// originally.
extern fn gtk_get_event_widget(p_event: *gdk.Event) ?*gtk.Widget;
pub const getEventWidget = gtk_get_event_widget;

/// Returns the interface age as passed to `libtool`
/// when building the GTK+ library the process is running against.
/// If `libtool` means nothing to you, don't
/// worry about it.
extern fn gtk_get_interface_age() c_uint;
pub const getInterfaceAge = gtk_get_interface_age;

/// Get the direction of the current locale. This is the expected
/// reading direction for text and UI.
///
/// This function depends on the current locale being set with
/// `setlocale` and will default to setting the `GTK_TEXT_DIR_LTR`
/// direction otherwise. `GTK_TEXT_DIR_NONE` will never be returned.
///
/// GTK+ sets the default text direction according to the locale
/// during `gtk.init`, and you should normally use
/// `gtk.Widget.getDirection` or `gtk.Widget.getDefaultDirection`
/// to obtain the current direcion.
///
/// This function is only needed rare cases when the locale is
/// changed after GTK+ has already been initialized. In this case,
/// you can use it to update the default text direction as follows:
///
/// ```
/// setlocale (LC_ALL, new_locale);
/// direction = gtk_get_locale_direction ();
/// gtk_widget_set_default_direction (direction);
/// ```
extern fn gtk_get_locale_direction() gtk.TextDirection;
pub const getLocaleDirection = gtk_get_locale_direction;

/// Returns the major version number of the GTK+ library.
/// (e.g. in GTK+ version 3.1.5 this is 3.)
///
/// This function is in the library, so it represents the GTK+ library
/// your code is running against. Contrast with the `GTK_MAJOR_VERSION`
/// macro, which represents the major version of the GTK+ headers you
/// have included when compiling your code.
extern fn gtk_get_major_version() c_uint;
pub const getMajorVersion = gtk_get_major_version;

/// Returns the micro version number of the GTK+ library.
/// (e.g. in GTK+ version 3.1.5 this is 5.)
///
/// This function is in the library, so it represents the GTK+ library
/// your code is are running against. Contrast with the
/// `GTK_MICRO_VERSION` macro, which represents the micro version of the
/// GTK+ headers you have included when compiling your code.
extern fn gtk_get_micro_version() c_uint;
pub const getMicroVersion = gtk_get_micro_version;

/// Returns the minor version number of the GTK+ library.
/// (e.g. in GTK+ version 3.1.5 this is 1.)
///
/// This function is in the library, so it represents the GTK+ library
/// your code is are running against. Contrast with the
/// `GTK_MINOR_VERSION` macro, which represents the minor version of the
/// GTK+ headers you have included when compiling your code.
extern fn gtk_get_minor_version() c_uint;
pub const getMinorVersion = gtk_get_minor_version;

/// Returns a `glib.OptionGroup` for the commandline arguments recognized
/// by GTK+ and GDK.
///
/// You should add this group to your `glib.OptionContext`
/// with `glib.OptionContext.addGroup`, if you are using
/// `glib.OptionContext.parse` to parse your commandline arguments.
extern fn gtk_get_option_group(p_open_default_display: c_int) *glib.OptionGroup;
pub const getOptionGroup = gtk_get_option_group;

/// Queries the current grab of the default window group.
extern fn gtk_grab_get_current() ?*gtk.Widget;
pub const grabGetCurrent = gtk_grab_get_current;

/// Call this function before using any other GTK+ functions in your GUI
/// applications.  It will initialize everything needed to operate the
/// toolkit and parses some standard command line options.
///
/// Although you are expected to pass the `argc`, `argv` parameters from `main` to
/// this function, it is possible to pass `NULL` if `argv` is not available or
/// commandline handling is not required.
///
/// `argc` and `argv` are adjusted accordingly so your own code will
/// never see those standard arguments.
///
/// Note that there are some alternative ways to initialize GTK+:
/// if you are calling `gtk.parseArgs`, `gtk.initCheck`,
/// `gtk.initWithArgs` or `glib.OptionContext.parse` with
/// the option group returned by `gtk.getOptionGroup`,
/// you don’t have to call `gtk.init`.
///
/// And if you are using `gtk.Application`, you don't have to call any of the
/// initialization functions either; the `gtk.Application.signals.startup` handler
/// does it for you.
///
/// This function will terminate your program if it was unable to
/// initialize the windowing system for some reason. If you want
/// your program to fall back to a textual interface you want to
/// call `gtk.initCheck` instead.
///
/// Since 2.18, GTK+ calls `signal (SIGPIPE, SIG_IGN)`
/// during initialization, to ignore SIGPIPE signals, since these are
/// almost never wanted in graphical applications. If you do need to
/// handle SIGPIPE for some reason, reset the handler after `gtk.init`,
/// but notice that other libraries (e.g. libdbus or gvfs) might do
/// similar things.
extern fn gtk_init(p_argc: *c_int, p_argv: ?*[*][*:0]u8) void;
pub const init = gtk_init;

/// This function does the same work as `gtk.init` with only a single
/// change: It does not terminate the program if the commandline
/// arguments couldn’t be parsed or the windowing system can’t be
/// initialized. Instead it returns `FALSE` on failure.
///
/// This way the application can fall back to some other means of
/// communication with the user - for example a curses or command line
/// interface.
///
/// Note that calling any GTK function or instantiating any GTK type after
/// this function returns `FALSE` results in undefined behavior.
extern fn gtk_init_check(p_argc: *c_int, p_argv: ?*[*][*:0]u8) c_int;
pub const initCheck = gtk_init_check;

/// This function does the same work as `gtk.initCheck`.
/// Additionally, it allows you to add your own commandline options,
/// and it automatically generates nicely formatted
/// `--help` output. Note that your program will
/// be terminated after writing out the help output.
extern fn gtk_init_with_args(p_argc: *c_int, p_argv: ?*[*][*:0]u8, p_parameter_string: ?[*:0]const u8, p_entries: [*]const glib.OptionEntry, p_translation_domain: ?[*:0]const u8, p_error: ?*?*glib.Error) c_int;
pub const initWithArgs = gtk_init_with_args;

/// Installs a key snooper function, which will get called on all
/// key events before delivering them normally.
extern fn gtk_key_snooper_install(p_snooper: gtk.KeySnoopFunc, p_func_data: ?*anyopaque) c_uint;
pub const keySnooperInstall = gtk_key_snooper_install;

/// Removes the key snooper function with the given id.
extern fn gtk_key_snooper_remove(p_snooper_handler_id: c_uint) void;
pub const keySnooperRemove = gtk_key_snooper_remove;

/// Runs the main loop until `gtk.mainQuit` is called.
///
/// You can nest calls to `gtk.main`. In that case `gtk.mainQuit`
/// will make the innermost invocation of the main loop return.
extern fn gtk_main() void;
pub const main = gtk_main;

/// Processes a single GDK event.
///
/// This is public only to allow filtering of events between GDK and GTK+.
/// You will not usually need to call this function directly.
///
/// While you should not call this function directly, you might want to
/// know how exactly events are handled. So here is what this function
/// does with the event:
///
/// 1. Compress enter/leave notify events. If the event passed build an
///    enter/leave pair together with the next event (peeked from GDK), both
///    events are thrown away. This is to avoid a backlog of (de-)highlighting
///    widgets crossed by the pointer.
///
/// 2. Find the widget which got the event. If the widget can’t be determined
///    the event is thrown away unless it belongs to a INCR transaction.
///
/// 3. Then the event is pushed onto a stack so you can query the currently
///    handled event with `gtk.getCurrentEvent`.
///
/// 4. The event is sent to a widget. If a grab is active all events for widgets
///    that are not in the contained in the grab widget are sent to the latter
///    with a few exceptions:
///    - Deletion and destruction events are still sent to the event widget for
///      obvious reasons.
///    - Events which directly relate to the visual representation of the event
///      widget.
///    - Leave events are delivered to the event widget if there was an enter
///      event delivered to it before without the paired leave event.
///    - Drag events are not redirected because it is unclear what the semantics
///      of that would be.
///    Another point of interest might be that all key events are first passed
///    through the key snooper functions if there are any. Read the description
///    of `gtk.keySnooperInstall` if you need this feature.
///
/// 5. After finishing the delivery the event is popped from the event stack.
extern fn gtk_main_do_event(p_event: *gdk.Event) void;
pub const mainDoEvent = gtk_main_do_event;

/// Runs a single iteration of the mainloop.
///
/// If no events are waiting to be processed GTK+ will block
/// until the next event is noticed. If you don’t want to block
/// look at `gtk.mainIterationDo` or check if any events are
/// pending with `gtk.eventsPending` first.
extern fn gtk_main_iteration() c_int;
pub const mainIteration = gtk_main_iteration;

/// Runs a single iteration of the mainloop.
/// If no events are available either return or block depending on
/// the value of `blocking`.
extern fn gtk_main_iteration_do(p_blocking: c_int) c_int;
pub const mainIterationDo = gtk_main_iteration_do;

/// Asks for the current nesting level of the main loop.
extern fn gtk_main_level() c_uint;
pub const mainLevel = gtk_main_level;

/// Makes the innermost invocation of the main loop return
/// when it regains control.
extern fn gtk_main_quit() void;
pub const mainQuit = gtk_main_quit;

/// Draws an arrow in the given rectangle on `cr` using the given
/// parameters. `arrow_type` determines the direction of the arrow.
extern fn gtk_paint_arrow(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_arrow_type: gtk.ArrowType, p_fill: c_int, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void;
pub const paintArrow = gtk_paint_arrow;

/// Draws a box on `cr` with the given parameters.
extern fn gtk_paint_box(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void;
pub const paintBox = gtk_paint_box;

/// Draws a box in `cr` using the given style and state and shadow type,
/// leaving a gap in one side.
extern fn gtk_paint_box_gap(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_gap_side: gtk.PositionType, p_gap_x: c_int, p_gap_width: c_int) void;
pub const paintBoxGap = gtk_paint_box_gap;

/// Draws a check button indicator in the given rectangle on `cr` with
/// the given parameters.
extern fn gtk_paint_check(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void;
pub const paintCheck = gtk_paint_check;

/// Draws a diamond in the given rectangle on `window` using the given
/// parameters.
extern fn gtk_paint_diamond(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void;
pub const paintDiamond = gtk_paint_diamond;

/// Draws an expander as used in `gtk.TreeView`. `x` and `y` specify the
/// center the expander. The size of the expander is determined by the
/// “expander-size” style property of `widget`.  (If widget is not
/// specified or doesn’t have an “expander-size” property, an
/// unspecified default size will be used, since the caller doesn't
/// have sufficient information to position the expander, this is
/// likely not useful.) The expander is expander_size pixels tall
/// in the collapsed position and expander_size pixels wide in the
/// expanded position.
extern fn gtk_paint_expander(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x: c_int, p_y: c_int, p_expander_style: gtk.ExpanderStyle) void;
pub const paintExpander = gtk_paint_expander;

/// Draws an extension, i.e. a notebook tab.
extern fn gtk_paint_extension(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_gap_side: gtk.PositionType) void;
pub const paintExtension = gtk_paint_extension;

/// Draws a flat box on `cr` with the given parameters.
extern fn gtk_paint_flat_box(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void;
pub const paintFlatBox = gtk_paint_flat_box;

/// Draws a focus indicator around the given rectangle on `cr` using the
/// given style.
extern fn gtk_paint_focus(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void;
pub const paintFocus = gtk_paint_focus;

/// Draws a handle as used in `gtk.HandleBox` and `gtk.Paned`.
extern fn gtk_paint_handle(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_orientation: gtk.Orientation) void;
pub const paintHandle = gtk_paint_handle;

/// Draws a horizontal line from (`x1`, `y`) to (`x2`, `y`) in `cr`
/// using the given style and state.
extern fn gtk_paint_hline(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x1: c_int, p_x2: c_int, p_y: c_int) void;
pub const paintHline = gtk_paint_hline;

/// Draws a layout on `cr` using the given parameters.
extern fn gtk_paint_layout(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_use_text: c_int, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x: c_int, p_y: c_int, p_layout: *pango.Layout) void;
pub const paintLayout = gtk_paint_layout;

/// Draws a radio button indicator in the given rectangle on `cr` with
/// the given parameters.
extern fn gtk_paint_option(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void;
pub const paintOption = gtk_paint_option;

/// Draws a resize grip in the given rectangle on `cr` using the given
/// parameters.
extern fn gtk_paint_resize_grip(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_edge: gdk.WindowEdge, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void;
pub const paintResizeGrip = gtk_paint_resize_grip;

/// Draws a shadow around the given rectangle in `cr`
/// using the given style and state and shadow type.
extern fn gtk_paint_shadow(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void;
pub const paintShadow = gtk_paint_shadow;

/// Draws a shadow around the given rectangle in `cr`
/// using the given style and state and shadow type, leaving a
/// gap in one side.
extern fn gtk_paint_shadow_gap(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_gap_side: gtk.PositionType, p_gap_x: c_int, p_gap_width: c_int) void;
pub const paintShadowGap = gtk_paint_shadow_gap;

/// Draws a slider in the given rectangle on `cr` using the
/// given style and orientation.
extern fn gtk_paint_slider(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int, p_orientation: gtk.Orientation) void;
pub const paintSlider = gtk_paint_slider;

/// Draws a spinner on `window` using the given parameters.
extern fn gtk_paint_spinner(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_step: c_uint, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void;
pub const paintSpinner = gtk_paint_spinner;

/// Draws an option menu tab (i.e. the up and down pointing arrows)
/// in the given rectangle on `cr` using the given parameters.
extern fn gtk_paint_tab(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_shadow_type: gtk.ShadowType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_x: c_int, p_y: c_int, p_width: c_int, p_height: c_int) void;
pub const paintTab = gtk_paint_tab;

/// Draws a vertical line from (`x`, `y1_`) to (`x`, `y2_`) in `cr`
/// using the given style and state.
extern fn gtk_paint_vline(p_style: *gtk.Style, p_cr: *cairo.Context, p_state_type: gtk.StateType, p_widget: ?*gtk.Widget, p_detail: ?[*:0]const u8, p_y1_: c_int, p_y2_: c_int, p_x: c_int) void;
pub const paintVline = gtk_paint_vline;

/// Parses command line arguments, and initializes global
/// attributes of GTK+, but does not actually open a connection
/// to a display. (See `gdk.Display.open`, `gdk.getDisplayArgName`)
///
/// Any arguments used by GTK+ or GDK are removed from the array and
/// `argc` and `argv` are updated accordingly.
///
/// There is no need to call this function explicitly if you are using
/// `gtk.init`, or `gtk.initCheck`.
///
/// Note that many aspects of GTK+ require a display connection to
/// function, so this way of initializing GTK+ is really only useful
/// for specialized use cases.
extern fn gtk_parse_args(p_argc: *c_int, p_argv: *[*][*:0]u8) c_int;
pub const parseArgs = gtk_parse_args;

/// Runs a page setup dialog, letting the user modify the values from
/// `page_setup`. If the user cancels the dialog, the returned `gtk.PageSetup`
/// is identical to the passed in `page_setup`, otherwise it contains the
/// modifications done in the dialog.
///
/// Note that this function may use a recursive mainloop to show the page
/// setup dialog. See `gtk.printRunPageSetupDialogAsync` if this is
/// a problem.
extern fn gtk_print_run_page_setup_dialog(p_parent: ?*gtk.Window, p_page_setup: ?*gtk.PageSetup, p_settings: *gtk.PrintSettings) *gtk.PageSetup;
pub const printRunPageSetupDialog = gtk_print_run_page_setup_dialog;

/// Runs a page setup dialog, letting the user modify the values from `page_setup`.
///
/// In contrast to `gtk.printRunPageSetupDialog`, this function  returns after
/// showing the page setup dialog on platforms that support this, and calls `done_cb`
/// from a signal handler for the ::response signal of the dialog.
extern fn gtk_print_run_page_setup_dialog_async(p_parent: ?*gtk.Window, p_page_setup: ?*gtk.PageSetup, p_settings: *gtk.PrintSettings, p_done_cb: gtk.PageSetupDoneFunc, p_data: ?*anyopaque) void;
pub const printRunPageSetupDialogAsync = gtk_print_run_page_setup_dialog_async;

/// Sends an event to a widget, propagating the event to parent widgets
/// if the event remains unhandled.
///
/// Events received by GTK+ from GDK normally begin in `gtk.mainDoEvent`.
/// Depending on the type of event, existence of modal dialogs, grabs, etc.,
/// the event may be propagated; if so, this function is used.
///
/// `gtk.propagateEvent` calls `gtk.Widget.event` on each widget it
/// decides to send the event to. So `gtk.Widget.event` is the lowest-level
/// function; it simply emits the `gtk.Widget.signals.event` and possibly an
/// event-specific signal on a widget. `gtk.propagateEvent` is a bit
/// higher-level, and `gtk.mainDoEvent` is the highest level.
///
/// All that said, you most likely don’t want to use any of these
/// functions; synthesizing events is rarely needed. There are almost
/// certainly better ways to achieve your goals. For example, use
/// `gdk.Window.invalidateRect` or `gtk.Widget.queueDraw` instead
/// of making up expose events.
extern fn gtk_propagate_event(p_widget: *gtk.Widget, p_event: *gdk.Event) void;
pub const propagateEvent = gtk_propagate_event;

/// Adds a file to the list of files to be parsed at the
/// end of `gtk.init`.
extern fn gtk_rc_add_default_file(p_filename: [*:0]const u8) void;
pub const rcAddDefaultFile = gtk_rc_add_default_file;

/// Searches for a theme engine in the GTK+ search path. This function
/// is not useful for applications and should not be used.
extern fn gtk_rc_find_module_in_path(p_module_file: [*:0]const u8) [*:0]u8;
pub const rcFindModuleInPath = gtk_rc_find_module_in_path;

/// Looks up a file in pixmap path for the specified `gtk.Settings`.
/// If the file is not found, it outputs a warning message using
/// `g_warning` and returns `NULL`.
extern fn gtk_rc_find_pixmap_in_path(p_settings: *gtk.Settings, p_scanner: *glib.Scanner, p_pixmap_file: [*:0]const u8) [*:0]u8;
pub const rcFindPixmapInPath = gtk_rc_find_pixmap_in_path;

/// Retrieves the current list of RC files that will be parsed
/// at the end of `gtk.init`.
extern fn gtk_rc_get_default_files() [*][*:0]u8;
pub const rcGetDefaultFiles = gtk_rc_get_default_files;

/// Obtains the path to the IM modules file. See the documentation
/// of the `GTK_IM_MODULE_FILE`
/// environment variable for more details.
extern fn gtk_rc_get_im_module_file() [*:0]u8;
pub const rcGetImModuleFile = gtk_rc_get_im_module_file;

/// Obtains the path in which to look for IM modules. See the documentation
/// of the `GTK_PATH`
/// environment variable for more details about looking up modules. This
/// function is useful solely for utilities supplied with GTK+ and should
/// not be used by applications under normal circumstances.
extern fn gtk_rc_get_im_module_path() [*:0]u8;
pub const rcGetImModulePath = gtk_rc_get_im_module_path;

/// Returns a directory in which GTK+ looks for theme engines.
/// For full information about the search for theme engines,
/// see the docs for `GTK_PATH` in [Running GTK+ Applications][gtk-running].
extern fn gtk_rc_get_module_dir() [*:0]u8;
pub const rcGetModuleDir = gtk_rc_get_module_dir;

/// Finds all matching RC styles for a given widget,
/// composites them together, and then creates a
/// `gtk.Style` representing the composite appearance.
/// (GTK+ actually keeps a cache of previously
/// created styles, so a new style may not be
/// created.)
extern fn gtk_rc_get_style(p_widget: *gtk.Widget) *gtk.Style;
pub const rcGetStyle = gtk_rc_get_style;

/// Creates up a `gtk.Style` from styles defined in a RC file by providing
/// the raw components used in matching. This function may be useful
/// when creating pseudo-widgets that should be themed like widgets but
/// don’t actually have corresponding GTK+ widgets. An example of this
/// would be items inside a GNOME canvas widget.
///
/// The action of `gtk.rcGetStyle` is similar to:
/// ```
///  gtk_widget_path (widget, NULL, &path, NULL);
///  gtk_widget_class_path (widget, NULL, &class_path, NULL);
///  gtk_rc_get_style_by_paths (gtk_widget_get_settings (widget),
///                             path, class_path,
///                             G_OBJECT_TYPE (widget));
/// ```
extern fn gtk_rc_get_style_by_paths(p_settings: *gtk.Settings, p_widget_path: ?[*:0]const u8, p_class_path: ?[*:0]const u8, p_type: usize) ?*gtk.Style;
pub const rcGetStyleByPaths = gtk_rc_get_style_by_paths;

/// Returns the standard directory in which themes should
/// be installed. (GTK+ does not actually use this directory
/// itself.)
extern fn gtk_rc_get_theme_dir() [*:0]u8;
pub const rcGetThemeDir = gtk_rc_get_theme_dir;

/// Parses a given resource file.
extern fn gtk_rc_parse(p_filename: [*:0]const u8) void;
pub const rcParse = gtk_rc_parse;

/// Parses a color in the format expected
/// in a RC file.
///
/// Note that theme engines should use `gtk.rcParseColorFull` in
/// order to support symbolic colors.
extern fn gtk_rc_parse_color(p_scanner: *glib.Scanner, p_color: *gdk.Color) c_uint;
pub const rcParseColor = gtk_rc_parse_color;

/// Parses a color in the format expected
/// in a RC file. If `style` is not `NULL`, it will be consulted to resolve
/// references to symbolic colors.
extern fn gtk_rc_parse_color_full(p_scanner: *glib.Scanner, p_style: ?*gtk.RcStyle, p_color: *gdk.Color) c_uint;
pub const rcParseColorFull = gtk_rc_parse_color_full;

/// Parses a `gtk.PathPriorityType` variable from the format expected
/// in a RC file.
extern fn gtk_rc_parse_priority(p_scanner: *glib.Scanner, p_priority: *gtk.PathPriorityType) c_uint;
pub const rcParsePriority = gtk_rc_parse_priority;

/// Parses a `gtk.StateType` variable from the format expected
/// in a RC file.
extern fn gtk_rc_parse_state(p_scanner: *glib.Scanner, p_state: *gtk.StateType) c_uint;
pub const rcParseState = gtk_rc_parse_state;

/// Parses resource information directly from a string.
extern fn gtk_rc_parse_string(p_rc_string: [*:0]const u8) void;
pub const rcParseString = gtk_rc_parse_string;

/// If the modification time on any previously read file for the
/// default `gtk.Settings` has changed, discard all style information
/// and then reread all previously read RC files.
extern fn gtk_rc_reparse_all() c_int;
pub const rcReparseAll = gtk_rc_reparse_all;

/// If the modification time on any previously read file
/// for the given `gtk.Settings` has changed, discard all style information
/// and then reread all previously read RC files.
extern fn gtk_rc_reparse_all_for_settings(p_settings: *gtk.Settings, p_force_load: c_int) c_int;
pub const rcReparseAllForSettings = gtk_rc_reparse_all_for_settings;

/// This function recomputes the styles for all widgets that use a
/// particular `gtk.Settings` object. (There is one `gtk.Settings` object
/// per `gdk.Screen`, see `gtk.Settings.getForScreen`); It is useful
/// when some global parameter has changed that affects the appearance
/// of all widgets, because when a widget gets a new style, it will
/// both redraw and recompute any cached information about its
/// appearance. As an example, it is used when the default font size
/// set by the operating system changes. Note that this function
/// doesn’t affect widgets that have a style set explicitly on them
/// with `gtk.Widget.setStyle`.
extern fn gtk_rc_reset_styles(p_settings: *gtk.Settings) void;
pub const rcResetStyles = gtk_rc_reset_styles;

extern fn gtk_rc_scanner_new() *glib.Scanner;
pub const rcScannerNew = gtk_rc_scanner_new;

/// Sets the list of files that GTK+ will read at the
/// end of `gtk.init`.
extern fn gtk_rc_set_default_files(p_filenames: [*][*:0]u8) void;
pub const rcSetDefaultFiles = gtk_rc_set_default_files;

/// Renders an activity indicator (such as in `gtk.Spinner`).
/// The state `GTK_STATE_FLAG_CHECKED` determines whether there is
/// activity going on.
extern fn gtk_render_activity(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void;
pub const renderActivity = gtk_render_activity;

/// Renders an arrow pointing to `angle`.
///
/// Typical arrow rendering at 0, 1⁄2 π;, π; and 3⁄2 π:
///
/// ![](arrows.png)
extern fn gtk_render_arrow(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_angle: f64, p_x: f64, p_y: f64, p_size: f64) void;
pub const renderArrow = gtk_render_arrow;

/// Renders the background of an element.
///
/// Typical background rendering, showing the effect of
/// `background-image`, `border-width` and `border-radius`:
///
/// ![](background.png)
extern fn gtk_render_background(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void;
pub const renderBackground = gtk_render_background;

/// Returns the area that will be affected (i.e. drawn to) when
/// calling `gtk.renderBackground` for the given `context` and
/// rectangle.
extern fn gtk_render_background_get_clip(p_context: *gtk.StyleContext, p_x: f64, p_y: f64, p_width: f64, p_height: f64, p_out_clip: *gdk.Rectangle) void;
pub const renderBackgroundGetClip = gtk_render_background_get_clip;

/// Renders a checkmark (as in a `gtk.CheckButton`).
///
/// The `GTK_STATE_FLAG_CHECKED` state determines whether the check is
/// on or off, and `GTK_STATE_FLAG_INCONSISTENT` determines whether it
/// should be marked as undefined.
///
/// Typical checkmark rendering:
///
/// ![](checks.png)
extern fn gtk_render_check(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void;
pub const renderCheck = gtk_render_check;

/// Renders an expander (as used in `gtk.TreeView` and `gtk.Expander`) in the area
/// defined by `x`, `y`, `width`, `height`. The state `GTK_STATE_FLAG_CHECKED`
/// determines whether the expander is collapsed or expanded.
///
/// Typical expander rendering:
///
/// ![](expanders.png)
extern fn gtk_render_expander(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void;
pub const renderExpander = gtk_render_expander;

/// Renders a extension (as in a `gtk.Notebook` tab) in the rectangle
/// defined by `x`, `y`, `width`, `height`. The side where the extension
/// connects to is defined by `gap_side`.
///
/// Typical extension rendering:
///
/// ![](extensions.png)
extern fn gtk_render_extension(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64, p_gap_side: gtk.PositionType) void;
pub const renderExtension = gtk_render_extension;

/// Renders a focus indicator on the rectangle determined by `x`, `y`, `width`, `height`.
///
/// Typical focus rendering:
///
/// ![](focus.png)
extern fn gtk_render_focus(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void;
pub const renderFocus = gtk_render_focus;

/// Renders a frame around the rectangle defined by `x`, `y`, `width`, `height`.
///
/// Examples of frame rendering, showing the effect of `border-image`,
/// `border-color`, `border-width`, `border-radius` and junctions:
///
/// ![](frames.png)
extern fn gtk_render_frame(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void;
pub const renderFrame = gtk_render_frame;

/// Renders a frame around the rectangle defined by (`x`, `y`, `width`, `height`),
/// leaving a gap on one side. `xy0_gap` and `xy1_gap` will mean X coordinates
/// for `GTK_POS_TOP` and `GTK_POS_BOTTOM` gap sides, and Y coordinates for
/// `GTK_POS_LEFT` and `GTK_POS_RIGHT`.
///
/// Typical rendering of a frame with a gap:
///
/// ![](frame-gap.png)
extern fn gtk_render_frame_gap(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64, p_gap_side: gtk.PositionType, p_xy0_gap: f64, p_xy1_gap: f64) void;
pub const renderFrameGap = gtk_render_frame_gap;

/// Renders a handle (as in `gtk.HandleBox`, `gtk.Paned` and
/// `gtk.Window`’s resize grip), in the rectangle
/// determined by `x`, `y`, `width`, `height`.
///
/// Handles rendered for the paned and grip classes:
///
/// ![](handles.png)
extern fn gtk_render_handle(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void;
pub const renderHandle = gtk_render_handle;

/// Renders the icon in `pixbuf` at the specified `x` and `y` coordinates.
///
/// This function will render the icon in `pixbuf` at exactly its size,
/// regardless of scaling factors, which may not be appropriate when
/// drawing on displays with high pixel densities.
///
/// You probably want to use `gtk.renderIconSurface` instead, if you
/// already have a Cairo surface.
extern fn gtk_render_icon(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_pixbuf: *gdkpixbuf.Pixbuf, p_x: f64, p_y: f64) void;
pub const renderIcon = gtk_render_icon;

/// Renders the icon specified by `source` at the given `size`, returning the result
/// in a pixbuf.
extern fn gtk_render_icon_pixbuf(p_context: *gtk.StyleContext, p_source: *const gtk.IconSource, p_size: c_int) *gdkpixbuf.Pixbuf;
pub const renderIconPixbuf = gtk_render_icon_pixbuf;

/// Renders the icon in `surface` at the specified `x` and `y` coordinates.
extern fn gtk_render_icon_surface(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_surface: *cairo.Surface, p_x: f64, p_y: f64) void;
pub const renderIconSurface = gtk_render_icon_surface;

/// Draws a text caret on `cr` at the specified index of `layout`.
extern fn gtk_render_insertion_cursor(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_layout: *pango.Layout, p_index: c_int, p_direction: pango.Direction) void;
pub const renderInsertionCursor = gtk_render_insertion_cursor;

/// Renders `layout` on the coordinates `x`, `y`
extern fn gtk_render_layout(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_layout: *pango.Layout) void;
pub const renderLayout = gtk_render_layout;

/// Renders a line from (x0, y0) to (x1, y1).
extern fn gtk_render_line(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_x0: f64, p_y0: f64, p_x1: f64, p_y1: f64) void;
pub const renderLine = gtk_render_line;

/// Renders an option mark (as in a `gtk.RadioButton`), the `GTK_STATE_FLAG_CHECKED`
/// state will determine whether the option is on or off, and
/// `GTK_STATE_FLAG_INCONSISTENT` whether it should be marked as undefined.
///
/// Typical option mark rendering:
///
/// ![](options.png)
extern fn gtk_render_option(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64) void;
pub const renderOption = gtk_render_option;

/// Renders a slider (as in `gtk.Scale`) in the rectangle defined by `x`, `y`,
/// `width`, `height`. `orientation` defines whether the slider is vertical
/// or horizontal.
///
/// Typical slider rendering:
///
/// ![](sliders.png)
extern fn gtk_render_slider(p_context: *gtk.StyleContext, p_cr: *cairo.Context, p_x: f64, p_y: f64, p_width: f64, p_height: f64, p_orientation: gtk.Orientation) void;
pub const renderSlider = gtk_render_slider;

/// Converts a color from RGB space to HSV.
///
/// Input values must be in the [0.0, 1.0] range;
/// output values will be in the same range.
extern fn gtk_rgb_to_hsv(p_r: f64, p_g: f64, p_b: f64, p_h: *f64, p_s: *f64, p_v: *f64) void;
pub const rgbToHsv = gtk_rgb_to_hsv;

/// Appends a specified target to the list of supported targets for a
/// given widget and selection.
extern fn gtk_selection_add_target(p_widget: *gtk.Widget, p_selection: gdk.Atom, p_target: gdk.Atom, p_info: c_uint) void;
pub const selectionAddTarget = gtk_selection_add_target;

/// Prepends a table of targets to the list of supported targets
/// for a given widget and selection.
extern fn gtk_selection_add_targets(p_widget: *gtk.Widget, p_selection: gdk.Atom, p_targets: [*]const gtk.TargetEntry, p_ntargets: c_uint) void;
pub const selectionAddTargets = gtk_selection_add_targets;

/// Remove all targets registered for the given selection for the
/// widget.
extern fn gtk_selection_clear_targets(p_widget: *gtk.Widget, p_selection: gdk.Atom) void;
pub const selectionClearTargets = gtk_selection_clear_targets;

/// Requests the contents of a selection. When received,
/// a “selection-received” signal will be generated.
extern fn gtk_selection_convert(p_widget: *gtk.Widget, p_selection: gdk.Atom, p_target: gdk.Atom, p_time_: u32) c_int;
pub const selectionConvert = gtk_selection_convert;

/// Claims ownership of a given selection for a particular widget,
/// or, if `widget` is `NULL`, release ownership of the selection.
extern fn gtk_selection_owner_set(p_widget: ?*gtk.Widget, p_selection: gdk.Atom, p_time_: u32) c_int;
pub const selectionOwnerSet = gtk_selection_owner_set;

/// Claim ownership of a given selection for a particular widget, or,
/// if `widget` is `NULL`, release ownership of the selection.
extern fn gtk_selection_owner_set_for_display(p_display: *gdk.Display, p_widget: ?*gtk.Widget, p_selection: gdk.Atom, p_time_: u32) c_int;
pub const selectionOwnerSetForDisplay = gtk_selection_owner_set_for_display;

/// Removes all handlers and unsets ownership of all
/// selections for a widget. Called when widget is being
/// destroyed. This function will not generally be
/// called by applications.
extern fn gtk_selection_remove_all(p_widget: *gtk.Widget) void;
pub const selectionRemoveAll = gtk_selection_remove_all;

/// Sets the GTK+ debug flags.
extern fn gtk_set_debug_flags(p_flags: c_uint) void;
pub const setDebugFlags = gtk_set_debug_flags;

/// This is a convenience function for showing an application’s about box.
/// The constructed dialog is associated with the parent window and
/// reused for future invocations of this function.
extern fn gtk_show_about_dialog(p_parent: ?*gtk.Window, p_first_property_name: [*:0]const u8, ...) void;
pub const showAboutDialog = gtk_show_about_dialog;

/// A convenience function for launching the default application
/// to show the uri. Like `gtk.showUriOnWindow`, but takes a screen
/// as transient parent instead of a window.
///
/// Note that this function is deprecated as it does not pass the necessary
/// information for helpers to parent their dialog properly, when run from
/// sandboxed applications for example.
extern fn gtk_show_uri(p_screen: ?*gdk.Screen, p_uri: [*:0]const u8, p_timestamp: u32, p_error: ?*?*glib.Error) c_int;
pub const showUri = gtk_show_uri;

/// This is a convenience function for launching the default application
/// to show the uri. The uri must be of a form understood by GIO (i.e. you
/// need to install gvfs to get support for uri schemes such as http://
/// or ftp://, as only local files are handled by GIO itself).
/// Typical examples are
/// - `file:///home/gnome/pict.jpg`
/// - `http://www.gnome.org`
/// - `mailto:me`gnome`.org`
///
/// Ideally the timestamp is taken from the event triggering
/// the `gtk.showUri` call. If timestamp is not known you can take
/// `GDK_CURRENT_TIME`.
///
/// This is the recommended call to be used as it passes information
/// necessary for sandbox helpers to parent their dialogs properly.
extern fn gtk_show_uri_on_window(p_parent: ?*gtk.Window, p_uri: [*:0]const u8, p_timestamp: u32, p_error: ?*?*glib.Error) c_int;
pub const showUriOnWindow = gtk_show_uri_on_window;

/// Registers each of the stock items in `items`. If an item already
/// exists with the same stock ID as one of the `items`, the old item
/// gets replaced. The stock items are copied, so GTK+ does not hold
/// any pointer into `items` and `items` can be freed. Use
/// `gtk.stockAddStatic` if `items` is persistent and GTK+ need not
/// copy the array.
extern fn gtk_stock_add(p_items: [*]const gtk.StockItem, p_n_items: c_uint) void;
pub const stockAdd = gtk_stock_add;

/// Same as `gtk.stockAdd`, but doesn’t copy `items`, so
/// `items` must persist until application exit.
extern fn gtk_stock_add_static(p_items: [*]const gtk.StockItem, p_n_items: c_uint) void;
pub const stockAddStatic = gtk_stock_add_static;

/// Retrieves a list of all known stock IDs added to a `gtk.IconFactory`
/// or registered with `gtk.stockAdd`. The list must be freed with `glib.SList.free`,
/// and each string in the list must be freed with `glib.free`.
extern fn gtk_stock_list_ids() *glib.SList;
pub const stockListIds = gtk_stock_list_ids;

/// Fills `item` with the registered values for `stock_id`, returning `TRUE`
/// if `stock_id` was known.
extern fn gtk_stock_lookup(p_stock_id: [*:0]const u8, p_item: *gtk.StockItem) c_int;
pub const stockLookup = gtk_stock_lookup;

/// Sets a function to be used for translating the `label` of
/// a stock item.
///
/// If no function is registered for a translation domain,
/// `glib.dgettext` is used.
///
/// The function is used for all stock items whose
/// `translation_domain` matches `domain`. Note that it is possible
/// to use strings different from the actual gettext translation domain
/// of your application for this, as long as your `gtk.TranslateFunc` uses
/// the correct domain when calling `dgettext`. This can be useful, e.g.
/// when dealing with message contexts:
///
/// ```
/// GtkStockItem items[] = {
///  { MY_ITEM1, NC_("odd items", "Item 1"), 0, 0, "odd-item-domain" },
///  { MY_ITEM2, NC_("even items", "Item 2"), 0, 0, "even-item-domain" },
/// };
///
/// gchar *
/// my_translate_func (const gchar *msgid,
///                    gpointer     data)
/// {
///   gchar *msgctxt = data;
///
///   return (gchar*)g_dpgettext2 (GETTEXT_PACKAGE, msgctxt, msgid);
/// }
///
/// ...
///
/// gtk_stock_add (items, G_N_ELEMENTS (items));
/// gtk_stock_set_translate_func ("odd-item-domain", my_translate_func, "odd items");
/// gtk_stock_set_translate_func ("even-item-domain", my_translate_func, "even items");
/// ```
extern fn gtk_stock_set_translate_func(p_domain: [*:0]const u8, p_func: gtk.TranslateFunc, p_data: ?*anyopaque, p_notify: ?glib.DestroyNotify) void;
pub const stockSetTranslateFunc = gtk_stock_set_translate_func;

/// This function frees a target table as returned by
/// `gtk.targetTableNewFromList`
extern fn gtk_target_table_free(p_targets: [*]gtk.TargetEntry, p_n_targets: c_int) void;
pub const targetTableFree = gtk_target_table_free;

/// This function creates an `gtk.TargetEntry` array that contains the
/// same targets as the passed `list`. The returned table is newly
/// allocated and should be freed using `gtk.targetTableFree` when no
/// longer needed.
extern fn gtk_target_table_new_from_list(p_list: *gtk.TargetList, p_n_targets: *c_int) [*]gtk.TargetEntry;
pub const targetTableNewFromList = gtk_target_table_new_from_list;

/// Determines if any of the targets in `targets` can be used to
/// provide a `gdkpixbuf.Pixbuf`.
extern fn gtk_targets_include_image(p_targets: [*]gdk.Atom, p_n_targets: c_int, p_writable: c_int) c_int;
pub const targetsIncludeImage = gtk_targets_include_image;

/// Determines if any of the targets in `targets` can be used to
/// provide rich text.
extern fn gtk_targets_include_rich_text(p_targets: [*]gdk.Atom, p_n_targets: c_int, p_buffer: *gtk.TextBuffer) c_int;
pub const targetsIncludeRichText = gtk_targets_include_rich_text;

/// Determines if any of the targets in `targets` can be used to
/// provide text.
extern fn gtk_targets_include_text(p_targets: [*]gdk.Atom, p_n_targets: c_int) c_int;
pub const targetsIncludeText = gtk_targets_include_text;

/// Determines if any of the targets in `targets` can be used to
/// provide an uri list.
extern fn gtk_targets_include_uri(p_targets: [*]gdk.Atom, p_n_targets: c_int) c_int;
pub const targetsIncludeUri = gtk_targets_include_uri;

/// Create a simple window with window title `window_title` and
/// text contents `dialog_text`.
/// The window will quit any running `gtk.main`-loop when destroyed, and it
/// will automatically be destroyed upon test function teardown.
extern fn gtk_test_create_simple_window(p_window_title: [*:0]const u8, p_dialog_text: [*:0]const u8) *gtk.Widget;
pub const testCreateSimpleWindow = gtk_test_create_simple_window;

/// This function wraps `gobject.Object.new` for widget types.
/// It’ll automatically show all created non window widgets, also
/// `gobject.Object.refSink` them (to keep them alive across a running test)
/// and set them up for destruction during the next test teardown phase.
extern fn gtk_test_create_widget(p_widget_type: usize, p_first_property_name: ?[*:0]const u8, ...) *gtk.Widget;
pub const testCreateWidget = gtk_test_create_widget;

/// Create a window with window title `window_title`, text contents `dialog_text`,
/// and a number of buttons, according to the paired argument list given
/// as @... parameters.
/// Each button is created with a `label` and a ::clicked signal handler that
/// incremrents the integer stored in `nump`.
/// The window will be automatically shown with `gtk.Widget.showNow` after
/// creation, so when this function returns it has already been mapped,
/// resized and positioned on screen.
/// The window will quit any running `gtk.main`-loop when destroyed, and it
/// will automatically be destroyed upon test function teardown.
extern fn gtk_test_display_button_window(p_window_title: [*:0]const u8, p_dialog_text: [*:0]const u8, ...) *gtk.Widget;
pub const testDisplayButtonWindow = gtk_test_display_button_window;

/// This function will search `widget` and all its descendants for a GtkLabel
/// widget with a text string matching `label_pattern`.
/// The `label_pattern` may contain asterisks “*” and question marks “?” as
/// placeholders, `glib.patternMatch` is used for the matching.
/// Note that locales other than "C“ tend to alter (translate” label strings,
/// so this function is genrally only useful in test programs with
/// predetermined locales, see `gtk.testInit` for more details.
extern fn gtk_test_find_label(p_widget: *gtk.Widget, p_label_pattern: [*:0]const u8) *gtk.Widget;
pub const testFindLabel = gtk_test_find_label;

/// This function will search siblings of `base_widget` and siblings of its
/// ancestors for all widgets matching `widget_type`.
/// Of the matching widgets, the one that is geometrically closest to
/// `base_widget` will be returned.
/// The general purpose of this function is to find the most likely “action”
/// widget, relative to another labeling widget. Such as finding a
/// button or text entry widget, given its corresponding label widget.
extern fn gtk_test_find_sibling(p_base_widget: *gtk.Widget, p_widget_type: usize) *gtk.Widget;
pub const testFindSibling = gtk_test_find_sibling;

/// This function will search the descendants of `widget` for a widget
/// of type `widget_type` that has a label matching `label_pattern` next
/// to it. This is most useful for automated GUI testing, e.g. to find
/// the “OK” button in a dialog and synthesize clicks on it.
/// However see `gtk.testFindLabel`, `gtk.testFindSibling` and
/// `gtk.testWidgetClick` for possible caveats involving the search of
/// such widgets and synthesizing widget events.
extern fn gtk_test_find_widget(p_widget: *gtk.Widget, p_label_pattern: [*:0]const u8, p_widget_type: usize) ?*gtk.Widget;
pub const testFindWidget = gtk_test_find_widget;

/// This function is used to initialize a GTK+ test program.
///
/// It will in turn call `glib.testInit` and `gtk.init` to properly
/// initialize the testing framework and graphical toolkit. It’ll
/// also set the program’s locale to “C” and prevent loading of rc
/// files and Gtk+ modules. This is done to make tets program
/// environments as deterministic as possible.
///
/// Like `gtk.init` and `glib.testInit`, any known arguments will be
/// processed and stripped from `argc` and `argv`.
extern fn gtk_test_init(p_argcp: *c_int, p_argvp: *[*][*:0]u8, ...) void;
pub const testInit = gtk_test_init;

/// Return the type ids that have been registered after
/// calling `gtk.testRegisterAllTypes`.
extern fn gtk_test_list_all_types(p_n_types: *c_uint) [*:0]const usize;
pub const testListAllTypes = gtk_test_list_all_types;

/// Force registration of all core Gtk+ and Gdk object types.
/// This allowes to refer to any of those object types via
/// `gobject.typeFromName` after calling this function.
extern fn gtk_test_register_all_types() void;
pub const testRegisterAllTypes = gtk_test_register_all_types;

/// Retrive the literal adjustment value for GtkRange based
/// widgets and spin buttons. Note that the value returned by
/// this function is anything between the lower and upper bounds
/// of the adjustment belonging to `widget`, and is not a percentage
/// as passed in to `gtk.testSliderSetPerc`.
extern fn gtk_test_slider_get_value(p_widget: *gtk.Widget) f64;
pub const testSliderGetValue = gtk_test_slider_get_value;

/// This function will adjust the slider position of all GtkRange
/// based widgets, such as scrollbars or scales, it’ll also adjust
/// spin buttons. The adjustment value of these widgets is set to
/// a value between the lower and upper limits, according to the
/// `percentage` argument.
extern fn gtk_test_slider_set_perc(p_widget: *gtk.Widget, p_percentage: f64) void;
pub const testSliderSetPerc = gtk_test_slider_set_perc;

/// This function will generate a `button` click in the upwards or downwards
/// spin button arrow areas, usually leading to an increase or decrease of
/// spin button’s value.
extern fn gtk_test_spin_button_click(p_spinner: *gtk.SpinButton, p_button: c_uint, p_upwards: c_int) c_int;
pub const testSpinButtonClick = gtk_test_spin_button_click;

/// Retrive the text string of `widget` if it is a GtkLabel,
/// GtkEditable (entry and text widgets) or GtkTextView.
extern fn gtk_test_text_get(p_widget: *gtk.Widget) [*:0]u8;
pub const testTextGet = gtk_test_text_get;

/// Set the text string of `widget` to `string` if it is a GtkLabel,
/// GtkEditable (entry and text widgets) or GtkTextView.
extern fn gtk_test_text_set(p_widget: *gtk.Widget, p_string: [*:0]const u8) void;
pub const testTextSet = gtk_test_text_set;

/// This function will generate a `button` click (button press and button
/// release event) in the middle of the first GdkWindow found that belongs
/// to `widget`.
/// For windowless widgets like `gtk.Button` (which returns `FALSE` from
/// `gtk.Widget.getHasWindow`), this will often be an
/// input-only event window. For other widgets, this is usually widget->window.
/// Certain caveats should be considered when using this function, in
/// particular because the mouse pointer is warped to the button click
/// location, see `gdk.testSimulateButton` for details.
extern fn gtk_test_widget_click(p_widget: *gtk.Widget, p_button: c_uint, p_modifiers: gdk.ModifierType) c_int;
pub const testWidgetClick = gtk_test_widget_click;

/// This function will generate keyboard press and release events in
/// the middle of the first GdkWindow found that belongs to `widget`.
/// For windowless widgets like `gtk.Button` (which returns `FALSE` from
/// `gtk.Widget.getHasWindow`), this will often be an
/// input-only event window. For other widgets, this is usually widget->window.
/// Certain caveats should be considered when using this function, in
/// particular because the mouse pointer is warped to the key press
/// location, see `gdk.testSimulateKey` for details.
extern fn gtk_test_widget_send_key(p_widget: *gtk.Widget, p_keyval: c_uint, p_modifiers: gdk.ModifierType) c_int;
pub const testWidgetSendKey = gtk_test_widget_send_key;

/// Enters the main loop and waits for `widget` to be “drawn”. In this
/// context that means it waits for the frame clock of `widget` to have
/// run a full styling, layout and drawing cycle.
///
/// This function is intended to be used for syncing with actions that
/// depend on `widget` relayouting or on interaction with the display
/// server.
extern fn gtk_test_widget_wait_for_draw(p_widget: *gtk.Widget) void;
pub const testWidgetWaitForDraw = gtk_test_widget_wait_for_draw;

/// Obtains a `tree_model` and `path` from selection data of target type
/// `GTK_TREE_MODEL_ROW`. Normally called from a drag_data_received handler.
/// This function can only be used if `selection_data` originates from the same
/// process that’s calling this function, because a pointer to the tree model
/// is being passed around. If you aren’t in the same process, then you'll
/// get memory corruption. In the `gtk.TreeDragDest` drag_data_received handler,
/// you can assume that selection data of type `GTK_TREE_MODEL_ROW` is
/// in from the current process. The returned path must be freed with
/// `gtk.TreePath.free`.
extern fn gtk_tree_get_row_drag_data(p_selection_data: *gtk.SelectionData, p_tree_model: ?**gtk.TreeModel, p_path: ?**gtk.TreePath) c_int;
pub const treeGetRowDragData = gtk_tree_get_row_drag_data;

/// Sets selection data of target type `GTK_TREE_MODEL_ROW`. Normally used
/// in a drag_data_get handler.
extern fn gtk_tree_set_row_drag_data(p_selection_data: *gtk.SelectionData, p_tree_model: *gtk.TreeModel, p_path: *gtk.TreePath) c_int;
pub const treeSetRowDragData = gtk_tree_set_row_drag_data;

/// All this function does it to return `TRUE`.
///
/// This can be useful for example if you want to inhibit the deletion
/// of a window. Of course you should not do this as the user expects
/// a reaction from clicking the close icon of the window...
///
/// ## A persistent window
///
/// ```
/// `include` <gtk/gtk.h>
///
/// int
/// main (int argc, char **argv)
/// {
///   GtkWidget *win, *but;
///   const char *text = "Close yourself. I mean it!";
///
///   gtk_init (&argc, &argv);
///
///   win = gtk_window_new (GTK_WINDOW_TOPLEVEL);
///   g_signal_connect (win,
///                     "delete-event",
///                     G_CALLBACK (gtk_true),
///                     NULL);
///   g_signal_connect (win, "destroy",
///                     G_CALLBACK (gtk_main_quit),
///                     NULL);
///
///   but = gtk_button_new_with_label (text);
///   g_signal_connect_swapped (but, "clicked",
///                             G_CALLBACK (gtk_object_destroy),
///                             win);
///   gtk_container_add (GTK_CONTAINER (win), but);
///
///   gtk_widget_show_all (win);
///
///   gtk_main ();
///
///   return 0;
/// }
/// ```
extern fn gtk_true() c_int;
pub const @"true" = gtk_true;

pub const AccelGroupActivate = *const fn (p_accel_group: *gtk.AccelGroup, p_acceleratable: *gobject.Object, p_keyval: c_uint, p_modifier: gdk.ModifierType) callconv(.c) c_int;

pub const AccelGroupFindFunc = *const fn (p_key: *gtk.AccelKey, p_closure: *gobject.Closure, p_data: ?*anyopaque) callconv(.c) c_int;

pub const AccelMapForeach = *const fn (p_data: ?*anyopaque, p_accel_path: [*:0]const u8, p_accel_key: c_uint, p_accel_mods: gdk.ModifierType, p_changed: c_int) callconv(.c) void;

/// A function used by `gtk.Assistant.setForwardPageFunc` to know which
/// is the next page given a current one. It’s called both for computing the
/// next page when the user presses the “forward” button and for handling
/// the behavior of the “last” button.
pub const AssistantPageFunc = *const fn (p_current_page: c_int, p_data: ?*anyopaque) callconv(.c) c_int;

/// This is the signature of a function used to connect signals.  It is used
/// by the `gtk.Builder.connectSignals` and `gtk.Builder.connectSignalsFull`
/// methods.  It is mainly intended for interpreted language bindings, but
/// could be useful where the programmer wants more control over the signal
/// connection process. Note that this function can only be called once,
/// subsequent calls will do nothing.
pub const BuilderConnectFunc = *const fn (p_builder: *gtk.Builder, p_object: *gobject.Object, p_signal_name: [*:0]const u8, p_handler_name: [*:0]const u8, p_connect_object: ?*gobject.Object, p_flags: gobject.ConnectFlags, p_user_data: ?*anyopaque) callconv(.c) void;

/// This kind of functions provide Pango markup with detail information for the
/// specified day. Examples for such details are holidays or appointments. The
/// function returns `NULL` when no information is available.
pub const CalendarDetailFunc = *const fn (p_calendar: *gtk.Calendar, p_year: c_uint, p_month: c_uint, p_day: c_uint, p_user_data: ?*anyopaque) callconv(.c) ?[*:0]u8;

/// The type of the callback functions used for e.g. iterating over
/// the children of a container, see `gtk.Container.foreach`.
pub const Callback = *const fn (p_widget: *gtk.Widget, p_data: ?*anyopaque) callconv(.c) void;

/// The type of the callback functions used for iterating over the
/// cell renderers and their allocated areas inside a `gtk.CellArea`,
/// see `gtk.CellArea.foreachAlloc`.
pub const CellAllocCallback = *const fn (p_renderer: *gtk.CellRenderer, p_cell_area: *const gdk.Rectangle, p_cell_background: *const gdk.Rectangle, p_data: ?*anyopaque) callconv(.c) c_int;

/// The type of the callback functions used for iterating over
/// the cell renderers of a `gtk.CellArea`, see `gtk.CellArea.foreach`.
pub const CellCallback = *const fn (p_renderer: *gtk.CellRenderer, p_data: ?*anyopaque) callconv(.c) c_int;

/// A function which should set the value of `cell_layout`’s cell renderer(s)
/// as appropriate.
pub const CellLayoutDataFunc = *const fn (p_cell_layout: *gtk.CellLayout, p_cell: *gtk.CellRenderer, p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_data: ?*anyopaque) callconv(.c) void;

/// A function that will be called when the contents of the clipboard are changed
/// or cleared. Once this has called, the `user_data_or_owner` argument
/// will not be used again.
pub const ClipboardClearFunc = *const fn (p_clipboard: *gtk.Clipboard, p_user_data_or_owner: ?*anyopaque) callconv(.c) void;

/// A function that will be called to provide the contents of the selection.
/// If multiple types of data were advertised, the requested type can
/// be determined from the `info` parameter or by checking the target field
/// of `selection_data`. If the data could successfully be converted into
/// then it should be stored into the `selection_data` object by
/// calling `gtk.SelectionData.set` (or related functions such
/// as `gtk.SelectionData.setText`). If no data is set, the requestor
/// will be informed that the attempt to get the data failed.
pub const ClipboardGetFunc = *const fn (p_clipboard: *gtk.Clipboard, p_selection_data: *gtk.SelectionData, p_info: c_uint, p_user_data_or_owner: ?*anyopaque) callconv(.c) void;

/// A function to be called when the results of `gtk.Clipboard.requestImage`
/// are received, or when the request fails.
pub const ClipboardImageReceivedFunc = *const fn (p_clipboard: *gtk.Clipboard, p_pixbuf: *gdkpixbuf.Pixbuf, p_data: ?*anyopaque) callconv(.c) void;

/// A function to be called when the results of `gtk.Clipboard.requestContents`
/// are received, or when the request fails.
pub const ClipboardReceivedFunc = *const fn (p_clipboard: *gtk.Clipboard, p_selection_data: *gtk.SelectionData, p_data: ?*anyopaque) callconv(.c) void;

/// A function to be called when the results of
/// `gtk.Clipboard.requestRichText` are received, or when the request
/// fails.
pub const ClipboardRichTextReceivedFunc = *const fn (p_clipboard: *gtk.Clipboard, p_format: gdk.Atom, p_text: ?[*:0]const u8, p_length: usize, p_data: ?*anyopaque) callconv(.c) void;

/// A function to be called when the results of `gtk.Clipboard.requestTargets`
/// are received, or when the request fails.
pub const ClipboardTargetsReceivedFunc = *const fn (p_clipboard: *gtk.Clipboard, p_atoms: ?[*]gdk.Atom, p_n_atoms: c_int, p_data: ?*anyopaque) callconv(.c) void;

/// A function to be called when the results of `gtk.Clipboard.requestText`
/// are received, or when the request fails.
pub const ClipboardTextReceivedFunc = *const fn (p_clipboard: *gtk.Clipboard, p_text: ?[*:0]const u8, p_data: ?*anyopaque) callconv(.c) void;

/// A function to be called when the results of
/// `gtk.Clipboard.requestUris` are received, or when the request
/// fails.
pub const ClipboardURIReceivedFunc = *const fn (p_clipboard: *gtk.Clipboard, p_uris: [*][*:0]u8, p_data: ?*anyopaque) callconv(.c) void;

pub const ColorSelectionChangePaletteFunc = *const fn (p_colors: [*]const gdk.Color, p_n_colors: c_int) callconv(.c) void;

pub const ColorSelectionChangePaletteWithScreenFunc = *const fn (p_screen: *gdk.Screen, p_colors: [*]const gdk.Color, p_n_colors: c_int) callconv(.c) void;

/// A function which decides whether the row indicated by `iter` matches
/// a given `key`, and should be displayed as a possible completion for `key`.
/// Note that `key` is normalized and case-folded (see `glib.utf8Normalize`
/// and `glib.utf8Casefold`). If this is not appropriate, match functions
/// have access to the unmodified key via
/// `gtk_entry_get_text (GTK_ENTRY (gtk_entry_completion_get_entry ()))`.
pub const EntryCompletionMatchFunc = *const fn (p_completion: *gtk.EntryCompletion, p_key: [*:0]const u8, p_iter: *gtk.TreeIter, p_user_data: ?*anyopaque) callconv(.c) c_int;

/// The type of function that is used with custom filters, see
/// `gtk.FileFilter.addCustom`.
pub const FileFilterFunc = *const fn (p_filter_info: *const gtk.FileFilterInfo, p_data: ?*anyopaque) callconv(.c) c_int;

/// Called for flow boxes that are bound to a `gio.ListModel` with
/// `gtk.FlowBox.bindModel` for each item that gets added to the model.
pub const FlowBoxCreateWidgetFunc = *const fn (p_item: *gobject.Object, p_user_data: ?*anyopaque) callconv(.c) *gtk.Widget;

/// A function that will be called whenrever a child changes
/// or is added. It lets you control if the child should be
/// visible or not.
pub const FlowBoxFilterFunc = *const fn (p_child: *gtk.FlowBoxChild, p_user_data: ?*anyopaque) callconv(.c) c_int;

/// A function used by `gtk.FlowBox.selectedForeach`.
/// It will be called on every selected child of the `box`.
pub const FlowBoxForeachFunc = *const fn (p_box: *gtk.FlowBox, p_child: *gtk.FlowBoxChild, p_user_data: ?*anyopaque) callconv(.c) void;

/// A function to compare two children to determine which
/// should come first.
pub const FlowBoxSortFunc = *const fn (p_child1: *gtk.FlowBoxChild, p_child2: *gtk.FlowBoxChild, p_user_data: ?*anyopaque) callconv(.c) c_int;

/// The type of function that is used for deciding what fonts get
/// shown in a `gtk.FontChooser`. See `gtk.FontChooser.setFilterFunc`.
pub const FontFilterFunc = *const fn (p_family: *const pango.FontFamily, p_face: *const pango.FontFace, p_data: ?*anyopaque) callconv(.c) c_int;

/// A function used by `gtk.IconView.selectedForeach` to map all
/// selected rows.  It will be called on every selected row in the view.
pub const IconViewForeachFunc = *const fn (p_icon_view: *gtk.IconView, p_path: *gtk.TreePath, p_data: ?*anyopaque) callconv(.c) void;

/// Key snooper functions are called before normal event delivery.
/// They can be used to implement custom key event handling.
pub const KeySnoopFunc = *const fn (p_grab_widget: *gtk.Widget, p_event: *gdk.EventKey, p_func_data: ?*anyopaque) callconv(.c) c_int;

/// Called for list boxes that are bound to a `gio.ListModel` with
/// `gtk.ListBox.bindModel` for each item that gets added to the model.
///
/// Versions of GTK+ prior to 3.18 called `gtk.Widget.showAll` on the rows
/// created by the GtkListBoxCreateWidgetFunc, but this forced all widgets
/// inside the row to be shown, and is no longer the case. Applications should
/// be updated to show the desired row widgets.
pub const ListBoxCreateWidgetFunc = *const fn (p_item: *gobject.Object, p_user_data: ?*anyopaque) callconv(.c) *gtk.Widget;

/// Will be called whenever the row changes or is added and lets you control
/// if the row should be visible or not.
pub const ListBoxFilterFunc = *const fn (p_row: *gtk.ListBoxRow, p_user_data: ?*anyopaque) callconv(.c) c_int;

/// A function used by `gtk.ListBox.selectedForeach`.
/// It will be called on every selected child of the `box`.
pub const ListBoxForeachFunc = *const fn (p_box: *gtk.ListBox, p_row: *gtk.ListBoxRow, p_user_data: ?*anyopaque) callconv(.c) void;

/// Compare two rows to determine which should be first.
pub const ListBoxSortFunc = *const fn (p_row1: *gtk.ListBoxRow, p_row2: *gtk.ListBoxRow, p_user_data: ?*anyopaque) callconv(.c) c_int;

/// Whenever `row` changes or which row is before `row` changes this
/// is called, which lets you update the header on `row`. You may
/// remove or set a new one via `gtk.ListBoxRow.setHeader` or
/// just change the state of the current header widget.
pub const ListBoxUpdateHeaderFunc = *const fn (p_row: *gtk.ListBoxRow, p_before: ?*gtk.ListBoxRow, p_user_data: ?*anyopaque) callconv(.c) void;

/// A user function supplied when calling `gtk.Menu.attachToWidget` which
/// will be called when the menu is later detached from the widget.
pub const MenuDetachFunc = *const fn (p_attach_widget: *gtk.Widget, p_menu: *gtk.Menu) callconv(.c) void;

/// A user function supplied when calling `gtk.Menu.popup` which
/// controls the positioning of the menu when it is displayed.  The
/// function sets the `x` and `y` parameters to the coordinates where the
/// menu is to be drawn.  To make the menu appear on a different
/// monitor than the mouse pointer, `gtk.Menu.setMonitor` must be
/// called.
pub const MenuPositionFunc = *const fn (p_menu: *gtk.Menu, p_x: *c_int, p_y: *c_int, p_push_in: *c_int, p_user_data: ?*anyopaque) callconv(.c) void;

/// A multihead-aware GTK+ module may have a `gtk_module_display_init` function
/// with this prototype. GTK+ calls this function for each opened display.
pub const ModuleDisplayInitFunc = *const fn (p_display: *gdk.Display) callconv(.c) void;

/// Each GTK+ module must have a function `gtk_module_init` with this prototype.
/// This function is called after loading the module.
pub const ModuleInitFunc = *const fn (p_argc: ?*c_int, p_argv: ?[*]*[*:0]u8) callconv(.c) void;

/// The type of function that is passed to
/// `gtk.printRunPageSetupDialogAsync`.
///
/// This function will be called when the page setup dialog
/// is dismissed, and also serves as destroy notify for `data`.
pub const PageSetupDoneFunc = *const fn (p_page_setup: *gtk.PageSetup, p_data: ?*anyopaque) callconv(.c) void;

pub const PrintSettingsFunc = *const fn (p_key: [*:0]const u8, p_value: [*:0]const u8, p_user_data: ?*anyopaque) callconv(.c) void;

pub const RcPropertyParser = *const fn (p_pspec: *const gobject.ParamSpec, p_rc_string: *const glib.String, p_property_value: *gobject.Value) callconv(.c) c_int;

/// The type of function that is used with custom filters,
/// see `gtk.RecentFilter.addCustom`.
pub const RecentFilterFunc = *const fn (p_filter_info: *const gtk.RecentFilterInfo, p_user_data: ?*anyopaque) callconv(.c) c_int;

pub const RecentSortFunc = *const fn (p_a: *gtk.RecentInfo, p_b: *gtk.RecentInfo, p_user_data: ?*anyopaque) callconv(.c) c_int;

pub const StylePropertyParser = *const fn (p_string: [*:0]const u8, p_value: *gobject.Value, p_error: ?*?*glib.Error) callconv(.c) c_int;

/// A function that is called to deserialize rich text that has been
/// serialized with `gtk.TextBuffer.serialize`, and insert it at `iter`.
pub const TextBufferDeserializeFunc = *const fn (p_register_buffer: *gtk.TextBuffer, p_content_buffer: *gtk.TextBuffer, p_iter: *gtk.TextIter, p_data: [*]const u8, p_length: usize, p_create_tags: c_int, p_user_data: ?*anyopaque, p_error: ?*?*glib.Error) callconv(.c) c_int;

/// A function that is called to serialize the content of a text buffer.
/// It must return the serialized form of the content.
pub const TextBufferSerializeFunc = *const fn (p_register_buffer: *gtk.TextBuffer, p_content_buffer: *gtk.TextBuffer, p_start: *const gtk.TextIter, p_end: *const gtk.TextIter, p_length: *usize, p_user_data: ?*anyopaque) callconv(.c) ?[*]u8;

pub const TextCharPredicate = *const fn (p_ch: u32, p_user_data: ?*anyopaque) callconv(.c) c_int;

pub const TextTagTableForeach = *const fn (p_tag: *gtk.TextTag, p_data: ?*anyopaque) callconv(.c) void;

/// Callback type for adding a function to update animations. See `gtk.Widget.addTickCallback`.
pub const TickCallback = *const fn (p_widget: *gtk.Widget, p_frame_clock: *gdk.FrameClock, p_user_data: ?*anyopaque) callconv(.c) c_int;

/// The function used to translate messages in e.g. `gtk.IconFactory`
/// and `gtk.ActionGroup`.
pub const TranslateFunc = *const fn (p_path: [*:0]const u8, p_func_data: ?*anyopaque) callconv(.c) [*:0]u8;

/// A function to set the properties of a cell instead of just using the
/// straight mapping between the cell and the model.  This is useful for
/// customizing the cell renderer.  For example, a function might get an
/// integer from the `tree_model`, and render it to the “text” attribute of
/// “cell” by converting it to its written equivalent.  This is set by
/// calling `gtk.TreeViewColumn.setCellDataFunc`
pub const TreeCellDataFunc = *const fn (p_tree_column: *gtk.TreeViewColumn, p_cell: *gtk.CellRenderer, p_tree_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_data: ?*anyopaque) callconv(.c) void;

pub const TreeDestroyCountFunc = *const fn (p_tree_view: *gtk.TreeView, p_path: *gtk.TreePath, p_children: c_int, p_user_data: ?*anyopaque) callconv(.c) void;

/// A GtkTreeIterCompareFunc should return a negative integer, zero, or a positive
/// integer if `a` sorts before `b`, `a` sorts with `b`, or `a` sorts after `b`
/// respectively. If two iters compare as equal, their order in the sorted model
/// is undefined. In order to ensure that the `gtk.TreeSortable` behaves as
/// expected, the GtkTreeIterCompareFunc must define a partial order on
/// the model, i.e. it must be reflexive, antisymmetric and transitive.
///
/// For example, if `model` is a product catalogue, then a compare function
/// for the “price” column could be one which returns
/// `price_of(`a`) - price_of(`b`)`.
pub const TreeIterCompareFunc = *const fn (p_model: *gtk.TreeModel, p_a: *gtk.TreeIter, p_b: *gtk.TreeIter, p_user_data: ?*anyopaque) callconv(.c) c_int;

/// A function which calculates display values from raw values in the model.
/// It must fill `value` with the display value for the column `column` in the
/// row indicated by `iter`.
///
/// Since this function is called for each data access, it’s not a
/// particularly efficient operation.
pub const TreeModelFilterModifyFunc = *const fn (p_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_value: *gobject.Value, p_column: c_int, p_data: ?*anyopaque) callconv(.c) void;

/// A function which decides whether the row indicated by `iter` is visible.
pub const TreeModelFilterVisibleFunc = *const fn (p_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_data: ?*anyopaque) callconv(.c) c_int;

/// Type of the callback passed to `gtk.TreeModel.foreach` to
/// iterate over the rows in a tree model.
pub const TreeModelForeachFunc = *const fn (p_model: *gtk.TreeModel, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter, p_data: ?*anyopaque) callconv(.c) c_int;

/// A function used by `gtk.TreeSelection.selectedForeach` to map all
/// selected rows.  It will be called on every selected row in the view.
pub const TreeSelectionForeachFunc = *const fn (p_model: *gtk.TreeModel, p_path: *gtk.TreePath, p_iter: *gtk.TreeIter, p_data: ?*anyopaque) callconv(.c) void;

/// A function used by `gtk.TreeSelection.setSelectFunction` to filter
/// whether or not a row may be selected.  It is called whenever a row's
/// state might change.  A return value of `TRUE` indicates to `selection`
/// that it is okay to change the selection.
pub const TreeSelectionFunc = *const fn (p_selection: *gtk.TreeSelection, p_model: *gtk.TreeModel, p_path: *gtk.TreePath, p_path_currently_selected: c_int, p_data: ?*anyopaque) callconv(.c) c_int;

/// Function type for determining whether `column` can be dropped in a
/// particular spot (as determined by `prev_column` and `next_column`).  In
/// left to right locales, `prev_column` is on the left of the potential drop
/// spot, and `next_column` is on the right.  In right to left mode, this is
/// reversed.  This function should return `TRUE` if the spot is a valid drop
/// spot.  Please note that returning `TRUE` does not actually indicate that
/// the column drop was made, but is meant only to indicate a possible drop
/// spot to the user.
pub const TreeViewColumnDropFunc = *const fn (p_tree_view: *gtk.TreeView, p_column: *gtk.TreeViewColumn, p_prev_column: *gtk.TreeViewColumn, p_next_column: *gtk.TreeViewColumn, p_data: ?*anyopaque) callconv(.c) c_int;

/// Function used for `gtk.TreeView.mapExpandedRows`.
pub const TreeViewMappingFunc = *const fn (p_tree_view: *gtk.TreeView, p_path: *gtk.TreePath, p_user_data: ?*anyopaque) callconv(.c) void;

/// Function type for determining whether the row pointed to by `iter` should
/// be rendered as a separator. A common way to implement this is to have a
/// boolean column in the model, whose values the `gtk.TreeViewRowSeparatorFunc`
/// returns.
pub const TreeViewRowSeparatorFunc = *const fn (p_model: *gtk.TreeModel, p_iter: *gtk.TreeIter, p_data: ?*anyopaque) callconv(.c) c_int;

/// A function used for checking whether a row in `model` matches
/// a search key string entered by the user. Note the return value
/// is reversed from what you would normally expect, though it
/// has some similarity to `strcmp` returning 0 for equal strings.
pub const TreeViewSearchEqualFunc = *const fn (p_model: *gtk.TreeModel, p_column: c_int, p_key: [*:0]const u8, p_iter: *gtk.TreeIter, p_search_data: ?*anyopaque) callconv(.c) c_int;

pub const TreeViewSearchPositionFunc = *const fn (p_tree_view: *gtk.TreeView, p_search_dialog: *gtk.Widget, p_user_data: ?*anyopaque) callconv(.c) void;

/// Like `gtk.getBinaryAge`, but from the headers used at
/// application compile time, rather than from the library linked
/// against at application run time.
pub const BINARY_AGE = 2449;
/// Constant to return from a signal handler for the `gtk.SpinButton.signals.input`
/// signal in case of conversion failure.
pub const INPUT_ERROR = -1;
/// Like `gtk.getInterfaceAge`, but from the headers used at
/// application compile time, rather than from the library linked
/// against at application run time.
pub const INTERFACE_AGE = 32;
/// The name used for the stock full offset included by `gtk.LevelBar`.
pub const LEVEL_BAR_OFFSET_FULL = "full";
/// The name used for the stock high offset included by `gtk.LevelBar`.
pub const LEVEL_BAR_OFFSET_HIGH = "high";
/// The name used for the stock low offset included by `gtk.LevelBar`.
pub const LEVEL_BAR_OFFSET_LOW = "low";
/// Like `gtk.getMajorVersion`, but from the headers used at
/// application compile time, rather than from the library linked
/// against at application run time.
pub const MAJOR_VERSION = 3;
/// The maximum length of sequences in compose tables.
pub const MAX_COMPOSE_LEN = 7;
/// Like `gtk.getMicroVersion`, but from the headers used at
/// application compile time, rather than from the library linked
/// against at application run time.
pub const MICRO_VERSION = 49;
/// Like `gtk.getMinorVersion`, but from the headers used at
/// application compile time, rather than from the library linked
/// against at application run time.
pub const MINOR_VERSION = 24;
/// Name for the A3 paper size.
pub const PAPER_NAME_A3 = "iso_a3";
/// Name for the A4 paper size.
pub const PAPER_NAME_A4 = "iso_a4";
/// Name for the A5 paper size.
pub const PAPER_NAME_A5 = "iso_a5";
/// Name for the B5 paper size.
pub const PAPER_NAME_B5 = "iso_b5";
/// Name for the Executive paper size.
pub const PAPER_NAME_EXECUTIVE = "na_executive";
/// Name for the Legal paper size.
pub const PAPER_NAME_LEGAL = "na_legal";
/// Name for the Letter paper size.
pub const PAPER_NAME_LETTER = "na_letter";
pub const PATH_PRIO_MASK = 15;
pub const PRINT_SETTINGS_COLLATE = "collate";
pub const PRINT_SETTINGS_DEFAULT_SOURCE = "default-source";
pub const PRINT_SETTINGS_DITHER = "dither";
pub const PRINT_SETTINGS_DUPLEX = "duplex";
pub const PRINT_SETTINGS_FINISHINGS = "finishings";
pub const PRINT_SETTINGS_MEDIA_TYPE = "media-type";
pub const PRINT_SETTINGS_NUMBER_UP = "number-up";
pub const PRINT_SETTINGS_NUMBER_UP_LAYOUT = "number-up-layout";
pub const PRINT_SETTINGS_N_COPIES = "n-copies";
pub const PRINT_SETTINGS_ORIENTATION = "orientation";
/// The key used by the “Print to file” printer to store the file
/// name of the output without the path to the directory and the
/// file extension.
pub const PRINT_SETTINGS_OUTPUT_BASENAME = "output-basename";
pub const PRINT_SETTINGS_OUTPUT_BIN = "output-bin";
/// The key used by the “Print to file” printer to store the
/// directory to which the output should be written.
pub const PRINT_SETTINGS_OUTPUT_DIR = "output-dir";
/// The key used by the “Print to file” printer to store the format
/// of the output. The supported values are “PS” and “PDF”.
pub const PRINT_SETTINGS_OUTPUT_FILE_FORMAT = "output-file-format";
/// The key used by the “Print to file” printer to store the URI
/// to which the output should be written. GTK+ itself supports
/// only “file://” URIs.
pub const PRINT_SETTINGS_OUTPUT_URI = "output-uri";
pub const PRINT_SETTINGS_PAGE_RANGES = "page-ranges";
pub const PRINT_SETTINGS_PAGE_SET = "page-set";
pub const PRINT_SETTINGS_PAPER_FORMAT = "paper-format";
pub const PRINT_SETTINGS_PAPER_HEIGHT = "paper-height";
pub const PRINT_SETTINGS_PAPER_WIDTH = "paper-width";
pub const PRINT_SETTINGS_PRINTER = "printer";
pub const PRINT_SETTINGS_PRINTER_LPI = "printer-lpi";
pub const PRINT_SETTINGS_PRINT_PAGES = "print-pages";
pub const PRINT_SETTINGS_QUALITY = "quality";
pub const PRINT_SETTINGS_RESOLUTION = "resolution";
pub const PRINT_SETTINGS_RESOLUTION_X = "resolution-x";
pub const PRINT_SETTINGS_RESOLUTION_Y = "resolution-y";
pub const PRINT_SETTINGS_REVERSE = "reverse";
pub const PRINT_SETTINGS_SCALE = "scale";
pub const PRINT_SETTINGS_USE_COLOR = "use-color";
pub const PRINT_SETTINGS_WIN32_DRIVER_EXTRA = "win32-driver-extra";
pub const PRINT_SETTINGS_WIN32_DRIVER_VERSION = "win32-driver-version";
/// Use this priority for functionality related to size allocation.
///
/// It is used internally by GTK+ to compute the sizes of widgets.
/// This priority is higher than `GDK_PRIORITY_REDRAW` to avoid
/// resizing a widget which was just redrawn.
pub const PRIORITY_RESIZE = 110;
/// The “About” item.
/// ![](help-about.png)
pub const STOCK_ABOUT = "gtk-about";
/// The “Add” item and icon.
pub const STOCK_ADD = "gtk-add";
/// The “Apply” item and icon.
pub const STOCK_APPLY = "gtk-apply";
/// The “Bold” item and icon.
pub const STOCK_BOLD = "gtk-bold";
/// The “Cancel” item and icon.
pub const STOCK_CANCEL = "gtk-cancel";
/// The “Caps Lock Warning” icon.
pub const STOCK_CAPS_LOCK_WARNING = "gtk-caps-lock-warning";
/// The “CD-Rom” item and icon.
pub const STOCK_CDROM = "gtk-cdrom";
/// The “Clear” item and icon.
pub const STOCK_CLEAR = "gtk-clear";
/// The “Close” item and icon.
pub const STOCK_CLOSE = "gtk-close";
/// The “Color Picker” item and icon.
pub const STOCK_COLOR_PICKER = "gtk-color-picker";
/// The “Connect” icon.
pub const STOCK_CONNECT = "gtk-connect";
/// The “Convert” item and icon.
pub const STOCK_CONVERT = "gtk-convert";
/// The “Copy” item and icon.
pub const STOCK_COPY = "gtk-copy";
/// The “Cut” item and icon.
pub const STOCK_CUT = "gtk-cut";
/// The “Delete” item and icon.
pub const STOCK_DELETE = "gtk-delete";
/// The “Authentication” item and icon.
pub const STOCK_DIALOG_AUTHENTICATION = "gtk-dialog-authentication";
/// The “Error” item and icon.
pub const STOCK_DIALOG_ERROR = "gtk-dialog-error";
/// The “Information” item and icon.
pub const STOCK_DIALOG_INFO = "gtk-dialog-info";
/// The “Question” item and icon.
pub const STOCK_DIALOG_QUESTION = "gtk-dialog-question";
/// The “Warning” item and icon.
pub const STOCK_DIALOG_WARNING = "gtk-dialog-warning";
/// The “Directory” icon.
pub const STOCK_DIRECTORY = "gtk-directory";
/// The “Discard” item.
pub const STOCK_DISCARD = "gtk-discard";
/// The “Disconnect” icon.
pub const STOCK_DISCONNECT = "gtk-disconnect";
/// The “Drag-And-Drop” icon.
pub const STOCK_DND = "gtk-dnd";
/// The “Drag-And-Drop multiple” icon.
pub const STOCK_DND_MULTIPLE = "gtk-dnd-multiple";
/// The “Edit” item and icon.
pub const STOCK_EDIT = "gtk-edit";
/// The “Execute” item and icon.
pub const STOCK_EXECUTE = "gtk-execute";
/// The “File” item and icon.
///
/// Since 3.0, this item has a label, before it only had an icon.
pub const STOCK_FILE = "gtk-file";
/// The “Find” item and icon.
pub const STOCK_FIND = "gtk-find";
/// The “Find and Replace” item and icon.
pub const STOCK_FIND_AND_REPLACE = "gtk-find-and-replace";
/// The “Floppy” item and icon.
pub const STOCK_FLOPPY = "gtk-floppy";
/// The “Fullscreen” item and icon.
pub const STOCK_FULLSCREEN = "gtk-fullscreen";
/// The “Bottom” item and icon.
pub const STOCK_GOTO_BOTTOM = "gtk-goto-bottom";
/// The “First” item and icon. The icon has an RTL variant.
pub const STOCK_GOTO_FIRST = "gtk-goto-first";
/// The “Last” item and icon. The icon has an RTL variant.
pub const STOCK_GOTO_LAST = "gtk-goto-last";
/// The “Top” item and icon.
pub const STOCK_GOTO_TOP = "gtk-goto-top";
/// The “Back” item and icon. The icon has an RTL variant.
pub const STOCK_GO_BACK = "gtk-go-back";
/// The “Down” item and icon.
pub const STOCK_GO_DOWN = "gtk-go-down";
/// The “Forward” item and icon. The icon has an RTL variant.
pub const STOCK_GO_FORWARD = "gtk-go-forward";
/// The “Up” item and icon.
pub const STOCK_GO_UP = "gtk-go-up";
/// The “Harddisk” item and icon.
pub const STOCK_HARDDISK = "gtk-harddisk";
/// The “Help” item and icon.
pub const STOCK_HELP = "gtk-help";
/// The “Home” item and icon.
pub const STOCK_HOME = "gtk-home";
/// The “Indent” item and icon. The icon has an RTL variant.
pub const STOCK_INDENT = "gtk-indent";
/// The “Index” item and icon.
pub const STOCK_INDEX = "gtk-index";
/// The “Info” item and icon.
pub const STOCK_INFO = "gtk-info";
/// The “Italic” item and icon.
pub const STOCK_ITALIC = "gtk-italic";
/// The “Jump to” item and icon. The icon has an RTL variant.
pub const STOCK_JUMP_TO = "gtk-jump-to";
/// The “Center” item and icon.
pub const STOCK_JUSTIFY_CENTER = "gtk-justify-center";
/// The “Fill” item and icon.
pub const STOCK_JUSTIFY_FILL = "gtk-justify-fill";
/// The “Left” item and icon.
pub const STOCK_JUSTIFY_LEFT = "gtk-justify-left";
/// The “Right” item and icon.
pub const STOCK_JUSTIFY_RIGHT = "gtk-justify-right";
/// The “Leave Fullscreen” item and icon.
pub const STOCK_LEAVE_FULLSCREEN = "gtk-leave-fullscreen";
/// The “Media Forward” item and icon. The icon has an RTL variant.
pub const STOCK_MEDIA_FORWARD = "gtk-media-forward";
/// The “Media Next” item and icon. The icon has an RTL variant.
pub const STOCK_MEDIA_NEXT = "gtk-media-next";
/// The “Media Pause” item and icon.
pub const STOCK_MEDIA_PAUSE = "gtk-media-pause";
/// The “Media Play” item and icon. The icon has an RTL variant.
pub const STOCK_MEDIA_PLAY = "gtk-media-play";
/// The “Media Previous” item and icon. The icon has an RTL variant.
pub const STOCK_MEDIA_PREVIOUS = "gtk-media-previous";
/// The “Media Record” item and icon.
pub const STOCK_MEDIA_RECORD = "gtk-media-record";
/// The “Media Rewind” item and icon. The icon has an RTL variant.
pub const STOCK_MEDIA_REWIND = "gtk-media-rewind";
/// The “Media Stop” item and icon.
pub const STOCK_MEDIA_STOP = "gtk-media-stop";
/// The “Missing image” icon.
pub const STOCK_MISSING_IMAGE = "gtk-missing-image";
/// The “Network” item and icon.
pub const STOCK_NETWORK = "gtk-network";
/// The “New” item and icon.
pub const STOCK_NEW = "gtk-new";
/// The “No” item and icon.
pub const STOCK_NO = "gtk-no";
/// The “OK” item and icon.
pub const STOCK_OK = "gtk-ok";
/// The “Open” item and icon.
pub const STOCK_OPEN = "gtk-open";
/// The “Landscape Orientation” item and icon.
pub const STOCK_ORIENTATION_LANDSCAPE = "gtk-orientation-landscape";
/// The “Portrait Orientation” item and icon.
pub const STOCK_ORIENTATION_PORTRAIT = "gtk-orientation-portrait";
/// The “Reverse Landscape Orientation” item and icon.
pub const STOCK_ORIENTATION_REVERSE_LANDSCAPE = "gtk-orientation-reverse-landscape";
/// The “Reverse Portrait Orientation” item and icon.
pub const STOCK_ORIENTATION_REVERSE_PORTRAIT = "gtk-orientation-reverse-portrait";
/// The “Page Setup” item and icon.
pub const STOCK_PAGE_SETUP = "gtk-page-setup";
/// The “Paste” item and icon.
pub const STOCK_PASTE = "gtk-paste";
/// The “Preferences” item and icon.
pub const STOCK_PREFERENCES = "gtk-preferences";
/// The “Print” item and icon.
pub const STOCK_PRINT = "gtk-print";
/// The “Print Error” icon.
pub const STOCK_PRINT_ERROR = "gtk-print-error";
/// The “Print Paused” icon.
pub const STOCK_PRINT_PAUSED = "gtk-print-paused";
/// The “Print Preview” item and icon.
pub const STOCK_PRINT_PREVIEW = "gtk-print-preview";
/// The “Print Report” icon.
pub const STOCK_PRINT_REPORT = "gtk-print-report";
/// The “Print Warning” icon.
pub const STOCK_PRINT_WARNING = "gtk-print-warning";
/// The “Properties” item and icon.
pub const STOCK_PROPERTIES = "gtk-properties";
/// The “Quit” item and icon.
pub const STOCK_QUIT = "gtk-quit";
/// The “Redo” item and icon. The icon has an RTL variant.
pub const STOCK_REDO = "gtk-redo";
/// The “Refresh” item and icon.
pub const STOCK_REFRESH = "gtk-refresh";
/// The “Remove” item and icon.
pub const STOCK_REMOVE = "gtk-remove";
/// The “Revert” item and icon. The icon has an RTL variant.
pub const STOCK_REVERT_TO_SAVED = "gtk-revert-to-saved";
/// The “Save” item and icon.
pub const STOCK_SAVE = "gtk-save";
/// The “Save As” item and icon.
pub const STOCK_SAVE_AS = "gtk-save-as";
/// The “Select All” item and icon.
pub const STOCK_SELECT_ALL = "gtk-select-all";
/// The “Color” item and icon.
pub const STOCK_SELECT_COLOR = "gtk-select-color";
/// The “Font” item and icon.
pub const STOCK_SELECT_FONT = "gtk-select-font";
/// The “Ascending” item and icon.
pub const STOCK_SORT_ASCENDING = "gtk-sort-ascending";
/// The “Descending” item and icon.
pub const STOCK_SORT_DESCENDING = "gtk-sort-descending";
/// The “Spell Check” item and icon.
pub const STOCK_SPELL_CHECK = "gtk-spell-check";
/// The “Stop” item and icon.
pub const STOCK_STOP = "gtk-stop";
/// The “Strikethrough” item and icon.
pub const STOCK_STRIKETHROUGH = "gtk-strikethrough";
/// The “Undelete” item and icon. The icon has an RTL variant.
pub const STOCK_UNDELETE = "gtk-undelete";
/// The “Underline” item and icon.
pub const STOCK_UNDERLINE = "gtk-underline";
/// The “Undo” item and icon. The icon has an RTL variant.
pub const STOCK_UNDO = "gtk-undo";
/// The “Unindent” item and icon. The icon has an RTL variant.
pub const STOCK_UNINDENT = "gtk-unindent";
/// The “Yes” item and icon.
pub const STOCK_YES = "gtk-yes";
/// The “Zoom 100%” item and icon.
pub const STOCK_ZOOM_100 = "gtk-zoom-100";
/// The “Zoom to Fit” item and icon.
pub const STOCK_ZOOM_FIT = "gtk-zoom-fit";
/// The “Zoom In” item and icon.
pub const STOCK_ZOOM_IN = "gtk-zoom-in";
/// The “Zoom Out” item and icon.
pub const STOCK_ZOOM_OUT = "gtk-zoom-out";
/// A CSS class to match an accelerator.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_ACCELERATOR = "accelerator";
/// A CSS class used when rendering an arrow element.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_ARROW = "arrow";
/// A CSS class to match the window background.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_BACKGROUND = "background";
/// A CSS class to indicate an area at the bottom of a widget.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_BOTTOM = "bottom";
/// A CSS class to match buttons.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_BUTTON = "button";
/// A CSS class to match calendars.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_CALENDAR = "calendar";
/// A CSS class to match content rendered in cell views.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_CELL = "cell";
/// A CSS class to match check boxes.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_CHECK = "check";
/// A CSS class to match combobox entries.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_COMBOBOX_ENTRY = "combobox-entry";
/// A CSS class to match context menus.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_CONTEXT_MENU = "context-menu";
/// A CSS class that gets added to windows which have client-side decorations.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_CSD = "csd";
/// A CSS class used when rendering a drag handle for
/// text selection.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_CURSOR_HANDLE = "cursor-handle";
/// A CSS class to match the default widget.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_DEFAULT = "default";
/// A CSS class used when an action (usually a button) is
/// one that is expected to remove or destroy something visible
/// to the user.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_DESTRUCTIVE_ACTION = "destructive-action";
/// A CSS class to match dimmed labels.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_DIM_LABEL = "dim-label";
/// A CSS class for a drag-and-drop indicator.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_DND = "dnd";
/// A CSS class defining a dock area.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_DOCK = "dock";
/// A CSS class to match text entries.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_ENTRY = "entry";
/// A CSS class for an area displaying an error message,
/// such as those in infobars.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_ERROR = "error";
/// A CSS class defining an expander, such as those in treeviews.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_EXPANDER = "expander";
/// A CSS class that is added when widgets that usually have
/// a frame or border (like buttons or entries) should appear
/// without it.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_FLAT = "flat";
/// A CSS class defining a frame delimiting content, such as
/// `gtk.Frame` or the scrolled window frame around the
/// scrollable area.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_FRAME = "frame";
/// A CSS class defining a resize grip.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_GRIP = "grip";
/// A CSS class to match a header element.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_HEADER = "header";
/// A CSS class defining a highlighted area, such as headings in
/// assistants and calendars.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_HIGHLIGHT = "highlight";
/// A CSS class for horizontally layered widgets.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_HORIZONTAL = "horizontal";
/// A CSS class defining an image, such as the icon in an entry.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_IMAGE = "image";
/// A CSS class for an area displaying an informational message,
/// such as those in infobars.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_INFO = "info";
/// A CSS class to match inline toolbars.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_INLINE_TOOLBAR = "inline-toolbar";
/// A CSS class used when rendering a drag handle for
/// the insertion cursor position.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_INSERTION_CURSOR = "insertion-cursor";
/// A CSS class to match labels.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_LABEL = "label";
/// A CSS class to indicate an area at the left of a widget.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_LEFT = "left";
/// A CSS class used when rendering a level indicator, such
/// as a battery charge level, or a password strength.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_LEVEL_BAR = "level-bar";
/// A CSS class to match a linked area, such as a box containing buttons
/// belonging to the same control.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_LINKED = "linked";
/// A CSS class to match lists.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_LIST = "list";
/// A CSS class to match list rows.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_LIST_ROW = "list-row";
/// A CSS class defining marks in a widget, such as in scales.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_MARK = "mark";
/// A CSS class to match menus.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_MENU = "menu";
/// A CSS class to menubars.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_MENUBAR = "menubar";
/// A CSS class to match menu items.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_MENUITEM = "menuitem";
/// A CSS class that is added to message dialogs.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_MESSAGE_DIALOG = "message-dialog";
/// A CSS class that is added to text view that should use
/// a monospace font.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_MONOSPACE = "monospace";
/// A CSS class used when an element needs the user attention,
/// for instance a button in a stack switcher corresponding to
/// a hidden page that changed state.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_NEEDS_ATTENTION = "needs-attention";
/// A CSS class defining a notebook.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_NOTEBOOK = "notebook";
/// A CSS class used when rendering an OSD (On Screen Display) element,
/// on top of another container.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_OSD = "osd";
/// A CSS class that is added on the visual hints that happen
/// when scrolling is attempted past the limits of a scrollable
/// area.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_OVERSHOOT = "overshoot";
/// A CSS class for a pane separator, such as those in `gtk.Paned`.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_PANE_SEPARATOR = "pane-separator";
/// A CSS class that is added to areas that should look like paper.
///
/// This is used in print previews and themes are encouraged to
/// style it as black text on white background.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_PAPER = "paper";
/// A CSS class that matches popovers.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_POPOVER = "popover";
/// A CSS class that is added to the toplevel windows used for menus.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_POPUP = "popup";
/// A CSS class to match primary toolbars.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_PRIMARY_TOOLBAR = "primary-toolbar";
/// A CSS class to use when rendering activity as a progressbar.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_PROGRESSBAR = "progressbar";
/// A CSS class to use when rendering a pulse in an indeterminate progress bar.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_PULSE = "pulse";
/// A CSS class for an area displaying a question to the user,
/// such as those in infobars.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_QUESTION = "question";
/// A CSS class to match radio buttons.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_RADIO = "radio";
/// A CSS class to match a raised control, such as a raised
/// button on a toolbar.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_RAISED = "raised";
/// A CSS class used to indicate a read-only state.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_READ_ONLY = "read-only";
/// A CSS class to indicate an area at the right of a widget.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_RIGHT = "right";
/// A CSS class to match the rubberband selection rectangle.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_RUBBERBAND = "rubberband";
/// A CSS class to match scale widgets.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_SCALE = "scale";
/// A CSS class to match scale widgets with marks attached,
/// all the marks are above for horizontal `gtk.Scale`.
/// left for vertical `gtk.Scale`.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_SCALE_HAS_MARKS_ABOVE = "scale-has-marks-above";
/// A CSS class to match scale widgets with marks attached,
/// all the marks are below for horizontal `gtk.Scale`,
/// right for vertical `gtk.Scale`.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_SCALE_HAS_MARKS_BELOW = "scale-has-marks-below";
/// A CSS class to match scrollbars.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_SCROLLBAR = "scrollbar";
/// A CSS class to match the junction area between an horizontal
/// and vertical scrollbar, when they’re both shown.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_SCROLLBARS_JUNCTION = "scrollbars-junction";
/// A CSS class for a separator.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_SEPARATOR = "separator";
/// A CSS class defining a sidebar, such as the left side in
/// a file chooser.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_SIDEBAR = "sidebar";
/// A CSS class to match sliders.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_SLIDER = "slider";
/// A CSS class defining an spinbutton.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_SPINBUTTON = "spinbutton";
/// A CSS class to use when rendering activity as a “spinner”.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_SPINNER = "spinner";
/// A CSS class to match statusbars.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_STATUSBAR = "statusbar";
/// A CSS class used for the subtitle label in a titlebar in
/// a toplevel window.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_SUBTITLE = "subtitle";
/// A CSS class used when an action (usually a button) is the
/// primary suggested action in a specific context.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_SUGGESTED_ACTION = "suggested-action";
/// A CSS class used for the title label in a titlebar in
/// a toplevel window.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_TITLE = "title";
/// A CSS class used when rendering a titlebar in a toplevel window.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_TITLEBAR = "titlebar";
/// A CSS class to match toolbars.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_TOOLBAR = "toolbar";
/// A CSS class to match tooltip windows.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_TOOLTIP = "tooltip";
/// A CSS class to indicate an area at the top of a widget.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_TOP = "top";
/// A CSS class for touch selection popups on entries
/// and text views.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_TOUCH_SELECTION = "touch-selection";
/// A CSS class to match troughs, as in scrollbars and progressbars.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_TROUGH = "trough";
/// A CSS class that is added on the visual hints that happen
/// where content is 'scrolled off' and can be made visible
/// by scrolling.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_UNDERSHOOT = "undershoot";
/// A CSS class for vertically layered widgets.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_VERTICAL = "vertical";
/// A CSS class defining a view, such as iconviews or treeviews.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_VIEW = "view";
/// A CSS class for an area displaying a warning message,
/// such as those in infobars.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_WARNING = "warning";
/// A CSS class to indicate that a UI element should be 'wide'.
/// Used by `gtk.Paned`.
///
/// Refer to individual widget documentation for used style classes.
pub const STYLE_CLASS_WIDE = "wide";
/// A property holding the background color of rendered elements as a `gdk.RGBA`.
pub const STYLE_PROPERTY_BACKGROUND_COLOR = "background-color";
/// A property holding the element’s background as a `cairo.Pattern`.
pub const STYLE_PROPERTY_BACKGROUND_IMAGE = "background-image";
/// A property holding the element’s border color as a `gdk.RGBA`.
pub const STYLE_PROPERTY_BORDER_COLOR = "border-color";
/// A property holding the rendered element’s border radius in pixels as a `gint`.
pub const STYLE_PROPERTY_BORDER_RADIUS = "border-radius";
/// A property holding the element’s border style as a `gtk.BorderStyle`.
pub const STYLE_PROPERTY_BORDER_STYLE = "border-style";
/// A property holding the rendered element’s border width in pixels as
/// a `gtk.Border`. The border is the intermediary spacing property of the
/// padding/border/margin series.
///
/// `gtk.renderFrame` uses this property to find out the frame line width,
/// so `GtkWidgets` rendering frames may need to add up this padding when
/// requesting size
pub const STYLE_PROPERTY_BORDER_WIDTH = "border-width";
/// A property holding the foreground color of rendered elements as a `gdk.RGBA`.
pub const STYLE_PROPERTY_COLOR = "color";
/// A property holding the font properties used when rendering text
/// as a `pango.FontDescription`.
pub const STYLE_PROPERTY_FONT = "font";
/// A property holding the rendered element’s margin as a `gtk.Border`. The
/// margin is defined as the spacing between the border of the element
/// and its surrounding elements. It is external to `gtk.Widget`'s
/// size allocations, and the most external spacing property of the
/// padding/border/margin series.
pub const STYLE_PROPERTY_MARGIN = "margin";
/// A property holding the rendered element’s padding as a `gtk.Border`. The
/// padding is defined as the spacing between the inner part of the element border
/// and its child. It’s the innermost spacing property of the padding/border/margin
/// series.
pub const STYLE_PROPERTY_PADDING = "padding";
/// A priority that can be used when adding a `gtk.StyleProvider`
/// for application-specific style information.
pub const STYLE_PROVIDER_PRIORITY_APPLICATION = 600;
/// The priority used for default style information
/// that is used in the absence of themes.
///
/// Note that this is not very useful for providing default
/// styling for custom style classes - themes are likely to
/// override styling provided at this priority with
/// catch-all `* {...}` rules.
pub const STYLE_PROVIDER_PRIORITY_FALLBACK = 1;
/// The priority used for style information provided
/// via `gtk.Settings`.
///
/// This priority is higher than `GTK_STYLE_PROVIDER_PRIORITY_THEME`
/// to let settings override themes.
pub const STYLE_PROVIDER_PRIORITY_SETTINGS = 400;
/// The priority used for style information provided
/// by themes.
pub const STYLE_PROVIDER_PRIORITY_THEME = 200;
/// The priority used for the style information from
/// `XDG_CONFIG_HOME/gtk-3.0/gtk.css`.
///
/// You should not use priorities higher than this, to
/// give the user the last word.
pub const STYLE_PROVIDER_PRIORITY_USER = 800;
/// A widget region name to define a treeview column.
pub const STYLE_REGION_COLUMN = "column";
/// A widget region name to define a treeview column header.
pub const STYLE_REGION_COLUMN_HEADER = "column-header";
/// A widget region name to define a treeview row.
pub const STYLE_REGION_ROW = "row";
/// A widget region name to define a notebook tab.
pub const STYLE_REGION_TAB = "tab";
/// The priority at which the text view validates onscreen lines
/// in an idle job in the background.
pub const TEXT_VIEW_PRIORITY_VALIDATE = 125;
/// The GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID can be used to make a
/// `gtk.TreeSortable` use the default sort function.
///
/// See also `gtk.TreeSortable.setSortColumnId`
pub const TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID = -1;
/// The GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID can be used to make a
/// `gtk.TreeSortable` use no sorting.
///
/// See also `gtk.TreeSortable.setSortColumnId`
pub const TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID = -2;

test {
    @setEvalBranchQuota(100_000);
    std.testing.refAllDecls(@This());
    std.testing.refAllDecls(ext);
}
