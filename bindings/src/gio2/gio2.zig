pub const ext = @import("ext.zig");
const gio = @This();

const std = @import("std");
const compat = @import("compat");
const gobject = @import("gobject2");
const glib = @import("glib2");
const gmodule = @import("gmodule2");
/// `GAppInfoMonitor` monitors application information for changes.
///
/// `GAppInfoMonitor` is a very simple object used for monitoring the app
/// info database for changes (newly installed or removed applications).
///
/// Call `gio.AppInfoMonitor.get` to get a `GAppInfoMonitor` and connect
/// to the `gio.AppInfoMonitor.signals.changed` signal. The signal will be emitted once when
/// the app info database changes, and will not be emitted again until after the
/// next call to `gio.AppInfo.getAll` or another `g_app_info_*()` function.
/// This is because monitoring the app info database for changes is expensive.
///
/// The following functions will re-arm the `gio.AppInfoMonitor.signals.changed`
/// signal so it can be emitted again:
///
///  - `gio.AppInfo.getAll`
///  - `gio.AppInfo.getAllForType`
///  - `gio.AppInfo.getDefaultForType`
///  - `gio.AppInfo.getFallbackForType`
///  - `gio.AppInfo.getRecommendedForType`
///  - [``gio.DesktopAppInfo.getImplementations``](../gio-unix/type_func.DesktopAppInfo.get_implementation.html)
///  - [``gio.DesktopAppInfo.new``](../gio-unix/ctor.DesktopAppInfo.new.html)
///  - [``gio.DesktopAppInfo.newFromFilename``](../gio-unix/ctor.DesktopAppInfo.new_from_filename.html)
///  - [``gio.DesktopAppInfo.newFromKeyfile``](../gio-unix/ctor.DesktopAppInfo.new_from_keyfile.html)
///  - [``gio.DesktopAppInfo.search``](../gio-unix/type_func.DesktopAppInfo.search.html)
///
/// The latter functions are available if using
/// [`GDesktopAppInfo`](../gio-unix/class.DesktopAppInfo.html) from
/// `gio-unix-2.0.pc` (GIR namespace `GioUnix-2.0`).
///
/// In the usual case, applications should try to make note of the change
/// (doing things like invalidating caches) but not act on it. In
/// particular, applications should avoid making calls to `GAppInfo` APIs
/// in response to the change signal, deferring these until the time that
/// the updated data is actually required. The exception to this case is when
/// application information is actually being displayed on the screen
/// (for example, during a search or when the list of all applications is shown).
/// The reason for this is that changes to the list of installed applications
/// often come in groups (like during system updates) and rescanning the list
/// on every change is pointless and expensive.
pub const AppInfoMonitor = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = AppInfoMonitor;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {
        /// Signal emitted when the app info database changes, when applications are
        /// installed or removed.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(AppInfoMonitor, p_instance))),
                    gobject.signalLookup("changed", AppInfoMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Gets the `gio.AppInfoMonitor` for the current thread-default main
    /// context.
    ///
    /// The `gio.AppInfoMonitor` will emit a “changed” signal in the
    /// thread-default main context whenever the list of installed
    /// applications (as reported by `gio.appInfoGetAll`) may have changed.
    ///
    /// The `gio.AppInfoMonitor.signals.changed` signal will only be emitted once until
    /// `gio.appInfoGetAll` (or another `g_app_info_*()` function) is called. Doing
    /// so will re-arm the signal ready to notify about the next change.
    ///
    /// You must only call `gobject.Object.unref` on the return value from under
    /// the same main context as you created it.
    extern fn g_app_info_monitor_get() *gio.AppInfoMonitor;
    pub const get = g_app_info_monitor_get;

    extern fn g_app_info_monitor_get_type() usize;
    pub const getGObjectType = g_app_info_monitor_get_type;

    extern fn g_object_ref(p_self: *gio.AppInfoMonitor) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.AppInfoMonitor) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *AppInfoMonitor, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Integrating the launch with the launching application. This is used to
/// handle for instance startup notification and launching the new application
/// on the same screen as the launching window.
pub const AppLaunchContext = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.AppLaunchContextClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.AppLaunchContextPrivate,

    pub const virtual_methods = struct {
        /// Gets the display string for the `context`. This is used to ensure new
        /// applications are started on the same display as the launching
        /// application, by setting the `DISPLAY` environment variable.
        pub const get_display = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_info: *gio.AppInfo, p_files: *glib.List) ?[*:0]u8 {
                return gobject.ext.as(AppLaunchContext.Class, p_class).f_get_display.?(gobject.ext.as(AppLaunchContext, p_context), p_info, p_files);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_info: *gio.AppInfo, p_files: *glib.List) callconv(.c) ?[*:0]u8) void {
                gobject.ext.as(AppLaunchContext.Class, p_class).f_get_display = @ptrCast(p_implementation);
            }
        };

        /// Initiates startup notification for the application and returns the
        /// `XDG_ACTIVATION_TOKEN` or `DESKTOP_STARTUP_ID` for the launched operation,
        /// if supported.
        ///
        /// The returned token may be referred to equivalently as an ‘activation token’
        /// (using Wayland terminology) or a ‘startup sequence ID’ (using X11 terminology).
        /// The two [are interoperable](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).
        ///
        /// Activation tokens are defined in the [XDG Activation Protocol](https://wayland.app/protocols/xdg-activation-v1),
        /// and startup notification IDs are defined in the
        /// [freedesktop.org Startup Notification Protocol](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
        ///
        /// Support for the XDG Activation Protocol was added in GLib 2.76.
        /// Since GLib 2.82 `info` and `files` can be `NULL`. If that’s not supported by the backend,
        /// the returned token will be `NULL`.
        pub const get_startup_notify_id = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_info: ?*gio.AppInfo, p_files: ?*glib.List) ?[*:0]u8 {
                return gobject.ext.as(AppLaunchContext.Class, p_class).f_get_startup_notify_id.?(gobject.ext.as(AppLaunchContext, p_context), p_info, p_files);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_info: ?*gio.AppInfo, p_files: ?*glib.List) callconv(.c) ?[*:0]u8) void {
                gobject.ext.as(AppLaunchContext.Class, p_class).f_get_startup_notify_id = @ptrCast(p_implementation);
            }
        };

        /// Called when an application has failed to launch, so that it can cancel
        /// the application startup notification started in
        /// `gio.AppLaunchContext.getStartupNotifyId`.
        pub const launch_failed = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_startup_notify_id: [*:0]const u8) void {
                return gobject.ext.as(AppLaunchContext.Class, p_class).f_launch_failed.?(gobject.ext.as(AppLaunchContext, p_context), p_startup_notify_id);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_startup_notify_id: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(AppLaunchContext.Class, p_class).f_launch_failed = @ptrCast(p_implementation);
            }
        };

        pub const launch_started = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_info: *gio.AppInfo, p_platform_data: *glib.Variant) void {
                return gobject.ext.as(AppLaunchContext.Class, p_class).f_launch_started.?(gobject.ext.as(AppLaunchContext, p_context), p_info, p_platform_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_info: *gio.AppInfo, p_platform_data: *glib.Variant) callconv(.c) void) void {
                gobject.ext.as(AppLaunchContext.Class, p_class).f_launch_started = @ptrCast(p_implementation);
            }
        };

        pub const launched = struct {
            pub fn call(p_class: anytype, p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_info: *gio.AppInfo, p_platform_data: *glib.Variant) void {
                return gobject.ext.as(AppLaunchContext.Class, p_class).f_launched.?(gobject.ext.as(AppLaunchContext, p_context), p_info, p_platform_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_context: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_info: *gio.AppInfo, p_platform_data: *glib.Variant) callconv(.c) void) void {
                gobject.ext.as(AppLaunchContext.Class, p_class).f_launched = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// The `gio.AppLaunchContext.signals.launch_failed` signal is emitted when a
        /// `gio.AppInfo` launch fails. The startup notification id is provided,
        /// so that the launcher can cancel the startup notification.
        ///
        /// Because a launch operation may involve spawning multiple instances of the
        /// target application, you should expect this signal to be emitted multiple
        /// times, one for each spawned instance.
        pub const launch_failed = struct {
            pub const name = "launch-failed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_startup_notify_id: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(AppLaunchContext, p_instance))),
                    gobject.signalLookup("launch-failed", AppLaunchContext.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The `gio.AppLaunchContext.signals.launch_started` signal is emitted when a
        /// `gio.AppInfo` is about to be launched. If non-null the
        /// `platform_data` is an GVariant dictionary mapping strings to variants
        /// (ie `a{sv}`), which contains additional, platform-specific data about this
        /// launch. On UNIX, at least the `startup-notification-id` keys will be
        /// present.
        ///
        /// The value of the `startup-notification-id` key (type `s`) is a startup
        /// notification ID corresponding to the format from the [startup-notification
        /// specification](https://specifications.freedesktop.org/startup-notification-spec/startup-notification-0.1.txt).
        /// It allows tracking the progress of the launchee through startup.
        ///
        /// It is guaranteed that this signal is followed by either a
        /// `gio.AppLaunchContext.signals.launched` or
        /// `gio.AppLaunchContext.signals.launch_failed` signal.
        ///
        /// Because a launch operation may involve spawning multiple instances of the
        /// target application, you should expect this signal to be emitted multiple
        /// times, one for each spawned instance.
        pub const launch_started = struct {
            pub const name = "launch-started";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_info: *gio.AppInfo, p_platform_data: ?*glib.Variant, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(AppLaunchContext, p_instance))),
                    gobject.signalLookup("launch-started", AppLaunchContext.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The `gio.AppLaunchContext.signals.launched` signal is emitted when a
        /// `gio.AppInfo` is successfully launched.
        ///
        /// Because a launch operation may involve spawning multiple instances of the
        /// target application, you should expect this signal to be emitted multiple
        /// times, one time for each spawned instance.
        ///
        /// The `platform_data` is an GVariant dictionary mapping
        /// strings to variants (ie `a{sv}`), which contains additional,
        /// platform-specific data about this launch. On UNIX, at least the
        /// `pid` and `startup-notification-id` keys will be present.
        ///
        /// Since 2.72 the `pid` may be 0 if the process id wasn’t known (for
        /// example if the process was launched via D-Bus). The `pid` may not be
        /// set at all in subsequent releases.
        ///
        /// On Windows, `pid` is guaranteed to be valid only for the duration of the
        /// `gio.AppLaunchContext.signals.launched` signal emission; after the signal
        /// is emitted, GLib will call `glib.spawnClosePid`. If you need to
        /// keep the `glib.Pid` after the signal has been emitted, then you can
        /// duplicate `pid` using ``DuplicateHandle``.
        pub const launched = struct {
            pub const name = "launched";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_info: *gio.AppInfo, p_platform_data: *glib.Variant, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(AppLaunchContext, p_instance))),
                    gobject.signalLookup("launched", AppLaunchContext.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new application launch context. This is not normally used,
    /// instead you instantiate a subclass of this, such as
    /// [`GdkAppLaunchContext`](https://docs.gtk.org/gdk4/class.AppLaunchContext.html).
    extern fn g_app_launch_context_new() *gio.AppLaunchContext;
    pub const new = g_app_launch_context_new;

    /// Gets the display string for the `context`. This is used to ensure new
    /// applications are started on the same display as the launching
    /// application, by setting the `DISPLAY` environment variable.
    extern fn g_app_launch_context_get_display(p_context: *AppLaunchContext, p_info: *gio.AppInfo, p_files: *glib.List) ?[*:0]u8;
    pub const getDisplay = g_app_launch_context_get_display;

    /// Gets the complete environment variable list to be passed to
    /// the child process when `context` is used to launch an application.
    /// This is a `NULL`-terminated array of strings, where each string has
    /// the form `KEY=VALUE`.
    extern fn g_app_launch_context_get_environment(p_context: *AppLaunchContext) [*][*:0]u8;
    pub const getEnvironment = g_app_launch_context_get_environment;

    /// Initiates startup notification for the application and returns the
    /// `XDG_ACTIVATION_TOKEN` or `DESKTOP_STARTUP_ID` for the launched operation,
    /// if supported.
    ///
    /// The returned token may be referred to equivalently as an ‘activation token’
    /// (using Wayland terminology) or a ‘startup sequence ID’ (using X11 terminology).
    /// The two [are interoperable](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).
    ///
    /// Activation tokens are defined in the [XDG Activation Protocol](https://wayland.app/protocols/xdg-activation-v1),
    /// and startup notification IDs are defined in the
    /// [freedesktop.org Startup Notification Protocol](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
    ///
    /// Support for the XDG Activation Protocol was added in GLib 2.76.
    /// Since GLib 2.82 `info` and `files` can be `NULL`. If that’s not supported by the backend,
    /// the returned token will be `NULL`.
    extern fn g_app_launch_context_get_startup_notify_id(p_context: *AppLaunchContext, p_info: ?*gio.AppInfo, p_files: ?*glib.List) ?[*:0]u8;
    pub const getStartupNotifyId = g_app_launch_context_get_startup_notify_id;

    /// Called when an application has failed to launch, so that it can cancel
    /// the application startup notification started in
    /// `gio.AppLaunchContext.getStartupNotifyId`.
    extern fn g_app_launch_context_launch_failed(p_context: *AppLaunchContext, p_startup_notify_id: [*:0]const u8) void;
    pub const launchFailed = g_app_launch_context_launch_failed;

    /// Arranges for `variable` to be set to `value` in the child’s environment when
    /// `context` is used to launch an application.
    extern fn g_app_launch_context_setenv(p_context: *AppLaunchContext, p_variable: [*:0]const u8, p_value: [*:0]const u8) void;
    pub const setenv = g_app_launch_context_setenv;

    /// Arranges for `variable` to be unset in the child’s environment when `context`
    /// is used to launch an application.
    extern fn g_app_launch_context_unsetenv(p_context: *AppLaunchContext, p_variable: [*:0]const u8) void;
    pub const unsetenv = g_app_launch_context_unsetenv;

    extern fn g_app_launch_context_get_type() usize;
    pub const getGObjectType = g_app_launch_context_get_type;

    extern fn g_object_ref(p_self: *gio.AppLaunchContext) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.AppLaunchContext) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *AppLaunchContext, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GApplication` is the core class for application support.
///
/// A `GApplication` is the foundation of an application. It wraps some
/// low-level platform-specific services and is intended to act as the
/// foundation for higher-level application classes such as
/// `GtkApplication` or `MxApplication`. In general, you should not use
/// this class outside of a higher level framework.
///
/// `GApplication` provides convenient life-cycle management by maintaining
/// a "use count" for the primary application instance. The use count can
/// be changed using `gio.Application.hold` and
/// `gio.Application.release`. If it drops to zero, the application
/// exits. Higher-level classes such as `GtkApplication` employ the use count
/// to ensure that the application stays alive as long as it has any opened
/// windows.
///
/// Another feature that `GApplication` (optionally) provides is process
/// uniqueness. Applications can make use of this functionality by
/// providing a unique application ID. If given, only one application
/// with this ID can be running at a time per session. The session
/// concept is platform-dependent, but corresponds roughly to a graphical
/// desktop login. When your application is launched again, its
/// arguments are passed through platform communication to the already
/// running program. The already running instance of the program is
/// called the "primary instance"; for non-unique applications this is
/// always the current instance. On Linux, the D-Bus session bus
/// is used for communication.
///
/// The use of `GApplication` differs from some other commonly-used
/// uniqueness libraries (such as libunique) in important ways. The
/// application is not expected to manually register itself and check
/// if it is the primary instance. Instead, the `main` function of a
/// `GApplication` should do very little more than instantiating the
/// application instance, possibly connecting signal handlers, then
/// calling `gio.Application.run`. All checks for uniqueness are done
/// internally. If the application is the primary instance then the
/// startup signal is emitted and the mainloop runs. If the application
/// is not the primary instance then a signal is sent to the primary
/// instance and `gio.Application.run` promptly returns. See the code
/// examples below.
///
/// If used, the expected form of an application identifier is the
/// same as that of a
/// [D-Bus well-known bus name](https://dbus.freedesktop.org/doc/dbus-specification.html`message`-protocol-names-bus).
/// Examples include: `com.example.MyApp`, `org.example.internal_apps.Calculator`,
/// `org._7_zip.Archiver`.
/// For details on valid application identifiers, see `gio.Application.idIsValid`.
///
/// On Linux, the application identifier is claimed as a well-known bus name
/// on the user's session bus. This means that the uniqueness of your
/// application is scoped to the current session. It also means that your
/// application may provide additional services (through registration of other
/// object paths) at that bus name. The registration of these object paths
/// should be done with the shared GDBus session bus. Note that due to the
/// internal architecture of GDBus, method calls can be dispatched at any time
/// (even if a main loop is not running). For this reason, you must ensure that
/// any object paths that you wish to register are registered before `gio.Application`
/// attempts to acquire the bus name of your application (which happens in
/// `gio.Application.register`). Unfortunately, this means that you cannot
/// use `gio.Application.properties.is_remote` to decide if you want to register
/// object paths.
///
/// `GApplication` also implements the `gio.ActionGroup` and `gio.ActionMap`
/// interfaces and lets you easily export actions by adding them with
/// `gio.ActionMap.addAction`. When invoking an action by calling
/// `gio.ActionGroup.activateAction` on the application, it is always
/// invoked in the primary instance. The actions are also exported on
/// the session bus, and GIO provides the `gio.DBusActionGroup` wrapper to
/// conveniently access them remotely. GIO provides a `gio.DBusMenuModel` wrapper
/// for remote access to exported `gio.MenuModel`s.
///
/// Note: Due to the fact that actions are exported on the session bus,
/// using `maybe` parameters is not supported, since D-Bus does not support
/// `maybe` types.
///
/// There is a number of different entry points into a `GApplication`:
///
/// - via 'Activate' (i.e. just starting the application)
///
/// - via 'Open' (i.e. opening some files)
///
/// - by handling a command-line
///
/// - via activating an action
///
/// The `gio.Application.signals.startup` signal lets you handle the application
/// initialization for all of these in a single place.
///
/// Regardless of which of these entry points is used to start the
/// application, `GApplication` passes some ‘platform data’ from the
/// launching instance to the primary instance, in the form of a
/// `glib.Variant` dictionary mapping strings to variants. To use platform
/// data, override the `gio.Application.virtual_methods.before_emit` or
/// `gio.Application.virtual_methods.after_emit` virtual functions
/// in your `GApplication` subclass. When dealing with
/// `gio.ApplicationCommandLine` objects, the platform data is
/// directly available via `gio.ApplicationCommandLine.getCwd`,
/// `gio.ApplicationCommandLine.getEnviron` and
/// `gio.ApplicationCommandLine.getPlatformData`.
///
/// As the name indicates, the platform data may vary depending on the
/// operating system, but it always includes the current directory (key
/// `cwd`), and optionally the environment (ie the set of environment
/// variables and their values) of the calling process (key `environ`).
/// The environment is only added to the platform data if the
/// `G_APPLICATION_SEND_ENVIRONMENT` flag is set. `GApplication` subclasses
/// can add their own platform data by overriding the
/// `gio.Application.virtual_methods.add_platform_data` virtual function. For instance,
/// `GtkApplication` adds startup notification data in this way.
///
/// To parse commandline arguments you may handle the
/// `gio.Application.signals.command_line` signal or override the
/// `gio.Application.virtual_methods.local_command_line` virtual function, to parse them in
/// either the primary instance or the local instance, respectively.
///
/// For an example of opening files with a `GApplication`, see
/// [gapplication-example-open.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-open.c).
///
/// For an example of using actions with `GApplication`, see
/// [gapplication-example-actions.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-actions.c).
///
/// For an example of using extra D-Bus hooks with `GApplication`, see
/// [gapplication-example-dbushooks.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-dbushooks.c).
pub const Application = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gio.ActionGroup, gio.ActionMap };
    pub const Class = gio.ApplicationClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.ApplicationPrivate,

    pub const virtual_methods = struct {
        /// Activates the application.
        ///
        /// In essence, this results in the `gio.Application.signals.activate` signal being
        /// emitted in the primary instance.
        ///
        /// The application must be registered before calling this function.
        pub const activate = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Application.Class, p_class).f_activate.?(gobject.ext.as(Application, p_application));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Application.Class, p_class).f_activate = @ptrCast(p_implementation);
            }
        };

        /// invoked (locally) to add 'platform data' to be sent to
        ///     the primary instance when activating, opening or invoking actions
        pub const add_platform_data = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *glib.VariantBuilder) void {
                return gobject.ext.as(Application.Class, p_class).f_add_platform_data.?(gobject.ext.as(Application, p_application), p_builder);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_builder: *glib.VariantBuilder) callconv(.c) void) void {
                gobject.ext.as(Application.Class, p_class).f_add_platform_data = @ptrCast(p_implementation);
            }
        };

        /// invoked on the primary instance after 'activate', 'open',
        ///     'command-line' or any action invocation, gets the 'platform data' from
        ///     the calling instance
        pub const after_emit = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_platform_data: *glib.Variant) void {
                return gobject.ext.as(Application.Class, p_class).f_after_emit.?(gobject.ext.as(Application, p_application), p_platform_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_platform_data: *glib.Variant) callconv(.c) void) void {
                gobject.ext.as(Application.Class, p_class).f_after_emit = @ptrCast(p_implementation);
            }
        };

        /// invoked on the primary instance before 'activate', 'open',
        ///     'command-line' or any action invocation, gets the 'platform data' from
        ///     the calling instance
        pub const before_emit = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_platform_data: *glib.Variant) void {
                return gobject.ext.as(Application.Class, p_class).f_before_emit.?(gobject.ext.as(Application, p_application), p_platform_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_platform_data: *glib.Variant) callconv(.c) void) void {
                gobject.ext.as(Application.Class, p_class).f_before_emit = @ptrCast(p_implementation);
            }
        };

        /// invoked on the primary instance when a command-line is
        ///   not handled locally
        pub const command_line = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_command_line: *gio.ApplicationCommandLine) c_int {
                return gobject.ext.as(Application.Class, p_class).f_command_line.?(gobject.ext.as(Application, p_application), p_command_line);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_command_line: *gio.ApplicationCommandLine) callconv(.c) c_int) void {
                gobject.ext.as(Application.Class, p_class).f_command_line = @ptrCast(p_implementation);
            }
        };

        /// invoked locally during registration, if the application is
        ///     using its D-Bus backend. You can use this to export extra objects on the
        ///     bus, that need to exist before the application tries to own the bus name.
        ///     The function is passed the `gio.DBusConnection` to to session bus, and the
        ///     object path that `gio.Application` will use to export its D-Bus API.
        ///     If this function returns `TRUE`, registration will proceed; otherwise
        ///     registration will abort. Since: 2.34
        pub const dbus_register = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.DBusConnection, p_object_path: [*:0]const u8, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Application.Class, p_class).f_dbus_register.?(gobject.ext.as(Application, p_application), p_connection, p_object_path, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.DBusConnection, p_object_path: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Application.Class, p_class).f_dbus_register = @ptrCast(p_implementation);
            }
        };

        /// invoked locally during unregistration, if the application
        ///     is using its D-Bus backend. Use this to undo anything done by
        ///     the `dbus_register` vfunc. Since: 2.34
        pub const dbus_unregister = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.DBusConnection, p_object_path: [*:0]const u8) void {
                return gobject.ext.as(Application.Class, p_class).f_dbus_unregister.?(gobject.ext.as(Application, p_application), p_connection, p_object_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.DBusConnection, p_object_path: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(Application.Class, p_class).f_dbus_unregister = @ptrCast(p_implementation);
            }
        };

        /// invoked locally after the parsing of the commandline
        ///  options has occurred. Since: 2.40
        pub const handle_local_options = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_options: *glib.VariantDict) c_int {
                return gobject.ext.as(Application.Class, p_class).f_handle_local_options.?(gobject.ext.as(Application, p_application), p_options);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_options: *glib.VariantDict) callconv(.c) c_int) void {
                gobject.ext.as(Application.Class, p_class).f_handle_local_options = @ptrCast(p_implementation);
            }
        };

        /// This virtual function is always invoked in the local instance. It
        /// gets passed a pointer to a `NULL`-terminated copy of `argv` and is
        /// expected to remove arguments that it handled (shifting up remaining
        /// arguments).
        ///
        /// The last argument to `local_command_line` is a pointer to the `status`
        /// variable which can used to set the exit status that is returned from
        /// `gio.Application.run`.
        ///
        /// See `gio.Application.run` for more details on `gio.Application` startup.
        pub const local_command_line = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_arguments: *[*][*:0]u8, p_exit_status: *c_int) c_int {
                return gobject.ext.as(Application.Class, p_class).f_local_command_line.?(gobject.ext.as(Application, p_application), p_arguments, p_exit_status);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_arguments: *[*][*:0]u8, p_exit_status: *c_int) callconv(.c) c_int) void {
                gobject.ext.as(Application.Class, p_class).f_local_command_line = @ptrCast(p_implementation);
            }
        };

        /// invoked when another instance is taking over the name. Since: 2.60
        pub const name_lost = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Application.Class, p_class).f_name_lost.?(gobject.ext.as(Application, p_application));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Application.Class, p_class).f_name_lost = @ptrCast(p_implementation);
            }
        };

        /// Opens the given files.
        ///
        /// In essence, this results in the `gio.Application.signals.open` signal being emitted
        /// in the primary instance.
        ///
        /// `n_files` must be greater than zero.
        ///
        /// `hint` is simply passed through to the ::open signal.  It is
        /// intended to be used by applications that have multiple modes for
        /// opening files (eg: "view" vs "edit", etc).  Unless you have a need
        /// for this functionality, you should use "".
        ///
        /// The application must be registered before calling this function
        /// and it must have the `G_APPLICATION_HANDLES_OPEN` flag set.
        pub const open = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_files: [*]*gio.File, p_n_files: c_int, p_hint: [*:0]const u8) void {
                return gobject.ext.as(Application.Class, p_class).f_open.?(gobject.ext.as(Application, p_application), p_files, p_n_files, p_hint);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_files: [*]*gio.File, p_n_files: c_int, p_hint: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(Application.Class, p_class).f_open = @ptrCast(p_implementation);
            }
        };

        /// Used to be invoked on the primary instance when the use
        ///     count of the application drops to zero (and after any inactivity
        ///     timeout, if requested). Not used anymore since 2.32
        pub const quit_mainloop = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Application.Class, p_class).f_quit_mainloop.?(gobject.ext.as(Application, p_application));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Application.Class, p_class).f_quit_mainloop = @ptrCast(p_implementation);
            }
        };

        /// Used to be invoked on the primary instance from
        ///     `gio.Application.run` if the use-count is non-zero. Since 2.32,
        ///     GApplication is iterating the main context directly and is not
        ///     using `run_mainloop` anymore
        pub const run_mainloop = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Application.Class, p_class).f_run_mainloop.?(gobject.ext.as(Application, p_application));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Application.Class, p_class).f_run_mainloop = @ptrCast(p_implementation);
            }
        };

        /// invoked only on the registered primary instance immediately
        ///      after the main loop terminates
        pub const shutdown = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Application.Class, p_class).f_shutdown.?(gobject.ext.as(Application, p_application));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Application.Class, p_class).f_shutdown = @ptrCast(p_implementation);
            }
        };

        /// invoked on the primary instance immediately after registration
        pub const startup = struct {
            pub fn call(p_class: anytype, p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Application.Class, p_class).f_startup.?(gobject.ext.as(Application, p_application));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_application: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Application.Class, p_class).f_startup = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The group of actions that the application exports.
        pub const action_group = struct {
            pub const name = "action-group";

            pub const Type = ?*gio.ActionGroup;
        };

        /// The unique identifier for the application.
        pub const application_id = struct {
            pub const name = "application-id";

            pub const Type = ?[*:0]u8;
        };

        /// Flags specifying the behaviour of the application.
        pub const flags = struct {
            pub const name = "flags";

            pub const Type = gio.ApplicationFlags;
        };

        /// Time (in milliseconds) to stay alive after becoming idle.
        pub const inactivity_timeout = struct {
            pub const name = "inactivity-timeout";

            pub const Type = c_uint;
        };

        /// Whether the application is currently marked as busy through
        /// `gio.Application.markBusy` or `gio.Application.bindBusyProperty`.
        pub const is_busy = struct {
            pub const name = "is-busy";

            pub const Type = c_int;
        };

        /// Whether `gio.Application.register` has been called.
        pub const is_registered = struct {
            pub const name = "is-registered";

            pub const Type = c_int;
        };

        /// Whether this application instance is remote.
        pub const is_remote = struct {
            pub const name = "is-remote";

            pub const Type = c_int;
        };

        /// The base resource path for the application.
        pub const resource_base_path = struct {
            pub const name = "resource-base-path";

            pub const Type = ?[*:0]u8;
        };

        /// The human-readable version number of the application.
        pub const version = struct {
            pub const name = "version";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {
        /// The ::activate signal is emitted on the primary instance when an
        /// activation occurs. See `gio.Application.activate`.
        pub const activate = struct {
            pub const name = "activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Application, p_instance))),
                    gobject.signalLookup("activate", Application.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::command-line signal is emitted on the primary instance when
        /// a commandline is not handled locally. See `gio.Application.run` and
        /// the `gio.ApplicationCommandLine` documentation for more information.
        pub const command_line = struct {
            pub const name = "command-line";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_command_line: *gio.ApplicationCommandLine, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Application, p_instance))),
                    gobject.signalLookup("command-line", Application.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::handle-local-options signal is emitted on the local instance
        /// after the parsing of the commandline options has occurred.
        ///
        /// You can add options to be recognised during commandline option
        /// parsing using `gio.Application.addMainOptionEntries` and
        /// `gio.Application.addOptionGroup`.
        ///
        /// Signal handlers can inspect `options` (along with values pointed to
        /// from the `arg_data` of an installed `GOptionEntrys`) in order to
        /// decide to perform certain actions, including direct local handling
        /// (which may be useful for options like --version).
        ///
        /// In the event that the application is marked
        /// `G_APPLICATION_HANDLES_COMMAND_LINE` the "normal processing" will
        /// send the `options` dictionary to the primary instance where it can be
        /// read with `gio.ApplicationCommandLine.getOptionsDict`.  The signal
        /// handler can modify the dictionary before returning, and the
        /// modified dictionary will be sent.
        ///
        /// In the event that `G_APPLICATION_HANDLES_COMMAND_LINE` is not set,
        /// "normal processing" will treat the remaining uncollected command
        /// line arguments as filenames or URIs.  If there are no arguments,
        /// the application is activated by `gio.Application.activate`.  One or
        /// more arguments results in a call to `gio.Application.open`.
        ///
        /// If you want to handle the local commandline arguments for yourself
        /// by converting them to calls to `gio.Application.open` or
        /// `gio.ActionGroup.activateAction` then you must be sure to register
        /// the application first.  You should probably not call
        /// `gio.Application.activate` for yourself, however: just return -1 and
        /// allow the default handler to do it for you.  This will ensure that
        /// the `--gapplication-service` switch works properly (i.e. no activation
        /// in that case).
        ///
        /// Note that this signal is emitted from the default implementation of
        /// `local_command_line`.  If you override that function and don't
        /// chain up then this signal will never be emitted.
        ///
        /// You can override `local_command_line` if you need more powerful
        /// capabilities than what is provided here, but this should not
        /// normally be required.
        pub const handle_local_options = struct {
            pub const name = "handle-local-options";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_options: *glib.VariantDict, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Application, p_instance))),
                    gobject.signalLookup("handle-local-options", Application.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::name-lost signal is emitted only on the registered primary instance
        /// when a new instance has taken over. This can only happen if the application
        /// is using the `G_APPLICATION_ALLOW_REPLACEMENT` flag.
        ///
        /// The default handler for this signal calls `gio.Application.quit`.
        pub const name_lost = struct {
            pub const name = "name-lost";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Application, p_instance))),
                    gobject.signalLookup("name-lost", Application.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::open signal is emitted on the primary instance when there are
        /// files to open. See `gio.Application.open` for more information.
        pub const open = struct {
            pub const name = "open";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_files: [*]*gio.File, p_n_files: c_int, p_hint: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Application, p_instance))),
                    gobject.signalLookup("open", Application.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::shutdown signal is emitted only on the registered primary instance
        /// immediately after the main loop terminates.
        pub const shutdown = struct {
            pub const name = "shutdown";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Application, p_instance))),
                    gobject.signalLookup("shutdown", Application.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The ::startup signal is emitted on the primary instance immediately
        /// after registration. See `gio.Application.register`.
        pub const startup = struct {
            pub const name = "startup";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Application, p_instance))),
                    gobject.signalLookup("startup", Application.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Returns the default `gio.Application` instance for this process.
    ///
    /// Normally there is only one `gio.Application` per process and it becomes
    /// the default when it is created.  You can exercise more control over
    /// this by using `gio.Application.setDefault`.
    ///
    /// If there is no default application then `NULL` is returned.
    extern fn g_application_get_default() ?*gio.Application;
    pub const getDefault = g_application_get_default;

    /// Checks if `application_id` is a valid application identifier.
    ///
    /// A valid ID is required for calls to `gio.Application.new` and
    /// `gio.Application.setApplicationId`.
    ///
    /// Application identifiers follow the same format as
    /// [D-Bus well-known bus names](https://dbus.freedesktop.org/doc/dbus-specification.html`message`-protocol-names-bus).
    /// For convenience, the restrictions on application identifiers are
    /// reproduced here:
    ///
    /// - Application identifiers are composed of 1 or more elements separated by a
    ///   period (`.`) character. All elements must contain at least one character.
    ///
    /// - Each element must only contain the ASCII characters `[A-Z][a-z][0-9]_-`,
    ///   with `-` discouraged in new application identifiers. Each element must not
    ///   begin with a digit.
    ///
    /// - Application identifiers must contain at least one `.` (period) character
    ///   (and thus at least two elements).
    ///
    /// - Application identifiers must not begin with a `.` (period) character.
    ///
    /// - Application identifiers must not exceed 255 characters.
    ///
    /// Note that the hyphen (`-`) character is allowed in application identifiers,
    /// but is problematic or not allowed in various specifications and APIs that
    /// refer to D-Bus, such as
    /// [Flatpak application IDs](http://docs.flatpak.org/en/latest/introduction.html`identifiers`),
    /// the
    /// [`DBusActivatable` interface in the Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html`dbus`),
    /// and the convention that an application's "main" interface and object path
    /// resemble its application identifier and bus name. To avoid situations that
    /// require special-case handling, it is recommended that new application
    /// identifiers consistently replace hyphens with underscores.
    ///
    /// Like D-Bus interface names, application identifiers should start with the
    /// reversed DNS domain name of the author of the interface (in lower-case), and
    /// it is conventional for the rest of the application identifier to consist of
    /// words run together, with initial capital letters.
    ///
    /// As with D-Bus interface names, if the author's DNS domain name contains
    /// hyphen/minus characters they should be replaced by underscores, and if it
    /// contains leading digits they should be escaped by prepending an underscore.
    /// For example, if the owner of 7-zip.org used an application identifier for an
    /// archiving application, it might be named `org._7_zip.Archiver`.
    extern fn g_application_id_is_valid(p_application_id: [*:0]const u8) c_int;
    pub const idIsValid = g_application_id_is_valid;

    /// Creates a new `gio.Application` instance.
    ///
    /// If non-`NULL`, the application id must be valid.  See
    /// `gio.Application.idIsValid`.
    ///
    /// If no application ID is given then some features of `gio.Application`
    /// (most notably application uniqueness) will be disabled.
    extern fn g_application_new(p_application_id: ?[*:0]const u8, p_flags: gio.ApplicationFlags) *gio.Application;
    pub const new = g_application_new;

    /// Activates the application.
    ///
    /// In essence, this results in the `gio.Application.signals.activate` signal being
    /// emitted in the primary instance.
    ///
    /// The application must be registered before calling this function.
    extern fn g_application_activate(p_application: *Application) void;
    pub const activate = g_application_activate;

    /// Add an option to be handled by `application`.
    ///
    /// Calling this function is the equivalent of calling
    /// `gio.Application.addMainOptionEntries` with a single `glib.OptionEntry`
    /// that has its arg_data member set to `NULL`.
    ///
    /// The parsed arguments will be packed into a `glib.VariantDict` which
    /// is passed to `gio.Application.signals.handle`-local-options. If
    /// `G_APPLICATION_HANDLES_COMMAND_LINE` is set, then it will also
    /// be sent to the primary instance. See
    /// `gio.Application.addMainOptionEntries` for more details.
    ///
    /// See `glib.OptionEntry` for more documentation of the arguments.
    extern fn g_application_add_main_option(p_application: *Application, p_long_name: [*:0]const u8, p_short_name: u8, p_flags: glib.OptionFlags, p_arg: glib.OptionArg, p_description: [*:0]const u8, p_arg_description: ?[*:0]const u8) void;
    pub const addMainOption = g_application_add_main_option;

    /// Adds main option entries to be handled by `application`.
    ///
    /// This function is comparable to `glib.OptionContext.addMainEntries`.
    ///
    /// After the commandline arguments are parsed, the
    /// `gio.Application.signals.handle`-local-options signal will be emitted.  At this
    /// point, the application can inspect the values pointed to by `arg_data`
    /// in the given `GOptionEntrys`.
    ///
    /// Unlike `glib.OptionContext`, `gio.Application` supports giving a `NULL`
    /// `arg_data` for a non-callback `glib.OptionEntry`.  This results in the
    /// argument in question being packed into a `glib.VariantDict` which is also
    /// passed to `gio.Application.signals.handle`-local-options, where it can be
    /// inspected and modified.  If `G_APPLICATION_HANDLES_COMMAND_LINE` is
    /// set, then the resulting dictionary is sent to the primary instance,
    /// where `gio.ApplicationCommandLine.getOptionsDict` will return it.
    /// As it has been passed outside the process at this point, the types of all
    /// values in the options dict must be checked before being used.
    /// This "packing" is done according to the type of the argument --
    /// booleans for normal flags, strings for strings, bytestrings for
    /// filenames, etc.  The packing only occurs if the flag is given (ie: we
    /// do not pack a "false" `glib.Variant` in the case that a flag is missing).
    ///
    /// In general, it is recommended that all commandline arguments are
    /// parsed locally.  The options dictionary should then be used to
    /// transmit the result of the parsing to the primary instance, where
    /// `glib.VariantDict.lookup` can be used.  For local options, it is
    /// possible to either use `arg_data` in the usual way, or to consult (and
    /// potentially remove) the option from the options dictionary.
    ///
    /// This function is new in GLib 2.40.  Before then, the only real choice
    /// was to send all of the commandline arguments (options and all) to the
    /// primary instance for handling.  `gio.Application` ignored them completely
    /// on the local side.  Calling this function "opts in" to the new
    /// behaviour, and in particular, means that unrecognized options will be
    /// treated as errors.  Unrecognized options have never been ignored when
    /// `G_APPLICATION_HANDLES_COMMAND_LINE` is unset.
    ///
    /// If `gio.Application.signals.handle`-local-options needs to see the list of
    /// filenames, then the use of `G_OPTION_REMAINING` is recommended.  If
    /// `arg_data` is `NULL` then `G_OPTION_REMAINING` can be used as a key into
    /// the options dictionary.  If you do use `G_OPTION_REMAINING` then you
    /// need to handle these arguments for yourself because once they are
    /// consumed, they will no longer be visible to the default handling
    /// (which treats them as filenames to be opened).
    ///
    /// It is important to use the proper GVariant format when retrieving
    /// the options with `glib.VariantDict.lookup`:
    /// - for `G_OPTION_ARG_NONE`, use `b`
    /// - for `G_OPTION_ARG_STRING`, use `&s`
    /// - for `G_OPTION_ARG_INT`, use `i`
    /// - for `G_OPTION_ARG_INT64`, use `x`
    /// - for `G_OPTION_ARG_DOUBLE`, use `d`
    /// - for `G_OPTION_ARG_FILENAME`, use `^&ay`
    /// - for `G_OPTION_ARG_STRING_ARRAY`, use `^a&s`
    /// - for `G_OPTION_ARG_FILENAME_ARRAY`, use `^a&ay`
    extern fn g_application_add_main_option_entries(p_application: *Application, p_entries: [*]const glib.OptionEntry) void;
    pub const addMainOptionEntries = g_application_add_main_option_entries;

    /// Adds a `glib.OptionGroup` to the commandline handling of `application`.
    ///
    /// This function is comparable to `glib.OptionContext.addGroup`.
    ///
    /// Unlike `gio.Application.addMainOptionEntries`, this function does
    /// not deal with `NULL` `arg_data` and never transmits options to the
    /// primary instance.
    ///
    /// The reason for that is because, by the time the options arrive at the
    /// primary instance, it is typically too late to do anything with them.
    /// Taking the GTK option group as an example: GTK will already have been
    /// initialised by the time the `gio.Application.signals.command`-line handler runs.
    /// In the case that this is not the first-running instance of the
    /// application, the existing instance may already have been running for
    /// a very long time.
    ///
    /// This means that the options from `glib.OptionGroup` are only really usable
    /// in the case that the instance of the application being run is the
    /// first instance.  Passing options like `--display=` or `--gdk-debug=`
    /// on future runs will have no effect on the existing primary instance.
    ///
    /// Calling this function will cause the options in the supplied option
    /// group to be parsed, but it does not cause you to be "opted in" to the
    /// new functionality whereby unrecognized options are rejected even if
    /// `G_APPLICATION_HANDLES_COMMAND_LINE` was given.
    extern fn g_application_add_option_group(p_application: *Application, p_group: *glib.OptionGroup) void;
    pub const addOptionGroup = g_application_add_option_group;

    /// Marks `application` as busy (see `gio.Application.markBusy`) while
    /// `property` on `object` is `TRUE`.
    ///
    /// The binding holds a reference to `application` while it is active, but
    /// not to `object`. Instead, the binding is destroyed when `object` is
    /// finalized.
    extern fn g_application_bind_busy_property(p_application: *Application, p_object: *gobject.Object, p_property: [*:0]const u8) void;
    pub const bindBusyProperty = g_application_bind_busy_property;

    /// Gets the unique identifier for `application`.
    extern fn g_application_get_application_id(p_application: *Application) ?[*:0]const u8;
    pub const getApplicationId = g_application_get_application_id;

    /// Gets the `gio.DBusConnection` being used by the application, or `NULL`.
    ///
    /// If `gio.Application` is using its D-Bus backend then this function will
    /// return the `gio.DBusConnection` being used for uniqueness and
    /// communication with the desktop environment and other instances of the
    /// application.
    ///
    /// If `gio.Application` is not using D-Bus then this function will return
    /// `NULL`.  This includes the situation where the D-Bus backend would
    /// normally be in use but we were unable to connect to the bus.
    ///
    /// This function must not be called before the application has been
    /// registered.  See `gio.Application.getIsRegistered`.
    extern fn g_application_get_dbus_connection(p_application: *Application) ?*gio.DBusConnection;
    pub const getDbusConnection = g_application_get_dbus_connection;

    /// Gets the D-Bus object path being used by the application, or `NULL`.
    ///
    /// If `gio.Application` is using its D-Bus backend then this function will
    /// return the D-Bus object path that `gio.Application` is using.  If the
    /// application is the primary instance then there is an object published
    /// at this path.  If the application is not the primary instance then
    /// the result of this function is undefined.
    ///
    /// If `gio.Application` is not using D-Bus then this function will return
    /// `NULL`.  This includes the situation where the D-Bus backend would
    /// normally be in use but we were unable to connect to the bus.
    ///
    /// This function must not be called before the application has been
    /// registered.  See `gio.Application.getIsRegistered`.
    extern fn g_application_get_dbus_object_path(p_application: *Application) ?[*:0]const u8;
    pub const getDbusObjectPath = g_application_get_dbus_object_path;

    /// Gets the flags for `application`.
    ///
    /// See `gio.ApplicationFlags`.
    extern fn g_application_get_flags(p_application: *Application) gio.ApplicationFlags;
    pub const getFlags = g_application_get_flags;

    /// Gets the current inactivity timeout for the application.
    ///
    /// This is the amount of time (in milliseconds) after the last call to
    /// `gio.Application.release` before the application stops running.
    extern fn g_application_get_inactivity_timeout(p_application: *Application) c_uint;
    pub const getInactivityTimeout = g_application_get_inactivity_timeout;

    /// Gets the application's current busy state, as set through
    /// `gio.Application.markBusy` or `gio.Application.bindBusyProperty`.
    extern fn g_application_get_is_busy(p_application: *Application) c_int;
    pub const getIsBusy = g_application_get_is_busy;

    /// Checks if `application` is registered.
    ///
    /// An application is registered if `gio.Application.register` has been
    /// successfully called.
    extern fn g_application_get_is_registered(p_application: *Application) c_int;
    pub const getIsRegistered = g_application_get_is_registered;

    /// Checks if `application` is remote.
    ///
    /// If `application` is remote then it means that another instance of
    /// application already exists (the 'primary' instance).  Calls to
    /// perform actions on `application` will result in the actions being
    /// performed by the primary instance.
    ///
    /// The value of this property cannot be accessed before
    /// `gio.Application.register` has been called.  See
    /// `gio.Application.getIsRegistered`.
    extern fn g_application_get_is_remote(p_application: *Application) c_int;
    pub const getIsRemote = g_application_get_is_remote;

    /// Gets the resource base path of `application`.
    ///
    /// See `gio.Application.setResourceBasePath` for more information.
    extern fn g_application_get_resource_base_path(p_application: *Application) ?[*:0]const u8;
    pub const getResourceBasePath = g_application_get_resource_base_path;

    /// Gets the version of `application`.
    extern fn g_application_get_version(p_application: *Application) ?[*:0]const u8;
    pub const getVersion = g_application_get_version;

    /// Increases the use count of `application`.
    ///
    /// Use this function to indicate that the application has a reason to
    /// continue to run.  For example, `gio.Application.hold` is called by GTK
    /// when a toplevel window is on the screen.
    ///
    /// To cancel the hold, call `gio.Application.release`.
    extern fn g_application_hold(p_application: *Application) void;
    pub const hold = g_application_hold;

    /// Increases the busy count of `application`.
    ///
    /// Use this function to indicate that the application is busy, for instance
    /// while a long running operation is pending.
    ///
    /// The busy state will be exposed to other processes, so a session shell will
    /// use that information to indicate the state to the user (e.g. with a
    /// spinner).
    ///
    /// To cancel the busy indication, use `gio.Application.unmarkBusy`.
    ///
    /// The application must be registered before calling this function.
    extern fn g_application_mark_busy(p_application: *Application) void;
    pub const markBusy = g_application_mark_busy;

    /// Opens the given files.
    ///
    /// In essence, this results in the `gio.Application.signals.open` signal being emitted
    /// in the primary instance.
    ///
    /// `n_files` must be greater than zero.
    ///
    /// `hint` is simply passed through to the ::open signal.  It is
    /// intended to be used by applications that have multiple modes for
    /// opening files (eg: "view" vs "edit", etc).  Unless you have a need
    /// for this functionality, you should use "".
    ///
    /// The application must be registered before calling this function
    /// and it must have the `G_APPLICATION_HANDLES_OPEN` flag set.
    extern fn g_application_open(p_application: *Application, p_files: [*]*gio.File, p_n_files: c_int, p_hint: [*:0]const u8) void;
    pub const open = g_application_open;

    /// Immediately quits the application.
    ///
    /// Upon return to the mainloop, `gio.Application.run` will return,
    /// calling only the 'shutdown' function before doing so.
    ///
    /// The hold count is ignored.
    /// Take care if your code has called `gio.Application.hold` on the application and
    /// is therefore still expecting it to exist.
    /// (Note that you may have called `gio.Application.hold` indirectly, for example
    /// through `gtk_application_add_window`.)
    ///
    /// The result of calling `gio.Application.run` again after it returns is
    /// unspecified.
    extern fn g_application_quit(p_application: *Application) void;
    pub const quit = g_application_quit;

    /// Attempts registration of the application.
    ///
    /// This is the point at which the application discovers if it is the
    /// primary instance or merely acting as a remote for an already-existing
    /// primary instance.  This is implemented by attempting to acquire the
    /// application identifier as a unique bus name on the session bus using
    /// GDBus.
    ///
    /// If there is no application ID or if `G_APPLICATION_NON_UNIQUE` was
    /// given, then this process will always become the primary instance.
    ///
    /// Due to the internal architecture of GDBus, method calls can be
    /// dispatched at any time (even if a main loop is not running).  For
    /// this reason, you must ensure that any object paths that you wish to
    /// register are registered before calling this function.
    ///
    /// If the application has already been registered then `TRUE` is
    /// returned with no work performed.
    ///
    /// The `gio.Application.signals.startup` signal is emitted if registration succeeds
    /// and `application` is the primary instance (including the non-unique
    /// case).
    ///
    /// In the event of an error (such as `cancellable` being cancelled, or a
    /// failure to connect to the session bus), `FALSE` is returned and `error`
    /// is set appropriately.
    ///
    /// Note: the return value of this function is not an indicator that this
    /// instance is or is not the primary instance of the application.  See
    /// `gio.Application.getIsRemote` for that.
    extern fn g_application_register(p_application: *Application, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const register = g_application_register;

    /// Decrease the use count of `application`.
    ///
    /// When the use count reaches zero, the application will stop running.
    ///
    /// Never call this function except to cancel the effect of a previous
    /// call to `gio.Application.hold`.
    extern fn g_application_release(p_application: *Application) void;
    pub const release = g_application_release;

    /// Runs the application.
    ///
    /// This function is intended to be run from `main` and its return value
    /// is intended to be returned by `main`. Although you are expected to pass
    /// the `argc`, `argv` parameters from `main` to this function, it is possible
    /// to pass `NULL` if `argv` is not available or commandline handling is not
    /// required.  Note that on Windows, `argc` and `argv` are ignored, and
    /// `g_win32_get_command_line` is called internally (for proper support
    /// of Unicode commandline arguments).
    ///
    /// `gio.Application` will attempt to parse the commandline arguments.  You
    /// can add commandline flags to the list of recognised options by way of
    /// `gio.Application.addMainOptionEntries`.  After this, the
    /// `gio.Application.signals.handle`-local-options signal is emitted, from which the
    /// application can inspect the values of its `GOptionEntrys`.
    ///
    /// `gio.Application.signals.handle`-local-options is a good place to handle options
    /// such as `--version`, where an immediate reply from the local process is
    /// desired (instead of communicating with an already-running instance).
    /// A `gio.Application.signals.handle`-local-options handler can stop further processing
    /// by returning a non-negative value, which then becomes the exit status of
    /// the process.
    ///
    /// What happens next depends on the flags: if
    /// `G_APPLICATION_HANDLES_COMMAND_LINE` was specified then the remaining
    /// commandline arguments are sent to the primary instance, where a
    /// `gio.Application.signals.command`-line signal is emitted.  Otherwise, the
    /// remaining commandline arguments are assumed to be a list of files.
    /// If there are no files listed, the application is activated via the
    /// `gio.Application.signals.activate` signal.  If there are one or more files, and
    /// `G_APPLICATION_HANDLES_OPEN` was specified then the files are opened
    /// via the `gio.Application.signals.open` signal.
    ///
    /// If you are interested in doing more complicated local handling of the
    /// commandline then you should implement your own `gio.Application` subclass
    /// and override `local_command_line`. In this case, you most likely want
    /// to return `TRUE` from your `local_command_line` implementation to
    /// suppress the default handling. See
    /// [gapplication-example-cmdline2.c][https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c]
    /// for an example.
    ///
    /// If, after the above is done, the use count of the application is zero
    /// then the exit status is returned immediately.  If the use count is
    /// non-zero then the default main context is iterated until the use count
    /// falls to zero, at which point 0 is returned.
    ///
    /// If the `G_APPLICATION_IS_SERVICE` flag is set, then the service will
    /// run for as much as 10 seconds with a use count of zero while waiting
    /// for the message that caused the activation to arrive.  After that,
    /// if the use count falls to zero the application will exit immediately,
    /// except in the case that `gio.Application.setInactivityTimeout` is in
    /// use.
    ///
    /// This function sets the prgname (`glib.setPrgname`), if not already set,
    /// to the basename of argv[0].
    ///
    /// Much like `glib.MainLoop.run`, this function will acquire the main context
    /// for the duration that the application is running.
    ///
    /// Since 2.40, applications that are not explicitly flagged as services
    /// or launchers (ie: neither `G_APPLICATION_IS_SERVICE` or
    /// `G_APPLICATION_IS_LAUNCHER` are given as flags) will check (from the
    /// default handler for local_command_line) if "--gapplication-service"
    /// was given in the command line.  If this flag is present then normal
    /// commandline processing is interrupted and the
    /// `G_APPLICATION_IS_SERVICE` flag is set.  This provides a "compromise"
    /// solution whereby running an application directly from the commandline
    /// will invoke it in the normal way (which can be useful for debugging)
    /// while still allowing applications to be D-Bus activated in service
    /// mode.  The D-Bus service file should invoke the executable with
    /// "--gapplication-service" as the sole commandline argument.  This
    /// approach is suitable for use by most graphical applications but
    /// should not be used from applications like editors that need precise
    /// control over when processes invoked via the commandline will exit and
    /// what their exit status will be.
    extern fn g_application_run(p_application: *Application, p_argc: c_int, p_argv: ?[*][*:0]u8) c_int;
    pub const run = g_application_run;

    /// Sends a notification on behalf of `application` to the desktop shell.
    /// There is no guarantee that the notification is displayed immediately,
    /// or even at all.
    ///
    /// Notifications may persist after the application exits. It will be
    /// D-Bus-activated when the notification or one of its actions is
    /// activated.
    ///
    /// Modifying `notification` after this call has no effect. However, the
    /// object can be reused for a later call to this function.
    ///
    /// `id` may be any string that uniquely identifies the event for the
    /// application. It does not need to be in any special format. For
    /// example, "new-message" might be appropriate for a notification about
    /// new messages.
    ///
    /// If a previous notification was sent with the same `id`, it will be
    /// replaced with `notification` and shown again as if it was a new
    /// notification. This works even for notifications sent from a previous
    /// execution of the application, as long as `id` is the same string.
    ///
    /// `id` may be `NULL`, but it is impossible to replace or withdraw
    /// notifications without an id.
    ///
    /// If `notification` is no longer relevant, it can be withdrawn with
    /// `gio.Application.withdrawNotification`.
    ///
    /// It is an error to call this function if `application` has no
    /// application ID.
    extern fn g_application_send_notification(p_application: *Application, p_id: ?[*:0]const u8, p_notification: *gio.Notification) void;
    pub const sendNotification = g_application_send_notification;

    /// This used to be how actions were associated with a `gio.Application`.
    /// Now there is `gio.ActionMap` for that.
    extern fn g_application_set_action_group(p_application: *Application, p_action_group: ?*gio.ActionGroup) void;
    pub const setActionGroup = g_application_set_action_group;

    /// Sets the unique identifier for `application`.
    ///
    /// The application id can only be modified if `application` has not yet
    /// been registered.
    ///
    /// If non-`NULL`, the application id must be valid.  See
    /// `gio.Application.idIsValid`.
    extern fn g_application_set_application_id(p_application: *Application, p_application_id: ?[*:0]const u8) void;
    pub const setApplicationId = g_application_set_application_id;

    /// Sets or unsets the default application for the process, as returned
    /// by `gio.Application.getDefault`.
    ///
    /// This function does not take its own reference on `application`.  If
    /// `application` is destroyed then the default application will revert
    /// back to `NULL`.
    extern fn g_application_set_default(p_application: ?*Application) void;
    pub const setDefault = g_application_set_default;

    /// Sets the flags for `application`.
    ///
    /// The flags can only be modified if `application` has not yet been
    /// registered.
    ///
    /// See `gio.ApplicationFlags`.
    extern fn g_application_set_flags(p_application: *Application, p_flags: gio.ApplicationFlags) void;
    pub const setFlags = g_application_set_flags;

    /// Sets the current inactivity timeout for the application.
    ///
    /// This is the amount of time (in milliseconds) after the last call to
    /// `gio.Application.release` before the application stops running.
    ///
    /// This call has no side effects of its own.  The value set here is only
    /// used for next time `gio.Application.release` drops the use count to
    /// zero.  Any timeouts currently in progress are not impacted.
    extern fn g_application_set_inactivity_timeout(p_application: *Application, p_inactivity_timeout: c_uint) void;
    pub const setInactivityTimeout = g_application_set_inactivity_timeout;

    /// Adds a description to the `application` option context.
    ///
    /// See `glib.OptionContext.setDescription` for more information.
    extern fn g_application_set_option_context_description(p_application: *Application, p_description: ?[*:0]const u8) void;
    pub const setOptionContextDescription = g_application_set_option_context_description;

    /// Sets the parameter string to be used by the commandline handling of `application`.
    ///
    /// This function registers the argument to be passed to `glib.OptionContext.new`
    /// when the internal `glib.OptionContext` of `application` is created.
    ///
    /// See `glib.OptionContext.new` for more information about `parameter_string`.
    extern fn g_application_set_option_context_parameter_string(p_application: *Application, p_parameter_string: ?[*:0]const u8) void;
    pub const setOptionContextParameterString = g_application_set_option_context_parameter_string;

    /// Adds a summary to the `application` option context.
    ///
    /// See `glib.OptionContext.setSummary` for more information.
    extern fn g_application_set_option_context_summary(p_application: *Application, p_summary: ?[*:0]const u8) void;
    pub const setOptionContextSummary = g_application_set_option_context_summary;

    /// Sets (or unsets) the base resource path of `application`.
    ///
    /// The path is used to automatically load various
    /// [application resources]`gio.Resource` such as menu layouts and
    /// action descriptions. The various types of resources will be found at
    /// fixed names relative to the given base path.
    ///
    /// By default, the resource base path is determined from the application
    /// ID by prefixing '/' and replacing each '.' with '/'.  This is done at
    /// the time that the `gio.Application` object is constructed.  Changes to
    /// the application ID after that point will not have an impact on the
    /// resource base path.
    ///
    /// As an example, if the application has an ID of "org.example.app" then
    /// the default resource base path will be "/org/example/app".  If this
    /// is a `GtkApplication` (and you have not manually changed the path)
    /// then Gtk will then search for the menus of the application at
    /// "/org/example/app/gtk/menus.ui".
    ///
    /// See `gio.Resource` for more information about adding resources to your
    /// application.
    ///
    /// You can disable automatic resource loading functionality by setting
    /// the path to `NULL`.
    ///
    /// Changing the resource base path once the application is running is
    /// not recommended.  The point at which the resource path is consulted
    /// for forming paths for various purposes is unspecified.  When writing
    /// a sub-class of `gio.Application` you should either set the
    /// `gio.Application.properties.resource`-base-path property at construction time, or call
    /// this function during the instance initialization. Alternatively, you
    /// can call this function in the `gio.ApplicationClass.startup` virtual function,
    /// before chaining up to the parent implementation.
    extern fn g_application_set_resource_base_path(p_application: *Application, p_resource_path: ?[*:0]const u8) void;
    pub const setResourceBasePath = g_application_set_resource_base_path;

    /// Sets the version number of `application`. This will be used to implement
    /// a `--version` command line argument
    ///
    /// The application version can only be modified if `application` has not yet
    /// been registered.
    extern fn g_application_set_version(p_application: *Application, p_version: [*:0]const u8) void;
    pub const setVersion = g_application_set_version;

    /// Destroys a binding between `property` and the busy state of
    /// `application` that was previously created with
    /// `gio.Application.bindBusyProperty`.
    extern fn g_application_unbind_busy_property(p_application: *Application, p_object: *gobject.Object, p_property: [*:0]const u8) void;
    pub const unbindBusyProperty = g_application_unbind_busy_property;

    /// Decreases the busy count of `application`.
    ///
    /// When the busy count reaches zero, the new state will be propagated
    /// to other processes.
    ///
    /// This function must only be called to cancel the effect of a previous
    /// call to `gio.Application.markBusy`.
    extern fn g_application_unmark_busy(p_application: *Application) void;
    pub const unmarkBusy = g_application_unmark_busy;

    /// Withdraws a notification that was sent with
    /// `gio.Application.sendNotification`.
    ///
    /// This call does nothing if a notification with `id` doesn't exist or
    /// the notification was never sent.
    ///
    /// This function works even for notifications sent in previous
    /// executions of this application, as long `id` is the same as it was for
    /// the sent notification.
    ///
    /// Note that notifications are dismissed when the user clicks on one
    /// of the buttons in a notification or triggers its default action, so
    /// there is no need to explicitly withdraw the notification in that case.
    extern fn g_application_withdraw_notification(p_application: *Application, p_id: [*:0]const u8) void;
    pub const withdrawNotification = g_application_withdraw_notification;

    extern fn g_application_get_type() usize;
    pub const getGObjectType = g_application_get_type;

    extern fn g_object_ref(p_self: *gio.Application) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Application) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Application, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GApplicationCommandLine` represents a command-line invocation of
/// an application.
///
/// It is created by `gio.Application` and emitted
/// in the `gio.Application.signals.command_line` signal and virtual function.
///
/// The class contains the list of arguments that the program was invoked
/// with. It is also possible to query if the commandline invocation was
/// local (ie: the current process is running in direct response to the
/// invocation) or remote (ie: some other process forwarded the
/// commandline to this process).
///
/// The `GApplicationCommandLine` object can provide the `argc` and `argv`
/// parameters for use with the `glib.OptionContext` command-line parsing API,
/// with the `gio.ApplicationCommandLine.getArguments` function. See
/// [gapplication-example-cmdline3.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline3.c)
/// for an example.
///
/// The exit status of the originally-invoked process may be set and
/// messages can be printed to stdout or stderr of that process.
///
/// For remote invocation, the originally-invoked process exits when
/// `gio.ApplicationCommandLine.done` method is called. This method is
/// also automatically called when the object is disposed.
///
/// The main use for `GApplicationCommandLine` (and the
/// `gio.Application.signals.command_line` signal) is 'Emacs server' like use cases:
/// You can set the `EDITOR` environment variable to have e.g. git use
/// your favourite editor to edit commit messages, and if you already
/// have an instance of the editor running, the editing will happen
/// in the running instance, instead of opening a new one. An important
/// aspect of this use case is that the process that gets started by git
/// does not return until the editing is done.
///
/// Normally, the commandline is completely handled in the
/// `gio.Application.signals.command_line` handler. The launching instance exits
/// once the signal handler in the primary instance has returned, and
/// the return value of the signal handler becomes the exit status
/// of the launching instance.
///
/// ```c
/// static int
/// command_line (GApplication            *application,
///               GApplicationCommandLine *cmdline)
/// {
///   gchar **argv;
///   gint argc;
///   gint i;
///
///   argv = g_application_command_line_get_arguments (cmdline, &argc);
///
///   g_application_command_line_print (cmdline,
///                                     "This text is written back\n"
///                                     "to stdout of the caller\n");
///
///   for (i = 0; i < argc; i++)
///     g_print ("argument `d`: `s`\n", i, argv[i]);
///
///   g_strfreev (argv);
///
///   return 0;
/// }
/// ```
///
/// The complete example can be found here:
/// [gapplication-example-cmdline.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline.c)
///
/// In more complicated cases, the handling of the commandline can be
/// split between the launcher and the primary instance.
///
/// ```c
/// static gboolean
///  test_local_cmdline (GApplication   *application,
///                      gchar        ***arguments,
///                      gint           *exit_status)
/// {
///   gint i, j;
///   gchar **argv;
///
///   argv = *arguments;
///
///   if (argv[0] == NULL)
///     {
///       *exit_status = 0;
///       return FALSE;
///     }
///
///   i = 1;
///   while (argv[i])
///     {
///       if (g_str_has_prefix (argv[i], "--local-"))
///         {
///           g_print ("handling argument `s` locally\n", argv[i]);
///           g_free (argv[i]);
///           for (j = i; argv[j]; j++)
///             argv[j] = argv[j + 1];
///         }
///       else
///         {
///           g_print ("not handling argument `s` locally\n", argv[i]);
///           i++;
///         }
///     }
///
///   *exit_status = 0;
///
///   return FALSE;
/// }
///
/// static void
/// test_application_class_init (TestApplicationClass *class)
/// {
///   G_APPLICATION_CLASS (class)->local_command_line = test_local_cmdline;
///
///   ...
/// }
/// ```
///
/// In this example of split commandline handling, options that start
/// with `--local-` are handled locally, all other options are passed
/// to the `gio.Application.signals.command_line` handler which runs in the primary
/// instance.
///
/// The complete example can be found here:
/// [gapplication-example-cmdline2.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c)
///
/// If handling the commandline requires a lot of work, it may be better to defer it.
///
/// ```c
/// static gboolean
/// my_cmdline_handler (gpointer data)
/// {
///   GApplicationCommandLine *cmdline = data;
///
///   // do the heavy lifting in an idle
///
///   g_application_command_line_set_exit_status (cmdline, 0);
///   g_object_unref (cmdline); // this releases the application
///
///   return G_SOURCE_REMOVE;
/// }
///
/// static int
/// command_line (GApplication            *application,
///               GApplicationCommandLine *cmdline)
/// {
///   // keep the application running until we are done with this commandline
///   g_application_hold (application);
///
///   g_object_set_data_full (G_OBJECT (cmdline),
///                           "application", application,
///                           (GDestroyNotify)g_application_release);
///
///   g_object_ref (cmdline);
///   g_idle_add (my_cmdline_handler, cmdline);
///
///   return 0;
/// }
/// ```
///
/// In this example the commandline is not completely handled before
/// the `gio.Application.signals.command_line` handler returns. Instead, we keep
/// a reference to the `GApplicationCommandLine` object and handle it
/// later (in this example, in an idle). Note that it is necessary to
/// hold the application until you are done with the commandline.
///
/// The complete example can be found here:
/// [gapplication-example-cmdline3.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline3.c)
pub const ApplicationCommandLine = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.ApplicationCommandLineClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.ApplicationCommandLinePrivate,

    pub const virtual_methods = struct {
        /// Signals that command line processing is completed.
        ///
        /// For remote invocation, it causes the invoking process to terminate.
        ///
        /// For local invocation, it does nothing.
        ///
        /// This method should be called in the `gio.Application.signals.command_line`
        /// handler, after the exit status is set and all messages are printed.
        ///
        /// After this call, `gio.ApplicationCommandLine.setExitStatus` has no effect.
        /// Subsequent calls to this method are no-ops.
        ///
        /// This method is automatically called when the `gio.ApplicationCommandLine`
        /// object is disposed — so you can omit the call in non-garbage collected
        /// languages.
        pub const done = struct {
            pub fn call(p_class: anytype, p_cmdline: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(ApplicationCommandLine.Class, p_class).f_done.?(gobject.ext.as(ApplicationCommandLine, p_cmdline));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cmdline: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(ApplicationCommandLine.Class, p_class).f_done = @ptrCast(p_implementation);
            }
        };

        /// Gets the stdin of the invoking process.
        ///
        /// The `gio.InputStream` can be used to read data passed to the standard
        /// input of the invoking process.
        /// This doesn't work on all platforms.  Presently, it is only available
        /// on UNIX when using a D-Bus daemon capable of passing file descriptors.
        /// If stdin is not available then `NULL` will be returned.  In the
        /// future, support may be expanded to other platforms.
        ///
        /// You must only call this function once per commandline invocation.
        pub const get_stdin = struct {
            pub fn call(p_class: anytype, p_cmdline: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*gio.InputStream {
                return gobject.ext.as(ApplicationCommandLine.Class, p_class).f_get_stdin.?(gobject.ext.as(ApplicationCommandLine, p_cmdline));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cmdline: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*gio.InputStream) void {
                gobject.ext.as(ApplicationCommandLine.Class, p_class).f_get_stdin = @ptrCast(p_implementation);
            }
        };

        /// Prints a message using the stdout print handler in the invoking process.
        ///
        /// Unlike `gio.ApplicationCommandLine.print`, `message` is not a ``printf``-style
        /// format string. Use this function if `message` contains text you don't have
        /// control over, that could include ``printf`` escape sequences.
        pub const print_literal = struct {
            pub fn call(p_class: anytype, p_cmdline: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_message: [*:0]const u8) void {
                return gobject.ext.as(ApplicationCommandLine.Class, p_class).f_print_literal.?(gobject.ext.as(ApplicationCommandLine, p_cmdline), p_message);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cmdline: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_message: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(ApplicationCommandLine.Class, p_class).f_print_literal = @ptrCast(p_implementation);
            }
        };

        /// Prints a message using the stderr print handler in the invoking process.
        ///
        /// Unlike `gio.ApplicationCommandLine.printerr`, `message` is not
        /// a ``printf``-style format string. Use this function if `message` contains text
        /// you don't have control over, that could include ``printf`` escape sequences.
        pub const printerr_literal = struct {
            pub fn call(p_class: anytype, p_cmdline: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_message: [*:0]const u8) void {
                return gobject.ext.as(ApplicationCommandLine.Class, p_class).f_printerr_literal.?(gobject.ext.as(ApplicationCommandLine, p_cmdline), p_message);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cmdline: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_message: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(ApplicationCommandLine.Class, p_class).f_printerr_literal = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The commandline that caused this `gio.Application.signals.command_line`
        /// signal emission.
        pub const arguments = struct {
            pub const name = "arguments";

            pub const Type = ?*glib.Variant;
        };

        /// Whether this is a remote commandline.
        pub const is_remote = struct {
            pub const name = "is-remote";

            pub const Type = c_int;
        };

        /// The options sent along with the commandline.
        pub const options = struct {
            pub const name = "options";

            pub const Type = ?*glib.Variant;
        };

        /// Platform-specific data for the commandline.
        pub const platform_data = struct {
            pub const name = "platform-data";

            pub const Type = ?*glib.Variant;
        };
    };

    pub const signals = struct {};

    /// Creates a `gio.File` corresponding to a filename that was given as part
    /// of the invocation of `cmdline`.
    ///
    /// This differs from `gio.fileNewForCommandlineArg` in that it
    /// resolves relative pathnames using the current working directory of
    /// the invoking process rather than the local process.
    extern fn g_application_command_line_create_file_for_arg(p_cmdline: *ApplicationCommandLine, p_arg: [*:0]const u8) *gio.File;
    pub const createFileForArg = g_application_command_line_create_file_for_arg;

    /// Signals that command line processing is completed.
    ///
    /// For remote invocation, it causes the invoking process to terminate.
    ///
    /// For local invocation, it does nothing.
    ///
    /// This method should be called in the `gio.Application.signals.command_line`
    /// handler, after the exit status is set and all messages are printed.
    ///
    /// After this call, `gio.ApplicationCommandLine.setExitStatus` has no effect.
    /// Subsequent calls to this method are no-ops.
    ///
    /// This method is automatically called when the `gio.ApplicationCommandLine`
    /// object is disposed — so you can omit the call in non-garbage collected
    /// languages.
    extern fn g_application_command_line_done(p_cmdline: *ApplicationCommandLine) void;
    pub const done = g_application_command_line_done;

    /// Gets the list of arguments that was passed on the command line.
    ///
    /// The strings in the array may contain non-UTF-8 data on UNIX (such as
    /// filenames or arguments given in the system locale) but are always in
    /// UTF-8 on Windows.
    ///
    /// If you wish to use the return value with `glib.OptionContext`, you must
    /// use `glib.OptionContext.parseStrv`.
    ///
    /// The return value is `NULL`-terminated and should be freed using
    /// `glib.strfreev`.
    extern fn g_application_command_line_get_arguments(p_cmdline: *ApplicationCommandLine, p_argc: ?*c_int) [*][*:0]u8;
    pub const getArguments = g_application_command_line_get_arguments;

    /// Gets the working directory of the command line invocation.
    /// The string may contain non-utf8 data.
    ///
    /// It is possible that the remote application did not send a working
    /// directory, so this may be `NULL`.
    ///
    /// The return value should not be modified or freed and is valid for as
    /// long as `cmdline` exists.
    extern fn g_application_command_line_get_cwd(p_cmdline: *ApplicationCommandLine) ?[*:0]const u8;
    pub const getCwd = g_application_command_line_get_cwd;

    /// Gets the contents of the 'environ' variable of the command line
    /// invocation, as would be returned by `glib.getEnviron`, ie as a
    /// `NULL`-terminated list of strings in the form 'NAME=VALUE'.
    /// The strings may contain non-utf8 data.
    ///
    /// The remote application usually does not send an environment.  Use
    /// `G_APPLICATION_SEND_ENVIRONMENT` to affect that.  Even with this flag
    /// set it is possible that the environment is still not available (due
    /// to invocation messages from other applications).
    ///
    /// The return value should not be modified or freed and is valid for as
    /// long as `cmdline` exists.
    ///
    /// See `gio.ApplicationCommandLine.getenv` if you are only interested
    /// in the value of a single environment variable.
    extern fn g_application_command_line_get_environ(p_cmdline: *ApplicationCommandLine) [*]const [*:0]const u8;
    pub const getEnviron = g_application_command_line_get_environ;

    /// Gets the exit status of `cmdline`.  See
    /// `gio.ApplicationCommandLine.setExitStatus` for more information.
    extern fn g_application_command_line_get_exit_status(p_cmdline: *ApplicationCommandLine) c_int;
    pub const getExitStatus = g_application_command_line_get_exit_status;

    /// Determines if `cmdline` represents a remote invocation.
    extern fn g_application_command_line_get_is_remote(p_cmdline: *ApplicationCommandLine) c_int;
    pub const getIsRemote = g_application_command_line_get_is_remote;

    /// Gets the options that were passed to `g_application_command_line`.
    ///
    /// If you did not override `local_command_line` then these are the same
    /// options that were parsed according to the `GOptionEntrys` added to the
    /// application with `gio.Application.addMainOptionEntries` and possibly
    /// modified from your GApplication::handle-local-options handler.
    ///
    /// If no options were sent then an empty dictionary is returned so that
    /// you don't need to check for `NULL`.
    ///
    /// The data has been passed via an untrusted external process, so the types of
    /// all values must be checked before being used.
    extern fn g_application_command_line_get_options_dict(p_cmdline: *ApplicationCommandLine) *glib.VariantDict;
    pub const getOptionsDict = g_application_command_line_get_options_dict;

    /// Gets the platform data associated with the invocation of `cmdline`.
    ///
    /// This is a `glib.Variant` dictionary containing information about the
    /// context in which the invocation occurred.  It typically contains
    /// information like the current working directory and the startup
    /// notification ID.
    ///
    /// It comes from an untrusted external process and hence the types of all
    /// values must be validated before being used.
    ///
    /// For local invocation, it will be `NULL`.
    extern fn g_application_command_line_get_platform_data(p_cmdline: *ApplicationCommandLine) ?*glib.Variant;
    pub const getPlatformData = g_application_command_line_get_platform_data;

    /// Gets the stdin of the invoking process.
    ///
    /// The `gio.InputStream` can be used to read data passed to the standard
    /// input of the invoking process.
    /// This doesn't work on all platforms.  Presently, it is only available
    /// on UNIX when using a D-Bus daemon capable of passing file descriptors.
    /// If stdin is not available then `NULL` will be returned.  In the
    /// future, support may be expanded to other platforms.
    ///
    /// You must only call this function once per commandline invocation.
    extern fn g_application_command_line_get_stdin(p_cmdline: *ApplicationCommandLine) ?*gio.InputStream;
    pub const getStdin = g_application_command_line_get_stdin;

    /// Gets the value of a particular environment variable of the command
    /// line invocation, as would be returned by `glib.getenv`.  The strings may
    /// contain non-utf8 data.
    ///
    /// The remote application usually does not send an environment.  Use
    /// `G_APPLICATION_SEND_ENVIRONMENT` to affect that.  Even with this flag
    /// set it is possible that the environment is still not available (due
    /// to invocation messages from other applications).
    ///
    /// The return value should not be modified or freed and is valid for as
    /// long as `cmdline` exists.
    extern fn g_application_command_line_getenv(p_cmdline: *ApplicationCommandLine, p_name: [*:0]const u8) ?[*:0]const u8;
    pub const getenv = g_application_command_line_getenv;

    /// Formats a message and prints it using the stdout print handler in the
    /// invoking process.
    ///
    /// If `cmdline` is a local invocation then this is exactly equivalent to
    /// `glib.print`.  If `cmdline` is remote then this is equivalent to calling
    /// `glib.print` in the invoking process.
    extern fn g_application_command_line_print(p_cmdline: *ApplicationCommandLine, p_format: [*:0]const u8, ...) void;
    pub const print = g_application_command_line_print;

    /// Prints a message using the stdout print handler in the invoking process.
    ///
    /// Unlike `gio.ApplicationCommandLine.print`, `message` is not a ``printf``-style
    /// format string. Use this function if `message` contains text you don't have
    /// control over, that could include ``printf`` escape sequences.
    extern fn g_application_command_line_print_literal(p_cmdline: *ApplicationCommandLine, p_message: [*:0]const u8) void;
    pub const printLiteral = g_application_command_line_print_literal;

    /// Formats a message and prints it using the stderr print handler in the
    /// invoking process.
    ///
    /// If `cmdline` is a local invocation then this is exactly equivalent to
    /// `glib.printerr`.  If `cmdline` is remote then this is equivalent to
    /// calling `glib.printerr` in the invoking process.
    extern fn g_application_command_line_printerr(p_cmdline: *ApplicationCommandLine, p_format: [*:0]const u8, ...) void;
    pub const printerr = g_application_command_line_printerr;

    /// Prints a message using the stderr print handler in the invoking process.
    ///
    /// Unlike `gio.ApplicationCommandLine.printerr`, `message` is not
    /// a ``printf``-style format string. Use this function if `message` contains text
    /// you don't have control over, that could include ``printf`` escape sequences.
    extern fn g_application_command_line_printerr_literal(p_cmdline: *ApplicationCommandLine, p_message: [*:0]const u8) void;
    pub const printerrLiteral = g_application_command_line_printerr_literal;

    /// Sets the exit status that will be used when the invoking process
    /// exits.
    ///
    /// The return value of the `gio.Application.signals.command`-line signal is
    /// passed to this function when the handler returns.  This is the usual
    /// way of setting the exit status.
    ///
    /// In the event that you want the remote invocation to continue running
    /// and want to decide on the exit status in the future, you can use this
    /// call.  For the case of a remote invocation, the remote process will
    /// typically exit when the last reference is dropped on `cmdline`.  The
    /// exit status of the remote process will be equal to the last value
    /// that was set with this function.
    ///
    /// In the case that the commandline invocation is local, the situation
    /// is slightly more complicated.  If the commandline invocation results
    /// in the mainloop running (ie: because the use-count of the application
    /// increased to a non-zero value) then the application is considered to
    /// have been 'successful' in a certain sense, and the exit status is
    /// always zero.  If the application use count is zero, though, the exit
    /// status of the local `gio.ApplicationCommandLine` is used.
    ///
    /// This method is a no-op if `gio.ApplicationCommandLine.done` has
    /// been called.
    extern fn g_application_command_line_set_exit_status(p_cmdline: *ApplicationCommandLine, p_exit_status: c_int) void;
    pub const setExitStatus = g_application_command_line_set_exit_status;

    extern fn g_application_command_line_get_type() usize;
    pub const getGObjectType = g_application_command_line_get_type;

    extern fn g_object_ref(p_self: *gio.ApplicationCommandLine) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.ApplicationCommandLine) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ApplicationCommandLine, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Buffered input stream implements `gio.FilterInputStream` and provides
/// for buffered reads.
///
/// By default, `GBufferedInputStream`'s buffer size is set at 4 kilobytes.
///
/// To create a buffered input stream, use `gio.BufferedInputStream.new`,
/// or `gio.BufferedInputStream.newSized` to specify the buffer's size at
/// construction.
///
/// To get the size of a buffer within a buffered input stream, use
/// `gio.BufferedInputStream.getBufferSize`. To change the size of a
/// buffered input stream's buffer, use `gio.BufferedInputStream.setBufferSize`.
/// Note that the buffer's size cannot be reduced below the size of the data within the buffer.
pub const BufferedInputStream = extern struct {
    pub const Parent = gio.FilterInputStream;
    pub const Implements = [_]type{gio.Seekable};
    pub const Class = gio.BufferedInputStreamClass;
    f_parent_instance: gio.FilterInputStream,
    f_priv: ?*gio.BufferedInputStreamPrivate,

    pub const virtual_methods = struct {
        /// Tries to read `count` bytes from the stream into the buffer.
        /// Will block during this read.
        ///
        /// If `count` is zero, returns zero and does nothing. A value of `count`
        /// larger than `G_MAXSSIZE` will cause a
        /// `gio.@"IOErrorEnum.INVALID_ARGUMENT"` error.
        ///
        /// On success, the number of bytes read into the buffer is returned.
        /// It is not an error if this is not the same as the requested size, as it
        /// can happen e.g. near the end of a file. Zero is returned on end of file
        /// (or if `count` is zero),  but never otherwise.
        ///
        /// If `count` is -1 then the attempted read size is equal to the number of
        /// bytes that are required to fill the buffer.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `gio.@"IOErrorEnum.CANCELLED"` will be returned.
        /// If an operation was partially finished when the operation was cancelled the
        /// partial result will be returned, without an error.
        ///
        /// On error `-1` is returned and `error` is set accordingly.
        ///
        /// For the asynchronous, non-blocking, version of this function, see
        /// `gio.BufferedInputStream.fillAsync`.
        pub const fill = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_count: isize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize {
                return gobject.ext.as(BufferedInputStream.Class, p_class).f_fill.?(gobject.ext.as(BufferedInputStream, p_stream), p_count, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_count: isize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) isize) void {
                gobject.ext.as(BufferedInputStream.Class, p_class).f_fill = @ptrCast(p_implementation);
            }
        };

        /// Reads data into `stream`'s buffer asynchronously, up to `count` size.
        /// `io_priority` can be used to prioritize reads. For the synchronous
        /// version of this function, see `gio.BufferedInputStream.fill`.
        ///
        /// If `count` is `-1` then the attempted read size is equal to the number
        /// of bytes that are required to fill the buffer.
        pub const fill_async = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_count: isize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(BufferedInputStream.Class, p_class).f_fill_async.?(gobject.ext.as(BufferedInputStream, p_stream), p_count, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_count: isize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(BufferedInputStream.Class, p_class).f_fill_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous read.
        pub const fill_finish = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) isize {
                return gobject.ext.as(BufferedInputStream.Class, p_class).f_fill_finish.?(gobject.ext.as(BufferedInputStream, p_stream), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) isize) void {
                gobject.ext.as(BufferedInputStream.Class, p_class).f_fill_finish = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The size of the backend buffer, in bytes.
        pub const buffer_size = struct {
            pub const name = "buffer-size";

            pub const Type = c_uint;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.InputStream` from the given `base_stream`, with
    /// a buffer set to the default size (4 kilobytes).
    extern fn g_buffered_input_stream_new(p_base_stream: *gio.InputStream) *gio.BufferedInputStream;
    pub const new = g_buffered_input_stream_new;

    /// Creates a new `gio.BufferedInputStream` from the given `base_stream`,
    /// with a buffer set to `size`.
    extern fn g_buffered_input_stream_new_sized(p_base_stream: *gio.InputStream, p_size: usize) *gio.BufferedInputStream;
    pub const newSized = g_buffered_input_stream_new_sized;

    /// Tries to read `count` bytes from the stream into the buffer.
    /// Will block during this read.
    ///
    /// If `count` is zero, returns zero and does nothing. A value of `count`
    /// larger than `G_MAXSSIZE` will cause a
    /// `gio.@"IOErrorEnum.INVALID_ARGUMENT"` error.
    ///
    /// On success, the number of bytes read into the buffer is returned.
    /// It is not an error if this is not the same as the requested size, as it
    /// can happen e.g. near the end of a file. Zero is returned on end of file
    /// (or if `count` is zero),  but never otherwise.
    ///
    /// If `count` is -1 then the attempted read size is equal to the number of
    /// bytes that are required to fill the buffer.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `gio.@"IOErrorEnum.CANCELLED"` will be returned.
    /// If an operation was partially finished when the operation was cancelled the
    /// partial result will be returned, without an error.
    ///
    /// On error `-1` is returned and `error` is set accordingly.
    ///
    /// For the asynchronous, non-blocking, version of this function, see
    /// `gio.BufferedInputStream.fillAsync`.
    extern fn g_buffered_input_stream_fill(p_stream: *BufferedInputStream, p_count: isize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const fill = g_buffered_input_stream_fill;

    /// Reads data into `stream`'s buffer asynchronously, up to `count` size.
    /// `io_priority` can be used to prioritize reads. For the synchronous
    /// version of this function, see `gio.BufferedInputStream.fill`.
    ///
    /// If `count` is `-1` then the attempted read size is equal to the number
    /// of bytes that are required to fill the buffer.
    extern fn g_buffered_input_stream_fill_async(p_stream: *BufferedInputStream, p_count: isize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const fillAsync = g_buffered_input_stream_fill_async;

    /// Finishes an asynchronous read.
    extern fn g_buffered_input_stream_fill_finish(p_stream: *BufferedInputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) isize;
    pub const fillFinish = g_buffered_input_stream_fill_finish;

    /// Gets the size of the available data within the stream.
    extern fn g_buffered_input_stream_get_available(p_stream: *BufferedInputStream) usize;
    pub const getAvailable = g_buffered_input_stream_get_available;

    /// Gets the size of the input buffer.
    extern fn g_buffered_input_stream_get_buffer_size(p_stream: *BufferedInputStream) usize;
    pub const getBufferSize = g_buffered_input_stream_get_buffer_size;

    /// Peeks in the buffer, copying data of size `count` into `buffer`,
    /// offset `offset` bytes.
    extern fn g_buffered_input_stream_peek(p_stream: *BufferedInputStream, p_buffer: [*]u8, p_offset: usize, p_count: usize) usize;
    pub const peek = g_buffered_input_stream_peek;

    /// Returns the buffer with the currently available bytes. The returned
    /// buffer must not be modified and will become invalid when reading from
    /// the stream or filling the buffer.
    extern fn g_buffered_input_stream_peek_buffer(p_stream: *BufferedInputStream, p_count: *usize) [*]u8;
    pub const peekBuffer = g_buffered_input_stream_peek_buffer;

    /// Tries to read a single byte from the stream or the buffer. Will block
    /// during this read.
    ///
    /// On success, the byte read from the stream is returned. On end of stream
    /// `-1` is returned but it's not an exceptional error and `error` is not set.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `gio.@"IOErrorEnum.CANCELLED"` will be returned.
    /// If an operation was partially finished when the operation was cancelled the
    /// partial result will be returned, without an error.
    ///
    /// On error `-1` is returned and `error` is set accordingly.
    extern fn g_buffered_input_stream_read_byte(p_stream: *BufferedInputStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const readByte = g_buffered_input_stream_read_byte;

    /// Sets the size of the internal buffer of `stream` to `size`, or to the
    /// size of the contents of the buffer. The buffer can never be resized
    /// smaller than its current contents.
    extern fn g_buffered_input_stream_set_buffer_size(p_stream: *BufferedInputStream, p_size: usize) void;
    pub const setBufferSize = g_buffered_input_stream_set_buffer_size;

    extern fn g_buffered_input_stream_get_type() usize;
    pub const getGObjectType = g_buffered_input_stream_get_type;

    extern fn g_object_ref(p_self: *gio.BufferedInputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.BufferedInputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *BufferedInputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Buffered output stream implements `gio.FilterOutputStream` and provides
/// for buffered writes.
///
/// By default, `GBufferedOutputStream`'s buffer size is set at 4 kilobytes.
///
/// To create a buffered output stream, use `gio.BufferedOutputStream.new`,
/// or `gio.BufferedOutputStream.newSized` to specify the buffer's size
/// at construction.
///
/// To get the size of a buffer within a buffered input stream, use
/// `gio.BufferedOutputStream.getBufferSize`. To change the size of a
/// buffered output stream's buffer, use `gio.BufferedOutputStream.setBufferSize`.
/// Note that the buffer's size cannot be reduced below the size of the data within the buffer.
pub const BufferedOutputStream = extern struct {
    pub const Parent = gio.FilterOutputStream;
    pub const Implements = [_]type{gio.Seekable};
    pub const Class = gio.BufferedOutputStreamClass;
    f_parent_instance: gio.FilterOutputStream,
    f_priv: ?*gio.BufferedOutputStreamPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Whether the buffer should automatically grow.
        pub const auto_grow = struct {
            pub const name = "auto-grow";

            pub const Type = c_int;
        };

        /// The size of the backend buffer, in bytes.
        pub const buffer_size = struct {
            pub const name = "buffer-size";

            pub const Type = c_uint;
        };
    };

    pub const signals = struct {};

    /// Creates a new buffered output stream for a base stream.
    extern fn g_buffered_output_stream_new(p_base_stream: *gio.OutputStream) *gio.BufferedOutputStream;
    pub const new = g_buffered_output_stream_new;

    /// Creates a new buffered output stream with a given buffer size.
    extern fn g_buffered_output_stream_new_sized(p_base_stream: *gio.OutputStream, p_size: usize) *gio.BufferedOutputStream;
    pub const newSized = g_buffered_output_stream_new_sized;

    /// Checks if the buffer automatically grows as data is added.
    extern fn g_buffered_output_stream_get_auto_grow(p_stream: *BufferedOutputStream) c_int;
    pub const getAutoGrow = g_buffered_output_stream_get_auto_grow;

    /// Gets the size of the buffer in the `stream`.
    extern fn g_buffered_output_stream_get_buffer_size(p_stream: *BufferedOutputStream) usize;
    pub const getBufferSize = g_buffered_output_stream_get_buffer_size;

    /// Sets whether or not the `stream`'s buffer should automatically grow.
    /// If `auto_grow` is true, then each write will just make the buffer
    /// larger, and you must manually flush the buffer to actually write out
    /// the data to the underlying stream.
    extern fn g_buffered_output_stream_set_auto_grow(p_stream: *BufferedOutputStream, p_auto_grow: c_int) void;
    pub const setAutoGrow = g_buffered_output_stream_set_auto_grow;

    /// Sets the size of the internal buffer to `size`.
    extern fn g_buffered_output_stream_set_buffer_size(p_stream: *BufferedOutputStream, p_size: usize) void;
    pub const setBufferSize = g_buffered_output_stream_set_buffer_size;

    extern fn g_buffered_output_stream_get_type() usize;
    pub const getGObjectType = g_buffered_output_stream_get_type;

    extern fn g_object_ref(p_self: *gio.BufferedOutputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.BufferedOutputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *BufferedOutputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GBytesIcon` specifies an image held in memory in a common format (usually
/// PNG) to be used as icon.
pub const BytesIcon = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gio.Icon, gio.LoadableIcon };
    pub const Class = opaque {
        pub const Instance = BytesIcon;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The bytes containing the icon.
        pub const bytes = struct {
            pub const name = "bytes";

            pub const Type = ?*glib.Bytes;
        };
    };

    pub const signals = struct {};

    /// Creates a new icon for a bytes.
    ///
    /// This cannot fail, but loading and interpreting the bytes may fail later on
    /// (for example, if `gio.LoadableIcon.load` is called) if the image is invalid.
    extern fn g_bytes_icon_new(p_bytes: *glib.Bytes) *gio.BytesIcon;
    pub const new = g_bytes_icon_new;

    /// Gets the `glib.Bytes` associated with the given `icon`.
    extern fn g_bytes_icon_get_bytes(p_icon: *BytesIcon) *glib.Bytes;
    pub const getBytes = g_bytes_icon_get_bytes;

    extern fn g_bytes_icon_get_type() usize;
    pub const getGObjectType = g_bytes_icon_get_type;

    extern fn g_object_ref(p_self: *gio.BytesIcon) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.BytesIcon) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *BytesIcon, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GCancellable` allows operations to be cancelled.
///
/// `GCancellable` is a thread-safe operation cancellation stack used
/// throughout GIO to allow for cancellation of synchronous and
/// asynchronous operations.
pub const Cancellable = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.CancellableClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.CancellablePrivate,

    pub const virtual_methods = struct {
        pub const cancelled = struct {
            pub fn call(p_class: anytype, p_cancellable: ?*@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Cancellable.Class, p_class).f_cancelled.?(gobject.ext.as(Cancellable, p_cancellable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cancellable: ?*@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Cancellable.Class, p_class).f_cancelled = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// Emitted when the operation has been cancelled.
        ///
        /// Can be used by implementations of cancellable operations. If the
        /// operation is cancelled from another thread, the signal will be
        /// emitted in the thread that cancelled the operation, not the
        /// thread that is running the operation.
        ///
        /// Note that disconnecting from this signal (or any signal) in a
        /// multi-threaded program is prone to race conditions. For instance
        /// it is possible that a signal handler may be invoked even after
        /// a call to `gobject.signalHandlerDisconnect` for that handler has
        /// already returned.
        ///
        /// There is also a problem when cancellation happens right before
        /// connecting to the signal. If this happens the signal will
        /// unexpectedly not be emitted, and checking before connecting to
        /// the signal leaves a race condition where this is still happening.
        ///
        /// In order to make it safe and easy to connect handlers there
        /// are two helper functions: `gio.Cancellable.connect` and
        /// `gio.Cancellable.disconnect` which protect against problems
        /// like this.
        ///
        /// An example of how to us this:
        /// ```
        ///     // Make sure we don't do unnecessary work if already cancelled
        ///     if (g_cancellable_set_error_if_cancelled (cancellable, error))
        ///       return;
        ///
        ///     // Set up all the data needed to be able to handle cancellation
        ///     // of the operation
        ///     my_data = my_data_new (...);
        ///
        ///     id = 0;
        ///     if (cancellable)
        ///       id = g_cancellable_connect (cancellable,
        ///                       G_CALLBACK (cancelled_handler)
        ///                       data, NULL);
        ///
        ///     // cancellable operation here...
        ///
        ///     g_cancellable_disconnect (cancellable, id);
        ///
        ///     // cancelled_handler is never called after this, it is now safe
        ///     // to free the data
        ///     my_data_free (my_data);
        /// ```
        ///
        /// Note that the cancelled signal is emitted in the thread that
        /// the user cancelled from, which may be the main thread. So, the
        /// cancellable signal should not do something that can block.
        pub const cancelled = struct {
            pub const name = "cancelled";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Cancellable, p_instance))),
                    gobject.signalLookup("cancelled", Cancellable.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Gets the top cancellable from the stack.
    extern fn g_cancellable_get_current() ?*gio.Cancellable;
    pub const getCurrent = g_cancellable_get_current;

    /// Creates a new `gio.Cancellable` object.
    ///
    /// Applications that want to start one or more operations
    /// that should be cancellable should create a `gio.Cancellable`
    /// and pass it to the operations.
    ///
    /// One `gio.Cancellable` can be used in multiple consecutive
    /// operations or in multiple concurrent operations.
    extern fn g_cancellable_new() *gio.Cancellable;
    pub const new = g_cancellable_new;

    /// Will set `cancellable` to cancelled, and will emit the
    /// `gio.Cancellable.signals.cancelled` signal. (However, see the warning about
    /// race conditions in the documentation for that signal if you are
    /// planning to connect to it.)
    ///
    /// This function is thread-safe. In other words, you can safely call
    /// it from a thread other than the one running the operation that was
    /// passed the `cancellable`.
    ///
    /// If `cancellable` is `NULL`, this function returns immediately for convenience.
    ///
    /// The convention within GIO is that cancelling an asynchronous
    /// operation causes it to complete asynchronously. That is, if you
    /// cancel the operation from the same thread in which it is running,
    /// then the operation's `gio.AsyncReadyCallback` will not be invoked until
    /// the application returns to the main loop.
    extern fn g_cancellable_cancel(p_cancellable: ?*Cancellable) void;
    pub const cancel = g_cancellable_cancel;

    /// Convenience function to connect to the `gio.Cancellable.signals.cancelled`
    /// signal. Also handles the race condition that may happen
    /// if the cancellable is cancelled right before connecting.
    ///
    /// `callback` is called exactly once each time `cancellable` is cancelled,
    /// either directly at the time of the connect if `cancellable` is already
    /// cancelled, or when `cancellable` is cancelled in some thread.
    /// In case the cancellable is reset via `gio.Cancellable.reset`
    /// then the callback can be called again if the `cancellable` is cancelled.
    ///
    /// `data_destroy_func` will be called when the handler is
    /// disconnected, or immediately if the cancellable is already
    /// cancelled.
    ///
    /// See `gio.Cancellable.signals.cancelled` for details on how to use this.
    ///
    /// Since GLib 2.40, the lock protecting `cancellable` is not held when
    /// `callback` is invoked.  This lifts a restriction in place for
    /// earlier GLib versions which now makes it easier to write cleanup
    /// code that unconditionally invokes e.g. `gio.Cancellable.cancel`.
    extern fn g_cancellable_connect(p_cancellable: ?*Cancellable, p_callback: gobject.Callback, p_data: ?*anyopaque, p_data_destroy_func: ?glib.DestroyNotify) c_ulong;
    pub const connect = g_cancellable_connect;

    /// Disconnects a handler from a cancellable instance similar to
    /// `gobject.signalHandlerDisconnect`.  Additionally, in the event that a
    /// signal handler is currently running, this call will block until the
    /// handler has finished.  Calling this function from a
    /// `gio.Cancellable.signals.cancelled` signal handler will therefore result in a
    /// deadlock.
    ///
    /// This avoids a race condition where a thread cancels at the
    /// same time as the cancellable operation is finished and the
    /// signal handler is removed. See `gio.Cancellable.signals.cancelled` for
    /// details on how to use this.
    ///
    /// If `cancellable` is `NULL` or `handler_id` is `0` this function does
    /// nothing.
    extern fn g_cancellable_disconnect(p_cancellable: ?*Cancellable, p_handler_id: c_ulong) void;
    pub const disconnect = g_cancellable_disconnect;

    /// Gets the file descriptor for a cancellable job. This can be used to
    /// implement cancellable operations on Unix systems. The returned fd will
    /// turn readable when `cancellable` is cancelled.
    ///
    /// You are not supposed to read from the fd yourself, just check for
    /// readable status. Reading to unset the readable status is done
    /// with `gio.Cancellable.reset`.
    ///
    /// After a successful return from this function, you should use
    /// `gio.Cancellable.releaseFd` to free up resources allocated for
    /// the returned file descriptor.
    ///
    /// See also `gio.Cancellable.makePollfd`.
    extern fn g_cancellable_get_fd(p_cancellable: ?*Cancellable) c_int;
    pub const getFd = g_cancellable_get_fd;

    /// Checks if a cancellable job has been cancelled.
    extern fn g_cancellable_is_cancelled(p_cancellable: ?*Cancellable) c_int;
    pub const isCancelled = g_cancellable_is_cancelled;

    /// Creates a `glib.PollFD` corresponding to `cancellable`; this can be passed
    /// to `glib.poll` and used to poll for cancellation. This is useful both
    /// for unix systems without a native poll and for portability to
    /// windows.
    ///
    /// When this function returns `TRUE`, you should use
    /// `gio.Cancellable.releaseFd` to free up resources allocated for the
    /// `pollfd`. After a `FALSE` return, do not call `gio.Cancellable.releaseFd`.
    ///
    /// If this function returns `FALSE`, either no `cancellable` was given or
    /// resource limits prevent this function from allocating the necessary
    /// structures for polling. (On Linux, you will likely have reached
    /// the maximum number of file descriptors.) The suggested way to handle
    /// these cases is to ignore the `cancellable`.
    ///
    /// You are not supposed to read from the fd yourself, just check for
    /// readable status. Reading to unset the readable status is done
    /// with `gio.Cancellable.reset`.
    extern fn g_cancellable_make_pollfd(p_cancellable: ?*Cancellable, p_pollfd: *glib.PollFD) c_int;
    pub const makePollfd = g_cancellable_make_pollfd;

    /// Pops `cancellable` off the cancellable stack (verifying that `cancellable`
    /// is on the top of the stack).
    extern fn g_cancellable_pop_current(p_cancellable: ?*Cancellable) void;
    pub const popCurrent = g_cancellable_pop_current;

    /// Pushes `cancellable` onto the cancellable stack. The current
    /// cancellable can then be received using `gio.Cancellable.getCurrent`.
    ///
    /// This is useful when implementing cancellable operations in
    /// code that does not allow you to pass down the cancellable object.
    ///
    /// This is typically called automatically by e.g. `gio.File` operations,
    /// so you rarely have to call this yourself.
    extern fn g_cancellable_push_current(p_cancellable: ?*Cancellable) void;
    pub const pushCurrent = g_cancellable_push_current;

    /// Releases a resources previously allocated by `gio.Cancellable.getFd`
    /// or `gio.Cancellable.makePollfd`.
    ///
    /// For compatibility reasons with older releases, calling this function
    /// is not strictly required, the resources will be automatically freed
    /// when the `cancellable` is finalized. However, the `cancellable` will
    /// block scarce file descriptors until it is finalized if this function
    /// is not called. This can cause the application to run out of file
    /// descriptors when many `GCancellables` are used at the same time.
    extern fn g_cancellable_release_fd(p_cancellable: ?*Cancellable) void;
    pub const releaseFd = g_cancellable_release_fd;

    /// Resets `cancellable` to its uncancelled state.
    ///
    /// If cancellable is currently in use by any cancellable operation
    /// then the behavior of this function is undefined.
    ///
    /// Note that it is generally not a good idea to reuse an existing
    /// cancellable for more operations after it has been cancelled once,
    /// as this function might tempt you to do. The recommended practice
    /// is to drop the reference to a cancellable after cancelling it,
    /// and let it die with the outstanding async operations. You should
    /// create a fresh cancellable for further async operations.
    extern fn g_cancellable_reset(p_cancellable: ?*Cancellable) void;
    pub const reset = g_cancellable_reset;

    /// If the `cancellable` is cancelled, sets the error to notify
    /// that the operation was cancelled.
    extern fn g_cancellable_set_error_if_cancelled(p_cancellable: ?*Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const setErrorIfCancelled = g_cancellable_set_error_if_cancelled;

    /// Creates a source that triggers if `cancellable` is cancelled and
    /// calls its callback of type `gio.CancellableSourceFunc`. This is
    /// primarily useful for attaching to another (non-cancellable) source
    /// with `glib.Source.addChildSource` to add cancellability to it.
    ///
    /// For convenience, you can call this with a `NULL` `gio.Cancellable`,
    /// in which case the source will never trigger.
    ///
    /// The new `glib.Source` will hold a reference to the `gio.Cancellable`.
    extern fn g_cancellable_source_new(p_cancellable: ?*Cancellable) *glib.Source;
    pub const sourceNew = g_cancellable_source_new;

    extern fn g_cancellable_get_type() usize;
    pub const getGObjectType = g_cancellable_get_type;

    extern fn g_object_ref(p_self: *gio.Cancellable) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Cancellable) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Cancellable, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GCharsetConverter` is an implementation of `gio.Converter` based on
/// `glib.IConv`.
pub const CharsetConverter = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gio.Converter, gio.Initable };
    pub const Class = gio.CharsetConverterClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The character encoding to convert from.
        pub const from_charset = struct {
            pub const name = "from-charset";

            pub const Type = ?[*:0]u8;
        };

        /// The character encoding to convert to.
        pub const to_charset = struct {
            pub const name = "to-charset";

            pub const Type = ?[*:0]u8;
        };

        /// Use fallback (of form `\<hexval>`) for invalid bytes.
        pub const use_fallback = struct {
            pub const name = "use-fallback";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.CharsetConverter`.
    extern fn g_charset_converter_new(p_to_charset: [*:0]const u8, p_from_charset: [*:0]const u8, p_error: ?*?*glib.Error) ?*gio.CharsetConverter;
    pub const new = g_charset_converter_new;

    /// Gets the number of fallbacks that `converter` has applied so far.
    extern fn g_charset_converter_get_num_fallbacks(p_converter: *CharsetConverter) c_uint;
    pub const getNumFallbacks = g_charset_converter_get_num_fallbacks;

    /// Gets the `gio.CharsetConverter.properties.use`-fallback property.
    extern fn g_charset_converter_get_use_fallback(p_converter: *CharsetConverter) c_int;
    pub const getUseFallback = g_charset_converter_get_use_fallback;

    /// Sets the `gio.CharsetConverter.properties.use`-fallback property.
    extern fn g_charset_converter_set_use_fallback(p_converter: *CharsetConverter, p_use_fallback: c_int) void;
    pub const setUseFallback = g_charset_converter_set_use_fallback;

    extern fn g_charset_converter_get_type() usize;
    pub const getGObjectType = g_charset_converter_get_type;

    extern fn g_object_ref(p_self: *gio.CharsetConverter) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.CharsetConverter) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *CharsetConverter, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Converter input stream implements `gio.InputStream` and allows
/// conversion of data of various types during reading.
///
/// As of GLib 2.34, `GConverterInputStream` implements
/// `gio.PollableInputStream`.
pub const ConverterInputStream = extern struct {
    pub const Parent = gio.FilterInputStream;
    pub const Implements = [_]type{gio.PollableInputStream};
    pub const Class = gio.ConverterInputStreamClass;
    f_parent_instance: gio.FilterInputStream,
    f_priv: ?*gio.ConverterInputStreamPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The converter object.
        pub const converter = struct {
            pub const name = "converter";

            pub const Type = ?*gio.Converter;
        };
    };

    pub const signals = struct {};

    /// Creates a new converter input stream for the `base_stream`.
    extern fn g_converter_input_stream_new(p_base_stream: *gio.InputStream, p_converter: *gio.Converter) *gio.ConverterInputStream;
    pub const new = g_converter_input_stream_new;

    /// Gets the `gio.Converter` that is used by `converter_stream`.
    extern fn g_converter_input_stream_get_converter(p_converter_stream: *ConverterInputStream) *gio.Converter;
    pub const getConverter = g_converter_input_stream_get_converter;

    extern fn g_converter_input_stream_get_type() usize;
    pub const getGObjectType = g_converter_input_stream_get_type;

    extern fn g_object_ref(p_self: *gio.ConverterInputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.ConverterInputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ConverterInputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Converter output stream implements `gio.OutputStream` and allows
/// conversion of data of various types during reading.
///
/// As of GLib 2.34, `GConverterOutputStream` implements
/// `gio.PollableOutputStream`.
pub const ConverterOutputStream = extern struct {
    pub const Parent = gio.FilterOutputStream;
    pub const Implements = [_]type{gio.PollableOutputStream};
    pub const Class = gio.ConverterOutputStreamClass;
    f_parent_instance: gio.FilterOutputStream,
    f_priv: ?*gio.ConverterOutputStreamPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The converter object.
        pub const converter = struct {
            pub const name = "converter";

            pub const Type = ?*gio.Converter;
        };
    };

    pub const signals = struct {};

    /// Creates a new converter output stream for the `base_stream`.
    extern fn g_converter_output_stream_new(p_base_stream: *gio.OutputStream, p_converter: *gio.Converter) *gio.ConverterOutputStream;
    pub const new = g_converter_output_stream_new;

    /// Gets the `gio.Converter` that is used by `converter_stream`.
    extern fn g_converter_output_stream_get_converter(p_converter_stream: *ConverterOutputStream) *gio.Converter;
    pub const getConverter = g_converter_output_stream_get_converter;

    extern fn g_converter_output_stream_get_type() usize;
    pub const getGObjectType = g_converter_output_stream_get_type;

    extern fn g_object_ref(p_self: *gio.ConverterOutputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.ConverterOutputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ConverterOutputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `GCredentials` type is a reference-counted wrapper for native
/// credentials.
///
/// The information in `GCredentials` is typically used for identifying,
/// authenticating and authorizing other processes.
///
/// Some operating systems supports looking up the credentials of the remote
/// peer of a communication endpoint - see e.g. `gio.Socket.getCredentials`.
///
/// Some operating systems supports securely sending and receiving
/// credentials over a Unix Domain Socket, see `gio.UnixCredentialsMessage`,
/// `gio.UnixConnection.sendCredentials` and
/// `gio.UnixConnection.receiveCredentials` for details.
///
/// On Linux, the native credential type is a `struct ucred` - see the
/// [`unix(7)` man page](man:unix(7)) for details. This corresponds to
/// `G_CREDENTIALS_TYPE_LINUX_UCRED`.
///
/// On Apple operating systems (including iOS, tvOS, and macOS), the native credential
/// type is a `struct xucred`. This corresponds to `G_CREDENTIALS_TYPE_APPLE_XUCRED`.
///
/// On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native credential type is a
/// `struct cmsgcred`. This corresponds to `G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED`.
///
/// On NetBSD, the native credential type is a `struct unpcbid`.
/// This corresponds to `G_CREDENTIALS_TYPE_NETBSD_UNPCBID`.
///
/// On OpenBSD, the native credential type is a `struct sockpeercred`.
/// This corresponds to `G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED`.
///
/// On Solaris (including OpenSolaris and its derivatives), the native credential type
/// is a `ucred_t`. This corresponds to `G_CREDENTIALS_TYPE_SOLARIS_UCRED`.
///
/// Since GLib 2.72, on Windows, the native credentials may contain the PID of a
/// process. This corresponds to `G_CREDENTIALS_TYPE_WIN32_PID`.
pub const Credentials = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.CredentialsClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gio.Credentials` object with credentials matching the
    /// the current process.
    extern fn g_credentials_new() *gio.Credentials;
    pub const new = g_credentials_new;

    /// Gets a pointer to native credentials of type `native_type` from
    /// `credentials`.
    ///
    /// It is a programming error (which will cause a warning to be
    /// logged) to use this method if there is no `gio.Credentials` support for
    /// the OS or if `native_type` isn't supported by the OS.
    extern fn g_credentials_get_native(p_credentials: *Credentials, p_native_type: gio.CredentialsType) ?*anyopaque;
    pub const getNative = g_credentials_get_native;

    /// Tries to get the UNIX process identifier from `credentials`. This
    /// method is only available on UNIX platforms.
    ///
    /// This operation can fail if `gio.Credentials` is not supported on the
    /// OS or if the native credentials type does not contain information
    /// about the UNIX process ID.
    extern fn g_credentials_get_unix_pid(p_credentials: *Credentials, p_error: ?*?*glib.Error) std.posix.pid_t;
    pub const getUnixPid = g_credentials_get_unix_pid;

    /// Tries to get the UNIX user identifier from `credentials`. This
    /// method is only available on UNIX platforms.
    ///
    /// This operation can fail if `gio.Credentials` is not supported on the
    /// OS or if the native credentials type does not contain information
    /// about the UNIX user.
    extern fn g_credentials_get_unix_user(p_credentials: *Credentials, p_error: ?*?*glib.Error) std.posix.uid_t;
    pub const getUnixUser = g_credentials_get_unix_user;

    /// Checks if `credentials` and `other_credentials` is the same user.
    ///
    /// This operation can fail if `gio.Credentials` is not supported on the
    /// the OS.
    extern fn g_credentials_is_same_user(p_credentials: *Credentials, p_other_credentials: *gio.Credentials, p_error: ?*?*glib.Error) c_int;
    pub const isSameUser = g_credentials_is_same_user;

    /// Copies the native credentials of type `native_type` from `native`
    /// into `credentials`.
    ///
    /// It is a programming error (which will cause a warning to be
    /// logged) to use this method if there is no `gio.Credentials` support for
    /// the OS or if `native_type` isn't supported by the OS.
    extern fn g_credentials_set_native(p_credentials: *Credentials, p_native_type: gio.CredentialsType, p_native: *anyopaque) void;
    pub const setNative = g_credentials_set_native;

    /// Tries to set the UNIX user identifier on `credentials`. This method
    /// is only available on UNIX platforms.
    ///
    /// This operation can fail if `gio.Credentials` is not supported on the
    /// OS or if the native credentials type does not contain information
    /// about the UNIX user. It can also fail if the OS does not allow the
    /// use of "spoofed" credentials.
    extern fn g_credentials_set_unix_user(p_credentials: *Credentials, p_uid: std.posix.uid_t, p_error: ?*?*glib.Error) c_int;
    pub const setUnixUser = g_credentials_set_unix_user;

    /// Creates a human-readable textual representation of `credentials`
    /// that can be used in logging and debug messages. The format of the
    /// returned string may change in future GLib release.
    extern fn g_credentials_to_string(p_credentials: *Credentials) [*:0]u8;
    pub const toString = g_credentials_to_string;

    extern fn g_credentials_get_type() usize;
    pub const getGObjectType = g_credentials_get_type;

    extern fn g_object_ref(p_self: *gio.Credentials) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Credentials) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Credentials, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GDBusActionGroup` is an implementation of the `gio.ActionGroup`
/// interface.
///
/// `GDBusActionGroup` can be used as a proxy for an action group
/// that is exported over D-Bus with `gio.DBusConnection.exportActionGroup`.
pub const DBusActionGroup = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gio.ActionGroup, gio.RemoteActionGroup };
    pub const Class = opaque {
        pub const Instance = DBusActionGroup;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Obtains a `gio.DBusActionGroup` for the action group which is exported at
    /// the given `bus_name` and `object_path`.
    ///
    /// The thread default main context is taken at the time of this call.
    /// All signals on the menu model (and any linked models) are reported
    /// with respect to this context.  All calls on the returned menu model
    /// (and linked models) must also originate from this same context, with
    /// the thread default main context unchanged.
    ///
    /// This call is non-blocking.  The returned action group may or may not
    /// already be filled in.  The correct thing to do is connect the signals
    /// for the action group to monitor for changes and then to call
    /// `gio.ActionGroup.listActions` to get the initial list.
    extern fn g_dbus_action_group_get(p_connection: *gio.DBusConnection, p_bus_name: ?[*:0]const u8, p_object_path: [*:0]const u8) *gio.DBusActionGroup;
    pub const get = g_dbus_action_group_get;

    extern fn g_dbus_action_group_get_type() usize;
    pub const getGObjectType = g_dbus_action_group_get_type;

    extern fn g_object_ref(p_self: *gio.DBusActionGroup) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusActionGroup) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusActionGroup, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GDBusAuthObserver` provides a mechanism for participating
/// in how a `gio.DBusServer` (or a `gio.DBusConnection`)
/// authenticates remote peers.
///
/// Simply instantiate a `GDBusAuthObserver` and connect to the
/// signals you are interested in. Note that new signals may be added
/// in the future.
///
/// ## Controlling Authentication Mechanisms
///
/// By default, a `GDBusServer` or server-side `GDBusConnection` will allow
/// any authentication mechanism to be used. If you only want to allow D-Bus
/// connections with the `EXTERNAL` mechanism, which makes use of credentials
/// passing and is the recommended mechanism for modern Unix platforms such
/// as Linux and the BSD family, you would use a signal handler like this:
///
/// ```c
/// static gboolean
/// on_allow_mechanism (GDBusAuthObserver *observer,
///                     const gchar       *mechanism,
///                     gpointer           user_data)
/// {
///   if (g_strcmp0 (mechanism, "EXTERNAL") == 0)
///     {
///       return TRUE;
///     }
///
///   return FALSE;
/// }
/// ```
///
/// ## Controlling Authorization
///
/// By default, a `GDBusServer` or server-side `GDBusConnection` will accept
/// connections from any successfully authenticated user (but not from
/// anonymous connections using the `ANONYMOUS` mechanism). If you only
/// want to allow D-Bus connections from processes owned by the same uid
/// as the server, since GLib 2.68, you should use the
/// `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag. It’s equivalent
/// to the following signal handler:
///
/// ```c
/// static gboolean
/// on_authorize_authenticated_peer (GDBusAuthObserver *observer,
///                                  GIOStream         *stream,
///                                  GCredentials      *credentials,
///                                  gpointer           user_data)
/// {
///   gboolean authorized;
///
///   authorized = FALSE;
///   if (credentials != NULL)
///     {
///       GCredentials *own_credentials;
///       own_credentials = g_credentials_new ();
///       if (g_credentials_is_same_user (credentials, own_credentials, NULL))
///         authorized = TRUE;
///       g_object_unref (own_credentials);
///     }
///
///   return authorized;
/// }
/// ```
pub const DBusAuthObserver = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = DBusAuthObserver;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {
        /// Emitted to check if `mechanism` is allowed to be used.
        pub const allow_mechanism = struct {
            pub const name = "allow-mechanism";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_mechanism: [*:0]u8, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusAuthObserver, p_instance))),
                    gobject.signalLookup("allow-mechanism", DBusAuthObserver.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted to check if a peer that is successfully authenticated
        /// is authorized.
        pub const authorize_authenticated_peer = struct {
            pub const name = "authorize-authenticated-peer";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_stream: *gio.IOStream, p_credentials: ?*gio.Credentials, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusAuthObserver, p_instance))),
                    gobject.signalLookup("authorize-authenticated-peer", DBusAuthObserver.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gio.DBusAuthObserver` object.
    extern fn g_dbus_auth_observer_new() *gio.DBusAuthObserver;
    pub const new = g_dbus_auth_observer_new;

    /// Emits the `gio.DBusAuthObserver.signals.allow`-mechanism signal on `observer`.
    extern fn g_dbus_auth_observer_allow_mechanism(p_observer: *DBusAuthObserver, p_mechanism: [*:0]const u8) c_int;
    pub const allowMechanism = g_dbus_auth_observer_allow_mechanism;

    /// Emits the `gio.DBusAuthObserver.signals.authorize`-authenticated-peer signal on `observer`.
    extern fn g_dbus_auth_observer_authorize_authenticated_peer(p_observer: *DBusAuthObserver, p_stream: *gio.IOStream, p_credentials: ?*gio.Credentials) c_int;
    pub const authorizeAuthenticatedPeer = g_dbus_auth_observer_authorize_authenticated_peer;

    extern fn g_dbus_auth_observer_get_type() usize;
    pub const getGObjectType = g_dbus_auth_observer_get_type;

    extern fn g_object_ref(p_self: *gio.DBusAuthObserver) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusAuthObserver) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusAuthObserver, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `GDBusConnection` type is used for D-Bus connections to remote
/// peers such as a message buses.
///
/// It is a low-level API that offers a lot of flexibility. For instance,
/// it lets you establish a connection over any transport that can by represented
/// as a `gio.IOStream`.
///
/// This class is rarely used directly in D-Bus clients. If you are writing
/// a D-Bus client, it is often easier to use the `gio.busOwnName`,
/// `gio.busWatchName` or `gio.DBusProxy.newForBus` APIs.
///
/// As an exception to the usual GLib rule that a particular object must not
/// be used by two threads at the same time, `GDBusConnection`s methods may be
/// called from any thread. This is so that `gio.busGet` and
/// `gio.busGetSync` can safely return the same `GDBusConnection` when
/// called from any thread.
///
/// Most of the ways to obtain a `GDBusConnection` automatically initialize it
/// (i.e. connect to D-Bus): for instance, `gio.DBusConnection.new` and
/// `gio.busGet`, and the synchronous versions of those methods, give you
/// an initialized connection. Language bindings for GIO should use
/// `gio.Initable.new` or `gio.AsyncInitable.newAsync`, which also
/// initialize the connection.
///
/// If you construct an uninitialized `GDBusConnection`, such as via
/// `gobject.Object.new`, you must initialize it via `gio.Initable.init` or
/// `gio.AsyncInitable.initAsync` before using its methods or properties.
/// Calling methods or accessing properties on a `GDBusConnection` that has not
/// completed initialization successfully is considered to be invalid, and leads
/// to undefined behaviour. In particular, if initialization fails with a
/// `GError`, the only valid thing you can do with that `GDBusConnection` is to
/// free it with `gobject.Object.unref`.
///
/// ## An example D-Bus server
///
/// Here is an example for a D-Bus server:
/// [gdbus-example-server.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-server.c)
///
/// ## An example for exporting a subtree
///
/// Here is an example for exporting a subtree:
/// [gdbus-example-subtree.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-subtree.c)
///
/// ## An example for file descriptor passing
///
/// Here is an example for passing UNIX file descriptors:
/// [gdbus-unix-fd-client.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-unix-fd-client.c)
///
/// ## An example for exporting a GObject
///
/// Here is an example for exporting a `gobject.Object`:
/// [gdbus-example-export.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-export.c)
pub const DBusConnection = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gio.AsyncInitable, gio.Initable };
    pub const Class = opaque {
        pub const Instance = DBusConnection;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// A D-Bus address specifying potential endpoints that can be used
        /// when establishing the connection.
        pub const address = struct {
            pub const name = "address";

            pub const Type = ?[*:0]u8;
        };

        /// A `gio.DBusAuthObserver` object to assist in the authentication process or `NULL`.
        pub const authentication_observer = struct {
            pub const name = "authentication-observer";

            pub const Type = ?*gio.DBusAuthObserver;
        };

        /// Flags from the `gio.DBusCapabilityFlags` enumeration
        /// representing connection features negotiated with the other peer.
        pub const capabilities = struct {
            pub const name = "capabilities";

            pub const Type = gio.DBusCapabilityFlags;
        };

        /// A boolean specifying whether the connection has been closed.
        pub const closed = struct {
            pub const name = "closed";

            pub const Type = c_int;
        };

        /// A boolean specifying whether the process will be terminated (by
        /// calling `raise(SIGTERM)`) if the connection is closed by the
        /// remote peer.
        ///
        /// Note that `gio.DBusConnection` objects returned by `gio.busGetFinish`
        /// and `gio.busGetSync` will (usually) have this property set to `TRUE`.
        pub const exit_on_close = struct {
            pub const name = "exit-on-close";

            pub const Type = c_int;
        };

        /// Flags from the `gio.DBusConnectionFlags` enumeration.
        pub const flags = struct {
            pub const name = "flags";

            pub const Type = gio.DBusConnectionFlags;
        };

        /// The GUID of the peer performing the role of server when
        /// authenticating.
        ///
        /// If you are constructing a `gio.DBusConnection` and pass
        /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER` in the
        /// `gio.DBusConnection.properties.flags` property then you **must** also set this
        /// property to a valid guid.
        ///
        /// If you are constructing a `gio.DBusConnection` and pass
        /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT` in the
        /// `gio.DBusConnection.properties.flags` property you will be able to read the GUID
        /// of the other peer here after the connection has been successfully
        /// initialized.
        ///
        /// Note that the
        /// [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`)
        /// uses the term ‘UUID’ to refer to this, whereas GLib consistently uses the
        /// term ‘GUID’ for historical reasons.
        ///
        /// Despite its name, the format of `gio.DBusConnection.properties.guid` does not follow
        /// [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122) or the Microsoft
        /// GUID format.
        pub const guid = struct {
            pub const name = "guid";

            pub const Type = ?[*:0]u8;
        };

        /// The underlying `gio.IOStream` used for I/O.
        ///
        /// If this is passed on construction and is a `gio.SocketConnection`,
        /// then the corresponding `gio.Socket` will be put into non-blocking mode.
        ///
        /// While the `gio.DBusConnection` is active, it will interact with this
        /// stream from a worker thread, so it is not safe to interact with
        /// the stream directly.
        pub const stream = struct {
            pub const name = "stream";

            pub const Type = ?*gio.IOStream;
        };

        /// The unique name as assigned by the message bus or `NULL` if the
        /// connection is not open or not a message bus connection.
        pub const unique_name = struct {
            pub const name = "unique-name";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {
        /// Emitted when the connection is closed.
        ///
        /// The cause of this event can be
        ///
        /// - If `gio.DBusConnection.close` is called. In this case
        ///   `remote_peer_vanished` is set to `FALSE` and `error` is `NULL`.
        ///
        /// - If the remote peer closes the connection. In this case
        ///   `remote_peer_vanished` is set to `TRUE` and `error` is set.
        ///
        /// - If the remote peer sends invalid or malformed data. In this
        ///   case `remote_peer_vanished` is set to `FALSE` and `error` is set.
        ///
        /// Upon receiving this signal, you should give up your reference to
        /// `connection`. You are guaranteed that this signal is emitted only
        /// once.
        pub const closed = struct {
            pub const name = "closed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_remote_peer_vanished: c_int, p_error: ?*glib.Error, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusConnection, p_instance))),
                    gobject.signalLookup("closed", DBusConnection.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Asynchronously sets up a D-Bus connection for exchanging D-Bus messages
    /// with the end represented by `stream`.
    ///
    /// If `stream` is a `gio.SocketConnection`, then the corresponding `gio.Socket`
    /// will be put into non-blocking mode.
    ///
    /// The D-Bus connection will interact with `stream` from a worker thread.
    /// As a result, the caller should not interact with `stream` after this
    /// method has been called, except by calling `gobject.Object.unref` on it.
    ///
    /// If `observer` is not `NULL` it may be used to control the
    /// authentication process.
    ///
    /// When the operation is finished, `callback` will be invoked. You can
    /// then call `gio.DBusConnection.newFinish` to get the result of the
    /// operation.
    ///
    /// This is an asynchronous failable constructor. See
    /// `gio.DBusConnection.newSync` for the synchronous
    /// version.
    extern fn g_dbus_connection_new(p_stream: *gio.IOStream, p_guid: ?[*:0]const u8, p_flags: gio.DBusConnectionFlags, p_observer: ?*gio.DBusAuthObserver, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const new = g_dbus_connection_new;

    /// Asynchronously connects and sets up a D-Bus client connection for
    /// exchanging D-Bus messages with an endpoint specified by `address`
    /// which must be in the
    /// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`).
    ///
    /// This constructor can only be used to initiate client-side
    /// connections - use `gio.DBusConnection.new` if you need to act as the
    /// server. In particular, `flags` cannot contain the
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER`,
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS` or
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flags.
    ///
    /// When the operation is finished, `callback` will be invoked. You can
    /// then call `gio.DBusConnection.newForAddressFinish` to get the result of
    /// the operation.
    ///
    /// If `observer` is not `NULL` it may be used to control the
    /// authentication process.
    ///
    /// This is an asynchronous failable constructor. See
    /// `gio.DBusConnection.newForAddressSync` for the synchronous
    /// version.
    extern fn g_dbus_connection_new_for_address(p_address: [*:0]const u8, p_flags: gio.DBusConnectionFlags, p_observer: ?*gio.DBusAuthObserver, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const newForAddress = g_dbus_connection_new_for_address;

    /// Finishes an operation started with `gio.DBusConnection.new`.
    extern fn g_dbus_connection_new_finish(p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.DBusConnection;
    pub const newFinish = g_dbus_connection_new_finish;

    /// Finishes an operation started with `gio.DBusConnection.newForAddress`.
    extern fn g_dbus_connection_new_for_address_finish(p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.DBusConnection;
    pub const newForAddressFinish = g_dbus_connection_new_for_address_finish;

    /// Synchronously connects and sets up a D-Bus client connection for
    /// exchanging D-Bus messages with an endpoint specified by `address`
    /// which must be in the
    /// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`).
    ///
    /// This constructor can only be used to initiate client-side
    /// connections - use `gio.DBusConnection.newSync` if you need to act
    /// as the server. In particular, `flags` cannot contain the
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER`,
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS` or
    /// `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flags.
    ///
    /// This is a synchronous failable constructor. See
    /// `gio.DBusConnection.newForAddress` for the asynchronous version.
    ///
    /// If `observer` is not `NULL` it may be used to control the
    /// authentication process.
    extern fn g_dbus_connection_new_for_address_sync(p_address: [*:0]const u8, p_flags: gio.DBusConnectionFlags, p_observer: ?*gio.DBusAuthObserver, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.DBusConnection;
    pub const newForAddressSync = g_dbus_connection_new_for_address_sync;

    /// Synchronously sets up a D-Bus connection for exchanging D-Bus messages
    /// with the end represented by `stream`.
    ///
    /// If `stream` is a `gio.SocketConnection`, then the corresponding `gio.Socket`
    /// will be put into non-blocking mode.
    ///
    /// The D-Bus connection will interact with `stream` from a worker thread.
    /// As a result, the caller should not interact with `stream` after this
    /// method has been called, except by calling `gobject.Object.unref` on it.
    ///
    /// If `observer` is not `NULL` it may be used to control the
    /// authentication process.
    ///
    /// This is a synchronous failable constructor. See
    /// `gio.DBusConnection.new` for the asynchronous version.
    extern fn g_dbus_connection_new_sync(p_stream: *gio.IOStream, p_guid: ?[*:0]const u8, p_flags: gio.DBusConnectionFlags, p_observer: ?*gio.DBusAuthObserver, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.DBusConnection;
    pub const newSync = g_dbus_connection_new_sync;

    /// Adds a message filter. Filters are handlers that are run on all
    /// incoming and outgoing messages, prior to standard dispatch. Filters
    /// are run in the order that they were added.  The same handler can be
    /// added as a filter more than once, in which case it will be run more
    /// than once.  Filters added during a filter callback won't be run on
    /// the message being processed. Filter functions are allowed to modify
    /// and even drop messages.
    ///
    /// Note that filters are run in a dedicated message handling thread so
    /// they can't block and, generally, can't do anything but signal a
    /// worker thread. Also note that filters are rarely needed - use API
    /// such as `gio.DBusConnection.sendMessageWithReply`,
    /// `gio.DBusConnection.signalSubscribe` or `gio.DBusConnection.call` instead.
    ///
    /// If a filter consumes an incoming message the message is not
    /// dispatched anywhere else - not even the standard dispatch machinery
    /// (that API such as `gio.DBusConnection.signalSubscribe` and
    /// `gio.DBusConnection.sendMessageWithReply` relies on) will see the
    /// message. Similarly, if a filter consumes an outgoing message, the
    /// message will not be sent to the other peer.
    ///
    /// If `user_data_free_func` is non-`NULL`, it will be called (in the
    /// thread-default main context of the thread you are calling this
    /// method from) at some point after `user_data` is no longer
    /// needed. (It is not guaranteed to be called synchronously when the
    /// filter is removed, and may be called after `connection` has been
    /// destroyed.)
    extern fn g_dbus_connection_add_filter(p_connection: *DBusConnection, p_filter_function: gio.DBusMessageFilterFunction, p_user_data: ?*anyopaque, p_user_data_free_func: ?glib.DestroyNotify) c_uint;
    pub const addFilter = g_dbus_connection_add_filter;

    /// Asynchronously invokes the `method_name` method on the
    /// `interface_name` D-Bus interface on the remote object at
    /// `object_path` owned by `bus_name`.
    ///
    /// If `connection` is closed then the operation will fail with
    /// `G_IO_ERROR_CLOSED`. If `cancellable` is canceled, the operation will
    /// fail with `G_IO_ERROR_CANCELLED`. If `parameters` contains a value
    /// not compatible with the D-Bus protocol, the operation fails with
    /// `G_IO_ERROR_INVALID_ARGUMENT`.
    ///
    /// If `reply_type` is non-`NULL` then the reply will be checked for having this type and an
    /// error will be raised if it does not match.  Said another way, if you give a `reply_type`
    /// then any non-`NULL` return value will be of this type. Unless it’s
    /// `G_VARIANT_TYPE_UNIT`, the `reply_type` will be a tuple containing one or more
    /// values.
    ///
    /// If the `parameters` `glib.Variant` is floating, it is consumed. This allows
    /// convenient 'inline' use of `glib.Variant.new`, e.g.:
    /// ```
    ///  g_dbus_connection_call (connection,
    ///                          "org.freedesktop.StringThings",
    ///                          "/org/freedesktop/StringThings",
    ///                          "org.freedesktop.StringThings",
    ///                          "TwoStrings",
    ///                          g_variant_new ("(ss)",
    ///                                         "Thing One",
    ///                                         "Thing Two"),
    ///                          NULL,
    ///                          G_DBUS_CALL_FLAGS_NONE,
    ///                          -1,
    ///                          NULL,
    ///                          (GAsyncReadyCallback) two_strings_done,
    ///                          NULL);
    /// ```
    ///
    /// This is an asynchronous method. When the operation is finished,
    /// `callback` will be invoked in the thread-default main context
    /// (see `glib.MainContext.pushThreadDefault`)
    /// of the thread you are calling this method from. You can then call
    /// `gio.DBusConnection.callFinish` to get the result of the operation.
    /// See `gio.DBusConnection.callSync` for the synchronous version of this
    /// function.
    ///
    /// If `callback` is `NULL` then the D-Bus method call message will be sent with
    /// the `G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED` flag set.
    extern fn g_dbus_connection_call(p_connection: *DBusConnection, p_bus_name: ?[*:0]const u8, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8, p_method_name: [*:0]const u8, p_parameters: ?*glib.Variant, p_reply_type: ?*const glib.VariantType, p_flags: gio.DBusCallFlags, p_timeout_msec: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const call = g_dbus_connection_call;

    /// Finishes an operation started with `gio.DBusConnection.call`.
    extern fn g_dbus_connection_call_finish(p_connection: *DBusConnection, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.Variant;
    pub const callFinish = g_dbus_connection_call_finish;

    /// Synchronously invokes the `method_name` method on the
    /// `interface_name` D-Bus interface on the remote object at
    /// `object_path` owned by `bus_name`.
    ///
    /// If `connection` is closed then the operation will fail with
    /// `G_IO_ERROR_CLOSED`. If `cancellable` is canceled, the
    /// operation will fail with `G_IO_ERROR_CANCELLED`. If `parameters`
    /// contains a value not compatible with the D-Bus protocol, the operation
    /// fails with `G_IO_ERROR_INVALID_ARGUMENT`.
    ///
    /// If `reply_type` is non-`NULL` then the reply will be checked for having
    /// this type and an error will be raised if it does not match.  Said
    /// another way, if you give a `reply_type` then any non-`NULL` return
    /// value will be of this type.
    ///
    /// If the `parameters` `glib.Variant` is floating, it is consumed.
    /// This allows convenient 'inline' use of `glib.Variant.new`, e.g.:
    /// ```
    ///  g_dbus_connection_call_sync (connection,
    ///                               "org.freedesktop.StringThings",
    ///                               "/org/freedesktop/StringThings",
    ///                               "org.freedesktop.StringThings",
    ///                               "TwoStrings",
    ///                               g_variant_new ("(ss)",
    ///                                              "Thing One",
    ///                                              "Thing Two"),
    ///                               NULL,
    ///                               G_DBUS_CALL_FLAGS_NONE,
    ///                               -1,
    ///                               NULL,
    ///                               &error);
    /// ```
    ///
    /// The calling thread is blocked until a reply is received. See
    /// `gio.DBusConnection.call` for the asynchronous version of
    /// this method.
    extern fn g_dbus_connection_call_sync(p_connection: *DBusConnection, p_bus_name: ?[*:0]const u8, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8, p_method_name: [*:0]const u8, p_parameters: ?*glib.Variant, p_reply_type: ?*const glib.VariantType, p_flags: gio.DBusCallFlags, p_timeout_msec: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.Variant;
    pub const callSync = g_dbus_connection_call_sync;

    /// Like `gio.DBusConnection.call` but also takes a `gio.UnixFDList` object.
    ///
    /// The file descriptors normally correspond to `G_VARIANT_TYPE_HANDLE`
    /// values in the body of the message. For example, if a message contains
    /// two file descriptors, `fd_list` would have length 2, and
    /// `g_variant_new_handle (0)` and `g_variant_new_handle (1)` would appear
    /// somewhere in the body of the message (not necessarily in that order!)
    /// to represent the file descriptors at indexes 0 and 1 respectively.
    ///
    /// When designing D-Bus APIs that are intended to be interoperable,
    /// please note that non-GDBus implementations of D-Bus can usually only
    /// access file descriptors if they are referenced in this way by a
    /// value of type `G_VARIANT_TYPE_HANDLE` in the body of the message.
    ///
    /// This method is only available on UNIX.
    extern fn g_dbus_connection_call_with_unix_fd_list(p_connection: *DBusConnection, p_bus_name: ?[*:0]const u8, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8, p_method_name: [*:0]const u8, p_parameters: ?*glib.Variant, p_reply_type: ?*const glib.VariantType, p_flags: gio.DBusCallFlags, p_timeout_msec: c_int, p_fd_list: ?*gio.UnixFDList, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const callWithUnixFdList = g_dbus_connection_call_with_unix_fd_list;

    /// Finishes an operation started with `gio.DBusConnection.callWithUnixFdList`.
    ///
    /// The file descriptors normally correspond to `G_VARIANT_TYPE_HANDLE`
    /// values in the body of the message. For example,
    /// if `glib.Variant.getHandle` returns 5, that is intended to be a reference
    /// to the file descriptor that can be accessed by
    /// `g_unix_fd_list_get (*out_fd_list, 5, ...)`.
    ///
    /// When designing D-Bus APIs that are intended to be interoperable,
    /// please note that non-GDBus implementations of D-Bus can usually only
    /// access file descriptors if they are referenced in this way by a
    /// value of type `G_VARIANT_TYPE_HANDLE` in the body of the message.
    extern fn g_dbus_connection_call_with_unix_fd_list_finish(p_connection: *DBusConnection, p_out_fd_list: ?**gio.UnixFDList, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.Variant;
    pub const callWithUnixFdListFinish = g_dbus_connection_call_with_unix_fd_list_finish;

    /// Like `gio.DBusConnection.callSync` but also takes and returns `gio.UnixFDList` objects.
    /// See `gio.DBusConnection.callWithUnixFdList` and
    /// `gio.DBusConnection.callWithUnixFdListFinish` for more details.
    ///
    /// This method is only available on UNIX.
    extern fn g_dbus_connection_call_with_unix_fd_list_sync(p_connection: *DBusConnection, p_bus_name: ?[*:0]const u8, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8, p_method_name: [*:0]const u8, p_parameters: ?*glib.Variant, p_reply_type: ?*const glib.VariantType, p_flags: gio.DBusCallFlags, p_timeout_msec: c_int, p_fd_list: ?*gio.UnixFDList, p_out_fd_list: ?**gio.UnixFDList, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.Variant;
    pub const callWithUnixFdListSync = g_dbus_connection_call_with_unix_fd_list_sync;

    /// Closes `connection`. Note that this never causes the process to
    /// exit (this might only happen if the other end of a shared message
    /// bus connection disconnects, see `gio.DBusConnection.properties.exit`-on-close).
    ///
    /// Once the connection is closed, operations such as sending a message
    /// will return with the error `G_IO_ERROR_CLOSED`. Closing a connection
    /// will not automatically flush the connection so queued messages may
    /// be lost. Use `gio.DBusConnection.flush` if you need such guarantees.
    ///
    /// If `connection` is already closed, this method fails with
    /// `G_IO_ERROR_CLOSED`.
    ///
    /// When `connection` has been closed, the `gio.DBusConnection.signals.closed`
    /// signal is emitted in the thread-default main context
    /// (see `glib.MainContext.pushThreadDefault`)
    /// of the thread that `connection` was constructed in.
    ///
    /// This is an asynchronous method. When the operation is finished,
    /// `callback` will be invoked in the thread-default main context
    /// (see `glib.MainContext.pushThreadDefault`)
    /// of the thread you are calling this method from. You can
    /// then call `gio.DBusConnection.closeFinish` to get the result of the
    /// operation. See `gio.DBusConnection.closeSync` for the synchronous
    /// version.
    extern fn g_dbus_connection_close(p_connection: *DBusConnection, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const close = g_dbus_connection_close;

    /// Finishes an operation started with `gio.DBusConnection.close`.
    extern fn g_dbus_connection_close_finish(p_connection: *DBusConnection, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const closeFinish = g_dbus_connection_close_finish;

    /// Synchronously closes `connection`. The calling thread is blocked
    /// until this is done. See `gio.DBusConnection.close` for the
    /// asynchronous version of this method and more details about what it
    /// does.
    extern fn g_dbus_connection_close_sync(p_connection: *DBusConnection, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const closeSync = g_dbus_connection_close_sync;

    /// Emits a signal.
    ///
    /// If the parameters GVariant is floating, it is consumed.
    ///
    /// This can only fail if `parameters` is not compatible with the D-Bus protocol
    /// (`G_IO_ERROR_INVALID_ARGUMENT`), or if `connection` has been closed
    /// (`G_IO_ERROR_CLOSED`).
    extern fn g_dbus_connection_emit_signal(p_connection: *DBusConnection, p_destination_bus_name: ?[*:0]const u8, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8, p_signal_name: [*:0]const u8, p_parameters: ?*glib.Variant, p_error: ?*?*glib.Error) c_int;
    pub const emitSignal = g_dbus_connection_emit_signal;

    /// Exports `action_group` on `connection` at `object_path`.
    ///
    /// The implemented D-Bus API should be considered private.  It is
    /// subject to change in the future.
    ///
    /// A given object path can only have one action group exported on it.
    /// If this constraint is violated, the export will fail and 0 will be
    /// returned (with `error` set accordingly).
    ///
    /// You can unexport the action group using
    /// `gio.DBusConnection.unexportActionGroup` with the return value of
    /// this function.
    ///
    /// The thread default main context is taken at the time of this call.
    /// All incoming action activations and state change requests are
    /// reported from this context.  Any changes on the action group that
    /// cause it to emit signals must also come from this same context.
    /// Since incoming action activations and state change requests are
    /// rather likely to cause changes on the action group, this effectively
    /// limits a given action group to being exported from only one main
    /// context.
    extern fn g_dbus_connection_export_action_group(p_connection: *DBusConnection, p_object_path: [*:0]const u8, p_action_group: *gio.ActionGroup, p_error: ?*?*glib.Error) c_uint;
    pub const exportActionGroup = g_dbus_connection_export_action_group;

    /// Exports `menu` on `connection` at `object_path`.
    ///
    /// The implemented D-Bus API should be considered private.
    /// It is subject to change in the future.
    ///
    /// An object path can only have one menu model exported on it. If this
    /// constraint is violated, the export will fail and 0 will be
    /// returned (with `error` set accordingly).
    ///
    /// Exporting menus with sections containing more than
    /// `G_MENU_EXPORTER_MAX_SECTION_SIZE` items is not supported and results in
    /// undefined behavior.
    ///
    /// You can unexport the menu model using
    /// `gio.DBusConnection.unexportMenuModel` with the return value of
    /// this function.
    extern fn g_dbus_connection_export_menu_model(p_connection: *DBusConnection, p_object_path: [*:0]const u8, p_menu: *gio.MenuModel, p_error: ?*?*glib.Error) c_uint;
    pub const exportMenuModel = g_dbus_connection_export_menu_model;

    /// Asynchronously flushes `connection`, that is, writes all queued
    /// outgoing messages to the transport and then flushes the transport
    /// (using `gio.OutputStream.flushAsync`). This is useful in programs
    /// that want to emit a D-Bus signal and then exit immediately. Without
    /// flushing the connection, there is no guarantee that the message has
    /// been sent to the networking buffers in the OS kernel.
    ///
    /// This is an asynchronous method. When the operation is finished,
    /// `callback` will be invoked in the thread-default main context
    /// (see `glib.MainContext.pushThreadDefault`)
    /// of the thread you are calling this method from. You can
    /// then call `gio.DBusConnection.flushFinish` to get the result of the
    /// operation. See `gio.DBusConnection.flushSync` for the synchronous
    /// version.
    extern fn g_dbus_connection_flush(p_connection: *DBusConnection, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const flush = g_dbus_connection_flush;

    /// Finishes an operation started with `gio.DBusConnection.flush`.
    extern fn g_dbus_connection_flush_finish(p_connection: *DBusConnection, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const flushFinish = g_dbus_connection_flush_finish;

    /// Synchronously flushes `connection`. The calling thread is blocked
    /// until this is done. See `gio.DBusConnection.flush` for the
    /// asynchronous version of this method and more details about what it
    /// does.
    extern fn g_dbus_connection_flush_sync(p_connection: *DBusConnection, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const flushSync = g_dbus_connection_flush_sync;

    /// Gets the capabilities negotiated with the remote peer
    extern fn g_dbus_connection_get_capabilities(p_connection: *DBusConnection) gio.DBusCapabilityFlags;
    pub const getCapabilities = g_dbus_connection_get_capabilities;

    /// Gets whether the process is terminated when `connection` is
    /// closed by the remote peer. See
    /// `gio.DBusConnection.properties.exit`-on-close for more details.
    extern fn g_dbus_connection_get_exit_on_close(p_connection: *DBusConnection) c_int;
    pub const getExitOnClose = g_dbus_connection_get_exit_on_close;

    /// Gets the flags used to construct this connection
    extern fn g_dbus_connection_get_flags(p_connection: *DBusConnection) gio.DBusConnectionFlags;
    pub const getFlags = g_dbus_connection_get_flags;

    /// The GUID of the peer performing the role of server when
    /// authenticating. See `gio.DBusConnection.properties.guid` for more details.
    extern fn g_dbus_connection_get_guid(p_connection: *DBusConnection) [*:0]const u8;
    pub const getGuid = g_dbus_connection_get_guid;

    /// Retrieves the last serial number assigned to a `gio.DBusMessage` on
    /// the current thread. This includes messages sent via both low-level
    /// API such as `gio.DBusConnection.sendMessage` as well as
    /// high-level API such as `gio.DBusConnection.emitSignal`,
    /// `gio.DBusConnection.call` or `gio.DBusProxy.call`.
    extern fn g_dbus_connection_get_last_serial(p_connection: *DBusConnection) u32;
    pub const getLastSerial = g_dbus_connection_get_last_serial;

    /// Gets the credentials of the authenticated peer. This will always
    /// return `NULL` unless `connection` acted as a server
    /// (e.g. `G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER` was passed)
    /// when set up and the client passed credentials as part of the
    /// authentication process.
    ///
    /// In a message bus setup, the message bus is always the server and
    /// each application is a client. So this method will always return
    /// `NULL` for message bus clients.
    extern fn g_dbus_connection_get_peer_credentials(p_connection: *DBusConnection) ?*gio.Credentials;
    pub const getPeerCredentials = g_dbus_connection_get_peer_credentials;

    /// Gets the underlying stream used for IO.
    ///
    /// While the `gio.DBusConnection` is active, it will interact with this
    /// stream from a worker thread, so it is not safe to interact with
    /// the stream directly.
    extern fn g_dbus_connection_get_stream(p_connection: *DBusConnection) *gio.IOStream;
    pub const getStream = g_dbus_connection_get_stream;

    /// Gets the unique name of `connection` as assigned by the message
    /// bus. This can also be used to figure out if `connection` is a
    /// message bus connection.
    extern fn g_dbus_connection_get_unique_name(p_connection: *DBusConnection) ?[*:0]const u8;
    pub const getUniqueName = g_dbus_connection_get_unique_name;

    /// Gets whether `connection` is closed.
    extern fn g_dbus_connection_is_closed(p_connection: *DBusConnection) c_int;
    pub const isClosed = g_dbus_connection_is_closed;

    /// Registers callbacks for exported objects at `object_path` with the
    /// D-Bus interface that is described in `interface_info`.
    ///
    /// Calls to functions in `vtable` (and `user_data_free_func`) will happen
    /// in the thread-default main context
    /// (see `glib.MainContext.pushThreadDefault`)
    /// of the thread you are calling this method from.
    ///
    /// Note that all `glib.Variant` values passed to functions in `vtable` will match
    /// the signature given in `interface_info` - if a remote caller passes
    /// incorrect values, the `org.freedesktop.DBus.Error.InvalidArgs`
    /// is returned to the remote caller.
    ///
    /// Additionally, if the remote caller attempts to invoke methods or
    /// access properties not mentioned in `interface_info` the
    /// `org.freedesktop.DBus.Error.UnknownMethod` resp.
    /// `org.freedesktop.DBus.Error.InvalidArgs` errors
    /// are returned to the caller.
    ///
    /// It is considered a programming error if the
    /// `gio.DBusInterfaceGetPropertyFunc` function in `vtable` returns a
    /// `glib.Variant` of incorrect type.
    ///
    /// If an existing callback is already registered at `object_path` and
    /// `interface_name`, then `error` is set to `G_IO_ERROR_EXISTS`.
    ///
    /// GDBus automatically implements the standard D-Bus interfaces
    /// org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable
    /// and org.freedesktop.Peer, so you don't have to implement those for the
    /// objects you export. You can implement org.freedesktop.DBus.Properties
    /// yourself, e.g. to handle getting and setting of properties asynchronously.
    ///
    /// Note that the reference count on `interface_info` will be
    /// incremented by 1 (unless allocated statically, e.g. if the
    /// reference count is -1, see `gio.DBusInterfaceInfo.ref`) for as long
    /// as the object is exported. Also note that `vtable` will be copied.
    ///
    /// See this [server]`gio.@"DBusConnection#an-example-d-bus-server"`
    /// for an example of how to use this method.
    extern fn g_dbus_connection_register_object(p_connection: *DBusConnection, p_object_path: [*:0]const u8, p_interface_info: *gio.DBusInterfaceInfo, p_vtable: ?*const gio.DBusInterfaceVTable, p_user_data: ?*anyopaque, p_user_data_free_func: glib.DestroyNotify, p_error: ?*?*glib.Error) c_uint;
    pub const registerObject = g_dbus_connection_register_object;

    /// Version of `gio.DBusConnection.registerObject` using closures instead of a
    /// `gio.DBusInterfaceVTable` for easier binding in other languages.
    ///
    /// Note that the reference counting semantics of the function wrapped by
    /// `method_call_closure` are the same as those of
    /// `gio.DBusInterfaceMethodCallFunc`: ownership of a reference to the
    /// `gio.DBusMethodInvocation` is transferred to the function.
    extern fn g_dbus_connection_register_object_with_closures(p_connection: *DBusConnection, p_object_path: [*:0]const u8, p_interface_info: *gio.DBusInterfaceInfo, p_method_call_closure: ?*gobject.Closure, p_get_property_closure: ?*gobject.Closure, p_set_property_closure: ?*gobject.Closure, p_error: ?*?*glib.Error) c_uint;
    pub const registerObjectWithClosures = g_dbus_connection_register_object_with_closures;

    /// Version of `gio.DBusConnection.registerObject` using closures instead
    /// of a `gio.DBusInterfaceVTable` for easier binding in other languages.
    ///
    /// In contrast to `gio.DBusConnection.registerObject` and
    /// `gio.DBusConnection.registerObjectWithClosures`, the reference
    /// counting semantics of the function wrapped by `method_call_closure` are *not*
    /// the same as those of `gio.DBusInterfaceMethodCallFunc`. Ownership of
    /// a reference to the `gio.DBusMethodInvocation` is *not* transferred to
    /// the function. Bindings must ensure that they add a reference to the
    /// `gio.DBusMethodInvocation` before calling any
    /// `g_dbus_method_invocation_return_*()` methods on it. This should be automatic
    /// as a result of the introspection annotations on those methods.
    extern fn g_dbus_connection_register_object_with_closures2(p_connection: *DBusConnection, p_object_path: [*:0]const u8, p_interface_info: *gio.DBusInterfaceInfo, p_method_call_closure: ?*gobject.Closure, p_get_property_closure: ?*gobject.Closure, p_set_property_closure: ?*gobject.Closure, p_error: ?*?*glib.Error) c_uint;
    pub const registerObjectWithClosures2 = g_dbus_connection_register_object_with_closures2;

    /// Registers a whole subtree of dynamic objects.
    ///
    /// The `enumerate` and `introspection` functions in `vtable` are used to
    /// convey, to remote callers, what nodes exist in the subtree rooted
    /// by `object_path`.
    ///
    /// When handling remote calls into any node in the subtree, first the
    /// `enumerate` function is used to check if the node exists. If the node exists
    /// or the `G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES` flag is set
    /// the `introspection` function is used to check if the node supports the
    /// requested method. If so, the `dispatch` function is used to determine
    /// where to dispatch the call. The collected `gio.DBusInterfaceVTable` and
    /// `gpointer` will be used to call into the interface vtable for processing
    /// the request.
    ///
    /// All calls into user-provided code will be invoked in the thread-default
    /// main context (see `glib.MainContext.pushThreadDefault`)
    /// of the thread you are calling this method from.
    ///
    /// If an existing subtree is already registered at `object_path` or
    /// then `error` is set to `G_IO_ERROR_EXISTS`.
    ///
    /// Note that it is valid to register regular objects (using
    /// `gio.DBusConnection.registerObject`) in a subtree registered with
    /// `gio.DBusConnection.registerSubtree` - if so, the subtree handler
    /// is tried as the last resort. One way to think about a subtree
    /// handler is to consider it a fallback handler for object paths not
    /// registered via `gio.DBusConnection.registerObject` or other bindings.
    ///
    /// Note that `vtable` will be copied so you cannot change it after
    /// registration.
    ///
    /// See this [server]`gio.@"DBusConnection#an-example-for-exporting-a-subtree"`
    /// for an example of how to use this method.
    extern fn g_dbus_connection_register_subtree(p_connection: *DBusConnection, p_object_path: [*:0]const u8, p_vtable: *const gio.DBusSubtreeVTable, p_flags: gio.DBusSubtreeFlags, p_user_data: ?*anyopaque, p_user_data_free_func: glib.DestroyNotify, p_error: ?*?*glib.Error) c_uint;
    pub const registerSubtree = g_dbus_connection_register_subtree;

    /// Removes a filter.
    ///
    /// Note that since filters run in a different thread, there is a race
    /// condition where it is possible that the filter will be running even
    /// after calling `gio.DBusConnection.removeFilter`, so you cannot just
    /// free data that the filter might be using. Instead, you should pass
    /// a `glib.DestroyNotify` to `gio.DBusConnection.addFilter`, which will be
    /// called when it is guaranteed that the data is no longer needed.
    extern fn g_dbus_connection_remove_filter(p_connection: *DBusConnection, p_filter_id: c_uint) void;
    pub const removeFilter = g_dbus_connection_remove_filter;

    /// Asynchronously sends `message` to the peer represented by `connection`.
    ///
    /// Unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag, the serial number
    /// will be assigned by `connection` and set on `message` via
    /// `gio.DBusMessage.setSerial`. If `out_serial` is not `NULL`, then the
    /// serial number used will be written to this location prior to
    /// submitting the message to the underlying transport. While it has a `volatile`
    /// qualifier, this is a historical artifact and the argument passed to it should
    /// not be `volatile`.
    ///
    /// If `connection` is closed then the operation will fail with
    /// `G_IO_ERROR_CLOSED`. If `message` is not well-formed,
    /// the operation fails with `G_IO_ERROR_INVALID_ARGUMENT`.
    ///
    /// See this [server]`gio.@"DBusConnection#an-example-d-bus-server"`
    /// and [client]`gio.@"DBusConnection#an-example-for-file-descriptor-passing"`
    /// for an example of how to use this low-level API to send and receive
    /// UNIX file descriptors.
    ///
    /// Note that `message` must be unlocked, unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag.
    extern fn g_dbus_connection_send_message(p_connection: *DBusConnection, p_message: *gio.DBusMessage, p_flags: gio.DBusSendMessageFlags, p_out_serial: ?*u32, p_error: ?*?*glib.Error) c_int;
    pub const sendMessage = g_dbus_connection_send_message;

    /// Asynchronously sends `message` to the peer represented by `connection`.
    ///
    /// Unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag, the serial number
    /// will be assigned by `connection` and set on `message` via
    /// `gio.DBusMessage.setSerial`. If `out_serial` is not `NULL`, then the
    /// serial number used will be written to this location prior to
    /// submitting the message to the underlying transport. While it has a `volatile`
    /// qualifier, this is a historical artifact and the argument passed to it should
    /// not be `volatile`.
    ///
    /// If `connection` is closed then the operation will fail with
    /// `G_IO_ERROR_CLOSED`. If `cancellable` is canceled, the operation will
    /// fail with `G_IO_ERROR_CANCELLED`. If `message` is not well-formed,
    /// the operation fails with `G_IO_ERROR_INVALID_ARGUMENT`.
    ///
    /// This is an asynchronous method. When the operation is finished, `callback`
    /// will be invoked in the thread-default main context
    /// (see `glib.MainContext.pushThreadDefault`)
    /// of the thread you are calling this method from. You can then call
    /// `gio.DBusConnection.sendMessageWithReplyFinish` to get the result of the operation.
    /// See `gio.DBusConnection.sendMessageWithReplySync` for the synchronous version.
    ///
    /// Note that `message` must be unlocked, unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag.
    ///
    /// See this [server]`gio.@"DBusConnection#an-example-d-bus-server"`
    /// and [client]`gio.@"DBusConnection#an-example-for-file-descriptor-passing"`
    /// for an example of how to use this low-level API to send and receive
    /// UNIX file descriptors.
    extern fn g_dbus_connection_send_message_with_reply(p_connection: *DBusConnection, p_message: *gio.DBusMessage, p_flags: gio.DBusSendMessageFlags, p_timeout_msec: c_int, p_out_serial: ?*u32, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const sendMessageWithReply = g_dbus_connection_send_message_with_reply;

    /// Finishes an operation started with `gio.DBusConnection.sendMessageWithReply`.
    ///
    /// Note that `error` is only set if a local in-process error
    /// occurred. That is to say that the returned `gio.DBusMessage` object may
    /// be of type `G_DBUS_MESSAGE_TYPE_ERROR`. Use
    /// `gio.DBusMessage.toGerror` to transcode this to a `glib.Error`.
    ///
    /// See this [server]`gio.@"DBusConnection#an-example-d-bus-server"`
    /// and [client]`gio.@"DBusConnection#an-example-for-file-descriptor-passing"`
    /// for an example of how to use this low-level API to send and receive
    /// UNIX file descriptors.
    extern fn g_dbus_connection_send_message_with_reply_finish(p_connection: *DBusConnection, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.DBusMessage;
    pub const sendMessageWithReplyFinish = g_dbus_connection_send_message_with_reply_finish;

    /// Synchronously sends `message` to the peer represented by `connection`
    /// and blocks the calling thread until a reply is received or the
    /// timeout is reached. See `gio.DBusConnection.sendMessageWithReply`
    /// for the asynchronous version of this method.
    ///
    /// Unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag, the serial number
    /// will be assigned by `connection` and set on `message` via
    /// `gio.DBusMessage.setSerial`. If `out_serial` is not `NULL`, then the
    /// serial number used will be written to this location prior to
    /// submitting the message to the underlying transport. While it has a `volatile`
    /// qualifier, this is a historical artifact and the argument passed to it should
    /// not be `volatile`.
    ///
    /// If `connection` is closed then the operation will fail with
    /// `G_IO_ERROR_CLOSED`. If `cancellable` is canceled, the operation will
    /// fail with `G_IO_ERROR_CANCELLED`. If `message` is not well-formed,
    /// the operation fails with `G_IO_ERROR_INVALID_ARGUMENT`.
    ///
    /// Note that `error` is only set if a local in-process error
    /// occurred. That is to say that the returned `gio.DBusMessage` object may
    /// be of type `G_DBUS_MESSAGE_TYPE_ERROR`. Use
    /// `gio.DBusMessage.toGerror` to transcode this to a `glib.Error`.
    ///
    /// See this [server]`gio.@"DBusConnection#an-example-d-bus-server"`
    /// and [client]`gio.@"DBusConnection#an-example-for-file-descriptor-passing"`
    /// for an example of how to use this low-level API to send and receive
    /// UNIX file descriptors.
    ///
    /// Note that `message` must be unlocked, unless `flags` contain the
    /// `G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL` flag.
    extern fn g_dbus_connection_send_message_with_reply_sync(p_connection: *DBusConnection, p_message: *gio.DBusMessage, p_flags: gio.DBusSendMessageFlags, p_timeout_msec: c_int, p_out_serial: ?*u32, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.DBusMessage;
    pub const sendMessageWithReplySync = g_dbus_connection_send_message_with_reply_sync;

    /// Sets whether the process should be terminated when `connection` is
    /// closed by the remote peer. See `gio.DBusConnection.properties.exit`-on-close for
    /// more details.
    ///
    /// Note that this function should be used with care. Most modern UNIX
    /// desktops tie the notion of a user session with the session bus, and expect
    /// all of a user's applications to quit when their bus connection goes away.
    /// If you are setting `exit_on_close` to `FALSE` for the shared session
    /// bus connection, you should make sure that your application exits
    /// when the user session ends.
    extern fn g_dbus_connection_set_exit_on_close(p_connection: *DBusConnection, p_exit_on_close: c_int) void;
    pub const setExitOnClose = g_dbus_connection_set_exit_on_close;

    /// Subscribes to signals on `connection` and invokes `callback` whenever
    /// the signal is received. Note that `callback` will be invoked in the
    /// thread-default main context (see `glib.MainContext.pushThreadDefault`)
    /// of the thread you are calling this method from.
    ///
    /// If `connection` is not a message bus connection, `sender` must be
    /// `NULL`.
    ///
    /// If `sender` is a well-known name note that `callback` is invoked with
    /// the unique name for the owner of `sender`, not the well-known name
    /// as one would expect. This is because the message bus rewrites the
    /// name. As such, to avoid certain race conditions, users should be
    /// tracking the name owner of the well-known name and use that when
    /// processing the received signal.
    ///
    /// If one of `G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE` or
    /// `G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH` are given, `arg0` is
    /// interpreted as part of a namespace or path.  The first argument
    /// of a signal is matched against that part as specified by D-Bus.
    ///
    /// If `user_data_free_func` is non-`NULL`, it will be called (in the
    /// thread-default main context of the thread you are calling this
    /// method from) at some point after `user_data` is no longer
    /// needed. (It is not guaranteed to be called synchronously when the
    /// signal is unsubscribed from, and may be called after `connection`
    /// has been destroyed.)
    ///
    /// As `callback` is potentially invoked in a different thread from where it’s
    /// emitted, it’s possible for this to happen after
    /// `gio.DBusConnection.signalUnsubscribe` has been called in another thread.
    /// Due to this, `user_data` should have a strong reference which is freed with
    /// `user_data_free_func`, rather than pointing to data whose lifecycle is tied
    /// to the signal subscription. For example, if a `gobject.Object` is used to store the
    /// subscription ID from `gio.DBusConnection.signalSubscribe`, a strong reference
    /// to that `gobject.Object` must be passed to `user_data`, and `gobject.Object.unref` passed to
    /// `user_data_free_func`. You are responsible for breaking the resulting
    /// reference count cycle by explicitly unsubscribing from the signal when
    /// dropping the last external reference to the `gobject.Object`. Alternatively, a weak
    /// reference may be used.
    ///
    /// It is guaranteed that if you unsubscribe from a signal using
    /// `gio.DBusConnection.signalUnsubscribe` from the same thread which made the
    /// corresponding `gio.DBusConnection.signalSubscribe` call, `callback` will not
    /// be invoked after `gio.DBusConnection.signalUnsubscribe` returns.
    ///
    /// The returned subscription identifier is an opaque value which is guaranteed
    /// to never be zero.
    ///
    /// This function can never fail.
    extern fn g_dbus_connection_signal_subscribe(p_connection: *DBusConnection, p_sender: ?[*:0]const u8, p_interface_name: ?[*:0]const u8, p_member: ?[*:0]const u8, p_object_path: ?[*:0]const u8, p_arg0: ?[*:0]const u8, p_flags: gio.DBusSignalFlags, p_callback: gio.DBusSignalCallback, p_user_data: ?*anyopaque, p_user_data_free_func: ?glib.DestroyNotify) c_uint;
    pub const signalSubscribe = g_dbus_connection_signal_subscribe;

    /// Unsubscribes from signals.
    ///
    /// Note that there may still be D-Bus traffic to process (relating to this
    /// signal subscription) in the current thread-default `glib.MainContext` after this
    /// function has returned. You should continue to iterate the `glib.MainContext`
    /// until the `glib.DestroyNotify` function passed to
    /// `gio.DBusConnection.signalSubscribe` is called, in order to avoid memory
    /// leaks through callbacks queued on the `glib.MainContext` after it’s stopped being
    /// iterated.
    /// Alternatively, any idle source with a priority lower than `G_PRIORITY_DEFAULT`
    /// that was scheduled after unsubscription, also indicates that all resources
    /// of this subscription are released.
    extern fn g_dbus_connection_signal_unsubscribe(p_connection: *DBusConnection, p_subscription_id: c_uint) void;
    pub const signalUnsubscribe = g_dbus_connection_signal_unsubscribe;

    /// If `connection` was created with
    /// `G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING`, this method
    /// starts processing messages. Does nothing on if `connection` wasn't
    /// created with this flag or if the method has already been called.
    extern fn g_dbus_connection_start_message_processing(p_connection: *DBusConnection) void;
    pub const startMessageProcessing = g_dbus_connection_start_message_processing;

    /// Reverses the effect of a previous call to
    /// `gio.DBusConnection.exportActionGroup`.
    ///
    /// It is an error to call this function with an ID that wasn’t returned from
    /// `gio.DBusConnection.exportActionGroup` or to call it with the same
    /// ID more than once.
    extern fn g_dbus_connection_unexport_action_group(p_connection: *DBusConnection, p_export_id: c_uint) void;
    pub const unexportActionGroup = g_dbus_connection_unexport_action_group;

    /// Reverses the effect of a previous call to
    /// `gio.DBusConnection.exportMenuModel`.
    ///
    /// It is an error to call this function with an ID that wasn't returned
    /// from `gio.DBusConnection.exportMenuModel` or to call it with the
    /// same ID more than once.
    extern fn g_dbus_connection_unexport_menu_model(p_connection: *DBusConnection, p_export_id: c_uint) void;
    pub const unexportMenuModel = g_dbus_connection_unexport_menu_model;

    /// Unregisters an object.
    extern fn g_dbus_connection_unregister_object(p_connection: *DBusConnection, p_registration_id: c_uint) c_int;
    pub const unregisterObject = g_dbus_connection_unregister_object;

    /// Unregisters a subtree.
    extern fn g_dbus_connection_unregister_subtree(p_connection: *DBusConnection, p_registration_id: c_uint) c_int;
    pub const unregisterSubtree = g_dbus_connection_unregister_subtree;

    extern fn g_dbus_connection_get_type() usize;
    pub const getGObjectType = g_dbus_connection_get_type;

    extern fn g_object_ref(p_self: *gio.DBusConnection) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusConnection) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusConnection, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Abstract base class for D-Bus interfaces on the service side.
pub const DBusInterfaceSkeleton = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.DBusInterface};
    pub const Class = gio.DBusInterfaceSkeletonClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.DBusInterfaceSkeletonPrivate,

    pub const virtual_methods = struct {
        /// If `interface_` has outstanding changes, request for these changes to be
        /// emitted immediately.
        ///
        /// For example, an exported D-Bus interface may queue up property
        /// changes and emit the
        /// `org.freedesktop.DBus.Properties.PropertiesChanged`
        /// signal later (e.g. in an idle handler). This technique is useful
        /// for collapsing multiple property changes into one.
        pub const flush = struct {
            pub fn call(p_class: anytype, p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(DBusInterfaceSkeleton.Class, p_class).f_flush.?(gobject.ext.as(DBusInterfaceSkeleton, p_interface_));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(DBusInterfaceSkeleton.Class, p_class).f_flush = @ptrCast(p_implementation);
            }
        };

        /// Signal class handler for the `gio.DBusInterfaceSkeleton.signals.g`-authorize-method signal.
        pub const g_authorize_method = struct {
            pub fn call(p_class: anytype, p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_invocation: *gio.DBusMethodInvocation) c_int {
                return gobject.ext.as(DBusInterfaceSkeleton.Class, p_class).f_g_authorize_method.?(gobject.ext.as(DBusInterfaceSkeleton, p_interface_), p_invocation);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_invocation: *gio.DBusMethodInvocation) callconv(.c) c_int) void {
                gobject.ext.as(DBusInterfaceSkeleton.Class, p_class).f_g_authorize_method = @ptrCast(p_implementation);
            }
        };

        /// Gets D-Bus introspection information for the D-Bus interface
        /// implemented by `interface_`.
        pub const get_info = struct {
            pub fn call(p_class: anytype, p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.DBusInterfaceInfo {
                return gobject.ext.as(DBusInterfaceSkeleton.Class, p_class).f_get_info.?(gobject.ext.as(DBusInterfaceSkeleton, p_interface_));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.DBusInterfaceInfo) void {
                gobject.ext.as(DBusInterfaceSkeleton.Class, p_class).f_get_info = @ptrCast(p_implementation);
            }
        };

        /// Gets all D-Bus properties for `interface_`.
        pub const get_properties = struct {
            pub fn call(p_class: anytype, p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *glib.Variant {
                return gobject.ext.as(DBusInterfaceSkeleton.Class, p_class).f_get_properties.?(gobject.ext.as(DBusInterfaceSkeleton, p_interface_));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *glib.Variant) void {
                gobject.ext.as(DBusInterfaceSkeleton.Class, p_class).f_get_properties = @ptrCast(p_implementation);
            }
        };

        /// Gets the interface vtable for the D-Bus interface implemented by
        /// `interface_`. The returned function pointers should expect `interface_`
        /// itself to be passed as `user_data`.
        pub const get_vtable = struct {
            pub fn call(p_class: anytype, p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.DBusInterfaceVTable {
                return gobject.ext.as(DBusInterfaceSkeleton.Class, p_class).f_get_vtable.?(gobject.ext.as(DBusInterfaceSkeleton, p_interface_));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.DBusInterfaceVTable) void {
                gobject.ext.as(DBusInterfaceSkeleton.Class, p_class).f_get_vtable = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Flags from the `gio.DBusInterfaceSkeletonFlags` enumeration.
        pub const g_flags = struct {
            pub const name = "g-flags";

            pub const Type = gio.DBusInterfaceSkeletonFlags;
        };
    };

    pub const signals = struct {
        /// Emitted when a method is invoked by a remote caller and used to
        /// determine if the method call is authorized.
        ///
        /// Note that this signal is emitted in a thread dedicated to
        /// handling the method call so handlers are allowed to perform
        /// blocking IO. This means that it is appropriate to call e.g.
        /// [`polkit_authority_check_authorization_sync`](http://hal.freedesktop.org/docs/polkit/PolkitAuthority.html`polkit`-authority-check-authorization-sync)
        /// with the
        /// [POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION](http://hal.freedesktop.org/docs/polkit/PolkitAuthority.html`POLKIT`-CHECK-AUTHORIZATION-FLAGS-ALLOW-USER-INTERACTION:CAPS)
        /// flag set.
        ///
        /// If `FALSE` is returned then no further handlers are run and the
        /// signal handler must take a reference to `invocation` and finish
        /// handling the call (e.g. return an error via
        /// `gio.DBusMethodInvocation.returnError`).
        ///
        /// Otherwise, if `TRUE` is returned, signal emission continues. If no
        /// handlers return `FALSE`, then the method is dispatched. If
        /// `interface` has an enclosing `gio.DBusObjectSkeleton`, then the
        /// `gio.DBusObjectSkeleton.signals.authorize`-method signal handlers run before
        /// the handlers for this signal.
        ///
        /// The default class handler just returns `TRUE`.
        ///
        /// Please note that the common case is optimized: if no signals
        /// handlers are connected and the default class handler isn't
        /// overridden (for both `interface` and the enclosing
        /// `gio.DBusObjectSkeleton`, if any) and `gio.DBusInterfaceSkeleton.properties.g`-flags does
        /// not have the
        /// `G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD`
        /// flags set, no dedicated thread is ever used and the call will be
        /// handled in the same thread as the object that `interface` belongs
        /// to was exported in.
        pub const g_authorize_method = struct {
            pub const name = "g-authorize-method";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_invocation: *gio.DBusMethodInvocation, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusInterfaceSkeleton, p_instance))),
                    gobject.signalLookup("g-authorize-method", DBusInterfaceSkeleton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Exports `interface_` at `object_path` on `connection`.
    ///
    /// This can be called multiple times to export the same `interface_`
    /// onto multiple connections however the `object_path` provided must be
    /// the same for all connections.
    ///
    /// Use `gio.DBusInterfaceSkeleton.unexport` to unexport the object.
    extern fn g_dbus_interface_skeleton_export(p_interface_: *DBusInterfaceSkeleton, p_connection: *gio.DBusConnection, p_object_path: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const @"export" = g_dbus_interface_skeleton_export;

    /// If `interface_` has outstanding changes, request for these changes to be
    /// emitted immediately.
    ///
    /// For example, an exported D-Bus interface may queue up property
    /// changes and emit the
    /// `org.freedesktop.DBus.Properties.PropertiesChanged`
    /// signal later (e.g. in an idle handler). This technique is useful
    /// for collapsing multiple property changes into one.
    extern fn g_dbus_interface_skeleton_flush(p_interface_: *DBusInterfaceSkeleton) void;
    pub const flush = g_dbus_interface_skeleton_flush;

    /// Gets the first connection that `interface_` is exported on, if any.
    extern fn g_dbus_interface_skeleton_get_connection(p_interface_: *DBusInterfaceSkeleton) ?*gio.DBusConnection;
    pub const getConnection = g_dbus_interface_skeleton_get_connection;

    /// Gets a list of the connections that `interface_` is exported on.
    extern fn g_dbus_interface_skeleton_get_connections(p_interface_: *DBusInterfaceSkeleton) *glib.List;
    pub const getConnections = g_dbus_interface_skeleton_get_connections;

    /// Gets the `gio.DBusInterfaceSkeletonFlags` that describes what the behavior
    /// of `interface_`
    extern fn g_dbus_interface_skeleton_get_flags(p_interface_: *DBusInterfaceSkeleton) gio.DBusInterfaceSkeletonFlags;
    pub const getFlags = g_dbus_interface_skeleton_get_flags;

    /// Gets D-Bus introspection information for the D-Bus interface
    /// implemented by `interface_`.
    extern fn g_dbus_interface_skeleton_get_info(p_interface_: *DBusInterfaceSkeleton) *gio.DBusInterfaceInfo;
    pub const getInfo = g_dbus_interface_skeleton_get_info;

    /// Gets the object path that `interface_` is exported on, if any.
    extern fn g_dbus_interface_skeleton_get_object_path(p_interface_: *DBusInterfaceSkeleton) ?[*:0]const u8;
    pub const getObjectPath = g_dbus_interface_skeleton_get_object_path;

    /// Gets all D-Bus properties for `interface_`.
    extern fn g_dbus_interface_skeleton_get_properties(p_interface_: *DBusInterfaceSkeleton) *glib.Variant;
    pub const getProperties = g_dbus_interface_skeleton_get_properties;

    /// Gets the interface vtable for the D-Bus interface implemented by
    /// `interface_`. The returned function pointers should expect `interface_`
    /// itself to be passed as `user_data`.
    extern fn g_dbus_interface_skeleton_get_vtable(p_interface_: *DBusInterfaceSkeleton) *gio.DBusInterfaceVTable;
    pub const getVtable = g_dbus_interface_skeleton_get_vtable;

    /// Checks if `interface_` is exported on `connection`.
    extern fn g_dbus_interface_skeleton_has_connection(p_interface_: *DBusInterfaceSkeleton, p_connection: *gio.DBusConnection) c_int;
    pub const hasConnection = g_dbus_interface_skeleton_has_connection;

    /// Sets flags describing what the behavior of `skeleton` should be.
    extern fn g_dbus_interface_skeleton_set_flags(p_interface_: *DBusInterfaceSkeleton, p_flags: gio.DBusInterfaceSkeletonFlags) void;
    pub const setFlags = g_dbus_interface_skeleton_set_flags;

    /// Stops exporting `interface_` on all connections it is exported on.
    ///
    /// To unexport `interface_` from only a single connection, use
    /// `gio.DBusInterfaceSkeleton.unexportFromConnection`
    extern fn g_dbus_interface_skeleton_unexport(p_interface_: *DBusInterfaceSkeleton) void;
    pub const unexport = g_dbus_interface_skeleton_unexport;

    /// Stops exporting `interface_` on `connection`.
    ///
    /// To stop exporting on all connections the interface is exported on,
    /// use `gio.DBusInterfaceSkeleton.unexport`.
    extern fn g_dbus_interface_skeleton_unexport_from_connection(p_interface_: *DBusInterfaceSkeleton, p_connection: *gio.DBusConnection) void;
    pub const unexportFromConnection = g_dbus_interface_skeleton_unexport_from_connection;

    extern fn g_dbus_interface_skeleton_get_type() usize;
    pub const getGObjectType = g_dbus_interface_skeleton_get_type;

    extern fn g_object_ref(p_self: *gio.DBusInterfaceSkeleton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusInterfaceSkeleton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusInterfaceSkeleton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GDBusMenuModel` is an implementation of `gio.MenuModel` that can be
/// used as a proxy for a menu model that is exported over D-Bus with
/// `gio.DBusConnection.exportMenuModel`.
pub const DBusMenuModel = opaque {
    pub const Parent = gio.MenuModel;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = DBusMenuModel;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Obtains a `gio.DBusMenuModel` for the menu model which is exported
    /// at the given `bus_name` and `object_path`.
    ///
    /// The thread default main context is taken at the time of this call.
    /// All signals on the menu model (and any linked models) are reported
    /// with respect to this context.  All calls on the returned menu model
    /// (and linked models) must also originate from this same context, with
    /// the thread default main context unchanged.
    extern fn g_dbus_menu_model_get(p_connection: *gio.DBusConnection, p_bus_name: ?[*:0]const u8, p_object_path: [*:0]const u8) *gio.DBusMenuModel;
    pub const get = g_dbus_menu_model_get;

    extern fn g_dbus_menu_model_get_type() usize;
    pub const getGObjectType = g_dbus_menu_model_get_type;

    extern fn g_object_ref(p_self: *gio.DBusMenuModel) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusMenuModel) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusMenuModel, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A type for representing D-Bus messages that can be sent or received
/// on a `gio.DBusConnection`.
pub const DBusMessage = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = DBusMessage;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {
        pub const locked = struct {
            pub const name = "locked";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Utility function to calculate how many bytes are needed to
    /// completely deserialize the D-Bus message stored at `blob`.
    extern fn g_dbus_message_bytes_needed(p_blob: [*]u8, p_blob_len: usize, p_error: ?*?*glib.Error) isize;
    pub const bytesNeeded = g_dbus_message_bytes_needed;

    /// Creates a new empty `gio.DBusMessage`.
    extern fn g_dbus_message_new() *gio.DBusMessage;
    pub const new = g_dbus_message_new;

    /// Creates a new `gio.DBusMessage` from the data stored at `blob`. The byte
    /// order that the message was in can be retrieved using
    /// `gio.DBusMessage.getByteOrder`.
    ///
    /// If the `blob` cannot be parsed, contains invalid fields, or contains invalid
    /// headers, `G_IO_ERROR_INVALID_ARGUMENT` will be returned.
    extern fn g_dbus_message_new_from_blob(p_blob: [*]u8, p_blob_len: usize, p_capabilities: gio.DBusCapabilityFlags, p_error: ?*?*glib.Error) ?*gio.DBusMessage;
    pub const newFromBlob = g_dbus_message_new_from_blob;

    /// Creates a new `gio.DBusMessage` for a method call.
    extern fn g_dbus_message_new_method_call(p_name: ?[*:0]const u8, p_path: [*:0]const u8, p_interface_: ?[*:0]const u8, p_method: [*:0]const u8) *gio.DBusMessage;
    pub const newMethodCall = g_dbus_message_new_method_call;

    /// Creates a new `gio.DBusMessage` for a signal emission.
    extern fn g_dbus_message_new_signal(p_path: [*:0]const u8, p_interface_: [*:0]const u8, p_signal: [*:0]const u8) *gio.DBusMessage;
    pub const newSignal = g_dbus_message_new_signal;

    /// Copies `message`. The copy is a deep copy and the returned
    /// `gio.DBusMessage` is completely identical except that it is guaranteed
    /// to not be locked.
    ///
    /// This operation can fail if e.g. `message` contains file descriptors
    /// and the per-process or system-wide open files limit is reached.
    extern fn g_dbus_message_copy(p_message: *DBusMessage, p_error: ?*?*glib.Error) ?*gio.DBusMessage;
    pub const copy = g_dbus_message_copy;

    /// Convenience to get the first item in the body of `message`.
    ///
    /// See `gio.DBusMessage.getArg0Path` for returning object-path-typed
    /// arg0 values.
    extern fn g_dbus_message_get_arg0(p_message: *DBusMessage) ?[*:0]const u8;
    pub const getArg0 = g_dbus_message_get_arg0;

    /// Convenience to get the first item in the body of `message`.
    ///
    /// See `gio.DBusMessage.getArg0` for returning string-typed arg0 values.
    extern fn g_dbus_message_get_arg0_path(p_message: *DBusMessage) ?[*:0]const u8;
    pub const getArg0Path = g_dbus_message_get_arg0_path;

    /// Gets the body of a message.
    extern fn g_dbus_message_get_body(p_message: *DBusMessage) ?*glib.Variant;
    pub const getBody = g_dbus_message_get_body;

    /// Gets the byte order of `message`.
    extern fn g_dbus_message_get_byte_order(p_message: *DBusMessage) gio.DBusMessageByteOrder;
    pub const getByteOrder = g_dbus_message_get_byte_order;

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION` header field.
    extern fn g_dbus_message_get_destination(p_message: *DBusMessage) ?[*:0]const u8;
    pub const getDestination = g_dbus_message_get_destination;

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME` header field.
    extern fn g_dbus_message_get_error_name(p_message: *DBusMessage) ?[*:0]const u8;
    pub const getErrorName = g_dbus_message_get_error_name;

    /// Gets the flags for `message`.
    extern fn g_dbus_message_get_flags(p_message: *DBusMessage) gio.DBusMessageFlags;
    pub const getFlags = g_dbus_message_get_flags;

    /// Gets a header field on `message`.
    ///
    /// The caller is responsible for checking the type of the returned `glib.Variant`
    /// matches what is expected.
    extern fn g_dbus_message_get_header(p_message: *DBusMessage, p_header_field: gio.DBusMessageHeaderField) ?*glib.Variant;
    pub const getHeader = g_dbus_message_get_header;

    /// Gets an array of all header fields on `message` that are set.
    extern fn g_dbus_message_get_header_fields(p_message: *DBusMessage) [*]u8;
    pub const getHeaderFields = g_dbus_message_get_header_fields;

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE` header field.
    extern fn g_dbus_message_get_interface(p_message: *DBusMessage) ?[*:0]const u8;
    pub const getInterface = g_dbus_message_get_interface;

    /// Checks whether `message` is locked. To monitor changes to this
    /// value, conncet to the `gobject.Object.signals.notify` signal to listen for changes
    /// on the `gio.DBusMessage.properties.locked` property.
    extern fn g_dbus_message_get_locked(p_message: *DBusMessage) c_int;
    pub const getLocked = g_dbus_message_get_locked;

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_MEMBER` header field.
    extern fn g_dbus_message_get_member(p_message: *DBusMessage) ?[*:0]const u8;
    pub const getMember = g_dbus_message_get_member;

    /// Gets the type of `message`.
    extern fn g_dbus_message_get_message_type(p_message: *DBusMessage) gio.DBusMessageType;
    pub const getMessageType = g_dbus_message_get_message_type;

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS` header field.
    extern fn g_dbus_message_get_num_unix_fds(p_message: *DBusMessage) u32;
    pub const getNumUnixFds = g_dbus_message_get_num_unix_fds;

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_PATH` header field.
    extern fn g_dbus_message_get_path(p_message: *DBusMessage) ?[*:0]const u8;
    pub const getPath = g_dbus_message_get_path;

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL` header field.
    extern fn g_dbus_message_get_reply_serial(p_message: *DBusMessage) u32;
    pub const getReplySerial = g_dbus_message_get_reply_serial;

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_SENDER` header field.
    extern fn g_dbus_message_get_sender(p_message: *DBusMessage) ?[*:0]const u8;
    pub const getSender = g_dbus_message_get_sender;

    /// Gets the serial for `message`.
    extern fn g_dbus_message_get_serial(p_message: *DBusMessage) u32;
    pub const getSerial = g_dbus_message_get_serial;

    /// Convenience getter for the `G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE` header field.
    ///
    /// This will always be non-`NULL`, but may be an empty string.
    extern fn g_dbus_message_get_signature(p_message: *DBusMessage) [*:0]const u8;
    pub const getSignature = g_dbus_message_get_signature;

    /// Gets the UNIX file descriptors associated with `message`, if any.
    ///
    /// This method is only available on UNIX.
    ///
    /// The file descriptors normally correspond to `G_VARIANT_TYPE_HANDLE`
    /// values in the body of the message. For example,
    /// if `glib.Variant.getHandle` returns 5, that is intended to be a reference
    /// to the file descriptor that can be accessed by
    /// `g_unix_fd_list_get (list, 5, ...)`.
    extern fn g_dbus_message_get_unix_fd_list(p_message: *DBusMessage) ?*gio.UnixFDList;
    pub const getUnixFdList = g_dbus_message_get_unix_fd_list;

    /// If `message` is locked, does nothing. Otherwise locks the message.
    extern fn g_dbus_message_lock(p_message: *DBusMessage) void;
    pub const lock = g_dbus_message_lock;

    /// Creates a new `gio.DBusMessage` that is an error reply to `method_call_message`.
    extern fn g_dbus_message_new_method_error(p_method_call_message: *DBusMessage, p_error_name: [*:0]const u8, p_error_message_format: [*:0]const u8, ...) *gio.DBusMessage;
    pub const newMethodError = g_dbus_message_new_method_error;

    /// Creates a new `gio.DBusMessage` that is an error reply to `method_call_message`.
    extern fn g_dbus_message_new_method_error_literal(p_method_call_message: *DBusMessage, p_error_name: [*:0]const u8, p_error_message: [*:0]const u8) *gio.DBusMessage;
    pub const newMethodErrorLiteral = g_dbus_message_new_method_error_literal;

    /// Like `gio.DBusMessage.newMethodError` but intended for language bindings.
    extern fn g_dbus_message_new_method_error_valist(p_method_call_message: *DBusMessage, p_error_name: [*:0]const u8, p_error_message_format: [*:0]const u8, p_var_args: std.builtin.VaList) *gio.DBusMessage;
    pub const newMethodErrorValist = g_dbus_message_new_method_error_valist;

    /// Creates a new `gio.DBusMessage` that is a reply to `method_call_message`.
    extern fn g_dbus_message_new_method_reply(p_method_call_message: *DBusMessage) *gio.DBusMessage;
    pub const newMethodReply = g_dbus_message_new_method_reply;

    /// Produces a human-readable multi-line description of `message`.
    ///
    /// The contents of the description has no ABI guarantees, the contents
    /// and formatting is subject to change at any time. Typical output
    /// looks something like this:
    /// ```
    /// Flags:   none
    /// Version: 0
    /// Serial:  4
    /// Headers:
    ///   path -> objectpath '/org/gtk/GDBus/TestObject'
    ///   interface -> 'org.gtk.GDBus.TestInterface'
    ///   member -> 'GimmeStdout'
    ///   destination -> ':1.146'
    /// Body: ()
    /// UNIX File Descriptors:
    ///   (none)
    /// ```
    /// or
    /// ```
    /// Flags:   no-reply-expected
    /// Version: 0
    /// Serial:  477
    /// Headers:
    ///   reply-serial -> uint32 4
    ///   destination -> ':1.159'
    ///   sender -> ':1.146'
    ///   num-unix-fds -> uint32 1
    /// Body: ()
    /// UNIX File Descriptors:
    ///   fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
    /// ```
    extern fn g_dbus_message_print(p_message: *DBusMessage, p_indent: c_uint) [*:0]u8;
    pub const print = g_dbus_message_print;

    /// Sets the body `message`. As a side-effect the
    /// `G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE` header field is set to the
    /// type string of `body` (or cleared if `body` is `NULL`).
    ///
    /// If `body` is floating, `message` assumes ownership of `body`.
    extern fn g_dbus_message_set_body(p_message: *DBusMessage, p_body: *glib.Variant) void;
    pub const setBody = g_dbus_message_set_body;

    /// Sets the byte order of `message`.
    extern fn g_dbus_message_set_byte_order(p_message: *DBusMessage, p_byte_order: gio.DBusMessageByteOrder) void;
    pub const setByteOrder = g_dbus_message_set_byte_order;

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION` header field.
    extern fn g_dbus_message_set_destination(p_message: *DBusMessage, p_value: ?[*:0]const u8) void;
    pub const setDestination = g_dbus_message_set_destination;

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME` header field.
    extern fn g_dbus_message_set_error_name(p_message: ?*DBusMessage, p_value: [*:0]const u8) void;
    pub const setErrorName = g_dbus_message_set_error_name;

    /// Sets the flags to set on `message`.
    extern fn g_dbus_message_set_flags(p_message: *DBusMessage, p_flags: gio.DBusMessageFlags) void;
    pub const setFlags = g_dbus_message_set_flags;

    /// Sets a header field on `message`.
    ///
    /// If `value` is floating, `message` assumes ownership of `value`.
    extern fn g_dbus_message_set_header(p_message: *DBusMessage, p_header_field: gio.DBusMessageHeaderField, p_value: ?*glib.Variant) void;
    pub const setHeader = g_dbus_message_set_header;

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE` header field.
    extern fn g_dbus_message_set_interface(p_message: *DBusMessage, p_value: ?[*:0]const u8) void;
    pub const setInterface = g_dbus_message_set_interface;

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_MEMBER` header field.
    extern fn g_dbus_message_set_member(p_message: *DBusMessage, p_value: ?[*:0]const u8) void;
    pub const setMember = g_dbus_message_set_member;

    /// Sets `message` to be of `type`.
    extern fn g_dbus_message_set_message_type(p_message: *DBusMessage, p_type: gio.DBusMessageType) void;
    pub const setMessageType = g_dbus_message_set_message_type;

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS` header field.
    extern fn g_dbus_message_set_num_unix_fds(p_message: *DBusMessage, p_value: u32) void;
    pub const setNumUnixFds = g_dbus_message_set_num_unix_fds;

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_PATH` header field.
    extern fn g_dbus_message_set_path(p_message: *DBusMessage, p_value: ?[*:0]const u8) void;
    pub const setPath = g_dbus_message_set_path;

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL` header field.
    extern fn g_dbus_message_set_reply_serial(p_message: *DBusMessage, p_value: u32) void;
    pub const setReplySerial = g_dbus_message_set_reply_serial;

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_SENDER` header field.
    extern fn g_dbus_message_set_sender(p_message: *DBusMessage, p_value: ?[*:0]const u8) void;
    pub const setSender = g_dbus_message_set_sender;

    /// Sets the serial for `message`.
    ///
    /// The [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html`message`-protocol-messages)
    /// does not allow the `serial` to be zero.
    extern fn g_dbus_message_set_serial(p_message: *DBusMessage, p_serial: u32) void;
    pub const setSerial = g_dbus_message_set_serial;

    /// Convenience setter for the `G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE` header field.
    extern fn g_dbus_message_set_signature(p_message: *DBusMessage, p_value: ?[*:0]const u8) void;
    pub const setSignature = g_dbus_message_set_signature;

    /// Sets the UNIX file descriptors associated with `message`. As a
    /// side-effect the `G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS` header
    /// field is set to the number of fds in `fd_list` (or cleared if
    /// `fd_list` is `NULL`).
    ///
    /// This method is only available on UNIX.
    ///
    /// When designing D-Bus APIs that are intended to be interoperable,
    /// please note that non-GDBus implementations of D-Bus can usually only
    /// access file descriptors if they are referenced by a value of type
    /// `G_VARIANT_TYPE_HANDLE` in the body of the message.
    extern fn g_dbus_message_set_unix_fd_list(p_message: *DBusMessage, p_fd_list: ?*gio.UnixFDList) void;
    pub const setUnixFdList = g_dbus_message_set_unix_fd_list;

    /// Serializes `message` to a blob. The byte order returned by
    /// `gio.DBusMessage.getByteOrder` will be used.
    extern fn g_dbus_message_to_blob(p_message: *DBusMessage, p_out_size: *usize, p_capabilities: gio.DBusCapabilityFlags, p_error: ?*?*glib.Error) ?[*]u8;
    pub const toBlob = g_dbus_message_to_blob;

    /// If `message` is not of type `G_DBUS_MESSAGE_TYPE_ERROR` does
    /// nothing and returns `FALSE`.
    ///
    /// Otherwise this method encodes the error in `message` as a `glib.Error`
    /// using `gio.DBusError.setDbusError` using the information in the
    /// `G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME` header field of `message` as
    /// well as the first string item in `message`'s body.
    extern fn g_dbus_message_to_gerror(p_message: *DBusMessage, p_error: ?*?*glib.Error) c_int;
    pub const toGerror = g_dbus_message_to_gerror;

    extern fn g_dbus_message_get_type() usize;
    pub const getGObjectType = g_dbus_message_get_type;

    extern fn g_object_ref(p_self: *gio.DBusMessage) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusMessage) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusMessage, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Instances of the `GDBusMethodInvocation` class are used when
/// handling D-Bus method calls. It provides a way to asynchronously
/// return results and errors.
///
/// The normal way to obtain a `GDBusMethodInvocation` object is to receive
/// it as an argument to the ``handle_method_call`` function in a
/// `gio.DBusInterfaceVTable` that was passed to
/// `gio.DBusConnection.registerObject`.
pub const DBusMethodInvocation = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = DBusMethodInvocation;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Gets the `gio.DBusConnection` the method was invoked on.
    extern fn g_dbus_method_invocation_get_connection(p_invocation: *DBusMethodInvocation) *gio.DBusConnection;
    pub const getConnection = g_dbus_method_invocation_get_connection;

    /// Gets the name of the D-Bus interface the method was invoked on.
    ///
    /// This can be `NULL` if it was not specified by the sender. See
    /// `gio.DBusInterfaceMethodCallFunc` or the
    /// [D-Bus Specification](https://dbus.freedesktop.org/doc/dbus-specification.html`message`-protocol-types-method)
    /// for details on when this can happen and how it should be handled.
    ///
    /// If this method call is a property Get, Set or GetAll call that has
    /// been redirected to the method call handler then
    /// "org.freedesktop.DBus.Properties" will be returned.  See
    /// `gio.DBusInterfaceVTable` for more information.
    extern fn g_dbus_method_invocation_get_interface_name(p_invocation: *DBusMethodInvocation) ?[*:0]const u8;
    pub const getInterfaceName = g_dbus_method_invocation_get_interface_name;

    /// Gets the `gio.DBusMessage` for the method invocation. This is useful if
    /// you need to use low-level protocol features, such as UNIX file
    /// descriptor passing, that cannot be properly expressed in the
    /// `glib.Variant` API.
    ///
    /// See this [server]`gio.@"DBusConnection#an-example-d-bus-server"`
    /// and [client]`gio.@"DBusConnection#an-example-for-file-descriptor-passing"`
    /// for an example of how to use this low-level API to send and receive
    /// UNIX file descriptors.
    extern fn g_dbus_method_invocation_get_message(p_invocation: *DBusMethodInvocation) *gio.DBusMessage;
    pub const getMessage = g_dbus_method_invocation_get_message;

    /// Gets information about the method call, if any.
    ///
    /// If this method invocation is a property Get, Set or GetAll call that
    /// has been redirected to the method call handler then `NULL` will be
    /// returned.  See `gio.DBusMethodInvocation.getPropertyInfo` and
    /// `gio.DBusInterfaceVTable` for more information.
    extern fn g_dbus_method_invocation_get_method_info(p_invocation: *DBusMethodInvocation) ?*const gio.DBusMethodInfo;
    pub const getMethodInfo = g_dbus_method_invocation_get_method_info;

    /// Gets the name of the method that was invoked.
    extern fn g_dbus_method_invocation_get_method_name(p_invocation: *DBusMethodInvocation) [*:0]const u8;
    pub const getMethodName = g_dbus_method_invocation_get_method_name;

    /// Gets the object path the method was invoked on.
    extern fn g_dbus_method_invocation_get_object_path(p_invocation: *DBusMethodInvocation) [*:0]const u8;
    pub const getObjectPath = g_dbus_method_invocation_get_object_path;

    /// Gets the parameters of the method invocation. If there are no input
    /// parameters then this will return a GVariant with 0 children rather than NULL.
    extern fn g_dbus_method_invocation_get_parameters(p_invocation: *DBusMethodInvocation) *glib.Variant;
    pub const getParameters = g_dbus_method_invocation_get_parameters;

    /// Gets information about the property that this method call is for, if
    /// any.
    ///
    /// This will only be set in the case of an invocation in response to a
    /// property Get or Set call that has been directed to the method call
    /// handler for an object on account of its `property_get` or
    /// `property_set` vtable pointers being unset.
    ///
    /// See `gio.DBusInterfaceVTable` for more information.
    ///
    /// If the call was GetAll, `NULL` will be returned.
    extern fn g_dbus_method_invocation_get_property_info(p_invocation: *DBusMethodInvocation) ?*const gio.DBusPropertyInfo;
    pub const getPropertyInfo = g_dbus_method_invocation_get_property_info;

    /// Gets the bus name that invoked the method.
    ///
    /// This can return `NULL` if not specified by the caller, e.g. on peer-to-peer
    /// connections.
    extern fn g_dbus_method_invocation_get_sender(p_invocation: *DBusMethodInvocation) ?[*:0]const u8;
    pub const getSender = g_dbus_method_invocation_get_sender;

    /// Gets the `user_data` `gpointer` passed to `gio.DBusConnection.registerObject`.
    extern fn g_dbus_method_invocation_get_user_data(p_invocation: *DBusMethodInvocation) ?*anyopaque;
    pub const getUserData = g_dbus_method_invocation_get_user_data;

    /// Finishes handling a D-Bus method call by returning an error.
    ///
    /// This method will take ownership of `invocation`. See
    /// `gio.DBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    extern fn g_dbus_method_invocation_return_dbus_error(p_invocation: *DBusMethodInvocation, p_error_name: [*:0]const u8, p_error_message: [*:0]const u8) void;
    pub const returnDbusError = g_dbus_method_invocation_return_dbus_error;

    /// Finishes handling a D-Bus method call by returning an error.
    ///
    /// See `gio.dbusErrorEncodeGerror` for details about what error name
    /// will be returned on the wire. In a nutshell, if the given error is
    /// registered using `gio.dbusErrorRegisterError` the name given
    /// during registration is used. Otherwise, a name of the form
    /// `org.gtk.GDBus.UnmappedGError.Quark...` is used. This provides
    /// transparent mapping of `glib.Error` between applications using GDBus.
    ///
    /// If you are writing an application intended to be portable,
    /// always register errors with `gio.dbusErrorRegisterError`
    /// or use `gio.DBusMethodInvocation.returnDbusError`.
    ///
    /// This method will take ownership of `invocation`. See
    /// `gio.DBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    ///
    /// Since 2.48, if the method call requested for a reply not to be sent
    /// then this call will free `invocation` but otherwise do nothing (as per
    /// the recommendations of the D-Bus specification).
    extern fn g_dbus_method_invocation_return_error(p_invocation: *DBusMethodInvocation, p_domain: glib.Quark, p_code: c_int, p_format: [*:0]const u8, ...) void;
    pub const returnError = g_dbus_method_invocation_return_error;

    /// Like `gio.DBusMethodInvocation.returnError` but without `printf`-style formatting.
    ///
    /// This method will take ownership of `invocation`. See
    /// `gio.DBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    extern fn g_dbus_method_invocation_return_error_literal(p_invocation: *DBusMethodInvocation, p_domain: glib.Quark, p_code: c_int, p_message: [*:0]const u8) void;
    pub const returnErrorLiteral = g_dbus_method_invocation_return_error_literal;

    /// Like `gio.DBusMethodInvocation.returnError` but intended for
    /// language bindings.
    ///
    /// This method will take ownership of `invocation`. See
    /// `gio.DBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    extern fn g_dbus_method_invocation_return_error_valist(p_invocation: *DBusMethodInvocation, p_domain: glib.Quark, p_code: c_int, p_format: [*:0]const u8, p_var_args: std.builtin.VaList) void;
    pub const returnErrorValist = g_dbus_method_invocation_return_error_valist;

    /// Like `gio.DBusMethodInvocation.returnError` but takes a `glib.Error`
    /// instead of the error domain, error code and message.
    ///
    /// This method will take ownership of `invocation`. See
    /// `gio.DBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    extern fn g_dbus_method_invocation_return_gerror(p_invocation: *DBusMethodInvocation, p_error: *const glib.Error) void;
    pub const returnGerror = g_dbus_method_invocation_return_gerror;

    /// Finishes handling a D-Bus method call by returning `parameters`.
    /// If the `parameters` GVariant is floating, it is consumed.
    ///
    /// It is an error if `parameters` is not of the right format: it must be a tuple
    /// containing the out-parameters of the D-Bus method. Even if the method has a
    /// single out-parameter, it must be contained in a tuple. If the method has no
    /// out-parameters, `parameters` may be `NULL` or an empty tuple.
    ///
    /// ```
    /// GDBusMethodInvocation *invocation = some_invocation;
    /// g_autofree gchar *result_string = NULL;
    /// g_autoptr (GError) error = NULL;
    ///
    /// result_string = calculate_result (&error);
    ///
    /// if (error != NULL)
    ///   g_dbus_method_invocation_return_gerror (invocation, error);
    /// else
    ///   g_dbus_method_invocation_return_value (invocation,
    ///                                          g_variant_new ("(s)", result_string));
    ///
    /// // Do not free `invocation` here; returning a value does that
    /// ```
    ///
    /// This method will take ownership of `invocation`. See
    /// `gio.DBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    ///
    /// Since 2.48, if the method call requested for a reply not to be sent
    /// then this call will sink `parameters` and free `invocation`, but
    /// otherwise do nothing (as per the recommendations of the D-Bus
    /// specification).
    extern fn g_dbus_method_invocation_return_value(p_invocation: *DBusMethodInvocation, p_parameters: ?*glib.Variant) void;
    pub const returnValue = g_dbus_method_invocation_return_value;

    /// Like `gio.DBusMethodInvocation.returnValue` but also takes a `gio.UnixFDList`.
    ///
    /// This method is only available on UNIX.
    ///
    /// This method will take ownership of `invocation`. See
    /// `gio.DBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    extern fn g_dbus_method_invocation_return_value_with_unix_fd_list(p_invocation: *DBusMethodInvocation, p_parameters: ?*glib.Variant, p_fd_list: ?*gio.UnixFDList) void;
    pub const returnValueWithUnixFdList = g_dbus_method_invocation_return_value_with_unix_fd_list;

    /// Like `gio.DBusMethodInvocation.returnGerror` but takes ownership
    /// of `error` so the caller does not need to free it.
    ///
    /// This method will take ownership of `invocation`. See
    /// `gio.DBusInterfaceVTable` for more information about the ownership of
    /// `invocation`.
    extern fn g_dbus_method_invocation_take_error(p_invocation: *DBusMethodInvocation, p_error: *glib.Error) void;
    pub const takeError = g_dbus_method_invocation_take_error;

    extern fn g_dbus_method_invocation_get_type() usize;
    pub const getGObjectType = g_dbus_method_invocation_get_type;

    extern fn g_object_ref(p_self: *gio.DBusMethodInvocation) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusMethodInvocation) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusMethodInvocation, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GDBusObjectManagerClient` is used to create, monitor and delete object
/// proxies for remote objects exported by a `gio.DBusObjectManagerServer`
/// (or any code implementing the
/// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html`standard`-interfaces-objectmanager)
/// interface).
///
/// Once an instance of this type has been created, you can connect to
/// the `gio.DBusObjectManager.signals.object_added` and
/// `gio.DBusObjectManager.signals.@"object_removed signals"` and inspect the
/// `gio.DBusObjectProxy` objects returned by
/// `gio.DBusObjectManager.getObjects`.
///
/// If the name for a `GDBusObjectManagerClient` is not owned by anyone at
/// object construction time, the default behavior is to request the
/// message bus to launch an owner for the name. This behavior can be
/// disabled using the `G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START`
/// flag. It’s also worth noting that this only works if the name of
/// interest is activatable in the first place. E.g. in some cases it
/// is not possible to launch an owner for the requested name. In this
/// case, `GDBusObjectManagerClient` object construction still succeeds but
/// there will be no object proxies
/// (e.g. `gio.DBusObjectManager.getObjects` returns the empty list) and
/// the `gio.DBusObjectManagerClient.properties.name_owner` property is `NULL`.
///
/// The owner of the requested name can come and go (for example
/// consider a system service being restarted) – `GDBusObjectManagerClient`
/// handles this case too; simply connect to the `gobject.Object.signals.notify`
/// signal to watch for changes on the
/// `gio.DBusObjectManagerClient.properties.name_owner` property. When the name
/// owner vanishes, the behavior is that
/// `gio.DBusObjectManagerClient.properties.name_owner` is set to `NULL` (this
/// includes emission of the `gobject.Object.signals.notify` signal) and then
/// `gio.DBusObjectManager.signals.object_removed` signals are synthesized
/// for all currently existing object proxies. Since
/// `gio.DBusObjectManagerClient.properties.name_owner` is `NULL` when this
/// happens, you can use this information to disambiguate a synthesized signal
/// from a genuine signal caused by object removal on the remote
/// `gio.DBusObjectManager`. Similarly, when a new name owner appears,
/// `gio.DBusObjectManager.signals.object_added` signals are synthesized
/// while `gio.DBusObjectManagerClient.properties.name_owner` is still `NULL`. Only
/// when all object proxies have been added, the
/// `gio.DBusObjectManagerClient.properties.name_owner` is set to the new name
/// owner (this includes emission of the `gobject.Object.signals.notify` signal).
/// Furthermore, you are guaranteed that
/// `gio.DBusObjectManagerClient.properties.name_owner` will alternate between a
/// name owner (e.g. `:1.42`) and `NULL` even in the case where
/// the name of interest is atomically replaced
///
/// Ultimately, `GDBusObjectManagerClient` is used to obtain
/// `gio.DBusProxy` instances. All signals (including the
/// `org.freedesktop.DBus.Properties::PropertiesChanged` signal)
/// delivered to `gio.DBusProxy` instances are guaranteed to originate
/// from the name owner. This guarantee along with the behavior
/// described above, means that certain race conditions including the
/// “half the proxy is from the old owner and the other half is from
/// the new owner” problem cannot happen.
///
/// To avoid having the application connect to signals on the returned
/// `gio.DBusObjectProxy` and `gio.DBusProxy` objects, the
/// `gio.DBusObject.signals.interface_added`,
/// `gio.DBusObject.signals.interface_removed`,
/// `gio.DBusProxy.signals.g_properties_changed` and
/// `gio.DBusProxy.signals.g_signal` signals
/// are also emitted on the `GDBusObjectManagerClient` instance managing these
/// objects. The signals emitted are
/// `gio.DBusObjectManager.signals.interface_added`,
/// `gio.DBusObjectManager.signals.interface_removed`,
/// `gio.DBusObjectManagerClient.signals.interface_proxy_properties_changed` and
/// `gio.DBusObjectManagerClient.signals.interface_proxy_signal`.
///
/// Note that all callbacks and signals are emitted in the
/// thread-default main context (see
/// `glib.MainContext.pushThreadDefault`) that the
/// `GDBusObjectManagerClient` object was constructed in. Additionally, the
/// `gio.DBusObjectProxy` and `gio.DBusProxy` objects
/// originating from the `GDBusObjectManagerClient` object will be created in
/// the same context and, consequently, will deliver signals in the
/// same main loop.
pub const DBusObjectManagerClient = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gio.AsyncInitable, gio.DBusObjectManager, gio.Initable };
    pub const Class = gio.DBusObjectManagerClientClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.DBusObjectManagerClientPrivate,

    pub const virtual_methods = struct {
        /// Signal class handler for the `gio.DBusObjectManagerClient.signals.interface`-proxy-properties-changed signal.
        pub const interface_proxy_properties_changed = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object_proxy: *gio.DBusObjectProxy, p_interface_proxy: *gio.DBusProxy, p_changed_properties: *glib.Variant, p_invalidated_properties: *const [*:0]const u8) void {
                return gobject.ext.as(DBusObjectManagerClient.Class, p_class).f_interface_proxy_properties_changed.?(gobject.ext.as(DBusObjectManagerClient, p_manager), p_object_proxy, p_interface_proxy, p_changed_properties, p_invalidated_properties);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object_proxy: *gio.DBusObjectProxy, p_interface_proxy: *gio.DBusProxy, p_changed_properties: *glib.Variant, p_invalidated_properties: *const [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(DBusObjectManagerClient.Class, p_class).f_interface_proxy_properties_changed = @ptrCast(p_implementation);
            }
        };

        /// Signal class handler for the `gio.DBusObjectManagerClient.signals.interface`-proxy-signal signal.
        pub const interface_proxy_signal = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object_proxy: *gio.DBusObjectProxy, p_interface_proxy: *gio.DBusProxy, p_sender_name: [*:0]const u8, p_signal_name: [*:0]const u8, p_parameters: *glib.Variant) void {
                return gobject.ext.as(DBusObjectManagerClient.Class, p_class).f_interface_proxy_signal.?(gobject.ext.as(DBusObjectManagerClient, p_manager), p_object_proxy, p_interface_proxy, p_sender_name, p_signal_name, p_parameters);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object_proxy: *gio.DBusObjectProxy, p_interface_proxy: *gio.DBusProxy, p_sender_name: [*:0]const u8, p_signal_name: [*:0]const u8, p_parameters: *glib.Variant) callconv(.c) void) void {
                gobject.ext.as(DBusObjectManagerClient.Class, p_class).f_interface_proxy_signal = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// If this property is not `G_BUS_TYPE_NONE`, then
        /// `gio.DBusObjectManagerClient.properties.connection` must be `NULL` and will be set to the
        /// `gio.DBusConnection` obtained by calling `gio.busGet` with the value
        /// of this property.
        pub const bus_type = struct {
            pub const name = "bus-type";

            pub const Type = gio.BusType;
        };

        /// The `gio.DBusConnection` to use.
        pub const connection = struct {
            pub const name = "connection";

            pub const Type = ?*gio.DBusConnection;
        };

        /// Flags from the `gio.DBusObjectManagerClientFlags` enumeration.
        pub const flags = struct {
            pub const name = "flags";

            pub const Type = gio.DBusObjectManagerClientFlags;
        };

        /// A `glib.DestroyNotify` for the `gpointer` user_data in `gio.DBusObjectManagerClient.properties.get`-proxy-type-user-data.
        pub const get_proxy_type_destroy_notify = struct {
            pub const name = "get-proxy-type-destroy-notify";

            pub const Type = ?*anyopaque;
        };

        /// The `gio.DBusProxyTypeFunc` to use when determining what `gobject.Type` to
        /// use for interface proxies or `NULL`.
        pub const get_proxy_type_func = struct {
            pub const name = "get-proxy-type-func";

            pub const Type = ?*anyopaque;
        };

        /// The `gpointer` user_data to pass to `gio.DBusObjectManagerClient.properties.get`-proxy-type-func.
        pub const get_proxy_type_user_data = struct {
            pub const name = "get-proxy-type-user-data";

            pub const Type = ?*anyopaque;
        };

        /// The well-known name or unique name that the manager is for.
        pub const name = struct {
            pub const name = "name";

            pub const Type = ?[*:0]u8;
        };

        /// The unique name that owns `gio.DBusObjectManagerClient.properties.name` or `NULL` if
        /// no-one is currently owning the name. Connect to the
        /// `gobject.Object.signals.notify` signal to track changes to this property.
        pub const name_owner = struct {
            pub const name = "name-owner";

            pub const Type = ?[*:0]u8;
        };

        /// The object path the manager is for.
        pub const object_path = struct {
            pub const name = "object-path";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {
        /// Emitted when one or more D-Bus properties on proxy changes. The
        /// local cache has already been updated when this signal fires. Note
        /// that both `changed_properties` and `invalidated_properties` are
        /// guaranteed to never be `NULL` (either may be empty though).
        ///
        /// This signal exists purely as a convenience to avoid having to
        /// connect signals to all interface proxies managed by `manager`.
        ///
        /// This signal is emitted in the thread-default main context
        /// (see `glib.MainContext.pushThreadDefault`)
        /// that `manager` was constructed in.
        pub const interface_proxy_properties_changed = struct {
            pub const name = "interface-proxy-properties-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object_proxy: *gio.DBusObjectProxy, p_interface_proxy: *gio.DBusProxy, p_changed_properties: *glib.Variant, p_invalidated_properties: [*][*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusObjectManagerClient, p_instance))),
                    gobject.signalLookup("interface-proxy-properties-changed", DBusObjectManagerClient.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when a D-Bus signal is received on `interface_proxy`.
        ///
        /// This signal exists purely as a convenience to avoid having to
        /// connect signals to all interface proxies managed by `manager`.
        ///
        /// This signal is emitted in the thread-default main context
        /// (see `glib.MainContext.pushThreadDefault`)
        /// that `manager` was constructed in.
        pub const interface_proxy_signal = struct {
            pub const name = "interface-proxy-signal";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object_proxy: *gio.DBusObjectProxy, p_interface_proxy: *gio.DBusProxy, p_sender_name: [*:0]u8, p_signal_name: [*:0]u8, p_parameters: *glib.Variant, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusObjectManagerClient, p_instance))),
                    gobject.signalLookup("interface-proxy-signal", DBusObjectManagerClient.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Asynchronously creates a new `gio.DBusObjectManagerClient` object.
    ///
    /// This is an asynchronous failable constructor. When the result is
    /// ready, `callback` will be invoked in the thread-default main context
    /// (see `glib.MainContext.pushThreadDefault`)
    /// of the thread you are calling this method from. You can then call
    /// `gio.DBusObjectManagerClient.newFinish` to get the result. See
    /// `gio.DBusObjectManagerClient.newSync` for the synchronous version.
    extern fn g_dbus_object_manager_client_new(p_connection: *gio.DBusConnection, p_flags: gio.DBusObjectManagerClientFlags, p_name: [*:0]const u8, p_object_path: [*:0]const u8, p_get_proxy_type_func: ?gio.DBusProxyTypeFunc, p_get_proxy_type_user_data: ?*anyopaque, p_get_proxy_type_destroy_notify: ?glib.DestroyNotify, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const new = g_dbus_object_manager_client_new;

    /// Like `gio.DBusObjectManagerClient.new` but takes a `gio.BusType` instead of a
    /// `gio.DBusConnection`.
    ///
    /// This is an asynchronous failable constructor. When the result is
    /// ready, `callback` will be invoked in the thread-default main context
    /// (see `glib.MainContext.pushThreadDefault`)
    /// of the thread you are calling this method from. You can
    /// then call `gio.DBusObjectManagerClient.newForBusFinish` to get the result. See
    /// `gio.DBusObjectManagerClient.newForBusSync` for the synchronous version.
    extern fn g_dbus_object_manager_client_new_for_bus(p_bus_type: gio.BusType, p_flags: gio.DBusObjectManagerClientFlags, p_name: [*:0]const u8, p_object_path: [*:0]const u8, p_get_proxy_type_func: ?gio.DBusProxyTypeFunc, p_get_proxy_type_user_data: ?*anyopaque, p_get_proxy_type_destroy_notify: ?glib.DestroyNotify, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const newForBus = g_dbus_object_manager_client_new_for_bus;

    /// Finishes an operation started with `gio.DBusObjectManagerClient.new`.
    extern fn g_dbus_object_manager_client_new_finish(p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.DBusObjectManagerClient;
    pub const newFinish = g_dbus_object_manager_client_new_finish;

    /// Finishes an operation started with `gio.DBusObjectManagerClient.newForBus`.
    extern fn g_dbus_object_manager_client_new_for_bus_finish(p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.DBusObjectManagerClient;
    pub const newForBusFinish = g_dbus_object_manager_client_new_for_bus_finish;

    /// Like `gio.DBusObjectManagerClient.newSync` but takes a `gio.BusType` instead
    /// of a `gio.DBusConnection`.
    ///
    /// This is a synchronous failable constructor - the calling thread is
    /// blocked until a reply is received. See `gio.DBusObjectManagerClient.newForBus`
    /// for the asynchronous version.
    extern fn g_dbus_object_manager_client_new_for_bus_sync(p_bus_type: gio.BusType, p_flags: gio.DBusObjectManagerClientFlags, p_name: [*:0]const u8, p_object_path: [*:0]const u8, p_get_proxy_type_func: ?gio.DBusProxyTypeFunc, p_get_proxy_type_user_data: ?*anyopaque, p_get_proxy_type_destroy_notify: ?glib.DestroyNotify, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.DBusObjectManagerClient;
    pub const newForBusSync = g_dbus_object_manager_client_new_for_bus_sync;

    /// Creates a new `gio.DBusObjectManagerClient` object.
    ///
    /// This is a synchronous failable constructor - the calling thread is
    /// blocked until a reply is received. See `gio.DBusObjectManagerClient.new`
    /// for the asynchronous version.
    extern fn g_dbus_object_manager_client_new_sync(p_connection: *gio.DBusConnection, p_flags: gio.DBusObjectManagerClientFlags, p_name: ?[*:0]const u8, p_object_path: [*:0]const u8, p_get_proxy_type_func: ?gio.DBusProxyTypeFunc, p_get_proxy_type_user_data: ?*anyopaque, p_get_proxy_type_destroy_notify: ?glib.DestroyNotify, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.DBusObjectManagerClient;
    pub const newSync = g_dbus_object_manager_client_new_sync;

    /// Gets the `gio.DBusConnection` used by `manager`.
    extern fn g_dbus_object_manager_client_get_connection(p_manager: *DBusObjectManagerClient) *gio.DBusConnection;
    pub const getConnection = g_dbus_object_manager_client_get_connection;

    /// Gets the flags that `manager` was constructed with.
    extern fn g_dbus_object_manager_client_get_flags(p_manager: *DBusObjectManagerClient) gio.DBusObjectManagerClientFlags;
    pub const getFlags = g_dbus_object_manager_client_get_flags;

    /// Gets the name that `manager` is for, or `NULL` if not a message bus
    /// connection.
    extern fn g_dbus_object_manager_client_get_name(p_manager: *DBusObjectManagerClient) [*:0]const u8;
    pub const getName = g_dbus_object_manager_client_get_name;

    /// The unique name that owns the name that `manager` is for or `NULL` if
    /// no-one currently owns that name. You can connect to the
    /// `gobject.Object.signals.notify` signal to track changes to the
    /// `gio.DBusObjectManagerClient.properties.name`-owner property.
    extern fn g_dbus_object_manager_client_get_name_owner(p_manager: *DBusObjectManagerClient) ?[*:0]u8;
    pub const getNameOwner = g_dbus_object_manager_client_get_name_owner;

    extern fn g_dbus_object_manager_client_get_type() usize;
    pub const getGObjectType = g_dbus_object_manager_client_get_type;

    extern fn g_object_ref(p_self: *gio.DBusObjectManagerClient) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusObjectManagerClient) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusObjectManagerClient, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GDBusObjectManagerServer` is used to export `gio.DBusObject` instances
/// using the standardized
/// [`org.freedesktop.DBus.ObjectManager`](http://dbus.freedesktop.org/doc/dbus-specification.html`standard`-interfaces-objectmanager)
/// interface. For example, remote D-Bus clients can get all objects
/// and properties in a single call. Additionally, any change in the
/// object hierarchy is broadcast using signals. This means that D-Bus
/// clients can keep caches up to date by only listening to D-Bus
/// signals.
///
/// The recommended path to export an object manager at is the path form of the
/// well-known name of a D-Bus service, or below. For example, if a D-Bus service
/// is available at the well-known name `net.example.ExampleService1`, the object
/// manager should typically be exported at `/net/example/ExampleService1`, or
/// below (to allow for multiple object managers in a service).
///
/// It is supported, but not recommended, to export an object manager at the root
/// path, `/`.
///
/// See `gio.DBusObjectManagerClient` for the client-side code that is
/// intended to be used with `GDBusObjectManagerServer` or any D-Bus
/// object implementing the `org.freedesktop.DBus.ObjectManager` interface.
pub const DBusObjectManagerServer = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.DBusObjectManager};
    pub const Class = gio.DBusObjectManagerServerClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.DBusObjectManagerServerPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The `gio.DBusConnection` to export objects on.
        pub const connection = struct {
            pub const name = "connection";

            pub const Type = ?*gio.DBusConnection;
        };

        /// The object path to register the manager object at.
        pub const object_path = struct {
            pub const name = "object-path";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.DBusObjectManagerServer` object.
    ///
    /// The returned server isn't yet exported on any connection. To do so,
    /// use `gio.DBusObjectManagerServer.setConnection`. Normally you
    /// want to export all of your objects before doing so to avoid
    /// [InterfacesAdded](http://dbus.freedesktop.org/doc/dbus-specification.html`standard`-interfaces-objectmanager)
    /// signals being emitted.
    extern fn g_dbus_object_manager_server_new(p_object_path: [*:0]const u8) *gio.DBusObjectManagerServer;
    pub const new = g_dbus_object_manager_server_new;

    /// Exports `object` on `manager`.
    ///
    /// If there is already a `gio.DBusObject` exported at the object path,
    /// then the old object is removed.
    ///
    /// The object path for `object` must be in the hierarchy rooted by the
    /// object path for `manager`.
    ///
    /// Note that `manager` will take a reference on `object` for as long as
    /// it is exported.
    extern fn g_dbus_object_manager_server_export(p_manager: *DBusObjectManagerServer, p_object: *gio.DBusObjectSkeleton) void;
    pub const @"export" = g_dbus_object_manager_server_export;

    /// Like `gio.DBusObjectManagerServer.@"export"` but appends a string of
    /// the form _N (with N being a natural number) to `object`'s object path
    /// if an object with the given path already exists. As such, the
    /// `gio.DBusObjectProxy.properties.g`-object-path property of `object` may be modified.
    extern fn g_dbus_object_manager_server_export_uniquely(p_manager: *DBusObjectManagerServer, p_object: *gio.DBusObjectSkeleton) void;
    pub const exportUniquely = g_dbus_object_manager_server_export_uniquely;

    /// Gets the `gio.DBusConnection` used by `manager`.
    extern fn g_dbus_object_manager_server_get_connection(p_manager: *DBusObjectManagerServer) ?*gio.DBusConnection;
    pub const getConnection = g_dbus_object_manager_server_get_connection;

    /// Returns whether `object` is currently exported on `manager`.
    extern fn g_dbus_object_manager_server_is_exported(p_manager: *DBusObjectManagerServer, p_object: *gio.DBusObjectSkeleton) c_int;
    pub const isExported = g_dbus_object_manager_server_is_exported;

    /// Exports all objects managed by `manager` on `connection`. If
    /// `connection` is `NULL`, stops exporting objects.
    extern fn g_dbus_object_manager_server_set_connection(p_manager: *DBusObjectManagerServer, p_connection: ?*gio.DBusConnection) void;
    pub const setConnection = g_dbus_object_manager_server_set_connection;

    /// If `manager` has an object at `path`, removes the object. Otherwise
    /// does nothing.
    ///
    /// Note that `object_path` must be in the hierarchy rooted by the
    /// object path for `manager`.
    extern fn g_dbus_object_manager_server_unexport(p_manager: *DBusObjectManagerServer, p_object_path: [*:0]const u8) c_int;
    pub const unexport = g_dbus_object_manager_server_unexport;

    extern fn g_dbus_object_manager_server_get_type() usize;
    pub const getGObjectType = g_dbus_object_manager_server_get_type;

    extern fn g_object_ref(p_self: *gio.DBusObjectManagerServer) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusObjectManagerServer) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusObjectManagerServer, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `GDBusObjectProxy` is an object used to represent a remote object
/// with one or more D-Bus interfaces. Normally, you don’t instantiate
/// a `GDBusObjectProxy` yourself — typically `gio.DBusObjectManagerClient`
/// is used to obtain it.
pub const DBusObjectProxy = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.DBusObject};
    pub const Class = gio.DBusObjectProxyClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.DBusObjectProxyPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The connection of the proxy.
        pub const g_connection = struct {
            pub const name = "g-connection";

            pub const Type = ?*gio.DBusConnection;
        };

        /// The object path of the proxy.
        pub const g_object_path = struct {
            pub const name = "g-object-path";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.DBusObjectProxy` for the given connection and
    /// object path.
    extern fn g_dbus_object_proxy_new(p_connection: *gio.DBusConnection, p_object_path: [*:0]const u8) *gio.DBusObjectProxy;
    pub const new = g_dbus_object_proxy_new;

    /// Gets the connection that `proxy` is for.
    extern fn g_dbus_object_proxy_get_connection(p_proxy: *DBusObjectProxy) *gio.DBusConnection;
    pub const getConnection = g_dbus_object_proxy_get_connection;

    extern fn g_dbus_object_proxy_get_type() usize;
    pub const getGObjectType = g_dbus_object_proxy_get_type;

    extern fn g_object_ref(p_self: *gio.DBusObjectProxy) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusObjectProxy) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusObjectProxy, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `GDBusObjectSkeleton` instance is essentially a group of D-Bus
/// interfaces. The set of exported interfaces on the object may be
/// dynamic and change at runtime.
///
/// This type is intended to be used with `gio.DBusObjectManager`.
pub const DBusObjectSkeleton = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.DBusObject};
    pub const Class = gio.DBusObjectSkeletonClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.DBusObjectSkeletonPrivate,

    pub const virtual_methods = struct {
        /// Signal class handler for the `gio.DBusObjectSkeleton.signals.authorize`-method signal.
        pub const authorize_method = struct {
            pub fn call(p_class: anytype, p_object: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_interface_: *gio.DBusInterfaceSkeleton, p_invocation: *gio.DBusMethodInvocation) c_int {
                return gobject.ext.as(DBusObjectSkeleton.Class, p_class).f_authorize_method.?(gobject.ext.as(DBusObjectSkeleton, p_object), p_interface_, p_invocation);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_object: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_interface_: *gio.DBusInterfaceSkeleton, p_invocation: *gio.DBusMethodInvocation) callconv(.c) c_int) void {
                gobject.ext.as(DBusObjectSkeleton.Class, p_class).f_authorize_method = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The object path where the object is exported.
        pub const g_object_path = struct {
            pub const name = "g-object-path";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {
        /// Emitted when a method is invoked by a remote caller and used to
        /// determine if the method call is authorized.
        ///
        /// This signal is like `gio.DBusInterfaceSkeleton`'s
        /// `gio.DBusInterfaceSkeleton.signals.g`-authorize-method signal,
        /// except that it is for the enclosing object.
        ///
        /// The default class handler just returns `TRUE`.
        pub const authorize_method = struct {
            pub const name = "authorize-method";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_interface: *gio.DBusInterfaceSkeleton, p_invocation: *gio.DBusMethodInvocation, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusObjectSkeleton, p_instance))),
                    gobject.signalLookup("authorize-method", DBusObjectSkeleton.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gio.DBusObjectSkeleton`.
    extern fn g_dbus_object_skeleton_new(p_object_path: [*:0]const u8) *gio.DBusObjectSkeleton;
    pub const new = g_dbus_object_skeleton_new;

    /// Adds `interface_` to `object`.
    ///
    /// If `object` already contains a `gio.DBusInterfaceSkeleton` with the same
    /// interface name, it is removed before `interface_` is added.
    ///
    /// Note that `object` takes its own reference on `interface_` and holds
    /// it until removed.
    extern fn g_dbus_object_skeleton_add_interface(p_object: *DBusObjectSkeleton, p_interface_: *gio.DBusInterfaceSkeleton) void;
    pub const addInterface = g_dbus_object_skeleton_add_interface;

    /// This method simply calls `gio.DBusInterfaceSkeleton.flush` on all
    /// interfaces belonging to `object`. See that method for when flushing
    /// is useful.
    extern fn g_dbus_object_skeleton_flush(p_object: *DBusObjectSkeleton) void;
    pub const flush = g_dbus_object_skeleton_flush;

    /// Removes `interface_` from `object`.
    extern fn g_dbus_object_skeleton_remove_interface(p_object: *DBusObjectSkeleton, p_interface_: *gio.DBusInterfaceSkeleton) void;
    pub const removeInterface = g_dbus_object_skeleton_remove_interface;

    /// Removes the `gio.DBusInterface` with `interface_name` from `object`.
    ///
    /// If no D-Bus interface of the given interface exists, this function
    /// does nothing.
    extern fn g_dbus_object_skeleton_remove_interface_by_name(p_object: *DBusObjectSkeleton, p_interface_name: [*:0]const u8) void;
    pub const removeInterfaceByName = g_dbus_object_skeleton_remove_interface_by_name;

    /// Sets the object path for `object`.
    extern fn g_dbus_object_skeleton_set_object_path(p_object: *DBusObjectSkeleton, p_object_path: [*:0]const u8) void;
    pub const setObjectPath = g_dbus_object_skeleton_set_object_path;

    extern fn g_dbus_object_skeleton_get_type() usize;
    pub const getGObjectType = g_dbus_object_skeleton_get_type;

    extern fn g_object_ref(p_self: *gio.DBusObjectSkeleton) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusObjectSkeleton) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusObjectSkeleton, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GDBusProxy` is a base class used for proxies to access a D-Bus
/// interface on a remote object. A `GDBusProxy` can be constructed for
/// both well-known and unique names.
///
/// By default, `GDBusProxy` will cache all properties (and listen to
/// changes) of the remote object, and proxy all signals that get
/// emitted. This behaviour can be changed by passing suitable
/// `gio.DBusProxyFlags` when the proxy is created. If the proxy is for a
/// well-known name, the property cache is flushed when the name owner
/// vanishes and reloaded when a name owner appears.
///
/// The unique name owner of the proxy’s name is tracked and can be read from
/// `gio.DBusProxy.properties.g_name_owner`. Connect to the
/// `gobject.Object.signals.notify` signal to get notified of changes.
/// Additionally, only signals and property changes emitted from the current name
/// owner are considered and calls are always sent to the current name owner.
/// This avoids a number of race conditions when the name is lost by one owner
/// and claimed by another. However, if no name owner currently exists,
/// then calls will be sent to the well-known name which may result in
/// the message bus launching an owner (unless
/// `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START` is set).
///
/// If the proxy is for a stateless D-Bus service, where the name owner may
/// be started and stopped between calls, the
/// `gio.DBusProxy.properties.g_name_owner` tracking of `GDBusProxy` will cause the
/// proxy to drop signal and property changes from the service after it has
/// restarted for the first time. When interacting with a stateless D-Bus
/// service, do not use `GDBusProxy` — use direct D-Bus method calls and signal
/// connections.
///
/// The generic `gio.DBusProxy.signals.g_properties_changed` and
/// `gio.DBusProxy.signals.g_signal` signals are not very convenient to work
/// with. Therefore, the recommended way of working with proxies is to subclass
/// `GDBusProxy`, and have more natural properties and signals in your derived
/// class. This [example](migrating-gdbus.html`using`-gdbus-codegen) shows how
/// this can easily be done using the [`gdbus-codegen`](gdbus-codegen.html) tool.
///
/// A `GDBusProxy` instance can be used from multiple threads but note
/// that all signals (e.g. `gio.DBusProxy.signals.g_signal`,
/// `gio.DBusProxy.signals.g_properties_changed` and
/// `gobject.Object.signals.notify`) are emitted in the thread-default main
/// context (see `glib.MainContext.pushThreadDefault`) of the thread
/// where the instance was constructed.
///
///
/// ## A watch proxy example
/// An example using a proxy for a well-known name can be found in
/// [`gdbus-example-watch-proxy.c`](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-watch-proxy.c).
pub const DBusProxy = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gio.AsyncInitable, gio.DBusInterface, gio.Initable };
    pub const Class = gio.DBusProxyClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.DBusProxyPrivate,

    pub const virtual_methods = struct {
        /// Signal class handler for the `gio.DBusProxy.signals.g`-properties-changed signal.
        pub const g_properties_changed = struct {
            pub fn call(p_class: anytype, p_proxy: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_changed_properties: *glib.Variant, p_invalidated_properties: *const [*:0]const u8) void {
                return gobject.ext.as(DBusProxy.Class, p_class).f_g_properties_changed.?(gobject.ext.as(DBusProxy, p_proxy), p_changed_properties, p_invalidated_properties);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_proxy: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_changed_properties: *glib.Variant, p_invalidated_properties: *const [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(DBusProxy.Class, p_class).f_g_properties_changed = @ptrCast(p_implementation);
            }
        };

        /// Signal class handler for the `gio.DBusProxy.signals.g`-signal signal.
        pub const g_signal = struct {
            pub fn call(p_class: anytype, p_proxy: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_sender_name: [*:0]const u8, p_signal_name: [*:0]const u8, p_parameters: *glib.Variant) void {
                return gobject.ext.as(DBusProxy.Class, p_class).f_g_signal.?(gobject.ext.as(DBusProxy, p_proxy), p_sender_name, p_signal_name, p_parameters);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_proxy: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_sender_name: [*:0]const u8, p_signal_name: [*:0]const u8, p_parameters: *glib.Variant) callconv(.c) void) void {
                gobject.ext.as(DBusProxy.Class, p_class).f_g_signal = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// If this property is not `G_BUS_TYPE_NONE`, then
        /// `gio.DBusProxy.properties.g`-connection must be `NULL` and will be set to the
        /// `gio.DBusConnection` obtained by calling `gio.busGet` with the value
        /// of this property.
        pub const g_bus_type = struct {
            pub const name = "g-bus-type";

            pub const Type = gio.BusType;
        };

        /// The `gio.DBusConnection` the proxy is for.
        pub const g_connection = struct {
            pub const name = "g-connection";

            pub const Type = ?*gio.DBusConnection;
        };

        /// The timeout to use if -1 (specifying default timeout) is passed
        /// as `timeout_msec` in the `gio.DBusProxy.call` and
        /// `gio.DBusProxy.callSync` functions.
        ///
        /// This allows applications to set a proxy-wide timeout for all
        /// remote method invocations on the proxy. If this property is -1,
        /// the default timeout (typically 25 seconds) is used. If set to
        /// `G_MAXINT`, then no timeout is used.
        pub const g_default_timeout = struct {
            pub const name = "g-default-timeout";

            pub const Type = c_int;
        };

        /// Flags from the `gio.DBusProxyFlags` enumeration.
        pub const g_flags = struct {
            pub const name = "g-flags";

            pub const Type = gio.DBusProxyFlags;
        };

        /// Ensure that interactions with this proxy conform to the given
        /// interface. This is mainly to ensure that malformed data received
        /// from the other peer is ignored. The given `gio.DBusInterfaceInfo` is
        /// said to be the "expected interface".
        ///
        /// The checks performed are:
        /// - When completing a method call, if the type signature of
        ///   the reply message isn't what's expected, the reply is
        ///   discarded and the `glib.Error` is set to `G_IO_ERROR_INVALID_ARGUMENT`.
        ///
        /// - Received signals that have a type signature mismatch are dropped and
        ///   a warning is logged via `g_warning`.
        ///
        /// - Properties received via the initial ``GetAll`` call or via the
        ///   `::PropertiesChanged` signal (on the
        ///   [org.freedesktop.DBus.Properties](http://dbus.freedesktop.org/doc/dbus-specification.html`standard`-interfaces-properties)
        ///   interface) or set using `gio.DBusProxy.setCachedProperty`
        ///   with a type signature mismatch are ignored and a warning is
        ///   logged via `g_warning`.
        ///
        /// Note that these checks are never done on methods, signals and
        /// properties that are not referenced in the given
        /// `gio.DBusInterfaceInfo`, since extending a D-Bus interface on the
        /// service-side is not considered an ABI break.
        pub const g_interface_info = struct {
            pub const name = "g-interface-info";

            pub const Type = ?*gio.DBusInterfaceInfo;
        };

        /// The D-Bus interface name the proxy is for.
        pub const g_interface_name = struct {
            pub const name = "g-interface-name";

            pub const Type = ?[*:0]u8;
        };

        /// The well-known or unique name that the proxy is for.
        pub const g_name = struct {
            pub const name = "g-name";

            pub const Type = ?[*:0]u8;
        };

        /// The unique name that owns `gio.DBusProxy.properties.g`-name or `NULL` if no-one
        /// currently owns that name. You may connect to `gobject.Object.signals.notify` signal to
        /// track changes to this property.
        pub const g_name_owner = struct {
            pub const name = "g-name-owner";

            pub const Type = ?[*:0]u8;
        };

        /// The object path the proxy is for.
        pub const g_object_path = struct {
            pub const name = "g-object-path";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {
        /// Emitted when one or more D-Bus properties on `proxy` changes. The
        /// local cache has already been updated when this signal fires. Note
        /// that both `changed_properties` and `invalidated_properties` are
        /// guaranteed to never be `NULL` (either may be empty though).
        ///
        /// If the proxy has the flag
        /// `G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES` set, then
        /// `invalidated_properties` will always be empty.
        ///
        /// This signal corresponds to the
        /// `PropertiesChanged` D-Bus signal on the
        /// `org.freedesktop.DBus.Properties` interface.
        pub const g_properties_changed = struct {
            pub const name = "g-properties-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_changed_properties: *glib.Variant, p_invalidated_properties: [*][*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusProxy, p_instance))),
                    gobject.signalLookup("g-properties-changed", DBusProxy.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when a signal from the remote object and interface that `proxy` is for, has been received.
        ///
        /// Since 2.72 this signal supports detailed connections. You can connect to
        /// the detailed signal `g-signal::x` in order to receive callbacks only when
        /// signal `x` is received from the remote object.
        pub const g_signal = struct {
            pub const name = "g-signal";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_sender_name: ?[*:0]u8, p_signal_name: [*:0]u8, p_parameters: *glib.Variant, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusProxy, p_instance))),
                    gobject.signalLookup("g-signal", DBusProxy.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a proxy for accessing `interface_name` on the remote object
    /// at `object_path` owned by `name` at `connection` and asynchronously
    /// loads D-Bus properties unless the
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES` flag is used. Connect to
    /// the `gio.DBusProxy.signals.g`-properties-changed signal to get notified about
    /// property changes.
    ///
    /// If the `G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS` flag is not set, also sets up
    /// match rules for signals. Connect to the `gio.DBusProxy.signals.g`-signal signal
    /// to handle signals from the remote object.
    ///
    /// If both `G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES` and
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS` are set, this constructor is
    /// guaranteed to complete immediately without blocking.
    ///
    /// If `name` is a well-known name and the
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START` and `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION`
    /// flags aren't set and no name owner currently exists, the message bus
    /// will be requested to launch a name owner for the name.
    ///
    /// This is a failable asynchronous constructor - when the proxy is
    /// ready, `callback` will be invoked and you can use
    /// `gio.DBusProxy.newFinish` to get the result.
    ///
    /// See `gio.DBusProxy.newSync` and for a synchronous version of this constructor.
    ///
    /// `gio.DBusProxy` is used in this [example]`gio.@"DBusProxy#a-watch-proxy-example"`.
    extern fn g_dbus_proxy_new(p_connection: *gio.DBusConnection, p_flags: gio.DBusProxyFlags, p_info: ?*gio.DBusInterfaceInfo, p_name: ?[*:0]const u8, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const new = g_dbus_proxy_new;

    /// Like `gio.DBusProxy.new` but takes a `gio.BusType` instead of a `gio.DBusConnection`.
    ///
    /// `gio.DBusProxy` is used in this [example]`gio.@"DBusProxy#a-watch-proxy-example"`.
    extern fn g_dbus_proxy_new_for_bus(p_bus_type: gio.BusType, p_flags: gio.DBusProxyFlags, p_info: ?*gio.DBusInterfaceInfo, p_name: [*:0]const u8, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const newForBus = g_dbus_proxy_new_for_bus;

    /// Finishes creating a `gio.DBusProxy`.
    extern fn g_dbus_proxy_new_finish(p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.DBusProxy;
    pub const newFinish = g_dbus_proxy_new_finish;

    /// Finishes creating a `gio.DBusProxy`.
    extern fn g_dbus_proxy_new_for_bus_finish(p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.DBusProxy;
    pub const newForBusFinish = g_dbus_proxy_new_for_bus_finish;

    /// Like `gio.DBusProxy.newSync` but takes a `gio.BusType` instead of a `gio.DBusConnection`.
    ///
    /// `gio.DBusProxy` is used in this [example]`gio.@"DBusProxy#a-watch-proxy-example"`.
    extern fn g_dbus_proxy_new_for_bus_sync(p_bus_type: gio.BusType, p_flags: gio.DBusProxyFlags, p_info: ?*gio.DBusInterfaceInfo, p_name: [*:0]const u8, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.DBusProxy;
    pub const newForBusSync = g_dbus_proxy_new_for_bus_sync;

    /// Creates a proxy for accessing `interface_name` on the remote object
    /// at `object_path` owned by `name` at `connection` and synchronously
    /// loads D-Bus properties unless the
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES` flag is used.
    ///
    /// If the `G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS` flag is not set, also sets up
    /// match rules for signals. Connect to the `gio.DBusProxy.signals.g`-signal signal
    /// to handle signals from the remote object.
    ///
    /// If both `G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES` and
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS` are set, this constructor is
    /// guaranteed to return immediately without blocking.
    ///
    /// If `name` is a well-known name and the
    /// `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START` and `G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION`
    /// flags aren't set and no name owner currently exists, the message bus
    /// will be requested to launch a name owner for the name.
    ///
    /// This is a synchronous failable constructor. See `gio.DBusProxy.new`
    /// and `gio.DBusProxy.newFinish` for the asynchronous version.
    ///
    /// `gio.DBusProxy` is used in this [example]`gio.@"DBusProxy#a-watch-proxy-example"`.
    extern fn g_dbus_proxy_new_sync(p_connection: *gio.DBusConnection, p_flags: gio.DBusProxyFlags, p_info: ?*gio.DBusInterfaceInfo, p_name: ?[*:0]const u8, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.DBusProxy;
    pub const newSync = g_dbus_proxy_new_sync;

    /// Asynchronously invokes the `method_name` method on `proxy`.
    ///
    /// If `method_name` contains any dots, then `name` is split into interface and
    /// method name parts. This allows using `proxy` for invoking methods on
    /// other interfaces.
    ///
    /// If the `gio.DBusConnection` associated with `proxy` is closed then
    /// the operation will fail with `G_IO_ERROR_CLOSED`. If
    /// `cancellable` is canceled, the operation will fail with
    /// `G_IO_ERROR_CANCELLED`. If `parameters` contains a value not
    /// compatible with the D-Bus protocol, the operation fails with
    /// `G_IO_ERROR_INVALID_ARGUMENT`.
    ///
    /// If the `parameters` `glib.Variant` is floating, it is consumed. This allows
    /// convenient 'inline' use of `glib.Variant.new`, e.g.:
    /// ```
    ///  g_dbus_proxy_call (proxy,
    ///                     "TwoStrings",
    ///                     g_variant_new ("(ss)",
    ///                                    "Thing One",
    ///                                    "Thing Two"),
    ///                     G_DBUS_CALL_FLAGS_NONE,
    ///                     -1,
    ///                     NULL,
    ///                     (GAsyncReadyCallback) two_strings_done,
    ///                     &data);
    /// ```
    ///
    /// If `proxy` has an expected interface (see
    /// `gio.DBusProxy.properties.g`-interface-info) and `method_name` is referenced by it,
    /// then the return value is checked against the return type.
    ///
    /// This is an asynchronous method. When the operation is finished,
    /// `callback` will be invoked in the thread-default main context
    /// (see `glib.MainContext.pushThreadDefault`)
    /// of the thread you are calling this method from.
    /// You can then call `gio.DBusProxy.callFinish` to get the result of
    /// the operation. See `gio.DBusProxy.callSync` for the synchronous
    /// version of this method.
    ///
    /// If `callback` is `NULL` then the D-Bus method call message will be sent with
    /// the `G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED` flag set.
    extern fn g_dbus_proxy_call(p_proxy: *DBusProxy, p_method_name: [*:0]const u8, p_parameters: ?*glib.Variant, p_flags: gio.DBusCallFlags, p_timeout_msec: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const call = g_dbus_proxy_call;

    /// Finishes an operation started with `gio.DBusProxy.call`.
    extern fn g_dbus_proxy_call_finish(p_proxy: *DBusProxy, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.Variant;
    pub const callFinish = g_dbus_proxy_call_finish;

    /// Synchronously invokes the `method_name` method on `proxy`.
    ///
    /// If `method_name` contains any dots, then `name` is split into interface and
    /// method name parts. This allows using `proxy` for invoking methods on
    /// other interfaces.
    ///
    /// If the `gio.DBusConnection` associated with `proxy` is disconnected then
    /// the operation will fail with `G_IO_ERROR_CLOSED`. If
    /// `cancellable` is canceled, the operation will fail with
    /// `G_IO_ERROR_CANCELLED`. If `parameters` contains a value not
    /// compatible with the D-Bus protocol, the operation fails with
    /// `G_IO_ERROR_INVALID_ARGUMENT`.
    ///
    /// If the `parameters` `glib.Variant` is floating, it is consumed. This allows
    /// convenient 'inline' use of `glib.Variant.new`, e.g.:
    /// ```
    ///  g_dbus_proxy_call_sync (proxy,
    ///                          "TwoStrings",
    ///                          g_variant_new ("(ss)",
    ///                                         "Thing One",
    ///                                         "Thing Two"),
    ///                          G_DBUS_CALL_FLAGS_NONE,
    ///                          -1,
    ///                          NULL,
    ///                          &error);
    /// ```
    ///
    /// The calling thread is blocked until a reply is received. See
    /// `gio.DBusProxy.call` for the asynchronous version of this
    /// method.
    ///
    /// If `proxy` has an expected interface (see
    /// `gio.DBusProxy.properties.g`-interface-info) and `method_name` is referenced by it,
    /// then the return value is checked against the return type.
    extern fn g_dbus_proxy_call_sync(p_proxy: *DBusProxy, p_method_name: [*:0]const u8, p_parameters: ?*glib.Variant, p_flags: gio.DBusCallFlags, p_timeout_msec: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.Variant;
    pub const callSync = g_dbus_proxy_call_sync;

    /// Like `gio.DBusProxy.call` but also takes a `gio.UnixFDList` object.
    ///
    /// This method is only available on UNIX.
    extern fn g_dbus_proxy_call_with_unix_fd_list(p_proxy: *DBusProxy, p_method_name: [*:0]const u8, p_parameters: ?*glib.Variant, p_flags: gio.DBusCallFlags, p_timeout_msec: c_int, p_fd_list: ?*gio.UnixFDList, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const callWithUnixFdList = g_dbus_proxy_call_with_unix_fd_list;

    /// Finishes an operation started with `gio.DBusProxy.callWithUnixFdList`.
    extern fn g_dbus_proxy_call_with_unix_fd_list_finish(p_proxy: *DBusProxy, p_out_fd_list: ?**gio.UnixFDList, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.Variant;
    pub const callWithUnixFdListFinish = g_dbus_proxy_call_with_unix_fd_list_finish;

    /// Like `gio.DBusProxy.callSync` but also takes and returns `gio.UnixFDList` objects.
    ///
    /// This method is only available on UNIX.
    extern fn g_dbus_proxy_call_with_unix_fd_list_sync(p_proxy: *DBusProxy, p_method_name: [*:0]const u8, p_parameters: ?*glib.Variant, p_flags: gio.DBusCallFlags, p_timeout_msec: c_int, p_fd_list: ?*gio.UnixFDList, p_out_fd_list: ?**gio.UnixFDList, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.Variant;
    pub const callWithUnixFdListSync = g_dbus_proxy_call_with_unix_fd_list_sync;

    /// Looks up the value for a property from the cache. This call does no
    /// blocking IO.
    ///
    /// If `proxy` has an expected interface (see
    /// `gio.DBusProxy.properties.g`-interface-info) and `property_name` is referenced by
    /// it, then `value` is checked against the type of the property.
    extern fn g_dbus_proxy_get_cached_property(p_proxy: *DBusProxy, p_property_name: [*:0]const u8) ?*glib.Variant;
    pub const getCachedProperty = g_dbus_proxy_get_cached_property;

    /// Gets the names of all cached properties on `proxy`.
    extern fn g_dbus_proxy_get_cached_property_names(p_proxy: *DBusProxy) ?[*][*:0]u8;
    pub const getCachedPropertyNames = g_dbus_proxy_get_cached_property_names;

    /// Gets the connection `proxy` is for.
    extern fn g_dbus_proxy_get_connection(p_proxy: *DBusProxy) *gio.DBusConnection;
    pub const getConnection = g_dbus_proxy_get_connection;

    /// Gets the timeout to use if -1 (specifying default timeout) is
    /// passed as `timeout_msec` in the `gio.DBusProxy.call` and
    /// `gio.DBusProxy.callSync` functions.
    ///
    /// See the `gio.DBusProxy.properties.g`-default-timeout property for more details.
    extern fn g_dbus_proxy_get_default_timeout(p_proxy: *DBusProxy) c_int;
    pub const getDefaultTimeout = g_dbus_proxy_get_default_timeout;

    /// Gets the flags that `proxy` was constructed with.
    extern fn g_dbus_proxy_get_flags(p_proxy: *DBusProxy) gio.DBusProxyFlags;
    pub const getFlags = g_dbus_proxy_get_flags;

    /// Returns the `gio.DBusInterfaceInfo`, if any, specifying the interface
    /// that `proxy` conforms to. See the `gio.DBusProxy.properties.g`-interface-info
    /// property for more details.
    extern fn g_dbus_proxy_get_interface_info(p_proxy: *DBusProxy) ?*gio.DBusInterfaceInfo;
    pub const getInterfaceInfo = g_dbus_proxy_get_interface_info;

    /// Gets the D-Bus interface name `proxy` is for.
    extern fn g_dbus_proxy_get_interface_name(p_proxy: *DBusProxy) [*:0]const u8;
    pub const getInterfaceName = g_dbus_proxy_get_interface_name;

    /// Gets the name that `proxy` was constructed for.
    ///
    /// When connected to a message bus, this will usually be non-`NULL`.
    /// However, it may be `NULL` for a proxy that communicates using a peer-to-peer
    /// pattern.
    extern fn g_dbus_proxy_get_name(p_proxy: *DBusProxy) ?[*:0]const u8;
    pub const getName = g_dbus_proxy_get_name;

    /// The unique name that owns the name that `proxy` is for or `NULL` if
    /// no-one currently owns that name. You may connect to the
    /// `gobject.Object.signals.notify` signal to track changes to the
    /// `gio.DBusProxy.properties.g`-name-owner property.
    extern fn g_dbus_proxy_get_name_owner(p_proxy: *DBusProxy) ?[*:0]u8;
    pub const getNameOwner = g_dbus_proxy_get_name_owner;

    /// Gets the object path `proxy` is for.
    extern fn g_dbus_proxy_get_object_path(p_proxy: *DBusProxy) [*:0]const u8;
    pub const getObjectPath = g_dbus_proxy_get_object_path;

    /// If `value` is not `NULL`, sets the cached value for the property with
    /// name `property_name` to the value in `value`.
    ///
    /// If `value` is `NULL`, then the cached value is removed from the
    /// property cache.
    ///
    /// If `proxy` has an expected interface (see
    /// `gio.DBusProxy.properties.g`-interface-info) and `property_name` is referenced by
    /// it, then `value` is checked against the type of the property.
    ///
    /// If the `value` `glib.Variant` is floating, it is consumed. This allows
    /// convenient 'inline' use of `glib.Variant.new`, e.g.
    /// ```
    ///  g_dbus_proxy_set_cached_property (proxy,
    ///                                    "SomeProperty",
    ///                                    g_variant_new ("(si)",
    ///                                                  "A String",
    ///                                                  42));
    /// ```
    ///
    /// Normally you will not need to use this method since `proxy`
    /// is tracking changes using the
    /// `org.freedesktop.DBus.Properties.PropertiesChanged`
    /// D-Bus signal. However, for performance reasons an object may
    /// decide to not use this signal for some properties and instead
    /// use a proprietary out-of-band mechanism to transmit changes.
    ///
    /// As a concrete example, consider an object with a property
    /// `ChatroomParticipants` which is an array of strings. Instead of
    /// transmitting the same (long) array every time the property changes,
    /// it is more efficient to only transmit the delta using e.g. signals
    /// `ChatroomParticipantJoined(String name)` and
    /// `ChatroomParticipantParted(String name)`.
    extern fn g_dbus_proxy_set_cached_property(p_proxy: *DBusProxy, p_property_name: [*:0]const u8, p_value: ?*glib.Variant) void;
    pub const setCachedProperty = g_dbus_proxy_set_cached_property;

    /// Sets the timeout to use if -1 (specifying default timeout) is
    /// passed as `timeout_msec` in the `gio.DBusProxy.call` and
    /// `gio.DBusProxy.callSync` functions.
    ///
    /// See the `gio.DBusProxy.properties.g`-default-timeout property for more details.
    extern fn g_dbus_proxy_set_default_timeout(p_proxy: *DBusProxy, p_timeout_msec: c_int) void;
    pub const setDefaultTimeout = g_dbus_proxy_set_default_timeout;

    /// Ensure that interactions with `proxy` conform to the given
    /// interface. See the `gio.DBusProxy.properties.g`-interface-info property for more
    /// details.
    extern fn g_dbus_proxy_set_interface_info(p_proxy: *DBusProxy, p_info: ?*gio.DBusInterfaceInfo) void;
    pub const setInterfaceInfo = g_dbus_proxy_set_interface_info;

    extern fn g_dbus_proxy_get_type() usize;
    pub const getGObjectType = g_dbus_proxy_get_type;

    extern fn g_object_ref(p_self: *gio.DBusProxy) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusProxy) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusProxy, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GDBusServer` is a helper for listening to and accepting D-Bus
/// connections. This can be used to create a new D-Bus server, allowing two
/// peers to use the D-Bus protocol for their own specialized communication.
/// A server instance provided in this way will not perform message routing or
/// implement the
/// [`org.freedesktop.DBus` interface](https://dbus.freedesktop.org/doc/dbus-specification.html`message`-bus-messages).
///
/// To just export an object on a well-known name on a message bus, such as the
/// session or system bus, you should instead use `gio.busOwnName`.
///
/// An example of peer-to-peer communication with GDBus can be found
/// in [gdbus-example-peer.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).
///
/// Note that a minimal `GDBusServer` will accept connections from any
/// peer. In many use-cases it will be necessary to add a
/// `gio.DBusAuthObserver` that only accepts connections that have
/// successfully authenticated as the same user that is running the
/// `GDBusServer`. Since GLib 2.68 this can be achieved more simply by passing
/// the `G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER` flag to the
/// server.
pub const DBusServer = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.Initable};
    pub const Class = opaque {
        pub const Instance = DBusServer;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Whether the server is currently active.
        pub const active = struct {
            pub const name = "active";

            pub const Type = c_int;
        };

        /// The D-Bus address to listen on.
        pub const address = struct {
            pub const name = "address";

            pub const Type = ?[*:0]u8;
        };

        /// A `gio.DBusAuthObserver` object to assist in the authentication process or `NULL`.
        pub const authentication_observer = struct {
            pub const name = "authentication-observer";

            pub const Type = ?*gio.DBusAuthObserver;
        };

        /// The D-Bus address that clients can use.
        pub const client_address = struct {
            pub const name = "client-address";

            pub const Type = ?[*:0]u8;
        };

        /// Flags from the `gio.DBusServerFlags` enumeration.
        pub const flags = struct {
            pub const name = "flags";

            pub const Type = gio.DBusServerFlags;
        };

        /// The GUID of the server.
        ///
        /// See `gio.DBusConnection.properties.guid` for more details.
        pub const guid = struct {
            pub const name = "guid";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {
        /// Emitted when a new authenticated connection has been made. Use
        /// `gio.DBusConnection.getPeerCredentials` to figure out what
        /// identity (if any), was authenticated.
        ///
        /// If you want to accept the connection, take a reference to the
        /// `connection` object and return `TRUE`. When you are done with the
        /// connection call `gio.DBusConnection.close` and give up your
        /// reference. Note that the other peer may disconnect at any time -
        /// a typical thing to do when accepting a connection is to listen to
        /// the `gio.DBusConnection.signals.closed` signal.
        ///
        /// If `gio.DBusServer.properties.flags` contains `G_DBUS_SERVER_FLAGS_RUN_IN_THREAD`
        /// then the signal is emitted in a new thread dedicated to the
        /// connection. Otherwise the signal is emitted in the thread-default
        /// main context (see `glib.MainContext.pushThreadDefault`)
        /// of the thread that `server` was constructed in.
        ///
        /// You are guaranteed that signal handlers for this signal runs
        /// before incoming messages on `connection` are processed. This means
        /// that it's suitable to call `gio.DBusConnection.registerObject` or
        /// similar from the signal handler.
        pub const new_connection = struct {
            pub const name = "new-connection";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_connection: *gio.DBusConnection, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusServer, p_instance))),
                    gobject.signalLookup("new-connection", DBusServer.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new D-Bus server that listens on the first address in
    /// `address` that works.
    ///
    /// Once constructed, you can use `gio.DBusServer.getClientAddress` to
    /// get a D-Bus address string that clients can use to connect.
    ///
    /// To have control over the available authentication mechanisms and
    /// the users that are authorized to connect, it is strongly recommended
    /// to provide a non-`NULL` `gio.DBusAuthObserver`.
    ///
    /// Connect to the `gio.DBusServer.signals.new`-connection signal to handle
    /// incoming connections.
    ///
    /// The returned `gio.DBusServer` isn't active - you have to start it with
    /// `gio.DBusServer.start`.
    ///
    /// `gio.DBusServer` is used in this [example](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).
    ///
    /// This is a synchronous failable constructor. There is currently no
    /// asynchronous version.
    extern fn g_dbus_server_new_sync(p_address: [*:0]const u8, p_flags: gio.DBusServerFlags, p_guid: [*:0]const u8, p_observer: ?*gio.DBusAuthObserver, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.DBusServer;
    pub const newSync = g_dbus_server_new_sync;

    /// Gets a
    /// [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`)
    /// string that can be used by clients to connect to `server`.
    ///
    /// This is valid and non-empty if initializing the `gio.DBusServer` succeeded.
    extern fn g_dbus_server_get_client_address(p_server: *DBusServer) [*:0]const u8;
    pub const getClientAddress = g_dbus_server_get_client_address;

    /// Gets the flags for `server`.
    extern fn g_dbus_server_get_flags(p_server: *DBusServer) gio.DBusServerFlags;
    pub const getFlags = g_dbus_server_get_flags;

    /// Gets the GUID for `server`, as provided to `gio.DBusServer.newSync`.
    extern fn g_dbus_server_get_guid(p_server: *DBusServer) [*:0]const u8;
    pub const getGuid = g_dbus_server_get_guid;

    /// Gets whether `server` is active.
    extern fn g_dbus_server_is_active(p_server: *DBusServer) c_int;
    pub const isActive = g_dbus_server_is_active;

    /// Starts `server`.
    extern fn g_dbus_server_start(p_server: *DBusServer) void;
    pub const start = g_dbus_server_start;

    /// Stops `server`.
    extern fn g_dbus_server_stop(p_server: *DBusServer) void;
    pub const stop = g_dbus_server_stop;

    extern fn g_dbus_server_get_type() usize;
    pub const getGObjectType = g_dbus_server_get_type;

    extern fn g_object_ref(p_self: *gio.DBusServer) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusServer) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusServer, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Data input stream implements `gio.InputStream` and includes functions
/// for reading structured data directly from a binary input stream.
pub const DataInputStream = extern struct {
    pub const Parent = gio.BufferedInputStream;
    pub const Implements = [_]type{gio.Seekable};
    pub const Class = gio.DataInputStreamClass;
    f_parent_instance: gio.BufferedInputStream,
    f_priv: ?*gio.DataInputStreamPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The :byte-order property determines the byte ordering that
        /// is used when reading multi-byte entities (such as integers)
        /// from the stream.
        pub const byte_order = struct {
            pub const name = "byte-order";

            pub const Type = gio.DataStreamByteOrder;
        };

        /// The :newline-type property determines what is considered
        /// as a line ending when reading complete lines from the stream.
        pub const newline_type = struct {
            pub const name = "newline-type";

            pub const Type = gio.DataStreamNewlineType;
        };
    };

    pub const signals = struct {};

    /// Creates a new data input stream for the `base_stream`.
    extern fn g_data_input_stream_new(p_base_stream: *gio.InputStream) *gio.DataInputStream;
    pub const new = g_data_input_stream_new;

    /// Gets the byte order for the data input stream.
    extern fn g_data_input_stream_get_byte_order(p_stream: *DataInputStream) gio.DataStreamByteOrder;
    pub const getByteOrder = g_data_input_stream_get_byte_order;

    /// Gets the current newline type for the `stream`.
    extern fn g_data_input_stream_get_newline_type(p_stream: *DataInputStream) gio.DataStreamNewlineType;
    pub const getNewlineType = g_data_input_stream_get_newline_type;

    /// Reads an unsigned 8-bit/1-byte value from `stream`.
    extern fn g_data_input_stream_read_byte(p_stream: *DataInputStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) u8;
    pub const readByte = g_data_input_stream_read_byte;

    /// Reads a 16-bit/2-byte value from `stream`.
    ///
    /// In order to get the correct byte order for this read operation,
    /// see `gio.DataInputStream.getByteOrder` and `gio.DataInputStream.setByteOrder`.
    extern fn g_data_input_stream_read_int16(p_stream: *DataInputStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) i16;
    pub const readInt16 = g_data_input_stream_read_int16;

    /// Reads a signed 32-bit/4-byte value from `stream`.
    ///
    /// In order to get the correct byte order for this read operation,
    /// see `gio.DataInputStream.getByteOrder` and `gio.DataInputStream.setByteOrder`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_data_input_stream_read_int32(p_stream: *DataInputStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) i32;
    pub const readInt32 = g_data_input_stream_read_int32;

    /// Reads a 64-bit/8-byte value from `stream`.
    ///
    /// In order to get the correct byte order for this read operation,
    /// see `gio.DataInputStream.getByteOrder` and `gio.DataInputStream.setByteOrder`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_data_input_stream_read_int64(p_stream: *DataInputStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) i64;
    pub const readInt64 = g_data_input_stream_read_int64;

    /// Reads a line from the data input stream.  Note that no encoding
    /// checks or conversion is performed; the input is not guaranteed to
    /// be UTF-8, and may in fact have embedded NUL characters.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_data_input_stream_read_line(p_stream: *DataInputStream, p_length: ?*usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?[*]u8;
    pub const readLine = g_data_input_stream_read_line;

    /// The asynchronous version of `gio.DataInputStream.readLine`.  It is
    /// an error to have two outstanding calls to this function.
    ///
    /// When the operation is finished, `callback` will be called. You
    /// can then call `gio.DataInputStream.readLineFinish` to get
    /// the result of the operation.
    extern fn g_data_input_stream_read_line_async(p_stream: *DataInputStream, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const readLineAsync = g_data_input_stream_read_line_async;

    /// Finish an asynchronous call started by
    /// `gio.DataInputStream.readLineAsync`.  Note the warning about
    /// string encoding in `gio.DataInputStream.readLine` applies here as
    /// well.
    extern fn g_data_input_stream_read_line_finish(p_stream: *DataInputStream, p_result: *gio.AsyncResult, p_length: ?*usize, p_error: ?*?*glib.Error) ?[*]u8;
    pub const readLineFinish = g_data_input_stream_read_line_finish;

    /// Finish an asynchronous call started by
    /// `gio.DataInputStream.readLineAsync`.
    extern fn g_data_input_stream_read_line_finish_utf8(p_stream: *DataInputStream, p_result: *gio.AsyncResult, p_length: ?*usize, p_error: ?*?*glib.Error) ?[*:0]u8;
    pub const readLineFinishUtf8 = g_data_input_stream_read_line_finish_utf8;

    /// Reads a UTF-8 encoded line from the data input stream.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_data_input_stream_read_line_utf8(p_stream: *DataInputStream, p_length: ?*usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?[*:0]u8;
    pub const readLineUtf8 = g_data_input_stream_read_line_utf8;

    /// Reads an unsigned 16-bit/2-byte value from `stream`.
    ///
    /// In order to get the correct byte order for this read operation,
    /// see `gio.DataInputStream.getByteOrder` and `gio.DataInputStream.setByteOrder`.
    extern fn g_data_input_stream_read_uint16(p_stream: *DataInputStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) u16;
    pub const readUint16 = g_data_input_stream_read_uint16;

    /// Reads an unsigned 32-bit/4-byte value from `stream`.
    ///
    /// In order to get the correct byte order for this read operation,
    /// see `gio.DataInputStream.getByteOrder` and `gio.DataInputStream.setByteOrder`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_data_input_stream_read_uint32(p_stream: *DataInputStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) u32;
    pub const readUint32 = g_data_input_stream_read_uint32;

    /// Reads an unsigned 64-bit/8-byte value from `stream`.
    ///
    /// In order to get the correct byte order for this read operation,
    /// see `gio.DataInputStream.getByteOrder`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_data_input_stream_read_uint64(p_stream: *DataInputStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) u64;
    pub const readUint64 = g_data_input_stream_read_uint64;

    /// Reads a string from the data input stream, up to the first
    /// occurrence of any of the stop characters.
    ///
    /// Note that, in contrast to `gio.DataInputStream.readUntilAsync`,
    /// this function consumes the stop character that it finds.
    ///
    /// Don't use this function in new code.  Its functionality is
    /// inconsistent with `gio.DataInputStream.readUntilAsync`.  Both
    /// functions will be marked as deprecated in a future release.  Use
    /// `gio.DataInputStream.readUpto` instead, but note that that function
    /// does not consume the stop character.
    extern fn g_data_input_stream_read_until(p_stream: *DataInputStream, p_stop_chars: [*:0]const u8, p_length: ?*usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?[*:0]u8;
    pub const readUntil = g_data_input_stream_read_until;

    /// The asynchronous version of `gio.DataInputStream.readUntil`.
    /// It is an error to have two outstanding calls to this function.
    ///
    /// Note that, in contrast to `gio.DataInputStream.readUntil`,
    /// this function does not consume the stop character that it finds.  You
    /// must read it for yourself.
    ///
    /// When the operation is finished, `callback` will be called. You
    /// can then call `gio.DataInputStream.readUntilFinish` to get
    /// the result of the operation.
    ///
    /// Don't use this function in new code.  Its functionality is
    /// inconsistent with `gio.DataInputStream.readUntil`.  Both functions
    /// will be marked as deprecated in a future release.  Use
    /// `gio.DataInputStream.readUptoAsync` instead.
    extern fn g_data_input_stream_read_until_async(p_stream: *DataInputStream, p_stop_chars: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const readUntilAsync = g_data_input_stream_read_until_async;

    /// Finish an asynchronous call started by
    /// `gio.DataInputStream.readUntilAsync`.
    extern fn g_data_input_stream_read_until_finish(p_stream: *DataInputStream, p_result: *gio.AsyncResult, p_length: ?*usize, p_error: ?*?*glib.Error) ?[*:0]u8;
    pub const readUntilFinish = g_data_input_stream_read_until_finish;

    /// Reads a string from the data input stream, up to the first
    /// occurrence of any of the stop characters.
    ///
    /// In contrast to `gio.DataInputStream.readUntil`, this function
    /// does not consume the stop character. You have to use
    /// `gio.DataInputStream.readByte` to get it before calling
    /// `gio.DataInputStream.readUpto` again.
    ///
    /// Note that `stop_chars` may contain '\0' if `stop_chars_len` is
    /// specified.
    ///
    /// The returned string will always be nul-terminated on success.
    extern fn g_data_input_stream_read_upto(p_stream: *DataInputStream, p_stop_chars: [*:0]const u8, p_stop_chars_len: isize, p_length: ?*usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?[*:0]u8;
    pub const readUpto = g_data_input_stream_read_upto;

    /// The asynchronous version of `gio.DataInputStream.readUpto`.
    /// It is an error to have two outstanding calls to this function.
    ///
    /// In contrast to `gio.DataInputStream.readUntil`, this function
    /// does not consume the stop character. You have to use
    /// `gio.DataInputStream.readByte` to get it before calling
    /// `gio.DataInputStream.readUpto` again.
    ///
    /// Note that `stop_chars` may contain '\0' if `stop_chars_len` is
    /// specified.
    ///
    /// When the operation is finished, `callback` will be called. You
    /// can then call `gio.DataInputStream.readUptoFinish` to get
    /// the result of the operation.
    extern fn g_data_input_stream_read_upto_async(p_stream: *DataInputStream, p_stop_chars: [*:0]const u8, p_stop_chars_len: isize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const readUptoAsync = g_data_input_stream_read_upto_async;

    /// Finish an asynchronous call started by
    /// `gio.DataInputStream.readUptoAsync`.
    ///
    /// Note that this function does not consume the stop character. You
    /// have to use `gio.DataInputStream.readByte` to get it before calling
    /// `gio.DataInputStream.readUptoAsync` again.
    ///
    /// The returned string will always be nul-terminated on success.
    extern fn g_data_input_stream_read_upto_finish(p_stream: *DataInputStream, p_result: *gio.AsyncResult, p_length: ?*usize, p_error: ?*?*glib.Error) ?[*:0]u8;
    pub const readUptoFinish = g_data_input_stream_read_upto_finish;

    /// This function sets the byte order for the given `stream`. All subsequent
    /// reads from the `stream` will be read in the given `order`.
    extern fn g_data_input_stream_set_byte_order(p_stream: *DataInputStream, p_order: gio.DataStreamByteOrder) void;
    pub const setByteOrder = g_data_input_stream_set_byte_order;

    /// Sets the newline type for the `stream`.
    ///
    /// Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read
    /// chunk ends in "CR" we must read an additional byte to know if this is "CR" or
    /// "CR LF", and this might block if there is no more data available.
    extern fn g_data_input_stream_set_newline_type(p_stream: *DataInputStream, p_type: gio.DataStreamNewlineType) void;
    pub const setNewlineType = g_data_input_stream_set_newline_type;

    extern fn g_data_input_stream_get_type() usize;
    pub const getGObjectType = g_data_input_stream_get_type;

    extern fn g_object_ref(p_self: *gio.DataInputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DataInputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DataInputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Data output stream implements `gio.OutputStream` and includes functions
/// for writing data directly to an output stream.
pub const DataOutputStream = extern struct {
    pub const Parent = gio.FilterOutputStream;
    pub const Implements = [_]type{gio.Seekable};
    pub const Class = gio.DataOutputStreamClass;
    f_parent_instance: gio.FilterOutputStream,
    f_priv: ?*gio.DataOutputStreamPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Determines the byte ordering that is used when writing
        /// multi-byte entities (such as integers) to the stream.
        pub const byte_order = struct {
            pub const name = "byte-order";

            pub const Type = gio.DataStreamByteOrder;
        };
    };

    pub const signals = struct {};

    /// Creates a new data output stream for `base_stream`.
    extern fn g_data_output_stream_new(p_base_stream: *gio.OutputStream) *gio.DataOutputStream;
    pub const new = g_data_output_stream_new;

    /// Gets the byte order for the stream.
    extern fn g_data_output_stream_get_byte_order(p_stream: *DataOutputStream) gio.DataStreamByteOrder;
    pub const getByteOrder = g_data_output_stream_get_byte_order;

    /// Puts a byte into the output stream.
    extern fn g_data_output_stream_put_byte(p_stream: *DataOutputStream, p_data: u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const putByte = g_data_output_stream_put_byte;

    /// Puts a signed 16-bit integer into the output stream.
    extern fn g_data_output_stream_put_int16(p_stream: *DataOutputStream, p_data: i16, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const putInt16 = g_data_output_stream_put_int16;

    /// Puts a signed 32-bit integer into the output stream.
    extern fn g_data_output_stream_put_int32(p_stream: *DataOutputStream, p_data: i32, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const putInt32 = g_data_output_stream_put_int32;

    /// Puts a signed 64-bit integer into the stream.
    extern fn g_data_output_stream_put_int64(p_stream: *DataOutputStream, p_data: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const putInt64 = g_data_output_stream_put_int64;

    /// Puts a string into the output stream.
    extern fn g_data_output_stream_put_string(p_stream: *DataOutputStream, p_str: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const putString = g_data_output_stream_put_string;

    /// Puts an unsigned 16-bit integer into the output stream.
    extern fn g_data_output_stream_put_uint16(p_stream: *DataOutputStream, p_data: u16, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const putUint16 = g_data_output_stream_put_uint16;

    /// Puts an unsigned 32-bit integer into the stream.
    extern fn g_data_output_stream_put_uint32(p_stream: *DataOutputStream, p_data: u32, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const putUint32 = g_data_output_stream_put_uint32;

    /// Puts an unsigned 64-bit integer into the stream.
    extern fn g_data_output_stream_put_uint64(p_stream: *DataOutputStream, p_data: u64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const putUint64 = g_data_output_stream_put_uint64;

    /// Sets the byte order of the data output stream to `order`.
    extern fn g_data_output_stream_set_byte_order(p_stream: *DataOutputStream, p_order: gio.DataStreamByteOrder) void;
    pub const setByteOrder = g_data_output_stream_set_byte_order;

    extern fn g_data_output_stream_get_type() usize;
    pub const getGObjectType = g_data_output_stream_get_type;

    extern fn g_object_ref(p_self: *gio.DataOutputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DataOutputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DataOutputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GDebugControllerDBus` is an implementation of `gio.DebugController`
/// which exposes debug settings as a D-Bus object.
///
/// It is a `gio.Initable` object, and will register an object at
/// `/org/gtk/Debugging` on the bus given as
/// `gio.DebugControllerDBus.properties.connection` once it’s initialized. The
/// object will be unregistered when the last reference to the
/// `GDebugControllerDBus` is dropped.
///
/// This D-Bus object can be used by remote processes to enable or disable debug
/// output in this process. Remote processes calling
/// `org.gtk.Debugging.`SetDebugEnabled`` will affect the value of
/// `gio.DebugController.properties.debug_enabled` and, by default,
/// `glib.logGetDebugEnabled`.
///
/// By default, no processes are allowed to call ``SetDebugEnabled`` unless a
/// `gio.DebugControllerDBus.signals.authorize` signal handler is installed. This
/// is because the process may be privileged, or might expose sensitive
/// information in its debug output. You may want to restrict the ability to
/// enable debug output to privileged users or processes.
///
/// One option is to install a D-Bus security policy which restricts access to
/// ``SetDebugEnabled``, installing something like the following in
/// `$datadir/dbus-1/system.d/`:
///
/// ```xml
/// <?xml version="1.0"?> <!--*-nxml-*-->
/// <!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
///      "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
/// <busconfig>
///   <policy user="root">
///     <allow send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
///   </policy>
///   <policy context="default">
///     <deny send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
///   </policy>
/// </busconfig>
/// ```
///
/// This will prevent the ``SetDebugEnabled`` method from being called by all
/// except root. It will not prevent the `DebugEnabled` property from being read,
/// as it’s accessed through the `org.freedesktop.DBus.Properties` interface.
///
/// Another option is to use polkit to allow or deny requests on a case-by-case
/// basis, allowing for the possibility of dynamic authorisation. To do this,
/// connect to the `gio.DebugControllerDBus.signals.authorize` signal and query
/// polkit in it:
///
/// ```c
///   g_autoptr(GError) child_error = NULL;
///   g_autoptr(GDBusConnection) connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
///   gulong debug_controller_authorize_id = 0;
///
///   // Set up the debug controller.
///   debug_controller = G_DEBUG_CONTROLLER (g_debug_controller_dbus_new (priv->connection, NULL, &child_error));
///   if (debug_controller == NULL)
///     {
///       g_error ("Could not register debug controller on bus: `s`",
///                child_error->message);
///     }
///
///   debug_controller_authorize_id = g_signal_connect (debug_controller,
///                                                     "authorize",
///                                                     G_CALLBACK (debug_controller_authorize_cb),
///                                                     self);
///
///   static gboolean
///   debug_controller_authorize_cb (GDebugControllerDBus  *debug_controller,
///                                  GDBusMethodInvocation *invocation,
///                                  gpointer               user_data)
///   {
///     g_autoptr(PolkitAuthority) authority = NULL;
///     g_autoptr(PolkitSubject) subject = NULL;
///     g_autoptr(PolkitAuthorizationResult) auth_result = NULL;
///     g_autoptr(GError) local_error = NULL;
///     GDBusMessage *message;
///     GDBusMessageFlags message_flags;
///     PolkitCheckAuthorizationFlags flags = POLKIT_CHECK_AUTHORIZATION_FLAGS_NONE;
///
///     message = g_dbus_method_invocation_get_message (invocation);
///     message_flags = g_dbus_message_get_flags (message);
///
///     authority = polkit_authority_get_sync (NULL, &local_error);
///     if (authority == NULL)
///       {
///         g_warning ("Failed to get polkit authority: `s`", local_error->message);
///         return FALSE;
///       }
///
///     if (message_flags & G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION)
///       flags |= POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION;
///
///     subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (invocation));
///
///     auth_result = polkit_authority_check_authorization_sync (authority,
///                                                              subject,
///                                                              "com.example.MyService.set-debug-enabled",
///                                                              NULL,
///                                                              flags,
///                                                              NULL,
///                                                              &local_error);
///     if (auth_result == NULL)
///       {
///         g_warning ("Failed to get check polkit authorization: `s`", local_error->message);
///         return FALSE;
///       }
///
///     return polkit_authorization_result_get_is_authorized (auth_result);
///   }
/// ```
pub const DebugControllerDBus = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gio.DebugController, gio.Initable };
    pub const Class = gio.DebugControllerDBusClass;
    f_parent_instance: gobject.Object,

    pub const virtual_methods = struct {
        /// Default handler for the `gio.DebugControllerDBus.signals.authorize` signal.
        pub const authorize = struct {
            pub fn call(p_class: anytype, p_controller: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_invocation: *gio.DBusMethodInvocation) c_int {
                return gobject.ext.as(DebugControllerDBus.Class, p_class).f_authorize.?(gobject.ext.as(DebugControllerDBus, p_controller), p_invocation);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_controller: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_invocation: *gio.DBusMethodInvocation) callconv(.c) c_int) void {
                gobject.ext.as(DebugControllerDBus.Class, p_class).f_authorize = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The D-Bus connection to expose the debugging interface on.
        ///
        /// Typically this will be the same connection (to the system or session bus)
        /// which the rest of the application or service’s D-Bus objects are registered
        /// on.
        pub const connection = struct {
            pub const name = "connection";

            pub const Type = ?*gio.DBusConnection;
        };
    };

    pub const signals = struct {
        /// Emitted when a D-Bus peer is trying to change the debug settings and used
        /// to determine if that is authorized.
        ///
        /// This signal is emitted in a dedicated worker thread, so handlers are
        /// allowed to perform blocking I/O. This means that, for example, it is
        /// appropriate to call ``polkit_authority_check_authorization_sync`` to check
        /// authorization using polkit.
        ///
        /// If `FALSE` is returned then no further handlers are run and the request to
        /// change the debug settings is rejected.
        ///
        /// Otherwise, if `TRUE` is returned, signal emission continues. If no handlers
        /// return `FALSE`, then the debug settings are allowed to be changed.
        ///
        /// Signal handlers must not modify `invocation`, or cause it to return a value.
        ///
        /// The default class handler just returns `TRUE`.
        pub const authorize = struct {
            pub const name = "authorize";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_invocation: *gio.DBusMethodInvocation, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DebugControllerDBus, p_instance))),
                    gobject.signalLookup("authorize", DebugControllerDBus.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Create a new `gio.DebugControllerDBus` and synchronously initialize it.
    ///
    /// Initializing the object will export the debug object on `connection`. The
    /// object will remain registered until the last reference to the
    /// `gio.DebugControllerDBus` is dropped.
    ///
    /// Initialization may fail if registering the object on `connection` fails.
    extern fn g_debug_controller_dbus_new(p_connection: *gio.DBusConnection, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.DebugControllerDBus;
    pub const new = g_debug_controller_dbus_new;

    /// Stop the debug controller, unregistering its object from the bus.
    ///
    /// Any pending method calls to the object will complete successfully, but new
    /// ones will return an error. This method will block until all pending
    /// `gio.DebugControllerDBus.signals.authorize` signals have been handled. This is expected
    /// to not take long, as it will just be waiting for threads to join. If any
    /// `gio.DebugControllerDBus.signals.authorize` signal handlers are still executing in other
    /// threads, this will block until after they have returned.
    ///
    /// This method will be called automatically when the final reference to the
    /// `gio.DebugControllerDBus` is dropped. You may want to call it explicitly to know
    /// when the controller has been fully removed from the bus, or to break
    /// reference count cycles.
    ///
    /// Calling this method from within a `gio.DebugControllerDBus.signals.authorize` signal
    /// handler will cause a deadlock and must not be done.
    extern fn g_debug_controller_dbus_stop(p_self: *DebugControllerDBus) void;
    pub const stop = g_debug_controller_dbus_stop;

    extern fn g_debug_controller_dbus_get_type() usize;
    pub const getGObjectType = g_debug_controller_dbus_get_type;

    extern fn g_object_ref(p_self: *gio.DebugControllerDBus) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DebugControllerDBus) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DebugControllerDBus, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GDesktopAppInfo` is an implementation of `gio.AppInfo` based on
/// desktop files.
///
/// Note that `<gio/gdesktopappinfo.h>` belongs to the UNIX-specific
/// GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
/// file or the `GioUnix-2.0` GIR namespace when using it.
pub const DesktopAppInfo = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.AppInfo};
    pub const Class = gio.DesktopAppInfoClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The origin filename of this `gio.DesktopAppInfo`
        pub const filename = struct {
            pub const name = "filename";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Gets all applications that implement `interface`.
    ///
    /// An application implements an interface if that interface is listed in
    /// the `Implements` line of the desktop file of the application.
    extern fn g_desktop_app_info_get_implementations(p_interface: [*:0]const u8) *glib.List;
    pub const getImplementations = g_desktop_app_info_get_implementations;

    /// Searches desktop files for ones that match `search_string`.
    ///
    /// The return value is an array of strvs.  Each strv contains a list of
    /// applications that matched `search_string` with an equal score.  The
    /// outer list is sorted by score so that the first strv contains the
    /// best-matching applications, and so on.
    /// The algorithm for determining matches is undefined and may change at
    /// any time.
    ///
    /// None of the search results are subjected to the normal validation
    /// checks performed by `gio.DesktopAppInfo.new` (for example, checking that
    /// the executable referenced by a result exists), and so it is possible for
    /// `gio.DesktopAppInfo.new` to return `NULL` when passed an app ID returned
    /// by this function. It is expected that calling code will do this when
    /// subsequently creating a `gio.DesktopAppInfo` for each result.
    extern fn g_desktop_app_info_search(p_search_string: [*:0]const u8) [*][*][*:0]u8;
    pub const search = g_desktop_app_info_search;

    /// Sets the name of the desktop that the application is running in.
    ///
    /// This is used by `gio.AppInfo.shouldShow` and
    /// `gio.DesktopAppInfo.getShowIn` to evaluate the
    /// [`OnlyShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html`key`-onlyshowin)
    /// and [`NotShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html`key`-notshowin)
    /// keys.
    ///
    /// Should be called only once; subsequent calls are ignored.
    extern fn g_desktop_app_info_set_desktop_env(p_desktop_env: [*:0]const u8) void;
    pub const setDesktopEnv = g_desktop_app_info_set_desktop_env;

    /// Creates a new `gio.DesktopAppInfo` based on a desktop file ID.
    ///
    /// A desktop file ID is the basename of the desktop file, including the
    /// `.desktop` extension. GIO is looking for a desktop file with this name
    /// in the `applications` subdirectories of the XDG
    /// data directories (i.e. the directories specified in the `XDG_DATA_HOME`
    /// and `XDG_DATA_DIRS` environment variables). GIO also supports the
    /// prefix-to-subdirectory mapping that is described in the
    /// [Menu Spec](http://standards.freedesktop.org/menu-spec/latest/)
    /// (i.e. a desktop ID of `kde-foo.desktop` will match
    /// `/usr/share/applications/kde/foo.desktop`).
    extern fn g_desktop_app_info_new(p_desktop_id: [*:0]const u8) ?*gio.DesktopAppInfo;
    pub const new = g_desktop_app_info_new;

    /// Creates a new `gio.DesktopAppInfo`.
    extern fn g_desktop_app_info_new_from_filename(p_filename: [*:0]const u8) ?*gio.DesktopAppInfo;
    pub const newFromFilename = g_desktop_app_info_new_from_filename;

    /// Creates a new `gio.DesktopAppInfo`.
    extern fn g_desktop_app_info_new_from_keyfile(p_key_file: *glib.KeyFile) ?*gio.DesktopAppInfo;
    pub const newFromKeyfile = g_desktop_app_info_new_from_keyfile;

    /// Gets the user-visible display name of the
    /// [‘additional application actions’](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s11.html)
    /// specified by `action_name`.
    ///
    /// This corresponds to the `Name` key within the keyfile group for the
    /// action.
    extern fn g_desktop_app_info_get_action_name(p_info: *DesktopAppInfo, p_action_name: [*:0]const u8) [*:0]u8;
    pub const getActionName = g_desktop_app_info_get_action_name;

    /// Looks up a boolean value in the keyfile backing `info`.
    ///
    /// The `key` is looked up in the `Desktop Entry` group.
    extern fn g_desktop_app_info_get_boolean(p_info: *DesktopAppInfo, p_key: [*:0]const u8) c_int;
    pub const getBoolean = g_desktop_app_info_get_boolean;

    /// Gets the categories from the desktop file.
    extern fn g_desktop_app_info_get_categories(p_info: *DesktopAppInfo) ?[*:0]const u8;
    pub const getCategories = g_desktop_app_info_get_categories;

    /// When `info` was created from a known filename, return it.  In some
    /// situations such as a `gio.DesktopAppInfo` returned from
    /// `gio.DesktopAppInfo.newFromKeyfile`, this function will return `NULL`.
    extern fn g_desktop_app_info_get_filename(p_info: *DesktopAppInfo) ?[*:0]const u8;
    pub const getFilename = g_desktop_app_info_get_filename;

    /// Gets the generic name from the desktop file.
    extern fn g_desktop_app_info_get_generic_name(p_info: *DesktopAppInfo) ?[*:0]const u8;
    pub const getGenericName = g_desktop_app_info_get_generic_name;

    /// A desktop file is hidden if the
    /// [`Hidden` key](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html`key`-hidden)
    /// in it is set to `True`.
    extern fn g_desktop_app_info_get_is_hidden(p_info: *DesktopAppInfo) c_int;
    pub const getIsHidden = g_desktop_app_info_get_is_hidden;

    /// Gets the keywords from the desktop file.
    extern fn g_desktop_app_info_get_keywords(p_info: *DesktopAppInfo) [*]const [*:0]const u8;
    pub const getKeywords = g_desktop_app_info_get_keywords;

    /// Looks up a localized string value in the keyfile backing `info`
    /// translated to the current locale.
    ///
    /// The `key` is looked up in the `Desktop Entry` group.
    extern fn g_desktop_app_info_get_locale_string(p_info: *DesktopAppInfo, p_key: [*:0]const u8) ?[*:0]u8;
    pub const getLocaleString = g_desktop_app_info_get_locale_string;

    /// Gets the value of the
    /// [`NoDisplay` key](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html`key`-nodisplay)
    ///  which helps determine if the application info should be shown in menus. See
    /// `G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY` and `gio.AppInfo.shouldShow`.
    extern fn g_desktop_app_info_get_nodisplay(p_info: *DesktopAppInfo) c_int;
    pub const getNodisplay = g_desktop_app_info_get_nodisplay;

    /// Checks if the application info should be shown in menus that list available
    /// applications for a specific name of the desktop, based on the
    /// [`OnlyShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html`key`-onlyshowin)
    /// and [`NotShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html`key`-notshowin)
    /// keys.
    ///
    /// `desktop_env` should typically be given as `NULL`, in which case the
    /// `XDG_CURRENT_DESKTOP` environment variable is consulted.  If you want
    /// to override the default mechanism then you may specify `desktop_env`,
    /// but this is not recommended.
    ///
    /// Note that `gio.AppInfo.shouldShow` for `info` will include this check
    /// (with `NULL` for `desktop_env`) as well as additional checks.
    extern fn g_desktop_app_info_get_show_in(p_info: *DesktopAppInfo, p_desktop_env: ?[*:0]const u8) c_int;
    pub const getShowIn = g_desktop_app_info_get_show_in;

    /// Retrieves the `StartupWMClass` field from `info`. This represents the
    /// `WM_CLASS` property of the main window of the application, if launched
    /// through `info`.
    extern fn g_desktop_app_info_get_startup_wm_class(p_info: *DesktopAppInfo) ?[*:0]const u8;
    pub const getStartupWmClass = g_desktop_app_info_get_startup_wm_class;

    /// Looks up a string value in the keyfile backing `info`.
    ///
    /// The `key` is looked up in the `Desktop Entry` group.
    extern fn g_desktop_app_info_get_string(p_info: *DesktopAppInfo, p_key: [*:0]const u8) ?[*:0]u8;
    pub const getString = g_desktop_app_info_get_string;

    /// Looks up a string list value in the keyfile backing `info`.
    ///
    /// The `key` is looked up in the `Desktop Entry` group.
    extern fn g_desktop_app_info_get_string_list(p_info: *DesktopAppInfo, p_key: [*:0]const u8, p_length: ?*usize) [*:null]?[*:0]u8;
    pub const getStringList = g_desktop_app_info_get_string_list;

    /// Returns whether `key` exists in the `Desktop Entry` group
    /// of the keyfile backing `info`.
    extern fn g_desktop_app_info_has_key(p_info: *DesktopAppInfo, p_key: [*:0]const u8) c_int;
    pub const hasKey = g_desktop_app_info_has_key;

    /// Activates the named application action.
    ///
    /// You may only call this function on action names that were
    /// returned from `gio.DesktopAppInfo.listActions`.
    ///
    /// Note that if the main entry of the desktop file indicates that the
    /// application supports startup notification, and `launch_context` is
    /// non-`NULL`, then startup notification will be used when activating the
    /// action (and as such, invocation of the action on the receiving side
    /// must signal the end of startup notification when it is completed).
    /// This is the expected behaviour of applications declaring additional
    /// actions, as per the
    /// [desktop file specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s11.html).
    ///
    /// As with `gio.AppInfo.launch` there is no way to detect failures that
    /// occur while using this function.
    extern fn g_desktop_app_info_launch_action(p_info: *DesktopAppInfo, p_action_name: [*:0]const u8, p_launch_context: ?*gio.AppLaunchContext) void;
    pub const launchAction = g_desktop_app_info_launch_action;

    /// This function performs the equivalent of `gio.AppInfo.launchUris`,
    /// but is intended primarily for operating system components that
    /// launch applications.  Ordinary applications should use
    /// `gio.AppInfo.launchUris`.
    ///
    /// If the application is launched via GSpawn, then `spawn_flags`, `user_setup`
    /// and `user_setup_data` are used for the call to `glib.spawnAsync`.
    /// Additionally, `pid_callback` (with `pid_callback_data`) will be called to
    /// inform about the PID of the created process. See
    /// `glib.spawnAsyncWithPipes` for information on certain parameter
    /// conditions that can enable an optimized [``posix_spawn``](man:posix_spawn(3))
    /// code path to be used.
    ///
    /// If application launching occurs via some other mechanism (for example, D-Bus
    /// activation) then `spawn_flags`, `user_setup`, `user_setup_data`,
    /// `pid_callback` and `pid_callback_data` are ignored.
    extern fn g_desktop_app_info_launch_uris_as_manager(p_appinfo: *DesktopAppInfo, p_uris: *glib.List, p_launch_context: ?*gio.AppLaunchContext, p_spawn_flags: glib.SpawnFlags, p_user_setup: ?glib.SpawnChildSetupFunc, p_user_setup_data: ?*anyopaque, p_pid_callback: ?gio.DesktopAppLaunchCallback, p_pid_callback_data: ?*anyopaque, p_error: ?*?*glib.Error) c_int;
    pub const launchUrisAsManager = g_desktop_app_info_launch_uris_as_manager;

    /// Equivalent to `gio.DesktopAppInfo.launchUrisAsManager` but allows
    /// you to pass in file descriptors for the stdin, stdout and stderr streams
    /// of the launched process.
    ///
    /// If application launching occurs via some non-spawn mechanism (e.g. D-Bus
    /// activation) then `stdin_fd`, `stdout_fd` and `stderr_fd` are ignored.
    extern fn g_desktop_app_info_launch_uris_as_manager_with_fds(p_appinfo: *DesktopAppInfo, p_uris: *glib.List, p_launch_context: ?*gio.AppLaunchContext, p_spawn_flags: glib.SpawnFlags, p_user_setup: ?glib.SpawnChildSetupFunc, p_user_setup_data: ?*anyopaque, p_pid_callback: ?gio.DesktopAppLaunchCallback, p_pid_callback_data: ?*anyopaque, p_stdin_fd: c_int, p_stdout_fd: c_int, p_stderr_fd: c_int, p_error: ?*?*glib.Error) c_int;
    pub const launchUrisAsManagerWithFds = g_desktop_app_info_launch_uris_as_manager_with_fds;

    /// Returns the list of
    /// [‘additional application actions’](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s11.html)
    /// supported on the desktop file, as per the desktop file specification.
    ///
    /// As per the specification, this is the list of actions that are
    /// explicitly listed in the `Actions` key of the `Desktop Entry` group.
    extern fn g_desktop_app_info_list_actions(p_info: *DesktopAppInfo) [*]const [*:0]const u8;
    pub const listActions = g_desktop_app_info_list_actions;

    extern fn g_desktop_app_info_get_type() usize;
    pub const getGObjectType = g_desktop_app_info_get_type;

    extern fn g_object_ref(p_self: *gio.DesktopAppInfo) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DesktopAppInfo) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DesktopAppInfo, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GEmblem` is an implementation of `gio.Icon` that supports
/// having an emblem, which is an icon with additional properties.
/// It can than be added to a `gio.EmblemedIcon`.
///
/// Currently, only metainformation about the emblem's origin is
/// supported. More may be added in the future.
pub const Emblem = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.Icon};
    pub const Class = gio.EmblemClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The actual icon of the emblem.
        pub const icon = struct {
            pub const name = "icon";

            pub const Type = ?*gobject.Object;
        };

        /// The origin the emblem is derived from.
        pub const origin = struct {
            pub const name = "origin";

            pub const Type = gio.EmblemOrigin;
        };
    };

    pub const signals = struct {};

    /// Creates a new emblem for `icon`.
    extern fn g_emblem_new(p_icon: *gio.Icon) *gio.Emblem;
    pub const new = g_emblem_new;

    /// Creates a new emblem for `icon`.
    extern fn g_emblem_new_with_origin(p_icon: *gio.Icon, p_origin: gio.EmblemOrigin) *gio.Emblem;
    pub const newWithOrigin = g_emblem_new_with_origin;

    /// Gives back the icon from `emblem`.
    extern fn g_emblem_get_icon(p_emblem: *Emblem) *gio.Icon;
    pub const getIcon = g_emblem_get_icon;

    /// Gets the origin of the emblem.
    extern fn g_emblem_get_origin(p_emblem: *Emblem) gio.EmblemOrigin;
    pub const getOrigin = g_emblem_get_origin;

    extern fn g_emblem_get_type() usize;
    pub const getGObjectType = g_emblem_get_type;

    extern fn g_object_ref(p_self: *gio.Emblem) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Emblem) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Emblem, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GEmblemedIcon` is an implementation of `gio.Icon` that supports
/// adding an emblem to an icon. Adding multiple emblems to an
/// icon is ensured via `gio.EmblemedIcon.addEmblem`.
///
/// Note that `GEmblemedIcon` allows no control over the position
/// of the emblems. See also `gio.Emblem` for more information.
pub const EmblemedIcon = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.Icon};
    pub const Class = gio.EmblemedIconClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.EmblemedIconPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The `gio.Icon` to attach emblems to.
        pub const gicon = struct {
            pub const name = "gicon";

            pub const Type = ?*gio.Icon;
        };
    };

    pub const signals = struct {};

    /// Creates a new emblemed icon for `icon` with the emblem `emblem`.
    extern fn g_emblemed_icon_new(p_icon: *gio.Icon, p_emblem: ?*gio.Emblem) *gio.EmblemedIcon;
    pub const new = g_emblemed_icon_new;

    /// Adds `emblem` to the `glib.List` of `GEmblems`.
    extern fn g_emblemed_icon_add_emblem(p_emblemed: *EmblemedIcon, p_emblem: *gio.Emblem) void;
    pub const addEmblem = g_emblemed_icon_add_emblem;

    /// Removes all the emblems from `icon`.
    extern fn g_emblemed_icon_clear_emblems(p_emblemed: *EmblemedIcon) void;
    pub const clearEmblems = g_emblemed_icon_clear_emblems;

    /// Gets the list of emblems for the `icon`.
    extern fn g_emblemed_icon_get_emblems(p_emblemed: *EmblemedIcon) *glib.List;
    pub const getEmblems = g_emblemed_icon_get_emblems;

    /// Gets the main icon for `emblemed`.
    extern fn g_emblemed_icon_get_icon(p_emblemed: *EmblemedIcon) *gio.Icon;
    pub const getIcon = g_emblemed_icon_get_icon;

    extern fn g_emblemed_icon_get_type() usize;
    pub const getGObjectType = g_emblemed_icon_get_type;

    extern fn g_object_ref(p_self: *gio.EmblemedIcon) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.EmblemedIcon) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *EmblemedIcon, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GFileEnumerator` allows you to operate on a set of `gio.File` objects,
/// returning a `gio.FileInfo` structure for each file enumerated (e.g.
/// `gio.File.enumerateChildren` will return a `GFileEnumerator` for each
/// of the children within a directory).
///
/// To get the next file's information from a `GFileEnumerator`, use
/// `gio.FileEnumerator.nextFile` or its asynchronous version,
/// `gio.FileEnumerator.nextFilesAsync`. Note that the asynchronous
/// version will return a list of `gio.FileInfo` objects, whereas the
/// synchronous will only return the next file in the enumerator.
///
/// The ordering of returned files is unspecified for non-Unix
/// platforms; for more information, see `glib.Dir.readName`.  On Unix,
/// when operating on local files, returned files will be sorted by
/// inode number.  Effectively you can assume that the ordering of
/// returned files will be stable between successive calls (and
/// applications) assuming the directory is unchanged.
///
/// If your application needs a specific ordering, such as by name or
/// modification time, you will have to implement that in your
/// application code.
///
/// To close a `GFileEnumerator`, use `gio.FileEnumerator.close`, or
/// its asynchronous version, `gio.FileEnumerator.closeAsync`. Once
/// a `GFileEnumerator` is closed, no further actions may be performed
/// on it, and it should be freed with `gobject.Object.unref`.
pub const FileEnumerator = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.FileEnumeratorClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.FileEnumeratorPrivate,

    pub const virtual_methods = struct {
        /// Asynchronously closes the file enumerator.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned in
        /// `gio.FileEnumerator.closeFinish`.
        pub const close_async = struct {
            pub fn call(p_class: anytype, p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(FileEnumerator.Class, p_class).f_close_async.?(gobject.ext.as(FileEnumerator, p_enumerator), p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(FileEnumerator.Class, p_class).f_close_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes closing a file enumerator, started from `gio.FileEnumerator.closeAsync`.
        ///
        /// If the file enumerator was already closed when `gio.FileEnumerator.closeAsync`
        /// was called, then this function will report `G_IO_ERROR_CLOSED` in `error`, and
        /// return `FALSE`. If the file enumerator had pending operation when the close
        /// operation was started, then this function will report `G_IO_ERROR_PENDING`, and
        /// return `FALSE`.  If `cancellable` was not `NULL`, then the operation may have been
        /// cancelled by triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be set, and `FALSE` will be
        /// returned.
        pub const close_finish = struct {
            pub fn call(p_class: anytype, p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(FileEnumerator.Class, p_class).f_close_finish.?(gobject.ext.as(FileEnumerator, p_enumerator), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(FileEnumerator.Class, p_class).f_close_finish = @ptrCast(p_implementation);
            }
        };

        pub const close_fn = struct {
            pub fn call(p_class: anytype, p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(FileEnumerator.Class, p_class).f_close_fn.?(gobject.ext.as(FileEnumerator, p_enumerator), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(FileEnumerator.Class, p_class).f_close_fn = @ptrCast(p_implementation);
            }
        };

        /// Returns information for the next file in the enumerated object.
        /// Will block until the information is available. The `gio.FileInfo`
        /// returned from this function will contain attributes that match the
        /// attribute string that was passed when the `gio.FileEnumerator` was created.
        ///
        /// See the documentation of `gio.FileEnumerator` for information about the
        /// order of returned files.
        ///
        /// On error, returns `NULL` and sets `error` to the error. If the
        /// enumerator is at the end, `NULL` will be returned and `error` will
        /// be unset.
        pub const next_file = struct {
            pub fn call(p_class: anytype, p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileInfo {
                return gobject.ext.as(FileEnumerator.Class, p_class).f_next_file.?(gobject.ext.as(FileEnumerator, p_enumerator), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo) void {
                gobject.ext.as(FileEnumerator.Class, p_class).f_next_file = @ptrCast(p_implementation);
            }
        };

        /// Request information for a number of files from the enumerator asynchronously.
        /// When all I/O for the operation is finished the `callback` will be called with
        /// the requested information.
        ///
        /// See the documentation of `gio.FileEnumerator` for information about the
        /// order of returned files.
        ///
        /// Once the end of the enumerator is reached, or if an error occurs, the
        /// `callback` will be called with an empty list. In this case, the previous call
        /// to `gio.FileEnumerator.nextFilesAsync` will typically have returned fewer
        /// than `num_files` items.
        ///
        /// If a request is cancelled the callback will be called with
        /// `G_IO_ERROR_CANCELLED`.
        ///
        /// This leads to the following pseudo-code usage:
        /// ```
        /// g_autoptr(GFile) dir = get_directory ();
        /// g_autoptr(GFileEnumerator) enumerator = NULL;
        /// g_autolist(GFileInfo) files = NULL;
        /// g_autoptr(GError) local_error = NULL;
        ///
        /// enumerator = yield g_file_enumerate_children_async (dir,
        ///                                                     G_FILE_ATTRIBUTE_STANDARD_NAME ","
        ///                                                     G_FILE_ATTRIBUTE_STANDARD_TYPE,
        ///                                                     G_FILE_QUERY_INFO_NONE,
        ///                                                     G_PRIORITY_DEFAULT,
        ///                                                     cancellable,
        ///                                                     …,
        ///                                                     &local_error);
        /// if (enumerator == NULL)
        ///   g_error ("Error enumerating: `s`", local_error->message);
        ///
        /// // Loop until no files are returned, either because the end of the enumerator
        /// // has been reached, or an error was returned.
        /// do
        ///   {
        ///     files = yield g_file_enumerator_next_files_async (enumerator,
        ///                                                       5,  // number of files to request
        ///                                                       G_PRIORITY_DEFAULT,
        ///                                                       cancellable,
        ///                                                       …,
        ///                                                       &local_error);
        ///
        ///     // Process the returned files, but don’t assume that exactly 5 were returned.
        ///     for (GList *l = files; l != NULL; l = l->next)
        ///       {
        ///         GFileInfo *info = l->data;
        ///         handle_file_info (info);
        ///       }
        ///   }
        /// while (files != NULL);
        ///
        /// if (local_error != NULL &&
        ///     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
        ///   g_error ("Error while enumerating: `s`", local_error->message);
        /// ```
        ///
        /// During an async request no other sync and async calls are allowed, and will
        /// result in `G_IO_ERROR_PENDING` errors.
        ///
        /// Any outstanding I/O request with higher priority (lower numerical value) will
        /// be executed before an outstanding request with lower priority. Default
        /// priority is `G_PRIORITY_DEFAULT`.
        pub const next_files_async = struct {
            pub fn call(p_class: anytype, p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_num_files: c_int, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(FileEnumerator.Class, p_class).f_next_files_async.?(gobject.ext.as(FileEnumerator, p_enumerator), p_num_files, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_num_files: c_int, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(FileEnumerator.Class, p_class).f_next_files_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes the asynchronous operation started with `gio.FileEnumerator.nextFilesAsync`.
        pub const next_files_finish = struct {
            pub fn call(p_class: anytype, p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.List {
                return gobject.ext.as(FileEnumerator.Class, p_class).f_next_files_finish.?(gobject.ext.as(FileEnumerator, p_enumerator), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List) void {
                gobject.ext.as(FileEnumerator.Class, p_class).f_next_files_finish = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The container that is being enumerated.
        pub const container = struct {
            pub const name = "container";

            pub const Type = ?*gio.File;
        };
    };

    pub const signals = struct {};

    /// Releases all resources used by this enumerator, making the
    /// enumerator return `G_IO_ERROR_CLOSED` on all calls.
    ///
    /// This will be automatically called when the last reference
    /// is dropped, but you might want to call this function to make
    /// sure resources are released as early as possible.
    extern fn g_file_enumerator_close(p_enumerator: *FileEnumerator, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const close = g_file_enumerator_close;

    /// Asynchronously closes the file enumerator.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned in
    /// `gio.FileEnumerator.closeFinish`.
    extern fn g_file_enumerator_close_async(p_enumerator: *FileEnumerator, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const closeAsync = g_file_enumerator_close_async;

    /// Finishes closing a file enumerator, started from `gio.FileEnumerator.closeAsync`.
    ///
    /// If the file enumerator was already closed when `gio.FileEnumerator.closeAsync`
    /// was called, then this function will report `G_IO_ERROR_CLOSED` in `error`, and
    /// return `FALSE`. If the file enumerator had pending operation when the close
    /// operation was started, then this function will report `G_IO_ERROR_PENDING`, and
    /// return `FALSE`.  If `cancellable` was not `NULL`, then the operation may have been
    /// cancelled by triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be set, and `FALSE` will be
    /// returned.
    extern fn g_file_enumerator_close_finish(p_enumerator: *FileEnumerator, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const closeFinish = g_file_enumerator_close_finish;

    /// Return a new `gio.File` which refers to the file named by `info` in the source
    /// directory of `enumerator`.  This function is primarily intended to be used
    /// inside loops with `gio.FileEnumerator.nextFile`.
    ///
    /// To use this, `G_FILE_ATTRIBUTE_STANDARD_NAME` must have been listed in the
    /// attributes list used when creating the `gio.FileEnumerator`.
    ///
    /// This is a convenience method that's equivalent to:
    /// ```
    ///   gchar *name = g_file_info_get_name (info);
    ///   GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
    ///                                    name);
    /// ```
    extern fn g_file_enumerator_get_child(p_enumerator: *FileEnumerator, p_info: *gio.FileInfo) *gio.File;
    pub const getChild = g_file_enumerator_get_child;

    /// Get the `gio.File` container which is being enumerated.
    extern fn g_file_enumerator_get_container(p_enumerator: *FileEnumerator) *gio.File;
    pub const getContainer = g_file_enumerator_get_container;

    /// Checks if the file enumerator has pending operations.
    extern fn g_file_enumerator_has_pending(p_enumerator: *FileEnumerator) c_int;
    pub const hasPending = g_file_enumerator_has_pending;

    /// Checks if the file enumerator has been closed.
    extern fn g_file_enumerator_is_closed(p_enumerator: *FileEnumerator) c_int;
    pub const isClosed = g_file_enumerator_is_closed;

    /// This is a version of `gio.FileEnumerator.nextFile` that's easier to
    /// use correctly from C programs.  With `gio.FileEnumerator.nextFile`,
    /// the gboolean return value signifies "end of iteration or error", which
    /// requires allocation of a temporary `glib.Error`.
    ///
    /// In contrast, with this function, a `FALSE` return from
    /// `gio.FileEnumerator.iterate` *always* means
    /// "error".  End of iteration is signaled by `out_info` or `out_child` being `NULL`.
    ///
    /// Another crucial difference is that the references for `out_info` and
    /// `out_child` are owned by `direnum` (they are cached as hidden
    /// properties).  You must not unref them in your own code.  This makes
    /// memory management significantly easier for C code in combination
    /// with loops.
    ///
    /// Finally, this function optionally allows retrieving a `gio.File` as
    /// well.
    ///
    /// You must specify at least one of `out_info` or `out_child`.
    ///
    /// The code pattern for correctly using `gio.FileEnumerator.iterate` from C
    /// is:
    ///
    /// ```
    /// direnum = g_file_enumerate_children (file, ...);
    /// while (TRUE)
    ///   {
    ///     GFileInfo *info;
    ///     if (!g_file_enumerator_iterate (direnum, &info, NULL, cancellable, error))
    ///       goto out;
    ///     if (!info)
    ///       break;
    ///     ... do stuff with "info"; do not unref it! ...
    ///   }
    ///
    /// out:
    ///   g_object_unref (direnum); // Note: frees the last `info`
    /// ```
    extern fn g_file_enumerator_iterate(p_direnum: *FileEnumerator, p_out_info: ?**gio.FileInfo, p_out_child: ?**gio.File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const iterate = g_file_enumerator_iterate;

    /// Returns information for the next file in the enumerated object.
    /// Will block until the information is available. The `gio.FileInfo`
    /// returned from this function will contain attributes that match the
    /// attribute string that was passed when the `gio.FileEnumerator` was created.
    ///
    /// See the documentation of `gio.FileEnumerator` for information about the
    /// order of returned files.
    ///
    /// On error, returns `NULL` and sets `error` to the error. If the
    /// enumerator is at the end, `NULL` will be returned and `error` will
    /// be unset.
    extern fn g_file_enumerator_next_file(p_enumerator: *FileEnumerator, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileInfo;
    pub const nextFile = g_file_enumerator_next_file;

    /// Request information for a number of files from the enumerator asynchronously.
    /// When all I/O for the operation is finished the `callback` will be called with
    /// the requested information.
    ///
    /// See the documentation of `gio.FileEnumerator` for information about the
    /// order of returned files.
    ///
    /// Once the end of the enumerator is reached, or if an error occurs, the
    /// `callback` will be called with an empty list. In this case, the previous call
    /// to `gio.FileEnumerator.nextFilesAsync` will typically have returned fewer
    /// than `num_files` items.
    ///
    /// If a request is cancelled the callback will be called with
    /// `G_IO_ERROR_CANCELLED`.
    ///
    /// This leads to the following pseudo-code usage:
    /// ```
    /// g_autoptr(GFile) dir = get_directory ();
    /// g_autoptr(GFileEnumerator) enumerator = NULL;
    /// g_autolist(GFileInfo) files = NULL;
    /// g_autoptr(GError) local_error = NULL;
    ///
    /// enumerator = yield g_file_enumerate_children_async (dir,
    ///                                                     G_FILE_ATTRIBUTE_STANDARD_NAME ","
    ///                                                     G_FILE_ATTRIBUTE_STANDARD_TYPE,
    ///                                                     G_FILE_QUERY_INFO_NONE,
    ///                                                     G_PRIORITY_DEFAULT,
    ///                                                     cancellable,
    ///                                                     …,
    ///                                                     &local_error);
    /// if (enumerator == NULL)
    ///   g_error ("Error enumerating: `s`", local_error->message);
    ///
    /// // Loop until no files are returned, either because the end of the enumerator
    /// // has been reached, or an error was returned.
    /// do
    ///   {
    ///     files = yield g_file_enumerator_next_files_async (enumerator,
    ///                                                       5,  // number of files to request
    ///                                                       G_PRIORITY_DEFAULT,
    ///                                                       cancellable,
    ///                                                       …,
    ///                                                       &local_error);
    ///
    ///     // Process the returned files, but don’t assume that exactly 5 were returned.
    ///     for (GList *l = files; l != NULL; l = l->next)
    ///       {
    ///         GFileInfo *info = l->data;
    ///         handle_file_info (info);
    ///       }
    ///   }
    /// while (files != NULL);
    ///
    /// if (local_error != NULL &&
    ///     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
    ///   g_error ("Error while enumerating: `s`", local_error->message);
    /// ```
    ///
    /// During an async request no other sync and async calls are allowed, and will
    /// result in `G_IO_ERROR_PENDING` errors.
    ///
    /// Any outstanding I/O request with higher priority (lower numerical value) will
    /// be executed before an outstanding request with lower priority. Default
    /// priority is `G_PRIORITY_DEFAULT`.
    extern fn g_file_enumerator_next_files_async(p_enumerator: *FileEnumerator, p_num_files: c_int, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const nextFilesAsync = g_file_enumerator_next_files_async;

    /// Finishes the asynchronous operation started with `gio.FileEnumerator.nextFilesAsync`.
    extern fn g_file_enumerator_next_files_finish(p_enumerator: *FileEnumerator, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.List;
    pub const nextFilesFinish = g_file_enumerator_next_files_finish;

    /// Sets the file enumerator as having pending operations.
    extern fn g_file_enumerator_set_pending(p_enumerator: *FileEnumerator, p_pending: c_int) void;
    pub const setPending = g_file_enumerator_set_pending;

    extern fn g_file_enumerator_get_type() usize;
    pub const getGObjectType = g_file_enumerator_get_type;

    extern fn g_object_ref(p_self: *gio.FileEnumerator) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.FileEnumerator) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FileEnumerator, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GFileIOStream` provides I/O streams that both read and write to the same
/// file handle.
///
/// `GFileIOStream` implements `gio.Seekable`, which allows the I/O
/// stream to jump to arbitrary positions in the file and to truncate
/// the file, provided the filesystem of the file supports these
/// operations.
///
/// To find the position of a file I/O stream, use `gio.Seekable.tell`.
///
/// To find out if a file I/O stream supports seeking, use
/// `gio.Seekable.canSeek`. To position a file I/O stream, use
/// `gio.Seekable.seek`. To find out if a file I/O stream supports
/// truncating, use `gio.Seekable.canTruncate`. To truncate a file I/O
/// stream, use `gio.Seekable.truncate`.
///
/// The default implementation of all the `GFileIOStream` operations
/// and the implementation of `gio.Seekable` just call into the same
/// operations on the output stream.
pub const FileIOStream = extern struct {
    pub const Parent = gio.IOStream;
    pub const Implements = [_]type{gio.Seekable};
    pub const Class = gio.FileIOStreamClass;
    f_parent_instance: gio.IOStream,
    f_priv: ?*gio.FileIOStreamPrivate,

    pub const virtual_methods = struct {
        pub const can_seek = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(FileIOStream.Class, p_class).f_can_seek.?(gobject.ext.as(FileIOStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(FileIOStream.Class, p_class).f_can_seek = @ptrCast(p_implementation);
            }
        };

        pub const can_truncate = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(FileIOStream.Class, p_class).f_can_truncate.?(gobject.ext.as(FileIOStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(FileIOStream.Class, p_class).f_can_truncate = @ptrCast(p_implementation);
            }
        };

        /// Gets the entity tag for the file when it has been written.
        /// This must be called after the stream has been written
        /// and closed, as the etag can change while writing.
        pub const get_etag = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]u8 {
                return gobject.ext.as(FileIOStream.Class, p_class).f_get_etag.?(gobject.ext.as(FileIOStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]u8) void {
                gobject.ext.as(FileIOStream.Class, p_class).f_get_etag = @ptrCast(p_implementation);
            }
        };

        /// Queries a file io stream for the given `attributes`.
        /// This function blocks while querying the stream. For the asynchronous
        /// version of this function, see `gio.FileIOStream.queryInfoAsync`.
        /// While the stream is blocked, the stream will set the pending flag
        /// internally, and any other operations on the stream will fail with
        /// `G_IO_ERROR_PENDING`.
        ///
        /// Can fail if the stream was already closed (with `error` being set to
        /// `G_IO_ERROR_CLOSED`), the stream has pending operations (with `error` being
        /// set to `G_IO_ERROR_PENDING`), or if querying info is not supported for
        /// the stream's interface (with `error` being set to `G_IO_ERROR_NOT_SUPPORTED`). I
        /// all cases of failure, `NULL` will be returned.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be set, and `NULL` will
        /// be returned.
        pub const query_info = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileInfo {
                return gobject.ext.as(FileIOStream.Class, p_class).f_query_info.?(gobject.ext.as(FileIOStream, p_stream), p_attributes, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo) void {
                gobject.ext.as(FileIOStream.Class, p_class).f_query_info = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously queries the `stream` for a `gio.FileInfo`. When completed,
        /// `callback` will be called with a `gio.AsyncResult` which can be used to
        /// finish the operation with `gio.FileIOStream.queryInfoFinish`.
        ///
        /// For the synchronous version of this function, see
        /// `gio.FileIOStream.queryInfo`.
        pub const query_info_async = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(FileIOStream.Class, p_class).f_query_info_async.?(gobject.ext.as(FileIOStream, p_stream), p_attributes, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(FileIOStream.Class, p_class).f_query_info_async = @ptrCast(p_implementation);
            }
        };

        /// Finalizes the asynchronous query started
        /// by `gio.FileIOStream.queryInfoAsync`.
        pub const query_info_finish = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileInfo {
                return gobject.ext.as(FileIOStream.Class, p_class).f_query_info_finish.?(gobject.ext.as(FileIOStream, p_stream), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo) void {
                gobject.ext.as(FileIOStream.Class, p_class).f_query_info_finish = @ptrCast(p_implementation);
            }
        };

        pub const seek = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_offset: i64, p_type: glib.SeekType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(FileIOStream.Class, p_class).f_seek.?(gobject.ext.as(FileIOStream, p_stream), p_offset, p_type, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_offset: i64, p_type: glib.SeekType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(FileIOStream.Class, p_class).f_seek = @ptrCast(p_implementation);
            }
        };

        pub const tell = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) i64 {
                return gobject.ext.as(FileIOStream.Class, p_class).f_tell.?(gobject.ext.as(FileIOStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) i64) void {
                gobject.ext.as(FileIOStream.Class, p_class).f_tell = @ptrCast(p_implementation);
            }
        };

        pub const truncate_fn = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_size: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(FileIOStream.Class, p_class).f_truncate_fn.?(gobject.ext.as(FileIOStream, p_stream), p_size, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_size: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(FileIOStream.Class, p_class).f_truncate_fn = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Gets the entity tag for the file when it has been written.
    /// This must be called after the stream has been written
    /// and closed, as the etag can change while writing.
    extern fn g_file_io_stream_get_etag(p_stream: *FileIOStream) ?[*:0]u8;
    pub const getEtag = g_file_io_stream_get_etag;

    /// Queries a file io stream for the given `attributes`.
    /// This function blocks while querying the stream. For the asynchronous
    /// version of this function, see `gio.FileIOStream.queryInfoAsync`.
    /// While the stream is blocked, the stream will set the pending flag
    /// internally, and any other operations on the stream will fail with
    /// `G_IO_ERROR_PENDING`.
    ///
    /// Can fail if the stream was already closed (with `error` being set to
    /// `G_IO_ERROR_CLOSED`), the stream has pending operations (with `error` being
    /// set to `G_IO_ERROR_PENDING`), or if querying info is not supported for
    /// the stream's interface (with `error` being set to `G_IO_ERROR_NOT_SUPPORTED`). I
    /// all cases of failure, `NULL` will be returned.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be set, and `NULL` will
    /// be returned.
    extern fn g_file_io_stream_query_info(p_stream: *FileIOStream, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileInfo;
    pub const queryInfo = g_file_io_stream_query_info;

    /// Asynchronously queries the `stream` for a `gio.FileInfo`. When completed,
    /// `callback` will be called with a `gio.AsyncResult` which can be used to
    /// finish the operation with `gio.FileIOStream.queryInfoFinish`.
    ///
    /// For the synchronous version of this function, see
    /// `gio.FileIOStream.queryInfo`.
    extern fn g_file_io_stream_query_info_async(p_stream: *FileIOStream, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const queryInfoAsync = g_file_io_stream_query_info_async;

    /// Finalizes the asynchronous query started
    /// by `gio.FileIOStream.queryInfoAsync`.
    extern fn g_file_io_stream_query_info_finish(p_stream: *FileIOStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileInfo;
    pub const queryInfoFinish = g_file_io_stream_query_info_finish;

    extern fn g_file_io_stream_get_type() usize;
    pub const getGObjectType = g_file_io_stream_get_type;

    extern fn g_object_ref(p_self: *gio.FileIOStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.FileIOStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FileIOStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GFileIcon` specifies an icon by pointing to an image file
/// to be used as icon.
///
/// It implements `gio.LoadableIcon`.
pub const FileIcon = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gio.Icon, gio.LoadableIcon };
    pub const Class = gio.FileIconClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The file containing the icon.
        pub const file = struct {
            pub const name = "file";

            pub const Type = ?*gio.File;
        };
    };

    pub const signals = struct {};

    /// Creates a new icon for a file.
    extern fn g_file_icon_new(p_file: *gio.File) *gio.FileIcon;
    pub const new = g_file_icon_new;

    /// Gets the `gio.File` associated with the given `icon`.
    extern fn g_file_icon_get_file(p_icon: *FileIcon) *gio.File;
    pub const getFile = g_file_icon_get_file;

    extern fn g_file_icon_get_type() usize;
    pub const getGObjectType = g_file_icon_get_type;

    extern fn g_object_ref(p_self: *gio.FileIcon) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.FileIcon) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FileIcon, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Stores information about a file system object referenced by a `gio.File`.
///
/// Functionality for manipulating basic metadata for files. `GFileInfo`
/// implements methods for getting information that all files should
/// contain, and allows for manipulation of extended attributes.
///
/// See the [file attributes](file-attributes.html) document for more
/// information on how GIO handles file attributes.
///
/// To obtain a `GFileInfo` for a `gio.File`, use
/// `gio.File.queryInfo` (or its async variant). To obtain a `GFileInfo`
/// for a file input or output stream, use `gio.FileInputStream.queryInfo`
/// or `gio.FileOutputStream.queryInfo` (or their async variants).
///
/// To change the actual attributes of a file, you should then set the
/// attribute in the `GFileInfo` and call `gio.File.setAttributesFromInfo`
/// or `gio.File.setAttributesAsync` on a `GFile`.
///
/// However, not all attributes can be changed in the file. For instance,
/// the actual size of a file cannot be changed via `gio.FileInfo.setSize`.
/// You may call `gio.File.querySettableAttributes` and
/// `gio.File.queryWritableNamespaces` to discover the settable attributes
/// of a particular file at runtime.
///
/// The direct accessors, such as `gio.FileInfo.getName`, are slightly more
/// optimized than the generic attribute accessors, such as
/// `gio.FileInfo.getAttributeByteString`.This optimization will matter
/// only if calling the API in a tight loop.
///
/// It is an error to call these accessors without specifying their required file
/// attributes when creating the `GFileInfo`. Use
/// `gio.FileInfo.hasAttribute` or `gio.FileInfo.listAttributes`
/// to check what attributes are specified for a `GFileInfo`.
///
/// `gio.FileAttributeMatcher` allows for searching through a `GFileInfo`
/// for attributes.
pub const FileInfo = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.FileInfoClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new file info structure.
    extern fn g_file_info_new() *gio.FileInfo;
    pub const new = g_file_info_new;

    /// Clears the status information from `info`.
    extern fn g_file_info_clear_status(p_info: *FileInfo) void;
    pub const clearStatus = g_file_info_clear_status;

    /// First clears all of the [GFileAttribute](file-attributes.html`file`-attributes) of
    /// `dest_info`, and then copies all of the file attributes from `src_info` to `dest_info`.
    extern fn g_file_info_copy_into(p_src_info: *FileInfo, p_dest_info: *gio.FileInfo) void;
    pub const copyInto = g_file_info_copy_into;

    /// Duplicates a file info structure.
    extern fn g_file_info_dup(p_other: *FileInfo) *gio.FileInfo;
    pub const dup = g_file_info_dup;

    /// Gets the access time of the current `info` and returns it as a
    /// `glib.DateTime`.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_TIME_ACCESS`. If `G_FILE_ATTRIBUTE_TIME_ACCESS_USEC` is
    /// provided, the resulting `glib.DateTime` will additionally have microsecond
    /// precision.
    ///
    /// If nanosecond precision is needed, `G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC` must
    /// be queried separately using `gio.FileInfo.getAttributeUint32`.
    extern fn g_file_info_get_access_date_time(p_info: *FileInfo) ?*glib.DateTime;
    pub const getAccessDateTime = g_file_info_get_access_date_time;

    /// Gets the value of an attribute, formatted as a string.
    /// This escapes things as needed to make the string valid
    /// UTF-8.
    extern fn g_file_info_get_attribute_as_string(p_info: *FileInfo, p_attribute: [*:0]const u8) ?[*:0]u8;
    pub const getAttributeAsString = g_file_info_get_attribute_as_string;

    /// Gets the value of a boolean attribute. If the attribute does not
    /// contain a boolean value, `FALSE` will be returned.
    extern fn g_file_info_get_attribute_boolean(p_info: *FileInfo, p_attribute: [*:0]const u8) c_int;
    pub const getAttributeBoolean = g_file_info_get_attribute_boolean;

    /// Gets the value of a byte string attribute. If the attribute does
    /// not contain a byte string, `NULL` will be returned.
    extern fn g_file_info_get_attribute_byte_string(p_info: *FileInfo, p_attribute: [*:0]const u8) ?[*:0]const u8;
    pub const getAttributeByteString = g_file_info_get_attribute_byte_string;

    /// Gets the attribute type, value and status for an attribute key.
    extern fn g_file_info_get_attribute_data(p_info: *FileInfo, p_attribute: [*:0]const u8, p_type: ?*gio.FileAttributeType, p_value_pp: ?*anyopaque, p_status: ?*gio.FileAttributeStatus) c_int;
    pub const getAttributeData = g_file_info_get_attribute_data;

    /// Gets the value of a byte string attribute as a file path.
    ///
    /// If the attribute does not contain a byte string, `NULL` will be returned.
    ///
    /// This function is meant to be used by language bindings that have specific
    /// handling for Unix paths.
    extern fn g_file_info_get_attribute_file_path(p_info: *FileInfo, p_attribute: [*:0]const u8) ?[*:0]const u8;
    pub const getAttributeFilePath = g_file_info_get_attribute_file_path;

    /// Gets a signed 32-bit integer contained within the attribute. If the
    /// attribute does not contain a signed 32-bit integer, or is invalid,
    /// 0 will be returned.
    extern fn g_file_info_get_attribute_int32(p_info: *FileInfo, p_attribute: [*:0]const u8) i32;
    pub const getAttributeInt32 = g_file_info_get_attribute_int32;

    /// Gets a signed 64-bit integer contained within the attribute. If the
    /// attribute does not contain a signed 64-bit integer, or is invalid,
    /// 0 will be returned.
    extern fn g_file_info_get_attribute_int64(p_info: *FileInfo, p_attribute: [*:0]const u8) i64;
    pub const getAttributeInt64 = g_file_info_get_attribute_int64;

    /// Gets the value of a `gobject.Object` attribute. If the attribute does
    /// not contain a `gobject.Object`, `NULL` will be returned.
    extern fn g_file_info_get_attribute_object(p_info: *FileInfo, p_attribute: [*:0]const u8) ?*gobject.Object;
    pub const getAttributeObject = g_file_info_get_attribute_object;

    /// Gets the attribute status for an attribute key.
    extern fn g_file_info_get_attribute_status(p_info: *FileInfo, p_attribute: [*:0]const u8) gio.FileAttributeStatus;
    pub const getAttributeStatus = g_file_info_get_attribute_status;

    /// Gets the value of a string attribute. If the attribute does
    /// not contain a string, `NULL` will be returned.
    extern fn g_file_info_get_attribute_string(p_info: *FileInfo, p_attribute: [*:0]const u8) ?[*:0]const u8;
    pub const getAttributeString = g_file_info_get_attribute_string;

    /// Gets the value of a stringv attribute. If the attribute does
    /// not contain a stringv, `NULL` will be returned.
    extern fn g_file_info_get_attribute_stringv(p_info: *FileInfo, p_attribute: [*:0]const u8) ?[*][*:0]u8;
    pub const getAttributeStringv = g_file_info_get_attribute_stringv;

    /// Gets the attribute type for an attribute key.
    extern fn g_file_info_get_attribute_type(p_info: *FileInfo, p_attribute: [*:0]const u8) gio.FileAttributeType;
    pub const getAttributeType = g_file_info_get_attribute_type;

    /// Gets an unsigned 32-bit integer contained within the attribute. If the
    /// attribute does not contain an unsigned 32-bit integer, or is invalid,
    /// 0 will be returned.
    extern fn g_file_info_get_attribute_uint32(p_info: *FileInfo, p_attribute: [*:0]const u8) u32;
    pub const getAttributeUint32 = g_file_info_get_attribute_uint32;

    /// Gets a unsigned 64-bit integer contained within the attribute. If the
    /// attribute does not contain an unsigned 64-bit integer, or is invalid,
    /// 0 will be returned.
    extern fn g_file_info_get_attribute_uint64(p_info: *FileInfo, p_attribute: [*:0]const u8) u64;
    pub const getAttributeUint64 = g_file_info_get_attribute_uint64;

    /// Gets the file's content type.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE`.
    extern fn g_file_info_get_content_type(p_info: *FileInfo) ?[*:0]const u8;
    pub const getContentType = g_file_info_get_content_type;

    /// Gets the creation time of the current `info` and returns it as a
    /// `glib.DateTime`.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_TIME_CREATED`. If `G_FILE_ATTRIBUTE_TIME_CREATED_USEC` is
    /// provided, the resulting `glib.DateTime` will additionally have microsecond
    /// precision.
    ///
    /// If nanosecond precision is needed, `G_FILE_ATTRIBUTE_TIME_CREATED_NSEC` must
    /// be queried separately using `gio.FileInfo.getAttributeUint32`.
    extern fn g_file_info_get_creation_date_time(p_info: *FileInfo) ?*glib.DateTime;
    pub const getCreationDateTime = g_file_info_get_creation_date_time;

    /// Returns the `glib.DateTime` representing the deletion date of the file, as
    /// available in `G_FILE_ATTRIBUTE_TRASH_DELETION_DATE`. If the
    /// `G_FILE_ATTRIBUTE_TRASH_DELETION_DATE` attribute is unset, `NULL` is returned.
    extern fn g_file_info_get_deletion_date(p_info: *FileInfo) ?*glib.DateTime;
    pub const getDeletionDate = g_file_info_get_deletion_date;

    /// Gets a display name for a file. This is guaranteed to always be set.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME`.
    extern fn g_file_info_get_display_name(p_info: *FileInfo) [*:0]const u8;
    pub const getDisplayName = g_file_info_get_display_name;

    /// Gets the edit name for a file.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME`.
    extern fn g_file_info_get_edit_name(p_info: *FileInfo) [*:0]const u8;
    pub const getEditName = g_file_info_get_edit_name;

    /// Gets the [entity tag]`gio.@"File#entity-tags"` for a given
    /// `gio.FileInfo`. See `G_FILE_ATTRIBUTE_ETAG_VALUE`.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_ETAG_VALUE`.
    extern fn g_file_info_get_etag(p_info: *FileInfo) ?[*:0]const u8;
    pub const getEtag = g_file_info_get_etag;

    /// Gets a file's type (whether it is a regular file, symlink, etc).
    /// This is different from the file's content type, see `gio.FileInfo.getContentType`.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_STANDARD_TYPE`.
    extern fn g_file_info_get_file_type(p_info: *FileInfo) gio.FileType;
    pub const getFileType = g_file_info_get_file_type;

    /// Gets the icon for a file.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_STANDARD_ICON`.
    extern fn g_file_info_get_icon(p_info: *FileInfo) ?*gio.Icon;
    pub const getIcon = g_file_info_get_icon;

    /// Checks if a file is a backup file.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP`.
    extern fn g_file_info_get_is_backup(p_info: *FileInfo) c_int;
    pub const getIsBackup = g_file_info_get_is_backup;

    /// Checks if a file is hidden.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN`.
    extern fn g_file_info_get_is_hidden(p_info: *FileInfo) c_int;
    pub const getIsHidden = g_file_info_get_is_hidden;

    /// Checks if a file is a symlink.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK`.
    extern fn g_file_info_get_is_symlink(p_info: *FileInfo) c_int;
    pub const getIsSymlink = g_file_info_get_is_symlink;

    /// Gets the modification time of the current `info` and returns it as a
    /// `glib.DateTime`.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_TIME_MODIFIED`. If `G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC` is
    /// provided, the resulting `glib.DateTime` will additionally have microsecond
    /// precision.
    ///
    /// If nanosecond precision is needed, `G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC` must
    /// be queried separately using `gio.FileInfo.getAttributeUint32`.
    extern fn g_file_info_get_modification_date_time(p_info: *FileInfo) ?*glib.DateTime;
    pub const getModificationDateTime = g_file_info_get_modification_date_time;

    /// Gets the modification time of the current `info` and sets it
    /// in `result`.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_TIME_MODIFIED`. If `G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC` is
    /// provided it will be used too.
    extern fn g_file_info_get_modification_time(p_info: *FileInfo, p_result: *glib.TimeVal) void;
    pub const getModificationTime = g_file_info_get_modification_time;

    /// Gets the name for a file. This is guaranteed to always be set.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_STANDARD_NAME`.
    extern fn g_file_info_get_name(p_info: *FileInfo) [*:0]const u8;
    pub const getName = g_file_info_get_name;

    /// Gets the file's size (in bytes). The size is retrieved through the value of
    /// the `G_FILE_ATTRIBUTE_STANDARD_SIZE` attribute and is converted
    /// from `guint64` to `goffset` before returning the result.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_STANDARD_SIZE`.
    extern fn g_file_info_get_size(p_info: *FileInfo) i64;
    pub const getSize = g_file_info_get_size;

    /// Gets the value of the sort_order attribute from the `gio.FileInfo`.
    /// See `G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER`.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER`.
    extern fn g_file_info_get_sort_order(p_info: *FileInfo) i32;
    pub const getSortOrder = g_file_info_get_sort_order;

    /// Gets the symbolic icon for a file.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON`.
    extern fn g_file_info_get_symbolic_icon(p_info: *FileInfo) ?*gio.Icon;
    pub const getSymbolicIcon = g_file_info_get_symbolic_icon;

    /// Gets the symlink target for a given `gio.FileInfo`.
    ///
    /// It is an error to call this if the `gio.FileInfo` does not contain
    /// `G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET`.
    extern fn g_file_info_get_symlink_target(p_info: *FileInfo) ?[*:0]const u8;
    pub const getSymlinkTarget = g_file_info_get_symlink_target;

    /// Checks if a file info structure has an attribute named `attribute`.
    extern fn g_file_info_has_attribute(p_info: *FileInfo, p_attribute: [*:0]const u8) c_int;
    pub const hasAttribute = g_file_info_has_attribute;

    /// Checks if a file info structure has an attribute in the
    /// specified `name_space`.
    extern fn g_file_info_has_namespace(p_info: *FileInfo, p_name_space: [*:0]const u8) c_int;
    pub const hasNamespace = g_file_info_has_namespace;

    /// Lists the file info structure's attributes.
    extern fn g_file_info_list_attributes(p_info: *FileInfo, p_name_space: ?[*:0]const u8) ?[*][*:0]u8;
    pub const listAttributes = g_file_info_list_attributes;

    /// Removes all cases of `attribute` from `info` if it exists.
    extern fn g_file_info_remove_attribute(p_info: *FileInfo, p_attribute: [*:0]const u8) void;
    pub const removeAttribute = g_file_info_remove_attribute;

    /// Sets the `G_FILE_ATTRIBUTE_TIME_ACCESS` and
    /// `G_FILE_ATTRIBUTE_TIME_ACCESS_USEC` attributes in the file info to the
    /// given date/time value.
    ///
    /// `G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC` will be cleared.
    extern fn g_file_info_set_access_date_time(p_info: *FileInfo, p_atime: *glib.DateTime) void;
    pub const setAccessDateTime = g_file_info_set_access_date_time;

    /// Sets the `attribute` to contain the given value, if possible. To unset the
    /// attribute, use `G_FILE_ATTRIBUTE_TYPE_INVALID` for `type`.
    extern fn g_file_info_set_attribute(p_info: *FileInfo, p_attribute: [*:0]const u8, p_type: gio.FileAttributeType, p_value_p: *anyopaque) void;
    pub const setAttribute = g_file_info_set_attribute;

    /// Sets the `attribute` to contain the given `attr_value`,
    /// if possible.
    extern fn g_file_info_set_attribute_boolean(p_info: *FileInfo, p_attribute: [*:0]const u8, p_attr_value: c_int) void;
    pub const setAttributeBoolean = g_file_info_set_attribute_boolean;

    /// Sets the `attribute` to contain the given `attr_value`,
    /// if possible.
    extern fn g_file_info_set_attribute_byte_string(p_info: *FileInfo, p_attribute: [*:0]const u8, p_attr_value: [*:0]const u8) void;
    pub const setAttributeByteString = g_file_info_set_attribute_byte_string;

    /// Sets the `attribute` to contain the given `attr_value`,
    /// if possible.
    ///
    /// This function is meant to be used by language bindings that have specific
    /// handling for Unix paths.
    extern fn g_file_info_set_attribute_file_path(p_info: *FileInfo, p_attribute: [*:0]const u8, p_attr_value: [*:0]const u8) void;
    pub const setAttributeFilePath = g_file_info_set_attribute_file_path;

    /// Sets the `attribute` to contain the given `attr_value`,
    /// if possible.
    extern fn g_file_info_set_attribute_int32(p_info: *FileInfo, p_attribute: [*:0]const u8, p_attr_value: i32) void;
    pub const setAttributeInt32 = g_file_info_set_attribute_int32;

    /// Sets the `attribute` to contain the given `attr_value`,
    /// if possible.
    extern fn g_file_info_set_attribute_int64(p_info: *FileInfo, p_attribute: [*:0]const u8, p_attr_value: i64) void;
    pub const setAttributeInt64 = g_file_info_set_attribute_int64;

    /// Sets `mask` on `info` to match specific attribute types.
    extern fn g_file_info_set_attribute_mask(p_info: *FileInfo, p_mask: *gio.FileAttributeMatcher) void;
    pub const setAttributeMask = g_file_info_set_attribute_mask;

    /// Sets the `attribute` to contain the given `attr_value`,
    /// if possible.
    extern fn g_file_info_set_attribute_object(p_info: *FileInfo, p_attribute: [*:0]const u8, p_attr_value: *gobject.Object) void;
    pub const setAttributeObject = g_file_info_set_attribute_object;

    /// Sets the attribute status for an attribute key. This is only
    /// needed by external code that implement `gio.File.setAttributesFromInfo`
    /// or similar functions.
    ///
    /// The attribute must exist in `info` for this to work. Otherwise `FALSE`
    /// is returned and `info` is unchanged.
    extern fn g_file_info_set_attribute_status(p_info: *FileInfo, p_attribute: [*:0]const u8, p_status: gio.FileAttributeStatus) c_int;
    pub const setAttributeStatus = g_file_info_set_attribute_status;

    /// Sets the `attribute` to contain the given `attr_value`,
    /// if possible.
    extern fn g_file_info_set_attribute_string(p_info: *FileInfo, p_attribute: [*:0]const u8, p_attr_value: [*:0]const u8) void;
    pub const setAttributeString = g_file_info_set_attribute_string;

    /// Sets the `attribute` to contain the given `attr_value`,
    /// if possible.
    ///
    /// Sinze: 2.22
    extern fn g_file_info_set_attribute_stringv(p_info: *FileInfo, p_attribute: [*:0]const u8, p_attr_value: [*][*:0]u8) void;
    pub const setAttributeStringv = g_file_info_set_attribute_stringv;

    /// Sets the `attribute` to contain the given `attr_value`,
    /// if possible.
    extern fn g_file_info_set_attribute_uint32(p_info: *FileInfo, p_attribute: [*:0]const u8, p_attr_value: u32) void;
    pub const setAttributeUint32 = g_file_info_set_attribute_uint32;

    /// Sets the `attribute` to contain the given `attr_value`,
    /// if possible.
    extern fn g_file_info_set_attribute_uint64(p_info: *FileInfo, p_attribute: [*:0]const u8, p_attr_value: u64) void;
    pub const setAttributeUint64 = g_file_info_set_attribute_uint64;

    /// Sets the content type attribute for a given `gio.FileInfo`.
    /// See `G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE`.
    extern fn g_file_info_set_content_type(p_info: *FileInfo, p_content_type: [*:0]const u8) void;
    pub const setContentType = g_file_info_set_content_type;

    /// Sets the `G_FILE_ATTRIBUTE_TIME_CREATED` and
    /// `G_FILE_ATTRIBUTE_TIME_CREATED_USEC` attributes in the file info to the
    /// given date/time value.
    ///
    /// `G_FILE_ATTRIBUTE_TIME_CREATED_NSEC` will be cleared.
    extern fn g_file_info_set_creation_date_time(p_info: *FileInfo, p_creation_time: *glib.DateTime) void;
    pub const setCreationDateTime = g_file_info_set_creation_date_time;

    /// Sets the display name for the current `gio.FileInfo`.
    /// See `G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME`.
    extern fn g_file_info_set_display_name(p_info: *FileInfo, p_display_name: [*:0]const u8) void;
    pub const setDisplayName = g_file_info_set_display_name;

    /// Sets the edit name for the current file.
    /// See `G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME`.
    extern fn g_file_info_set_edit_name(p_info: *FileInfo, p_edit_name: [*:0]const u8) void;
    pub const setEditName = g_file_info_set_edit_name;

    /// Sets the file type in a `gio.FileInfo` to `type`.
    /// See `G_FILE_ATTRIBUTE_STANDARD_TYPE`.
    extern fn g_file_info_set_file_type(p_info: *FileInfo, p_type: gio.FileType) void;
    pub const setFileType = g_file_info_set_file_type;

    /// Sets the icon for a given `gio.FileInfo`.
    /// See `G_FILE_ATTRIBUTE_STANDARD_ICON`.
    extern fn g_file_info_set_icon(p_info: *FileInfo, p_icon: *gio.Icon) void;
    pub const setIcon = g_file_info_set_icon;

    /// Sets the "is_hidden" attribute in a `gio.FileInfo` according to `is_hidden`.
    /// See `G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN`.
    extern fn g_file_info_set_is_hidden(p_info: *FileInfo, p_is_hidden: c_int) void;
    pub const setIsHidden = g_file_info_set_is_hidden;

    /// Sets the "is_symlink" attribute in a `gio.FileInfo` according to `is_symlink`.
    /// See `G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK`.
    extern fn g_file_info_set_is_symlink(p_info: *FileInfo, p_is_symlink: c_int) void;
    pub const setIsSymlink = g_file_info_set_is_symlink;

    /// Sets the `G_FILE_ATTRIBUTE_TIME_MODIFIED` and
    /// `G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC` attributes in the file info to the
    /// given date/time value.
    ///
    /// `G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC` will be cleared.
    extern fn g_file_info_set_modification_date_time(p_info: *FileInfo, p_mtime: *glib.DateTime) void;
    pub const setModificationDateTime = g_file_info_set_modification_date_time;

    /// Sets the `G_FILE_ATTRIBUTE_TIME_MODIFIED` and
    /// `G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC` attributes in the file info to the
    /// given time value.
    ///
    /// `G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC` will be cleared.
    extern fn g_file_info_set_modification_time(p_info: *FileInfo, p_mtime: *glib.TimeVal) void;
    pub const setModificationTime = g_file_info_set_modification_time;

    /// Sets the name attribute for the current `gio.FileInfo`.
    /// See `G_FILE_ATTRIBUTE_STANDARD_NAME`.
    extern fn g_file_info_set_name(p_info: *FileInfo, p_name: [*:0]const u8) void;
    pub const setName = g_file_info_set_name;

    /// Sets the `G_FILE_ATTRIBUTE_STANDARD_SIZE` attribute in the file info
    /// to the given size.
    extern fn g_file_info_set_size(p_info: *FileInfo, p_size: i64) void;
    pub const setSize = g_file_info_set_size;

    /// Sets the sort order attribute in the file info structure. See
    /// `G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER`.
    extern fn g_file_info_set_sort_order(p_info: *FileInfo, p_sort_order: i32) void;
    pub const setSortOrder = g_file_info_set_sort_order;

    /// Sets the symbolic icon for a given `gio.FileInfo`.
    /// See `G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON`.
    extern fn g_file_info_set_symbolic_icon(p_info: *FileInfo, p_icon: *gio.Icon) void;
    pub const setSymbolicIcon = g_file_info_set_symbolic_icon;

    /// Sets the `G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET` attribute in the file info
    /// to the given symlink target.
    extern fn g_file_info_set_symlink_target(p_info: *FileInfo, p_symlink_target: [*:0]const u8) void;
    pub const setSymlinkTarget = g_file_info_set_symlink_target;

    /// Unsets a mask set by `gio.FileInfo.setAttributeMask`, if one
    /// is set.
    extern fn g_file_info_unset_attribute_mask(p_info: *FileInfo) void;
    pub const unsetAttributeMask = g_file_info_unset_attribute_mask;

    extern fn g_file_info_get_type() usize;
    pub const getGObjectType = g_file_info_get_type;

    extern fn g_object_ref(p_self: *gio.FileInfo) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.FileInfo) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FileInfo, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GFileInputStream` provides input streams that take their
/// content from a file.
///
/// `GFileInputStream` implements `gio.Seekable`, which allows the input
/// stream to jump to arbitrary positions in the file, provided the
/// filesystem of the file allows it. To find the position of a file
/// input stream, use `gio.Seekable.tell`. To find out if a file input
/// stream supports seeking, use `gio.Seekable.virtual_methods.can_seek`.
/// To position a file input stream, use `gio.Seekable.virtual_methods.seek`.
pub const FileInputStream = extern struct {
    pub const Parent = gio.InputStream;
    pub const Implements = [_]type{gio.Seekable};
    pub const Class = gio.FileInputStreamClass;
    f_parent_instance: gio.InputStream,
    f_priv: ?*gio.FileInputStreamPrivate,

    pub const virtual_methods = struct {
        pub const can_seek = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(FileInputStream.Class, p_class).f_can_seek.?(gobject.ext.as(FileInputStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(FileInputStream.Class, p_class).f_can_seek = @ptrCast(p_implementation);
            }
        };

        /// Queries a file input stream the given `attributes`. This function blocks
        /// while querying the stream. For the asynchronous (non-blocking) version
        /// of this function, see `gio.FileInputStream.queryInfoAsync`. While the
        /// stream is blocked, the stream will set the pending flag internally, and
        /// any other operations on the stream will fail with `G_IO_ERROR_PENDING`.
        pub const query_info = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileInfo {
                return gobject.ext.as(FileInputStream.Class, p_class).f_query_info.?(gobject.ext.as(FileInputStream, p_stream), p_attributes, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo) void {
                gobject.ext.as(FileInputStream.Class, p_class).f_query_info = @ptrCast(p_implementation);
            }
        };

        /// Queries the stream information asynchronously.
        /// When the operation is finished `callback` will be called.
        /// You can then call `gio.FileInputStream.queryInfoFinish`
        /// to get the result of the operation.
        ///
        /// For the synchronous version of this function,
        /// see `gio.FileInputStream.queryInfo`.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be set
        pub const query_info_async = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(FileInputStream.Class, p_class).f_query_info_async.?(gobject.ext.as(FileInputStream, p_stream), p_attributes, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(FileInputStream.Class, p_class).f_query_info_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous info query operation.
        pub const query_info_finish = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileInfo {
                return gobject.ext.as(FileInputStream.Class, p_class).f_query_info_finish.?(gobject.ext.as(FileInputStream, p_stream), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo) void {
                gobject.ext.as(FileInputStream.Class, p_class).f_query_info_finish = @ptrCast(p_implementation);
            }
        };

        pub const seek = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_offset: i64, p_type: glib.SeekType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(FileInputStream.Class, p_class).f_seek.?(gobject.ext.as(FileInputStream, p_stream), p_offset, p_type, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_offset: i64, p_type: glib.SeekType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(FileInputStream.Class, p_class).f_seek = @ptrCast(p_implementation);
            }
        };

        pub const tell = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) i64 {
                return gobject.ext.as(FileInputStream.Class, p_class).f_tell.?(gobject.ext.as(FileInputStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) i64) void {
                gobject.ext.as(FileInputStream.Class, p_class).f_tell = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Queries a file input stream the given `attributes`. This function blocks
    /// while querying the stream. For the asynchronous (non-blocking) version
    /// of this function, see `gio.FileInputStream.queryInfoAsync`. While the
    /// stream is blocked, the stream will set the pending flag internally, and
    /// any other operations on the stream will fail with `G_IO_ERROR_PENDING`.
    extern fn g_file_input_stream_query_info(p_stream: *FileInputStream, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileInfo;
    pub const queryInfo = g_file_input_stream_query_info;

    /// Queries the stream information asynchronously.
    /// When the operation is finished `callback` will be called.
    /// You can then call `gio.FileInputStream.queryInfoFinish`
    /// to get the result of the operation.
    ///
    /// For the synchronous version of this function,
    /// see `gio.FileInputStream.queryInfo`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be set
    extern fn g_file_input_stream_query_info_async(p_stream: *FileInputStream, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const queryInfoAsync = g_file_input_stream_query_info_async;

    /// Finishes an asynchronous info query operation.
    extern fn g_file_input_stream_query_info_finish(p_stream: *FileInputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileInfo;
    pub const queryInfoFinish = g_file_input_stream_query_info_finish;

    extern fn g_file_input_stream_get_type() usize;
    pub const getGObjectType = g_file_input_stream_get_type;

    extern fn g_object_ref(p_self: *gio.FileInputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.FileInputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FileInputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Monitors a file or directory for changes.
///
/// To obtain a `GFileMonitor` for a file or directory, use
/// `gio.File.monitor`, `gio.File.monitorFile`, or
/// `gio.File.monitorDirectory`.
///
/// To get informed about changes to the file or directory you are
/// monitoring, connect to the `gio.FileMonitor.signals.changed` signal. The
/// signal will be emitted in the thread-default main context (see
/// `glib.MainContext.pushThreadDefault`) of the thread that the monitor
/// was created in (though if the global default main context is blocked, this
/// may cause notifications to be blocked even if the thread-default
/// context is still running).
pub const FileMonitor = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.FileMonitorClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.FileMonitorPrivate,

    pub const virtual_methods = struct {
        /// Cancels a file monitor.
        pub const cancel = struct {
            pub fn call(p_class: anytype, p_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(FileMonitor.Class, p_class).f_cancel.?(gobject.ext.as(FileMonitor, p_monitor));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(FileMonitor.Class, p_class).f_cancel = @ptrCast(p_implementation);
            }
        };

        pub const changed = struct {
            pub fn call(p_class: anytype, p_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_file: *gio.File, p_other_file: *gio.File, p_event_type: gio.FileMonitorEvent) void {
                return gobject.ext.as(FileMonitor.Class, p_class).f_changed.?(gobject.ext.as(FileMonitor, p_monitor), p_file, p_other_file, p_event_type);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_file: *gio.File, p_other_file: *gio.File, p_event_type: gio.FileMonitorEvent) callconv(.c) void) void {
                gobject.ext.as(FileMonitor.Class, p_class).f_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Whether the monitor has been cancelled.
        pub const cancelled = struct {
            pub const name = "cancelled";

            pub const Type = c_int;
        };

        /// The limit of the monitor to watch for changes, in milliseconds.
        pub const rate_limit = struct {
            pub const name = "rate-limit";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted when `file` has been changed.
        ///
        /// If using `G_FILE_MONITOR_WATCH_MOVES` on a directory monitor, and
        /// the information is available (and if supported by the backend),
        /// `event_type` may be `G_FILE_MONITOR_EVENT_RENAMED`,
        /// `G_FILE_MONITOR_EVENT_MOVED_IN` or `G_FILE_MONITOR_EVENT_MOVED_OUT`.
        ///
        /// In all cases `file` will be a child of the monitored directory.  For
        /// renames, `file` will be the old name and `other_file` is the new
        /// name.  For "moved in" events, `file` is the name of the file that
        /// appeared and `other_file` is the old name that it was moved from (in
        /// another directory).  For "moved out" events, `file` is the name of
        /// the file that used to be in this directory and `other_file` is the
        /// name of the file at its new location.
        ///
        /// It makes sense to treat `G_FILE_MONITOR_EVENT_MOVED_IN` as
        /// equivalent to `G_FILE_MONITOR_EVENT_CREATED` and
        /// `G_FILE_MONITOR_EVENT_MOVED_OUT` as equivalent to
        /// `G_FILE_MONITOR_EVENT_DELETED`, with extra information.
        /// `G_FILE_MONITOR_EVENT_RENAMED` is equivalent to a delete/create
        /// pair.  This is exactly how the events will be reported in the case
        /// that the `G_FILE_MONITOR_WATCH_MOVES` flag is not in use.
        ///
        /// If using the deprecated flag `G_FILE_MONITOR_SEND_MOVED` flag and `event_type` is
        /// `G_FILE_MONITOR_EVENT_MOVED`, `file` will be set to a `gio.File` containing the
        /// old path, and `other_file` will be set to a `gio.File` containing the new path.
        ///
        /// In all the other cases, `other_file` will be set to `NULL`.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_file: *gio.File, p_other_file: ?*gio.File, p_event_type: gio.FileMonitorEvent, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FileMonitor, p_instance))),
                    gobject.signalLookup("changed", FileMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Cancels a file monitor.
    extern fn g_file_monitor_cancel(p_monitor: *FileMonitor) c_int;
    pub const cancel = g_file_monitor_cancel;

    /// Emits the `gio.FileMonitor.signals.changed` signal if a change
    /// has taken place. Should be called from file monitor
    /// implementations only.
    ///
    /// Implementations are responsible to call this method from the
    /// thread-default main context (see `glib.MainContext.pushThreadDefault`)
    /// of the thread that the monitor was created in.
    extern fn g_file_monitor_emit_event(p_monitor: *FileMonitor, p_child: *gio.File, p_other_file: *gio.File, p_event_type: gio.FileMonitorEvent) void;
    pub const emitEvent = g_file_monitor_emit_event;

    /// Returns whether the monitor is canceled.
    extern fn g_file_monitor_is_cancelled(p_monitor: *FileMonitor) c_int;
    pub const isCancelled = g_file_monitor_is_cancelled;

    /// Sets the rate limit to which the `monitor` will report
    /// consecutive change events to the same file.
    extern fn g_file_monitor_set_rate_limit(p_monitor: *FileMonitor, p_limit_msecs: c_int) void;
    pub const setRateLimit = g_file_monitor_set_rate_limit;

    extern fn g_file_monitor_get_type() usize;
    pub const getGObjectType = g_file_monitor_get_type;

    extern fn g_object_ref(p_self: *gio.FileMonitor) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.FileMonitor) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FileMonitor, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GFileOutputStream` provides output streams that write their
/// content to a file.
///
/// `GFileOutputStream` implements `gio.Seekable`, which allows the output
/// stream to jump to arbitrary positions in the file and to truncate
/// the file, provided the filesystem of the file supports these
/// operations.
///
/// To find the position of a file output stream, use `gio.Seekable.tell`.
/// To find out if a file output stream supports seeking, use
/// `gio.Seekable.canSeek`.To position a file output stream, use
/// `gio.Seekable.seek`. To find out if a file output stream supports
/// truncating, use `gio.Seekable.canTruncate`. To truncate a file output
/// stream, use `gio.Seekable.truncate`.
pub const FileOutputStream = extern struct {
    pub const Parent = gio.OutputStream;
    pub const Implements = [_]type{gio.Seekable};
    pub const Class = gio.FileOutputStreamClass;
    f_parent_instance: gio.OutputStream,
    f_priv: ?*gio.FileOutputStreamPrivate,

    pub const virtual_methods = struct {
        pub const can_seek = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(FileOutputStream.Class, p_class).f_can_seek.?(gobject.ext.as(FileOutputStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(FileOutputStream.Class, p_class).f_can_seek = @ptrCast(p_implementation);
            }
        };

        pub const can_truncate = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(FileOutputStream.Class, p_class).f_can_truncate.?(gobject.ext.as(FileOutputStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(FileOutputStream.Class, p_class).f_can_truncate = @ptrCast(p_implementation);
            }
        };

        /// Gets the entity tag for the file when it has been written.
        /// This must be called after the stream has been written
        /// and closed, as the etag can change while writing.
        pub const get_etag = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]u8 {
                return gobject.ext.as(FileOutputStream.Class, p_class).f_get_etag.?(gobject.ext.as(FileOutputStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]u8) void {
                gobject.ext.as(FileOutputStream.Class, p_class).f_get_etag = @ptrCast(p_implementation);
            }
        };

        /// Queries a file output stream for the given `attributes`.
        /// This function blocks while querying the stream. For the asynchronous
        /// version of this function, see `gio.FileOutputStream.queryInfoAsync`.
        /// While the stream is blocked, the stream will set the pending flag
        /// internally, and any other operations on the stream will fail with
        /// `G_IO_ERROR_PENDING`.
        ///
        /// Can fail if the stream was already closed (with `error` being set to
        /// `G_IO_ERROR_CLOSED`), the stream has pending operations (with `error` being
        /// set to `G_IO_ERROR_PENDING`), or if querying info is not supported for
        /// the stream's interface (with `error` being set to `G_IO_ERROR_NOT_SUPPORTED`). In
        /// all cases of failure, `NULL` will be returned.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be set, and `NULL` will
        /// be returned.
        pub const query_info = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileInfo {
                return gobject.ext.as(FileOutputStream.Class, p_class).f_query_info.?(gobject.ext.as(FileOutputStream, p_stream), p_attributes, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo) void {
                gobject.ext.as(FileOutputStream.Class, p_class).f_query_info = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously queries the `stream` for a `gio.FileInfo`. When completed,
        /// `callback` will be called with a `gio.AsyncResult` which can be used to
        /// finish the operation with `gio.FileOutputStream.queryInfoFinish`.
        ///
        /// For the synchronous version of this function, see
        /// `gio.FileOutputStream.queryInfo`.
        pub const query_info_async = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(FileOutputStream.Class, p_class).f_query_info_async.?(gobject.ext.as(FileOutputStream, p_stream), p_attributes, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(FileOutputStream.Class, p_class).f_query_info_async = @ptrCast(p_implementation);
            }
        };

        /// Finalizes the asynchronous query started
        /// by `gio.FileOutputStream.queryInfoAsync`.
        pub const query_info_finish = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileInfo {
                return gobject.ext.as(FileOutputStream.Class, p_class).f_query_info_finish.?(gobject.ext.as(FileOutputStream, p_stream), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo) void {
                gobject.ext.as(FileOutputStream.Class, p_class).f_query_info_finish = @ptrCast(p_implementation);
            }
        };

        pub const seek = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_offset: i64, p_type: glib.SeekType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(FileOutputStream.Class, p_class).f_seek.?(gobject.ext.as(FileOutputStream, p_stream), p_offset, p_type, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_offset: i64, p_type: glib.SeekType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(FileOutputStream.Class, p_class).f_seek = @ptrCast(p_implementation);
            }
        };

        pub const tell = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) i64 {
                return gobject.ext.as(FileOutputStream.Class, p_class).f_tell.?(gobject.ext.as(FileOutputStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) i64) void {
                gobject.ext.as(FileOutputStream.Class, p_class).f_tell = @ptrCast(p_implementation);
            }
        };

        pub const truncate_fn = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_size: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(FileOutputStream.Class, p_class).f_truncate_fn.?(gobject.ext.as(FileOutputStream, p_stream), p_size, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_size: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(FileOutputStream.Class, p_class).f_truncate_fn = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Gets the entity tag for the file when it has been written.
    /// This must be called after the stream has been written
    /// and closed, as the etag can change while writing.
    extern fn g_file_output_stream_get_etag(p_stream: *FileOutputStream) ?[*:0]u8;
    pub const getEtag = g_file_output_stream_get_etag;

    /// Queries a file output stream for the given `attributes`.
    /// This function blocks while querying the stream. For the asynchronous
    /// version of this function, see `gio.FileOutputStream.queryInfoAsync`.
    /// While the stream is blocked, the stream will set the pending flag
    /// internally, and any other operations on the stream will fail with
    /// `G_IO_ERROR_PENDING`.
    ///
    /// Can fail if the stream was already closed (with `error` being set to
    /// `G_IO_ERROR_CLOSED`), the stream has pending operations (with `error` being
    /// set to `G_IO_ERROR_PENDING`), or if querying info is not supported for
    /// the stream's interface (with `error` being set to `G_IO_ERROR_NOT_SUPPORTED`). In
    /// all cases of failure, `NULL` will be returned.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be set, and `NULL` will
    /// be returned.
    extern fn g_file_output_stream_query_info(p_stream: *FileOutputStream, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileInfo;
    pub const queryInfo = g_file_output_stream_query_info;

    /// Asynchronously queries the `stream` for a `gio.FileInfo`. When completed,
    /// `callback` will be called with a `gio.AsyncResult` which can be used to
    /// finish the operation with `gio.FileOutputStream.queryInfoFinish`.
    ///
    /// For the synchronous version of this function, see
    /// `gio.FileOutputStream.queryInfo`.
    extern fn g_file_output_stream_query_info_async(p_stream: *FileOutputStream, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const queryInfoAsync = g_file_output_stream_query_info_async;

    /// Finalizes the asynchronous query started
    /// by `gio.FileOutputStream.queryInfoAsync`.
    extern fn g_file_output_stream_query_info_finish(p_stream: *FileOutputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileInfo;
    pub const queryInfoFinish = g_file_output_stream_query_info_finish;

    extern fn g_file_output_stream_get_type() usize;
    pub const getGObjectType = g_file_output_stream_get_type;

    extern fn g_object_ref(p_self: *gio.FileOutputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.FileOutputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FileOutputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Completes partial file and directory names given a partial string by
/// looking in the file system for clues. Can return a list of possible
/// completion strings for widget implementations.
pub const FilenameCompleter = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.FilenameCompleterClass;
    pub const virtual_methods = struct {
        pub const got_completion_data = struct {
            pub fn call(p_class: anytype, p_filename_completer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(FilenameCompleter.Class, p_class).f_got_completion_data.?(gobject.ext.as(FilenameCompleter, p_filename_completer));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_filename_completer: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(FilenameCompleter.Class, p_class).f_got_completion_data = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// Emitted when the file name completion information comes available.
        pub const got_completion_data = struct {
            pub const name = "got-completion-data";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(FilenameCompleter, p_instance))),
                    gobject.signalLookup("got-completion-data", FilenameCompleter.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new filename completer.
    extern fn g_filename_completer_new() *gio.FilenameCompleter;
    pub const new = g_filename_completer_new;

    /// Obtains a completion for `initial_text` from `completer`.
    extern fn g_filename_completer_get_completion_suffix(p_completer: *FilenameCompleter, p_initial_text: [*:0]const u8) ?[*:0]u8;
    pub const getCompletionSuffix = g_filename_completer_get_completion_suffix;

    /// Gets an array of completion strings for a given initial text.
    extern fn g_filename_completer_get_completions(p_completer: *FilenameCompleter, p_initial_text: [*:0]const u8) [*][*:0]u8;
    pub const getCompletions = g_filename_completer_get_completions;

    /// If `dirs_only` is `TRUE`, `completer` will only
    /// complete directory names, and not file names.
    extern fn g_filename_completer_set_dirs_only(p_completer: *FilenameCompleter, p_dirs_only: c_int) void;
    pub const setDirsOnly = g_filename_completer_set_dirs_only;

    extern fn g_filename_completer_get_type() usize;
    pub const getGObjectType = g_filename_completer_get_type;

    extern fn g_object_ref(p_self: *gio.FilenameCompleter) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.FilenameCompleter) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FilenameCompleter, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Base class for input stream implementations that perform some
/// kind of filtering operation on a base stream. Typical examples
/// of filtering operations are character set conversion, compression
/// and byte order flipping.
pub const FilterInputStream = extern struct {
    pub const Parent = gio.InputStream;
    pub const Implements = [_]type{};
    pub const Class = gio.FilterInputStreamClass;
    f_parent_instance: gio.InputStream,
    f_base_stream: ?*gio.InputStream,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The underlying base stream on which the I/O ops will be done.
        pub const base_stream = struct {
            pub const name = "base-stream";

            pub const Type = ?*gio.InputStream;
        };

        /// Whether the base stream should be closed when the filter stream is closed.
        pub const close_base_stream = struct {
            pub const name = "close-base-stream";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Gets the base stream for the filter stream.
    extern fn g_filter_input_stream_get_base_stream(p_stream: *FilterInputStream) *gio.InputStream;
    pub const getBaseStream = g_filter_input_stream_get_base_stream;

    /// Returns whether the base stream will be closed when `stream` is
    /// closed.
    extern fn g_filter_input_stream_get_close_base_stream(p_stream: *FilterInputStream) c_int;
    pub const getCloseBaseStream = g_filter_input_stream_get_close_base_stream;

    /// Sets whether the base stream will be closed when `stream` is closed.
    extern fn g_filter_input_stream_set_close_base_stream(p_stream: *FilterInputStream, p_close_base: c_int) void;
    pub const setCloseBaseStream = g_filter_input_stream_set_close_base_stream;

    extern fn g_filter_input_stream_get_type() usize;
    pub const getGObjectType = g_filter_input_stream_get_type;

    extern fn g_object_ref(p_self: *gio.FilterInputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.FilterInputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FilterInputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Base class for output stream implementations that perform some
/// kind of filtering operation on a base stream. Typical examples
/// of filtering operations are character set conversion, compression
/// and byte order flipping.
pub const FilterOutputStream = extern struct {
    pub const Parent = gio.OutputStream;
    pub const Implements = [_]type{};
    pub const Class = gio.FilterOutputStreamClass;
    f_parent_instance: gio.OutputStream,
    f_base_stream: ?*gio.OutputStream,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The underlying base stream on which the I/O ops will be done.
        pub const base_stream = struct {
            pub const name = "base-stream";

            pub const Type = ?*gio.OutputStream;
        };

        /// Whether the base stream should be closed when the filter stream is closed.
        pub const close_base_stream = struct {
            pub const name = "close-base-stream";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Gets the base stream for the filter stream.
    extern fn g_filter_output_stream_get_base_stream(p_stream: *FilterOutputStream) *gio.OutputStream;
    pub const getBaseStream = g_filter_output_stream_get_base_stream;

    /// Returns whether the base stream will be closed when `stream` is
    /// closed.
    extern fn g_filter_output_stream_get_close_base_stream(p_stream: *FilterOutputStream) c_int;
    pub const getCloseBaseStream = g_filter_output_stream_get_close_base_stream;

    /// Sets whether the base stream will be closed when `stream` is closed.
    extern fn g_filter_output_stream_set_close_base_stream(p_stream: *FilterOutputStream, p_close_base: c_int) void;
    pub const setCloseBaseStream = g_filter_output_stream_set_close_base_stream;

    extern fn g_filter_output_stream_get_type() usize;
    pub const getGObjectType = g_filter_output_stream_get_type;

    extern fn g_object_ref(p_self: *gio.FilterOutputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.FilterOutputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FilterOutputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Provides an interface and default functions for loading and unloading
/// modules. This is used internally to make GIO extensible, but can also
/// be used by others to implement module loading.
pub const IOModule = opaque {
    pub const Parent = gobject.TypeModule;
    pub const Implements = [_]type{gobject.TypePlugin};
    pub const Class = gio.IOModuleClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Optional API for GIO modules to implement.
    ///
    /// Should return a list of all the extension points that may be
    /// implemented in this module.
    ///
    /// This method will not be called in normal use, however it may be
    /// called when probing existing modules and recording which extension
    /// points that this model is used for. This means we won't have to
    /// load and initialize this module unless its needed.
    ///
    /// If this function is not implemented by the module the module will
    /// always be loaded, initialized and then unloaded on application
    /// startup so that it can register its extension points during init.
    ///
    /// Note that a module need not actually implement all the extension
    /// points that `gio.IOModule.query` returns, since the exact list of
    /// extension may depend on runtime issues. However all extension
    /// points actually implemented must be returned by `gio.IOModule.query`
    /// (if defined).
    ///
    /// When installing a module that implements `gio.IOModule.query` you must
    /// run gio-querymodules in order to build the cache files required for
    /// lazy loading.
    ///
    /// Since 2.56, this function should be named `g_io_<modulename>_query`, where
    /// `modulename` is the plugin’s filename with the `lib` or `libgio` prefix and
    /// everything after the first dot removed, and with `-` replaced with `_`
    /// throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.
    /// Using the new symbol names avoids name clashes when building modules
    /// statically. The old symbol names continue to be supported, but cannot be used
    /// for static builds.
    extern fn g_io_module_query() [*][*:0]u8;
    pub const query = g_io_module_query;

    /// Creates a new GIOModule that will load the specific
    /// shared library when in use.
    extern fn g_io_module_new(p_filename: [*:0]const u8) *gio.IOModule;
    pub const new = g_io_module_new;

    /// Required API for GIO modules to implement.
    ///
    /// This function is run after the module has been loaded into GIO,
    /// to initialize the module. Typically, this function will call
    /// `gio.ioExtensionPointImplement`.
    ///
    /// Since 2.56, this function should be named `g_io_<modulename>_load`, where
    /// `modulename` is the plugin’s filename with the `lib` or `libgio` prefix and
    /// everything after the first dot removed, and with `-` replaced with `_`
    /// throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.
    /// Using the new symbol names avoids name clashes when building modules
    /// statically. The old symbol names continue to be supported, but cannot be used
    /// for static builds.
    extern fn g_io_module_load(p_module: *IOModule) void;
    pub const load = g_io_module_load;

    /// Required API for GIO modules to implement.
    ///
    /// This function is run when the module is being unloaded from GIO,
    /// to finalize the module.
    ///
    /// Since 2.56, this function should be named `g_io_<modulename>_unload`, where
    /// `modulename` is the plugin’s filename with the `lib` or `libgio` prefix and
    /// everything after the first dot removed, and with `-` replaced with `_`
    /// throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.
    /// Using the new symbol names avoids name clashes when building modules
    /// statically. The old symbol names continue to be supported, but cannot be used
    /// for static builds.
    extern fn g_io_module_unload(p_module: *IOModule) void;
    pub const unload = g_io_module_unload;

    extern fn g_io_module_get_type() usize;
    pub const getGObjectType = g_io_module_get_type;

    extern fn g_object_ref(p_self: *gio.IOModule) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.IOModule) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *IOModule, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GIOStream` represents an object that has both read and write streams.
/// Generally the two streams act as separate input and output streams,
/// but they share some common resources and state. For instance, for
/// seekable streams, both streams may use the same position.
///
/// Examples of `GIOStream` objects are `gio.SocketConnection`, which represents
/// a two-way network connection; and `gio.FileIOStream`, which represents a
/// file handle opened in read-write mode.
///
/// To do the actual reading and writing you need to get the substreams
/// with `gio.IOStream.getInputStream` and
/// `gio.IOStream.getOutputStream`.
///
/// The `GIOStream` object owns the input and the output streams, not the other
/// way around, so keeping the substreams alive will not keep the `GIOStream`
/// object alive. If the `GIOStream` object is freed it will be closed, thus
/// closing the substreams, so even if the substreams stay alive they will
/// always return `G_IO_ERROR_CLOSED` for all operations.
///
/// To close a stream use `gio.IOStream.close` which will close the common
/// stream object and also the individual substreams. You can also close
/// the substreams themselves. In most cases this only marks the
/// substream as closed, so further I/O on it fails but common state in the
/// `GIOStream` may still be open. However, some streams may support
/// ‘half-closed’ states where one direction of the stream is actually shut down.
///
/// Operations on `GIOStream`s cannot be started while another operation on the
/// `GIOStream` or its substreams is in progress. Specifically, an application can
/// read from the `gio.InputStream` and write to the
/// `gio.OutputStream` simultaneously (either in separate threads, or as
/// asynchronous operations in the same thread), but an application cannot start
/// any `GIOStream` operation while there is a `GIOStream`, `GInputStream` or
/// `GOutputStream` operation in progress, and an application can’t start any
/// `GInputStream` or `GOutputStream` operation while there is a `GIOStream`
/// operation in progress.
///
/// This is a product of individual stream operations being associated with a
/// given `glib.MainContext` (the thread-default context at the time the
/// operation was started), rather than entire streams being associated with a
/// single `GMainContext`.
///
/// GIO may run operations on `GIOStream`s from other (worker) threads, and this
/// may be exposed to application code in the behaviour of wrapper streams, such
/// as `gio.BufferedInputStream` or `gio.TlsConnection`. With such
/// wrapper APIs, application code may only run operations on the base (wrapped)
/// stream when the wrapper stream is idle. Note that the semantics of such
/// operations may not be well-defined due to the state the wrapper stream leaves
/// the base stream in (though they are guaranteed not to crash).
pub const IOStream = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.IOStreamClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.IOStreamPrivate,

    pub const virtual_methods = struct {
        /// Requests an asynchronous close of the stream, releasing resources
        /// related to it. When the operation is finished `callback` will be
        /// called. You can then call `gio.IOStream.closeFinish` to get
        /// the result of the operation.
        ///
        /// For behaviour details see `gio.IOStream.close`.
        ///
        /// The asynchronous methods have a default fallback that uses threads
        /// to implement asynchronicity, so they are optional for inheriting
        /// classes. However, if you override one you must override all.
        pub const close_async = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(IOStream.Class, p_class).f_close_async.?(gobject.ext.as(IOStream, p_stream), p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(IOStream.Class, p_class).f_close_async = @ptrCast(p_implementation);
            }
        };

        /// Closes a stream.
        pub const close_finish = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(IOStream.Class, p_class).f_close_finish.?(gobject.ext.as(IOStream, p_stream), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(IOStream.Class, p_class).f_close_finish = @ptrCast(p_implementation);
            }
        };

        pub const close_fn = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(IOStream.Class, p_class).f_close_fn.?(gobject.ext.as(IOStream, p_stream), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(IOStream.Class, p_class).f_close_fn = @ptrCast(p_implementation);
            }
        };

        /// Gets the input stream for this object. This is used
        /// for reading.
        pub const get_input_stream = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.InputStream {
                return gobject.ext.as(IOStream.Class, p_class).f_get_input_stream.?(gobject.ext.as(IOStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.InputStream) void {
                gobject.ext.as(IOStream.Class, p_class).f_get_input_stream = @ptrCast(p_implementation);
            }
        };

        /// Gets the output stream for this object. This is used for
        /// writing.
        pub const get_output_stream = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.OutputStream {
                return gobject.ext.as(IOStream.Class, p_class).f_get_output_stream.?(gobject.ext.as(IOStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.OutputStream) void {
                gobject.ext.as(IOStream.Class, p_class).f_get_output_stream = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Whether the stream is closed.
        pub const closed = struct {
            pub const name = "closed";

            pub const Type = c_int;
        };

        /// The `gio.InputStream` to read from.
        pub const input_stream = struct {
            pub const name = "input-stream";

            pub const Type = ?*gio.InputStream;
        };

        /// The `gio.OutputStream` to write to.
        pub const output_stream = struct {
            pub const name = "output-stream";

            pub const Type = ?*gio.OutputStream;
        };
    };

    pub const signals = struct {};

    /// Finishes an asynchronous io stream splice operation.
    extern fn g_io_stream_splice_finish(p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const spliceFinish = g_io_stream_splice_finish;

    /// Clears the pending flag on `stream`.
    extern fn g_io_stream_clear_pending(p_stream: *IOStream) void;
    pub const clearPending = g_io_stream_clear_pending;

    /// Closes the stream, releasing resources related to it. This will also
    /// close the individual input and output streams, if they are not already
    /// closed.
    ///
    /// Once the stream is closed, all other operations will return
    /// `G_IO_ERROR_CLOSED`. Closing a stream multiple times will not
    /// return an error.
    ///
    /// Closing a stream will automatically flush any outstanding buffers
    /// in the stream.
    ///
    /// Streams will be automatically closed when the last reference
    /// is dropped, but you might want to call this function to make sure
    /// resources are released as early as possible.
    ///
    /// Some streams might keep the backing store of the stream (e.g. a file
    /// descriptor) open after the stream is closed. See the documentation for
    /// the individual stream for details.
    ///
    /// On failure the first error that happened will be reported, but the
    /// close operation will finish as much as possible. A stream that failed
    /// to close will still return `G_IO_ERROR_CLOSED` for all operations.
    /// Still, it is important to check and report the error to the user,
    /// otherwise there might be a loss of data as all data might not be written.
    ///
    /// If `cancellable` is not NULL, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    /// Cancelling a close will still leave the stream closed, but some streams
    /// can use a faster close that doesn't block to e.g. check errors.
    ///
    /// The default implementation of this method just calls close on the
    /// individual input/output streams.
    extern fn g_io_stream_close(p_stream: *IOStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const close = g_io_stream_close;

    /// Requests an asynchronous close of the stream, releasing resources
    /// related to it. When the operation is finished `callback` will be
    /// called. You can then call `gio.IOStream.closeFinish` to get
    /// the result of the operation.
    ///
    /// For behaviour details see `gio.IOStream.close`.
    ///
    /// The asynchronous methods have a default fallback that uses threads
    /// to implement asynchronicity, so they are optional for inheriting
    /// classes. However, if you override one you must override all.
    extern fn g_io_stream_close_async(p_stream: *IOStream, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const closeAsync = g_io_stream_close_async;

    /// Closes a stream.
    extern fn g_io_stream_close_finish(p_stream: *IOStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const closeFinish = g_io_stream_close_finish;

    /// Gets the input stream for this object. This is used
    /// for reading.
    extern fn g_io_stream_get_input_stream(p_stream: *IOStream) *gio.InputStream;
    pub const getInputStream = g_io_stream_get_input_stream;

    /// Gets the output stream for this object. This is used for
    /// writing.
    extern fn g_io_stream_get_output_stream(p_stream: *IOStream) *gio.OutputStream;
    pub const getOutputStream = g_io_stream_get_output_stream;

    /// Checks if a stream has pending actions.
    extern fn g_io_stream_has_pending(p_stream: *IOStream) c_int;
    pub const hasPending = g_io_stream_has_pending;

    /// Checks if a stream is closed.
    extern fn g_io_stream_is_closed(p_stream: *IOStream) c_int;
    pub const isClosed = g_io_stream_is_closed;

    /// Sets `stream` to have actions pending. If the pending flag is
    /// already set or `stream` is closed, it will return `FALSE` and set
    /// `error`.
    extern fn g_io_stream_set_pending(p_stream: *IOStream, p_error: ?*?*glib.Error) c_int;
    pub const setPending = g_io_stream_set_pending;

    /// Asynchronously splice the output stream of `stream1` to the input stream of
    /// `stream2`, and splice the output stream of `stream2` to the input stream of
    /// `stream1`.
    ///
    /// When the operation is finished `callback` will be called.
    /// You can then call `gio.IOStream.spliceFinish` to get the
    /// result of the operation.
    extern fn g_io_stream_splice_async(p_stream1: *IOStream, p_stream2: *gio.IOStream, p_flags: gio.IOStreamSpliceFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const spliceAsync = g_io_stream_splice_async;

    extern fn g_io_stream_get_type() usize;
    pub const getGObjectType = g_io_stream_get_type;

    extern fn g_object_ref(p_self: *gio.IOStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.IOStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *IOStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GInetAddress` represents an IPv4 or IPv6 internet address. Use
/// `gio.Resolver.lookupByName` or
/// `gio.Resolver.lookupByNameAsync` to look up the `GInetAddress` for
/// a hostname. Use `gio.Resolver.lookupByAddress` or
/// `gio.Resolver.lookupByAddressAsync` to look up the hostname for a
/// `GInetAddress`.
///
/// To actually connect to a remote host, you will need a
/// `gio.InetSocketAddress` (which includes a `GInetAddress` as well as a
/// port number).
pub const InetAddress = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.InetAddressClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.InetAddressPrivate,

    pub const virtual_methods = struct {
        /// Gets the raw binary address data from `address`.
        pub const to_bytes = struct {
            pub fn call(p_class: anytype, p_address: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *const u8 {
                return gobject.ext.as(InetAddress.Class, p_class).f_to_bytes.?(gobject.ext.as(InetAddress, p_address));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_address: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *const u8) void {
                gobject.ext.as(InetAddress.Class, p_class).f_to_bytes = @ptrCast(p_implementation);
            }
        };

        /// Converts `address` to string form.
        pub const to_string = struct {
            pub fn call(p_class: anytype, p_address: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]u8 {
                return gobject.ext.as(InetAddress.Class, p_class).f_to_string.?(gobject.ext.as(InetAddress, p_address));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_address: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]u8) void {
                gobject.ext.as(InetAddress.Class, p_class).f_to_string = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The raw address data.
        pub const bytes = struct {
            pub const name = "bytes";

            pub const Type = ?*anyopaque;
        };

        /// The address family (IPv4 or IPv6).
        pub const family = struct {
            pub const name = "family";

            pub const Type = gio.SocketFamily;
        };

        /// Whether this is the "any" address for its family.
        /// See `gio.InetAddress.getIsAny`.
        pub const is_any = struct {
            pub const name = "is-any";

            pub const Type = c_int;
        };

        /// Whether this is a link-local address.
        /// See `gio.InetAddress.getIsLinkLocal`.
        pub const is_link_local = struct {
            pub const name = "is-link-local";

            pub const Type = c_int;
        };

        /// Whether this is the loopback address for its family.
        /// See `gio.InetAddress.getIsLoopback`.
        pub const is_loopback = struct {
            pub const name = "is-loopback";

            pub const Type = c_int;
        };

        /// Whether this is a global multicast address.
        /// See `gio.InetAddress.getIsMcGlobal`.
        pub const is_mc_global = struct {
            pub const name = "is-mc-global";

            pub const Type = c_int;
        };

        /// Whether this is a link-local multicast address.
        /// See `gio.InetAddress.getIsMcLinkLocal`.
        pub const is_mc_link_local = struct {
            pub const name = "is-mc-link-local";

            pub const Type = c_int;
        };

        /// Whether this is a node-local multicast address.
        /// See `gio.InetAddress.getIsMcNodeLocal`.
        pub const is_mc_node_local = struct {
            pub const name = "is-mc-node-local";

            pub const Type = c_int;
        };

        /// Whether this is an organization-local multicast address.
        /// See `gio.InetAddress.getIsMcOrgLocal`.
        pub const is_mc_org_local = struct {
            pub const name = "is-mc-org-local";

            pub const Type = c_int;
        };

        /// Whether this is a site-local multicast address.
        /// See `gio.InetAddress.getIsMcSiteLocal`.
        pub const is_mc_site_local = struct {
            pub const name = "is-mc-site-local";

            pub const Type = c_int;
        };

        /// Whether this is a multicast address.
        /// See `gio.InetAddress.getIsMulticast`.
        pub const is_multicast = struct {
            pub const name = "is-multicast";

            pub const Type = c_int;
        };

        /// Whether this is a site-local address.
        /// See `gio.InetAddress.getIsLoopback`.
        pub const is_site_local = struct {
            pub const name = "is-site-local";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a `gio.InetAddress` for the "any" address (unassigned/"don't
    /// care") for `family`.
    extern fn g_inet_address_new_any(p_family: gio.SocketFamily) *gio.InetAddress;
    pub const newAny = g_inet_address_new_any;

    /// Creates a new `gio.InetAddress` from the given `family` and `bytes`.
    /// `bytes` should be 4 bytes for `G_SOCKET_FAMILY_IPV4` and 16 bytes for
    /// `G_SOCKET_FAMILY_IPV6`.
    extern fn g_inet_address_new_from_bytes(p_bytes: [*]const u8, p_family: gio.SocketFamily) *gio.InetAddress;
    pub const newFromBytes = g_inet_address_new_from_bytes;

    /// Parses `string` as an IP address and creates a new `gio.InetAddress`.
    extern fn g_inet_address_new_from_string(p_string: [*:0]const u8) ?*gio.InetAddress;
    pub const newFromString = g_inet_address_new_from_string;

    /// Creates a `gio.InetAddress` for the loopback address for `family`.
    extern fn g_inet_address_new_loopback(p_family: gio.SocketFamily) *gio.InetAddress;
    pub const newLoopback = g_inet_address_new_loopback;

    /// Checks if two `gio.InetAddress` instances are equal, e.g. the same address.
    extern fn g_inet_address_equal(p_address: *InetAddress, p_other_address: *gio.InetAddress) c_int;
    pub const equal = g_inet_address_equal;

    /// Gets `address`'s family
    extern fn g_inet_address_get_family(p_address: *InetAddress) gio.SocketFamily;
    pub const getFamily = g_inet_address_get_family;

    /// Tests whether `address` is the "any" address for its family.
    extern fn g_inet_address_get_is_any(p_address: *InetAddress) c_int;
    pub const getIsAny = g_inet_address_get_is_any;

    /// Tests whether `address` is a link-local address (that is, if it
    /// identifies a host on a local network that is not connected to the
    /// Internet).
    extern fn g_inet_address_get_is_link_local(p_address: *InetAddress) c_int;
    pub const getIsLinkLocal = g_inet_address_get_is_link_local;

    /// Tests whether `address` is the loopback address for its family.
    extern fn g_inet_address_get_is_loopback(p_address: *InetAddress) c_int;
    pub const getIsLoopback = g_inet_address_get_is_loopback;

    /// Tests whether `address` is a global multicast address.
    extern fn g_inet_address_get_is_mc_global(p_address: *InetAddress) c_int;
    pub const getIsMcGlobal = g_inet_address_get_is_mc_global;

    /// Tests whether `address` is a link-local multicast address.
    extern fn g_inet_address_get_is_mc_link_local(p_address: *InetAddress) c_int;
    pub const getIsMcLinkLocal = g_inet_address_get_is_mc_link_local;

    /// Tests whether `address` is a node-local multicast address.
    extern fn g_inet_address_get_is_mc_node_local(p_address: *InetAddress) c_int;
    pub const getIsMcNodeLocal = g_inet_address_get_is_mc_node_local;

    /// Tests whether `address` is an organization-local multicast address.
    extern fn g_inet_address_get_is_mc_org_local(p_address: *InetAddress) c_int;
    pub const getIsMcOrgLocal = g_inet_address_get_is_mc_org_local;

    /// Tests whether `address` is a site-local multicast address.
    extern fn g_inet_address_get_is_mc_site_local(p_address: *InetAddress) c_int;
    pub const getIsMcSiteLocal = g_inet_address_get_is_mc_site_local;

    /// Tests whether `address` is a multicast address.
    extern fn g_inet_address_get_is_multicast(p_address: *InetAddress) c_int;
    pub const getIsMulticast = g_inet_address_get_is_multicast;

    /// Tests whether `address` is a site-local address such as 10.0.0.1
    /// (that is, the address identifies a host on a local network that can
    /// not be reached directly from the Internet, but which may have
    /// outgoing Internet connectivity via a NAT or firewall).
    extern fn g_inet_address_get_is_site_local(p_address: *InetAddress) c_int;
    pub const getIsSiteLocal = g_inet_address_get_is_site_local;

    /// Gets the size of the native raw binary address for `address`. This
    /// is the size of the data that you get from `gio.InetAddress.toBytes`.
    extern fn g_inet_address_get_native_size(p_address: *InetAddress) usize;
    pub const getNativeSize = g_inet_address_get_native_size;

    /// Gets the raw binary address data from `address`.
    extern fn g_inet_address_to_bytes(p_address: *InetAddress) *const u8;
    pub const toBytes = g_inet_address_to_bytes;

    /// Converts `address` to string form.
    extern fn g_inet_address_to_string(p_address: *InetAddress) [*:0]u8;
    pub const toString = g_inet_address_to_string;

    extern fn g_inet_address_get_type() usize;
    pub const getGObjectType = g_inet_address_get_type;

    extern fn g_object_ref(p_self: *gio.InetAddress) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.InetAddress) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *InetAddress, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GInetAddressMask` represents a range of IPv4 or IPv6 addresses
/// described by a base address and a length indicating how many bits
/// of the base address are relevant for matching purposes. These are
/// often given in string form. For example, `10.0.0.0/8`, or `fe80::/10`.
pub const InetAddressMask = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.Initable};
    pub const Class = gio.InetAddressMaskClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.InetAddressMaskPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The base address.
        pub const address = struct {
            pub const name = "address";

            pub const Type = ?*gio.InetAddress;
        };

        /// The address family (IPv4 or IPv6).
        pub const family = struct {
            pub const name = "family";

            pub const Type = gio.SocketFamily;
        };

        /// The prefix length, in bytes.
        pub const length = struct {
            pub const name = "length";

            pub const Type = c_uint;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.InetAddressMask` representing all addresses whose
    /// first `length` bits match `addr`.
    extern fn g_inet_address_mask_new(p_addr: *gio.InetAddress, p_length: c_uint, p_error: ?*?*glib.Error) ?*gio.InetAddressMask;
    pub const new = g_inet_address_mask_new;

    /// Parses `mask_string` as an IP address and (optional) length, and
    /// creates a new `gio.InetAddressMask`. The length, if present, is
    /// delimited by a "/". If it is not present, then the length is
    /// assumed to be the full length of the address.
    extern fn g_inet_address_mask_new_from_string(p_mask_string: [*:0]const u8, p_error: ?*?*glib.Error) ?*gio.InetAddressMask;
    pub const newFromString = g_inet_address_mask_new_from_string;

    /// Tests if `mask` and `mask2` are the same mask.
    extern fn g_inet_address_mask_equal(p_mask: *InetAddressMask, p_mask2: *gio.InetAddressMask) c_int;
    pub const equal = g_inet_address_mask_equal;

    /// Gets `mask`'s base address
    extern fn g_inet_address_mask_get_address(p_mask: *InetAddressMask) *gio.InetAddress;
    pub const getAddress = g_inet_address_mask_get_address;

    /// Gets the `gio.SocketFamily` of `mask`'s address
    extern fn g_inet_address_mask_get_family(p_mask: *InetAddressMask) gio.SocketFamily;
    pub const getFamily = g_inet_address_mask_get_family;

    /// Gets `mask`'s length
    extern fn g_inet_address_mask_get_length(p_mask: *InetAddressMask) c_uint;
    pub const getLength = g_inet_address_mask_get_length;

    /// Tests if `address` falls within the range described by `mask`.
    extern fn g_inet_address_mask_matches(p_mask: *InetAddressMask, p_address: *gio.InetAddress) c_int;
    pub const matches = g_inet_address_mask_matches;

    /// Converts `mask` back to its corresponding string form.
    extern fn g_inet_address_mask_to_string(p_mask: *InetAddressMask) [*:0]u8;
    pub const toString = g_inet_address_mask_to_string;

    extern fn g_inet_address_mask_get_type() usize;
    pub const getGObjectType = g_inet_address_mask_get_type;

    extern fn g_object_ref(p_self: *gio.InetAddressMask) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.InetAddressMask) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *InetAddressMask, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// An IPv4 or IPv6 socket address. That is, the combination of a
/// `gio.InetAddress` and a port number.
///
/// In UNIX terms, `GInetSocketAddress` corresponds to a
/// [`struct sockaddr_in` or `struct sockaddr_in6`](man:sockaddr(3type)).
pub const InetSocketAddress = extern struct {
    pub const Parent = gio.SocketAddress;
    pub const Implements = [_]type{gio.SocketConnectable};
    pub const Class = gio.InetSocketAddressClass;
    f_parent_instance: gio.SocketAddress,
    f_priv: ?*gio.InetSocketAddressPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The address.
        pub const address = struct {
            pub const name = "address";

            pub const Type = ?*gio.InetAddress;
        };

        /// The `sin6_flowinfo` field, for IPv6 addresses.
        pub const flowinfo = struct {
            pub const name = "flowinfo";

            pub const Type = c_uint;
        };

        /// The port.
        pub const port = struct {
            pub const name = "port";

            pub const Type = c_uint;
        };

        /// The `sin6_scope_id` field, for IPv6 addresses.
        pub const scope_id = struct {
            pub const name = "scope-id";

            pub const Type = c_uint;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.InetSocketAddress` for `address` and `port`.
    extern fn g_inet_socket_address_new(p_address: *gio.InetAddress, p_port: u16) *gio.InetSocketAddress;
    pub const new = g_inet_socket_address_new;

    /// Creates a new `gio.InetSocketAddress` for `address` and `port`.
    ///
    /// If `address` is an IPv6 address, it can also contain a scope ID
    /// (separated from the address by a `%`).
    extern fn g_inet_socket_address_new_from_string(p_address: [*:0]const u8, p_port: c_uint) ?*gio.InetSocketAddress;
    pub const newFromString = g_inet_socket_address_new_from_string;

    /// Gets `address`'s `gio.InetAddress`.
    extern fn g_inet_socket_address_get_address(p_address: *InetSocketAddress) *gio.InetAddress;
    pub const getAddress = g_inet_socket_address_get_address;

    /// Gets the `sin6_flowinfo` field from `address`,
    /// which must be an IPv6 address.
    extern fn g_inet_socket_address_get_flowinfo(p_address: *InetSocketAddress) u32;
    pub const getFlowinfo = g_inet_socket_address_get_flowinfo;

    /// Gets `address`'s port.
    extern fn g_inet_socket_address_get_port(p_address: *InetSocketAddress) u16;
    pub const getPort = g_inet_socket_address_get_port;

    /// Gets the `sin6_scope_id` field from `address`,
    /// which must be an IPv6 address.
    extern fn g_inet_socket_address_get_scope_id(p_address: *InetSocketAddress) u32;
    pub const getScopeId = g_inet_socket_address_get_scope_id;

    extern fn g_inet_socket_address_get_type() usize;
    pub const getGObjectType = g_inet_socket_address_get_type;

    extern fn g_object_ref(p_self: *gio.InetSocketAddress) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.InetSocketAddress) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *InetSocketAddress, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GInputStream` is a base class for implementing streaming input.
///
/// It has functions to read from a stream (`gio.InputStream.read`),
/// to close a stream (`gio.InputStream.close`) and to skip some content
/// (`gio.InputStream.skip`).
///
/// To copy the content of an input stream to an output stream without
/// manually handling the reads and writes, use `gio.OutputStream.splice`.
///
/// See the documentation for `gio.IOStream` for details of thread safety
/// of streaming APIs.
///
/// All of these functions have async variants too.
pub const InputStream = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.InputStreamClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.InputStreamPrivate,

    pub const virtual_methods = struct {
        /// Requests an asynchronous closes of the stream, releasing resources related to it.
        /// When the operation is finished `callback` will be called.
        /// You can then call `gio.InputStream.closeFinish` to get the result of the
        /// operation.
        ///
        /// For behaviour details see `gio.InputStream.close`.
        ///
        /// The asynchronous methods have a default fallback that uses threads to implement
        /// asynchronicity, so they are optional for inheriting classes. However, if you
        /// override one you must override all.
        pub const close_async = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(InputStream.Class, p_class).f_close_async.?(gobject.ext.as(InputStream, p_stream), p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(InputStream.Class, p_class).f_close_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes closing a stream asynchronously, started from `gio.InputStream.closeAsync`.
        pub const close_finish = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(InputStream.Class, p_class).f_close_finish.?(gobject.ext.as(InputStream, p_stream), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(InputStream.Class, p_class).f_close_finish = @ptrCast(p_implementation);
            }
        };

        pub const close_fn = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(InputStream.Class, p_class).f_close_fn.?(gobject.ext.as(InputStream, p_stream), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(InputStream.Class, p_class).f_close_fn = @ptrCast(p_implementation);
            }
        };

        /// Request an asynchronous read of `count` bytes from the stream into the buffer
        /// starting at `buffer`. When the operation is finished `callback` will be called.
        /// You can then call `gio.InputStream.readFinish` to get the result of the
        /// operation.
        ///
        /// During an async request no other sync and async calls are allowed on `stream`, and will
        /// result in `G_IO_ERROR_PENDING` errors.
        ///
        /// A value of `count` larger than `G_MAXSSIZE` will cause a `G_IO_ERROR_INVALID_ARGUMENT` error.
        ///
        /// On success, the number of bytes read into the buffer will be passed to the
        /// callback. It is not an error if this is not the same as the requested size, as it
        /// can happen e.g. near the end of a file, but generally we try to read
        /// as many bytes as requested. Zero is returned on end of file
        /// (or if `count` is zero),  but never otherwise.
        ///
        /// Any outstanding i/o request with higher priority (lower numerical value) will
        /// be executed before an outstanding request with lower priority. Default
        /// priority is `G_PRIORITY_DEFAULT`.
        ///
        /// The asynchronous methods have a default fallback that uses threads to implement
        /// asynchronicity, so they are optional for inheriting classes. However, if you
        /// override one you must override all.
        pub const read_async = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_buffer: ?*[*]u8, p_count: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(InputStream.Class, p_class).f_read_async.?(gobject.ext.as(InputStream, p_stream), p_buffer, p_count, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_buffer: ?*[*]u8, p_count: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(InputStream.Class, p_class).f_read_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous stream read operation.
        pub const read_finish = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) isize {
                return gobject.ext.as(InputStream.Class, p_class).f_read_finish.?(gobject.ext.as(InputStream, p_stream), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) isize) void {
                gobject.ext.as(InputStream.Class, p_class).f_read_finish = @ptrCast(p_implementation);
            }
        };

        pub const read_fn = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_buffer: ?*anyopaque, p_count: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize {
                return gobject.ext.as(InputStream.Class, p_class).f_read_fn.?(gobject.ext.as(InputStream, p_stream), p_buffer, p_count, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_buffer: ?*anyopaque, p_count: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) isize) void {
                gobject.ext.as(InputStream.Class, p_class).f_read_fn = @ptrCast(p_implementation);
            }
        };

        /// Tries to skip `count` bytes from the stream. Will block during the operation.
        ///
        /// This is identical to `gio.InputStream.read`, from a behaviour standpoint,
        /// but the bytes that are skipped are not returned to the user. Some
        /// streams have an implementation that is more efficient than reading the data.
        ///
        /// This function is optional for inherited classes, as the default implementation
        /// emulates it using read.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned. If an
        /// operation was partially finished when the operation was cancelled the
        /// partial result will be returned, without an error.
        pub const skip = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_count: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize {
                return gobject.ext.as(InputStream.Class, p_class).f_skip.?(gobject.ext.as(InputStream, p_stream), p_count, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_count: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) isize) void {
                gobject.ext.as(InputStream.Class, p_class).f_skip = @ptrCast(p_implementation);
            }
        };

        /// Request an asynchronous skip of `count` bytes from the stream.
        /// When the operation is finished `callback` will be called.
        /// You can then call `gio.InputStream.skipFinish` to get the result
        /// of the operation.
        ///
        /// During an async request no other sync and async calls are allowed,
        /// and will result in `G_IO_ERROR_PENDING` errors.
        ///
        /// A value of `count` larger than `G_MAXSSIZE` will cause a `G_IO_ERROR_INVALID_ARGUMENT` error.
        ///
        /// On success, the number of bytes skipped will be passed to the callback.
        /// It is not an error if this is not the same as the requested size, as it
        /// can happen e.g. near the end of a file, but generally we try to skip
        /// as many bytes as requested. Zero is returned on end of file
        /// (or if `count` is zero), but never otherwise.
        ///
        /// Any outstanding i/o request with higher priority (lower numerical value)
        /// will be executed before an outstanding request with lower priority.
        /// Default priority is `G_PRIORITY_DEFAULT`.
        ///
        /// The asynchronous methods have a default fallback that uses threads to
        /// implement asynchronicity, so they are optional for inheriting classes.
        /// However, if you override one, you must override all.
        pub const skip_async = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_count: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(InputStream.Class, p_class).f_skip_async.?(gobject.ext.as(InputStream, p_stream), p_count, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_count: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(InputStream.Class, p_class).f_skip_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes a stream skip operation.
        pub const skip_finish = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) isize {
                return gobject.ext.as(InputStream.Class, p_class).f_skip_finish.?(gobject.ext.as(InputStream, p_stream), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) isize) void {
                gobject.ext.as(InputStream.Class, p_class).f_skip_finish = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Clears the pending flag on `stream`.
    extern fn g_input_stream_clear_pending(p_stream: *InputStream) void;
    pub const clearPending = g_input_stream_clear_pending;

    /// Closes the stream, releasing resources related to it.
    ///
    /// Once the stream is closed, all other operations will return `G_IO_ERROR_CLOSED`.
    /// Closing a stream multiple times will not return an error.
    ///
    /// Streams will be automatically closed when the last reference
    /// is dropped, but you might want to call this function to make sure
    /// resources are released as early as possible.
    ///
    /// Some streams might keep the backing store of the stream (e.g. a file descriptor)
    /// open after the stream is closed. See the documentation for the individual
    /// stream for details.
    ///
    /// On failure the first error that happened will be reported, but the close
    /// operation will finish as much as possible. A stream that failed to
    /// close will still return `G_IO_ERROR_CLOSED` for all operations. Still, it
    /// is important to check and report the error to the user.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    /// Cancelling a close will still leave the stream closed, but some streams
    /// can use a faster close that doesn't block to e.g. check errors.
    extern fn g_input_stream_close(p_stream: *InputStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const close = g_input_stream_close;

    /// Requests an asynchronous closes of the stream, releasing resources related to it.
    /// When the operation is finished `callback` will be called.
    /// You can then call `gio.InputStream.closeFinish` to get the result of the
    /// operation.
    ///
    /// For behaviour details see `gio.InputStream.close`.
    ///
    /// The asynchronous methods have a default fallback that uses threads to implement
    /// asynchronicity, so they are optional for inheriting classes. However, if you
    /// override one you must override all.
    extern fn g_input_stream_close_async(p_stream: *InputStream, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const closeAsync = g_input_stream_close_async;

    /// Finishes closing a stream asynchronously, started from `gio.InputStream.closeAsync`.
    extern fn g_input_stream_close_finish(p_stream: *InputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const closeFinish = g_input_stream_close_finish;

    /// Checks if an input stream has pending actions.
    extern fn g_input_stream_has_pending(p_stream: *InputStream) c_int;
    pub const hasPending = g_input_stream_has_pending;

    /// Checks if an input stream is closed.
    extern fn g_input_stream_is_closed(p_stream: *InputStream) c_int;
    pub const isClosed = g_input_stream_is_closed;

    /// Tries to read `count` bytes from the stream into the buffer starting at
    /// `buffer`. Will block during this read.
    ///
    /// If count is zero returns zero and does nothing. A value of `count`
    /// larger than `G_MAXSSIZE` will cause a `G_IO_ERROR_INVALID_ARGUMENT` error.
    ///
    /// On success, the number of bytes read into the buffer is returned.
    /// It is not an error if this is not the same as the requested size, as it
    /// can happen e.g. near the end of a file. Zero is returned on end of file
    /// (or if `count` is zero),  but never otherwise.
    ///
    /// The returned `buffer` is not a nul-terminated string, it can contain nul bytes
    /// at any position, and this function doesn't nul-terminate the `buffer`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned. If an
    /// operation was partially finished when the operation was cancelled the
    /// partial result will be returned, without an error.
    ///
    /// On error -1 is returned and `error` is set accordingly.
    extern fn g_input_stream_read(p_stream: *InputStream, p_buffer: *[*]u8, p_count: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const read = g_input_stream_read;

    /// Tries to read `count` bytes from the stream into the buffer starting at
    /// `buffer`. Will block during this read.
    ///
    /// This function is similar to `gio.InputStream.read`, except it tries to
    /// read as many bytes as requested, only stopping on an error or end of stream.
    ///
    /// On a successful read of `count` bytes, or if we reached the end of the
    /// stream,  `TRUE` is returned, and `bytes_read` is set to the number of bytes
    /// read into `buffer`.
    ///
    /// If there is an error during the operation `FALSE` is returned and `error`
    /// is set to indicate the error status.
    ///
    /// As a special exception to the normal conventions for functions that
    /// use `glib.Error`, if this function returns `FALSE` (and sets `error`) then
    /// `bytes_read` will be set to the number of bytes that were successfully
    /// read before the error was encountered.  This functionality is only
    /// available from C.  If you need it from another language then you must
    /// write your own loop around `gio.InputStream.read`.
    extern fn g_input_stream_read_all(p_stream: *InputStream, p_buffer: *[*]u8, p_count: usize, p_bytes_read: *usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const readAll = g_input_stream_read_all;

    /// Request an asynchronous read of `count` bytes from the stream into the
    /// buffer starting at `buffer`.
    ///
    /// This is the asynchronous equivalent of `InputStream.readAll`.
    ///
    /// Call `InputStream.readAllFinish` to collect the result.
    ///
    /// Any outstanding I/O request with higher priority (lower numerical
    /// value) will be executed before an outstanding request with lower
    /// priority. Default priority is `G_PRIORITY_DEFAULT`.
    extern fn g_input_stream_read_all_async(p_stream: *InputStream, p_buffer: *[*]u8, p_count: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const readAllAsync = g_input_stream_read_all_async;

    /// Finishes an asynchronous stream read operation started with
    /// `InputStream.readAllAsync`.
    ///
    /// As a special exception to the normal conventions for functions that
    /// use `glib.Error`, if this function returns `FALSE` (and sets `error`) then
    /// `bytes_read` will be set to the number of bytes that were successfully
    /// read before the error was encountered.  This functionality is only
    /// available from C.  If you need it from another language then you must
    /// write your own loop around `gio.InputStream.readAsync`.
    extern fn g_input_stream_read_all_finish(p_stream: *InputStream, p_result: *gio.AsyncResult, p_bytes_read: *usize, p_error: ?*?*glib.Error) c_int;
    pub const readAllFinish = g_input_stream_read_all_finish;

    /// Request an asynchronous read of `count` bytes from the stream into the buffer
    /// starting at `buffer`. When the operation is finished `callback` will be called.
    /// You can then call `gio.InputStream.readFinish` to get the result of the
    /// operation.
    ///
    /// During an async request no other sync and async calls are allowed on `stream`, and will
    /// result in `G_IO_ERROR_PENDING` errors.
    ///
    /// A value of `count` larger than `G_MAXSSIZE` will cause a `G_IO_ERROR_INVALID_ARGUMENT` error.
    ///
    /// On success, the number of bytes read into the buffer will be passed to the
    /// callback. It is not an error if this is not the same as the requested size, as it
    /// can happen e.g. near the end of a file, but generally we try to read
    /// as many bytes as requested. Zero is returned on end of file
    /// (or if `count` is zero),  but never otherwise.
    ///
    /// Any outstanding i/o request with higher priority (lower numerical value) will
    /// be executed before an outstanding request with lower priority. Default
    /// priority is `G_PRIORITY_DEFAULT`.
    ///
    /// The asynchronous methods have a default fallback that uses threads to implement
    /// asynchronicity, so they are optional for inheriting classes. However, if you
    /// override one you must override all.
    extern fn g_input_stream_read_async(p_stream: *InputStream, p_buffer: *[*]u8, p_count: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const readAsync = g_input_stream_read_async;

    /// Like `gio.InputStream.read`, this tries to read `count` bytes from
    /// the stream in a blocking fashion. However, rather than reading into
    /// a user-supplied buffer, this will create a new `glib.Bytes` containing
    /// the data that was read. This may be easier to use from language
    /// bindings.
    ///
    /// If count is zero, returns a zero-length `glib.Bytes` and does nothing. A
    /// value of `count` larger than `G_MAXSSIZE` will cause a
    /// `G_IO_ERROR_INVALID_ARGUMENT` error.
    ///
    /// On success, a new `glib.Bytes` is returned. It is not an error if the
    /// size of this object is not the same as the requested size, as it
    /// can happen e.g. near the end of a file. A zero-length `glib.Bytes` is
    /// returned on end of file (or if `count` is zero), but never
    /// otherwise.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned. If an
    /// operation was partially finished when the operation was cancelled the
    /// partial result will be returned, without an error.
    ///
    /// On error `NULL` is returned and `error` is set accordingly.
    extern fn g_input_stream_read_bytes(p_stream: *InputStream, p_count: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.Bytes;
    pub const readBytes = g_input_stream_read_bytes;

    /// Request an asynchronous read of `count` bytes from the stream into a
    /// new `glib.Bytes`. When the operation is finished `callback` will be
    /// called. You can then call `gio.InputStream.readBytesFinish` to get the
    /// result of the operation.
    ///
    /// During an async request no other sync and async calls are allowed
    /// on `stream`, and will result in `G_IO_ERROR_PENDING` errors.
    ///
    /// A value of `count` larger than `G_MAXSSIZE` will cause a
    /// `G_IO_ERROR_INVALID_ARGUMENT` error.
    ///
    /// On success, the new `glib.Bytes` will be passed to the callback. It is
    /// not an error if this is smaller than the requested size, as it can
    /// happen e.g. near the end of a file, but generally we try to read as
    /// many bytes as requested. Zero is returned on end of file (or if
    /// `count` is zero), but never otherwise.
    ///
    /// Any outstanding I/O request with higher priority (lower numerical
    /// value) will be executed before an outstanding request with lower
    /// priority. Default priority is `G_PRIORITY_DEFAULT`.
    extern fn g_input_stream_read_bytes_async(p_stream: *InputStream, p_count: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const readBytesAsync = g_input_stream_read_bytes_async;

    /// Finishes an asynchronous stream read-into-`glib.Bytes` operation.
    extern fn g_input_stream_read_bytes_finish(p_stream: *InputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.Bytes;
    pub const readBytesFinish = g_input_stream_read_bytes_finish;

    /// Finishes an asynchronous stream read operation.
    extern fn g_input_stream_read_finish(p_stream: *InputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) isize;
    pub const readFinish = g_input_stream_read_finish;

    /// Sets `stream` to have actions pending. If the pending flag is
    /// already set or `stream` is closed, it will return `FALSE` and set
    /// `error`.
    extern fn g_input_stream_set_pending(p_stream: *InputStream, p_error: ?*?*glib.Error) c_int;
    pub const setPending = g_input_stream_set_pending;

    /// Tries to skip `count` bytes from the stream. Will block during the operation.
    ///
    /// This is identical to `gio.InputStream.read`, from a behaviour standpoint,
    /// but the bytes that are skipped are not returned to the user. Some
    /// streams have an implementation that is more efficient than reading the data.
    ///
    /// This function is optional for inherited classes, as the default implementation
    /// emulates it using read.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned. If an
    /// operation was partially finished when the operation was cancelled the
    /// partial result will be returned, without an error.
    extern fn g_input_stream_skip(p_stream: *InputStream, p_count: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const skip = g_input_stream_skip;

    /// Request an asynchronous skip of `count` bytes from the stream.
    /// When the operation is finished `callback` will be called.
    /// You can then call `gio.InputStream.skipFinish` to get the result
    /// of the operation.
    ///
    /// During an async request no other sync and async calls are allowed,
    /// and will result in `G_IO_ERROR_PENDING` errors.
    ///
    /// A value of `count` larger than `G_MAXSSIZE` will cause a `G_IO_ERROR_INVALID_ARGUMENT` error.
    ///
    /// On success, the number of bytes skipped will be passed to the callback.
    /// It is not an error if this is not the same as the requested size, as it
    /// can happen e.g. near the end of a file, but generally we try to skip
    /// as many bytes as requested. Zero is returned on end of file
    /// (or if `count` is zero), but never otherwise.
    ///
    /// Any outstanding i/o request with higher priority (lower numerical value)
    /// will be executed before an outstanding request with lower priority.
    /// Default priority is `G_PRIORITY_DEFAULT`.
    ///
    /// The asynchronous methods have a default fallback that uses threads to
    /// implement asynchronicity, so they are optional for inheriting classes.
    /// However, if you override one, you must override all.
    extern fn g_input_stream_skip_async(p_stream: *InputStream, p_count: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const skipAsync = g_input_stream_skip_async;

    /// Finishes a stream skip operation.
    extern fn g_input_stream_skip_finish(p_stream: *InputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) isize;
    pub const skipFinish = g_input_stream_skip_finish;

    extern fn g_input_stream_get_type() usize;
    pub const getGObjectType = g_input_stream_get_type;

    extern fn g_object_ref(p_self: *gio.InputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.InputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *InputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GListStore` is a simple implementation of `gio.ListModel` that stores
/// all items in memory.
///
/// It provides insertions, deletions, and lookups in logarithmic time
/// with a fast path for the common case of iterating the list linearly.
pub const ListStore = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.ListModel};
    pub const Class = gio.ListStoreClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The type of items contained in this list store. Items must be
        /// subclasses of `gobject.Object`.
        pub const item_type = struct {
            pub const name = "item-type";

            pub const Type = usize;
        };

        /// The number of items contained in this list store.
        pub const n_items = struct {
            pub const name = "n-items";

            pub const Type = c_uint;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.ListStore` with items of type `item_type`. `item_type`
    /// must be a subclass of `gobject.Object`.
    extern fn g_list_store_new(p_item_type: usize) *gio.ListStore;
    pub const new = g_list_store_new;

    /// Appends `item` to `store`. `item` must be of type `gio.ListStore.properties.item`-type.
    ///
    /// This function takes a ref on `item`.
    ///
    /// Use `gio.ListStore.splice` to append multiple items at the same time
    /// efficiently.
    extern fn g_list_store_append(p_store: *ListStore, p_item: *gobject.Object) void;
    pub const append = g_list_store_append;

    /// Looks up the given `item` in the list store by looping over the items until
    /// the first occurrence of `item`. If `item` was not found, then `position` will
    /// not be set, and this method will return `FALSE`.
    ///
    /// If you need to compare the two items with a custom comparison function, use
    /// `gio.ListStore.findWithEqualFunc` with a custom `glib.EqualFunc` instead.
    extern fn g_list_store_find(p_store: *ListStore, p_item: *gobject.Object, p_position: ?*c_uint) c_int;
    pub const find = g_list_store_find;

    /// Looks up the given `item` in the list store by looping over the items and
    /// comparing them with `equal_func` until the first occurrence of `item` which
    /// matches. If `item` was not found, then `position` will not be set, and this
    /// method will return `FALSE`.
    ///
    /// `item` is always passed as second parameter to `equal_func`.
    ///
    /// Since GLib 2.76 it is possible to pass `NULL` for `item`.
    extern fn g_list_store_find_with_equal_func(p_store: *ListStore, p_item: ?*gobject.Object, p_equal_func: glib.EqualFunc, p_position: ?*c_uint) c_int;
    pub const findWithEqualFunc = g_list_store_find_with_equal_func;

    /// Like `gio.ListStore.findWithEqualFunc` but with an additional `user_data`
    /// that is passed to `equal_func`.
    ///
    /// `item` is always passed as second parameter to `equal_func`.
    ///
    /// Since GLib 2.76 it is possible to pass `NULL` for `item`.
    extern fn g_list_store_find_with_equal_func_full(p_store: *ListStore, p_item: ?*gobject.Object, p_equal_func: glib.EqualFuncFull, p_user_data: ?*anyopaque, p_position: ?*c_uint) c_int;
    pub const findWithEqualFuncFull = g_list_store_find_with_equal_func_full;

    /// Inserts `item` into `store` at `position`. `item` must be of type
    /// `gio.ListStore.properties.item`-type or derived from it. `position` must be smaller
    /// than the length of the list, or equal to it to append.
    ///
    /// This function takes a ref on `item`.
    ///
    /// Use `gio.ListStore.splice` to insert multiple items at the same time
    /// efficiently.
    extern fn g_list_store_insert(p_store: *ListStore, p_position: c_uint, p_item: *gobject.Object) void;
    pub const insert = g_list_store_insert;

    /// Inserts `item` into `store` at a position to be determined by the
    /// `compare_func`.
    ///
    /// The list must already be sorted before calling this function or the
    /// result is undefined.  Usually you would approach this by only ever
    /// inserting items by way of this function.
    ///
    /// This function takes a ref on `item`.
    extern fn g_list_store_insert_sorted(p_store: *ListStore, p_item: *gobject.Object, p_compare_func: glib.CompareDataFunc, p_user_data: ?*anyopaque) c_uint;
    pub const insertSorted = g_list_store_insert_sorted;

    /// Removes the item from `store` that is at `position`. `position` must be
    /// smaller than the current length of the list.
    ///
    /// Use `gio.ListStore.splice` to remove multiple items at the same time
    /// efficiently.
    extern fn g_list_store_remove(p_store: *ListStore, p_position: c_uint) void;
    pub const remove = g_list_store_remove;

    /// Removes all items from `store`.
    extern fn g_list_store_remove_all(p_store: *ListStore) void;
    pub const removeAll = g_list_store_remove_all;

    /// Sort the items in `store` according to `compare_func`.
    extern fn g_list_store_sort(p_store: *ListStore, p_compare_func: glib.CompareDataFunc, p_user_data: ?*anyopaque) void;
    pub const sort = g_list_store_sort;

    /// Changes `store` by removing `n_removals` items and adding `n_additions`
    /// items to it. `additions` must contain `n_additions` items of type
    /// `gio.ListStore.properties.item`-type.  `NULL` is not permitted.
    ///
    /// This function is more efficient than `gio.ListStore.insert` and
    /// `gio.ListStore.remove`, because it only emits
    /// `gio.ListModel.signals.items`-changed once for the change.
    ///
    /// This function takes a ref on each item in `additions`.
    ///
    /// The parameters `position` and `n_removals` must be correct (ie:
    /// `position` + `n_removals` must be less than or equal to the length of
    /// the list at the time this function is called).
    extern fn g_list_store_splice(p_store: *ListStore, p_position: c_uint, p_n_removals: c_uint, p_additions: [*]*gobject.Object, p_n_additions: c_uint) void;
    pub const splice = g_list_store_splice;

    extern fn g_list_store_get_type() usize;
    pub const getGObjectType = g_list_store_get_type;

    extern fn g_object_ref(p_self: *gio.ListStore) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.ListStore) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ListStore, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GMemoryInputStream` is a class for using arbitrary
/// memory chunks as input for GIO streaming input operations.
///
/// As of GLib 2.34, `GMemoryInputStream` implements
/// `gio.PollableInputStream`.
pub const MemoryInputStream = extern struct {
    pub const Parent = gio.InputStream;
    pub const Implements = [_]type{ gio.PollableInputStream, gio.Seekable };
    pub const Class = gio.MemoryInputStreamClass;
    f_parent_instance: gio.InputStream,
    f_priv: ?*gio.MemoryInputStreamPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new empty `gio.MemoryInputStream`.
    extern fn g_memory_input_stream_new() *gio.MemoryInputStream;
    pub const new = g_memory_input_stream_new;

    /// Creates a new `gio.MemoryInputStream` with data from the given `bytes`.
    extern fn g_memory_input_stream_new_from_bytes(p_bytes: *glib.Bytes) *gio.MemoryInputStream;
    pub const newFromBytes = g_memory_input_stream_new_from_bytes;

    /// Creates a new `gio.MemoryInputStream` with data in memory of a given size.
    extern fn g_memory_input_stream_new_from_data(p_data: [*]u8, p_len: isize, p_destroy: ?glib.DestroyNotify) *gio.MemoryInputStream;
    pub const newFromData = g_memory_input_stream_new_from_data;

    /// Appends `bytes` to data that can be read from the input stream.
    extern fn g_memory_input_stream_add_bytes(p_stream: *MemoryInputStream, p_bytes: *glib.Bytes) void;
    pub const addBytes = g_memory_input_stream_add_bytes;

    /// Appends `data` to data that can be read from the input stream
    extern fn g_memory_input_stream_add_data(p_stream: *MemoryInputStream, p_data: [*]u8, p_len: isize, p_destroy: ?glib.DestroyNotify) void;
    pub const addData = g_memory_input_stream_add_data;

    extern fn g_memory_input_stream_get_type() usize;
    pub const getGObjectType = g_memory_input_stream_get_type;

    extern fn g_object_ref(p_self: *gio.MemoryInputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.MemoryInputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MemoryInputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GMemoryOutputStream` is a class for using arbitrary
/// memory chunks as output for GIO streaming output operations.
///
/// As of GLib 2.34, `GMemoryOutputStream` trivially implements
/// `gio.PollableOutputStream`: it always polls as ready.
pub const MemoryOutputStream = extern struct {
    pub const Parent = gio.OutputStream;
    pub const Implements = [_]type{ gio.PollableOutputStream, gio.Seekable };
    pub const Class = gio.MemoryOutputStreamClass;
    f_parent_instance: gio.OutputStream,
    f_priv: ?*gio.MemoryOutputStreamPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Pointer to buffer where data will be written.
        pub const data = struct {
            pub const name = "data";

            pub const Type = ?*anyopaque;
        };

        /// Size of data written to the buffer.
        pub const data_size = struct {
            pub const name = "data-size";

            pub const Type = c_ulong;
        };

        /// Function called with the buffer as argument when the stream is destroyed.
        pub const destroy_function = struct {
            pub const name = "destroy-function";

            pub const Type = ?*anyopaque;
        };

        /// Function with realloc semantics called to enlarge the buffer.
        pub const realloc_function = struct {
            pub const name = "realloc-function";

            pub const Type = ?*anyopaque;
        };

        /// Current size of the data buffer.
        pub const size = struct {
            pub const name = "size";

            pub const Type = c_ulong;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.MemoryOutputStream`.
    ///
    /// In most cases this is not the function you want.  See
    /// `gio.MemoryOutputStream.newResizable` instead.
    ///
    /// If `data` is non-`NULL`, the stream will use that for its internal storage.
    ///
    /// If `realloc_fn` is non-`NULL`, it will be used for resizing the internal
    /// storage when necessary and the stream will be considered resizable.
    /// In that case, the stream will start out being (conceptually) empty.
    /// `size` is used only as a hint for how big `data` is.  Specifically,
    /// seeking to the end of a newly-created stream will seek to zero, not
    /// `size`.  Seeking past the end of the stream and then writing will
    /// introduce a zero-filled gap.
    ///
    /// If `realloc_fn` is `NULL` then the stream is fixed-sized.  Seeking to
    /// the end will seek to `size` exactly.  Writing past the end will give
    /// an 'out of space' error.  Attempting to seek past the end will fail.
    /// Unlike the resizable case, seeking to an offset within the stream and
    /// writing will preserve the bytes passed in as `data` before that point
    /// and will return them as part of `gio.MemoryOutputStream.stealData`.
    /// If you intend to seek you should probably therefore ensure that `data`
    /// is properly initialised.
    ///
    /// It is probably only meaningful to provide `data` and `size` in the case
    /// that you want a fixed-sized stream.  Put another way: if `realloc_fn`
    /// is non-`NULL` then it makes most sense to give `data` as `NULL` and
    /// `size` as 0 (allowing `gio.MemoryOutputStream` to do the initial
    /// allocation for itself).
    ///
    /// ```
    /// // a stream that can grow
    /// stream = g_memory_output_stream_new (NULL, 0, realloc, free);
    ///
    /// // another stream that can grow
    /// stream2 = g_memory_output_stream_new (NULL, 0, g_realloc, g_free);
    ///
    /// // a fixed-size stream
    /// data = malloc (200);
    /// stream3 = g_memory_output_stream_new (data, 200, NULL, free);
    /// ```
    extern fn g_memory_output_stream_new(p_data: ?*anyopaque, p_size: usize, p_realloc_function: ?gio.ReallocFunc, p_destroy_function: ?glib.DestroyNotify) *gio.MemoryOutputStream;
    pub const new = g_memory_output_stream_new;

    /// Creates a new `gio.MemoryOutputStream`, using `glib.realloc` and `glib.free`
    /// for memory allocation.
    extern fn g_memory_output_stream_new_resizable() *gio.MemoryOutputStream;
    pub const newResizable = g_memory_output_stream_new_resizable;

    /// Gets any loaded data from the `ostream`.
    ///
    /// Note that the returned pointer may become invalid on the next
    /// write or truncate operation on the stream.
    extern fn g_memory_output_stream_get_data(p_ostream: *MemoryOutputStream) ?*anyopaque;
    pub const getData = g_memory_output_stream_get_data;

    /// Returns the number of bytes from the start up to including the last
    /// byte written in the stream that has not been truncated away.
    extern fn g_memory_output_stream_get_data_size(p_ostream: *MemoryOutputStream) usize;
    pub const getDataSize = g_memory_output_stream_get_data_size;

    /// Gets the size of the currently allocated data area (available from
    /// `gio.MemoryOutputStream.getData`).
    ///
    /// You probably don't want to use this function on resizable streams.
    /// See `gio.MemoryOutputStream.getDataSize` instead.  For resizable
    /// streams the size returned by this function is an implementation
    /// detail and may be change at any time in response to operations on the
    /// stream.
    ///
    /// If the stream is fixed-sized (ie: no realloc was passed to
    /// `gio.MemoryOutputStream.new`) then this is the maximum size of the
    /// stream and further writes will return `G_IO_ERROR_NO_SPACE`.
    ///
    /// In any case, if you want the number of bytes currently written to the
    /// stream, use `gio.MemoryOutputStream.getDataSize`.
    extern fn g_memory_output_stream_get_size(p_ostream: *MemoryOutputStream) usize;
    pub const getSize = g_memory_output_stream_get_size;

    /// Returns data from the `ostream` as a `glib.Bytes`. `ostream` must be
    /// closed before calling this function.
    extern fn g_memory_output_stream_steal_as_bytes(p_ostream: *MemoryOutputStream) *glib.Bytes;
    pub const stealAsBytes = g_memory_output_stream_steal_as_bytes;

    /// Gets any loaded data from the `ostream`. Ownership of the data
    /// is transferred to the caller; when no longer needed it must be
    /// freed using the free function set in `ostream`'s
    /// `gio.MemoryOutputStream.properties.destroy`-function property.
    ///
    /// `ostream` must be closed before calling this function.
    extern fn g_memory_output_stream_steal_data(p_ostream: *MemoryOutputStream) ?*anyopaque;
    pub const stealData = g_memory_output_stream_steal_data;

    extern fn g_memory_output_stream_get_type() usize;
    pub const getGObjectType = g_memory_output_stream_get_type;

    extern fn g_object_ref(p_self: *gio.MemoryOutputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.MemoryOutputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MemoryOutputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GMenu` is a simple implementation of `gio.MenuModel`.
/// You populate a `GMenu` by adding `gio.MenuItem` instances to it.
///
/// There are some convenience functions to allow you to directly
/// add items (avoiding `gio.MenuItem`) for the common cases. To add
/// a regular item, use `gio.Menu.insert`. To add a section, use
/// `gio.Menu.insertSection`. To add a submenu, use
/// `gio.Menu.insertSubmenu`.
pub const Menu = opaque {
    pub const Parent = gio.MenuModel;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = Menu;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gio.Menu`.
    ///
    /// The new menu has no items.
    extern fn g_menu_new() *gio.Menu;
    pub const new = g_menu_new;

    /// Convenience function for appending a normal menu item to the end of
    /// `menu`.  Combine `gio.MenuItem.new` and `gio.Menu.insertItem` for a more
    /// flexible alternative.
    extern fn g_menu_append(p_menu: *Menu, p_label: ?[*:0]const u8, p_detailed_action: ?[*:0]const u8) void;
    pub const append = g_menu_append;

    /// Appends `item` to the end of `menu`.
    ///
    /// See `gio.Menu.insertItem` for more information.
    extern fn g_menu_append_item(p_menu: *Menu, p_item: *gio.MenuItem) void;
    pub const appendItem = g_menu_append_item;

    /// Convenience function for appending a section menu item to the end of
    /// `menu`.  Combine `gio.MenuItem.newSection` and `gio.Menu.insertItem` for a
    /// more flexible alternative.
    extern fn g_menu_append_section(p_menu: *Menu, p_label: ?[*:0]const u8, p_section: *gio.MenuModel) void;
    pub const appendSection = g_menu_append_section;

    /// Convenience function for appending a submenu menu item to the end of
    /// `menu`.  Combine `gio.MenuItem.newSubmenu` and `gio.Menu.insertItem` for a
    /// more flexible alternative.
    extern fn g_menu_append_submenu(p_menu: *Menu, p_label: ?[*:0]const u8, p_submenu: *gio.MenuModel) void;
    pub const appendSubmenu = g_menu_append_submenu;

    /// Marks `menu` as frozen.
    ///
    /// After the menu is frozen, it is an error to attempt to make any
    /// changes to it.  In effect this means that the `gio.Menu` API must no
    /// longer be used.
    ///
    /// This function causes `gio.MenuModel.isMutable` to begin returning
    /// `FALSE`, which has some positive performance implications.
    extern fn g_menu_freeze(p_menu: *Menu) void;
    pub const freeze = g_menu_freeze;

    /// Convenience function for inserting a normal menu item into `menu`.
    /// Combine `gio.MenuItem.new` and `gio.Menu.insertItem` for a more flexible
    /// alternative.
    extern fn g_menu_insert(p_menu: *Menu, p_position: c_int, p_label: ?[*:0]const u8, p_detailed_action: ?[*:0]const u8) void;
    pub const insert = g_menu_insert;

    /// Inserts `item` into `menu`.
    ///
    /// The "insertion" is actually done by copying all of the attribute and
    /// link values of `item` and using them to form a new item within `menu`.
    /// As such, `item` itself is not really inserted, but rather, a menu item
    /// that is exactly the same as the one presently described by `item`.
    ///
    /// This means that `item` is essentially useless after the insertion
    /// occurs.  Any changes you make to it are ignored unless it is inserted
    /// again (at which point its updated values will be copied).
    ///
    /// You should probably just free `item` once you're done.
    ///
    /// There are many convenience functions to take care of common cases.
    /// See `gio.Menu.insert`, `gio.Menu.insertSection` and
    /// `gio.Menu.insertSubmenu` as well as "prepend" and "append" variants of
    /// each of these functions.
    extern fn g_menu_insert_item(p_menu: *Menu, p_position: c_int, p_item: *gio.MenuItem) void;
    pub const insertItem = g_menu_insert_item;

    /// Convenience function for inserting a section menu item into `menu`.
    /// Combine `gio.MenuItem.newSection` and `gio.Menu.insertItem` for a more
    /// flexible alternative.
    extern fn g_menu_insert_section(p_menu: *Menu, p_position: c_int, p_label: ?[*:0]const u8, p_section: *gio.MenuModel) void;
    pub const insertSection = g_menu_insert_section;

    /// Convenience function for inserting a submenu menu item into `menu`.
    /// Combine `gio.MenuItem.newSubmenu` and `gio.Menu.insertItem` for a more
    /// flexible alternative.
    extern fn g_menu_insert_submenu(p_menu: *Menu, p_position: c_int, p_label: ?[*:0]const u8, p_submenu: *gio.MenuModel) void;
    pub const insertSubmenu = g_menu_insert_submenu;

    /// Convenience function for prepending a normal menu item to the start
    /// of `menu`.  Combine `gio.MenuItem.new` and `gio.Menu.insertItem` for a more
    /// flexible alternative.
    extern fn g_menu_prepend(p_menu: *Menu, p_label: ?[*:0]const u8, p_detailed_action: ?[*:0]const u8) void;
    pub const prepend = g_menu_prepend;

    /// Prepends `item` to the start of `menu`.
    ///
    /// See `gio.Menu.insertItem` for more information.
    extern fn g_menu_prepend_item(p_menu: *Menu, p_item: *gio.MenuItem) void;
    pub const prependItem = g_menu_prepend_item;

    /// Convenience function for prepending a section menu item to the start
    /// of `menu`.  Combine `gio.MenuItem.newSection` and `gio.Menu.insertItem` for
    /// a more flexible alternative.
    extern fn g_menu_prepend_section(p_menu: *Menu, p_label: ?[*:0]const u8, p_section: *gio.MenuModel) void;
    pub const prependSection = g_menu_prepend_section;

    /// Convenience function for prepending a submenu menu item to the start
    /// of `menu`.  Combine `gio.MenuItem.newSubmenu` and `gio.Menu.insertItem` for
    /// a more flexible alternative.
    extern fn g_menu_prepend_submenu(p_menu: *Menu, p_label: ?[*:0]const u8, p_submenu: *gio.MenuModel) void;
    pub const prependSubmenu = g_menu_prepend_submenu;

    /// Removes an item from the menu.
    ///
    /// `position` gives the index of the item to remove.
    ///
    /// It is an error if position is not in range the range from 0 to one
    /// less than the number of items in the menu.
    ///
    /// It is not possible to remove items by identity since items are added
    /// to the menu simply by copying their links and attributes (ie:
    /// identity of the item itself is not preserved).
    extern fn g_menu_remove(p_menu: *Menu, p_position: c_int) void;
    pub const remove = g_menu_remove;

    /// Removes all items in the menu.
    extern fn g_menu_remove_all(p_menu: *Menu) void;
    pub const removeAll = g_menu_remove_all;

    extern fn g_menu_get_type() usize;
    pub const getGObjectType = g_menu_get_type;

    extern fn g_object_ref(p_self: *gio.Menu) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Menu) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Menu, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gio.MenuAttributeIter` is an opaque structure type.  You must access it
/// using the functions below.
pub const MenuAttributeIter = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.MenuAttributeIterClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.MenuAttributeIterPrivate,

    pub const virtual_methods = struct {
        /// This function combines `gio.MenuAttributeIter.next` with
        /// `gio.MenuAttributeIter.getName` and `gio.MenuAttributeIter.getValue`.
        ///
        /// First the iterator is advanced to the next (possibly first) attribute.
        /// If that fails, then `FALSE` is returned and there are no other
        /// effects.
        ///
        /// If successful, `name` and `value` are set to the name and value of the
        /// attribute that has just been advanced to.  At this point,
        /// `gio.MenuAttributeIter.getName` and `gio.MenuAttributeIter.getValue` will
        /// return the same values again.
        ///
        /// The value returned in `name` remains valid for as long as the iterator
        /// remains at the current position.  The value returned in `value` must
        /// be unreffed using `glib.Variant.unref` when it is no longer in use.
        pub const get_next = struct {
            pub fn call(p_class: anytype, p_iter: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_out_name: ?*[*:0]const u8, p_value: ?**glib.Variant) c_int {
                return gobject.ext.as(MenuAttributeIter.Class, p_class).f_get_next.?(gobject.ext.as(MenuAttributeIter, p_iter), p_out_name, p_value);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_iter: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_out_name: ?*[*:0]const u8, p_value: ?**glib.Variant) callconv(.c) c_int) void {
                gobject.ext.as(MenuAttributeIter.Class, p_class).f_get_next = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Gets the name of the attribute at the current iterator position, as
    /// a string.
    ///
    /// The iterator is not advanced.
    extern fn g_menu_attribute_iter_get_name(p_iter: *MenuAttributeIter) [*:0]const u8;
    pub const getName = g_menu_attribute_iter_get_name;

    /// This function combines `gio.MenuAttributeIter.next` with
    /// `gio.MenuAttributeIter.getName` and `gio.MenuAttributeIter.getValue`.
    ///
    /// First the iterator is advanced to the next (possibly first) attribute.
    /// If that fails, then `FALSE` is returned and there are no other
    /// effects.
    ///
    /// If successful, `name` and `value` are set to the name and value of the
    /// attribute that has just been advanced to.  At this point,
    /// `gio.MenuAttributeIter.getName` and `gio.MenuAttributeIter.getValue` will
    /// return the same values again.
    ///
    /// The value returned in `name` remains valid for as long as the iterator
    /// remains at the current position.  The value returned in `value` must
    /// be unreffed using `glib.Variant.unref` when it is no longer in use.
    extern fn g_menu_attribute_iter_get_next(p_iter: *MenuAttributeIter, p_out_name: ?*[*:0]const u8, p_value: ?**glib.Variant) c_int;
    pub const getNext = g_menu_attribute_iter_get_next;

    /// Gets the value of the attribute at the current iterator position.
    ///
    /// The iterator is not advanced.
    extern fn g_menu_attribute_iter_get_value(p_iter: *MenuAttributeIter) *glib.Variant;
    pub const getValue = g_menu_attribute_iter_get_value;

    /// Attempts to advance the iterator to the next (possibly first)
    /// attribute.
    ///
    /// `TRUE` is returned on success, or `FALSE` if there are no more
    /// attributes.
    ///
    /// You must call this function when you first acquire the iterator
    /// to advance it to the first attribute (and determine if the first
    /// attribute exists at all).
    extern fn g_menu_attribute_iter_next(p_iter: *MenuAttributeIter) c_int;
    pub const next = g_menu_attribute_iter_next;

    extern fn g_menu_attribute_iter_get_type() usize;
    pub const getGObjectType = g_menu_attribute_iter_get_type;

    extern fn g_object_ref(p_self: *gio.MenuAttributeIter) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.MenuAttributeIter) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MenuAttributeIter, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gio.MenuItem` is an opaque structure type.  You must access it using the
/// functions below.
pub const MenuItem = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = MenuItem;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gio.MenuItem`.
    ///
    /// If `label` is non-`NULL` it is used to set the "label" attribute of the
    /// new item.
    ///
    /// If `detailed_action` is non-`NULL` it is used to set the "action" and
    /// possibly the "target" attribute of the new item.  See
    /// `gio.MenuItem.setDetailedAction` for more information.
    extern fn g_menu_item_new(p_label: ?[*:0]const u8, p_detailed_action: ?[*:0]const u8) *gio.MenuItem;
    pub const new = g_menu_item_new;

    /// Creates a `gio.MenuItem` as an exact copy of an existing menu item in a
    /// `gio.MenuModel`.
    ///
    /// `item_index` must be valid (ie: be sure to call
    /// `gio.MenuModel.getNItems` first).
    extern fn g_menu_item_new_from_model(p_model: *gio.MenuModel, p_item_index: c_int) *gio.MenuItem;
    pub const newFromModel = g_menu_item_new_from_model;

    /// Creates a new `gio.MenuItem` representing a section.
    ///
    /// This is a convenience API around `gio.MenuItem.new` and
    /// `gio.MenuItem.setSection`.
    ///
    /// The effect of having one menu appear as a section of another is
    /// exactly as it sounds: the items from `section` become a direct part of
    /// the menu that `menu_item` is added to.
    ///
    /// Visual separation is typically displayed between two non-empty
    /// sections.  If `label` is non-`NULL` then it will be incorporated into
    /// this visual indication.  This allows for labeled subsections of a
    /// menu.
    ///
    /// As a simple example, consider a typical "Edit" menu from a simple
    /// program.  It probably contains an "Undo" and "Redo" item, followed by
    /// a separator, followed by "Cut", "Copy" and "Paste".
    ///
    /// This would be accomplished by creating three `gio.Menu` instances.  The
    /// first would be populated with the "Undo" and "Redo" items, and the
    /// second with the "Cut", "Copy" and "Paste" items.  The first and
    /// second menus would then be added as submenus of the third.  In XML
    /// format, this would look something like the following:
    /// ```
    /// <menu id='edit-menu'>
    ///   <section>
    ///     <item label='Undo'/>
    ///     <item label='Redo'/>
    ///   </section>
    ///   <section>
    ///     <item label='Cut'/>
    ///     <item label='Copy'/>
    ///     <item label='Paste'/>
    ///   </section>
    /// </menu>
    /// ```
    ///
    /// The following example is exactly equivalent.  It is more illustrative
    /// of the exact relationship between the menus and items (keeping in
    /// mind that the 'link' element defines a new menu that is linked to the
    /// containing one).  The style of the second example is more verbose and
    /// difficult to read (and therefore not recommended except for the
    /// purpose of understanding what is really going on).
    /// ```
    /// <menu id='edit-menu'>
    ///   <item>
    ///     <link name='section'>
    ///       <item label='Undo'/>
    ///       <item label='Redo'/>
    ///     </link>
    ///   </item>
    ///   <item>
    ///     <link name='section'>
    ///       <item label='Cut'/>
    ///       <item label='Copy'/>
    ///       <item label='Paste'/>
    ///     </link>
    ///   </item>
    /// </menu>
    /// ```
    extern fn g_menu_item_new_section(p_label: ?[*:0]const u8, p_section: *gio.MenuModel) *gio.MenuItem;
    pub const newSection = g_menu_item_new_section;

    /// Creates a new `gio.MenuItem` representing a submenu.
    ///
    /// This is a convenience API around `gio.MenuItem.new` and
    /// `gio.MenuItem.setSubmenu`.
    extern fn g_menu_item_new_submenu(p_label: ?[*:0]const u8, p_submenu: *gio.MenuModel) *gio.MenuItem;
    pub const newSubmenu = g_menu_item_new_submenu;

    /// Queries the named `attribute` on `menu_item`.
    ///
    /// If the attribute exists and matches the `glib.VariantType` corresponding
    /// to `format_string` then `format_string` is used to deconstruct the
    /// value into the positional parameters and `TRUE` is returned.
    ///
    /// If the attribute does not exist, or it does exist but has the wrong
    /// type, then the positional parameters are ignored and `FALSE` is
    /// returned.
    extern fn g_menu_item_get_attribute(p_menu_item: *MenuItem, p_attribute: [*:0]const u8, p_format_string: [*:0]const u8, ...) c_int;
    pub const getAttribute = g_menu_item_get_attribute;

    /// Queries the named `attribute` on `menu_item`.
    ///
    /// If `expected_type` is specified and the attribute does not have this
    /// type, `NULL` is returned.  `NULL` is also returned if the attribute
    /// simply does not exist.
    extern fn g_menu_item_get_attribute_value(p_menu_item: *MenuItem, p_attribute: [*:0]const u8, p_expected_type: ?*const glib.VariantType) ?*glib.Variant;
    pub const getAttributeValue = g_menu_item_get_attribute_value;

    /// Queries the named `link` on `menu_item`.
    extern fn g_menu_item_get_link(p_menu_item: *MenuItem, p_link: [*:0]const u8) ?*gio.MenuModel;
    pub const getLink = g_menu_item_get_link;

    /// Sets or unsets the "action" and "target" attributes of `menu_item`.
    ///
    /// If `action` is `NULL` then both the "action" and "target" attributes
    /// are unset (and `format_string` is ignored along with the positional
    /// parameters).
    ///
    /// If `action` is non-`NULL` then the "action" attribute is set.
    /// `format_string` is then inspected.  If it is non-`NULL` then the proper
    /// position parameters are collected to create a `glib.Variant` instance to
    /// use as the target value.  If it is `NULL` then the positional
    /// parameters are ignored and the "target" attribute is unset.
    ///
    /// See also `gio.MenuItem.setActionAndTargetValue` for an equivalent
    /// call that directly accepts a `glib.Variant`.  See
    /// `gio.MenuItem.setDetailedAction` for a more convenient version that
    /// works with string-typed targets.
    ///
    /// See also `gio.MenuItem.setActionAndTargetValue` for a
    /// description of the semantics of the action and target attributes.
    extern fn g_menu_item_set_action_and_target(p_menu_item: *MenuItem, p_action: ?[*:0]const u8, p_format_string: ?[*:0]const u8, ...) void;
    pub const setActionAndTarget = g_menu_item_set_action_and_target;

    /// Sets or unsets the "action" and "target" attributes of `menu_item`.
    ///
    /// If `action` is `NULL` then both the "action" and "target" attributes
    /// are unset (and `target_value` is ignored).
    ///
    /// If `action` is non-`NULL` then the "action" attribute is set.  The
    /// "target" attribute is then set to the value of `target_value` if it is
    /// non-`NULL` or unset otherwise.
    ///
    /// Normal menu items (ie: not submenu, section or other custom item
    /// types) are expected to have the "action" attribute set to identify
    /// the action that they are associated with.  The state type of the
    /// action help to determine the disposition of the menu item.  See
    /// `gio.Action` and `gio.ActionGroup` for an overview of actions.
    ///
    /// In general, clicking on the menu item will result in activation of
    /// the named action with the "target" attribute given as the parameter
    /// to the action invocation.  If the "target" attribute is not set then
    /// the action is invoked with no parameter.
    ///
    /// If the action has no state then the menu item is usually drawn as a
    /// plain menu item (ie: with no additional decoration).
    ///
    /// If the action has a boolean state then the menu item is usually drawn
    /// as a toggle menu item (ie: with a checkmark or equivalent
    /// indication).  The item should be marked as 'toggled' or 'checked'
    /// when the boolean state is `TRUE`.
    ///
    /// If the action has a string state then the menu item is usually drawn
    /// as a radio menu item (ie: with a radio bullet or equivalent
    /// indication).  The item should be marked as 'selected' when the string
    /// state is equal to the value of the `target` property.
    ///
    /// See `gio.MenuItem.setActionAndTarget` or
    /// `gio.MenuItem.setDetailedAction` for two equivalent calls that are
    /// probably more convenient for most uses.
    extern fn g_menu_item_set_action_and_target_value(p_menu_item: *MenuItem, p_action: ?[*:0]const u8, p_target_value: ?*glib.Variant) void;
    pub const setActionAndTargetValue = g_menu_item_set_action_and_target_value;

    /// Sets or unsets an attribute on `menu_item`.
    ///
    /// The attribute to set or unset is specified by `attribute`. This
    /// can be one of the standard attribute names `G_MENU_ATTRIBUTE_LABEL`,
    /// `G_MENU_ATTRIBUTE_ACTION`, `G_MENU_ATTRIBUTE_TARGET`, or a custom
    /// attribute name.
    /// Attribute names are restricted to lowercase characters, numbers
    /// and '-'. Furthermore, the names must begin with a lowercase character,
    /// must not end with a '-', and must not contain consecutive dashes.
    ///
    /// If `format_string` is non-`NULL` then the proper position parameters
    /// are collected to create a `glib.Variant` instance to use as the attribute
    /// value.  If it is `NULL` then the positional parameterrs are ignored
    /// and the named attribute is unset.
    ///
    /// See also `gio.MenuItem.setAttributeValue` for an equivalent call
    /// that directly accepts a `glib.Variant`.
    extern fn g_menu_item_set_attribute(p_menu_item: *MenuItem, p_attribute: [*:0]const u8, p_format_string: ?[*:0]const u8, ...) void;
    pub const setAttribute = g_menu_item_set_attribute;

    /// Sets or unsets an attribute on `menu_item`.
    ///
    /// The attribute to set or unset is specified by `attribute`. This
    /// can be one of the standard attribute names `G_MENU_ATTRIBUTE_LABEL`,
    /// `G_MENU_ATTRIBUTE_ACTION`, `G_MENU_ATTRIBUTE_TARGET`, or a custom
    /// attribute name.
    /// Attribute names are restricted to lowercase characters, numbers
    /// and '-'. Furthermore, the names must begin with a lowercase character,
    /// must not end with a '-', and must not contain consecutive dashes.
    ///
    /// must consist only of lowercase
    /// ASCII characters, digits and '-'.
    ///
    /// If `value` is non-`NULL` then it is used as the new value for the
    /// attribute.  If `value` is `NULL` then the attribute is unset. If
    /// the `value` `glib.Variant` is floating, it is consumed.
    ///
    /// See also `gio.MenuItem.setAttribute` for a more convenient way to do
    /// the same.
    extern fn g_menu_item_set_attribute_value(p_menu_item: *MenuItem, p_attribute: [*:0]const u8, p_value: ?*glib.Variant) void;
    pub const setAttributeValue = g_menu_item_set_attribute_value;

    /// Sets the "action" and possibly the "target" attribute of `menu_item`.
    ///
    /// The format of `detailed_action` is the same format parsed by
    /// `gio.actionParseDetailedName`.
    ///
    /// See `gio.MenuItem.setActionAndTarget` or
    /// `gio.MenuItem.setActionAndTargetValue` for more flexible (but
    /// slightly less convenient) alternatives.
    ///
    /// See also `gio.MenuItem.setActionAndTargetValue` for a description of
    /// the semantics of the action and target attributes.
    extern fn g_menu_item_set_detailed_action(p_menu_item: *MenuItem, p_detailed_action: [*:0]const u8) void;
    pub const setDetailedAction = g_menu_item_set_detailed_action;

    /// Sets (or unsets) the icon on `menu_item`.
    ///
    /// This call is the same as calling `gio.Icon.serialize` and using the
    /// result as the value to `gio.MenuItem.setAttributeValue` for
    /// `G_MENU_ATTRIBUTE_ICON`.
    ///
    /// This API is only intended for use with "noun" menu items; things like
    /// bookmarks or applications in an "Open With" menu.  Don't use it on
    /// menu items corresponding to verbs (eg: stock icons for 'Save' or
    /// 'Quit').
    ///
    /// If `icon` is `NULL` then the icon is unset.
    extern fn g_menu_item_set_icon(p_menu_item: *MenuItem, p_icon: *gio.Icon) void;
    pub const setIcon = g_menu_item_set_icon;

    /// Sets or unsets the "label" attribute of `menu_item`.
    ///
    /// If `label` is non-`NULL` it is used as the label for the menu item.  If
    /// it is `NULL` then the label attribute is unset.
    extern fn g_menu_item_set_label(p_menu_item: *MenuItem, p_label: ?[*:0]const u8) void;
    pub const setLabel = g_menu_item_set_label;

    /// Creates a link from `menu_item` to `model` if non-`NULL`, or unsets it.
    ///
    /// Links are used to establish a relationship between a particular menu
    /// item and another menu.  For example, `G_MENU_LINK_SUBMENU` is used to
    /// associate a submenu with a particular menu item, and `G_MENU_LINK_SECTION`
    /// is used to create a section. Other types of link can be used, but there
    /// is no guarantee that clients will be able to make sense of them.
    /// Link types are restricted to lowercase characters, numbers
    /// and '-'. Furthermore, the names must begin with a lowercase character,
    /// must not end with a '-', and must not contain consecutive dashes.
    extern fn g_menu_item_set_link(p_menu_item: *MenuItem, p_link: [*:0]const u8, p_model: ?*gio.MenuModel) void;
    pub const setLink = g_menu_item_set_link;

    /// Sets or unsets the "section" link of `menu_item` to `section`.
    ///
    /// The effect of having one menu appear as a section of another is
    /// exactly as it sounds: the items from `section` become a direct part of
    /// the menu that `menu_item` is added to.  See `gio.MenuItem.newSection`
    /// for more information about what it means for a menu item to be a
    /// section.
    extern fn g_menu_item_set_section(p_menu_item: *MenuItem, p_section: ?*gio.MenuModel) void;
    pub const setSection = g_menu_item_set_section;

    /// Sets or unsets the "submenu" link of `menu_item` to `submenu`.
    ///
    /// If `submenu` is non-`NULL`, it is linked to.  If it is `NULL` then the
    /// link is unset.
    ///
    /// The effect of having one menu appear as a submenu of another is
    /// exactly as it sounds.
    extern fn g_menu_item_set_submenu(p_menu_item: *MenuItem, p_submenu: ?*gio.MenuModel) void;
    pub const setSubmenu = g_menu_item_set_submenu;

    extern fn g_menu_item_get_type() usize;
    pub const getGObjectType = g_menu_item_get_type;

    extern fn g_object_ref(p_self: *gio.MenuItem) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.MenuItem) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MenuItem, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gio.MenuLinkIter` is an opaque structure type.  You must access it using
/// the functions below.
pub const MenuLinkIter = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.MenuLinkIterClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.MenuLinkIterPrivate,

    pub const virtual_methods = struct {
        /// This function combines `gio.MenuLinkIter.next` with
        /// `gio.MenuLinkIter.getName` and `gio.MenuLinkIter.getValue`.
        ///
        /// First the iterator is advanced to the next (possibly first) link.
        /// If that fails, then `FALSE` is returned and there are no other effects.
        ///
        /// If successful, `out_link` and `value` are set to the name and `gio.MenuModel`
        /// of the link that has just been advanced to.  At this point,
        /// `gio.MenuLinkIter.getName` and `gio.MenuLinkIter.getValue` will return the
        /// same values again.
        ///
        /// The value returned in `out_link` remains valid for as long as the iterator
        /// remains at the current position.  The value returned in `value` must
        /// be unreffed using `gobject.Object.unref` when it is no longer in use.
        pub const get_next = struct {
            pub fn call(p_class: anytype, p_iter: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_out_link: ?*[*:0]const u8, p_value: ?**gio.MenuModel) c_int {
                return gobject.ext.as(MenuLinkIter.Class, p_class).f_get_next.?(gobject.ext.as(MenuLinkIter, p_iter), p_out_link, p_value);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_iter: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_out_link: ?*[*:0]const u8, p_value: ?**gio.MenuModel) callconv(.c) c_int) void {
                gobject.ext.as(MenuLinkIter.Class, p_class).f_get_next = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Gets the name of the link at the current iterator position.
    ///
    /// The iterator is not advanced.
    extern fn g_menu_link_iter_get_name(p_iter: *MenuLinkIter) [*:0]const u8;
    pub const getName = g_menu_link_iter_get_name;

    /// This function combines `gio.MenuLinkIter.next` with
    /// `gio.MenuLinkIter.getName` and `gio.MenuLinkIter.getValue`.
    ///
    /// First the iterator is advanced to the next (possibly first) link.
    /// If that fails, then `FALSE` is returned and there are no other effects.
    ///
    /// If successful, `out_link` and `value` are set to the name and `gio.MenuModel`
    /// of the link that has just been advanced to.  At this point,
    /// `gio.MenuLinkIter.getName` and `gio.MenuLinkIter.getValue` will return the
    /// same values again.
    ///
    /// The value returned in `out_link` remains valid for as long as the iterator
    /// remains at the current position.  The value returned in `value` must
    /// be unreffed using `gobject.Object.unref` when it is no longer in use.
    extern fn g_menu_link_iter_get_next(p_iter: *MenuLinkIter, p_out_link: ?*[*:0]const u8, p_value: ?**gio.MenuModel) c_int;
    pub const getNext = g_menu_link_iter_get_next;

    /// Gets the linked `gio.MenuModel` at the current iterator position.
    ///
    /// The iterator is not advanced.
    extern fn g_menu_link_iter_get_value(p_iter: *MenuLinkIter) *gio.MenuModel;
    pub const getValue = g_menu_link_iter_get_value;

    /// Attempts to advance the iterator to the next (possibly first)
    /// link.
    ///
    /// `TRUE` is returned on success, or `FALSE` if there are no more links.
    ///
    /// You must call this function when you first acquire the iterator to
    /// advance it to the first link (and determine if the first link exists
    /// at all).
    extern fn g_menu_link_iter_next(p_iter: *MenuLinkIter) c_int;
    pub const next = g_menu_link_iter_next;

    extern fn g_menu_link_iter_get_type() usize;
    pub const getGObjectType = g_menu_link_iter_get_type;

    extern fn g_object_ref(p_self: *gio.MenuLinkIter) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.MenuLinkIter) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MenuLinkIter, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GMenuModel` represents the contents of a menu — an ordered list of
/// menu items. The items are associated with actions, which can be
/// activated through them. Items can be grouped in sections, and may
/// have submenus associated with them. Both items and sections usually
/// have some representation data, such as labels or icons. The type of
/// the associated action (ie whether it is stateful, and what kind of
/// state it has) can influence the representation of the item.
///
/// The conceptual model of menus in `GMenuModel` is hierarchical:
/// sections and submenus are again represented by `GMenuModel`s.
/// Menus themselves do not define their own roles. Rather, the role
/// of a particular `GMenuModel` is defined by the item that references
/// it (or, in the case of the ‘root’ menu, is defined by the context
/// in which it is used).
///
/// As an example, consider the visible portions of this menu:
///
/// ## An example menu
///
/// ![](menu-example.png)
///
/// While this kind of deeply nested menu is no longer considered good UI
/// practice, it serves as a good example of the concepts in `GMenuModel`.
/// There are 8 ‘menus’ visible in the screenshot: one menubar, two
/// submenus and 5 sections:
///
/// - the toplevel menubar (containing 4 items)
/// - the View submenu (containing 3 sections)
/// - the first section of the View submenu (containing 2 items)
/// - the second section of the View submenu (containing 1 item)
/// - the final section of the View submenu (containing 1 item)
/// - the Highlight Mode submenu (containing 2 sections)
/// - the Sources section (containing 2 items)
/// - the Markup section (containing 2 items)
///
/// The [example](`a`-menu-example) illustrates the conceptual connection between
/// these 8 menus. Each large block in the figure represents a menu and the
/// smaller blocks within the large block represent items in that menu. Some
/// items contain references to other menus.
///
/// ## A menu example
///
/// <picture>
///   <source srcset="menu-model-dark.svg" media="(prefers-color-scheme: dark)">
///   <img src="menu-model-light.svg" alt="menu model">
/// </picture>
///
/// Notice that the separators visible in the [example](`an`-example-menu)
/// appear nowhere in the [menu model](`a`-menu-example). This is because
/// separators are not explicitly represented in the menu model. Instead,
/// a separator is inserted between any two non-empty sections of a menu.
/// Section items can have labels just like any other item. In that case,
/// a display system may show a section header instead of a separator.
///
/// The motivation for this abstract model of application controls is
/// that modern user interfaces tend to make these controls available
/// outside the application. Examples include global menus, jumplists,
/// dash boards, etc. To support such uses, it is necessary to ‘export’
/// information about actions and their representation in menus, which
/// is exactly what the action group exporter and the menu model exporter do for
/// `gio.ActionGroup` and `gio.MenuModel`. The client-side
/// counterparts to make use of the exported information are
/// `gio.DBusActionGroup` and `gio.DBusMenuModel`.
///
/// The API of `GMenuModel` is very generic, with iterators for the
/// attributes and links of an item, see
/// `gio.MenuModel.iterateItemAttributes` and
/// `gio.MenuModel.iterateItemLinks`. The ‘standard’ attributes and
/// link types have predefined names: `G_MENU_ATTRIBUTE_LABEL`,
/// `G_MENU_ATTRIBUTE_ACTION`, `G_MENU_ATTRIBUTE_TARGET`, `G_MENU_LINK_SECTION`
/// and `G_MENU_LINK_SUBMENU`.
///
/// Items in a `GMenuModel` represent active controls if they refer to
/// an action that can get activated when the user interacts with the
/// menu item. The reference to the action is encoded by the string ID
/// in the `G_MENU_ATTRIBUTE_ACTION` attribute. An action ID uniquely
/// identifies an action in an action group. Which action group(s) provide
/// actions depends on the context in which the menu model is used.
/// E.g. when the model is exported as the application menu of a
/// [`GtkApplication`](https://docs.gtk.org/gtk4/class.Application.html),
/// actions can be application-wide or window-specific (and thus come from
/// two different action groups). By convention, the application-wide actions
/// have names that start with `app.`, while the names of window-specific
/// actions start with `win.`.
///
/// While a wide variety of stateful actions is possible, the following
/// is the minimum that is expected to be supported by all users of exported
/// menu information:
/// - an action with no parameter type and no state
/// - an action with no parameter type and boolean state
/// - an action with string parameter type and string state
///
/// ## Stateless
///
/// A stateless action typically corresponds to an ordinary menu item.
///
/// Selecting such a menu item will activate the action (with no parameter).
///
/// ## Boolean State
///
/// An action with a boolean state will most typically be used with a ‘toggle’
/// or ‘switch’ menu item. The state can be set directly, but activating the
/// action (with no parameter) results in the state being toggled.
///
/// Selecting a toggle menu item will activate the action. The menu item should
/// be rendered as ‘checked’ when the state is true.
///
/// ## String Parameter and State
///
/// Actions with string parameters and state will most typically be used to
/// represent an enumerated choice over the items available for a group of
/// radio menu items. Activating the action with a string parameter is
/// equivalent to setting that parameter as the state.
///
/// Radio menu items, in addition to being associated with the action, will
/// have a target value. Selecting that menu item will result in activation
/// of the action with the target value as the parameter. The menu item should
/// be rendered as ‘selected’ when the state of the action is equal to the
/// target value of the menu item.
pub const MenuModel = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.MenuModelClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.MenuModelPrivate,

    pub const virtual_methods = struct {
        /// Queries the item at position `item_index` in `model` for the attribute
        /// specified by `attribute`.
        ///
        /// If `expected_type` is non-`NULL` then it specifies the expected type of
        /// the attribute.  If it is `NULL` then any type will be accepted.
        ///
        /// If the attribute exists and matches `expected_type` (or if the
        /// expected type is unspecified) then the value is returned.
        ///
        /// If the attribute does not exist, or does not match the expected type
        /// then `NULL` is returned.
        pub const get_item_attribute_value = struct {
            pub fn call(p_class: anytype, p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_item_index: c_int, p_attribute: [*:0]const u8, p_expected_type: ?*const glib.VariantType) ?*glib.Variant {
                return gobject.ext.as(MenuModel.Class, p_class).f_get_item_attribute_value.?(gobject.ext.as(MenuModel, p_model), p_item_index, p_attribute, p_expected_type);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_item_index: c_int, p_attribute: [*:0]const u8, p_expected_type: ?*const glib.VariantType) callconv(.c) ?*glib.Variant) void {
                gobject.ext.as(MenuModel.Class, p_class).f_get_item_attribute_value = @ptrCast(p_implementation);
            }
        };

        /// Gets all the attributes associated with the item in the menu model.
        pub const get_item_attributes = struct {
            pub fn call(p_class: anytype, p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_item_index: c_int, p_attributes: **glib.HashTable) void {
                return gobject.ext.as(MenuModel.Class, p_class).f_get_item_attributes.?(gobject.ext.as(MenuModel, p_model), p_item_index, p_attributes);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_item_index: c_int, p_attributes: **glib.HashTable) callconv(.c) void) void {
                gobject.ext.as(MenuModel.Class, p_class).f_get_item_attributes = @ptrCast(p_implementation);
            }
        };

        /// Queries the item at position `item_index` in `model` for the link
        /// specified by `link`.
        ///
        /// If the link exists, the linked `gio.MenuModel` is returned.  If the link
        /// does not exist, `NULL` is returned.
        pub const get_item_link = struct {
            pub fn call(p_class: anytype, p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_item_index: c_int, p_link: [*:0]const u8) ?*gio.MenuModel {
                return gobject.ext.as(MenuModel.Class, p_class).f_get_item_link.?(gobject.ext.as(MenuModel, p_model), p_item_index, p_link);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_item_index: c_int, p_link: [*:0]const u8) callconv(.c) ?*gio.MenuModel) void {
                gobject.ext.as(MenuModel.Class, p_class).f_get_item_link = @ptrCast(p_implementation);
            }
        };

        /// Gets all the links associated with the item in the menu model.
        pub const get_item_links = struct {
            pub fn call(p_class: anytype, p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_item_index: c_int, p_links: **glib.HashTable) void {
                return gobject.ext.as(MenuModel.Class, p_class).f_get_item_links.?(gobject.ext.as(MenuModel, p_model), p_item_index, p_links);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_item_index: c_int, p_links: **glib.HashTable) callconv(.c) void) void {
                gobject.ext.as(MenuModel.Class, p_class).f_get_item_links = @ptrCast(p_implementation);
            }
        };

        /// Query the number of items in `model`.
        pub const get_n_items = struct {
            pub fn call(p_class: anytype, p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(MenuModel.Class, p_class).f_get_n_items.?(gobject.ext.as(MenuModel, p_model));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(MenuModel.Class, p_class).f_get_n_items = @ptrCast(p_implementation);
            }
        };

        /// Queries if `model` is mutable.
        ///
        /// An immutable `gio.MenuModel` will never emit the `gio.MenuModel.signals.items`-changed
        /// signal. Consumers of the model may make optimisations accordingly.
        pub const is_mutable = struct {
            pub fn call(p_class: anytype, p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(MenuModel.Class, p_class).f_is_mutable.?(gobject.ext.as(MenuModel, p_model));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(MenuModel.Class, p_class).f_is_mutable = @ptrCast(p_implementation);
            }
        };

        /// Creates a `gio.MenuAttributeIter` to iterate over the attributes of
        /// the item at position `item_index` in `model`.
        ///
        /// You must free the iterator with `gobject.Object.unref` when you are done.
        pub const iterate_item_attributes = struct {
            pub fn call(p_class: anytype, p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_item_index: c_int) *gio.MenuAttributeIter {
                return gobject.ext.as(MenuModel.Class, p_class).f_iterate_item_attributes.?(gobject.ext.as(MenuModel, p_model), p_item_index);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_item_index: c_int) callconv(.c) *gio.MenuAttributeIter) void {
                gobject.ext.as(MenuModel.Class, p_class).f_iterate_item_attributes = @ptrCast(p_implementation);
            }
        };

        /// Creates a `gio.MenuLinkIter` to iterate over the links of the item at
        /// position `item_index` in `model`.
        ///
        /// You must free the iterator with `gobject.Object.unref` when you are done.
        pub const iterate_item_links = struct {
            pub fn call(p_class: anytype, p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_item_index: c_int) *gio.MenuLinkIter {
                return gobject.ext.as(MenuModel.Class, p_class).f_iterate_item_links.?(gobject.ext.as(MenuModel, p_model), p_item_index);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_model: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_item_index: c_int) callconv(.c) *gio.MenuLinkIter) void {
                gobject.ext.as(MenuModel.Class, p_class).f_iterate_item_links = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// Emitted when a change has occurred to the menu.
        ///
        /// The only changes that can occur to a menu is that items are removed
        /// or added.  Items may not change (except by being removed and added
        /// back in the same location).  This signal is capable of describing
        /// both of those changes (at the same time).
        ///
        /// The signal means that starting at the index `position`, `removed`
        /// items were removed and `added` items were added in their place.  If
        /// `removed` is zero then only items were added.  If `added` is zero
        /// then only items were removed.
        ///
        /// As an example, if the menu contains items a, b, c, d (in that
        /// order) and the signal (2, 1, 3) occurs then the new composition of
        /// the menu will be a, b, _, _, _, d (with each _ representing some
        /// new item).
        ///
        /// Signal handlers may query the model (particularly the added items)
        /// and expect to see the results of the modification that is being
        /// reported.  The signal is emitted after the modification.
        pub const items_changed = struct {
            pub const name = "items-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_position: c_int, p_removed: c_int, p_added: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MenuModel, p_instance))),
                    gobject.signalLookup("items-changed", MenuModel.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Queries item at position `item_index` in `model` for the attribute
    /// specified by `attribute`.
    ///
    /// If the attribute exists and matches the `glib.VariantType` corresponding
    /// to `format_string` then `format_string` is used to deconstruct the
    /// value into the positional parameters and `TRUE` is returned.
    ///
    /// If the attribute does not exist, or it does exist but has the wrong
    /// type, then the positional parameters are ignored and `FALSE` is
    /// returned.
    ///
    /// This function is a mix of `gio.MenuModel.getItemAttributeValue` and
    /// `glib.Variant.get`, followed by a `glib.Variant.unref`.  As such,
    /// `format_string` must make a complete copy of the data (since the
    /// `glib.Variant` may go away after the call to `glib.Variant.unref`).  In
    /// particular, no '&' characters are allowed in `format_string`.
    extern fn g_menu_model_get_item_attribute(p_model: *MenuModel, p_item_index: c_int, p_attribute: [*:0]const u8, p_format_string: [*:0]const u8, ...) c_int;
    pub const getItemAttribute = g_menu_model_get_item_attribute;

    /// Queries the item at position `item_index` in `model` for the attribute
    /// specified by `attribute`.
    ///
    /// If `expected_type` is non-`NULL` then it specifies the expected type of
    /// the attribute.  If it is `NULL` then any type will be accepted.
    ///
    /// If the attribute exists and matches `expected_type` (or if the
    /// expected type is unspecified) then the value is returned.
    ///
    /// If the attribute does not exist, or does not match the expected type
    /// then `NULL` is returned.
    extern fn g_menu_model_get_item_attribute_value(p_model: *MenuModel, p_item_index: c_int, p_attribute: [*:0]const u8, p_expected_type: ?*const glib.VariantType) ?*glib.Variant;
    pub const getItemAttributeValue = g_menu_model_get_item_attribute_value;

    /// Queries the item at position `item_index` in `model` for the link
    /// specified by `link`.
    ///
    /// If the link exists, the linked `gio.MenuModel` is returned.  If the link
    /// does not exist, `NULL` is returned.
    extern fn g_menu_model_get_item_link(p_model: *MenuModel, p_item_index: c_int, p_link: [*:0]const u8) ?*gio.MenuModel;
    pub const getItemLink = g_menu_model_get_item_link;

    /// Query the number of items in `model`.
    extern fn g_menu_model_get_n_items(p_model: *MenuModel) c_int;
    pub const getNItems = g_menu_model_get_n_items;

    /// Queries if `model` is mutable.
    ///
    /// An immutable `gio.MenuModel` will never emit the `gio.MenuModel.signals.items`-changed
    /// signal. Consumers of the model may make optimisations accordingly.
    extern fn g_menu_model_is_mutable(p_model: *MenuModel) c_int;
    pub const isMutable = g_menu_model_is_mutable;

    /// Requests emission of the `gio.MenuModel.signals.items`-changed signal on `model`.
    ///
    /// This function should never be called except by `gio.MenuModel`
    /// subclasses.  Any other calls to this function will very likely lead
    /// to a violation of the interface of the model.
    ///
    /// The implementation should update its internal representation of the
    /// menu before emitting the signal.  The implementation should further
    /// expect to receive queries about the new state of the menu (and
    /// particularly added menu items) while signal handlers are running.
    ///
    /// The implementation must dispatch this call directly from a mainloop
    /// entry and not in response to calls -- particularly those from the
    /// `gio.MenuModel` API.  Said another way: the menu must not change while
    /// user code is running without returning to the mainloop.
    extern fn g_menu_model_items_changed(p_model: *MenuModel, p_position: c_int, p_removed: c_int, p_added: c_int) void;
    pub const itemsChanged = g_menu_model_items_changed;

    /// Creates a `gio.MenuAttributeIter` to iterate over the attributes of
    /// the item at position `item_index` in `model`.
    ///
    /// You must free the iterator with `gobject.Object.unref` when you are done.
    extern fn g_menu_model_iterate_item_attributes(p_model: *MenuModel, p_item_index: c_int) *gio.MenuAttributeIter;
    pub const iterateItemAttributes = g_menu_model_iterate_item_attributes;

    /// Creates a `gio.MenuLinkIter` to iterate over the links of the item at
    /// position `item_index` in `model`.
    ///
    /// You must free the iterator with `gobject.Object.unref` when you are done.
    extern fn g_menu_model_iterate_item_links(p_model: *MenuModel, p_item_index: c_int) *gio.MenuLinkIter;
    pub const iterateItemLinks = g_menu_model_iterate_item_links;

    extern fn g_menu_model_get_type() usize;
    pub const getGObjectType = g_menu_model_get_type;

    extern fn g_object_ref(p_self: *gio.MenuModel) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.MenuModel) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MenuModel, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GMountOperation` provides a mechanism for interacting with the user.
/// It can be used for authenticating mountable operations, such as loop
/// mounting files, hard drive partitions or server locations. It can
/// also be used to ask the user questions or show a list of applications
/// preventing unmount or eject operations from completing.
///
/// Note that `GMountOperation` is used for more than just `gio.Mount`
/// objects – for example it is also used in `gio.Drive.start` and
/// `gio.Drive.stop`.
///
/// Users should instantiate a subclass of this that implements all the
/// various callbacks to show the required dialogs, such as
/// [`GtkMountOperation`](https://docs.gtk.org/gtk4/class.MountOperation.html).
/// If no user interaction is desired (for example when automounting
/// filesystems at login time), usually `NULL` can be passed, see each method
/// taking a `GMountOperation` for details.
///
/// Throughout the API, the term ‘TCRYPT’ is used to mean ‘compatible with TrueCrypt and VeraCrypt’.
/// [TrueCrypt](https://en.wikipedia.org/wiki/TrueCrypt) is a discontinued system for
/// encrypting file containers, partitions or whole disks, typically used with Windows.
/// [VeraCrypt](https://www.veracrypt.fr/) is a maintained fork of TrueCrypt with various
/// improvements and auditing fixes.
pub const MountOperation = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.MountOperationClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.MountOperationPrivate,

    pub const virtual_methods = struct {
        pub const aborted = struct {
            pub fn call(p_class: anytype, p_op: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(MountOperation.Class, p_class).f_aborted.?(gobject.ext.as(MountOperation, p_op));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_op: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(MountOperation.Class, p_class).f_aborted = @ptrCast(p_implementation);
            }
        };

        pub const ask_password = struct {
            pub fn call(p_class: anytype, p_op: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_message: [*:0]const u8, p_default_user: [*:0]const u8, p_default_domain: [*:0]const u8, p_flags: gio.AskPasswordFlags) void {
                return gobject.ext.as(MountOperation.Class, p_class).f_ask_password.?(gobject.ext.as(MountOperation, p_op), p_message, p_default_user, p_default_domain, p_flags);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_op: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_message: [*:0]const u8, p_default_user: [*:0]const u8, p_default_domain: [*:0]const u8, p_flags: gio.AskPasswordFlags) callconv(.c) void) void {
                gobject.ext.as(MountOperation.Class, p_class).f_ask_password = @ptrCast(p_implementation);
            }
        };

        /// Virtual implementation of `gio.MountOperation.signals.ask`-question.
        pub const ask_question = struct {
            pub fn call(p_class: anytype, p_op: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_message: [*:0]const u8, p_choices: [*][*:0]const u8) void {
                return gobject.ext.as(MountOperation.Class, p_class).f_ask_question.?(gobject.ext.as(MountOperation, p_op), p_message, p_choices);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_op: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_message: [*:0]const u8, p_choices: [*][*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(MountOperation.Class, p_class).f_ask_question = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gio.MountOperation.signals.reply` signal.
        pub const reply = struct {
            pub fn call(p_class: anytype, p_op: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: gio.MountOperationResult) void {
                return gobject.ext.as(MountOperation.Class, p_class).f_reply.?(gobject.ext.as(MountOperation, p_op), p_result);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_op: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: gio.MountOperationResult) callconv(.c) void) void {
                gobject.ext.as(MountOperation.Class, p_class).f_reply = @ptrCast(p_implementation);
            }
        };

        /// Virtual implementation of `gio.MountOperation.signals.show`-processes.
        pub const show_processes = struct {
            pub fn call(p_class: anytype, p_op: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_message: [*:0]const u8, p_processes: *glib.Array, p_choices: [*][*:0]const u8) void {
                return gobject.ext.as(MountOperation.Class, p_class).f_show_processes.?(gobject.ext.as(MountOperation, p_op), p_message, p_processes, p_choices);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_op: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_message: [*:0]const u8, p_processes: *glib.Array, p_choices: [*][*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(MountOperation.Class, p_class).f_show_processes = @ptrCast(p_implementation);
            }
        };

        pub const show_unmount_progress = struct {
            pub fn call(p_class: anytype, p_op: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_message: [*:0]const u8, p_time_left: i64, p_bytes_left: i64) void {
                return gobject.ext.as(MountOperation.Class, p_class).f_show_unmount_progress.?(gobject.ext.as(MountOperation, p_op), p_message, p_time_left, p_bytes_left);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_op: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_message: [*:0]const u8, p_time_left: i64, p_bytes_left: i64) callconv(.c) void) void {
                gobject.ext.as(MountOperation.Class, p_class).f_show_unmount_progress = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Whether to use an anonymous user when authenticating.
        pub const anonymous = struct {
            pub const name = "anonymous";

            pub const Type = c_int;
        };

        /// The index of the user's choice when a question is asked during the
        /// mount operation. See the `gio.MountOperation.signals.ask`-question signal.
        pub const choice = struct {
            pub const name = "choice";

            pub const Type = c_int;
        };

        /// The domain to use for the mount operation.
        pub const domain = struct {
            pub const name = "domain";

            pub const Type = ?[*:0]u8;
        };

        /// Whether the device to be unlocked is a TCRYPT hidden volume.
        /// See [the VeraCrypt documentation](https://www.veracrypt.fr/en/Hidden`@"20Volume"`.html).
        pub const is_tcrypt_hidden_volume = struct {
            pub const name = "is-tcrypt-hidden-volume";

            pub const Type = c_int;
        };

        /// Whether the device to be unlocked is a TCRYPT system volume.
        /// In this context, a system volume is a volume with a bootloader
        /// and operating system installed. This is only supported for Windows
        /// operating systems. For further documentation, see
        /// [the VeraCrypt documentation](https://www.veracrypt.fr/en/System`@"20Encryption"`.html).
        pub const is_tcrypt_system_volume = struct {
            pub const name = "is-tcrypt-system-volume";

            pub const Type = c_int;
        };

        /// The password that is used for authentication when carrying out
        /// the mount operation.
        pub const password = struct {
            pub const name = "password";

            pub const Type = ?[*:0]u8;
        };

        /// Determines if and how the password information should be saved.
        pub const password_save = struct {
            pub const name = "password-save";

            pub const Type = gio.PasswordSave;
        };

        /// The VeraCrypt PIM value, when unlocking a VeraCrypt volume. See
        /// [the VeraCrypt documentation](https://www.veracrypt.fr/en/Personal`@"20Iterations"``@"20Multiplier"``@"20"`(PIM).html).
        pub const pim = struct {
            pub const name = "pim";

            pub const Type = c_uint;
        };

        /// The user name that is used for authentication when carrying out
        /// the mount operation.
        pub const username = struct {
            pub const name = "username";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {
        /// Emitted by the backend when e.g. a device becomes unavailable
        /// while a mount operation is in progress.
        ///
        /// Implementations of GMountOperation should handle this signal
        /// by dismissing open password dialogs.
        pub const aborted = struct {
            pub const name = "aborted";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MountOperation, p_instance))),
                    gobject.signalLookup("aborted", MountOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when a mount operation asks the user for a password.
        ///
        /// If the message contains a line break, the first line should be
        /// presented as a heading. For example, it may be used as the
        /// primary text in a `GtkMessageDialog`.
        pub const ask_password = struct {
            pub const name = "ask-password";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_message: [*:0]u8, p_default_user: [*:0]u8, p_default_domain: [*:0]u8, p_flags: gio.AskPasswordFlags, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MountOperation, p_instance))),
                    gobject.signalLookup("ask-password", MountOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when asking the user a question and gives a list of
        /// choices for the user to choose from.
        ///
        /// If the message contains a line break, the first line should be
        /// presented as a heading. For example, it may be used as the
        /// primary text in a `GtkMessageDialog`.
        pub const ask_question = struct {
            pub const name = "ask-question";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_message: [*:0]u8, p_choices: [*][*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MountOperation, p_instance))),
                    gobject.signalLookup("ask-question", MountOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the user has replied to the mount operation.
        pub const reply = struct {
            pub const name = "reply";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_result: gio.MountOperationResult, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MountOperation, p_instance))),
                    gobject.signalLookup("reply", MountOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when one or more processes are blocking an operation
        /// e.g. unmounting/ejecting a `gio.Mount` or stopping a `gio.Drive`.
        ///
        /// Note that this signal may be emitted several times to update the
        /// list of blocking processes as processes close files. The
        /// application should only respond with `gio.MountOperation.reply` to
        /// the latest signal (setting `gio.MountOperation.properties.choice` to the choice
        /// the user made).
        ///
        /// If the message contains a line break, the first line should be
        /// presented as a heading. For example, it may be used as the
        /// primary text in a `GtkMessageDialog`.
        pub const show_processes = struct {
            pub const name = "show-processes";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_message: [*:0]u8, p_processes: [*]glib.Pid, p_choices: [*][*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MountOperation, p_instance))),
                    gobject.signalLookup("show-processes", MountOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when an unmount operation has been busy for more than some time
        /// (typically 1.5 seconds).
        ///
        /// When unmounting or ejecting a volume, the kernel might need to flush
        /// pending data in its buffers to the volume stable storage, and this operation
        /// can take a considerable amount of time. This signal may be emitted several
        /// times as long as the unmount operation is outstanding, and then one
        /// last time when the operation is completed, with `bytes_left` set to zero.
        ///
        /// Implementations of GMountOperation should handle this signal by
        /// showing an UI notification, and then dismiss it, or show another notification
        /// of completion, when `bytes_left` reaches zero.
        ///
        /// If the message contains a line break, the first line should be
        /// presented as a heading. For example, it may be used as the
        /// primary text in a `GtkMessageDialog`.
        pub const show_unmount_progress = struct {
            pub const name = "show-unmount-progress";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_message: [*:0]u8, p_time_left: i64, p_bytes_left: i64, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MountOperation, p_instance))),
                    gobject.signalLookup("show-unmount-progress", MountOperation.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new mount operation.
    extern fn g_mount_operation_new() *gio.MountOperation;
    pub const new = g_mount_operation_new;

    /// Check to see whether the mount operation is being used
    /// for an anonymous user.
    extern fn g_mount_operation_get_anonymous(p_op: *MountOperation) c_int;
    pub const getAnonymous = g_mount_operation_get_anonymous;

    /// Gets a choice from the mount operation.
    extern fn g_mount_operation_get_choice(p_op: *MountOperation) c_int;
    pub const getChoice = g_mount_operation_get_choice;

    /// Gets the domain of the mount operation.
    extern fn g_mount_operation_get_domain(p_op: *MountOperation) ?[*:0]const u8;
    pub const getDomain = g_mount_operation_get_domain;

    /// Check to see whether the mount operation is being used
    /// for a TCRYPT hidden volume.
    extern fn g_mount_operation_get_is_tcrypt_hidden_volume(p_op: *MountOperation) c_int;
    pub const getIsTcryptHiddenVolume = g_mount_operation_get_is_tcrypt_hidden_volume;

    /// Check to see whether the mount operation is being used
    /// for a TCRYPT system volume.
    extern fn g_mount_operation_get_is_tcrypt_system_volume(p_op: *MountOperation) c_int;
    pub const getIsTcryptSystemVolume = g_mount_operation_get_is_tcrypt_system_volume;

    /// Gets a password from the mount operation.
    extern fn g_mount_operation_get_password(p_op: *MountOperation) ?[*:0]const u8;
    pub const getPassword = g_mount_operation_get_password;

    /// Gets the state of saving passwords for the mount operation.
    extern fn g_mount_operation_get_password_save(p_op: *MountOperation) gio.PasswordSave;
    pub const getPasswordSave = g_mount_operation_get_password_save;

    /// Gets a PIM from the mount operation.
    extern fn g_mount_operation_get_pim(p_op: *MountOperation) c_uint;
    pub const getPim = g_mount_operation_get_pim;

    /// Get the user name from the mount operation.
    extern fn g_mount_operation_get_username(p_op: *MountOperation) ?[*:0]const u8;
    pub const getUsername = g_mount_operation_get_username;

    /// Emits the `gio.MountOperation.signals.reply` signal.
    extern fn g_mount_operation_reply(p_op: *MountOperation, p_result: gio.MountOperationResult) void;
    pub const reply = g_mount_operation_reply;

    /// Sets the mount operation to use an anonymous user if `anonymous` is `TRUE`.
    extern fn g_mount_operation_set_anonymous(p_op: *MountOperation, p_anonymous: c_int) void;
    pub const setAnonymous = g_mount_operation_set_anonymous;

    /// Sets a default choice for the mount operation.
    extern fn g_mount_operation_set_choice(p_op: *MountOperation, p_choice: c_int) void;
    pub const setChoice = g_mount_operation_set_choice;

    /// Sets the mount operation's domain.
    extern fn g_mount_operation_set_domain(p_op: *MountOperation, p_domain: ?[*:0]const u8) void;
    pub const setDomain = g_mount_operation_set_domain;

    /// Sets the mount operation to use a hidden volume if `hidden_volume` is `TRUE`.
    extern fn g_mount_operation_set_is_tcrypt_hidden_volume(p_op: *MountOperation, p_hidden_volume: c_int) void;
    pub const setIsTcryptHiddenVolume = g_mount_operation_set_is_tcrypt_hidden_volume;

    /// Sets the mount operation to use a system volume if `system_volume` is `TRUE`.
    extern fn g_mount_operation_set_is_tcrypt_system_volume(p_op: *MountOperation, p_system_volume: c_int) void;
    pub const setIsTcryptSystemVolume = g_mount_operation_set_is_tcrypt_system_volume;

    /// Sets the mount operation's password to `password`.
    extern fn g_mount_operation_set_password(p_op: *MountOperation, p_password: ?[*:0]const u8) void;
    pub const setPassword = g_mount_operation_set_password;

    /// Sets the state of saving passwords for the mount operation.
    extern fn g_mount_operation_set_password_save(p_op: *MountOperation, p_save: gio.PasswordSave) void;
    pub const setPasswordSave = g_mount_operation_set_password_save;

    /// Sets the mount operation's PIM to `pim`.
    extern fn g_mount_operation_set_pim(p_op: *MountOperation, p_pim: c_uint) void;
    pub const setPim = g_mount_operation_set_pim;

    /// Sets the user name within `op` to `username`.
    extern fn g_mount_operation_set_username(p_op: *MountOperation, p_username: ?[*:0]const u8) void;
    pub const setUsername = g_mount_operation_set_username;

    extern fn g_mount_operation_get_type() usize;
    pub const getGObjectType = g_mount_operation_get_type;

    extern fn g_object_ref(p_self: *gio.MountOperation) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.MountOperation) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MountOperation, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A socket address of some unknown native type.
///
/// This corresponds to a general `struct sockaddr` of a type not otherwise
/// handled by GLib.
pub const NativeSocketAddress = extern struct {
    pub const Parent = gio.SocketAddress;
    pub const Implements = [_]type{gio.SocketConnectable};
    pub const Class = gio.NativeSocketAddressClass;
    f_parent_instance: gio.SocketAddress,
    f_priv: ?*gio.NativeSocketAddressPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gio.NativeSocketAddress` for `native` and `len`.
    extern fn g_native_socket_address_new(p_native: ?*anyopaque, p_len: usize) *gio.NativeSocketAddress;
    pub const new = g_native_socket_address_new;

    extern fn g_native_socket_address_get_type() usize;
    pub const getGObjectType = g_native_socket_address_get_type;

    extern fn g_object_ref(p_self: *gio.NativeSocketAddress) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.NativeSocketAddress) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *NativeSocketAddress, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NativeVolumeMonitor = extern struct {
    pub const Parent = gio.VolumeMonitor;
    pub const Implements = [_]type{};
    pub const Class = gio.NativeVolumeMonitorClass;
    f_parent_instance: gio.VolumeMonitor,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn g_native_volume_monitor_get_type() usize;
    pub const getGObjectType = g_native_volume_monitor_get_type;

    extern fn g_object_ref(p_self: *gio.NativeVolumeMonitor) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.NativeVolumeMonitor) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *NativeVolumeMonitor, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GNetworkAddress` provides an easy way to resolve a hostname and
/// then attempt to connect to that host, handling the possibility of
/// multiple IP addresses and multiple address families.
///
/// The enumeration results of resolved addresses *may* be cached as long
/// as this object is kept alive which may have unexpected results if
/// alive for too long.
///
/// See `gio.SocketConnectable` for an example of using the connectable
/// interface.
pub const NetworkAddress = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.SocketConnectable};
    pub const Class = gio.NetworkAddressClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.NetworkAddressPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Hostname to resolve.
        pub const hostname = struct {
            pub const name = "hostname";

            pub const Type = ?[*:0]u8;
        };

        /// Network port.
        pub const port = struct {
            pub const name = "port";

            pub const Type = c_uint;
        };

        /// URI scheme.
        pub const scheme = struct {
            pub const name = "scheme";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.SocketConnectable` for connecting to the given
    /// `hostname` and `port`. May fail and return `NULL` in case
    /// parsing `host_and_port` fails.
    ///
    /// `host_and_port` may be in any of a number of recognised formats; an IPv6
    /// address, an IPv4 address, or a domain name (in which case a DNS
    /// lookup is performed). Quoting with [] is supported for all address
    /// types. A port override may be specified in the usual way with a
    /// colon.
    ///
    /// If no port is specified in `host_and_port` then `default_port` will be
    /// used as the port number to connect to.
    ///
    /// In general, `host_and_port` is expected to be provided by the user
    /// (allowing them to give the hostname, and a port override if necessary)
    /// and `default_port` is expected to be provided by the application.
    ///
    /// (The port component of `host_and_port` can also be specified as a
    /// service name rather than as a numeric port, but this functionality
    /// is deprecated, because it depends on the contents of /etc/services,
    /// which is generally quite sparse on platforms other than Linux.)
    extern fn g_network_address_parse(p_host_and_port: [*:0]const u8, p_default_port: u16, p_error: ?*?*glib.Error) ?*gio.NetworkAddress;
    pub const parse = g_network_address_parse;

    /// Creates a new `gio.SocketConnectable` for connecting to the given
    /// `uri`. May fail and return `NULL` in case parsing `uri` fails.
    ///
    /// Using this rather than `gio.NetworkAddress.new` or
    /// `gio.NetworkAddress.parse` allows `gio.SocketClient` to determine
    /// when to use application-specific proxy protocols.
    extern fn g_network_address_parse_uri(p_uri: [*:0]const u8, p_default_port: u16, p_error: ?*?*glib.Error) ?*gio.NetworkAddress;
    pub const parseUri = g_network_address_parse_uri;

    /// Creates a new `gio.SocketConnectable` for connecting to the given
    /// `hostname` and `port`.
    ///
    /// Note that depending on the configuration of the machine, a
    /// `hostname` of `localhost` may refer to the IPv4 loopback address
    /// only, or to both IPv4 and IPv6; use
    /// `gio.NetworkAddress.newLoopback` to create a `gio.NetworkAddress` that
    /// is guaranteed to resolve to both addresses.
    extern fn g_network_address_new(p_hostname: [*:0]const u8, p_port: u16) *gio.NetworkAddress;
    pub const new = g_network_address_new;

    /// Creates a new `gio.SocketConnectable` for connecting to the local host
    /// over a loopback connection to the given `port`. This is intended for
    /// use in connecting to local services which may be running on IPv4 or
    /// IPv6.
    ///
    /// The connectable will return IPv4 and IPv6 loopback addresses,
    /// regardless of how the host resolves `localhost`. By contrast,
    /// `gio.NetworkAddress.new` will often only return an IPv4 address when
    /// resolving `localhost`, and an IPv6 address for `localhost6`.
    ///
    /// `gio.NetworkAddress.getHostname` will always return `localhost` for
    /// a `gio.NetworkAddress` created with this constructor.
    extern fn g_network_address_new_loopback(p_port: u16) *gio.NetworkAddress;
    pub const newLoopback = g_network_address_new_loopback;

    /// Gets `addr`'s hostname. This might be either UTF-8 or ASCII-encoded,
    /// depending on what `addr` was created with.
    extern fn g_network_address_get_hostname(p_addr: *NetworkAddress) [*:0]const u8;
    pub const getHostname = g_network_address_get_hostname;

    /// Gets `addr`'s port number
    extern fn g_network_address_get_port(p_addr: *NetworkAddress) u16;
    pub const getPort = g_network_address_get_port;

    /// Gets `addr`'s scheme
    extern fn g_network_address_get_scheme(p_addr: *NetworkAddress) ?[*:0]const u8;
    pub const getScheme = g_network_address_get_scheme;

    extern fn g_network_address_get_type() usize;
    pub const getGObjectType = g_network_address_get_type;

    extern fn g_object_ref(p_self: *gio.NetworkAddress) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.NetworkAddress) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *NetworkAddress, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Like `gio.NetworkAddress` does with hostnames, `GNetworkService`
/// provides an easy way to resolve a SRV record, and then attempt to
/// connect to one of the hosts that implements that service, handling
/// service priority/weighting, multiple IP addresses, and multiple
/// address families.
///
/// See `gio.SrvTarget` for more information about SRV records, and see
/// `gio.SocketConnectable` for an example of using the connectable
/// interface.
pub const NetworkService = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.SocketConnectable};
    pub const Class = gio.NetworkServiceClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.NetworkServicePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Network domain, for example `example.com`.
        pub const domain = struct {
            pub const name = "domain";

            pub const Type = ?[*:0]u8;
        };

        /// Network protocol, for example `tcp`.
        pub const protocol = struct {
            pub const name = "protocol";

            pub const Type = ?[*:0]u8;
        };

        /// Network scheme (default is to use service).
        pub const scheme = struct {
            pub const name = "scheme";

            pub const Type = ?[*:0]u8;
        };

        /// Service name, for example `ldap`.
        pub const service = struct {
            pub const name = "service";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.NetworkService` representing the given `service`,
    /// `protocol`, and `domain`. This will initially be unresolved; use the
    /// `gio.SocketConnectable` interface to resolve it.
    extern fn g_network_service_new(p_service: [*:0]const u8, p_protocol: [*:0]const u8, p_domain: [*:0]const u8) *gio.NetworkService;
    pub const new = g_network_service_new;

    /// Gets the domain that `srv` serves. This might be either UTF-8 or
    /// ASCII-encoded, depending on what `srv` was created with.
    extern fn g_network_service_get_domain(p_srv: *NetworkService) [*:0]const u8;
    pub const getDomain = g_network_service_get_domain;

    /// Gets `srv`'s protocol name (eg, "tcp").
    extern fn g_network_service_get_protocol(p_srv: *NetworkService) [*:0]const u8;
    pub const getProtocol = g_network_service_get_protocol;

    /// Gets the URI scheme used to resolve proxies. By default, the service name
    /// is used as scheme.
    extern fn g_network_service_get_scheme(p_srv: *NetworkService) [*:0]const u8;
    pub const getScheme = g_network_service_get_scheme;

    /// Gets `srv`'s service name (eg, "ldap").
    extern fn g_network_service_get_service(p_srv: *NetworkService) [*:0]const u8;
    pub const getService = g_network_service_get_service;

    /// Set's the URI scheme used to resolve proxies. By default, the service name
    /// is used as scheme.
    extern fn g_network_service_set_scheme(p_srv: *NetworkService, p_scheme: [*:0]const u8) void;
    pub const setScheme = g_network_service_set_scheme;

    extern fn g_network_service_get_type() usize;
    pub const getGObjectType = g_network_service_get_type;

    extern fn g_object_ref(p_self: *gio.NetworkService) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.NetworkService) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *NetworkService, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GNotification` is a mechanism for creating a notification to be shown
/// to the user — typically as a pop-up notification presented by the
/// desktop environment shell.
///
/// The key difference between `GNotification` and other similar APIs is
/// that, if supported by the desktop environment, notifications sent
/// with `GNotification` will persist after the application has exited,
/// and even across system reboots.
///
/// Since the user may click on a notification while the application is
/// not running, applications using `GNotification` should be able to be
/// started as a D-Bus service, using `gio.Application`.
///
/// In order for `GNotification` to work, the application must have installed
/// a `.desktop` file. For example:
/// ```
/// [Desktop Entry]
/// Name=Test Application
/// Comment=Description of what Test Application does
/// Exec=gnome-test-application
/// Icon=org.gnome.TestApplication
/// Terminal=false
/// Type=Application
/// Categories=GNOME;GTK;TestApplication Category;
/// StartupNotify=true
/// DBusActivatable=true
/// X-GNOME-UsesNotifications=true
/// ```
///
/// The `X-GNOME-UsesNotifications` key indicates to GNOME Control Center
/// that this application uses notifications, so it can be listed in the
/// Control Center’s ‘Notifications’ panel.
///
/// The `.desktop` file must be named as `org.gnome.TestApplication.desktop`,
/// where `org.gnome.TestApplication` is the ID passed to
/// `gio.Application.new`.
///
/// User interaction with a notification (either the default action, or
/// buttons) must be associated with actions on the application (ie:
/// `app.` actions).  It is not possible to route user interaction
/// through the notification itself, because the object will not exist if
/// the application is autostarted as a result of a notification being
/// clicked.
///
/// A notification can be sent with `gio.Application.sendNotification`.
pub const Notification = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = Notification;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gio.Notification` with `title` as its title.
    ///
    /// After populating `notification` with more details, it can be sent to
    /// the desktop shell with `gio.Application.sendNotification`. Changing
    /// any properties after this call will not have any effect until
    /// resending `notification`.
    extern fn g_notification_new(p_title: [*:0]const u8) *gio.Notification;
    pub const new = g_notification_new;

    /// Adds a button to `notification` that activates the action in
    /// `detailed_action` when clicked. That action must be an
    /// application-wide action (starting with "app."). If `detailed_action`
    /// contains a target, the action will be activated with that target as
    /// its parameter.
    ///
    /// See `gio.actionParseDetailedName` for a description of the format
    /// for `detailed_action`.
    extern fn g_notification_add_button(p_notification: *Notification, p_label: [*:0]const u8, p_detailed_action: [*:0]const u8) void;
    pub const addButton = g_notification_add_button;

    /// Adds a button to `notification` that activates `action` when clicked.
    /// `action` must be an application-wide action (it must start with "app.").
    ///
    /// If `target_format` is given, it is used to collect remaining
    /// positional parameters into a `glib.Variant` instance, similar to
    /// `glib.Variant.new`. `action` will be activated with that `glib.Variant` as its
    /// parameter.
    extern fn g_notification_add_button_with_target(p_notification: *Notification, p_label: [*:0]const u8, p_action: [*:0]const u8, p_target_format: ?[*:0]const u8, ...) void;
    pub const addButtonWithTarget = g_notification_add_button_with_target;

    /// Adds a button to `notification` that activates `action` when clicked.
    /// `action` must be an application-wide action (it must start with "app.").
    ///
    /// If `target` is non-`NULL`, `action` will be activated with `target` as
    /// its parameter.
    extern fn g_notification_add_button_with_target_value(p_notification: *Notification, p_label: [*:0]const u8, p_action: [*:0]const u8, p_target: ?*glib.Variant) void;
    pub const addButtonWithTargetValue = g_notification_add_button_with_target_value;

    /// Sets the body of `notification` to `body`.
    extern fn g_notification_set_body(p_notification: *Notification, p_body: ?[*:0]const u8) void;
    pub const setBody = g_notification_set_body;

    /// Sets the type of `notification` to `category`. Categories have a main
    /// type like `email`, `im` or `device` and can have a detail separated
    /// by a `.`, e.g. `im.received` or `email.arrived`. Setting the category
    /// helps the notification server to select proper feedback to the user.
    ///
    /// Standard categories are [listed in the specification](https://specifications.freedesktop.org/notification-spec/latest/ar01s06.html).
    extern fn g_notification_set_category(p_notification: *Notification, p_category: ?[*:0]const u8) void;
    pub const setCategory = g_notification_set_category;

    /// Sets the default action of `notification` to `detailed_action`. This
    /// action is activated when the notification is clicked on.
    ///
    /// The action in `detailed_action` must be an application-wide action (it
    /// must start with "app."). If `detailed_action` contains a target, the
    /// given action will be activated with that target as its parameter.
    /// See `gio.actionParseDetailedName` for a description of the format
    /// for `detailed_action`.
    ///
    /// When no default action is set, the application that the notification
    /// was sent on is activated.
    extern fn g_notification_set_default_action(p_notification: *Notification, p_detailed_action: [*:0]const u8) void;
    pub const setDefaultAction = g_notification_set_default_action;

    /// Sets the default action of `notification` to `action`. This action is
    /// activated when the notification is clicked on. It must be an
    /// application-wide action (it must start with "app.").
    ///
    /// If `target_format` is given, it is used to collect remaining
    /// positional parameters into a `glib.Variant` instance, similar to
    /// `glib.Variant.new`. `action` will be activated with that `glib.Variant` as its
    /// parameter.
    ///
    /// When no default action is set, the application that the notification
    /// was sent on is activated.
    extern fn g_notification_set_default_action_and_target(p_notification: *Notification, p_action: [*:0]const u8, p_target_format: ?[*:0]const u8, ...) void;
    pub const setDefaultActionAndTarget = g_notification_set_default_action_and_target;

    /// Sets the default action of `notification` to `action`. This action is
    /// activated when the notification is clicked on. It must be an
    /// application-wide action (start with "app.").
    ///
    /// If `target` is non-`NULL`, `action` will be activated with `target` as
    /// its parameter. If `target` is floating, it will be consumed.
    ///
    /// When no default action is set, the application that the notification
    /// was sent on is activated.
    extern fn g_notification_set_default_action_and_target_value(p_notification: *Notification, p_action: [*:0]const u8, p_target: ?*glib.Variant) void;
    pub const setDefaultActionAndTargetValue = g_notification_set_default_action_and_target_value;

    /// Sets the icon of `notification` to `icon`.
    extern fn g_notification_set_icon(p_notification: *Notification, p_icon: *gio.Icon) void;
    pub const setIcon = g_notification_set_icon;

    /// Sets the priority of `notification` to `priority`. See
    /// `gio.NotificationPriority` for possible values.
    extern fn g_notification_set_priority(p_notification: *Notification, p_priority: gio.NotificationPriority) void;
    pub const setPriority = g_notification_set_priority;

    /// Sets the title of `notification` to `title`.
    extern fn g_notification_set_title(p_notification: *Notification, p_title: [*:0]const u8) void;
    pub const setTitle = g_notification_set_title;

    /// Deprecated in favor of `gio.Notification.setPriority`.
    extern fn g_notification_set_urgent(p_notification: *Notification, p_urgent: c_int) void;
    pub const setUrgent = g_notification_set_urgent;

    extern fn g_notification_get_type() usize;
    pub const getGObjectType = g_notification_get_type;

    extern fn g_object_ref(p_self: *gio.Notification) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Notification) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Notification, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GOutputStream` is a base class for implementing streaming output.
///
/// It has functions to write to a stream (`gio.OutputStream.write`),
/// to close a stream (`gio.OutputStream.close`) and to flush pending
/// writes (`gio.OutputStream.flush`).
///
/// To copy the content of an input stream to an output stream without
/// manually handling the reads and writes, use `gio.OutputStream.splice`.
///
/// See the documentation for `gio.IOStream` for details of thread safety
/// of streaming APIs.
///
/// All of these functions have async variants too.
///
/// All classes derived from `GOutputStream` *should* implement synchronous
/// writing, splicing, flushing and closing streams, but *may* implement
/// asynchronous versions.
pub const OutputStream = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.OutputStreamClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.OutputStreamPrivate,

    pub const virtual_methods = struct {
        /// Requests an asynchronous close of the stream, releasing resources
        /// related to it. When the operation is finished `callback` will be
        /// called. You can then call `gio.OutputStream.closeFinish` to get
        /// the result of the operation.
        ///
        /// For behaviour details see `gio.OutputStream.close`.
        ///
        /// The asynchronous methods have a default fallback that uses threads
        /// to implement asynchronicity, so they are optional for inheriting
        /// classes. However, if you override one you must override all.
        pub const close_async = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(OutputStream.Class, p_class).f_close_async.?(gobject.ext.as(OutputStream, p_stream), p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(OutputStream.Class, p_class).f_close_async = @ptrCast(p_implementation);
            }
        };

        /// Closes an output stream.
        pub const close_finish = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(OutputStream.Class, p_class).f_close_finish.?(gobject.ext.as(OutputStream, p_stream), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(OutputStream.Class, p_class).f_close_finish = @ptrCast(p_implementation);
            }
        };

        pub const close_fn = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(OutputStream.Class, p_class).f_close_fn.?(gobject.ext.as(OutputStream, p_stream), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(OutputStream.Class, p_class).f_close_fn = @ptrCast(p_implementation);
            }
        };

        /// Forces a write of all user-space buffered data for the given
        /// `stream`. Will block during the operation. Closing the stream will
        /// implicitly cause a flush.
        ///
        /// This function is optional for inherited classes.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        pub const flush = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(OutputStream.Class, p_class).f_flush.?(gobject.ext.as(OutputStream, p_stream), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(OutputStream.Class, p_class).f_flush = @ptrCast(p_implementation);
            }
        };

        /// Forces an asynchronous write of all user-space buffered data for
        /// the given `stream`.
        /// For behaviour details see `gio.OutputStream.flush`.
        ///
        /// When the operation is finished `callback` will be
        /// called. You can then call `gio.OutputStream.flushFinish` to get the
        /// result of the operation.
        pub const flush_async = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(OutputStream.Class, p_class).f_flush_async.?(gobject.ext.as(OutputStream, p_stream), p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(OutputStream.Class, p_class).f_flush_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes flushing an output stream.
        pub const flush_finish = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(OutputStream.Class, p_class).f_flush_finish.?(gobject.ext.as(OutputStream, p_stream), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(OutputStream.Class, p_class).f_flush_finish = @ptrCast(p_implementation);
            }
        };

        /// Splices an input stream into an output stream.
        pub const splice = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_source: *gio.InputStream, p_flags: gio.OutputStreamSpliceFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize {
                return gobject.ext.as(OutputStream.Class, p_class).f_splice.?(gobject.ext.as(OutputStream, p_stream), p_source, p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_source: *gio.InputStream, p_flags: gio.OutputStreamSpliceFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) isize) void {
                gobject.ext.as(OutputStream.Class, p_class).f_splice = @ptrCast(p_implementation);
            }
        };

        /// Splices a stream asynchronously.
        /// When the operation is finished `callback` will be called.
        /// You can then call `gio.OutputStream.spliceFinish` to get the
        /// result of the operation.
        ///
        /// For the synchronous, blocking version of this function, see
        /// `gio.OutputStream.splice`.
        pub const splice_async = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_source: *gio.InputStream, p_flags: gio.OutputStreamSpliceFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(OutputStream.Class, p_class).f_splice_async.?(gobject.ext.as(OutputStream, p_stream), p_source, p_flags, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_source: *gio.InputStream, p_flags: gio.OutputStreamSpliceFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(OutputStream.Class, p_class).f_splice_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous stream splice operation.
        pub const splice_finish = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) isize {
                return gobject.ext.as(OutputStream.Class, p_class).f_splice_finish.?(gobject.ext.as(OutputStream, p_stream), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) isize) void {
                gobject.ext.as(OutputStream.Class, p_class).f_splice_finish = @ptrCast(p_implementation);
            }
        };

        /// Request an asynchronous write of `count` bytes from `buffer` into
        /// the stream. When the operation is finished `callback` will be called.
        /// You can then call `gio.OutputStream.writeFinish` to get the result of the
        /// operation.
        ///
        /// During an async request no other sync and async calls are allowed,
        /// and will result in `G_IO_ERROR_PENDING` errors.
        ///
        /// A value of `count` larger than `G_MAXSSIZE` will cause a
        /// `G_IO_ERROR_INVALID_ARGUMENT` error.
        ///
        /// On success, the number of bytes written will be passed to the
        /// `callback`. It is not an error if this is not the same as the
        /// requested size, as it can happen e.g. on a partial I/O error,
        /// but generally we try to write as many bytes as requested.
        ///
        /// You are guaranteed that this method will never fail with
        /// `G_IO_ERROR_WOULD_BLOCK` - if `stream` can't accept more data, the
        /// method will just wait until this changes.
        ///
        /// Any outstanding I/O request with higher priority (lower numerical
        /// value) will be executed before an outstanding request with lower
        /// priority. Default priority is `G_PRIORITY_DEFAULT`.
        ///
        /// The asynchronous methods have a default fallback that uses threads
        /// to implement asynchronicity, so they are optional for inheriting
        /// classes. However, if you override one you must override all.
        ///
        /// For the synchronous, blocking version of this function, see
        /// `gio.OutputStream.write`.
        ///
        /// Note that no copy of `buffer` will be made, so it must stay valid
        /// until `callback` is called. See `gio.OutputStream.writeBytesAsync`
        /// for a `glib.Bytes` version that will automatically hold a reference to
        /// the contents (without copying) for the duration of the call.
        pub const write_async = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_buffer: ?[*]u8, p_count: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(OutputStream.Class, p_class).f_write_async.?(gobject.ext.as(OutputStream, p_stream), p_buffer, p_count, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_buffer: ?[*]u8, p_count: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(OutputStream.Class, p_class).f_write_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes a stream write operation.
        pub const write_finish = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) isize {
                return gobject.ext.as(OutputStream.Class, p_class).f_write_finish.?(gobject.ext.as(OutputStream, p_stream), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) isize) void {
                gobject.ext.as(OutputStream.Class, p_class).f_write_finish = @ptrCast(p_implementation);
            }
        };

        /// Tries to write `count` bytes from `buffer` into the stream. Will block
        /// during the operation.
        ///
        /// If count is 0, returns 0 and does nothing. A value of `count`
        /// larger than `G_MAXSSIZE` will cause a `G_IO_ERROR_INVALID_ARGUMENT` error.
        ///
        /// On success, the number of bytes written to the stream is returned.
        /// It is not an error if this is not the same as the requested size, as it
        /// can happen e.g. on a partial I/O error, or if there is not enough
        /// storage in the stream. All writes block until at least one byte
        /// is written or an error occurs; 0 is never returned (unless
        /// `count` is 0).
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned. If an
        /// operation was partially finished when the operation was cancelled the
        /// partial result will be returned, without an error.
        ///
        /// On error -1 is returned and `error` is set accordingly.
        pub const write_fn = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_buffer: ?[*]u8, p_count: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize {
                return gobject.ext.as(OutputStream.Class, p_class).f_write_fn.?(gobject.ext.as(OutputStream, p_stream), p_buffer, p_count, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_buffer: ?[*]u8, p_count: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) isize) void {
                gobject.ext.as(OutputStream.Class, p_class).f_write_fn = @ptrCast(p_implementation);
            }
        };

        /// Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
        /// the stream. When the operation is finished `callback` will be called.
        /// You can then call `gio.OutputStream.writevFinish` to get the result of the
        /// operation.
        ///
        /// During an async request no other sync and async calls are allowed,
        /// and will result in `G_IO_ERROR_PENDING` errors.
        ///
        /// On success, the number of bytes written will be passed to the
        /// `callback`. It is not an error if this is not the same as the
        /// requested size, as it can happen e.g. on a partial I/O error,
        /// but generally we try to write as many bytes as requested.
        ///
        /// You are guaranteed that this method will never fail with
        /// `G_IO_ERROR_WOULD_BLOCK` — if `stream` can't accept more data, the
        /// method will just wait until this changes.
        ///
        /// Any outstanding I/O request with higher priority (lower numerical
        /// value) will be executed before an outstanding request with lower
        /// priority. Default priority is `G_PRIORITY_DEFAULT`.
        ///
        /// The asynchronous methods have a default fallback that uses threads
        /// to implement asynchronicity, so they are optional for inheriting
        /// classes. However, if you override one you must override all.
        ///
        /// For the synchronous, blocking version of this function, see
        /// `gio.OutputStream.writev`.
        ///
        /// Note that no copy of `vectors` will be made, so it must stay valid
        /// until `callback` is called.
        pub const writev_async = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_vectors: [*]const gio.OutputVector, p_n_vectors: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(OutputStream.Class, p_class).f_writev_async.?(gobject.ext.as(OutputStream, p_stream), p_vectors, p_n_vectors, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_vectors: [*]const gio.OutputVector, p_n_vectors: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(OutputStream.Class, p_class).f_writev_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes a stream writev operation.
        pub const writev_finish = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_bytes_written: ?*usize, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(OutputStream.Class, p_class).f_writev_finish.?(gobject.ext.as(OutputStream, p_stream), p_result, p_bytes_written, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_bytes_written: ?*usize, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(OutputStream.Class, p_class).f_writev_finish = @ptrCast(p_implementation);
            }
        };

        /// Tries to write the bytes contained in the `n_vectors` `vectors` into the
        /// stream. Will block during the operation.
        ///
        /// If `n_vectors` is 0 or the sum of all bytes in `vectors` is 0, returns 0 and
        /// does nothing.
        ///
        /// On success, the number of bytes written to the stream is returned.
        /// It is not an error if this is not the same as the requested size, as it
        /// can happen e.g. on a partial I/O error, or if there is not enough
        /// storage in the stream. All writes block until at least one byte
        /// is written or an error occurs; 0 is never returned (unless
        /// `n_vectors` is 0 or the sum of all bytes in `vectors` is 0).
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned. If an
        /// operation was partially finished when the operation was cancelled the
        /// partial result will be returned, without an error.
        ///
        /// Some implementations of `gio.OutputStream.writev` may have limitations on the
        /// aggregate buffer size, and will return `G_IO_ERROR_INVALID_ARGUMENT` if these
        /// are exceeded. For example, when writing to a local file on UNIX platforms,
        /// the aggregate buffer size must not exceed `G_MAXSSIZE` bytes.
        pub const writev_fn = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_vectors: [*]const gio.OutputVector, p_n_vectors: usize, p_bytes_written: ?*usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(OutputStream.Class, p_class).f_writev_fn.?(gobject.ext.as(OutputStream, p_stream), p_vectors, p_n_vectors, p_bytes_written, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_vectors: [*]const gio.OutputVector, p_n_vectors: usize, p_bytes_written: ?*usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(OutputStream.Class, p_class).f_writev_fn = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Clears the pending flag on `stream`.
    extern fn g_output_stream_clear_pending(p_stream: *OutputStream) void;
    pub const clearPending = g_output_stream_clear_pending;

    /// Closes the stream, releasing resources related to it.
    ///
    /// Once the stream is closed, all other operations will return `G_IO_ERROR_CLOSED`.
    /// Closing a stream multiple times will not return an error.
    ///
    /// Closing a stream will automatically flush any outstanding buffers in the
    /// stream.
    ///
    /// Streams will be automatically closed when the last reference
    /// is dropped, but you might want to call this function to make sure
    /// resources are released as early as possible.
    ///
    /// Some streams might keep the backing store of the stream (e.g. a file descriptor)
    /// open after the stream is closed. See the documentation for the individual
    /// stream for details.
    ///
    /// On failure the first error that happened will be reported, but the close
    /// operation will finish as much as possible. A stream that failed to
    /// close will still return `G_IO_ERROR_CLOSED` for all operations. Still, it
    /// is important to check and report the error to the user, otherwise
    /// there might be a loss of data as all data might not be written.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    /// Cancelling a close will still leave the stream closed, but there some streams
    /// can use a faster close that doesn't block to e.g. check errors. On
    /// cancellation (as with any error) there is no guarantee that all written
    /// data will reach the target.
    extern fn g_output_stream_close(p_stream: *OutputStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const close = g_output_stream_close;

    /// Requests an asynchronous close of the stream, releasing resources
    /// related to it. When the operation is finished `callback` will be
    /// called. You can then call `gio.OutputStream.closeFinish` to get
    /// the result of the operation.
    ///
    /// For behaviour details see `gio.OutputStream.close`.
    ///
    /// The asynchronous methods have a default fallback that uses threads
    /// to implement asynchronicity, so they are optional for inheriting
    /// classes. However, if you override one you must override all.
    extern fn g_output_stream_close_async(p_stream: *OutputStream, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const closeAsync = g_output_stream_close_async;

    /// Closes an output stream.
    extern fn g_output_stream_close_finish(p_stream: *OutputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const closeFinish = g_output_stream_close_finish;

    /// Forces a write of all user-space buffered data for the given
    /// `stream`. Will block during the operation. Closing the stream will
    /// implicitly cause a flush.
    ///
    /// This function is optional for inherited classes.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_output_stream_flush(p_stream: *OutputStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const flush = g_output_stream_flush;

    /// Forces an asynchronous write of all user-space buffered data for
    /// the given `stream`.
    /// For behaviour details see `gio.OutputStream.flush`.
    ///
    /// When the operation is finished `callback` will be
    /// called. You can then call `gio.OutputStream.flushFinish` to get the
    /// result of the operation.
    extern fn g_output_stream_flush_async(p_stream: *OutputStream, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const flushAsync = g_output_stream_flush_async;

    /// Finishes flushing an output stream.
    extern fn g_output_stream_flush_finish(p_stream: *OutputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const flushFinish = g_output_stream_flush_finish;

    /// Checks if an output stream has pending actions.
    extern fn g_output_stream_has_pending(p_stream: *OutputStream) c_int;
    pub const hasPending = g_output_stream_has_pending;

    /// Checks if an output stream has already been closed.
    extern fn g_output_stream_is_closed(p_stream: *OutputStream) c_int;
    pub const isClosed = g_output_stream_is_closed;

    /// Checks if an output stream is being closed. This can be
    /// used inside e.g. a flush implementation to see if the
    /// flush (or other i/o operation) is called from within
    /// the closing operation.
    extern fn g_output_stream_is_closing(p_stream: *OutputStream) c_int;
    pub const isClosing = g_output_stream_is_closing;

    /// This is a utility function around `gio.OutputStream.writeAll`. It
    /// uses `glib.strdupVprintf` to turn `format` and @... into a string that
    /// is then written to `stream`.
    ///
    /// See the documentation of `gio.OutputStream.writeAll` about the
    /// behavior of the actual write operation.
    ///
    /// Note that partial writes cannot be properly checked with this
    /// function due to the variable length of the written string, if you
    /// need precise control over partial write failures, you need to
    /// create you own `printf`-like wrapper around `gio.OutputStream.write`
    /// or `gio.OutputStream.writeAll`.
    extern fn g_output_stream_printf(p_stream: *OutputStream, p_bytes_written: ?*usize, p_cancellable: ?*gio.Cancellable, p_error: **glib.Error, p_format: [*:0]const u8, ...) c_int;
    pub const printf = g_output_stream_printf;

    /// Sets `stream` to have actions pending. If the pending flag is
    /// already set or `stream` is closed, it will return `FALSE` and set
    /// `error`.
    extern fn g_output_stream_set_pending(p_stream: *OutputStream, p_error: ?*?*glib.Error) c_int;
    pub const setPending = g_output_stream_set_pending;

    /// Splices an input stream into an output stream.
    extern fn g_output_stream_splice(p_stream: *OutputStream, p_source: *gio.InputStream, p_flags: gio.OutputStreamSpliceFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const splice = g_output_stream_splice;

    /// Splices a stream asynchronously.
    /// When the operation is finished `callback` will be called.
    /// You can then call `gio.OutputStream.spliceFinish` to get the
    /// result of the operation.
    ///
    /// For the synchronous, blocking version of this function, see
    /// `gio.OutputStream.splice`.
    extern fn g_output_stream_splice_async(p_stream: *OutputStream, p_source: *gio.InputStream, p_flags: gio.OutputStreamSpliceFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const spliceAsync = g_output_stream_splice_async;

    /// Finishes an asynchronous stream splice operation.
    extern fn g_output_stream_splice_finish(p_stream: *OutputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) isize;
    pub const spliceFinish = g_output_stream_splice_finish;

    /// This is a utility function around `gio.OutputStream.writeAll`. It
    /// uses `glib.strdupVprintf` to turn `format` and `args` into a string that
    /// is then written to `stream`.
    ///
    /// See the documentation of `gio.OutputStream.writeAll` about the
    /// behavior of the actual write operation.
    ///
    /// Note that partial writes cannot be properly checked with this
    /// function due to the variable length of the written string, if you
    /// need precise control over partial write failures, you need to
    /// create you own `printf`-like wrapper around `gio.OutputStream.write`
    /// or `gio.OutputStream.writeAll`.
    extern fn g_output_stream_vprintf(p_stream: *OutputStream, p_bytes_written: ?*usize, p_cancellable: ?*gio.Cancellable, p_error: **glib.Error, p_format: [*:0]const u8, p_args: std.builtin.VaList) c_int;
    pub const vprintf = g_output_stream_vprintf;

    /// Tries to write `count` bytes from `buffer` into the stream. Will block
    /// during the operation.
    ///
    /// If count is 0, returns 0 and does nothing. A value of `count`
    /// larger than `G_MAXSSIZE` will cause a `G_IO_ERROR_INVALID_ARGUMENT` error.
    ///
    /// On success, the number of bytes written to the stream is returned.
    /// It is not an error if this is not the same as the requested size, as it
    /// can happen e.g. on a partial I/O error, or if there is not enough
    /// storage in the stream. All writes block until at least one byte
    /// is written or an error occurs; 0 is never returned (unless
    /// `count` is 0).
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned. If an
    /// operation was partially finished when the operation was cancelled the
    /// partial result will be returned, without an error.
    ///
    /// On error -1 is returned and `error` is set accordingly.
    extern fn g_output_stream_write(p_stream: *OutputStream, p_buffer: [*]u8, p_count: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const write = g_output_stream_write;

    /// Tries to write `count` bytes from `buffer` into the stream. Will block
    /// during the operation.
    ///
    /// This function is similar to `gio.OutputStream.write`, except it tries to
    /// write as many bytes as requested, only stopping on an error.
    ///
    /// On a successful write of `count` bytes, `TRUE` is returned, and `bytes_written`
    /// is set to `count`.
    ///
    /// If there is an error during the operation `FALSE` is returned and `error`
    /// is set to indicate the error status.
    ///
    /// As a special exception to the normal conventions for functions that
    /// use `glib.Error`, if this function returns `FALSE` (and sets `error`) then
    /// `bytes_written` will be set to the number of bytes that were
    /// successfully written before the error was encountered.  This
    /// functionality is only available from C.  If you need it from another
    /// language then you must write your own loop around
    /// `gio.OutputStream.write`.
    extern fn g_output_stream_write_all(p_stream: *OutputStream, p_buffer: [*]u8, p_count: usize, p_bytes_written: ?*usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const writeAll = g_output_stream_write_all;

    /// Request an asynchronous write of `count` bytes from `buffer` into
    /// the stream. When the operation is finished `callback` will be called.
    /// You can then call `gio.OutputStream.writeAllFinish` to get the result of the
    /// operation.
    ///
    /// This is the asynchronous version of `gio.OutputStream.writeAll`.
    ///
    /// Call `gio.OutputStream.writeAllFinish` to collect the result.
    ///
    /// Any outstanding I/O request with higher priority (lower numerical
    /// value) will be executed before an outstanding request with lower
    /// priority. Default priority is `G_PRIORITY_DEFAULT`.
    ///
    /// Note that no copy of `buffer` will be made, so it must stay valid
    /// until `callback` is called.
    extern fn g_output_stream_write_all_async(p_stream: *OutputStream, p_buffer: [*]u8, p_count: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const writeAllAsync = g_output_stream_write_all_async;

    /// Finishes an asynchronous stream write operation started with
    /// `gio.OutputStream.writeAllAsync`.
    ///
    /// As a special exception to the normal conventions for functions that
    /// use `glib.Error`, if this function returns `FALSE` (and sets `error`) then
    /// `bytes_written` will be set to the number of bytes that were
    /// successfully written before the error was encountered.  This
    /// functionality is only available from C.  If you need it from another
    /// language then you must write your own loop around
    /// `gio.OutputStream.writeAsync`.
    extern fn g_output_stream_write_all_finish(p_stream: *OutputStream, p_result: *gio.AsyncResult, p_bytes_written: ?*usize, p_error: ?*?*glib.Error) c_int;
    pub const writeAllFinish = g_output_stream_write_all_finish;

    /// Request an asynchronous write of `count` bytes from `buffer` into
    /// the stream. When the operation is finished `callback` will be called.
    /// You can then call `gio.OutputStream.writeFinish` to get the result of the
    /// operation.
    ///
    /// During an async request no other sync and async calls are allowed,
    /// and will result in `G_IO_ERROR_PENDING` errors.
    ///
    /// A value of `count` larger than `G_MAXSSIZE` will cause a
    /// `G_IO_ERROR_INVALID_ARGUMENT` error.
    ///
    /// On success, the number of bytes written will be passed to the
    /// `callback`. It is not an error if this is not the same as the
    /// requested size, as it can happen e.g. on a partial I/O error,
    /// but generally we try to write as many bytes as requested.
    ///
    /// You are guaranteed that this method will never fail with
    /// `G_IO_ERROR_WOULD_BLOCK` - if `stream` can't accept more data, the
    /// method will just wait until this changes.
    ///
    /// Any outstanding I/O request with higher priority (lower numerical
    /// value) will be executed before an outstanding request with lower
    /// priority. Default priority is `G_PRIORITY_DEFAULT`.
    ///
    /// The asynchronous methods have a default fallback that uses threads
    /// to implement asynchronicity, so they are optional for inheriting
    /// classes. However, if you override one you must override all.
    ///
    /// For the synchronous, blocking version of this function, see
    /// `gio.OutputStream.write`.
    ///
    /// Note that no copy of `buffer` will be made, so it must stay valid
    /// until `callback` is called. See `gio.OutputStream.writeBytesAsync`
    /// for a `glib.Bytes` version that will automatically hold a reference to
    /// the contents (without copying) for the duration of the call.
    extern fn g_output_stream_write_async(p_stream: *OutputStream, p_buffer: [*]u8, p_count: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const writeAsync = g_output_stream_write_async;

    /// A wrapper function for `gio.OutputStream.write` which takes a
    /// `glib.Bytes` as input.  This can be more convenient for use by language
    /// bindings or in other cases where the refcounted nature of `glib.Bytes`
    /// is helpful over a bare pointer interface.
    ///
    /// However, note that this function may still perform partial writes,
    /// just like `gio.OutputStream.write`.  If that occurs, to continue
    /// writing, you will need to create a new `glib.Bytes` containing just the
    /// remaining bytes, using `glib.Bytes.newFromBytes`. Passing the same
    /// `glib.Bytes` instance multiple times potentially can result in duplicated
    /// data in the output stream.
    extern fn g_output_stream_write_bytes(p_stream: *OutputStream, p_bytes: *glib.Bytes, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const writeBytes = g_output_stream_write_bytes;

    /// This function is similar to `gio.OutputStream.writeAsync`, but
    /// takes a `glib.Bytes` as input.  Due to the refcounted nature of `glib.Bytes`,
    /// this allows the stream to avoid taking a copy of the data.
    ///
    /// However, note that this function may still perform partial writes,
    /// just like `gio.OutputStream.writeAsync`. If that occurs, to continue
    /// writing, you will need to create a new `glib.Bytes` containing just the
    /// remaining bytes, using `glib.Bytes.newFromBytes`. Passing the same
    /// `glib.Bytes` instance multiple times potentially can result in duplicated
    /// data in the output stream.
    ///
    /// For the synchronous, blocking version of this function, see
    /// `gio.OutputStream.writeBytes`.
    extern fn g_output_stream_write_bytes_async(p_stream: *OutputStream, p_bytes: *glib.Bytes, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const writeBytesAsync = g_output_stream_write_bytes_async;

    /// Finishes a stream write-from-`glib.Bytes` operation.
    extern fn g_output_stream_write_bytes_finish(p_stream: *OutputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) isize;
    pub const writeBytesFinish = g_output_stream_write_bytes_finish;

    /// Finishes a stream write operation.
    extern fn g_output_stream_write_finish(p_stream: *OutputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) isize;
    pub const writeFinish = g_output_stream_write_finish;

    /// Tries to write the bytes contained in the `n_vectors` `vectors` into the
    /// stream. Will block during the operation.
    ///
    /// If `n_vectors` is 0 or the sum of all bytes in `vectors` is 0, returns 0 and
    /// does nothing.
    ///
    /// On success, the number of bytes written to the stream is returned.
    /// It is not an error if this is not the same as the requested size, as it
    /// can happen e.g. on a partial I/O error, or if there is not enough
    /// storage in the stream. All writes block until at least one byte
    /// is written or an error occurs; 0 is never returned (unless
    /// `n_vectors` is 0 or the sum of all bytes in `vectors` is 0).
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned. If an
    /// operation was partially finished when the operation was cancelled the
    /// partial result will be returned, without an error.
    ///
    /// Some implementations of `gio.OutputStream.writev` may have limitations on the
    /// aggregate buffer size, and will return `G_IO_ERROR_INVALID_ARGUMENT` if these
    /// are exceeded. For example, when writing to a local file on UNIX platforms,
    /// the aggregate buffer size must not exceed `G_MAXSSIZE` bytes.
    extern fn g_output_stream_writev(p_stream: *OutputStream, p_vectors: [*]const gio.OutputVector, p_n_vectors: usize, p_bytes_written: ?*usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const writev = g_output_stream_writev;

    /// Tries to write the bytes contained in the `n_vectors` `vectors` into the
    /// stream. Will block during the operation.
    ///
    /// This function is similar to `gio.OutputStream.writev`, except it tries to
    /// write as many bytes as requested, only stopping on an error.
    ///
    /// On a successful write of all `n_vectors` vectors, `TRUE` is returned, and
    /// `bytes_written` is set to the sum of all the sizes of `vectors`.
    ///
    /// If there is an error during the operation `FALSE` is returned and `error`
    /// is set to indicate the error status.
    ///
    /// As a special exception to the normal conventions for functions that
    /// use `glib.Error`, if this function returns `FALSE` (and sets `error`) then
    /// `bytes_written` will be set to the number of bytes that were
    /// successfully written before the error was encountered.  This
    /// functionality is only available from C. If you need it from another
    /// language then you must write your own loop around
    /// `gio.OutputStream.write`.
    ///
    /// The content of the individual elements of `vectors` might be changed by this
    /// function.
    extern fn g_output_stream_writev_all(p_stream: *OutputStream, p_vectors: [*]gio.OutputVector, p_n_vectors: usize, p_bytes_written: ?*usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const writevAll = g_output_stream_writev_all;

    /// Request an asynchronous write of the bytes contained in the `n_vectors` `vectors` into
    /// the stream. When the operation is finished `callback` will be called.
    /// You can then call `gio.OutputStream.writevAllFinish` to get the result of the
    /// operation.
    ///
    /// This is the asynchronous version of `gio.OutputStream.writevAll`.
    ///
    /// Call `gio.OutputStream.writevAllFinish` to collect the result.
    ///
    /// Any outstanding I/O request with higher priority (lower numerical
    /// value) will be executed before an outstanding request with lower
    /// priority. Default priority is `G_PRIORITY_DEFAULT`.
    ///
    /// Note that no copy of `vectors` will be made, so it must stay valid
    /// until `callback` is called. The content of the individual elements
    /// of `vectors` might be changed by this function.
    extern fn g_output_stream_writev_all_async(p_stream: *OutputStream, p_vectors: [*]gio.OutputVector, p_n_vectors: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const writevAllAsync = g_output_stream_writev_all_async;

    /// Finishes an asynchronous stream write operation started with
    /// `gio.OutputStream.writevAllAsync`.
    ///
    /// As a special exception to the normal conventions for functions that
    /// use `glib.Error`, if this function returns `FALSE` (and sets `error`) then
    /// `bytes_written` will be set to the number of bytes that were
    /// successfully written before the error was encountered.  This
    /// functionality is only available from C.  If you need it from another
    /// language then you must write your own loop around
    /// `gio.OutputStream.writevAsync`.
    extern fn g_output_stream_writev_all_finish(p_stream: *OutputStream, p_result: *gio.AsyncResult, p_bytes_written: ?*usize, p_error: ?*?*glib.Error) c_int;
    pub const writevAllFinish = g_output_stream_writev_all_finish;

    /// Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
    /// the stream. When the operation is finished `callback` will be called.
    /// You can then call `gio.OutputStream.writevFinish` to get the result of the
    /// operation.
    ///
    /// During an async request no other sync and async calls are allowed,
    /// and will result in `G_IO_ERROR_PENDING` errors.
    ///
    /// On success, the number of bytes written will be passed to the
    /// `callback`. It is not an error if this is not the same as the
    /// requested size, as it can happen e.g. on a partial I/O error,
    /// but generally we try to write as many bytes as requested.
    ///
    /// You are guaranteed that this method will never fail with
    /// `G_IO_ERROR_WOULD_BLOCK` — if `stream` can't accept more data, the
    /// method will just wait until this changes.
    ///
    /// Any outstanding I/O request with higher priority (lower numerical
    /// value) will be executed before an outstanding request with lower
    /// priority. Default priority is `G_PRIORITY_DEFAULT`.
    ///
    /// The asynchronous methods have a default fallback that uses threads
    /// to implement asynchronicity, so they are optional for inheriting
    /// classes. However, if you override one you must override all.
    ///
    /// For the synchronous, blocking version of this function, see
    /// `gio.OutputStream.writev`.
    ///
    /// Note that no copy of `vectors` will be made, so it must stay valid
    /// until `callback` is called.
    extern fn g_output_stream_writev_async(p_stream: *OutputStream, p_vectors: [*]const gio.OutputVector, p_n_vectors: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const writevAsync = g_output_stream_writev_async;

    /// Finishes a stream writev operation.
    extern fn g_output_stream_writev_finish(p_stream: *OutputStream, p_result: *gio.AsyncResult, p_bytes_written: ?*usize, p_error: ?*?*glib.Error) c_int;
    pub const writevFinish = g_output_stream_writev_finish;

    extern fn g_output_stream_get_type() usize;
    pub const getGObjectType = g_output_stream_get_type;

    extern fn g_object_ref(p_self: *gio.OutputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.OutputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *OutputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `GPermission` represents the status of the caller’s permission to
/// perform a certain action.
///
/// You can query if the action is currently allowed and if it is
/// possible to acquire the permission so that the action will be allowed
/// in the future.
///
/// There is also an API to actually acquire the permission and one to
/// release it.
///
/// As an example, a `GPermission` might represent the ability for the
/// user to write to a `gio.Settings` object.  This `GPermission` object
/// could then be used to decide if it is appropriate to show a “Click here to
/// unlock” button in a dialog and to provide the mechanism to invoke
/// when that button is clicked.
pub const Permission = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.PermissionClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.PermissionPrivate,

    pub const virtual_methods = struct {
        /// Attempts to acquire the permission represented by `permission`.
        ///
        /// The precise method by which this happens depends on the permission
        /// and the underlying authentication mechanism.  A simple example is
        /// that a dialog may appear asking the user to enter their password.
        ///
        /// You should check with `gio.Permission.getCanAcquire` before calling
        /// this function.
        ///
        /// If the permission is acquired then `TRUE` is returned.  Otherwise,
        /// `FALSE` is returned and `error` is set appropriately.
        ///
        /// This call is blocking, likely for a very long time (in the case that
        /// user interaction is required).  See `gio.Permission.acquireAsync` for
        /// the non-blocking version.
        pub const acquire = struct {
            pub fn call(p_class: anytype, p_permission: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Permission.Class, p_class).f_acquire.?(gobject.ext.as(Permission, p_permission), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_permission: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Permission.Class, p_class).f_acquire = @ptrCast(p_implementation);
            }
        };

        /// Attempts to acquire the permission represented by `permission`.
        ///
        /// This is the first half of the asynchronous version of
        /// `gio.Permission.acquire`.
        pub const acquire_async = struct {
            pub fn call(p_class: anytype, p_permission: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Permission.Class, p_class).f_acquire_async.?(gobject.ext.as(Permission, p_permission), p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_permission: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Permission.Class, p_class).f_acquire_async = @ptrCast(p_implementation);
            }
        };

        /// Collects the result of attempting to acquire the permission
        /// represented by `permission`.
        ///
        /// This is the second half of the asynchronous version of
        /// `gio.Permission.acquire`.
        pub const acquire_finish = struct {
            pub fn call(p_class: anytype, p_permission: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Permission.Class, p_class).f_acquire_finish.?(gobject.ext.as(Permission, p_permission), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_permission: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Permission.Class, p_class).f_acquire_finish = @ptrCast(p_implementation);
            }
        };

        /// Attempts to release the permission represented by `permission`.
        ///
        /// The precise method by which this happens depends on the permission
        /// and the underlying authentication mechanism.  In most cases the
        /// permission will be dropped immediately without further action.
        ///
        /// You should check with `gio.Permission.getCanRelease` before calling
        /// this function.
        ///
        /// If the permission is released then `TRUE` is returned.  Otherwise,
        /// `FALSE` is returned and `error` is set appropriately.
        ///
        /// This call is blocking, likely for a very long time (in the case that
        /// user interaction is required).  See `gio.Permission.releaseAsync` for
        /// the non-blocking version.
        pub const release = struct {
            pub fn call(p_class: anytype, p_permission: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Permission.Class, p_class).f_release.?(gobject.ext.as(Permission, p_permission), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_permission: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Permission.Class, p_class).f_release = @ptrCast(p_implementation);
            }
        };

        /// Attempts to release the permission represented by `permission`.
        ///
        /// This is the first half of the asynchronous version of
        /// `gio.Permission.release`.
        pub const release_async = struct {
            pub fn call(p_class: anytype, p_permission: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Permission.Class, p_class).f_release_async.?(gobject.ext.as(Permission, p_permission), p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_permission: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Permission.Class, p_class).f_release_async = @ptrCast(p_implementation);
            }
        };

        /// Collects the result of attempting to release the permission
        /// represented by `permission`.
        ///
        /// This is the second half of the asynchronous version of
        /// `gio.Permission.release`.
        pub const release_finish = struct {
            pub fn call(p_class: anytype, p_permission: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Permission.Class, p_class).f_release_finish.?(gobject.ext.as(Permission, p_permission), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_permission: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Permission.Class, p_class).f_release_finish = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// `TRUE` if the caller currently has permission to perform the action that
        /// `permission` represents the permission to perform.
        pub const allowed = struct {
            pub const name = "allowed";

            pub const Type = c_int;
        };

        /// `TRUE` if it is generally possible to acquire the permission by calling
        /// `gio.Permission.acquire`.
        pub const can_acquire = struct {
            pub const name = "can-acquire";

            pub const Type = c_int;
        };

        /// `TRUE` if it is generally possible to release the permission by calling
        /// `gio.Permission.release`.
        pub const can_release = struct {
            pub const name = "can-release";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Attempts to acquire the permission represented by `permission`.
    ///
    /// The precise method by which this happens depends on the permission
    /// and the underlying authentication mechanism.  A simple example is
    /// that a dialog may appear asking the user to enter their password.
    ///
    /// You should check with `gio.Permission.getCanAcquire` before calling
    /// this function.
    ///
    /// If the permission is acquired then `TRUE` is returned.  Otherwise,
    /// `FALSE` is returned and `error` is set appropriately.
    ///
    /// This call is blocking, likely for a very long time (in the case that
    /// user interaction is required).  See `gio.Permission.acquireAsync` for
    /// the non-blocking version.
    extern fn g_permission_acquire(p_permission: *Permission, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const acquire = g_permission_acquire;

    /// Attempts to acquire the permission represented by `permission`.
    ///
    /// This is the first half of the asynchronous version of
    /// `gio.Permission.acquire`.
    extern fn g_permission_acquire_async(p_permission: *Permission, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const acquireAsync = g_permission_acquire_async;

    /// Collects the result of attempting to acquire the permission
    /// represented by `permission`.
    ///
    /// This is the second half of the asynchronous version of
    /// `gio.Permission.acquire`.
    extern fn g_permission_acquire_finish(p_permission: *Permission, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const acquireFinish = g_permission_acquire_finish;

    /// Gets the value of the 'allowed' property.  This property is `TRUE` if
    /// the caller currently has permission to perform the action that
    /// `permission` represents the permission to perform.
    extern fn g_permission_get_allowed(p_permission: *Permission) c_int;
    pub const getAllowed = g_permission_get_allowed;

    /// Gets the value of the 'can-acquire' property.  This property is `TRUE`
    /// if it is generally possible to acquire the permission by calling
    /// `gio.Permission.acquire`.
    extern fn g_permission_get_can_acquire(p_permission: *Permission) c_int;
    pub const getCanAcquire = g_permission_get_can_acquire;

    /// Gets the value of the 'can-release' property.  This property is `TRUE`
    /// if it is generally possible to release the permission by calling
    /// `gio.Permission.release`.
    extern fn g_permission_get_can_release(p_permission: *Permission) c_int;
    pub const getCanRelease = g_permission_get_can_release;

    /// This function is called by the `gio.Permission` implementation to update
    /// the properties of the permission.  You should never call this
    /// function except from a `gio.Permission` implementation.
    ///
    /// GObject notify signals are generated, as appropriate.
    extern fn g_permission_impl_update(p_permission: *Permission, p_allowed: c_int, p_can_acquire: c_int, p_can_release: c_int) void;
    pub const implUpdate = g_permission_impl_update;

    /// Attempts to release the permission represented by `permission`.
    ///
    /// The precise method by which this happens depends on the permission
    /// and the underlying authentication mechanism.  In most cases the
    /// permission will be dropped immediately without further action.
    ///
    /// You should check with `gio.Permission.getCanRelease` before calling
    /// this function.
    ///
    /// If the permission is released then `TRUE` is returned.  Otherwise,
    /// `FALSE` is returned and `error` is set appropriately.
    ///
    /// This call is blocking, likely for a very long time (in the case that
    /// user interaction is required).  See `gio.Permission.releaseAsync` for
    /// the non-blocking version.
    extern fn g_permission_release(p_permission: *Permission, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const release = g_permission_release;

    /// Attempts to release the permission represented by `permission`.
    ///
    /// This is the first half of the asynchronous version of
    /// `gio.Permission.release`.
    extern fn g_permission_release_async(p_permission: *Permission, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const releaseAsync = g_permission_release_async;

    /// Collects the result of attempting to release the permission
    /// represented by `permission`.
    ///
    /// This is the second half of the asynchronous version of
    /// `gio.Permission.release`.
    extern fn g_permission_release_finish(p_permission: *Permission, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const releaseFinish = g_permission_release_finish;

    extern fn g_permission_get_type() usize;
    pub const getGObjectType = g_permission_get_type;

    extern fn g_object_ref(p_self: *gio.Permission) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Permission) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Permission, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `GPropertyAction` is a way to get a `gio.Action` with a state value
/// reflecting and controlling the value of a `gobject.Object` property.
///
/// The state of the action will correspond to the value of the property.
/// Changing it will change the property (assuming the requested value
/// matches the requirements as specified in the `gobject.ParamSpec`).
///
/// Only the most common types are presently supported.  Booleans are
/// mapped to booleans, strings to strings, signed/unsigned integers to
/// int32/uint32 and floats and doubles to doubles.
///
/// If the property is an enum then the state will be string-typed and
/// conversion will automatically be performed between the enum value and
/// ‘nick’ string as per the `gobject.EnumValue` table.
///
/// Flags types are not currently supported.
///
/// Properties of object types, boxed types and pointer types are not
/// supported and probably never will be.
///
/// Properties of `glib.Variant` types are not currently supported.
///
/// If the property is boolean-valued then the action will have a `NULL`
/// parameter type, and activating the action (with no parameter) will
/// toggle the value of the property.
///
/// In all other cases, the parameter type will correspond to the type of
/// the property.
///
/// The general idea here is to reduce the number of locations where a
/// particular piece of state is kept (and therefore has to be synchronised
/// between). `GPropertyAction` does not have a separate state that is kept
/// in sync with the property value — its state is the property value.
///
/// For example, it might be useful to create a `gio.Action` corresponding
/// to the `visible-child-name` property of a [`GtkStack`](https://docs.gtk.org/gtk4/class.Stack.html)
/// so that the current page can be switched from a menu.  The active radio
/// indication in the menu is then directly determined from the active page of
/// the `GtkStack`.
///
/// An anti-example would be binding the `active-id` property on a
/// [`GtkComboBox`](https://docs.gtk.org/gtk4/class.ComboBox.html). This is
/// because the state of the combo box itself is probably uninteresting and is
/// actually being used to control something else.
///
/// Another anti-example would be to bind to the `visible-child-name`
/// property of a [`GtkStack`](https://docs.gtk.org/gtk4/class.Stack.html) if
/// this value is actually stored in `gio.Settings`.  In that case, the
/// real source of the value is* `gio.Settings`.  If you want
/// a `gio.Action` to control a setting stored in `gio.Settings`,
/// see `gio.Settings.createAction` instead, and possibly combine its
/// use with `gio.Settings.bind`.
pub const PropertyAction = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.Action};
    pub const Class = opaque {
        pub const Instance = PropertyAction;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// If `action` is currently enabled.
        ///
        /// If the action is disabled then calls to `gio.Action.activate` and
        /// `gio.Action.changeState` have no effect.
        pub const enabled = struct {
            pub const name = "enabled";

            pub const Type = c_int;
        };

        /// If `TRUE`, the state of the action will be the negation of the
        /// property value, provided the property is boolean.
        pub const invert_boolean = struct {
            pub const name = "invert-boolean";

            pub const Type = c_int;
        };

        /// The name of the action.  This is mostly meaningful for identifying
        /// the action once it has been added to a `gio.ActionMap`.
        pub const name = struct {
            pub const name = "name";

            pub const Type = ?[*:0]u8;
        };

        /// The object to wrap a property on.
        ///
        /// The object must be a non-`NULL` `gobject.Object` with properties.
        pub const object = struct {
            pub const name = "object";

            pub const Type = ?*gobject.Object;
        };

        /// The type of the parameter that must be given when activating the
        /// action.
        pub const parameter_type = struct {
            pub const name = "parameter-type";

            pub const Type = ?*glib.VariantType;
        };

        /// The name of the property to wrap on the object.
        ///
        /// The property must exist on the passed-in object and it must be
        /// readable and writable (and not construct-only).
        pub const property_name = struct {
            pub const name = "property-name";

            pub const Type = ?[*:0]u8;
        };

        /// The state of the action, or `NULL` if the action is stateless.
        pub const state = struct {
            pub const name = "state";

            pub const Type = ?*glib.Variant;
        };

        /// The `glib.VariantType` of the state that the action has, or `NULL` if the
        /// action is stateless.
        pub const state_type = struct {
            pub const name = "state-type";

            pub const Type = ?*glib.VariantType;
        };
    };

    pub const signals = struct {};

    /// Creates a `gio.Action` corresponding to the value of property
    /// `property_name` on `object`.
    ///
    /// The property must be existent and readable and writable (and not
    /// construct-only).
    ///
    /// This function takes a reference on `object` and doesn't release it
    /// until the action is destroyed.
    extern fn g_property_action_new(p_name: [*:0]const u8, p_object: *gobject.Object, p_property_name: [*:0]const u8) *gio.PropertyAction;
    pub const new = g_property_action_new;

    extern fn g_property_action_get_type() usize;
    pub const getGObjectType = g_property_action_get_type;

    extern fn g_object_ref(p_self: *gio.PropertyAction) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.PropertyAction) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *PropertyAction, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `gio.InetSocketAddress` representing a connection via a proxy server.
pub const ProxyAddress = extern struct {
    pub const Parent = gio.InetSocketAddress;
    pub const Implements = [_]type{gio.SocketConnectable};
    pub const Class = gio.ProxyAddressClass;
    f_parent_instance: gio.InetSocketAddress,
    f_priv: ?*gio.ProxyAddressPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The proxy destination hostname.
        pub const destination_hostname = struct {
            pub const name = "destination-hostname";

            pub const Type = ?[*:0]u8;
        };

        /// The proxy destination port.
        pub const destination_port = struct {
            pub const name = "destination-port";

            pub const Type = c_uint;
        };

        /// The protocol being spoke to the destination host, or `NULL` if
        /// the `gio.ProxyAddress` doesn't know.
        pub const destination_protocol = struct {
            pub const name = "destination-protocol";

            pub const Type = ?[*:0]u8;
        };

        /// The proxy password.
        pub const password = struct {
            pub const name = "password";

            pub const Type = ?[*:0]u8;
        };

        /// The proxy protocol.
        pub const protocol = struct {
            pub const name = "protocol";

            pub const Type = ?[*:0]u8;
        };

        /// The URI string that the proxy was constructed from (or `NULL`
        /// if the creator didn't specify this).
        pub const uri = struct {
            pub const name = "uri";

            pub const Type = ?[*:0]u8;
        };

        /// The proxy username.
        pub const username = struct {
            pub const name = "username";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.ProxyAddress` for `inetaddr` with `protocol` that should
    /// tunnel through `dest_hostname` and `dest_port`.
    ///
    /// (Note that this method doesn't set the `gio.ProxyAddress.properties.uri` or
    /// `gio.ProxyAddress.properties.destination`-protocol fields; use `gobject.Object.new`
    /// directly if you want to set those.)
    extern fn g_proxy_address_new(p_inetaddr: *gio.InetAddress, p_port: u16, p_protocol: [*:0]const u8, p_dest_hostname: [*:0]const u8, p_dest_port: u16, p_username: ?[*:0]const u8, p_password: ?[*:0]const u8) *gio.ProxyAddress;
    pub const new = g_proxy_address_new;

    /// Gets `proxy`'s destination hostname; that is, the name of the host
    /// that will be connected to via the proxy, not the name of the proxy
    /// itself.
    extern fn g_proxy_address_get_destination_hostname(p_proxy: *ProxyAddress) [*:0]const u8;
    pub const getDestinationHostname = g_proxy_address_get_destination_hostname;

    /// Gets `proxy`'s destination port; that is, the port on the
    /// destination host that will be connected to via the proxy, not the
    /// port number of the proxy itself.
    extern fn g_proxy_address_get_destination_port(p_proxy: *ProxyAddress) u16;
    pub const getDestinationPort = g_proxy_address_get_destination_port;

    /// Gets the protocol that is being spoken to the destination
    /// server; eg, "http" or "ftp".
    extern fn g_proxy_address_get_destination_protocol(p_proxy: *ProxyAddress) [*:0]const u8;
    pub const getDestinationProtocol = g_proxy_address_get_destination_protocol;

    /// Gets `proxy`'s password.
    extern fn g_proxy_address_get_password(p_proxy: *ProxyAddress) ?[*:0]const u8;
    pub const getPassword = g_proxy_address_get_password;

    /// Gets `proxy`'s protocol. eg, "socks" or "http"
    extern fn g_proxy_address_get_protocol(p_proxy: *ProxyAddress) [*:0]const u8;
    pub const getProtocol = g_proxy_address_get_protocol;

    /// Gets the proxy URI that `proxy` was constructed from.
    extern fn g_proxy_address_get_uri(p_proxy: *ProxyAddress) ?[*:0]const u8;
    pub const getUri = g_proxy_address_get_uri;

    /// Gets `proxy`'s username.
    extern fn g_proxy_address_get_username(p_proxy: *ProxyAddress) ?[*:0]const u8;
    pub const getUsername = g_proxy_address_get_username;

    extern fn g_proxy_address_get_type() usize;
    pub const getGObjectType = g_proxy_address_get_type;

    extern fn g_object_ref(p_self: *gio.ProxyAddress) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.ProxyAddress) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ProxyAddress, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GProxyAddressEnumerator` is a wrapper around
/// `gio.SocketAddressEnumerator` which takes the `gio.SocketAddress`
/// instances returned by the `gio.SocketAddressEnumerator`
/// and wraps them in `gio.ProxyAddress` instances, using the given
/// `gio.ProxyAddressEnumerator.properties.proxy_resolver`.
///
/// This enumerator will be returned (for example, by
/// `gio.SocketConnectable.enumerate`) as appropriate when a proxy is
/// configured; there should be no need to manually wrap a
/// `gio.SocketAddressEnumerator` instance with one.
pub const ProxyAddressEnumerator = extern struct {
    pub const Parent = gio.SocketAddressEnumerator;
    pub const Implements = [_]type{};
    pub const Class = gio.ProxyAddressEnumeratorClass;
    f_parent_instance: gio.SocketAddressEnumerator,
    f_priv: ?*gio.ProxyAddressEnumeratorPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The connectable being enumerated.
        pub const connectable = struct {
            pub const name = "connectable";

            pub const Type = ?*gio.SocketConnectable;
        };

        /// The default port to use if `gio.ProxyAddressEnumerator.properties.uri` does not
        /// specify one.
        pub const default_port = struct {
            pub const name = "default-port";

            pub const Type = c_uint;
        };

        /// The proxy resolver to use.
        pub const proxy_resolver = struct {
            pub const name = "proxy-resolver";

            pub const Type = ?*gio.ProxyResolver;
        };

        /// The destination URI. Use `none://` for a generic socket.
        pub const uri = struct {
            pub const name = "uri";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    extern fn g_proxy_address_enumerator_get_type() usize;
    pub const getGObjectType = g_proxy_address_enumerator_get_type;

    extern fn g_object_ref(p_self: *gio.ProxyAddressEnumerator) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.ProxyAddressEnumerator) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ProxyAddressEnumerator, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The object that handles DNS resolution. Use `gio.Resolver.getDefault`
/// to get the default resolver.
///
/// `GResolver` provides cancellable synchronous and asynchronous DNS
/// resolution, for hostnames (`gio.Resolver.lookupByAddress`,
/// `gio.Resolver.lookupByName` and their async variants) and SRV
/// (service) records (`gio.Resolver.lookupService`).
///
/// `gio.NetworkAddress` and `gio.NetworkService` provide wrappers
/// around `GResolver` functionality that also implement
/// `gio.SocketConnectable`, making it easy to connect to a remote
/// host/service.
///
/// The default resolver (see `gio.Resolver.getDefault`) has a timeout of
/// 30s set on it since GLib 2.78. Earlier versions of GLib did not support
/// resolver timeouts.
///
/// This is an abstract type; subclasses of it implement different resolvers for
/// different platforms and situations.
pub const Resolver = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.ResolverClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.ResolverPrivate,

    pub const virtual_methods = struct {
        /// Synchronously reverse-resolves `address` to determine its
        /// associated hostname.
        ///
        /// If the DNS resolution fails, `error` (if non-`NULL`) will be set to
        /// a value from `gio.ResolverError`.
        ///
        /// If `cancellable` is non-`NULL`, it can be used to cancel the
        /// operation, in which case `error` (if non-`NULL`) will be set to
        /// `G_IO_ERROR_CANCELLED`.
        pub const lookup_by_address = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_address: *gio.InetAddress, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?[*:0]u8 {
                return gobject.ext.as(Resolver.Class, p_class).f_lookup_by_address.?(gobject.ext.as(Resolver, p_resolver), p_address, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_address: *gio.InetAddress, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?[*:0]u8) void {
                gobject.ext.as(Resolver.Class, p_class).f_lookup_by_address = @ptrCast(p_implementation);
            }
        };

        /// Begins asynchronously reverse-resolving `address` to determine its
        /// associated hostname, and eventually calls `callback`, which must
        /// call `gio.Resolver.lookupByAddressFinish` to get the final result.
        pub const lookup_by_address_async = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_address: *gio.InetAddress, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Resolver.Class, p_class).f_lookup_by_address_async.?(gobject.ext.as(Resolver, p_resolver), p_address, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_address: *gio.InetAddress, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Resolver.Class, p_class).f_lookup_by_address_async = @ptrCast(p_implementation);
            }
        };

        /// Retrieves the result of a previous call to
        /// `gio.Resolver.lookupByAddressAsync`.
        ///
        /// If the DNS resolution failed, `error` (if non-`NULL`) will be set to
        /// a value from `gio.ResolverError`. If the operation was cancelled,
        /// `error` will be set to `G_IO_ERROR_CANCELLED`.
        pub const lookup_by_address_finish = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?[*:0]u8 {
                return gobject.ext.as(Resolver.Class, p_class).f_lookup_by_address_finish.?(gobject.ext.as(Resolver, p_resolver), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?[*:0]u8) void {
                gobject.ext.as(Resolver.Class, p_class).f_lookup_by_address_finish = @ptrCast(p_implementation);
            }
        };

        /// Synchronously resolves `hostname` to determine its associated IP
        /// address(es). `hostname` may be an ASCII-only or UTF-8 hostname, or
        /// the textual form of an IP address (in which case this just becomes
        /// a wrapper around `gio.InetAddress.newFromString`).
        ///
        /// On success, `gio.Resolver.lookupByName` will return a non-empty `glib.List` of
        /// `gio.InetAddress`, sorted in order of preference and guaranteed to not
        /// contain duplicates. That is, if using the result to connect to
        /// `hostname`, you should attempt to connect to the first address
        /// first, then the second if the first fails, etc. If you are using
        /// the result to listen on a socket, it is appropriate to add each
        /// result using e.g. `gio.SocketListener.addAddress`.
        ///
        /// If the DNS resolution fails, `error` (if non-`NULL`) will be set to a
        /// value from `gio.ResolverError` and `NULL` will be returned.
        ///
        /// If `cancellable` is non-`NULL`, it can be used to cancel the
        /// operation, in which case `error` (if non-`NULL`) will be set to
        /// `G_IO_ERROR_CANCELLED`.
        ///
        /// If you are planning to connect to a socket on the resolved IP
        /// address, it may be easier to create a `gio.NetworkAddress` and use its
        /// `gio.SocketConnectable` interface.
        pub const lookup_by_name = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_hostname: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.List {
                return gobject.ext.as(Resolver.Class, p_class).f_lookup_by_name.?(gobject.ext.as(Resolver, p_resolver), p_hostname, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_hostname: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List) void {
                gobject.ext.as(Resolver.Class, p_class).f_lookup_by_name = @ptrCast(p_implementation);
            }
        };

        /// Begins asynchronously resolving `hostname` to determine its
        /// associated IP address(es), and eventually calls `callback`, which
        /// must call `gio.Resolver.lookupByNameFinish` to get the result.
        /// See `gio.Resolver.lookupByName` for more details.
        pub const lookup_by_name_async = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_hostname: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Resolver.Class, p_class).f_lookup_by_name_async.?(gobject.ext.as(Resolver, p_resolver), p_hostname, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_hostname: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Resolver.Class, p_class).f_lookup_by_name_async = @ptrCast(p_implementation);
            }
        };

        /// Retrieves the result of a call to
        /// `gio.Resolver.lookupByNameAsync`.
        ///
        /// If the DNS resolution failed, `error` (if non-`NULL`) will be set to
        /// a value from `gio.ResolverError`. If the operation was cancelled,
        /// `error` will be set to `G_IO_ERROR_CANCELLED`.
        pub const lookup_by_name_finish = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.List {
                return gobject.ext.as(Resolver.Class, p_class).f_lookup_by_name_finish.?(gobject.ext.as(Resolver, p_resolver), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List) void {
                gobject.ext.as(Resolver.Class, p_class).f_lookup_by_name_finish = @ptrCast(p_implementation);
            }
        };

        /// This differs from `gio.Resolver.lookupByName` in that you can modify
        /// the lookup behavior with `flags`. For example this can be used to limit
        /// results with `G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY`.
        pub const lookup_by_name_with_flags = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_hostname: [*:0]const u8, p_flags: gio.ResolverNameLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.List {
                return gobject.ext.as(Resolver.Class, p_class).f_lookup_by_name_with_flags.?(gobject.ext.as(Resolver, p_resolver), p_hostname, p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_hostname: [*:0]const u8, p_flags: gio.ResolverNameLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List) void {
                gobject.ext.as(Resolver.Class, p_class).f_lookup_by_name_with_flags = @ptrCast(p_implementation);
            }
        };

        /// Begins asynchronously resolving `hostname` to determine its
        /// associated IP address(es), and eventually calls `callback`, which
        /// must call `gio.Resolver.lookupByNameWithFlagsFinish` to get the result.
        /// See `gio.Resolver.lookupByName` for more details.
        pub const lookup_by_name_with_flags_async = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_hostname: [*:0]const u8, p_flags: gio.ResolverNameLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Resolver.Class, p_class).f_lookup_by_name_with_flags_async.?(gobject.ext.as(Resolver, p_resolver), p_hostname, p_flags, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_hostname: [*:0]const u8, p_flags: gio.ResolverNameLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Resolver.Class, p_class).f_lookup_by_name_with_flags_async = @ptrCast(p_implementation);
            }
        };

        /// Retrieves the result of a call to
        /// `gio.Resolver.lookupByNameWithFlagsAsync`.
        ///
        /// If the DNS resolution failed, `error` (if non-`NULL`) will be set to
        /// a value from `gio.ResolverError`. If the operation was cancelled,
        /// `error` will be set to `G_IO_ERROR_CANCELLED`.
        pub const lookup_by_name_with_flags_finish = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.List {
                return gobject.ext.as(Resolver.Class, p_class).f_lookup_by_name_with_flags_finish.?(gobject.ext.as(Resolver, p_resolver), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List) void {
                gobject.ext.as(Resolver.Class, p_class).f_lookup_by_name_with_flags_finish = @ptrCast(p_implementation);
            }
        };

        /// Synchronously performs a DNS record lookup for the given `rrname` and returns
        /// a list of records as `glib.Variant` tuples. See `gio.ResolverRecordType` for
        /// information on what the records contain for each `record_type`.
        ///
        /// If the DNS resolution fails, `error` (if non-`NULL`) will be set to
        /// a value from `gio.ResolverError` and `NULL` will be returned.
        ///
        /// If `cancellable` is non-`NULL`, it can be used to cancel the
        /// operation, in which case `error` (if non-`NULL`) will be set to
        /// `G_IO_ERROR_CANCELLED`.
        pub const lookup_records = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_rrname: [*:0]const u8, p_record_type: gio.ResolverRecordType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.List {
                return gobject.ext.as(Resolver.Class, p_class).f_lookup_records.?(gobject.ext.as(Resolver, p_resolver), p_rrname, p_record_type, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_rrname: [*:0]const u8, p_record_type: gio.ResolverRecordType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List) void {
                gobject.ext.as(Resolver.Class, p_class).f_lookup_records = @ptrCast(p_implementation);
            }
        };

        /// Begins asynchronously performing a DNS lookup for the given
        /// `rrname`, and eventually calls `callback`, which must call
        /// `gio.Resolver.lookupRecordsFinish` to get the final result. See
        /// `gio.Resolver.lookupRecords` for more details.
        pub const lookup_records_async = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_rrname: [*:0]const u8, p_record_type: gio.ResolverRecordType, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Resolver.Class, p_class).f_lookup_records_async.?(gobject.ext.as(Resolver, p_resolver), p_rrname, p_record_type, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_rrname: [*:0]const u8, p_record_type: gio.ResolverRecordType, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Resolver.Class, p_class).f_lookup_records_async = @ptrCast(p_implementation);
            }
        };

        /// Retrieves the result of a previous call to
        /// `gio.Resolver.lookupRecordsAsync`. Returns a non-empty list of records as
        /// `glib.Variant` tuples. See `gio.ResolverRecordType` for information on what the
        /// records contain.
        ///
        /// If the DNS resolution failed, `error` (if non-`NULL`) will be set to
        /// a value from `gio.ResolverError`. If the operation was cancelled,
        /// `error` will be set to `G_IO_ERROR_CANCELLED`.
        pub const lookup_records_finish = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.List {
                return gobject.ext.as(Resolver.Class, p_class).f_lookup_records_finish.?(gobject.ext.as(Resolver, p_resolver), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List) void {
                gobject.ext.as(Resolver.Class, p_class).f_lookup_records_finish = @ptrCast(p_implementation);
            }
        };

        pub const lookup_service = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_rrname: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.List {
                return gobject.ext.as(Resolver.Class, p_class).f_lookup_service.?(gobject.ext.as(Resolver, p_resolver), p_rrname, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_rrname: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List) void {
                gobject.ext.as(Resolver.Class, p_class).f_lookup_service = @ptrCast(p_implementation);
            }
        };

        pub const lookup_service_async = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_rrname: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Resolver.Class, p_class).f_lookup_service_async.?(gobject.ext.as(Resolver, p_resolver), p_rrname, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_rrname: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Resolver.Class, p_class).f_lookup_service_async = @ptrCast(p_implementation);
            }
        };

        /// Retrieves the result of a previous call to
        /// `gio.Resolver.lookupServiceAsync`.
        ///
        /// If the DNS resolution failed, `error` (if non-`NULL`) will be set to
        /// a value from `gio.ResolverError`. If the operation was cancelled,
        /// `error` will be set to `G_IO_ERROR_CANCELLED`.
        pub const lookup_service_finish = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.List {
                return gobject.ext.as(Resolver.Class, p_class).f_lookup_service_finish.?(gobject.ext.as(Resolver, p_resolver), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List) void {
                gobject.ext.as(Resolver.Class, p_class).f_lookup_service_finish = @ptrCast(p_implementation);
            }
        };

        pub const reload = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Resolver.Class, p_class).f_reload.?(gobject.ext.as(Resolver, p_resolver));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Resolver.Class, p_class).f_reload = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The timeout applied to all resolver lookups, in milliseconds.
        ///
        /// This may be changed through the lifetime of the `gio.Resolver`. The new value
        /// will apply to any lookups started after the change, but not to any
        /// already-ongoing lookups.
        ///
        /// If this is `0`, no timeout is applied to lookups.
        ///
        /// No timeout was applied to lookups before this property was added in
        /// GLib 2.78.
        pub const timeout = struct {
            pub const name = "timeout";

            pub const Type = c_uint;
        };
    };

    pub const signals = struct {
        /// Emitted when the resolver notices that the system resolver
        /// configuration has changed.
        pub const reload = struct {
            pub const name = "reload";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Resolver, p_instance))),
                    gobject.signalLookup("reload", Resolver.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Frees `addresses` (which should be the return value from
    /// `gio.Resolver.lookupByName` or `gio.Resolver.lookupByNameFinish`).
    /// (This is a convenience method; you can also simply free the results
    /// by hand.)
    extern fn g_resolver_free_addresses(p_addresses: *glib.List) void;
    pub const freeAddresses = g_resolver_free_addresses;

    /// Frees `targets` (which should be the return value from
    /// `gio.Resolver.lookupService` or `gio.Resolver.lookupServiceFinish`).
    /// (This is a convenience method; you can also simply free the
    /// results by hand.)
    extern fn g_resolver_free_targets(p_targets: *glib.List) void;
    pub const freeTargets = g_resolver_free_targets;

    /// Gets the default `gio.Resolver`. You should unref it when you are done
    /// with it. `gio.Resolver` may use its reference count as a hint about how
    /// many threads it should allocate for concurrent DNS resolutions.
    extern fn g_resolver_get_default() *gio.Resolver;
    pub const getDefault = g_resolver_get_default;

    /// Get the timeout applied to all resolver lookups. See `gio.Resolver.properties.timeout`.
    extern fn g_resolver_get_timeout(p_resolver: *Resolver) c_uint;
    pub const getTimeout = g_resolver_get_timeout;

    /// Synchronously reverse-resolves `address` to determine its
    /// associated hostname.
    ///
    /// If the DNS resolution fails, `error` (if non-`NULL`) will be set to
    /// a value from `gio.ResolverError`.
    ///
    /// If `cancellable` is non-`NULL`, it can be used to cancel the
    /// operation, in which case `error` (if non-`NULL`) will be set to
    /// `G_IO_ERROR_CANCELLED`.
    extern fn g_resolver_lookup_by_address(p_resolver: *Resolver, p_address: *gio.InetAddress, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?[*:0]u8;
    pub const lookupByAddress = g_resolver_lookup_by_address;

    /// Begins asynchronously reverse-resolving `address` to determine its
    /// associated hostname, and eventually calls `callback`, which must
    /// call `gio.Resolver.lookupByAddressFinish` to get the final result.
    extern fn g_resolver_lookup_by_address_async(p_resolver: *Resolver, p_address: *gio.InetAddress, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const lookupByAddressAsync = g_resolver_lookup_by_address_async;

    /// Retrieves the result of a previous call to
    /// `gio.Resolver.lookupByAddressAsync`.
    ///
    /// If the DNS resolution failed, `error` (if non-`NULL`) will be set to
    /// a value from `gio.ResolverError`. If the operation was cancelled,
    /// `error` will be set to `G_IO_ERROR_CANCELLED`.
    extern fn g_resolver_lookup_by_address_finish(p_resolver: *Resolver, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?[*:0]u8;
    pub const lookupByAddressFinish = g_resolver_lookup_by_address_finish;

    /// Synchronously resolves `hostname` to determine its associated IP
    /// address(es). `hostname` may be an ASCII-only or UTF-8 hostname, or
    /// the textual form of an IP address (in which case this just becomes
    /// a wrapper around `gio.InetAddress.newFromString`).
    ///
    /// On success, `gio.Resolver.lookupByName` will return a non-empty `glib.List` of
    /// `gio.InetAddress`, sorted in order of preference and guaranteed to not
    /// contain duplicates. That is, if using the result to connect to
    /// `hostname`, you should attempt to connect to the first address
    /// first, then the second if the first fails, etc. If you are using
    /// the result to listen on a socket, it is appropriate to add each
    /// result using e.g. `gio.SocketListener.addAddress`.
    ///
    /// If the DNS resolution fails, `error` (if non-`NULL`) will be set to a
    /// value from `gio.ResolverError` and `NULL` will be returned.
    ///
    /// If `cancellable` is non-`NULL`, it can be used to cancel the
    /// operation, in which case `error` (if non-`NULL`) will be set to
    /// `G_IO_ERROR_CANCELLED`.
    ///
    /// If you are planning to connect to a socket on the resolved IP
    /// address, it may be easier to create a `gio.NetworkAddress` and use its
    /// `gio.SocketConnectable` interface.
    extern fn g_resolver_lookup_by_name(p_resolver: *Resolver, p_hostname: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.List;
    pub const lookupByName = g_resolver_lookup_by_name;

    /// Begins asynchronously resolving `hostname` to determine its
    /// associated IP address(es), and eventually calls `callback`, which
    /// must call `gio.Resolver.lookupByNameFinish` to get the result.
    /// See `gio.Resolver.lookupByName` for more details.
    extern fn g_resolver_lookup_by_name_async(p_resolver: *Resolver, p_hostname: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const lookupByNameAsync = g_resolver_lookup_by_name_async;

    /// Retrieves the result of a call to
    /// `gio.Resolver.lookupByNameAsync`.
    ///
    /// If the DNS resolution failed, `error` (if non-`NULL`) will be set to
    /// a value from `gio.ResolverError`. If the operation was cancelled,
    /// `error` will be set to `G_IO_ERROR_CANCELLED`.
    extern fn g_resolver_lookup_by_name_finish(p_resolver: *Resolver, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.List;
    pub const lookupByNameFinish = g_resolver_lookup_by_name_finish;

    /// This differs from `gio.Resolver.lookupByName` in that you can modify
    /// the lookup behavior with `flags`. For example this can be used to limit
    /// results with `G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY`.
    extern fn g_resolver_lookup_by_name_with_flags(p_resolver: *Resolver, p_hostname: [*:0]const u8, p_flags: gio.ResolverNameLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.List;
    pub const lookupByNameWithFlags = g_resolver_lookup_by_name_with_flags;

    /// Begins asynchronously resolving `hostname` to determine its
    /// associated IP address(es), and eventually calls `callback`, which
    /// must call `gio.Resolver.lookupByNameWithFlagsFinish` to get the result.
    /// See `gio.Resolver.lookupByName` for more details.
    extern fn g_resolver_lookup_by_name_with_flags_async(p_resolver: *Resolver, p_hostname: [*:0]const u8, p_flags: gio.ResolverNameLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const lookupByNameWithFlagsAsync = g_resolver_lookup_by_name_with_flags_async;

    /// Retrieves the result of a call to
    /// `gio.Resolver.lookupByNameWithFlagsAsync`.
    ///
    /// If the DNS resolution failed, `error` (if non-`NULL`) will be set to
    /// a value from `gio.ResolverError`. If the operation was cancelled,
    /// `error` will be set to `G_IO_ERROR_CANCELLED`.
    extern fn g_resolver_lookup_by_name_with_flags_finish(p_resolver: *Resolver, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.List;
    pub const lookupByNameWithFlagsFinish = g_resolver_lookup_by_name_with_flags_finish;

    /// Synchronously performs a DNS record lookup for the given `rrname` and returns
    /// a list of records as `glib.Variant` tuples. See `gio.ResolverRecordType` for
    /// information on what the records contain for each `record_type`.
    ///
    /// If the DNS resolution fails, `error` (if non-`NULL`) will be set to
    /// a value from `gio.ResolverError` and `NULL` will be returned.
    ///
    /// If `cancellable` is non-`NULL`, it can be used to cancel the
    /// operation, in which case `error` (if non-`NULL`) will be set to
    /// `G_IO_ERROR_CANCELLED`.
    extern fn g_resolver_lookup_records(p_resolver: *Resolver, p_rrname: [*:0]const u8, p_record_type: gio.ResolverRecordType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.List;
    pub const lookupRecords = g_resolver_lookup_records;

    /// Begins asynchronously performing a DNS lookup for the given
    /// `rrname`, and eventually calls `callback`, which must call
    /// `gio.Resolver.lookupRecordsFinish` to get the final result. See
    /// `gio.Resolver.lookupRecords` for more details.
    extern fn g_resolver_lookup_records_async(p_resolver: *Resolver, p_rrname: [*:0]const u8, p_record_type: gio.ResolverRecordType, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const lookupRecordsAsync = g_resolver_lookup_records_async;

    /// Retrieves the result of a previous call to
    /// `gio.Resolver.lookupRecordsAsync`. Returns a non-empty list of records as
    /// `glib.Variant` tuples. See `gio.ResolverRecordType` for information on what the
    /// records contain.
    ///
    /// If the DNS resolution failed, `error` (if non-`NULL`) will be set to
    /// a value from `gio.ResolverError`. If the operation was cancelled,
    /// `error` will be set to `G_IO_ERROR_CANCELLED`.
    extern fn g_resolver_lookup_records_finish(p_resolver: *Resolver, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.List;
    pub const lookupRecordsFinish = g_resolver_lookup_records_finish;

    /// Synchronously performs a DNS SRV lookup for the given `service` and
    /// `protocol` in the given `domain` and returns an array of `gio.SrvTarget`.
    /// `domain` may be an ASCII-only or UTF-8 hostname. Note also that the
    /// `service` and `protocol` arguments do not include the leading underscore
    /// that appears in the actual DNS entry.
    ///
    /// On success, `gio.Resolver.lookupService` will return a non-empty `glib.List` of
    /// `gio.SrvTarget`, sorted in order of preference. (That is, you should
    /// attempt to connect to the first target first, then the second if
    /// the first fails, etc.)
    ///
    /// If the DNS resolution fails, `error` (if non-`NULL`) will be set to
    /// a value from `gio.ResolverError` and `NULL` will be returned.
    ///
    /// If `cancellable` is non-`NULL`, it can be used to cancel the
    /// operation, in which case `error` (if non-`NULL`) will be set to
    /// `G_IO_ERROR_CANCELLED`.
    ///
    /// If you are planning to connect to the service, it is usually easier
    /// to create a `gio.NetworkService` and use its `gio.SocketConnectable`
    /// interface.
    extern fn g_resolver_lookup_service(p_resolver: *Resolver, p_service: [*:0]const u8, p_protocol: [*:0]const u8, p_domain: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.List;
    pub const lookupService = g_resolver_lookup_service;

    /// Begins asynchronously performing a DNS SRV lookup for the given
    /// `service` and `protocol` in the given `domain`, and eventually calls
    /// `callback`, which must call `gio.Resolver.lookupServiceFinish` to
    /// get the final result. See `gio.Resolver.lookupService` for more
    /// details.
    extern fn g_resolver_lookup_service_async(p_resolver: *Resolver, p_service: [*:0]const u8, p_protocol: [*:0]const u8, p_domain: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const lookupServiceAsync = g_resolver_lookup_service_async;

    /// Retrieves the result of a previous call to
    /// `gio.Resolver.lookupServiceAsync`.
    ///
    /// If the DNS resolution failed, `error` (if non-`NULL`) will be set to
    /// a value from `gio.ResolverError`. If the operation was cancelled,
    /// `error` will be set to `G_IO_ERROR_CANCELLED`.
    extern fn g_resolver_lookup_service_finish(p_resolver: *Resolver, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.List;
    pub const lookupServiceFinish = g_resolver_lookup_service_finish;

    /// Sets `resolver` to be the application's default resolver (reffing
    /// `resolver`, and unreffing the previous default resolver, if any).
    /// Future calls to `gio.Resolver.getDefault` will return this resolver.
    ///
    /// This can be used if an application wants to perform any sort of DNS
    /// caching or "pinning"; it can implement its own `gio.Resolver` that
    /// calls the original default resolver for DNS operations, and
    /// implements its own cache policies on top of that, and then set
    /// itself as the default resolver for all later code to use.
    extern fn g_resolver_set_default(p_resolver: *Resolver) void;
    pub const setDefault = g_resolver_set_default;

    /// Set the timeout applied to all resolver lookups. See `gio.Resolver.properties.timeout`.
    extern fn g_resolver_set_timeout(p_resolver: *Resolver, p_timeout_ms: c_uint) void;
    pub const setTimeout = g_resolver_set_timeout;

    extern fn g_resolver_get_type() usize;
    pub const getGObjectType = g_resolver_get_type;

    extern fn g_object_ref(p_self: *gio.Resolver) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Resolver) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Resolver, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `GSettings` class provides a convenient API for storing and retrieving
/// application settings.
///
/// Reads and writes can be considered to be non-blocking.  Reading
/// settings with `GSettings` is typically extremely fast: on
/// approximately the same order of magnitude (but slower than) a
/// `glib.HashTable` lookup.  Writing settings is also extremely fast in
/// terms of time to return to your application, but can be extremely expensive
/// for other threads and other processes.  Many settings backends
/// (including dconf) have lazy initialisation which means in the common
/// case of the user using their computer without modifying any settings
/// a lot of work can be avoided.  For dconf, the D-Bus service doesn’t
/// even need to be started in this case.  For this reason, you should
/// only ever modify `GSettings` keys in response to explicit user action.
/// Particular care should be paid to ensure that modifications are not
/// made during startup — for example, when setting the initial value
/// of preferences widgets.  The built-in `gio.Settings.bind`
/// functionality is careful not to write settings in response to notify signals
/// as a result of modifications that it makes to widgets.
///
/// When creating a `GSettings` instance, you have to specify a schema
/// that describes the keys in your settings and their types and default
/// values, as well as some other information.
///
/// Normally, a schema has a fixed path that determines where the settings
/// are stored in the conceptual global tree of settings. However, schemas
/// can also be ‘[relocatable](`relocatable`-schemas)’, i.e. not equipped with
/// a fixed path. This is
/// useful e.g. when the schema describes an ‘account’, and you want to be
/// able to store a arbitrary number of accounts.
///
/// Paths must start with and end with a forward slash character (`/`)
/// and must not contain two sequential slash characters.  Paths should
/// be chosen based on a domain name associated with the program or
/// library to which the settings belong.  Examples of paths are
/// `/org/gtk/settings/file-chooser/` and `/ca/desrt/dconf-editor/`.
/// Paths should not start with `/apps/`, `/desktop/` or `/system/` as
/// they often did in GConf.
///
/// Unlike other configuration systems (like GConf), GSettings does not
/// restrict keys to basic types like strings and numbers. GSettings stores
/// values as `glib.Variant`, and allows any `glib.VariantType` for
/// keys. Key names are restricted to lowercase characters, numbers and `-`.
/// Furthermore, the names must begin with a lowercase character, must not end
/// with a `-`, and must not contain consecutive dashes.
///
/// Similar to GConf, the default values in GSettings schemas can be
/// localized, but the localized values are stored in gettext catalogs
/// and looked up with the domain that is specified in the
/// `gettext-domain` attribute of the `<schemalist>` or `<schema>`
/// elements and the category that is specified in the `l10n` attribute of
/// the `<default>` element. The string which is translated includes all text in
/// the `<default>` element, including any surrounding quotation marks.
///
/// The `l10n` attribute must be set to `messages` or `time`, and sets the
/// [locale category for
/// translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html`index`-locale-categories-1).
/// The `messages` category should be used by default; use `time` for
/// translatable date or time formats. A translation comment can be added as an
/// XML comment immediately above the `<default>` element — it is recommended to
/// add these comments to aid translators understand the meaning and
/// implications of the default value. An optional translation `context`
/// attribute can be set on the `<default>` element to disambiguate multiple
/// defaults which use the same string.
///
/// For example:
/// ```xml
///  <!-- Translators: A list of words which are not allowed to be typed, in
///       GVariant serialization syntax.
///       See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
///  <default l10n='messages' context='Banned words'>['bad', 'words']</default>
/// ```
///
/// Translations of default values must remain syntactically valid serialized
/// `glib.Variant`s (e.g. retaining any surrounding quotation marks) or
/// runtime errors will occur.
///
/// GSettings uses schemas in a compact binary form that is created
/// by the [`glib-compile-schemas`](glib-compile-schemas.html)
/// utility. The input is a schema description in an XML format.
///
/// A DTD for the gschema XML format can be found here:
/// [gschema.dtd](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/gschema.dtd)
///
/// The [`glib-compile-schemas`](glib-compile-schemas.html) tool expects schema
/// files to have the extension `.gschema.xml`.
///
/// At runtime, schemas are identified by their ID (as specified in the
/// `id` attribute of the `<schema>` element). The convention for schema
/// IDs is to use a dotted name, similar in style to a D-Bus bus name,
/// e.g. `org.gnome.SessionManager`. In particular, if the settings are
/// for a specific service that owns a D-Bus bus name, the D-Bus bus name
/// and schema ID should match. For schemas which deal with settings not
/// associated with one named application, the ID should not use
/// StudlyCaps, e.g. `org.gnome.font-rendering`.
///
/// In addition to `glib.Variant` types, keys can have types that have
/// enumerated types. These can be described by a `<choice>`,
/// `<enum>` or `<flags>` element, as seen in the
/// second example below. The underlying type of such a key
/// is string, but you can use `gio.Settings.getEnum`,
/// `gio.Settings.setEnum`, `gio.Settings.getFlags`,
/// `gio.Settings.setFlags` access the numeric values corresponding to
/// the string value of enum and flags keys.
///
/// An example for default value:
/// ```xml
/// <schemalist>
///   <schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test">
///
///     <key name="greeting" type="s">
///       <default l10n="messages">"Hello, earthlings"</default>
///       <summary>A greeting</summary>
///       <description>
///         Greeting of the invading martians
///       </description>
///     </key>
///
///     <key name="box" type="(ii)">
///       <default>(20,30)</default>
///     </key>
///
///     <key name="empty-string" type="s">
///       <default>""</default>
///       <summary>Empty strings have to be provided in GVariant form</summary>
///     </key>
///
///   </schema>
/// </schemalist>
/// ```
///
/// An example for ranges, choices and enumerated types:
/// ```xml
/// <schemalist>
///
///   <enum id="org.gtk.Test.myenum">
///     <value nick="first" value="1"/>
///     <value nick="second" value="2"/>
///   </enum>
///
///   <flags id="org.gtk.Test.myflags">
///     <value nick="flag1" value="1"/>
///     <value nick="flag2" value="2"/>
///     <value nick="flag3" value="4"/>
///   </flags>
///
///   <schema id="org.gtk.Test">
///
///     <key name="key-with-range" type="i">
///       <range min="1" max="100"/>
///       <default>10</default>
///     </key>
///
///     <key name="key-with-choices" type="s">
///       <choices>
///         <choice value='Elisabeth'/>
///         <choice value='Annabeth'/>
///         <choice value='Joe'/>
///       </choices>
///       <aliases>
///         <alias value='Anna' target='Annabeth'/>
///         <alias value='Beth' target='Elisabeth'/>
///       </aliases>
///       <default>'Joe'</default>
///     </key>
///
///     <key name='enumerated-key' enum='org.gtk.Test.myenum'>
///       <default>'first'</default>
///     </key>
///
///     <key name='flags-key' flags='org.gtk.Test.myflags'>
///       <default>["flag1","flag2"]</default>
///     </key>
///   </schema>
/// </schemalist>
/// ```
///
/// ## Vendor overrides
///
/// Default values are defined in the schemas that get installed by
/// an application. Sometimes, it is necessary for a vendor or distributor
/// to adjust these defaults. Since patching the XML source for the schema
/// is inconvenient and error-prone,
/// [`glib-compile-schemas`](glib-compile-schemas.html) reads so-called ‘vendor
/// override’ files. These are keyfiles in the same directory as the XML
/// schema sources which can override default values. The schema ID serves
/// as the group name in the key file, and the values are expected in
/// serialized `glib.Variant` form, as in the following example:
/// ```
/// [org.gtk.Example]
/// key1='string'
/// key2=1.5
/// ```
///
/// `glib-compile-schemas` expects schema files to have the extension
/// `.gschema.override`.
///
/// ## Binding
///
/// A very convenient feature of GSettings lets you bind `gobject.Object`
/// properties directly to settings, using `gio.Settings.bind`. Once a
/// `gobject.Object` property has been bound to a setting, changes on
/// either side are automatically propagated to the other side. GSettings handles
/// details like mapping between `gobject.Object` and `glib.Variant`
/// types, and preventing infinite cycles.
///
/// This makes it very easy to hook up a preferences dialog to the
/// underlying settings. To make this even more convenient, GSettings
/// looks for a boolean property with the name `sensitivity` and
/// automatically binds it to the writability of the bound setting.
/// If this ‘magic’ gets in the way, it can be suppressed with the
/// `G_SETTINGS_BIND_NO_SENSITIVITY` flag.
///
/// ## Relocatable schemas
///
/// A relocatable schema is one with no `path` attribute specified on its
/// `<schema>` element. By using `gio.Settings.newWithPath`, a `GSettings`
/// object can be instantiated for a relocatable schema, assigning a path to the
/// instance. Paths passed to `gio.Settings.newWithPath` will typically be
/// constructed dynamically from a constant prefix plus some form of instance
/// identifier; but they must still be valid GSettings paths. Paths could also
/// be constant and used with a globally installed schema originating from a
/// dependency library.
///
/// For example, a relocatable schema could be used to store geometry information
/// for different windows in an application. If the schema ID was
/// `org.foo.MyApp.Window`, it could be instantiated for paths
/// `/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
/// `/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known
/// they can be specified as `<child>` elements in the parent schema, e.g.:
/// ```xml
/// <schema id="org.foo.MyApp" path="/org/foo/MyApp/">
///   <child name="main" schema="org.foo.MyApp.Window"/>
/// </schema>
/// ```
///
/// ## Build system integration
///
/// ### Meson
///
/// GSettings is natively supported by Meson's [GNOME module](https://mesonbuild.com/Gnome-module.html).
///
/// You can install the schemas as any other data file:
///
/// ```
/// install_data(
///   'org.foo.MyApp.gschema.xml',
///   install_dir: get_option('datadir') / 'glib-2.0/schemas',
/// )
/// ```
///
/// You can use `gnome.`post_install`` function to compile the schemas on
/// installation:
///
/// ```
/// gnome = import('gnome')
/// gnome.post_install(
///   glib_compile_schemas: true,
/// )
/// ```
///
/// If an enumerated type defined in a C header file is to be used in a GSettings
/// schema, it can either be defined manually using an `<enum>` element in the
/// schema XML, or it can be extracted automatically from the C header. This
/// approach is preferred, as it ensures the two representations are always
/// synchronised. To do so, you will need to use the `gnome.`mkenums`` function
/// with the following templates:
///
/// ```
/// schemas_enums = gnome.mkenums('org.foo.MyApp.enums.xml',
///   comments: '<!-- `comment`@ -->',
///   fhead: '<schemalist>',
///   vhead: '  <`type`@ id="org.foo.MyApp.`EnumName`@">',
///   vprod: '    <value nick="`valuenick`@" value="`valuenum`@"/>',
///   vtail: '  </`type`@>',
///   ftail: '</schemalist>',
///   sources: enum_sources,
///   install_header: true,
///   install_dir: get_option('datadir') / 'glib-2.0/schemas',
/// )
/// ```
///
/// It is recommended to validate your schemas as part of the test suite for
/// your application:
///
/// ```
/// test('validate-schema',
///   find_program('glib-compile-schemas'),
///   args: ['--strict', '--dry-run', meson.`current_source_dir`],
/// )
/// ```
///
/// If your application allows running uninstalled, you should also use the
/// `gnome.`compile_schemas`` function to compile the schemas in the current
/// build directory:
///
/// ```
/// gnome.`compile_schemas`
/// ```
///
/// ### Autotools
///
/// GSettings comes with autotools integration to simplify compiling and
/// installing schemas. To add GSettings support to an application, add the
/// following to your `configure.ac`:
/// ```
/// GLIB_GSETTINGS
/// ```
///
/// In the appropriate `Makefile.am`, use the following snippet to compile and
/// install the named schema:
/// ```
/// gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
/// EXTRA_DIST = $(gsettings_SCHEMAS)
///
/// `GSETTINGS_RULES`@
/// ```
///
/// If an enumerated type defined in a C header file is to be used in a GSettings
/// schema, it can either be defined manually using an `<enum>` element in the
/// schema XML, or it can be extracted automatically from the C header. This
/// approach is preferred, as it ensures the two representations are always
/// synchronised. To do so, add the following to the relevant `Makefile.am`:
/// ```
/// gsettings_ENUM_NAMESPACE = org.foo.MyApp
/// gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
/// ```
///
/// `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
/// which are specified in `gsettings_ENUM_FILES`. This will generate a
/// `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
/// automatically included in the schema compilation, install and uninstall
/// rules. It should not be committed to version control or included in
/// `EXTRA_DIST`.
///
/// ## Localization
///
/// No changes are needed to the build system to mark a schema XML file for
/// translation. Assuming it sets the `gettext-domain` attribute, a schema may
/// be marked for translation by adding it to `POTFILES.in`, assuming gettext
/// 0.19 or newer is in use (the preferred method for translation):
/// ```
/// data/org.foo.MyApp.gschema.xml
/// ```
///
/// Alternatively, if intltool 0.50.1 is in use:
/// ```
/// [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
/// ```
///
/// GSettings will use gettext to look up translations for the `<summary>` and
/// `<description>` elements, and also any `<default>` elements which have a
/// `l10n` attribute set.
///
/// Translations **must not** be included in the `.gschema.xml` file by the build
/// system, for example by using a rule to generate the XML file from a template.
pub const Settings = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.SettingsClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.SettingsPrivate,

    pub const virtual_methods = struct {
        pub const change_event = struct {
            pub fn call(p_class: anytype, p_settings: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_keys: *const glib.Quark, p_n_keys: c_int) c_int {
                return gobject.ext.as(Settings.Class, p_class).f_change_event.?(gobject.ext.as(Settings, p_settings), p_keys, p_n_keys);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_settings: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_keys: *const glib.Quark, p_n_keys: c_int) callconv(.c) c_int) void {
                gobject.ext.as(Settings.Class, p_class).f_change_event = @ptrCast(p_implementation);
            }
        };

        pub const changed = struct {
            pub fn call(p_class: anytype, p_settings: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: [*:0]const u8) void {
                return gobject.ext.as(Settings.Class, p_class).f_changed.?(gobject.ext.as(Settings, p_settings), p_key);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_settings: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(Settings.Class, p_class).f_changed = @ptrCast(p_implementation);
            }
        };

        pub const writable_change_event = struct {
            pub fn call(p_class: anytype, p_settings: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: glib.Quark) c_int {
                return gobject.ext.as(Settings.Class, p_class).f_writable_change_event.?(gobject.ext.as(Settings, p_settings), p_key);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_settings: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: glib.Quark) callconv(.c) c_int) void {
                gobject.ext.as(Settings.Class, p_class).f_writable_change_event = @ptrCast(p_implementation);
            }
        };

        pub const writable_changed = struct {
            pub fn call(p_class: anytype, p_settings: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: [*:0]const u8) void {
                return gobject.ext.as(Settings.Class, p_class).f_writable_changed.?(gobject.ext.as(Settings, p_settings), p_key);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_settings: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(Settings.Class, p_class).f_writable_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The name of the context that the settings are stored in.
        pub const backend = struct {
            pub const name = "backend";

            pub const Type = ?*gio.SettingsBackend;
        };

        /// Whether the `gio.Settings` object is in 'delay-apply' mode. See
        /// `gio.Settings.delay` for details.
        pub const delay_apply = struct {
            pub const name = "delay-apply";

            pub const Type = c_int;
        };

        /// If this property is `TRUE`, the `gio.Settings` object has outstanding
        /// changes that will be applied when `gio.Settings.apply` is called.
        pub const has_unapplied = struct {
            pub const name = "has-unapplied";

            pub const Type = c_int;
        };

        /// The path within the backend where the settings are stored.
        pub const path = struct {
            pub const name = "path";

            pub const Type = ?[*:0]u8;
        };

        /// The name of the schema that describes the types of keys
        /// for this `gio.Settings` object.
        ///
        /// The type of this property is *not* `gio.SettingsSchema`.
        /// `gio.SettingsSchema` has only existed since version 2.32 and
        /// unfortunately this name was used in previous versions to refer to
        /// the schema ID rather than the schema itself.  Take care to use the
        /// 'settings-schema' property if you wish to pass in a
        /// `gio.SettingsSchema`.
        pub const schema = struct {
            pub const name = "schema";

            pub const Type = ?[*:0]u8;
        };

        /// The name of the schema that describes the types of keys
        /// for this `gio.Settings` object.
        pub const schema_id = struct {
            pub const name = "schema-id";

            pub const Type = ?[*:0]u8;
        };

        /// The `gio.SettingsSchema` describing the types of keys for this
        /// `gio.Settings` object.
        ///
        /// Ideally, this property would be called 'schema'.  `gio.SettingsSchema`
        /// has only existed since version 2.32, however, and before then the
        /// 'schema' property was used to refer to the ID of the schema rather
        /// than the schema itself.  Take care.
        pub const settings_schema = struct {
            pub const name = "settings-schema";

            pub const Type = ?*gio.SettingsSchema;
        };
    };

    pub const signals = struct {
        /// The "change-event" signal is emitted once per change event that
        /// affects this settings object.  You should connect to this signal
        /// only if you are interested in viewing groups of changes before they
        /// are split out into multiple emissions of the "changed" signal.
        /// For most use cases it is more appropriate to use the "changed" signal.
        ///
        /// In the event that the change event applies to one or more specified
        /// keys, `keys` will be an array of `glib.Quark` of length `n_keys`.  In the
        /// event that the change event applies to the `gio.Settings` object as a
        /// whole (ie: potentially every key has been changed) then `keys` will
        /// be `NULL` and `n_keys` will be 0.
        ///
        /// The default handler for this signal invokes the "changed" signal
        /// for each affected key.  If any other connected handler returns
        /// `TRUE` then this default functionality will be suppressed.
        pub const change_event = struct {
            pub const name = "change-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_keys: ?[*]glib.Quark, p_n_keys: c_int, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Settings, p_instance))),
                    gobject.signalLookup("change-event", Settings.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The "changed" signal is emitted when a key has potentially changed.
        /// You should call one of the `gio.Settings.get` calls to check the new
        /// value.
        ///
        /// This signal supports detailed connections.  You can connect to the
        /// detailed signal "changed::x" in order to only receive callbacks
        /// when key "x" changes.
        ///
        /// Note that `settings` only emits this signal if you have read `key` at
        /// least once while a signal handler was already connected for `key`.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_key: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Settings, p_instance))),
                    gobject.signalLookup("changed", Settings.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The "writable-change-event" signal is emitted once per writability
        /// change event that affects this settings object.  You should connect
        /// to this signal if you are interested in viewing groups of changes
        /// before they are split out into multiple emissions of the
        /// "writable-changed" signal.  For most use cases it is more
        /// appropriate to use the "writable-changed" signal.
        ///
        /// In the event that the writability change applies only to a single
        /// key, `key` will be set to the `glib.Quark` for that key.  In the event
        /// that the writability change affects the entire settings object,
        /// `key` will be 0.
        ///
        /// The default handler for this signal invokes the "writable-changed"
        /// and "changed" signals for each affected key.  This is done because
        /// changes in writability might also imply changes in value (if for
        /// example, a new mandatory setting is introduced).  If any other
        /// connected handler returns `TRUE` then this default functionality
        /// will be suppressed.
        pub const writable_change_event = struct {
            pub const name = "writable-change-event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_key: c_uint, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Settings, p_instance))),
                    gobject.signalLookup("writable-change-event", Settings.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// The "writable-changed" signal is emitted when the writability of a
        /// key has potentially changed.  You should call
        /// `gio.Settings.isWritable` in order to determine the new status.
        ///
        /// This signal supports detailed connections.  You can connect to the
        /// detailed signal "writable-changed::x" in order to only receive
        /// callbacks when the writability of "x" changes.
        pub const writable_changed = struct {
            pub const name = "writable-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_key: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Settings, p_instance))),
                    gobject.signalLookup("writable-changed", Settings.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Deprecated.
    extern fn g_settings_list_relocatable_schemas() [*]const [*:0]const u8;
    pub const listRelocatableSchemas = g_settings_list_relocatable_schemas;

    /// Deprecated.
    extern fn g_settings_list_schemas() [*]const [*:0]const u8;
    pub const listSchemas = g_settings_list_schemas;

    /// Ensures that all pending operations are complete for the default backend.
    ///
    /// Writes made to a `gio.Settings` are handled asynchronously.  For this
    /// reason, it is very unlikely that the changes have it to disk by the
    /// time `gio.Settings.set` returns.
    ///
    /// This call will block until all of the writes have made it to the
    /// backend.  Since the mainloop is not running, no change notifications
    /// will be dispatched during this call (but some may be queued by the
    /// time the call is done).
    extern fn g_settings_sync() void;
    pub const sync = g_settings_sync;

    /// Removes an existing binding for `property` on `object`.
    ///
    /// Note that bindings are automatically removed when the
    /// object is finalized, so it is rarely necessary to call this
    /// function.
    extern fn g_settings_unbind(p_object: *gobject.Object, p_property: [*:0]const u8) void;
    pub const unbind = g_settings_unbind;

    /// Creates a new `gio.Settings` object with the schema specified by
    /// `schema_id`.
    ///
    /// It is an error for the schema to not exist: schemas are an
    /// essential part of a program, as they provide type information.
    /// If schemas need to be dynamically loaded (for example, from an
    /// optional runtime dependency), `gio.SettingsSchemaSource.lookup`
    /// can be used to test for their existence before loading them.
    ///
    /// Signals on the newly created `gio.Settings` object will be dispatched
    /// via the thread-default `glib.MainContext` in effect at the time of the
    /// call to `gio.Settings.new`.  The new `gio.Settings` will hold a reference
    /// on the context.  See `glib.MainContext.pushThreadDefault`.
    extern fn g_settings_new(p_schema_id: [*:0]const u8) *gio.Settings;
    pub const new = g_settings_new;

    /// Creates a new `gio.Settings` object with a given schema, backend and
    /// path.
    ///
    /// It should be extremely rare that you ever want to use this function.
    /// It is made available for advanced use-cases (such as plugin systems
    /// that want to provide access to schemas loaded from custom locations,
    /// etc).
    ///
    /// At the most basic level, a `gio.Settings` object is a pure composition of
    /// 4 things: a `gio.SettingsSchema`, a `gio.SettingsBackend`, a path within that
    /// backend, and a `glib.MainContext` to which signals are dispatched.
    ///
    /// This constructor therefore gives you full control over constructing
    /// `gio.Settings` instances.  The first 3 parameters are given directly as
    /// `schema`, `backend` and `path`, and the main context is taken from the
    /// thread-default (as per `gio.Settings.new`).
    ///
    /// If `backend` is `NULL` then the default backend is used.
    ///
    /// If `path` is `NULL` then the path from the schema is used.  It is an
    /// error if `path` is `NULL` and the schema has no path of its own or if
    /// `path` is non-`NULL` and not equal to the path that the schema does
    /// have.
    extern fn g_settings_new_full(p_schema: *gio.SettingsSchema, p_backend: ?*gio.SettingsBackend, p_path: ?[*:0]const u8) *gio.Settings;
    pub const newFull = g_settings_new_full;

    /// Creates a new `gio.Settings` object with the schema specified by
    /// `schema_id` and a given `gio.SettingsBackend`.
    ///
    /// Creating a `gio.Settings` object with a different backend allows accessing
    /// settings from a database other than the usual one. For example, it may make
    /// sense to pass a backend corresponding to the "defaults" settings database on
    /// the system to get a settings object that modifies the system default
    /// settings instead of the settings for this user.
    extern fn g_settings_new_with_backend(p_schema_id: [*:0]const u8, p_backend: *gio.SettingsBackend) *gio.Settings;
    pub const newWithBackend = g_settings_new_with_backend;

    /// Creates a new `gio.Settings` object with the schema specified by
    /// `schema_id` and a given `gio.SettingsBackend` and path.
    ///
    /// This is a mix of `gio.Settings.newWithBackend` and
    /// `gio.Settings.newWithPath`.
    extern fn g_settings_new_with_backend_and_path(p_schema_id: [*:0]const u8, p_backend: *gio.SettingsBackend, p_path: [*:0]const u8) *gio.Settings;
    pub const newWithBackendAndPath = g_settings_new_with_backend_and_path;

    /// Creates a new `gio.Settings` object with the relocatable schema specified
    /// by `schema_id` and a given path.
    ///
    /// You only need to do this if you want to directly create a settings
    /// object with a schema that doesn't have a specified path of its own.
    /// That's quite rare.
    ///
    /// It is a programmer error to call this function for a schema that
    /// has an explicitly specified path.
    ///
    /// It is a programmer error if `path` is not a valid path.  A valid path
    /// begins and ends with '/' and does not contain two consecutive '/'
    /// characters.
    extern fn g_settings_new_with_path(p_schema_id: [*:0]const u8, p_path: [*:0]const u8) *gio.Settings;
    pub const newWithPath = g_settings_new_with_path;

    /// Applies any changes that have been made to the settings.  This
    /// function does nothing unless `settings` is in 'delay-apply' mode;
    /// see `gio.Settings.delay`.  In the normal case settings are always
    /// applied immediately.
    extern fn g_settings_apply(p_settings: *Settings) void;
    pub const apply = g_settings_apply;

    /// Create a binding between the `key` in the `settings` object
    /// and the property `property` of `object`.
    ///
    /// The binding uses the default GIO mapping functions to map
    /// between the settings and property values. These functions
    /// handle booleans, numeric types and string types in a
    /// straightforward way. Use `gio.Settings.bindWithMapping` if
    /// you need a custom mapping, or map between types that are not
    /// supported by the default mapping functions.
    ///
    /// Unless the `flags` include `G_SETTINGS_BIND_NO_SENSITIVITY`, this
    /// function also establishes a binding between the writability of
    /// `key` and the "sensitive" property of `object` (if `object` has
    /// a boolean property by that name). See `gio.Settings.bindWritable`
    /// for more details about writable bindings.
    ///
    /// Note that the lifecycle of the binding is tied to `object`,
    /// and that you can have only one binding per object property.
    /// If you bind the same property twice on the same object, the second
    /// binding overrides the first one.
    extern fn g_settings_bind(p_settings: *Settings, p_key: [*:0]const u8, p_object: *gobject.Object, p_property: [*:0]const u8, p_flags: gio.SettingsBindFlags) void;
    pub const bind = g_settings_bind;

    /// Create a binding between the `key` in the `settings` object
    /// and the property `property` of `object`.
    ///
    /// The binding uses the provided mapping functions to map between
    /// settings and property values.
    ///
    /// Note that the lifecycle of the binding is tied to `object`,
    /// and that you can have only one binding per object property.
    /// If you bind the same property twice on the same object, the second
    /// binding overrides the first one.
    extern fn g_settings_bind_with_mapping(p_settings: *Settings, p_key: [*:0]const u8, p_object: *gobject.Object, p_property: [*:0]const u8, p_flags: gio.SettingsBindFlags, p_get_mapping: gio.SettingsBindGetMapping, p_set_mapping: gio.SettingsBindSetMapping, p_user_data: ?*anyopaque, p_destroy: ?glib.DestroyNotify) void;
    pub const bindWithMapping = g_settings_bind_with_mapping;

    /// Version of `gio.Settings.bindWithMapping` using closures instead of callbacks
    /// for easier binding in other languages.
    extern fn g_settings_bind_with_mapping_closures(p_settings: *Settings, p_key: [*:0]const u8, p_object: *gobject.Object, p_property: [*:0]const u8, p_flags: gio.SettingsBindFlags, p_get_mapping: ?*gobject.Closure, p_set_mapping: ?*gobject.Closure) void;
    pub const bindWithMappingClosures = g_settings_bind_with_mapping_closures;

    /// Create a binding between the writability of `key` in the
    /// `settings` object and the property `property` of `object`.
    /// The property must be boolean; "sensitive" or "visible"
    /// properties of widgets are the most likely candidates.
    ///
    /// Writable bindings are always uni-directional; changes of the
    /// writability of the setting will be propagated to the object
    /// property, not the other way.
    ///
    /// When the `inverted` argument is `TRUE`, the binding inverts the
    /// value as it passes from the setting to the object, i.e. `property`
    /// will be set to `TRUE` if the key is not writable.
    ///
    /// Note that the lifecycle of the binding is tied to `object`,
    /// and that you can have only one binding per object property.
    /// If you bind the same property twice on the same object, the second
    /// binding overrides the first one.
    extern fn g_settings_bind_writable(p_settings: *Settings, p_key: [*:0]const u8, p_object: *gobject.Object, p_property: [*:0]const u8, p_inverted: c_int) void;
    pub const bindWritable = g_settings_bind_writable;

    /// Creates a `gio.Action` corresponding to a given `gio.Settings` key.
    ///
    /// The action has the same name as the key.
    ///
    /// The value of the key becomes the state of the action and the action
    /// is enabled when the key is writable.  Changing the state of the
    /// action results in the key being written to.  Changes to the value or
    /// writability of the key cause appropriate change notifications to be
    /// emitted for the action.
    ///
    /// For boolean-valued keys, action activations take no parameter and
    /// result in the toggling of the value.  For all other types,
    /// activations take the new value for the key (which must have the
    /// correct type).
    extern fn g_settings_create_action(p_settings: *Settings, p_key: [*:0]const u8) *gio.Action;
    pub const createAction = g_settings_create_action;

    /// Changes the `gio.Settings` object into 'delay-apply' mode. In this
    /// mode, changes to `settings` are not immediately propagated to the
    /// backend, but kept locally until `gio.Settings.apply` is called.
    extern fn g_settings_delay(p_settings: *Settings) void;
    pub const delay = g_settings_delay;

    /// Gets the value that is stored at `key` in `settings`.
    ///
    /// A convenience function that combines `gio.Settings.getValue` with
    /// `glib.Variant.get`.
    ///
    /// It is a programmer error to give a `key` that isn't contained in the
    /// schema for `settings` or for the `glib.VariantType` of `format` to mismatch
    /// the type given in the schema.
    extern fn g_settings_get(p_settings: *Settings, p_key: [*:0]const u8, p_format: [*:0]const u8, ...) void;
    pub const get = g_settings_get;

    /// Gets the value that is stored at `key` in `settings`.
    ///
    /// A convenience variant of `gio.Settings.get` for booleans.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having a boolean type in the schema for `settings`.
    extern fn g_settings_get_boolean(p_settings: *Settings, p_key: [*:0]const u8) c_int;
    pub const getBoolean = g_settings_get_boolean;

    /// Creates a child settings object which has a base path of
    /// `base-path/`name``, where `base-path` is the base path of
    /// `settings`.
    ///
    /// The schema for the child settings object must have been declared
    /// in the schema of `settings` using a `<child>` element.
    ///
    /// The created child settings object will inherit the `gio.Settings.properties.delay`-apply
    /// mode from `settings`.
    extern fn g_settings_get_child(p_settings: *Settings, p_name: [*:0]const u8) *gio.Settings;
    pub const getChild = g_settings_get_child;

    /// Gets the "default value" of a key.
    ///
    /// This is the value that would be read if `gio.Settings.reset` were to be
    /// called on the key.
    ///
    /// Note that this may be a different value than returned by
    /// `gio.SettingsSchemaKey.getDefaultValue` if the system administrator
    /// has provided a default value.
    ///
    /// Comparing the return values of `gio.Settings.getDefaultValue` and
    /// `gio.Settings.getValue` is not sufficient for determining if a value
    /// has been set because the user may have explicitly set the value to
    /// something that happens to be equal to the default.  The difference
    /// here is that if the default changes in the future, the user's key
    /// will still be set.
    ///
    /// This function may be useful for adding an indication to a UI of what
    /// the default value was before the user set it.
    ///
    /// It is a programmer error to give a `key` that isn't contained in the
    /// schema for `settings`.
    extern fn g_settings_get_default_value(p_settings: *Settings, p_key: [*:0]const u8) ?*glib.Variant;
    pub const getDefaultValue = g_settings_get_default_value;

    /// Gets the value that is stored at `key` in `settings`.
    ///
    /// A convenience variant of `gio.Settings.get` for doubles.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having a 'double' type in the schema for `settings`.
    extern fn g_settings_get_double(p_settings: *Settings, p_key: [*:0]const u8) f64;
    pub const getDouble = g_settings_get_double;

    /// Gets the value that is stored in `settings` for `key` and converts it
    /// to the enum value that it represents.
    ///
    /// In order to use this function the type of the value must be a string
    /// and it must be marked in the schema file as an enumerated type.
    ///
    /// It is a programmer error to give a `key` that isn't contained in the
    /// schema for `settings` or is not marked as an enumerated type.
    ///
    /// If the value stored in the configuration database is not a valid
    /// value for the enumerated type then this function will return the
    /// default value.
    extern fn g_settings_get_enum(p_settings: *Settings, p_key: [*:0]const u8) c_int;
    pub const getEnum = g_settings_get_enum;

    /// Gets the value that is stored in `settings` for `key` and converts it
    /// to the flags value that it represents.
    ///
    /// In order to use this function the type of the value must be an array
    /// of strings and it must be marked in the schema file as a flags type.
    ///
    /// It is a programmer error to give a `key` that isn't contained in the
    /// schema for `settings` or is not marked as a flags type.
    ///
    /// If the value stored in the configuration database is not a valid
    /// value for the flags type then this function will return the default
    /// value.
    extern fn g_settings_get_flags(p_settings: *Settings, p_key: [*:0]const u8) c_uint;
    pub const getFlags = g_settings_get_flags;

    /// Returns whether the `gio.Settings` object has any unapplied
    /// changes.  This can only be the case if it is in 'delayed-apply' mode.
    extern fn g_settings_get_has_unapplied(p_settings: *Settings) c_int;
    pub const getHasUnapplied = g_settings_get_has_unapplied;

    /// Gets the value that is stored at `key` in `settings`.
    ///
    /// A convenience variant of `gio.Settings.get` for 32-bit integers.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having a int32 type in the schema for `settings`.
    extern fn g_settings_get_int(p_settings: *Settings, p_key: [*:0]const u8) c_int;
    pub const getInt = g_settings_get_int;

    /// Gets the value that is stored at `key` in `settings`.
    ///
    /// A convenience variant of `gio.Settings.get` for 64-bit integers.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having a int64 type in the schema for `settings`.
    extern fn g_settings_get_int64(p_settings: *Settings, p_key: [*:0]const u8) i64;
    pub const getInt64 = g_settings_get_int64;

    /// Gets the value that is stored at `key` in `settings`, subject to
    /// application-level validation/mapping.
    ///
    /// You should use this function when the application needs to perform
    /// some processing on the value of the key (for example, parsing).  The
    /// `mapping` function performs that processing.  If the function
    /// indicates that the processing was unsuccessful (due to a parse error,
    /// for example) then the mapping is tried again with another value.
    ///
    /// This allows a robust 'fall back to defaults' behaviour to be
    /// implemented somewhat automatically.
    ///
    /// The first value that is tried is the user's setting for the key.  If
    /// the mapping function fails to map this value, other values may be
    /// tried in an unspecified order (system or site defaults, translated
    /// schema default values, untranslated schema default values, etc).
    ///
    /// If the mapping function fails for all possible values, one additional
    /// attempt is made: the mapping function is called with a `NULL` value.
    /// If the mapping function still indicates failure at this point then
    /// the application will be aborted.
    ///
    /// The result parameter for the `mapping` function is pointed to a
    /// `gpointer` which is initially set to `NULL`.  The same pointer is given
    /// to each invocation of `mapping`.  The final value of that `gpointer` is
    /// what is returned by this function.  `NULL` is valid; it is returned
    /// just as any other value would be.
    extern fn g_settings_get_mapped(p_settings: *Settings, p_key: [*:0]const u8, p_mapping: gio.SettingsGetMapping, p_user_data: ?*anyopaque) ?*anyopaque;
    pub const getMapped = g_settings_get_mapped;

    /// Queries the range of a key.
    extern fn g_settings_get_range(p_settings: *Settings, p_key: [*:0]const u8) *glib.Variant;
    pub const getRange = g_settings_get_range;

    /// Gets the value that is stored at `key` in `settings`.
    ///
    /// A convenience variant of `gio.Settings.get` for strings.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having a string type in the schema for `settings`.
    extern fn g_settings_get_string(p_settings: *Settings, p_key: [*:0]const u8) [*:0]u8;
    pub const getString = g_settings_get_string;

    /// A convenience variant of `gio.Settings.get` for string arrays.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having an array of strings type in the schema for `settings`.
    extern fn g_settings_get_strv(p_settings: *Settings, p_key: [*:0]const u8) [*][*:0]u8;
    pub const getStrv = g_settings_get_strv;

    /// Gets the value that is stored at `key` in `settings`.
    ///
    /// A convenience variant of `gio.Settings.get` for 32-bit unsigned
    /// integers.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having a uint32 type in the schema for `settings`.
    extern fn g_settings_get_uint(p_settings: *Settings, p_key: [*:0]const u8) c_uint;
    pub const getUint = g_settings_get_uint;

    /// Gets the value that is stored at `key` in `settings`.
    ///
    /// A convenience variant of `gio.Settings.get` for 64-bit unsigned
    /// integers.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having a uint64 type in the schema for `settings`.
    extern fn g_settings_get_uint64(p_settings: *Settings, p_key: [*:0]const u8) u64;
    pub const getUint64 = g_settings_get_uint64;

    /// Checks the "user value" of a key, if there is one.
    ///
    /// The user value of a key is the last value that was set by the user.
    ///
    /// After calling `gio.Settings.reset` this function should always return
    /// `NULL` (assuming something is not wrong with the system
    /// configuration).
    ///
    /// It is possible that `gio.Settings.getValue` will return a different
    /// value than this function.  This can happen in the case that the user
    /// set a value for a key that was subsequently locked down by the system
    /// administrator -- this function will return the user's old value.
    ///
    /// This function may be useful for adding a "reset" option to a UI or
    /// for providing indication that a particular value has been changed.
    ///
    /// It is a programmer error to give a `key` that isn't contained in the
    /// schema for `settings`.
    extern fn g_settings_get_user_value(p_settings: *Settings, p_key: [*:0]const u8) ?*glib.Variant;
    pub const getUserValue = g_settings_get_user_value;

    /// Gets the value that is stored in `settings` for `key`.
    ///
    /// It is a programmer error to give a `key` that isn't contained in the
    /// schema for `settings`.
    extern fn g_settings_get_value(p_settings: *Settings, p_key: [*:0]const u8) *glib.Variant;
    pub const getValue = g_settings_get_value;

    /// Finds out if a key can be written or not
    extern fn g_settings_is_writable(p_settings: *Settings, p_name: [*:0]const u8) c_int;
    pub const isWritable = g_settings_is_writable;

    /// Gets the list of children on `settings`.
    ///
    /// The list is exactly the list of strings for which it is not an error
    /// to call `gio.Settings.getChild`.
    ///
    /// There is little reason to call this function from "normal" code, since
    /// you should already know what children are in your schema. This function
    /// may still be useful there for introspection reasons, however.
    ///
    /// You should free the return value with `glib.strfreev` when you are done
    /// with it.
    extern fn g_settings_list_children(p_settings: *Settings) [*][*:0]u8;
    pub const listChildren = g_settings_list_children;

    /// Introspects the list of keys on `settings`.
    ///
    /// You should probably not be calling this function from "normal" code
    /// (since you should already know what keys are in your schema).  This
    /// function is intended for introspection reasons.
    ///
    /// You should free the return value with `glib.strfreev` when you are done
    /// with it.
    extern fn g_settings_list_keys(p_settings: *Settings) [*][*:0]u8;
    pub const listKeys = g_settings_list_keys;

    /// Checks if the given `value` is of the correct type and within the
    /// permitted range for `key`.
    extern fn g_settings_range_check(p_settings: *Settings, p_key: [*:0]const u8, p_value: *glib.Variant) c_int;
    pub const rangeCheck = g_settings_range_check;

    /// Resets `key` to its default value.
    ///
    /// This call resets the key, as much as possible, to its default value.
    /// That might be the value specified in the schema or the one set by the
    /// administrator.
    extern fn g_settings_reset(p_settings: *Settings, p_key: [*:0]const u8) void;
    pub const reset = g_settings_reset;

    /// Reverts all non-applied changes to the settings.  This function
    /// does nothing unless `settings` is in 'delay-apply' mode; see
    /// `gio.Settings.delay`.  In the normal case settings are always applied
    /// immediately.
    ///
    /// Change notifications will be emitted for affected keys.
    extern fn g_settings_revert(p_settings: *Settings) void;
    pub const revert = g_settings_revert;

    /// Sets `key` in `settings` to `value`.
    ///
    /// A convenience function that combines `gio.Settings.setValue` with
    /// `glib.Variant.new`.
    ///
    /// It is a programmer error to give a `key` that isn't contained in the
    /// schema for `settings` or for the `glib.VariantType` of `format` to mismatch
    /// the type given in the schema.
    extern fn g_settings_set(p_settings: *Settings, p_key: [*:0]const u8, p_format: [*:0]const u8, ...) c_int;
    pub const set = g_settings_set;

    /// Sets `key` in `settings` to `value`.
    ///
    /// A convenience variant of `gio.Settings.set` for booleans.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having a boolean type in the schema for `settings`.
    extern fn g_settings_set_boolean(p_settings: *Settings, p_key: [*:0]const u8, p_value: c_int) c_int;
    pub const setBoolean = g_settings_set_boolean;

    /// Sets `key` in `settings` to `value`.
    ///
    /// A convenience variant of `gio.Settings.set` for doubles.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having a 'double' type in the schema for `settings`.
    extern fn g_settings_set_double(p_settings: *Settings, p_key: [*:0]const u8, p_value: f64) c_int;
    pub const setDouble = g_settings_set_double;

    /// Looks up the enumerated type nick for `value` and writes it to `key`,
    /// within `settings`.
    ///
    /// It is a programmer error to give a `key` that isn't contained in the
    /// schema for `settings` or is not marked as an enumerated type, or for
    /// `value` not to be a valid value for the named type.
    ///
    /// After performing the write, accessing `key` directly with
    /// `gio.Settings.getString` will return the 'nick' associated with
    /// `value`.
    extern fn g_settings_set_enum(p_settings: *Settings, p_key: [*:0]const u8, p_value: c_int) c_int;
    pub const setEnum = g_settings_set_enum;

    /// Looks up the flags type nicks for the bits specified by `value`, puts
    /// them in an array of strings and writes the array to `key`, within
    /// `settings`.
    ///
    /// It is a programmer error to give a `key` that isn't contained in the
    /// schema for `settings` or is not marked as a flags type, or for `value`
    /// to contain any bits that are not value for the named type.
    ///
    /// After performing the write, accessing `key` directly with
    /// `gio.Settings.getStrv` will return an array of 'nicks'; one for each
    /// bit in `value`.
    extern fn g_settings_set_flags(p_settings: *Settings, p_key: [*:0]const u8, p_value: c_uint) c_int;
    pub const setFlags = g_settings_set_flags;

    /// Sets `key` in `settings` to `value`.
    ///
    /// A convenience variant of `gio.Settings.set` for 32-bit integers.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having a int32 type in the schema for `settings`.
    extern fn g_settings_set_int(p_settings: *Settings, p_key: [*:0]const u8, p_value: c_int) c_int;
    pub const setInt = g_settings_set_int;

    /// Sets `key` in `settings` to `value`.
    ///
    /// A convenience variant of `gio.Settings.set` for 64-bit integers.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having a int64 type in the schema for `settings`.
    extern fn g_settings_set_int64(p_settings: *Settings, p_key: [*:0]const u8, p_value: i64) c_int;
    pub const setInt64 = g_settings_set_int64;

    /// Sets `key` in `settings` to `value`.
    ///
    /// A convenience variant of `gio.Settings.set` for strings.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having a string type in the schema for `settings`.
    extern fn g_settings_set_string(p_settings: *Settings, p_key: [*:0]const u8, p_value: [*:0]const u8) c_int;
    pub const setString = g_settings_set_string;

    /// Sets `key` in `settings` to `value`.
    ///
    /// A convenience variant of `gio.Settings.set` for string arrays.  If
    /// `value` is `NULL`, then `key` is set to be the empty array.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having an array of strings type in the schema for `settings`.
    extern fn g_settings_set_strv(p_settings: *Settings, p_key: [*:0]const u8, p_value: ?[*]const [*:0]const u8) c_int;
    pub const setStrv = g_settings_set_strv;

    /// Sets `key` in `settings` to `value`.
    ///
    /// A convenience variant of `gio.Settings.set` for 32-bit unsigned
    /// integers.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having a uint32 type in the schema for `settings`.
    extern fn g_settings_set_uint(p_settings: *Settings, p_key: [*:0]const u8, p_value: c_uint) c_int;
    pub const setUint = g_settings_set_uint;

    /// Sets `key` in `settings` to `value`.
    ///
    /// A convenience variant of `gio.Settings.set` for 64-bit unsigned
    /// integers.
    ///
    /// It is a programmer error to give a `key` that isn't specified as
    /// having a uint64 type in the schema for `settings`.
    extern fn g_settings_set_uint64(p_settings: *Settings, p_key: [*:0]const u8, p_value: u64) c_int;
    pub const setUint64 = g_settings_set_uint64;

    /// Sets `key` in `settings` to `value`.
    ///
    /// It is a programmer error to give a `key` that isn't contained in the
    /// schema for `settings` or for `value` to have the incorrect type, per
    /// the schema.
    ///
    /// If `value` is floating then this function consumes the reference.
    extern fn g_settings_set_value(p_settings: *Settings, p_key: [*:0]const u8, p_value: *glib.Variant) c_int;
    pub const setValue = g_settings_set_value;

    extern fn g_settings_get_type() usize;
    pub const getGObjectType = g_settings_get_type;

    extern fn g_object_ref(p_self: *gio.Settings) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Settings) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Settings, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `GSettingsBackend` interface defines a generic interface for
/// non-strictly-typed data that is stored in a hierarchy. To implement
/// an alternative storage backend for `gio.Settings`, you need to
/// implement the `GSettingsBackend` interface and then make it implement the
/// extension point `G_SETTINGS_BACKEND_EXTENSION_POINT_NAME`.
///
/// The interface defines methods for reading and writing values, a
/// method for determining if writing of certain values will fail
/// (lockdown) and a change notification mechanism.
///
/// The semantics of the interface are very precisely defined and
/// implementations must carefully adhere to the expectations of
/// callers that are documented on each of the interface methods.
///
/// Some of the `GSettingsBackend` functions accept or return a
/// `glib.Tree`. These trees always have strings as keys and
/// `glib.Variant` as values.
///
/// The `GSettingsBackend` API is exported to allow third-party
/// implementations, but does not carry the same stability guarantees
/// as the public GIO API. For this reason, you have to define the
/// C preprocessor symbol `G_SETTINGS_ENABLE_BACKEND` before including
/// `gio/gsettingsbackend.h`.
pub const SettingsBackend = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.SettingsBackendClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.SettingsBackendPrivate,

    pub const virtual_methods = struct {
        /// virtual method to get permission of a key
        pub const get_permission = struct {
            pub fn call(p_class: anytype, p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: [*:0]const u8) *gio.Permission {
                return gobject.ext.as(SettingsBackend.Class, p_class).f_get_permission.?(gobject.ext.as(SettingsBackend, p_backend), p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: [*:0]const u8) callconv(.c) *gio.Permission) void {
                gobject.ext.as(SettingsBackend.Class, p_class).f_get_permission = @ptrCast(p_implementation);
            }
        };

        /// virtual method to get if a key is writable
        pub const get_writable = struct {
            pub fn call(p_class: anytype, p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: [*:0]const u8) c_int {
                return gobject.ext.as(SettingsBackend.Class, p_class).f_get_writable.?(gobject.ext.as(SettingsBackend, p_backend), p_key);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: [*:0]const u8) callconv(.c) c_int) void {
                gobject.ext.as(SettingsBackend.Class, p_class).f_get_writable = @ptrCast(p_implementation);
            }
        };

        /// virtual method to read a key's value
        pub const read = struct {
            pub fn call(p_class: anytype, p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: [*:0]const u8, p_expected_type: *const glib.VariantType, p_default_value: c_int) *glib.Variant {
                return gobject.ext.as(SettingsBackend.Class, p_class).f_read.?(gobject.ext.as(SettingsBackend, p_backend), p_key, p_expected_type, p_default_value);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: [*:0]const u8, p_expected_type: *const glib.VariantType, p_default_value: c_int) callconv(.c) *glib.Variant) void {
                gobject.ext.as(SettingsBackend.Class, p_class).f_read = @ptrCast(p_implementation);
            }
        };

        /// virtual method to read user's key value
        pub const read_user_value = struct {
            pub fn call(p_class: anytype, p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: [*:0]const u8, p_expected_type: *const glib.VariantType) *glib.Variant {
                return gobject.ext.as(SettingsBackend.Class, p_class).f_read_user_value.?(gobject.ext.as(SettingsBackend, p_backend), p_key, p_expected_type);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: [*:0]const u8, p_expected_type: *const glib.VariantType) callconv(.c) *glib.Variant) void {
                gobject.ext.as(SettingsBackend.Class, p_class).f_read_user_value = @ptrCast(p_implementation);
            }
        };

        /// virtual method to reset state
        pub const reset = struct {
            pub fn call(p_class: anytype, p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: [*:0]const u8, p_origin_tag: ?*anyopaque) void {
                return gobject.ext.as(SettingsBackend.Class, p_class).f_reset.?(gobject.ext.as(SettingsBackend, p_backend), p_key, p_origin_tag);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: [*:0]const u8, p_origin_tag: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(SettingsBackend.Class, p_class).f_reset = @ptrCast(p_implementation);
            }
        };

        /// virtual method to subscribe to key changes
        pub const subscribe = struct {
            pub fn call(p_class: anytype, p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_name: [*:0]const u8) void {
                return gobject.ext.as(SettingsBackend.Class, p_class).f_subscribe.?(gobject.ext.as(SettingsBackend, p_backend), p_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_name: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(SettingsBackend.Class, p_class).f_subscribe = @ptrCast(p_implementation);
            }
        };

        /// virtual method to sync state
        pub const sync = struct {
            pub fn call(p_class: anytype, p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(SettingsBackend.Class, p_class).f_sync.?(gobject.ext.as(SettingsBackend, p_backend));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(SettingsBackend.Class, p_class).f_sync = @ptrCast(p_implementation);
            }
        };

        /// virtual method to unsubscribe to key changes
        pub const unsubscribe = struct {
            pub fn call(p_class: anytype, p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_name: [*:0]const u8) void {
                return gobject.ext.as(SettingsBackend.Class, p_class).f_unsubscribe.?(gobject.ext.as(SettingsBackend, p_backend), p_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_name: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(SettingsBackend.Class, p_class).f_unsubscribe = @ptrCast(p_implementation);
            }
        };

        /// virtual method to change key's value
        pub const write = struct {
            pub fn call(p_class: anytype, p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: [*:0]const u8, p_value: *glib.Variant, p_origin_tag: ?*anyopaque) c_int {
                return gobject.ext.as(SettingsBackend.Class, p_class).f_write.?(gobject.ext.as(SettingsBackend, p_backend), p_key, p_value, p_origin_tag);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_key: [*:0]const u8, p_value: *glib.Variant, p_origin_tag: ?*anyopaque) callconv(.c) c_int) void {
                gobject.ext.as(SettingsBackend.Class, p_class).f_write = @ptrCast(p_implementation);
            }
        };

        /// virtual method to change a tree of keys
        pub const write_tree = struct {
            pub fn call(p_class: anytype, p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tree: *glib.Tree, p_origin_tag: ?*anyopaque) c_int {
                return gobject.ext.as(SettingsBackend.Class, p_class).f_write_tree.?(gobject.ext.as(SettingsBackend, p_backend), p_tree, p_origin_tag);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tree: *glib.Tree, p_origin_tag: ?*anyopaque) callconv(.c) c_int) void {
                gobject.ext.as(SettingsBackend.Class, p_class).f_write_tree = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Calculate the longest common prefix of all keys in a tree and write
    /// out an array of the key names relative to that prefix and,
    /// optionally, the value to store at each of those keys.
    ///
    /// You must free the value returned in `path`, `keys` and `values` using
    /// `glib.free`.  You should not attempt to free or unref the contents of
    /// `keys` or `values`.
    extern fn g_settings_backend_flatten_tree(p_tree: *glib.Tree, p_path: *[*:0]u8, p_keys: *[*][*:0]const u8, p_values: ?*[*]*glib.Variant) void;
    pub const flattenTree = g_settings_backend_flatten_tree;

    /// Returns the default `gio.SettingsBackend`. It is possible to override
    /// the default by setting the `GSETTINGS_BACKEND` environment variable
    /// to the name of a settings backend.
    ///
    /// The user gets a reference to the backend.
    extern fn g_settings_backend_get_default() *gio.SettingsBackend;
    pub const getDefault = g_settings_backend_get_default;

    /// Signals that a single key has possibly changed.  Backend
    /// implementations should call this if a key has possibly changed its
    /// value.
    ///
    /// `key` must be a valid key (ie starting with a slash, not containing
    /// '//', and not ending with a slash).
    ///
    /// The implementation must call this function during any call to
    /// `g_settings_backend_write`, before the call returns (except in the
    /// case that no keys are actually changed and it cares to detect this
    /// fact).  It may not rely on the existence of a mainloop for
    /// dispatching the signal later.
    ///
    /// The implementation may call this function at any other time it likes
    /// in response to other events (such as changes occurring outside of the
    /// program).  These calls may originate from a mainloop or may originate
    /// in response to any other action (including from calls to
    /// `g_settings_backend_write`).
    ///
    /// In the case that this call is in response to a call to
    /// `g_settings_backend_write` then `origin_tag` must be set to the same
    /// value that was passed to that call.
    extern fn g_settings_backend_changed(p_backend: *SettingsBackend, p_key: [*:0]const u8, p_origin_tag: ?*anyopaque) void;
    pub const changed = g_settings_backend_changed;

    /// This call is a convenience wrapper.  It gets the list of changes from
    /// `tree`, computes the longest common prefix and calls
    /// `gio.SettingsBackend.changed`.
    extern fn g_settings_backend_changed_tree(p_backend: *SettingsBackend, p_tree: *glib.Tree, p_origin_tag: ?*anyopaque) void;
    pub const changedTree = g_settings_backend_changed_tree;

    /// Signals that a list of keys have possibly changed.  Backend
    /// implementations should call this if keys have possibly changed their
    /// values.
    ///
    /// `path` must be a valid path (ie starting and ending with a slash and
    /// not containing '//').  Each string in `items` must form a valid key
    /// name when `path` is prefixed to it (ie: each item must not start or
    /// end with '/' and must not contain '//').
    ///
    /// The meaning of this signal is that any of the key names resulting
    /// from the contatenation of `path` with each item in `items` may have
    /// changed.
    ///
    /// The same rules for when notifications must occur apply as per
    /// `gio.SettingsBackend.changed`.  These two calls can be used
    /// interchangeably if exactly one item has changed (although in that
    /// case `gio.SettingsBackend.changed` is definitely preferred).
    ///
    /// For efficiency reasons, the implementation should strive for `path` to
    /// be as long as possible (ie: the longest common prefix of all of the
    /// keys that were changed) but this is not strictly required.
    extern fn g_settings_backend_keys_changed(p_backend: *SettingsBackend, p_path: [*:0]const u8, p_items: [*]const [*:0]const u8, p_origin_tag: ?*anyopaque) void;
    pub const keysChanged = g_settings_backend_keys_changed;

    /// Signals that all keys below a given path may have possibly changed.
    /// Backend implementations should call this if an entire path of keys
    /// have possibly changed their values.
    ///
    /// `path` must be a valid path (ie starting and ending with a slash and
    /// not containing '//').
    ///
    /// The meaning of this signal is that any of the key which has a name
    /// starting with `path` may have changed.
    ///
    /// The same rules for when notifications must occur apply as per
    /// `gio.SettingsBackend.changed`.  This call might be an appropriate
    /// reasponse to a 'reset' call but implementations are also free to
    /// explicitly list the keys that were affected by that call if they can
    /// easily do so.
    ///
    /// For efficiency reasons, the implementation should strive for `path` to
    /// be as long as possible (ie: the longest common prefix of all of the
    /// keys that were changed) but this is not strictly required.  As an
    /// example, if this function is called with the path of "/" then every
    /// single key in the application will be notified of a possible change.
    extern fn g_settings_backend_path_changed(p_backend: *SettingsBackend, p_path: [*:0]const u8, p_origin_tag: ?*anyopaque) void;
    pub const pathChanged = g_settings_backend_path_changed;

    /// Signals that the writability of all keys below a given path may have
    /// changed.
    ///
    /// Since GSettings performs no locking operations for itself, this call
    /// will always be made in response to external events.
    extern fn g_settings_backend_path_writable_changed(p_backend: *SettingsBackend, p_path: [*:0]const u8) void;
    pub const pathWritableChanged = g_settings_backend_path_writable_changed;

    /// Signals that the writability of a single key has possibly changed.
    ///
    /// Since GSettings performs no locking operations for itself, this call
    /// will always be made in response to external events.
    extern fn g_settings_backend_writable_changed(p_backend: *SettingsBackend, p_key: [*:0]const u8) void;
    pub const writableChanged = g_settings_backend_writable_changed;

    extern fn g_settings_backend_get_type() usize;
    pub const getGObjectType = g_settings_backend_get_type;

    extern fn g_object_ref(p_self: *gio.SettingsBackend) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SettingsBackend) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SettingsBackend, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `GSimpleAction` is the obvious simple implementation of the
/// `gio.Action` interface. This is the easiest way to create an action for
/// purposes of adding it to a `gio.SimpleActionGroup`.
pub const SimpleAction = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.Action};
    pub const Class = opaque {
        pub const Instance = SimpleAction;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// If `action` is currently enabled.
        ///
        /// If the action is disabled then calls to `gio.Action.activate` and
        /// `gio.Action.changeState` have no effect.
        pub const enabled = struct {
            pub const name = "enabled";

            pub const Type = c_int;
        };

        /// The name of the action. This is mostly meaningful for identifying
        /// the action once it has been added to a `gio.SimpleActionGroup`.
        pub const name = struct {
            pub const name = "name";

            pub const Type = ?[*:0]u8;
        };

        /// The type of the parameter that must be given when activating the
        /// action.
        pub const parameter_type = struct {
            pub const name = "parameter-type";

            pub const Type = ?*glib.VariantType;
        };

        /// The state of the action, or `NULL` if the action is stateless.
        pub const state = struct {
            pub const name = "state";

            pub const Type = ?*glib.Variant;
        };

        /// The `glib.VariantType` of the state that the action has, or `NULL` if the
        /// action is stateless.
        pub const state_type = struct {
            pub const name = "state-type";

            pub const Type = ?*glib.VariantType;
        };
    };

    pub const signals = struct {
        /// Indicates that the action was just activated.
        ///
        /// `parameter` will always be of the expected type, i.e. the parameter type
        /// specified when the action was created. If an incorrect type is given when
        /// activating the action, this signal is not emitted.
        ///
        /// Since GLib 2.40, if no handler is connected to this signal then the
        /// default behaviour for boolean-stated actions with a `NULL` parameter
        /// type is to toggle them via the `gio.SimpleAction.signals.change`-state signal.
        /// For stateful actions where the state type is equal to the parameter
        /// type, the default is to forward them directly to
        /// `gio.SimpleAction.signals.change`-state.  This should allow almost all users
        /// of `gio.SimpleAction` to connect only one handler or the other.
        pub const activate = struct {
            pub const name = "activate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_parameter: ?*glib.Variant, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(SimpleAction, p_instance))),
                    gobject.signalLookup("activate", SimpleAction.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Indicates that the action just received a request to change its
        /// state.
        ///
        /// `value` will always be of the correct state type, i.e. the type of the
        /// initial state passed to `gio.SimpleAction.newStateful`. If an incorrect
        /// type is given when requesting to change the state, this signal is not
        /// emitted.
        ///
        /// If no handler is connected to this signal then the default
        /// behaviour is to call `gio.SimpleAction.setState` to set the state
        /// to the requested value. If you connect a signal handler then no
        /// default action is taken. If the state should change then you must
        /// call `gio.SimpleAction.setState` from the handler.
        ///
        /// An example of a 'change-state' handler:
        /// ```
        /// static void
        /// change_volume_state (GSimpleAction *action,
        ///                      GVariant      *value,
        ///                      gpointer       user_data)
        /// {
        ///   gint requested;
        ///
        ///   requested = g_variant_get_int32 (value);
        ///
        ///   // Volume only goes from 0 to 10
        ///   if (0 <= requested && requested <= 10)
        ///     g_simple_action_set_state (action, value);
        /// }
        /// ```
        ///
        /// The handler need not set the state to the requested value.
        /// It could set it to any value at all, or take some other action.
        pub const change_state = struct {
            pub const name = "change-state";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_value: ?*glib.Variant, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(SimpleAction, p_instance))),
                    gobject.signalLookup("change-state", SimpleAction.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new action.
    ///
    /// The created action is stateless. See `gio.SimpleAction.newStateful` to create
    /// an action that has state.
    extern fn g_simple_action_new(p_name: [*:0]const u8, p_parameter_type: ?*const glib.VariantType) *gio.SimpleAction;
    pub const new = g_simple_action_new;

    /// Creates a new stateful action.
    ///
    /// All future state values must have the same `glib.VariantType` as the initial
    /// `state`.
    ///
    /// If the `state` `glib.Variant` is floating, it is consumed.
    extern fn g_simple_action_new_stateful(p_name: [*:0]const u8, p_parameter_type: ?*const glib.VariantType, p_state: *glib.Variant) *gio.SimpleAction;
    pub const newStateful = g_simple_action_new_stateful;

    /// Sets the action as enabled or not.
    ///
    /// An action must be enabled in order to be activated or in order to
    /// have its state changed from outside callers.
    ///
    /// This should only be called by the implementor of the action.  Users
    /// of the action should not attempt to modify its enabled flag.
    extern fn g_simple_action_set_enabled(p_simple: *SimpleAction, p_enabled: c_int) void;
    pub const setEnabled = g_simple_action_set_enabled;

    /// Sets the state of the action.
    ///
    /// This directly updates the 'state' property to the given value.
    ///
    /// This should only be called by the implementor of the action.  Users
    /// of the action should not attempt to directly modify the 'state'
    /// property.  Instead, they should call `gio.Action.changeState` to
    /// request the change.
    ///
    /// If the `value` GVariant is floating, it is consumed.
    extern fn g_simple_action_set_state(p_simple: *SimpleAction, p_value: *glib.Variant) void;
    pub const setState = g_simple_action_set_state;

    /// Sets the state hint for the action.
    ///
    /// See `gio.Action.getStateHint` for more information about
    /// action state hints.
    extern fn g_simple_action_set_state_hint(p_simple: *SimpleAction, p_state_hint: ?*glib.Variant) void;
    pub const setStateHint = g_simple_action_set_state_hint;

    extern fn g_simple_action_get_type() usize;
    pub const getGObjectType = g_simple_action_get_type;

    extern fn g_object_ref(p_self: *gio.SimpleAction) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SimpleAction) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SimpleAction, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GSimpleActionGroup` is a hash table filled with `gio.Action` objects,
/// implementing the `gio.ActionGroup` and `gio.ActionMap`
/// interfaces.
pub const SimpleActionGroup = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gio.ActionGroup, gio.ActionMap };
    pub const Class = gio.SimpleActionGroupClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.SimpleActionGroupPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new, empty, `gio.SimpleActionGroup`.
    extern fn g_simple_action_group_new() *gio.SimpleActionGroup;
    pub const new = g_simple_action_group_new;

    /// A convenience function for creating multiple `gio.SimpleAction` instances
    /// and adding them to the action group.
    extern fn g_simple_action_group_add_entries(p_simple: *SimpleActionGroup, p_entries: [*]const gio.ActionEntry, p_n_entries: c_int, p_user_data: ?*anyopaque) void;
    pub const addEntries = g_simple_action_group_add_entries;

    /// Adds an action to the action group.
    ///
    /// If the action group already contains an action with the same name as
    /// `action` then the old action is dropped from the group.
    ///
    /// The action group takes its own reference on `action`.
    extern fn g_simple_action_group_insert(p_simple: *SimpleActionGroup, p_action: *gio.Action) void;
    pub const insert = g_simple_action_group_insert;

    /// Looks up the action with the name `action_name` in the group.
    ///
    /// If no such action exists, returns `NULL`.
    extern fn g_simple_action_group_lookup(p_simple: *SimpleActionGroup, p_action_name: [*:0]const u8) *gio.Action;
    pub const lookup = g_simple_action_group_lookup;

    /// Removes the named action from the action group.
    ///
    /// If no action of this name is in the group then nothing happens.
    extern fn g_simple_action_group_remove(p_simple: *SimpleActionGroup, p_action_name: [*:0]const u8) void;
    pub const remove = g_simple_action_group_remove;

    extern fn g_simple_action_group_get_type() usize;
    pub const getGObjectType = g_simple_action_group_get_type;

    extern fn g_object_ref(p_self: *gio.SimpleActionGroup) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SimpleActionGroup) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SimpleActionGroup, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// As of GLib 2.46, `GSimpleAsyncResult` is deprecated in favor of
/// `gio.Task`, which provides a simpler API.
///
/// `GSimpleAsyncResult` implements `gio.AsyncResult`.
///
/// `GSimpleAsyncResult` handles `gio.AsyncReadyCallback`s, error
/// reporting, operation cancellation and the final state of an operation,
/// completely transparent to the application. Results can be returned
/// as a pointer e.g. for functions that return data that is collected
/// asynchronously, a boolean value for checking the success or failure
/// of an operation, or a `gssize` for operations which return the number
/// of bytes modified by the operation; all of the simple return cases
/// are covered.
///
/// Most of the time, an application will not need to know of the details
/// of this API; it is handled transparently, and any necessary operations
/// are handled by `gio.AsyncResult`’s interface. However, if implementing
/// a new GIO module, for writing language bindings, or for complex
/// applications that need better control of how asynchronous operations
/// are completed, it is important to understand this functionality.
///
/// `GSimpleAsyncResult`s are tagged with the calling function to ensure
/// that asynchronous functions and their finishing functions are used
/// together correctly.
///
/// To create a new `GSimpleAsyncResult`, call `gio.SimpleAsyncResult.new`.
/// If the result needs to be created for a `GError`, use
/// `gio.SimpleAsyncResult.newFromError` or
/// `gio.SimpleAsyncResult.newTakeError`. If a `GError` is not available
/// (e.g. the asynchronous operation doesn’t take a `GError` argument),
/// but the result still needs to be created for an error condition, use
/// `gio.SimpleAsyncResult.newError` (or
/// `gio.SimpleAsyncResult.setErrorVa` if your application or binding
/// requires passing a variable argument list directly), and the error can then
/// be propagated through the use of
/// `gio.SimpleAsyncResult.propagateError`.
///
/// An asynchronous operation can be made to ignore a cancellation event by
/// calling `gio.SimpleAsyncResult.setHandleCancellation` with a
/// `GSimpleAsyncResult` for the operation and `FALSE`. This is useful for
/// operations that are dangerous to cancel, such as close (which would
/// cause a leak if cancelled before being run).
///
/// `GSimpleAsyncResult` can integrate into GLib’s event loop,
/// `glib.MainLoop`, or it can use `glib.Thread`s.
/// `gio.SimpleAsyncResult.complete` will finish an I/O task directly
/// from the point where it is called.
/// `gio.SimpleAsyncResult.completeInIdle` will finish it from an idle
/// handler in the  thread-default main context (see
/// `glib.MainContext.pushThreadDefault`) where the `GSimpleAsyncResult`
/// was created. `gio.SimpleAsyncResult.runInThread` will run the job in
/// a separate thread and then use
/// `gio.SimpleAsyncResult.completeInIdle` to deliver the result.
///
/// To set the results of an asynchronous function,
/// `gio.SimpleAsyncResult.setOpResGpointer`,
/// `gio.SimpleAsyncResult.setOpResGboolean`, and
/// `gio.SimpleAsyncResult.setOpResGssize`
/// are provided, setting the operation's result to a `gpointer`, `gboolean`, or
/// `gssize`, respectively.
///
/// Likewise, to get the result of an asynchronous function,
/// `gio.SimpleAsyncResult.getOpResGpointer`,
/// `gio.SimpleAsyncResult.getOpResGboolean`, and
/// `gio.SimpleAsyncResult.getOpResGssize` are
/// provided, getting the operation’s result as a `gpointer`, `gboolean`, and
/// `gssize`, respectively.
///
/// For the details of the requirements implementations must respect, see
/// `gio.AsyncResult`.  A typical implementation of an asynchronous
/// operation using `GSimpleAsyncResult` looks something like this:
///
/// ```c
/// static void
/// baked_cb (Cake    *cake,
///           gpointer user_data)
/// {
///   // In this example, this callback is not given a reference to the cake,
///   // so the GSimpleAsyncResult has to take a reference to it.
///   GSimpleAsyncResult *result = user_data;
///
///   if (cake == NULL)
///     g_simple_async_result_set_error (result,
///                                      BAKER_ERRORS,
///                                      BAKER_ERROR_NO_FLOUR,
///                                      "Go to the supermarket");
///   else
///     g_simple_async_result_set_op_res_gpointer (result,
///                                                g_object_ref (cake),
///                                                g_object_unref);
///
///
///   // In this example, we assume that baked_cb is called as a callback from
///   // the mainloop, so it's safe to complete the operation synchronously here.
///   // If, however, _baker_prepare_cake () might call its callback without
///   // first returning to the mainloop — inadvisable, but some APIs do so —
///   // we would need to use `gio.SimpleAsyncResult.completeInIdle`.
///   g_simple_async_result_complete (result);
///   g_object_unref (result);
/// }
///
/// void
/// baker_bake_cake_async (Baker              *self,
///                        guint               radius,
///                        GAsyncReadyCallback callback,
///                        gpointer            user_data)
/// {
///   GSimpleAsyncResult *simple;
///   Cake               *cake;
///
///   if (radius < 3)
///     {
///       g_simple_async_report_error_in_idle (G_OBJECT (self),
///                                            callback,
///                                            user_data,
///                                            BAKER_ERRORS,
///                                            BAKER_ERROR_TOO_SMALL,
///                                            "`ucm` radius cakes are silly",
///                                            radius);
///       return;
///     }
///
///   simple = g_simple_async_result_new (G_OBJECT (self),
///                                       callback,
///                                       user_data,
///                                       baker_bake_cake_async);
///   cake = _baker_get_cached_cake (self, radius);
///
///   if (cake != NULL)
///     {
///       g_simple_async_result_set_op_res_gpointer (simple,
///                                                  g_object_ref (cake),
///                                                  g_object_unref);
///       g_simple_async_result_complete_in_idle (simple);
///       g_object_unref (simple);
///       // Drop the reference returned by `_baker_get_cached_cake`;
///       // the GSimpleAsyncResult has taken its own reference.
///       g_object_unref (cake);
///       return;
///     }
///
///   _baker_prepare_cake (self, radius, baked_cb, simple);
/// }
///
/// Cake *
/// baker_bake_cake_finish (Baker        *self,
///                         GAsyncResult *result,
///                         GError      **error)
/// {
///   GSimpleAsyncResult *simple;
///   Cake               *cake;
///
///   g_return_val_if_fail (g_simple_async_result_is_valid (result,
///                                                         G_OBJECT (self),
///                                                         baker_bake_cake_async),
///                         NULL);
///
///   simple = (GSimpleAsyncResult *) result;
///
///   if (g_simple_async_result_propagate_error (simple, error))
///     return NULL;
///
///   cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
///   return g_object_ref (cake);
/// }
/// ```
pub const SimpleAsyncResult = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.AsyncResult};
    pub const Class = gio.SimpleAsyncResultClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Ensures that the data passed to the _finish function of an async
    /// operation is consistent.  Three checks are performed.
    ///
    /// First, `result` is checked to ensure that it is really a
    /// `gio.SimpleAsyncResult`.  Second, `source` is checked to ensure that it
    /// matches the source object of `result`.  Third, `source_tag` is
    /// checked to ensure that it is equal to the `source_tag` argument given
    /// to `gio.SimpleAsyncResult.new` (which, by convention, is a pointer
    /// to the _async function corresponding to the _finish function from
    /// which this function is called).  (Alternatively, if either
    /// `source_tag` or `result`'s source tag is `NULL`, then the source tag
    /// check is skipped.)
    extern fn g_simple_async_result_is_valid(p_result: *gio.AsyncResult, p_source: ?*gobject.Object, p_source_tag: ?*anyopaque) c_int;
    pub const isValid = g_simple_async_result_is_valid;

    /// Creates a `gio.SimpleAsyncResult`.
    ///
    /// The common convention is to create the `gio.SimpleAsyncResult` in the
    /// function that starts the asynchronous operation and use that same
    /// function as the `source_tag`.
    ///
    /// If your operation supports cancellation with `gio.Cancellable` (which it
    /// probably should) then you should provide the user's cancellable to
    /// `gio.SimpleAsyncResult.setCheckCancellable` immediately after
    /// this function returns.
    extern fn g_simple_async_result_new(p_source_object: ?*gobject.Object, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque, p_source_tag: ?*anyopaque) *gio.SimpleAsyncResult;
    pub const new = g_simple_async_result_new;

    /// Creates a new `gio.SimpleAsyncResult` with a set error.
    extern fn g_simple_async_result_new_error(p_source_object: ?*gobject.Object, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque, p_domain: glib.Quark, p_code: c_int, p_format: [*:0]const u8, ...) *gio.SimpleAsyncResult;
    pub const newError = g_simple_async_result_new_error;

    /// Creates a `gio.SimpleAsyncResult` from an error condition.
    extern fn g_simple_async_result_new_from_error(p_source_object: ?*gobject.Object, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque, p_error: *const glib.Error) *gio.SimpleAsyncResult;
    pub const newFromError = g_simple_async_result_new_from_error;

    /// Creates a `gio.SimpleAsyncResult` from an error condition, and takes over the
    /// caller's ownership of `error`, so the caller does not need to free it anymore.
    extern fn g_simple_async_result_new_take_error(p_source_object: ?*gobject.Object, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque, p_error: *glib.Error) *gio.SimpleAsyncResult;
    pub const newTakeError = g_simple_async_result_new_take_error;

    /// Completes an asynchronous I/O job immediately. Must be called in
    /// the thread where the asynchronous result was to be delivered, as it
    /// invokes the callback directly. If you are in a different thread use
    /// `gio.SimpleAsyncResult.completeInIdle`.
    ///
    /// Calling this function takes a reference to `simple` for as long as
    /// is needed to complete the call.
    extern fn g_simple_async_result_complete(p_simple: *SimpleAsyncResult) void;
    pub const complete = g_simple_async_result_complete;

    /// Completes an asynchronous function in an idle handler in the
    /// thread-default main context (see `glib.MainContext.pushThreadDefault`)
    /// of the thread that `simple` was initially created in
    /// (and re-pushes that context around the invocation of the callback).
    ///
    /// Calling this function takes a reference to `simple` for as long as
    /// is needed to complete the call.
    extern fn g_simple_async_result_complete_in_idle(p_simple: *SimpleAsyncResult) void;
    pub const completeInIdle = g_simple_async_result_complete_in_idle;

    /// Gets the operation result boolean from within the asynchronous result.
    extern fn g_simple_async_result_get_op_res_gboolean(p_simple: *SimpleAsyncResult) c_int;
    pub const getOpResGboolean = g_simple_async_result_get_op_res_gboolean;

    /// Gets a pointer result as returned by the asynchronous function.
    extern fn g_simple_async_result_get_op_res_gpointer(p_simple: *SimpleAsyncResult) ?*anyopaque;
    pub const getOpResGpointer = g_simple_async_result_get_op_res_gpointer;

    /// Gets a gssize from the asynchronous result.
    extern fn g_simple_async_result_get_op_res_gssize(p_simple: *SimpleAsyncResult) isize;
    pub const getOpResGssize = g_simple_async_result_get_op_res_gssize;

    /// Gets the source tag for the `gio.SimpleAsyncResult`.
    extern fn g_simple_async_result_get_source_tag(p_simple: *SimpleAsyncResult) ?*anyopaque;
    pub const getSourceTag = g_simple_async_result_get_source_tag;

    /// Propagates an error from within the simple asynchronous result to
    /// a given destination.
    ///
    /// If the `gio.Cancellable` given to a prior call to
    /// `gio.SimpleAsyncResult.setCheckCancellable` is cancelled then this
    /// function will return `TRUE` with `dest` set appropriately.
    extern fn g_simple_async_result_propagate_error(p_simple: *SimpleAsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const propagateError = g_simple_async_result_propagate_error;

    /// Runs the asynchronous job in a separate thread and then calls
    /// `gio.SimpleAsyncResult.completeInIdle` on `simple` to return
    /// the result to the appropriate main loop.
    ///
    /// Calling this function takes a reference to `simple` for as long as
    /// is needed to run the job and report its completion.
    extern fn g_simple_async_result_run_in_thread(p_simple: *SimpleAsyncResult, p_func: gio.SimpleAsyncThreadFunc, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable) void;
    pub const runInThread = g_simple_async_result_run_in_thread;

    /// Sets a `gio.Cancellable` to check before dispatching results.
    ///
    /// This function has one very specific purpose: the provided cancellable
    /// is checked at the time of `gio.SimpleAsyncResult.propagateError` If
    /// it is cancelled, these functions will return an "Operation was
    /// cancelled" error (`G_IO_ERROR_CANCELLED`).
    ///
    /// Implementors of cancellable asynchronous functions should use this in
    /// order to provide a guarantee to their callers that cancelling an
    /// async operation will reliably result in an error being returned for
    /// that operation (even if a positive result for the operation has
    /// already been sent as an idle to the main context to be dispatched).
    ///
    /// The checking described above is done regardless of any call to the
    /// unrelated `gio.SimpleAsyncResult.setHandleCancellation` function.
    extern fn g_simple_async_result_set_check_cancellable(p_simple: *SimpleAsyncResult, p_check_cancellable: ?*gio.Cancellable) void;
    pub const setCheckCancellable = g_simple_async_result_set_check_cancellable;

    /// Sets an error within the asynchronous result without a `glib.Error`.
    extern fn g_simple_async_result_set_error(p_simple: *SimpleAsyncResult, p_domain: glib.Quark, p_code: c_int, p_format: [*:0]const u8, ...) void;
    pub const setError = g_simple_async_result_set_error;

    /// Sets an error within the asynchronous result without a `glib.Error`.
    /// Unless writing a binding, see `gio.SimpleAsyncResult.setError`.
    extern fn g_simple_async_result_set_error_va(p_simple: *SimpleAsyncResult, p_domain: glib.Quark, p_code: c_int, p_format: [*:0]const u8, p_args: std.builtin.VaList) void;
    pub const setErrorVa = g_simple_async_result_set_error_va;

    /// Sets the result from a `glib.Error`.
    extern fn g_simple_async_result_set_from_error(p_simple: *SimpleAsyncResult, p_error: *const glib.Error) void;
    pub const setFromError = g_simple_async_result_set_from_error;

    /// Sets whether to handle cancellation within the asynchronous operation.
    ///
    /// This function has nothing to do with
    /// `gio.SimpleAsyncResult.setCheckCancellable`.  It only refers to the
    /// `gio.Cancellable` passed to `gio.SimpleAsyncResult.runInThread`.
    extern fn g_simple_async_result_set_handle_cancellation(p_simple: *SimpleAsyncResult, p_handle_cancellation: c_int) void;
    pub const setHandleCancellation = g_simple_async_result_set_handle_cancellation;

    /// Sets the operation result to a boolean within the asynchronous result.
    extern fn g_simple_async_result_set_op_res_gboolean(p_simple: *SimpleAsyncResult, p_op_res: c_int) void;
    pub const setOpResGboolean = g_simple_async_result_set_op_res_gboolean;

    /// Sets the operation result within the asynchronous result to a pointer.
    extern fn g_simple_async_result_set_op_res_gpointer(p_simple: *SimpleAsyncResult, p_op_res: ?*anyopaque, p_destroy_op_res: glib.DestroyNotify) void;
    pub const setOpResGpointer = g_simple_async_result_set_op_res_gpointer;

    /// Sets the operation result within the asynchronous result to
    /// the given `op_res`.
    extern fn g_simple_async_result_set_op_res_gssize(p_simple: *SimpleAsyncResult, p_op_res: isize) void;
    pub const setOpResGssize = g_simple_async_result_set_op_res_gssize;

    /// Sets the result from `error`, and takes over the caller's ownership
    /// of `error`, so the caller does not need to free it any more.
    extern fn g_simple_async_result_take_error(p_simple: *SimpleAsyncResult, p_error: *glib.Error) void;
    pub const takeError = g_simple_async_result_take_error;

    extern fn g_simple_async_result_get_type() usize;
    pub const getGObjectType = g_simple_async_result_get_type;

    extern fn g_object_ref(p_self: *gio.SimpleAsyncResult) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SimpleAsyncResult) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SimpleAsyncResult, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GSimpleIOStream` creates a `gio.IOStream` from an arbitrary
/// `gio.InputStream` and `gio.OutputStream`. This allows any pair of
/// input and output streams to be used with `gio.IOStream` methods.
///
/// This is useful when you obtained a `gio.InputStream` and a
/// `gio.OutputStream` by other means, for instance creating them with
/// platform specific methods as
/// [``gio.UnixInputStream.new``](../gio-unix/ctor.UnixInputStream.new.html)
/// (from `gio-unix-2.0.pc` / `GioUnix-2.0`), and you want to
/// take advantage of the methods provided by `gio.IOStream`.
pub const SimpleIOStream = opaque {
    pub const Parent = gio.IOStream;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = SimpleIOStream;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The `gio.InputStream` to read from.
        pub const input_stream = struct {
            pub const name = "input-stream";

            pub const Type = ?*gio.InputStream;
        };

        /// The `gio.OutputStream` to write to.
        pub const output_stream = struct {
            pub const name = "output-stream";

            pub const Type = ?*gio.OutputStream;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.SimpleIOStream` wrapping `input_stream` and `output_stream`.
    /// See also `gio.IOStream`.
    extern fn g_simple_io_stream_new(p_input_stream: *gio.InputStream, p_output_stream: *gio.OutputStream) *gio.SimpleIOStream;
    pub const new = g_simple_io_stream_new;

    extern fn g_simple_io_stream_get_type() usize;
    pub const getGObjectType = g_simple_io_stream_get_type;

    extern fn g_object_ref(p_self: *gio.SimpleIOStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SimpleIOStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SimpleIOStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GSimplePermission` is a trivial implementation of `gio.Permission`
/// that represents a permission that is either always or never allowed.  The
/// value is given at construction and doesn’t change.
///
/// Calling `gio.Permission.acquire` or `gio.Permission.release`
/// on a `GSimplePermission` will result in errors.
pub const SimplePermission = opaque {
    pub const Parent = gio.Permission;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = SimplePermission;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gio.Permission` instance that represents an action that is
    /// either always or never allowed.
    extern fn g_simple_permission_new(p_allowed: c_int) *gio.SimplePermission;
    pub const new = g_simple_permission_new;

    extern fn g_simple_permission_get_type() usize;
    pub const getGObjectType = g_simple_permission_get_type;

    extern fn g_object_ref(p_self: *gio.SimplePermission) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SimplePermission) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SimplePermission, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GSimpleProxyResolver` is a simple `gio.ProxyResolver` implementation
/// that handles a single default proxy, multiple URI-scheme-specific
/// proxies, and a list of hosts that proxies should not be used for.
///
/// `GSimpleProxyResolver` is never the default proxy resolver, but it
/// can be used as the base class for another proxy resolver
/// implementation, or it can be created and used manually, such as
/// with `gio.SocketClient.setProxyResolver`.
pub const SimpleProxyResolver = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.ProxyResolver};
    pub const Class = gio.SimpleProxyResolverClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.SimpleProxyResolverPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The default proxy URI that will be used for any URI that doesn't
        /// match `gio.SimpleProxyResolver.properties.ignore`-hosts, and doesn't match any
        /// of the schemes set with `gio.SimpleProxyResolver.setUriProxy`.
        ///
        /// Note that as a special case, if this URI starts with
        /// "socks://", `gio.SimpleProxyResolver` will treat it as referring
        /// to all three of the socks5, socks4a, and socks4 proxy types.
        pub const default_proxy = struct {
            pub const name = "default-proxy";

            pub const Type = ?[*:0]u8;
        };

        /// A list of hostnames and IP addresses that the resolver should
        /// allow direct connections to.
        ///
        /// Entries can be in one of 4 formats:
        ///
        /// - A hostname, such as "example.com", ".example.com", or
        ///   "*.example.com", any of which match "example.com" or
        ///   any subdomain of it.
        ///
        /// - An IPv4 or IPv6 address, such as "192.168.1.1",
        ///   which matches only that address.
        ///
        /// - A hostname or IP address followed by a port, such as
        ///   "example.com:80", which matches whatever the hostname or IP
        ///   address would match, but only for URLs with the (explicitly)
        ///   indicated port. In the case of an IPv6 address, the address
        ///   part must appear in brackets: "[::1]:443"
        ///
        /// - An IP address range, given by a base address and prefix length,
        ///   such as "fe80::/10", which matches any address in that range.
        ///
        /// Note that when dealing with Unicode hostnames, the matching is
        /// done against the ASCII form of the name.
        ///
        /// Also note that hostname exclusions apply only to connections made
        /// to hosts identified by name, and IP address exclusions apply only
        /// to connections made to hosts identified by address. That is, if
        /// example.com has an address of 192.168.1.1, and the :ignore-hosts list
        /// contains only "192.168.1.1", then a connection to "example.com"
        /// (eg, via a `gio.NetworkAddress`) will use the proxy, and a connection to
        /// "192.168.1.1" (eg, via a `gio.InetSocketAddress`) will not.
        ///
        /// These rules match the "ignore-hosts"/"noproxy" rules most
        /// commonly used by other applications.
        pub const ignore_hosts = struct {
            pub const name = "ignore-hosts";

            pub const Type = ?[*][*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.SimpleProxyResolver`. See
    /// `gio.SimpleProxyResolver.properties.default`-proxy and
    /// `gio.SimpleProxyResolver.properties.ignore`-hosts for more details on how the
    /// arguments are interpreted.
    extern fn g_simple_proxy_resolver_new(p_default_proxy: ?[*:0]const u8, p_ignore_hosts: ?[*][*:0]u8) *gio.ProxyResolver;
    pub const new = g_simple_proxy_resolver_new;

    /// Sets the default proxy on `resolver`, to be used for any URIs that
    /// don't match `gio.SimpleProxyResolver.properties.ignore`-hosts or a proxy set
    /// via `gio.SimpleProxyResolver.setUriProxy`.
    ///
    /// If `default_proxy` starts with "socks://",
    /// `gio.SimpleProxyResolver` will treat it as referring to all three of
    /// the socks5, socks4a, and socks4 proxy types.
    extern fn g_simple_proxy_resolver_set_default_proxy(p_resolver: *SimpleProxyResolver, p_default_proxy: ?[*:0]const u8) void;
    pub const setDefaultProxy = g_simple_proxy_resolver_set_default_proxy;

    /// Sets the list of ignored hosts.
    ///
    /// See `gio.SimpleProxyResolver.properties.ignore`-hosts for more details on how the
    /// `ignore_hosts` argument is interpreted.
    extern fn g_simple_proxy_resolver_set_ignore_hosts(p_resolver: *SimpleProxyResolver, p_ignore_hosts: [*][*:0]u8) void;
    pub const setIgnoreHosts = g_simple_proxy_resolver_set_ignore_hosts;

    /// Adds a URI-scheme-specific proxy to `resolver`; URIs whose scheme
    /// matches `uri_scheme` (and which don't match
    /// `gio.SimpleProxyResolver.properties.ignore`-hosts) will be proxied via `proxy`.
    ///
    /// As with `gio.SimpleProxyResolver.properties.default`-proxy, if `proxy` starts with
    /// "socks://", `gio.SimpleProxyResolver` will treat it
    /// as referring to all three of the socks5, socks4a, and socks4 proxy
    /// types.
    extern fn g_simple_proxy_resolver_set_uri_proxy(p_resolver: *SimpleProxyResolver, p_uri_scheme: [*:0]const u8, p_proxy: [*:0]const u8) void;
    pub const setUriProxy = g_simple_proxy_resolver_set_uri_proxy;

    extern fn g_simple_proxy_resolver_get_type() usize;
    pub const getGObjectType = g_simple_proxy_resolver_get_type;

    extern fn g_object_ref(p_self: *gio.SimpleProxyResolver) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SimpleProxyResolver) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SimpleProxyResolver, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `GSocket` is a low-level networking primitive. It is a more or less
/// direct mapping of the BSD socket API in a portable GObject based API.
/// It supports both the UNIX socket implementations and winsock2 on Windows.
///
/// `GSocket` is the platform independent base upon which the higher level
/// network primitives are based. Applications are not typically meant to
/// use it directly, but rather through classes like `gio.SocketClient`,
/// `gio.SocketService` and `gio.SocketConnection`. However there may
/// be cases where direct use of `GSocket` is useful.
///
/// `GSocket` implements the `gio.Initable` interface, so if it is manually
/// constructed by e.g. `gobject.Object.new` you must call
/// `gio.Initable.init` and check the results before using the object.
/// This is done automatically in `gio.Socket.new` and
/// `gio.Socket.newFromFd`, so these functions can return `NULL`.
///
/// Sockets operate in two general modes, blocking or non-blocking. When
/// in blocking mode all operations (which don’t take an explicit blocking
/// parameter) block until the requested operation
/// is finished or there is an error. In non-blocking mode all calls that
/// would block return immediately with a `G_IO_ERROR_WOULD_BLOCK` error.
/// To know when a call would successfully run you can call
/// `gio.Socket.conditionCheck`, or `gio.Socket.conditionWait`.
/// You can also use `gio.Socket.createSource` and attach it to a
/// `glib.MainContext` to get callbacks when I/O is possible.
/// Note that all sockets are always set to non blocking mode in the system, and
/// blocking mode is emulated in `GSocket`.
///
/// When working in non-blocking mode applications should always be able to
/// handle getting a `G_IO_ERROR_WOULD_BLOCK` error even when some other
/// function said that I/O was possible. This can easily happen in case
/// of a race condition in the application, but it can also happen for other
/// reasons. For instance, on Windows a socket is always seen as writable
/// until a write returns `G_IO_ERROR_WOULD_BLOCK`.
///
/// `GSocket`s can be either connection oriented or datagram based.
/// For connection oriented types you must first establish a connection by
/// either connecting to an address or accepting a connection from another
/// address. For connectionless socket types the target/source address is
/// specified or received in each I/O operation.
///
/// All socket file descriptors are set to be close-on-exec.
///
/// Note that creating a `GSocket` causes the signal `SIGPIPE` to be
/// ignored for the remainder of the program. If you are writing a
/// command-line utility that uses `GSocket`, you may need to take into
/// account the fact that your program will not automatically be killed
/// if it tries to write to `stdout` after it has been closed.
///
/// Like most other APIs in GLib, `GSocket` is not inherently thread safe. To use
/// a `GSocket` concurrently from multiple threads, you must implement your own
/// locking.
///
/// ## Nagle’s algorithm
///
/// Since GLib 2.80, `GSocket` will automatically set the `TCP_NODELAY` option on
/// all `G_SOCKET_TYPE_STREAM` sockets. This disables
/// [Nagle’s algorithm](https://en.wikipedia.org/wiki/Nagle`@"27s_algorithm"`) as it
/// typically does more harm than good on modern networks.
///
/// If your application needs Nagle’s algorithm enabled, call
/// `gio.Socket.setOption` after constructing a `GSocket` to enable it:
/// ```c
/// socket = g_socket_new (…, G_SOCKET_TYPE_STREAM, …);
/// if (socket != NULL)
///   {
///     g_socket_set_option (socket, IPPROTO_TCP, TCP_NODELAY, FALSE, &local_error);
///     // handle error if needed
///   }
/// ```
pub const Socket = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{ gio.DatagramBased, gio.Initable };
    pub const Class = gio.SocketClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.SocketPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Whether I/O on this socket is blocking.
        pub const blocking = struct {
            pub const name = "blocking";

            pub const Type = c_int;
        };

        /// Whether the socket should allow sending to broadcast addresses.
        pub const broadcast = struct {
            pub const name = "broadcast";

            pub const Type = c_int;
        };

        /// The socket’s address family.
        pub const family = struct {
            pub const name = "family";

            pub const Type = gio.SocketFamily;
        };

        /// The socket’s file descriptor.
        pub const fd = struct {
            pub const name = "fd";

            pub const Type = c_int;
        };

        /// Whether to keep the connection alive by sending periodic pings.
        pub const keepalive = struct {
            pub const name = "keepalive";

            pub const Type = c_int;
        };

        /// The number of outstanding connections in the listen queue.
        pub const listen_backlog = struct {
            pub const name = "listen-backlog";

            pub const Type = c_int;
        };

        /// The local address the socket is bound to.
        pub const local_address = struct {
            pub const name = "local-address";

            pub const Type = ?*gio.SocketAddress;
        };

        /// Whether outgoing multicast packets loop back to the local host.
        pub const multicast_loopback = struct {
            pub const name = "multicast-loopback";

            pub const Type = c_int;
        };

        /// Time-to-live out outgoing multicast packets
        pub const multicast_ttl = struct {
            pub const name = "multicast-ttl";

            pub const Type = c_uint;
        };

        /// The ID of the protocol to use, or `-1` for unknown.
        pub const protocol = struct {
            pub const name = "protocol";

            pub const Type = gio.SocketProtocol;
        };

        /// The remote address the socket is connected to.
        pub const remote_address = struct {
            pub const name = "remote-address";

            pub const Type = ?*gio.SocketAddress;
        };

        /// The timeout in seconds on socket I/O
        pub const timeout = struct {
            pub const name = "timeout";

            pub const Type = c_uint;
        };

        /// Time-to-live for outgoing unicast packets
        pub const ttl = struct {
            pub const name = "ttl";

            pub const Type = c_uint;
        };

        /// The socket’s type.
        pub const @"type" = struct {
            pub const name = "type";

            pub const Type = gio.SocketType;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.Socket` with the defined family, type and protocol.
    /// If `protocol` is 0 (`G_SOCKET_PROTOCOL_DEFAULT`) the default protocol type
    /// for the family and type is used.
    ///
    /// The `protocol` is a family and type specific int that specifies what
    /// kind of protocol to use. `gio.SocketProtocol` lists several common ones.
    /// Many families only support one protocol, and use 0 for this, others
    /// support several and using 0 means to use the default protocol for
    /// the family and type.
    ///
    /// The protocol id is passed directly to the operating
    /// system, so you can use protocols not listed in `gio.SocketProtocol` if you
    /// know the protocol number used for it.
    extern fn g_socket_new(p_family: gio.SocketFamily, p_type: gio.SocketType, p_protocol: gio.SocketProtocol, p_error: ?*?*glib.Error) ?*gio.Socket;
    pub const new = g_socket_new;

    /// Creates a new `gio.Socket` from a native file descriptor
    /// or winsock SOCKET handle.
    ///
    /// This reads all the settings from the file descriptor so that
    /// all properties should work. Note that the file descriptor
    /// will be set to non-blocking mode, independent on the blocking
    /// mode of the `gio.Socket`.
    ///
    /// On success, the returned `gio.Socket` takes ownership of `fd`. On failure, the
    /// caller must close `fd` themselves.
    ///
    /// Since GLib 2.46, it is no longer a fatal error to call this on a non-socket
    /// descriptor.  Instead, a GError will be set with code `G_IO_ERROR_FAILED`
    extern fn g_socket_new_from_fd(p_fd: c_int, p_error: ?*?*glib.Error) ?*gio.Socket;
    pub const newFromFd = g_socket_new_from_fd;

    /// Accept incoming connections on a connection-based socket. This removes
    /// the first outstanding connection request from the listening socket and
    /// creates a `gio.Socket` object for it.
    ///
    /// The `socket` must be bound to a local address with `gio.Socket.bind` and
    /// must be listening for incoming connections (`gio.Socket.listen`).
    ///
    /// If there are no outstanding connections then the operation will block
    /// or return `G_IO_ERROR_WOULD_BLOCK` if non-blocking I/O is enabled.
    /// To be notified of an incoming connection, wait for the `G_IO_IN` condition.
    extern fn g_socket_accept(p_socket: *Socket, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.Socket;
    pub const accept = g_socket_accept;

    /// When a socket is created it is attached to an address family, but it
    /// doesn't have an address in this family. `gio.Socket.bind` assigns the
    /// address (sometimes called name) of the socket.
    ///
    /// It is generally required to bind to a local address before you can
    /// receive connections. (See `gio.Socket.listen` and `gio.Socket.accept` ).
    /// In certain situations, you may also want to bind a socket that will be
    /// used to initiate connections, though this is not normally required.
    ///
    /// If `socket` is a TCP socket, then `allow_reuse` controls the setting
    /// of the `SO_REUSEADDR` socket option; normally it should be `TRUE` for
    /// server sockets (sockets that you will eventually call
    /// `gio.Socket.accept` on), and `FALSE` for client sockets. (Failing to
    /// set this flag on a server socket may cause `gio.Socket.bind` to return
    /// `G_IO_ERROR_ADDRESS_IN_USE` if the server program is stopped and then
    /// immediately restarted.)
    ///
    /// If `socket` is a UDP socket, then `allow_reuse` determines whether or
    /// not other UDP sockets can be bound to the same address at the same
    /// time. In particular, you can have several UDP sockets bound to the
    /// same address, and they will all receive all of the multicast and
    /// broadcast packets sent to that address. (The behavior of unicast
    /// UDP packets to an address with multiple listeners is not defined.)
    extern fn g_socket_bind(p_socket: *Socket, p_address: *gio.SocketAddress, p_allow_reuse: c_int, p_error: ?*?*glib.Error) c_int;
    pub const bind = g_socket_bind;

    /// Checks and resets the pending connect error for the socket.
    /// This is used to check for errors when `gio.Socket.connect` is
    /// used in non-blocking mode.
    extern fn g_socket_check_connect_result(p_socket: *Socket, p_error: ?*?*glib.Error) c_int;
    pub const checkConnectResult = g_socket_check_connect_result;

    /// Closes the socket, shutting down any active connection.
    ///
    /// Closing a socket does not wait for all outstanding I/O operations
    /// to finish, so the caller should not rely on them to be guaranteed
    /// to complete even if the close returns with no error.
    ///
    /// Once the socket is closed, all other operations will return
    /// `G_IO_ERROR_CLOSED`. Closing a socket multiple times will not
    /// return an error.
    ///
    /// Sockets will be automatically closed when the last reference
    /// is dropped, but you might want to call this function to make sure
    /// resources are released as early as possible.
    ///
    /// Beware that due to the way that TCP works, it is possible for
    /// recently-sent data to be lost if either you close a socket while the
    /// `G_IO_IN` condition is set, or else if the remote connection tries to
    /// send something to you after you close the socket but before it has
    /// finished reading all of the data you sent. There is no easy generic
    /// way to avoid this problem; the easiest fix is to design the network
    /// protocol such that the client will never send data "out of turn".
    /// Another solution is for the server to half-close the connection by
    /// calling `gio.Socket.shutdown` with only the `shutdown_write` flag set,
    /// and then wait for the client to notice this and close its side of the
    /// connection, after which the server can safely call `gio.Socket.close`.
    /// (This is what `gio.TcpConnection` does if you call
    /// `gio.TcpConnection.setGracefulDisconnect`. But of course, this
    /// only works if the client will close its connection after the server
    /// does.)
    extern fn g_socket_close(p_socket: *Socket, p_error: ?*?*glib.Error) c_int;
    pub const close = g_socket_close;

    /// Checks on the readiness of `socket` to perform operations.
    /// The operations specified in `condition` are checked for and masked
    /// against the currently-satisfied conditions on `socket`. The result
    /// is returned.
    ///
    /// Note that on Windows, it is possible for an operation to return
    /// `G_IO_ERROR_WOULD_BLOCK` even immediately after
    /// `gio.Socket.conditionCheck` has claimed that the socket is ready for
    /// writing. Rather than calling `gio.Socket.conditionCheck` and then
    /// writing to the socket if it succeeds, it is generally better to
    /// simply try writing to the socket right away, and try again later if
    /// the initial attempt returns `G_IO_ERROR_WOULD_BLOCK`.
    ///
    /// It is meaningless to specify `G_IO_ERR` or `G_IO_HUP` in condition;
    /// these conditions will always be set in the output if they are true.
    ///
    /// This call never blocks.
    extern fn g_socket_condition_check(p_socket: *Socket, p_condition: glib.IOCondition) glib.IOCondition;
    pub const conditionCheck = g_socket_condition_check;

    /// Waits for up to `timeout_us` microseconds for `condition` to become true
    /// on `socket`. If the condition is met, `TRUE` is returned.
    ///
    /// If `cancellable` is cancelled before the condition is met, or if
    /// `timeout_us` (or the socket's `gio.Socket.properties.timeout`) is reached before the
    /// condition is met, then `FALSE` is returned and `error`, if non-`NULL`,
    /// is set to the appropriate value (`G_IO_ERROR_CANCELLED` or
    /// `G_IO_ERROR_TIMED_OUT`).
    ///
    /// If you don't want a timeout, use `gio.Socket.conditionWait`.
    /// (Alternatively, you can pass -1 for `timeout_us`.)
    ///
    /// Note that although `timeout_us` is in microseconds for consistency with
    /// other GLib APIs, this function actually only has millisecond
    /// resolution, and the behavior is undefined if `timeout_us` is not an
    /// exact number of milliseconds.
    extern fn g_socket_condition_timed_wait(p_socket: *Socket, p_condition: glib.IOCondition, p_timeout_us: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const conditionTimedWait = g_socket_condition_timed_wait;

    /// Waits for `condition` to become true on `socket`. When the condition
    /// is met, `TRUE` is returned.
    ///
    /// If `cancellable` is cancelled before the condition is met, or if the
    /// socket has a timeout set and it is reached before the condition is
    /// met, then `FALSE` is returned and `error`, if non-`NULL`, is set to
    /// the appropriate value (`G_IO_ERROR_CANCELLED` or
    /// `G_IO_ERROR_TIMED_OUT`).
    ///
    /// See also `gio.Socket.conditionTimedWait`.
    extern fn g_socket_condition_wait(p_socket: *Socket, p_condition: glib.IOCondition, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const conditionWait = g_socket_condition_wait;

    /// Connect the socket to the specified remote address.
    ///
    /// For connection oriented socket this generally means we attempt to make
    /// a connection to the `address`. For a connection-less socket it sets
    /// the default address for `gio.Socket.send` and discards all incoming datagrams
    /// from other sources.
    ///
    /// Generally connection oriented sockets can only connect once, but
    /// connection-less sockets can connect multiple times to change the
    /// default address.
    ///
    /// If the connect call needs to do network I/O it will block, unless
    /// non-blocking I/O is enabled. Then `G_IO_ERROR_PENDING` is returned
    /// and the user can be notified of the connection finishing by waiting
    /// for the G_IO_OUT condition. The result of the connection must then be
    /// checked with `gio.Socket.checkConnectResult`.
    extern fn g_socket_connect(p_socket: *Socket, p_address: *gio.SocketAddress, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const connect = g_socket_connect;

    /// Creates a `gio.SocketConnection` subclass of the right type for
    /// `socket`.
    extern fn g_socket_connection_factory_create_connection(p_socket: *Socket) *gio.SocketConnection;
    pub const connectionFactoryCreateConnection = g_socket_connection_factory_create_connection;

    /// Creates a `glib.Source` that can be attached to a `glib.MainContext` to monitor
    /// for the availability of the specified `condition` on the socket. The `glib.Source`
    /// keeps a reference to the `socket`.
    ///
    /// The callback on the source is of the `gio.SocketSourceFunc` type.
    ///
    /// It is meaningless to specify `G_IO_ERR` or `G_IO_HUP` in `condition`;
    /// these conditions will always be reported output if they are true.
    ///
    /// `cancellable` if not `NULL` can be used to cancel the source, which will
    /// cause the source to trigger, reporting the current condition (which
    /// is likely 0 unless cancellation happened at the same time as a
    /// condition change). You can check for this in the callback using
    /// `gio.Cancellable.isCancelled`.
    ///
    /// If `socket` has a timeout set, and it is reached before `condition`
    /// occurs, the source will then trigger anyway, reporting `G_IO_IN` or
    /// `G_IO_OUT` depending on `condition`. However, `socket` will have been
    /// marked as having had a timeout, and so the next `gio.Socket` I/O method
    /// you call will then fail with a `G_IO_ERROR_TIMED_OUT`.
    extern fn g_socket_create_source(p_socket: *Socket, p_condition: glib.IOCondition, p_cancellable: ?*gio.Cancellable) *glib.Source;
    pub const createSource = g_socket_create_source;

    /// Get the amount of data pending in the OS input buffer, without blocking.
    ///
    /// If `socket` is a UDP or SCTP socket, this will return the size of
    /// just the next packet, even if additional packets are buffered after
    /// that one.
    ///
    /// Note that on Windows, this function is rather inefficient in the
    /// UDP case, and so if you know any plausible upper bound on the size
    /// of the incoming packet, it is better to just do a
    /// `gio.Socket.receive` with a buffer of that size, rather than calling
    /// `gio.Socket.getAvailableBytes` first and then doing a receive of
    /// exactly the right size.
    extern fn g_socket_get_available_bytes(p_socket: *Socket) isize;
    pub const getAvailableBytes = g_socket_get_available_bytes;

    /// Gets the blocking mode of the socket. For details on blocking I/O,
    /// see `gio.Socket.setBlocking`.
    extern fn g_socket_get_blocking(p_socket: *Socket) c_int;
    pub const getBlocking = g_socket_get_blocking;

    /// Gets the broadcast setting on `socket`; if `TRUE`,
    /// it is possible to send packets to broadcast
    /// addresses.
    extern fn g_socket_get_broadcast(p_socket: *Socket) c_int;
    pub const getBroadcast = g_socket_get_broadcast;

    /// Returns the credentials of the foreign process connected to this
    /// socket, if any (e.g. it is only supported for `G_SOCKET_FAMILY_UNIX`
    /// sockets).
    ///
    /// If this operation isn't supported on the OS, the method fails with
    /// the `G_IO_ERROR_NOT_SUPPORTED` error. On Linux this is implemented
    /// by reading the `SO_PEERCRED` option on the underlying socket.
    ///
    /// This method can be expected to be available on the following platforms:
    ///
    /// - Linux since GLib 2.26
    /// - OpenBSD since GLib 2.30
    /// - Solaris, Illumos and OpenSolaris since GLib 2.40
    /// - NetBSD since GLib 2.42
    /// - macOS, tvOS, iOS since GLib 2.66
    ///
    /// Other ways to obtain credentials from a foreign peer includes the
    /// `gio.UnixCredentialsMessage` type and
    /// `gio.UnixConnection.sendCredentials` /
    /// `gio.UnixConnection.receiveCredentials` functions.
    extern fn g_socket_get_credentials(p_socket: *Socket, p_error: ?*?*glib.Error) ?*gio.Credentials;
    pub const getCredentials = g_socket_get_credentials;

    /// Gets the socket family of the socket.
    extern fn g_socket_get_family(p_socket: *Socket) gio.SocketFamily;
    pub const getFamily = g_socket_get_family;

    /// Returns the underlying OS socket object. On unix this
    /// is a socket file descriptor, and on Windows this is
    /// a Winsock2 SOCKET handle. This may be useful for
    /// doing platform specific or otherwise unusual operations
    /// on the socket.
    extern fn g_socket_get_fd(p_socket: *Socket) c_int;
    pub const getFd = g_socket_get_fd;

    /// Gets the keepalive mode of the socket. For details on this,
    /// see `gio.Socket.setKeepalive`.
    extern fn g_socket_get_keepalive(p_socket: *Socket) c_int;
    pub const getKeepalive = g_socket_get_keepalive;

    /// Gets the listen backlog setting of the socket. For details on this,
    /// see `gio.Socket.setListenBacklog`.
    extern fn g_socket_get_listen_backlog(p_socket: *Socket) c_int;
    pub const getListenBacklog = g_socket_get_listen_backlog;

    /// Try to get the local address of a bound socket. This is only
    /// useful if the socket has been bound to a local address,
    /// either explicitly or implicitly when connecting.
    extern fn g_socket_get_local_address(p_socket: *Socket, p_error: ?*?*glib.Error) ?*gio.SocketAddress;
    pub const getLocalAddress = g_socket_get_local_address;

    /// Gets the multicast loopback setting on `socket`; if `TRUE` (the
    /// default), outgoing multicast packets will be looped back to
    /// multicast listeners on the same host.
    extern fn g_socket_get_multicast_loopback(p_socket: *Socket) c_int;
    pub const getMulticastLoopback = g_socket_get_multicast_loopback;

    /// Gets the multicast time-to-live setting on `socket`; see
    /// `gio.Socket.setMulticastTtl` for more details.
    extern fn g_socket_get_multicast_ttl(p_socket: *Socket) c_uint;
    pub const getMulticastTtl = g_socket_get_multicast_ttl;

    /// Gets the value of an integer-valued option on `socket`, as with
    /// `getsockopt`. (If you need to fetch a  non-integer-valued option,
    /// you will need to call `getsockopt` directly.)
    ///
    /// The [`<gio/gnetworking.h>`](networking.html)
    /// header pulls in system headers that will define most of the
    /// standard/portable socket options. For unusual socket protocols or
    /// platform-dependent options, you may need to include additional
    /// headers.
    ///
    /// Note that even for socket options that are a single byte in size,
    /// `value` is still a pointer to a `gint` variable, not a `guchar`;
    /// `gio.Socket.getOption` will handle the conversion internally.
    extern fn g_socket_get_option(p_socket: *Socket, p_level: c_int, p_optname: c_int, p_value: *c_int, p_error: ?*?*glib.Error) c_int;
    pub const getOption = g_socket_get_option;

    /// Gets the socket protocol id the socket was created with.
    /// In case the protocol is unknown, -1 is returned.
    extern fn g_socket_get_protocol(p_socket: *Socket) gio.SocketProtocol;
    pub const getProtocol = g_socket_get_protocol;

    /// Try to get the remote address of a connected socket. This is only
    /// useful for connection oriented sockets that have been connected.
    extern fn g_socket_get_remote_address(p_socket: *Socket, p_error: ?*?*glib.Error) ?*gio.SocketAddress;
    pub const getRemoteAddress = g_socket_get_remote_address;

    /// Gets the socket type of the socket.
    extern fn g_socket_get_socket_type(p_socket: *Socket) gio.SocketType;
    pub const getSocketType = g_socket_get_socket_type;

    /// Gets the timeout setting of the socket. For details on this, see
    /// `gio.Socket.setTimeout`.
    extern fn g_socket_get_timeout(p_socket: *Socket) c_uint;
    pub const getTimeout = g_socket_get_timeout;

    /// Gets the unicast time-to-live setting on `socket`; see
    /// `gio.Socket.setTtl` for more details.
    extern fn g_socket_get_ttl(p_socket: *Socket) c_uint;
    pub const getTtl = g_socket_get_ttl;

    /// Checks whether a socket is closed.
    extern fn g_socket_is_closed(p_socket: *Socket) c_int;
    pub const isClosed = g_socket_is_closed;

    /// Check whether the socket is connected. This is only useful for
    /// connection-oriented sockets.
    ///
    /// If using `gio.Socket.shutdown`, this function will return `TRUE` until the
    /// socket has been shut down for reading and writing. If you do a non-blocking
    /// connect, this function will not return `TRUE` until after you call
    /// `gio.Socket.checkConnectResult`.
    extern fn g_socket_is_connected(p_socket: *Socket) c_int;
    pub const isConnected = g_socket_is_connected;

    /// Registers `socket` to receive multicast messages sent to `group`.
    /// `socket` must be a `G_SOCKET_TYPE_DATAGRAM` socket, and must have
    /// been bound to an appropriate interface and port with
    /// `gio.Socket.bind`.
    ///
    /// If `iface` is `NULL`, the system will automatically pick an interface
    /// to bind to based on `group`.
    ///
    /// If `source_specific` is `TRUE`, source-specific multicast as defined
    /// in RFC 4604 is used. Note that on older platforms this may fail
    /// with a `G_IO_ERROR_NOT_SUPPORTED` error.
    ///
    /// To bind to a given source-specific multicast address, use
    /// `gio.Socket.joinMulticastGroupSsm` instead.
    extern fn g_socket_join_multicast_group(p_socket: *Socket, p_group: *gio.InetAddress, p_source_specific: c_int, p_iface: ?[*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const joinMulticastGroup = g_socket_join_multicast_group;

    /// Registers `socket` to receive multicast messages sent to `group`.
    /// `socket` must be a `G_SOCKET_TYPE_DATAGRAM` socket, and must have
    /// been bound to an appropriate interface and port with
    /// `gio.Socket.bind`.
    ///
    /// If `iface` is `NULL`, the system will automatically pick an interface
    /// to bind to based on `group`.
    ///
    /// If `source_specific` is not `NULL`, use source-specific multicast as
    /// defined in RFC 4604. Note that on older platforms this may fail
    /// with a `G_IO_ERROR_NOT_SUPPORTED` error.
    ///
    /// Note that this function can be called multiple times for the same
    /// `group` with different `source_specific` in order to receive multicast
    /// packets from more than one source.
    extern fn g_socket_join_multicast_group_ssm(p_socket: *Socket, p_group: *gio.InetAddress, p_source_specific: ?*gio.InetAddress, p_iface: ?[*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const joinMulticastGroupSsm = g_socket_join_multicast_group_ssm;

    /// Removes `socket` from the multicast group defined by `group`, `iface`,
    /// and `source_specific` (which must all have the same values they had
    /// when you joined the group).
    ///
    /// `socket` remains bound to its address and port, and can still receive
    /// unicast messages after calling this.
    ///
    /// To unbind to a given source-specific multicast address, use
    /// `gio.Socket.leaveMulticastGroupSsm` instead.
    extern fn g_socket_leave_multicast_group(p_socket: *Socket, p_group: *gio.InetAddress, p_source_specific: c_int, p_iface: ?[*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const leaveMulticastGroup = g_socket_leave_multicast_group;

    /// Removes `socket` from the multicast group defined by `group`, `iface`,
    /// and `source_specific` (which must all have the same values they had
    /// when you joined the group).
    ///
    /// `socket` remains bound to its address and port, and can still receive
    /// unicast messages after calling this.
    extern fn g_socket_leave_multicast_group_ssm(p_socket: *Socket, p_group: *gio.InetAddress, p_source_specific: ?*gio.InetAddress, p_iface: ?[*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const leaveMulticastGroupSsm = g_socket_leave_multicast_group_ssm;

    /// Marks the socket as a server socket, i.e. a socket that is used
    /// to accept incoming requests using `gio.Socket.accept`.
    ///
    /// Before calling this the socket must be bound to a local address using
    /// `gio.Socket.bind`.
    ///
    /// To set the maximum amount of outstanding clients, use
    /// `gio.Socket.setListenBacklog`.
    extern fn g_socket_listen(p_socket: *Socket, p_error: ?*?*glib.Error) c_int;
    pub const listen = g_socket_listen;

    /// Receive data (up to `size` bytes) from a socket. This is mainly used by
    /// connection-oriented sockets; it is identical to `gio.Socket.receiveFrom`
    /// with `address` set to `NULL`.
    ///
    /// For `G_SOCKET_TYPE_DATAGRAM` and `G_SOCKET_TYPE_SEQPACKET` sockets,
    /// `gio.Socket.receive` will always read either 0 or 1 complete messages from
    /// the socket. If the received message is too large to fit in `buffer`, then
    /// the data beyond `size` bytes will be discarded, without any explicit
    /// indication that this has occurred.
    ///
    /// For `G_SOCKET_TYPE_STREAM` sockets, `gio.Socket.receive` can return any
    /// number of bytes, up to `size`. If more than `size` bytes have been
    /// received, the additional data will be returned in future calls to
    /// `gio.Socket.receive`.
    ///
    /// If the socket is in blocking mode the call will block until there
    /// is some data to receive, the connection is closed, or there is an
    /// error. If there is no data available and the socket is in
    /// non-blocking mode, a `G_IO_ERROR_WOULD_BLOCK` error will be
    /// returned. To be notified when data is available, wait for the
    /// `G_IO_IN` condition.
    ///
    /// On error -1 is returned and `error` is set accordingly.
    extern fn g_socket_receive(p_socket: *Socket, p_buffer: *[*]u8, p_size: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const receive = g_socket_receive;

    /// Receives data (up to `size` bytes) from a socket.
    ///
    /// This function is a variant of `gio.Socket.receive` which returns a
    /// `glib.Bytes` rather than a plain buffer.
    ///
    /// Pass `-1` to `timeout_us` to block indefinitely until data is received (or
    /// the connection is closed, or there is an error). Pass `0` to use the default
    /// timeout from `gio.Socket.properties.timeout`, or pass a positive number to wait
    /// for that many microseconds for data before returning `G_IO_ERROR_TIMED_OUT`.
    extern fn g_socket_receive_bytes(p_socket: *Socket, p_size: usize, p_timeout_us: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.Bytes;
    pub const receiveBytes = g_socket_receive_bytes;

    /// Receive data (up to `size` bytes) from a socket.
    ///
    /// This function is a variant of `gio.Socket.receiveFrom` which returns
    /// a `glib.Bytes` rather than a plain buffer.
    ///
    /// If `address` is non-`NULL` then `address` will be set equal to the
    /// source address of the received packet.
    ///
    /// The `address` is owned by the caller.
    ///
    /// Pass `-1` to `timeout_us` to block indefinitely until data is received (or
    /// the connection is closed, or there is an error). Pass `0` to use the default
    /// timeout from `gio.Socket.properties.timeout`, or pass a positive number to wait
    /// for that many microseconds for data before returning `G_IO_ERROR_TIMED_OUT`.
    extern fn g_socket_receive_bytes_from(p_socket: *Socket, p_address: ?**gio.SocketAddress, p_size: usize, p_timeout_us: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.Bytes;
    pub const receiveBytesFrom = g_socket_receive_bytes_from;

    /// Receive data (up to `size` bytes) from a socket.
    ///
    /// If `address` is non-`NULL` then `address` will be set equal to the
    /// source address of the received packet.
    /// `address` is owned by the caller.
    ///
    /// See `gio.Socket.receive` for additional information.
    extern fn g_socket_receive_from(p_socket: *Socket, p_address: ?**gio.SocketAddress, p_buffer: *[*]u8, p_size: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const receiveFrom = g_socket_receive_from;

    /// Receive data from a socket.  For receiving multiple messages, see
    /// `gio.Socket.receiveMessages`; for easier use, see
    /// `gio.Socket.receive` and `gio.Socket.receiveFrom`.
    ///
    /// If `address` is non-`NULL` then `address` will be set equal to the
    /// source address of the received packet.
    /// `address` is owned by the caller.
    ///
    /// `vector` must point to an array of `gio.InputVector` structs and
    /// `num_vectors` must be the length of this array.  These structs
    /// describe the buffers that received data will be scattered into.
    /// If `num_vectors` is -1, then `vectors` is assumed to be terminated
    /// by a `gio.InputVector` with a `NULL` buffer pointer.
    ///
    /// As a special case, if `num_vectors` is 0 (in which case, `vectors`
    /// may of course be `NULL`), then a single byte is received and
    /// discarded. This is to facilitate the common practice of sending a
    /// single '\0' byte for the purposes of transferring ancillary data.
    ///
    /// `messages`, if non-`NULL`, will be set to point to a newly-allocated
    /// array of `gio.SocketControlMessage` instances or `NULL` if no such
    /// messages was received. These correspond to the control messages
    /// received from the kernel, one `gio.SocketControlMessage` per message
    /// from the kernel. This array is `NULL`-terminated and must be freed
    /// by the caller using `glib.free` after calling `gobject.Object.unref` on each
    /// element. If `messages` is `NULL`, any control messages received will
    /// be discarded.
    ///
    /// `num_messages`, if non-`NULL`, will be set to the number of control
    /// messages received.
    ///
    /// If both `messages` and `num_messages` are non-`NULL`, then
    /// `num_messages` gives the number of `gio.SocketControlMessage` instances
    /// in `messages` (ie: not including the `NULL` terminator).
    ///
    /// `flags` is an in/out parameter. The commonly available arguments
    /// for this are available in the `gio.SocketMsgFlags` enum, but the
    /// values there are the same as the system values, and the flags
    /// are passed in as-is, so you can pass in system-specific flags too
    /// (and `gio.Socket.receiveMessage` may pass system-specific flags out).
    /// Flags passed in to the parameter affect the receive operation; flags returned
    /// out of it are relevant to the specific returned message.
    ///
    /// As with `gio.Socket.receive`, data may be discarded if `socket` is
    /// `G_SOCKET_TYPE_DATAGRAM` or `G_SOCKET_TYPE_SEQPACKET` and you do not
    /// provide enough buffer space to read a complete message. You can pass
    /// `G_SOCKET_MSG_PEEK` in `flags` to peek at the current message without
    /// removing it from the receive queue, but there is no portable way to find
    /// out the length of the message other than by reading it into a
    /// sufficiently-large buffer.
    ///
    /// If the socket is in blocking mode the call will block until there
    /// is some data to receive, the connection is closed, or there is an
    /// error. If there is no data available and the socket is in
    /// non-blocking mode, a `G_IO_ERROR_WOULD_BLOCK` error will be
    /// returned. To be notified when data is available, wait for the
    /// `G_IO_IN` condition.
    ///
    /// On error -1 is returned and `error` is set accordingly.
    extern fn g_socket_receive_message(p_socket: *Socket, p_address: ?**gio.SocketAddress, p_vectors: [*]gio.InputVector, p_num_vectors: c_int, p_messages: ?*[*]*gio.SocketControlMessage, p_num_messages: *c_int, p_flags: *c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const receiveMessage = g_socket_receive_message;

    /// Receive multiple data messages from `socket` in one go.  This is the most
    /// complicated and fully-featured version of this call. For easier use, see
    /// `gio.Socket.receive`, `gio.Socket.receiveFrom`, and `gio.Socket.receiveMessage`.
    ///
    /// `messages` must point to an array of `gio.InputMessage` structs and
    /// `num_messages` must be the length of this array. Each `gio.InputMessage`
    /// contains a pointer to an array of `gio.InputVector` structs describing the
    /// buffers that the data received in each message will be written to. Using
    /// multiple `GInputVectors` is more memory-efficient than manually copying data
    /// out of a single buffer to multiple sources, and more system-call-efficient
    /// than making multiple calls to `gio.Socket.receive`, such as in scenarios where
    /// a lot of data packets need to be received (e.g. high-bandwidth video
    /// streaming over RTP/UDP).
    ///
    /// `flags` modify how all messages are received. The commonly available
    /// arguments for this are available in the `gio.SocketMsgFlags` enum, but the
    /// values there are the same as the system values, and the flags
    /// are passed in as-is, so you can pass in system-specific flags too. These
    /// flags affect the overall receive operation. Flags affecting individual
    /// messages are returned in `gio.InputMessage.flags`.
    ///
    /// The other members of `gio.InputMessage` are treated as described in its
    /// documentation.
    ///
    /// If `gio.Socket.properties.blocking` is `TRUE` the call will block until `num_messages` have
    /// been received, or the end of the stream is reached.
    ///
    /// If `gio.Socket.properties.blocking` is `FALSE` the call will return up to `num_messages`
    /// without blocking, or `G_IO_ERROR_WOULD_BLOCK` if no messages are queued in the
    /// operating system to be received.
    ///
    /// In blocking mode, if `gio.Socket.properties.timeout` is positive and is reached before any
    /// messages are received, `G_IO_ERROR_TIMED_OUT` is returned, otherwise up to
    /// `num_messages` are returned. (Note: This is effectively the
    /// behaviour of `MSG_WAITFORONE` with `recvmmsg`.)
    ///
    /// To be notified when messages are available, wait for the
    /// `G_IO_IN` condition. Note though that you may still receive
    /// `G_IO_ERROR_WOULD_BLOCK` from `gio.Socket.receiveMessages` even if you were
    /// previously notified of a `G_IO_IN` condition.
    ///
    /// If the remote peer closes the connection, any messages queued in the
    /// operating system will be returned, and subsequent calls to
    /// `gio.Socket.receiveMessages` will return 0 (with no error set).
    ///
    /// On error -1 is returned and `error` is set accordingly. An error will only
    /// be returned if zero messages could be received; otherwise the number of
    /// messages successfully received before the error will be returned.
    extern fn g_socket_receive_messages(p_socket: *Socket, p_messages: [*]gio.InputMessage, p_num_messages: c_uint, p_flags: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const receiveMessages = g_socket_receive_messages;

    /// This behaves exactly the same as `gio.Socket.receive`, except that
    /// the choice of blocking or non-blocking behavior is determined by
    /// the `blocking` argument rather than by `socket`'s properties.
    extern fn g_socket_receive_with_blocking(p_socket: *Socket, p_buffer: *[*]u8, p_size: usize, p_blocking: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const receiveWithBlocking = g_socket_receive_with_blocking;

    /// Tries to send `size` bytes from `buffer` on the socket. This is
    /// mainly used by connection-oriented sockets; it is identical to
    /// `gio.Socket.sendTo` with `address` set to `NULL`.
    ///
    /// If the socket is in blocking mode the call will block until there is
    /// space for the data in the socket queue. If there is no space available
    /// and the socket is in non-blocking mode a `G_IO_ERROR_WOULD_BLOCK` error
    /// will be returned. To be notified when space is available, wait for the
    /// `G_IO_OUT` condition. Note though that you may still receive
    /// `G_IO_ERROR_WOULD_BLOCK` from `gio.Socket.send` even if you were previously
    /// notified of a `G_IO_OUT` condition. (On Windows in particular, this is
    /// very common due to the way the underlying APIs work.)
    ///
    /// On error -1 is returned and `error` is set accordingly.
    extern fn g_socket_send(p_socket: *Socket, p_buffer: [*]const u8, p_size: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const send = g_socket_send;

    /// Send data to `address` on `socket`.  For sending multiple messages see
    /// `gio.Socket.sendMessages`; for easier use, see
    /// `gio.Socket.send` and `gio.Socket.sendTo`.
    ///
    /// If `address` is `NULL` then the message is sent to the default receiver
    /// (set by `gio.Socket.connect`).
    ///
    /// `vectors` must point to an array of `gio.OutputVector` structs and
    /// `num_vectors` must be the length of this array. (If `num_vectors` is -1,
    /// then `vectors` is assumed to be terminated by a `gio.OutputVector` with a
    /// `NULL` buffer pointer.) The `gio.OutputVector` structs describe the buffers
    /// that the sent data will be gathered from. Using multiple
    /// `GOutputVectors` is more memory-efficient than manually copying
    /// data from multiple sources into a single buffer, and more
    /// network-efficient than making multiple calls to `gio.Socket.send`.
    ///
    /// `messages`, if non-`NULL`, is taken to point to an array of `num_messages`
    /// `gio.SocketControlMessage` instances. These correspond to the control
    /// messages to be sent on the socket.
    /// If `num_messages` is -1 then `messages` is treated as a `NULL`-terminated
    /// array.
    ///
    /// `flags` modify how the message is sent. The commonly available arguments
    /// for this are available in the `gio.SocketMsgFlags` enum, but the
    /// values there are the same as the system values, and the flags
    /// are passed in as-is, so you can pass in system-specific flags too.
    ///
    /// If the socket is in blocking mode the call will block until there is
    /// space for the data in the socket queue. If there is no space available
    /// and the socket is in non-blocking mode a `G_IO_ERROR_WOULD_BLOCK` error
    /// will be returned. To be notified when space is available, wait for the
    /// `G_IO_OUT` condition. Note though that you may still receive
    /// `G_IO_ERROR_WOULD_BLOCK` from `gio.Socket.send` even if you were previously
    /// notified of a `G_IO_OUT` condition. (On Windows in particular, this is
    /// very common due to the way the underlying APIs work.)
    ///
    /// The sum of the sizes of each `gio.OutputVector` in vectors must not be
    /// greater than `G_MAXSSIZE`. If the message can be larger than this,
    /// then it is mandatory to use the `gio.Socket.sendMessageWithTimeout`
    /// function.
    ///
    /// On error -1 is returned and `error` is set accordingly.
    extern fn g_socket_send_message(p_socket: *Socket, p_address: ?*gio.SocketAddress, p_vectors: [*]gio.OutputVector, p_num_vectors: c_int, p_messages: ?[*]*gio.SocketControlMessage, p_num_messages: c_int, p_flags: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const sendMessage = g_socket_send_message;

    /// This behaves exactly the same as `gio.Socket.sendMessage`, except that
    /// the choice of timeout behavior is determined by the `timeout_us` argument
    /// rather than by `socket`'s properties.
    ///
    /// On error `G_POLLABLE_RETURN_FAILED` is returned and `error` is set accordingly, or
    /// if the socket is currently not writable `G_POLLABLE_RETURN_WOULD_BLOCK` is
    /// returned. `bytes_written` will contain 0 in both cases.
    extern fn g_socket_send_message_with_timeout(p_socket: *Socket, p_address: ?*gio.SocketAddress, p_vectors: [*]const gio.OutputVector, p_num_vectors: c_int, p_messages: ?[*]*gio.SocketControlMessage, p_num_messages: c_int, p_flags: c_int, p_timeout_us: i64, p_bytes_written: ?*usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) gio.PollableReturn;
    pub const sendMessageWithTimeout = g_socket_send_message_with_timeout;

    /// Send multiple data messages from `socket` in one go.  This is the most
    /// complicated and fully-featured version of this call. For easier use, see
    /// `gio.Socket.send`, `gio.Socket.sendTo`, and `gio.Socket.sendMessage`.
    ///
    /// `messages` must point to an array of `gio.OutputMessage` structs and
    /// `num_messages` must be the length of this array. Each `gio.OutputMessage`
    /// contains an address to send the data to, and a pointer to an array of
    /// `gio.OutputVector` structs to describe the buffers that the data to be sent
    /// for each message will be gathered from. Using multiple `GOutputVectors` is
    /// more memory-efficient than manually copying data from multiple sources
    /// into a single buffer, and more network-efficient than making multiple
    /// calls to `gio.Socket.send`. Sending multiple messages in one go avoids the
    /// overhead of making a lot of syscalls in scenarios where a lot of data
    /// packets need to be sent (e.g. high-bandwidth video streaming over RTP/UDP),
    /// or where the same data needs to be sent to multiple recipients.
    ///
    /// `flags` modify how the message is sent. The commonly available arguments
    /// for this are available in the `gio.SocketMsgFlags` enum, but the
    /// values there are the same as the system values, and the flags
    /// are passed in as-is, so you can pass in system-specific flags too.
    ///
    /// If the socket is in blocking mode the call will block until there is
    /// space for all the data in the socket queue. If there is no space available
    /// and the socket is in non-blocking mode a `G_IO_ERROR_WOULD_BLOCK` error
    /// will be returned if no data was written at all, otherwise the number of
    /// messages sent will be returned. To be notified when space is available,
    /// wait for the `G_IO_OUT` condition. Note though that you may still receive
    /// `G_IO_ERROR_WOULD_BLOCK` from `gio.Socket.send` even if you were previously
    /// notified of a `G_IO_OUT` condition. (On Windows in particular, this is
    /// very common due to the way the underlying APIs work.)
    ///
    /// On error -1 is returned and `error` is set accordingly. An error will only
    /// be returned if zero messages could be sent; otherwise the number of messages
    /// successfully sent before the error will be returned.
    extern fn g_socket_send_messages(p_socket: *Socket, p_messages: [*]gio.OutputMessage, p_num_messages: c_uint, p_flags: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const sendMessages = g_socket_send_messages;

    /// Tries to send `size` bytes from `buffer` to `address`. If `address` is
    /// `NULL` then the message is sent to the default receiver (set by
    /// `gio.Socket.connect`).
    ///
    /// See `gio.Socket.send` for additional information.
    extern fn g_socket_send_to(p_socket: *Socket, p_address: ?*gio.SocketAddress, p_buffer: [*]const u8, p_size: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const sendTo = g_socket_send_to;

    /// This behaves exactly the same as `gio.Socket.send`, except that
    /// the choice of blocking or non-blocking behavior is determined by
    /// the `blocking` argument rather than by `socket`'s properties.
    extern fn g_socket_send_with_blocking(p_socket: *Socket, p_buffer: [*]const u8, p_size: usize, p_blocking: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const sendWithBlocking = g_socket_send_with_blocking;

    /// Sets the blocking mode of the socket. In blocking mode
    /// all operations (which don’t take an explicit blocking parameter) block until
    /// they succeed or there is an error. In
    /// non-blocking mode all functions return results immediately or
    /// with a `G_IO_ERROR_WOULD_BLOCK` error.
    ///
    /// All sockets are created in blocking mode. However, note that the
    /// platform level socket is always non-blocking, and blocking mode
    /// is a GSocket level feature.
    extern fn g_socket_set_blocking(p_socket: *Socket, p_blocking: c_int) void;
    pub const setBlocking = g_socket_set_blocking;

    /// Sets whether `socket` should allow sending to broadcast addresses.
    /// This is `FALSE` by default.
    extern fn g_socket_set_broadcast(p_socket: *Socket, p_broadcast: c_int) void;
    pub const setBroadcast = g_socket_set_broadcast;

    /// Sets or unsets the `SO_KEEPALIVE` flag on the underlying socket. When
    /// this flag is set on a socket, the system will attempt to verify that the
    /// remote socket endpoint is still present if a sufficiently long period of
    /// time passes with no data being exchanged. If the system is unable to
    /// verify the presence of the remote endpoint, it will automatically close
    /// the connection.
    ///
    /// This option is only functional on certain kinds of sockets. (Notably,
    /// `G_SOCKET_PROTOCOL_TCP` sockets.)
    ///
    /// The exact time between pings is system- and protocol-dependent, but will
    /// normally be at least two hours. Most commonly, you would set this flag
    /// on a server socket if you want to allow clients to remain idle for long
    /// periods of time, but also want to ensure that connections are eventually
    /// garbage-collected if clients crash or become unreachable.
    extern fn g_socket_set_keepalive(p_socket: *Socket, p_keepalive: c_int) void;
    pub const setKeepalive = g_socket_set_keepalive;

    /// Sets the maximum number of outstanding connections allowed
    /// when listening on this socket. If more clients than this are
    /// connecting to the socket and the application is not handling them
    /// on time then the new connections will be refused.
    ///
    /// Note that this must be called before `gio.Socket.listen` and has no
    /// effect if called after that.
    extern fn g_socket_set_listen_backlog(p_socket: *Socket, p_backlog: c_int) void;
    pub const setListenBacklog = g_socket_set_listen_backlog;

    /// Sets whether outgoing multicast packets will be received by sockets
    /// listening on that multicast address on the same host. This is `TRUE`
    /// by default.
    extern fn g_socket_set_multicast_loopback(p_socket: *Socket, p_loopback: c_int) void;
    pub const setMulticastLoopback = g_socket_set_multicast_loopback;

    /// Sets the time-to-live for outgoing multicast datagrams on `socket`.
    /// By default, this is 1, meaning that multicast packets will not leave
    /// the local network.
    extern fn g_socket_set_multicast_ttl(p_socket: *Socket, p_ttl: c_uint) void;
    pub const setMulticastTtl = g_socket_set_multicast_ttl;

    /// Sets the value of an integer-valued option on `socket`, as with
    /// `setsockopt`. (If you need to set a non-integer-valued option,
    /// you will need to call `setsockopt` directly.)
    ///
    /// The [`<gio/gnetworking.h>`](networking.html)
    /// header pulls in system headers that will define most of the
    /// standard/portable socket options. For unusual socket protocols or
    /// platform-dependent options, you may need to include additional
    /// headers.
    extern fn g_socket_set_option(p_socket: *Socket, p_level: c_int, p_optname: c_int, p_value: c_int, p_error: ?*?*glib.Error) c_int;
    pub const setOption = g_socket_set_option;

    /// Sets the time in seconds after which I/O operations on `socket` will
    /// time out if they have not yet completed.
    ///
    /// On a blocking socket, this means that any blocking `gio.Socket`
    /// operation will time out after `timeout` seconds of inactivity,
    /// returning `G_IO_ERROR_TIMED_OUT`.
    ///
    /// On a non-blocking socket, calls to `gio.Socket.conditionWait` will
    /// also fail with `G_IO_ERROR_TIMED_OUT` after the given time. Sources
    /// created with `gio.Socket.createSource` will trigger after
    /// `timeout` seconds of inactivity, with the requested condition
    /// set, at which point calling `gio.Socket.receive`, `gio.Socket.send`,
    /// `gio.Socket.checkConnectResult`, etc, will fail with
    /// `G_IO_ERROR_TIMED_OUT`.
    ///
    /// If `timeout` is 0 (the default), operations will never time out
    /// on their own.
    ///
    /// Note that if an I/O operation is interrupted by a signal, this may
    /// cause the timeout to be reset.
    extern fn g_socket_set_timeout(p_socket: *Socket, p_timeout: c_uint) void;
    pub const setTimeout = g_socket_set_timeout;

    /// Sets the time-to-live for outgoing unicast packets on `socket`.
    /// By default the platform-specific default value is used.
    extern fn g_socket_set_ttl(p_socket: *Socket, p_ttl: c_uint) void;
    pub const setTtl = g_socket_set_ttl;

    /// Shut down part or all of a full-duplex connection.
    ///
    /// If `shutdown_read` is `TRUE` then the receiving side of the connection
    /// is shut down, and further reading is disallowed.
    ///
    /// If `shutdown_write` is `TRUE` then the sending side of the connection
    /// is shut down, and further writing is disallowed.
    ///
    /// It is allowed for both `shutdown_read` and `shutdown_write` to be `TRUE`.
    ///
    /// One example where it is useful to shut down only one side of a connection is
    /// graceful disconnect for TCP connections where you close the sending side,
    /// then wait for the other side to close the connection, thus ensuring that the
    /// other side saw all sent data.
    extern fn g_socket_shutdown(p_socket: *Socket, p_shutdown_read: c_int, p_shutdown_write: c_int, p_error: ?*?*glib.Error) c_int;
    pub const shutdown = g_socket_shutdown;

    /// Checks if a socket is capable of speaking IPv4.
    ///
    /// IPv4 sockets are capable of speaking IPv4.  On some operating systems
    /// and under some combinations of circumstances IPv6 sockets are also
    /// capable of speaking IPv4.  See RFC 3493 section 3.7 for more
    /// information.
    ///
    /// No other types of sockets are currently considered as being capable
    /// of speaking IPv4.
    extern fn g_socket_speaks_ipv4(p_socket: *Socket) c_int;
    pub const speaksIpv4 = g_socket_speaks_ipv4;

    extern fn g_socket_get_type() usize;
    pub const getGObjectType = g_socket_get_type;

    extern fn g_object_ref(p_self: *gio.Socket) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Socket) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Socket, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GSocketAddress` is the equivalent of
/// [`struct sockaddr`](man:sockaddr(3type)) and its subtypes in the BSD sockets
/// API. This is an abstract class; use `gio.InetSocketAddress` for
/// internet sockets, or `gio.UnixSocketAddress` for UNIX domain sockets.
pub const SocketAddress = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.SocketConnectable};
    pub const Class = gio.SocketAddressClass;
    f_parent_instance: gobject.Object,

    pub const virtual_methods = struct {
        /// Gets the socket family type of `address`.
        pub const get_family = struct {
            pub fn call(p_class: anytype, p_address: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) gio.SocketFamily {
                return gobject.ext.as(SocketAddress.Class, p_class).f_get_family.?(gobject.ext.as(SocketAddress, p_address));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_address: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) gio.SocketFamily) void {
                gobject.ext.as(SocketAddress.Class, p_class).f_get_family = @ptrCast(p_implementation);
            }
        };

        /// Gets the size of `address`'s native struct sockaddr.
        /// You can use this to allocate memory to pass to
        /// `gio.SocketAddress.toNative`.
        pub const get_native_size = struct {
            pub fn call(p_class: anytype, p_address: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) isize {
                return gobject.ext.as(SocketAddress.Class, p_class).f_get_native_size.?(gobject.ext.as(SocketAddress, p_address));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_address: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) isize) void {
                gobject.ext.as(SocketAddress.Class, p_class).f_get_native_size = @ptrCast(p_implementation);
            }
        };

        /// Converts a `gio.SocketAddress` to a native struct sockaddr, which can
        /// be passed to low-level functions like `connect` or `bind`.
        ///
        /// If not enough space is available, a `G_IO_ERROR_NO_SPACE` error
        /// is returned. If the address type is not known on the system
        /// then a `G_IO_ERROR_NOT_SUPPORTED` error is returned.
        pub const to_native = struct {
            pub fn call(p_class: anytype, p_address: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_dest: ?*anyopaque, p_destlen: usize, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(SocketAddress.Class, p_class).f_to_native.?(gobject.ext.as(SocketAddress, p_address), p_dest, p_destlen, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_address: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_dest: ?*anyopaque, p_destlen: usize, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(SocketAddress.Class, p_class).f_to_native = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The family of the socket address.
        pub const family = struct {
            pub const name = "family";

            pub const Type = gio.SocketFamily;
        };
    };

    pub const signals = struct {};

    /// Creates a `gio.SocketAddress` subclass corresponding to the native
    /// struct sockaddr `native`.
    extern fn g_socket_address_new_from_native(p_native: *anyopaque, p_len: usize) *gio.SocketAddress;
    pub const newFromNative = g_socket_address_new_from_native;

    /// Gets the socket family type of `address`.
    extern fn g_socket_address_get_family(p_address: *SocketAddress) gio.SocketFamily;
    pub const getFamily = g_socket_address_get_family;

    /// Gets the size of `address`'s native struct sockaddr.
    /// You can use this to allocate memory to pass to
    /// `gio.SocketAddress.toNative`.
    extern fn g_socket_address_get_native_size(p_address: *SocketAddress) isize;
    pub const getNativeSize = g_socket_address_get_native_size;

    /// Converts a `gio.SocketAddress` to a native struct sockaddr, which can
    /// be passed to low-level functions like `connect` or `bind`.
    ///
    /// If not enough space is available, a `G_IO_ERROR_NO_SPACE` error
    /// is returned. If the address type is not known on the system
    /// then a `G_IO_ERROR_NOT_SUPPORTED` error is returned.
    extern fn g_socket_address_to_native(p_address: *SocketAddress, p_dest: ?*anyopaque, p_destlen: usize, p_error: ?*?*glib.Error) c_int;
    pub const toNative = g_socket_address_to_native;

    extern fn g_socket_address_get_type() usize;
    pub const getGObjectType = g_socket_address_get_type;

    extern fn g_object_ref(p_self: *gio.SocketAddress) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SocketAddress) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SocketAddress, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GSocketAddressEnumerator` is an enumerator type for
/// `gio.SocketAddress` instances. It is returned by enumeration functions
/// such as `gio.SocketConnectable.enumerate`, which returns a
/// `GSocketAddressEnumerator` to list each `gio.SocketAddress` which could
/// be used to connect to that `gio.SocketConnectable`.
///
/// Enumeration is typically a blocking operation, so the asynchronous methods
/// `gio.SocketAddressEnumerator.nextAsync` and
/// `gio.SocketAddressEnumerator.nextFinish` should be used where
/// possible.
///
/// Each `GSocketAddressEnumerator` can only be enumerated once. Once
/// `gio.SocketAddressEnumerator.next` has returned `NULL`, further
/// enumeration with that `GSocketAddressEnumerator` is not possible, and it can
/// be unreffed.
pub const SocketAddressEnumerator = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.SocketAddressEnumeratorClass;
    f_parent_instance: gobject.Object,

    pub const virtual_methods = struct {
        /// Retrieves the next `gio.SocketAddress` from `enumerator`. Note that this
        /// may block for some amount of time. (Eg, a `gio.NetworkAddress` may need
        /// to do a DNS lookup before it can return an address.) Use
        /// `gio.SocketAddressEnumerator.nextAsync` if you need to avoid
        /// blocking.
        ///
        /// If `enumerator` is expected to yield addresses, but for some reason
        /// is unable to (eg, because of a DNS error), then the first call to
        /// `gio.SocketAddressEnumerator.next` will return an appropriate error
        /// in `*error`. However, if the first call to
        /// `gio.SocketAddressEnumerator.next` succeeds, then any further
        /// internal errors (other than `cancellable` being triggered) will be
        /// ignored.
        pub const next = struct {
            pub fn call(p_class: anytype, p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.SocketAddress {
                return gobject.ext.as(SocketAddressEnumerator.Class, p_class).f_next.?(gobject.ext.as(SocketAddressEnumerator, p_enumerator), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.SocketAddress) void {
                gobject.ext.as(SocketAddressEnumerator.Class, p_class).f_next = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously retrieves the next `gio.SocketAddress` from `enumerator`
        /// and then calls `callback`, which must call
        /// `gio.SocketAddressEnumerator.nextFinish` to get the result.
        ///
        /// It is an error to call this multiple times before the previous callback has finished.
        pub const next_async = struct {
            pub fn call(p_class: anytype, p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(SocketAddressEnumerator.Class, p_class).f_next_async.?(gobject.ext.as(SocketAddressEnumerator, p_enumerator), p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(SocketAddressEnumerator.Class, p_class).f_next_async = @ptrCast(p_implementation);
            }
        };

        /// Retrieves the result of a completed call to
        /// `gio.SocketAddressEnumerator.nextAsync`. See
        /// `gio.SocketAddressEnumerator.next` for more information about
        /// error handling.
        pub const next_finish = struct {
            pub fn call(p_class: anytype, p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.SocketAddress {
                return gobject.ext.as(SocketAddressEnumerator.Class, p_class).f_next_finish.?(gobject.ext.as(SocketAddressEnumerator, p_enumerator), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_enumerator: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.SocketAddress) void {
                gobject.ext.as(SocketAddressEnumerator.Class, p_class).f_next_finish = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Retrieves the next `gio.SocketAddress` from `enumerator`. Note that this
    /// may block for some amount of time. (Eg, a `gio.NetworkAddress` may need
    /// to do a DNS lookup before it can return an address.) Use
    /// `gio.SocketAddressEnumerator.nextAsync` if you need to avoid
    /// blocking.
    ///
    /// If `enumerator` is expected to yield addresses, but for some reason
    /// is unable to (eg, because of a DNS error), then the first call to
    /// `gio.SocketAddressEnumerator.next` will return an appropriate error
    /// in `*error`. However, if the first call to
    /// `gio.SocketAddressEnumerator.next` succeeds, then any further
    /// internal errors (other than `cancellable` being triggered) will be
    /// ignored.
    extern fn g_socket_address_enumerator_next(p_enumerator: *SocketAddressEnumerator, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.SocketAddress;
    pub const next = g_socket_address_enumerator_next;

    /// Asynchronously retrieves the next `gio.SocketAddress` from `enumerator`
    /// and then calls `callback`, which must call
    /// `gio.SocketAddressEnumerator.nextFinish` to get the result.
    ///
    /// It is an error to call this multiple times before the previous callback has finished.
    extern fn g_socket_address_enumerator_next_async(p_enumerator: *SocketAddressEnumerator, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const nextAsync = g_socket_address_enumerator_next_async;

    /// Retrieves the result of a completed call to
    /// `gio.SocketAddressEnumerator.nextAsync`. See
    /// `gio.SocketAddressEnumerator.next` for more information about
    /// error handling.
    extern fn g_socket_address_enumerator_next_finish(p_enumerator: *SocketAddressEnumerator, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.SocketAddress;
    pub const nextFinish = g_socket_address_enumerator_next_finish;

    extern fn g_socket_address_enumerator_get_type() usize;
    pub const getGObjectType = g_socket_address_enumerator_get_type;

    extern fn g_object_ref(p_self: *gio.SocketAddressEnumerator) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SocketAddressEnumerator) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SocketAddressEnumerator, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GSocketClient` is a lightweight high-level utility class for connecting to
/// a network host using a connection oriented socket type.
///
/// You create a `GSocketClient` object, set any options you want, and then
/// call a sync or async connect operation, which returns a
/// `gio.SocketConnection` subclass on success.
///
/// The type of the `gio.SocketConnection` object returned depends on the
/// type of the underlying socket that is in use. For instance, for a TCP/IP
/// connection it will be a `gio.TcpConnection`.
///
/// As `GSocketClient` is a lightweight object, you don't need to cache it. You
/// can just create a new one any time you need one.
pub const SocketClient = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.SocketClientClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.SocketClientPrivate,

    pub const virtual_methods = struct {
        pub const event = struct {
            pub fn call(p_class: anytype, p_client: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: gio.SocketClientEvent, p_connectable: *gio.SocketConnectable, p_connection: *gio.IOStream) void {
                return gobject.ext.as(SocketClient.Class, p_class).f_event.?(gobject.ext.as(SocketClient, p_client), p_event, p_connectable, p_connection);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_client: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: gio.SocketClientEvent, p_connectable: *gio.SocketConnectable, p_connection: *gio.IOStream) callconv(.c) void) void {
                gobject.ext.as(SocketClient.Class, p_class).f_event = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Enable proxy support.
        pub const enable_proxy = struct {
            pub const name = "enable-proxy";

            pub const Type = c_int;
        };

        /// The address family to use for socket construction.
        pub const family = struct {
            pub const name = "family";

            pub const Type = gio.SocketFamily;
        };

        /// The local address constructed sockets will be bound to.
        pub const local_address = struct {
            pub const name = "local-address";

            pub const Type = ?*gio.SocketAddress;
        };

        /// The protocol to use for socket construction, or `0` for default.
        pub const protocol = struct {
            pub const name = "protocol";

            pub const Type = gio.SocketProtocol;
        };

        /// The proxy resolver to use
        pub const proxy_resolver = struct {
            pub const name = "proxy-resolver";

            pub const Type = ?*gio.ProxyResolver;
        };

        /// The I/O timeout for sockets, in seconds, or `0` for none.
        pub const timeout = struct {
            pub const name = "timeout";

            pub const Type = c_uint;
        };

        /// Whether to create TLS connections.
        pub const tls = struct {
            pub const name = "tls";

            pub const Type = c_int;
        };

        /// The TLS validation flags used when creating TLS connections. The
        /// default value is `G_TLS_CERTIFICATE_VALIDATE_ALL`.
        ///
        /// GLib guarantees that if certificate verification fails, at least one
        /// flag will be set, but it does not guarantee that all possible flags
        /// will be set. Accordingly, you may not safely decide to ignore any
        /// particular type of error. For example, it would be incorrect to mask
        /// `G_TLS_CERTIFICATE_EXPIRED` if you want to allow expired certificates,
        /// because this could potentially be the only error flag set even if
        /// other problems exist with the certificate. Therefore, there is no
        /// safe way to use this property. This is not a horrible problem,
        /// though, because you should not be attempting to ignore validation
        /// errors anyway. If you really must ignore TLS certificate errors,
        /// connect to the `gio.SocketClient.signals.event` signal, wait for it to be
        /// emitted with `G_SOCKET_CLIENT_TLS_HANDSHAKING`, and use that to
        /// connect to `gio.TlsConnection.signals.accept`-certificate.
        pub const tls_validation_flags = struct {
            pub const name = "tls-validation-flags";

            pub const Type = gio.TlsCertificateFlags;
        };

        /// The type to use for socket construction.
        pub const @"type" = struct {
            pub const name = "type";

            pub const Type = gio.SocketType;
        };
    };

    pub const signals = struct {
        /// Emitted when `client`'s activity on `connectable` changes state.
        /// Among other things, this can be used to provide progress
        /// information about a network connection in the UI. The meanings of
        /// the different `event` values are as follows:
        ///
        /// - `G_SOCKET_CLIENT_RESOLVING`: `client` is about to look up `connectable`
        ///   in DNS. `connection` will be `NULL`.
        ///
        /// - `G_SOCKET_CLIENT_RESOLVED`:  `client` has successfully resolved
        ///   `connectable` in DNS. `connection` will be `NULL`.
        ///
        /// - `G_SOCKET_CLIENT_CONNECTING`: `client` is about to make a connection
        ///   to a remote host; either a proxy server or the destination server
        ///   itself. `connection` is the `gio.SocketConnection`, which is not yet
        ///   connected.  Since GLib 2.40, you can access the remote
        ///   address via `gio.SocketConnection.getRemoteAddress`.
        ///
        /// - `G_SOCKET_CLIENT_CONNECTED`: `client` has successfully connected
        ///   to a remote host. `connection` is the connected `gio.SocketConnection`.
        ///
        /// - `G_SOCKET_CLIENT_PROXY_NEGOTIATING`: `client` is about to negotiate
        ///   with a proxy to get it to connect to `connectable`. `connection` is
        ///   the `gio.SocketConnection` to the proxy server.
        ///
        /// - `G_SOCKET_CLIENT_PROXY_NEGOTIATED`: `client` has negotiated a
        ///   connection to `connectable` through a proxy server. `connection` is
        ///   the stream returned from `gio.Proxy.connect`, which may or may not
        ///   be a `gio.SocketConnection`.
        ///
        /// - `G_SOCKET_CLIENT_TLS_HANDSHAKING`: `client` is about to begin a TLS
        ///   handshake. `connection` is a `gio.TlsClientConnection`.
        ///
        /// - `G_SOCKET_CLIENT_TLS_HANDSHAKED`: `client` has successfully completed
        ///   the TLS handshake. `connection` is a `gio.TlsClientConnection`.
        ///
        /// - `G_SOCKET_CLIENT_COMPLETE`: `client` has either successfully connected
        ///   to `connectable` (in which case `connection` is the `gio.SocketConnection`
        ///   that it will be returning to the caller) or has failed (in which
        ///   case `connection` is `NULL` and the client is about to return an error).
        ///
        /// Each event except `G_SOCKET_CLIENT_COMPLETE` may be emitted
        /// multiple times (or not at all) for a given connectable (in
        /// particular, if `client` ends up attempting to connect to more than
        /// one address). However, if `client` emits the `gio.SocketClient.signals.event`
        /// signal at all for a given connectable, then it will always emit
        /// it with `G_SOCKET_CLIENT_COMPLETE` when it is done.
        ///
        /// Note that there may be additional `gio.SocketClientEvent` values in
        /// the future; unrecognized `event` values should be ignored.
        pub const event = struct {
            pub const name = "event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: gio.SocketClientEvent, p_connectable: *gio.SocketConnectable, p_connection: ?*gio.IOStream, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(SocketClient, p_instance))),
                    gobject.signalLookup("event", SocketClient.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gio.SocketClient` with the default options.
    extern fn g_socket_client_new() *gio.SocketClient;
    pub const new = g_socket_client_new;

    /// Enable proxy protocols to be handled by the application. When the
    /// indicated proxy protocol is returned by the `gio.ProxyResolver`,
    /// `gio.SocketClient` will consider this protocol as supported but will
    /// not try to find a `gio.Proxy` instance to handle handshaking. The
    /// application must check for this case by calling
    /// `gio.SocketConnection.getRemoteAddress` on the returned
    /// `gio.SocketConnection`, and seeing if it's a `gio.ProxyAddress` of the
    /// appropriate type, to determine whether or not it needs to handle
    /// the proxy handshaking itself.
    ///
    /// This should be used for proxy protocols that are dialects of
    /// another protocol such as HTTP proxy. It also allows cohabitation of
    /// proxy protocols that are reused between protocols. A good example
    /// is HTTP. It can be used to proxy HTTP, FTP and Gopher and can also
    /// be use as generic socket proxy through the HTTP CONNECT method.
    ///
    /// When the proxy is detected as being an application proxy, TLS handshake
    /// will be skipped. This is required to let the application do the proxy
    /// specific handshake.
    extern fn g_socket_client_add_application_proxy(p_client: *SocketClient, p_protocol: [*:0]const u8) void;
    pub const addApplicationProxy = g_socket_client_add_application_proxy;

    /// Tries to resolve the `connectable` and make a network connection to it.
    ///
    /// Upon a successful connection, a new `gio.SocketConnection` is constructed
    /// and returned.  The caller owns this new object and must drop their
    /// reference to it when finished with it.
    ///
    /// The type of the `gio.SocketConnection` object returned depends on the type of
    /// the underlying socket that is used. For instance, for a TCP/IP connection
    /// it will be a `gio.TcpConnection`.
    ///
    /// The socket created will be the same family as the address that the
    /// `connectable` resolves to, unless family is set with `gio.SocketClient.setFamily`
    /// or indirectly via `gio.SocketClient.setLocalAddress`. The socket type
    /// defaults to `G_SOCKET_TYPE_STREAM` but can be set with
    /// `gio.SocketClient.setSocketType`.
    ///
    /// If a local address is specified with `gio.SocketClient.setLocalAddress` the
    /// socket will be bound to this address before connecting.
    extern fn g_socket_client_connect(p_client: *SocketClient, p_connectable: *gio.SocketConnectable, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.SocketConnection;
    pub const connect = g_socket_client_connect;

    /// This is the asynchronous version of `gio.SocketClient.connect`.
    ///
    /// You may wish to prefer the asynchronous version even in synchronous
    /// command line programs because, since 2.60, it implements
    /// [RFC 8305](https://tools.ietf.org/html/rfc8305) "Happy Eyeballs"
    /// recommendations to work around long connection timeouts in networks
    /// where IPv6 is broken by performing an IPv4 connection simultaneously
    /// without waiting for IPv6 to time out, which is not supported by the
    /// synchronous call. (This is not an API guarantee, and may change in
    /// the future.)
    ///
    /// When the operation is finished `callback` will be
    /// called. You can then call `gio.SocketClient.connectFinish` to get
    /// the result of the operation.
    extern fn g_socket_client_connect_async(p_client: *SocketClient, p_connectable: *gio.SocketConnectable, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const connectAsync = g_socket_client_connect_async;

    /// Finishes an async connect operation. See `gio.SocketClient.connectAsync`
    extern fn g_socket_client_connect_finish(p_client: *SocketClient, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.SocketConnection;
    pub const connectFinish = g_socket_client_connect_finish;

    /// This is a helper function for `gio.SocketClient.connect`.
    ///
    /// Attempts to create a TCP connection to the named host.
    ///
    /// `host_and_port` may be in any of a number of recognized formats; an IPv6
    /// address, an IPv4 address, or a domain name (in which case a DNS
    /// lookup is performed).  Quoting with [] is supported for all address
    /// types.  A port override may be specified in the usual way with a
    /// colon.  Ports may be given as decimal numbers or symbolic names (in
    /// which case an /etc/services lookup is performed).
    ///
    /// If no port override is given in `host_and_port` then `default_port` will be
    /// used as the port number to connect to.
    ///
    /// In general, `host_and_port` is expected to be provided by the user (allowing
    /// them to give the hostname, and a port override if necessary) and
    /// `default_port` is expected to be provided by the application.
    ///
    /// In the case that an IP address is given, a single connection
    /// attempt is made.  In the case that a name is given, multiple
    /// connection attempts may be made, in turn and according to the
    /// number of address records in DNS, until a connection succeeds.
    ///
    /// Upon a successful connection, a new `gio.SocketConnection` is constructed
    /// and returned.  The caller owns this new object and must drop their
    /// reference to it when finished with it.
    ///
    /// In the event of any failure (DNS error, service not found, no hosts
    /// connectable) `NULL` is returned and `error` (if non-`NULL`) is set
    /// accordingly.
    extern fn g_socket_client_connect_to_host(p_client: *SocketClient, p_host_and_port: [*:0]const u8, p_default_port: u16, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.SocketConnection;
    pub const connectToHost = g_socket_client_connect_to_host;

    /// This is the asynchronous version of `gio.SocketClient.connectToHost`.
    ///
    /// When the operation is finished `callback` will be
    /// called. You can then call `gio.SocketClient.connectToHostFinish` to get
    /// the result of the operation.
    extern fn g_socket_client_connect_to_host_async(p_client: *SocketClient, p_host_and_port: [*:0]const u8, p_default_port: u16, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const connectToHostAsync = g_socket_client_connect_to_host_async;

    /// Finishes an async connect operation. See `gio.SocketClient.connectToHostAsync`
    extern fn g_socket_client_connect_to_host_finish(p_client: *SocketClient, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.SocketConnection;
    pub const connectToHostFinish = g_socket_client_connect_to_host_finish;

    /// Attempts to create a TCP connection to a service.
    ///
    /// This call looks up the SRV record for `service` at `domain` for the
    /// "tcp" protocol.  It then attempts to connect, in turn, to each of
    /// the hosts providing the service until either a connection succeeds
    /// or there are no hosts remaining.
    ///
    /// Upon a successful connection, a new `gio.SocketConnection` is constructed
    /// and returned.  The caller owns this new object and must drop their
    /// reference to it when finished with it.
    ///
    /// In the event of any failure (DNS error, service not found, no hosts
    /// connectable) `NULL` is returned and `error` (if non-`NULL`) is set
    /// accordingly.
    extern fn g_socket_client_connect_to_service(p_client: *SocketClient, p_domain: [*:0]const u8, p_service: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.SocketConnection;
    pub const connectToService = g_socket_client_connect_to_service;

    /// This is the asynchronous version of
    /// `gio.SocketClient.connectToService`.
    extern fn g_socket_client_connect_to_service_async(p_client: *SocketClient, p_domain: [*:0]const u8, p_service: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const connectToServiceAsync = g_socket_client_connect_to_service_async;

    /// Finishes an async connect operation. See `gio.SocketClient.connectToServiceAsync`
    extern fn g_socket_client_connect_to_service_finish(p_client: *SocketClient, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.SocketConnection;
    pub const connectToServiceFinish = g_socket_client_connect_to_service_finish;

    /// This is a helper function for `gio.SocketClient.connect`.
    ///
    /// Attempts to create a TCP connection with a network URI.
    ///
    /// `uri` may be any valid URI containing an "authority" (hostname/port)
    /// component. If a port is not specified in the URI, `default_port`
    /// will be used. TLS will be negotiated if `gio.SocketClient.properties.tls` is `TRUE`.
    /// (`gio.SocketClient` does not know to automatically assume TLS for
    /// certain URI schemes.)
    ///
    /// Using this rather than `gio.SocketClient.connect` or
    /// `gio.SocketClient.connectToHost` allows `gio.SocketClient` to
    /// determine when to use application-specific proxy protocols.
    ///
    /// Upon a successful connection, a new `gio.SocketConnection` is constructed
    /// and returned.  The caller owns this new object and must drop their
    /// reference to it when finished with it.
    ///
    /// In the event of any failure (DNS error, service not found, no hosts
    /// connectable) `NULL` is returned and `error` (if non-`NULL`) is set
    /// accordingly.
    extern fn g_socket_client_connect_to_uri(p_client: *SocketClient, p_uri: [*:0]const u8, p_default_port: u16, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.SocketConnection;
    pub const connectToUri = g_socket_client_connect_to_uri;

    /// This is the asynchronous version of `gio.SocketClient.connectToUri`.
    ///
    /// When the operation is finished `callback` will be
    /// called. You can then call `gio.SocketClient.connectToUriFinish` to get
    /// the result of the operation.
    extern fn g_socket_client_connect_to_uri_async(p_client: *SocketClient, p_uri: [*:0]const u8, p_default_port: u16, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const connectToUriAsync = g_socket_client_connect_to_uri_async;

    /// Finishes an async connect operation. See `gio.SocketClient.connectToUriAsync`
    extern fn g_socket_client_connect_to_uri_finish(p_client: *SocketClient, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.SocketConnection;
    pub const connectToUriFinish = g_socket_client_connect_to_uri_finish;

    /// Gets the proxy enable state; see `gio.SocketClient.setEnableProxy`
    extern fn g_socket_client_get_enable_proxy(p_client: *SocketClient) c_int;
    pub const getEnableProxy = g_socket_client_get_enable_proxy;

    /// Gets the socket family of the socket client.
    ///
    /// See `gio.SocketClient.setFamily` for details.
    extern fn g_socket_client_get_family(p_client: *SocketClient) gio.SocketFamily;
    pub const getFamily = g_socket_client_get_family;

    /// Gets the local address of the socket client.
    ///
    /// See `gio.SocketClient.setLocalAddress` for details.
    extern fn g_socket_client_get_local_address(p_client: *SocketClient) ?*gio.SocketAddress;
    pub const getLocalAddress = g_socket_client_get_local_address;

    /// Gets the protocol name type of the socket client.
    ///
    /// See `gio.SocketClient.setProtocol` for details.
    extern fn g_socket_client_get_protocol(p_client: *SocketClient) gio.SocketProtocol;
    pub const getProtocol = g_socket_client_get_protocol;

    /// Gets the `gio.ProxyResolver` being used by `client`. Normally, this will
    /// be the resolver returned by `gio.proxyResolverGetDefault`, but you
    /// can override it with `gio.SocketClient.setProxyResolver`.
    extern fn g_socket_client_get_proxy_resolver(p_client: *SocketClient) *gio.ProxyResolver;
    pub const getProxyResolver = g_socket_client_get_proxy_resolver;

    /// Gets the socket type of the socket client.
    ///
    /// See `gio.SocketClient.setSocketType` for details.
    extern fn g_socket_client_get_socket_type(p_client: *SocketClient) gio.SocketType;
    pub const getSocketType = g_socket_client_get_socket_type;

    /// Gets the I/O timeout time for sockets created by `client`.
    ///
    /// See `gio.SocketClient.setTimeout` for details.
    extern fn g_socket_client_get_timeout(p_client: *SocketClient) c_uint;
    pub const getTimeout = g_socket_client_get_timeout;

    /// Gets whether `client` creates TLS connections. See
    /// `gio.SocketClient.setTls` for details.
    extern fn g_socket_client_get_tls(p_client: *SocketClient) c_int;
    pub const getTls = g_socket_client_get_tls;

    /// Gets the TLS validation flags used creating TLS connections via
    /// `client`.
    ///
    /// This function does not work as originally designed and is impossible
    /// to use correctly. See `gio.SocketClient.properties.tls`-validation-flags for more
    /// information.
    extern fn g_socket_client_get_tls_validation_flags(p_client: *SocketClient) gio.TlsCertificateFlags;
    pub const getTlsValidationFlags = g_socket_client_get_tls_validation_flags;

    /// Sets whether or not `client` attempts to make connections via a
    /// proxy server. When enabled (the default), `gio.SocketClient` will use a
    /// `gio.ProxyResolver` to determine if a proxy protocol such as SOCKS is
    /// needed, and automatically do the necessary proxy negotiation.
    ///
    /// See also `gio.SocketClient.setProxyResolver`.
    extern fn g_socket_client_set_enable_proxy(p_client: *SocketClient, p_enable: c_int) void;
    pub const setEnableProxy = g_socket_client_set_enable_proxy;

    /// Sets the socket family of the socket client.
    /// If this is set to something other than `G_SOCKET_FAMILY_INVALID`
    /// then the sockets created by this object will be of the specified
    /// family.
    ///
    /// This might be useful for instance if you want to force the local
    /// connection to be an ipv4 socket, even though the address might
    /// be an ipv6 mapped to ipv4 address.
    extern fn g_socket_client_set_family(p_client: *SocketClient, p_family: gio.SocketFamily) void;
    pub const setFamily = g_socket_client_set_family;

    /// Sets the local address of the socket client.
    /// The sockets created by this object will bound to the
    /// specified address (if not `NULL`) before connecting.
    ///
    /// This is useful if you want to ensure that the local
    /// side of the connection is on a specific port, or on
    /// a specific interface.
    extern fn g_socket_client_set_local_address(p_client: *SocketClient, p_address: ?*gio.SocketAddress) void;
    pub const setLocalAddress = g_socket_client_set_local_address;

    /// Sets the protocol of the socket client.
    /// The sockets created by this object will use of the specified
    /// protocol.
    ///
    /// If `protocol` is `G_SOCKET_PROTOCOL_DEFAULT` that means to use the default
    /// protocol for the socket family and type.
    extern fn g_socket_client_set_protocol(p_client: *SocketClient, p_protocol: gio.SocketProtocol) void;
    pub const setProtocol = g_socket_client_set_protocol;

    /// Overrides the `gio.ProxyResolver` used by `client`. You can call this if
    /// you want to use specific proxies, rather than using the system
    /// default proxy settings.
    ///
    /// Note that whether or not the proxy resolver is actually used
    /// depends on the setting of `gio.SocketClient.properties.enable`-proxy, which is not
    /// changed by this function (but which is `TRUE` by default)
    extern fn g_socket_client_set_proxy_resolver(p_client: *SocketClient, p_proxy_resolver: ?*gio.ProxyResolver) void;
    pub const setProxyResolver = g_socket_client_set_proxy_resolver;

    /// Sets the socket type of the socket client.
    /// The sockets created by this object will be of the specified
    /// type.
    ///
    /// It doesn't make sense to specify a type of `G_SOCKET_TYPE_DATAGRAM`,
    /// as GSocketClient is used for connection oriented services.
    extern fn g_socket_client_set_socket_type(p_client: *SocketClient, p_type: gio.SocketType) void;
    pub const setSocketType = g_socket_client_set_socket_type;

    /// Sets the I/O timeout for sockets created by `client`. `timeout` is a
    /// time in seconds, or 0 for no timeout (the default).
    ///
    /// The timeout value affects the initial connection attempt as well,
    /// so setting this may cause calls to `gio.SocketClient.connect`, etc,
    /// to fail with `G_IO_ERROR_TIMED_OUT`.
    extern fn g_socket_client_set_timeout(p_client: *SocketClient, p_timeout: c_uint) void;
    pub const setTimeout = g_socket_client_set_timeout;

    /// Sets whether `client` creates TLS (aka SSL) connections. If `tls` is
    /// `TRUE`, `client` will wrap its connections in a `gio.TlsClientConnection`
    /// and perform a TLS handshake when connecting.
    ///
    /// Note that since `gio.SocketClient` must return a `gio.SocketConnection`,
    /// but `gio.TlsClientConnection` is not a `gio.SocketConnection`, this
    /// actually wraps the resulting `gio.TlsClientConnection` in a
    /// `gio.TcpWrapperConnection` when returning it. You can use
    /// `gio.TcpWrapperConnection.getBaseIoStream` on the return value
    /// to extract the `gio.TlsClientConnection`.
    ///
    /// If you need to modify the behavior of the TLS handshake (eg, by
    /// setting a client-side certificate to use, or connecting to the
    /// `gio.TlsConnection.signals.accept`-certificate signal), you can connect to
    /// `client`'s `gio.SocketClient.signals.event` signal and wait for it to be
    /// emitted with `G_SOCKET_CLIENT_TLS_HANDSHAKING`, which will give you
    /// a chance to see the `gio.TlsClientConnection` before the handshake
    /// starts.
    extern fn g_socket_client_set_tls(p_client: *SocketClient, p_tls: c_int) void;
    pub const setTls = g_socket_client_set_tls;

    /// Sets the TLS validation flags used when creating TLS connections
    /// via `client`. The default value is `G_TLS_CERTIFICATE_VALIDATE_ALL`.
    ///
    /// This function does not work as originally designed and is impossible
    /// to use correctly. See `gio.SocketClient.properties.tls`-validation-flags for more
    /// information.
    extern fn g_socket_client_set_tls_validation_flags(p_client: *SocketClient, p_flags: gio.TlsCertificateFlags) void;
    pub const setTlsValidationFlags = g_socket_client_set_tls_validation_flags;

    extern fn g_socket_client_get_type() usize;
    pub const getGObjectType = g_socket_client_get_type;

    extern fn g_object_ref(p_self: *gio.SocketClient) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SocketClient) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SocketClient, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GSocketConnection` is a `gio.IOStream` for a connected socket. They
/// can be created either by `gio.SocketClient` when connecting to a host,
/// or by `gio.SocketListener` when accepting a new client.
///
/// The type of the `GSocketConnection` object returned from these calls
/// depends on the type of the underlying socket that is in use. For
/// instance, for a TCP/IP connection it will be a `gio.TcpConnection`.
///
/// Choosing what type of object to construct is done with the socket
/// connection factory, and it is possible for third parties to register
/// custom socket connection types for specific combination of socket
/// family/type/protocol using `gio.SocketConnection.factoryRegisterType`.
///
/// To close a `GSocketConnection`, use `gio.IOStream.close`. Closing both
/// substreams of the `gio.IOStream` separately will not close the
/// underlying `gio.Socket`.
pub const SocketConnection = extern struct {
    pub const Parent = gio.IOStream;
    pub const Implements = [_]type{};
    pub const Class = gio.SocketConnectionClass;
    f_parent_instance: gio.IOStream,
    f_priv: ?*gio.SocketConnectionPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The underlying `gio.Socket`.
        pub const socket = struct {
            pub const name = "socket";

            pub const Type = ?*gio.Socket;
        };
    };

    pub const signals = struct {};

    /// Looks up the `gobject.Type` to be used when creating socket connections on
    /// sockets with the specified `family`, `type` and `protocol_id`.
    ///
    /// If no type is registered, the `gio.SocketConnection` base type is returned.
    extern fn g_socket_connection_factory_lookup_type(p_family: gio.SocketFamily, p_type: gio.SocketType, p_protocol_id: c_int) usize;
    pub const factoryLookupType = g_socket_connection_factory_lookup_type;

    /// Looks up the `gobject.Type` to be used when creating socket connections on
    /// sockets with the specified `family`, `type` and `protocol`.
    ///
    /// If no type is registered, the `gio.SocketConnection` base type is returned.
    extern fn g_socket_connection_factory_register_type(p_g_type: usize, p_family: gio.SocketFamily, p_type: gio.SocketType, p_protocol: c_int) void;
    pub const factoryRegisterType = g_socket_connection_factory_register_type;

    /// Connect `connection` to the specified remote address.
    extern fn g_socket_connection_connect(p_connection: *SocketConnection, p_address: *gio.SocketAddress, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const connect = g_socket_connection_connect;

    /// Asynchronously connect `connection` to the specified remote address.
    ///
    /// This clears the `gio.Socket.properties.blocking` flag on `connection`'s underlying
    /// socket if it is currently set.
    ///
    /// If `gio.Socket.properties.timeout` is set, the operation will time out and return
    /// `G_IO_ERROR_TIMED_OUT` after that period. Otherwise, it will continue
    /// indefinitely until operating system timeouts (if any) are hit.
    ///
    /// Use `gio.SocketConnection.connectFinish` to retrieve the result.
    extern fn g_socket_connection_connect_async(p_connection: *SocketConnection, p_address: *gio.SocketAddress, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const connectAsync = g_socket_connection_connect_async;

    /// Gets the result of a `gio.SocketConnection.connectAsync` call.
    extern fn g_socket_connection_connect_finish(p_connection: *SocketConnection, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const connectFinish = g_socket_connection_connect_finish;

    /// Try to get the local address of a socket connection.
    extern fn g_socket_connection_get_local_address(p_connection: *SocketConnection, p_error: ?*?*glib.Error) ?*gio.SocketAddress;
    pub const getLocalAddress = g_socket_connection_get_local_address;

    /// Try to get the remote address of a socket connection.
    ///
    /// Since GLib 2.40, when used with `gio.SocketClient.connect` or
    /// `gio.SocketClient.connectAsync`, during emission of
    /// `G_SOCKET_CLIENT_CONNECTING`, this function will return the remote
    /// address that will be used for the connection.  This allows
    /// applications to print e.g. "Connecting to example.com
    /// (10.42.77.3)...".
    extern fn g_socket_connection_get_remote_address(p_connection: *SocketConnection, p_error: ?*?*glib.Error) ?*gio.SocketAddress;
    pub const getRemoteAddress = g_socket_connection_get_remote_address;

    /// Gets the underlying `gio.Socket` object of the connection.
    /// This can be useful if you want to do something unusual on it
    /// not supported by the `gio.SocketConnection` APIs.
    extern fn g_socket_connection_get_socket(p_connection: *SocketConnection) *gio.Socket;
    pub const getSocket = g_socket_connection_get_socket;

    /// Checks if `connection` is connected. This is equivalent to calling
    /// `gio.Socket.isConnected` on `connection`'s underlying `gio.Socket`.
    extern fn g_socket_connection_is_connected(p_connection: *SocketConnection) c_int;
    pub const isConnected = g_socket_connection_is_connected;

    extern fn g_socket_connection_get_type() usize;
    pub const getGObjectType = g_socket_connection_get_type;

    extern fn g_object_ref(p_self: *gio.SocketConnection) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SocketConnection) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SocketConnection, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `GSocketControlMessage` is a special-purpose utility message that
/// can be sent to or received from a `gio.Socket`. These types of
/// messages are often called ‘ancillary data’.
///
/// The message can represent some sort of special instruction to or
/// information from the socket or can represent a special kind of
/// transfer to the peer (for example, sending a file descriptor over
/// a UNIX socket).
///
/// These messages are sent with `gio.Socket.sendMessage` and received
/// with `gio.Socket.receiveMessage`.
///
/// To extend the set of control message that can be sent, subclass this
/// class and override the `get_size`, `get_level`, `get_type` and `serialize`
/// methods.
///
/// To extend the set of control messages that can be received, subclass
/// this class and implement the `deserialize` method. Also, make sure your
/// class is registered with the `gobject.Type` type system before calling
/// `gio.Socket.receiveMessage` to read such a message.
pub const SocketControlMessage = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.SocketControlMessageClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.SocketControlMessagePrivate,

    pub const virtual_methods = struct {
        /// Returns the "level" (i.e. the originating protocol) of the control message.
        /// This is often SOL_SOCKET.
        pub const get_level = struct {
            pub fn call(p_class: anytype, p_message: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(SocketControlMessage.Class, p_class).f_get_level.?(gobject.ext.as(SocketControlMessage, p_message));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_message: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(SocketControlMessage.Class, p_class).f_get_level = @ptrCast(p_implementation);
            }
        };

        /// Returns the space required for the control message, not including
        /// headers or alignment.
        pub const get_size = struct {
            pub fn call(p_class: anytype, p_message: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) usize {
                return gobject.ext.as(SocketControlMessage.Class, p_class).f_get_size.?(gobject.ext.as(SocketControlMessage, p_message));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_message: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) usize) void {
                gobject.ext.as(SocketControlMessage.Class, p_class).f_get_size = @ptrCast(p_implementation);
            }
        };

        /// gets the protocol specific type of the message.
        pub const get_type = struct {
            pub fn call(p_class: anytype, p_message: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(SocketControlMessage.Class, p_class).f_get_type.?(gobject.ext.as(SocketControlMessage, p_message));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_message: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(SocketControlMessage.Class, p_class).f_get_type = @ptrCast(p_implementation);
            }
        };

        /// Converts the data in the message to bytes placed in the
        /// message.
        ///
        /// `data` is guaranteed to have enough space to fit the size
        /// returned by `gio.SocketControlMessage.getSize` on this
        /// object.
        pub const serialize = struct {
            pub fn call(p_class: anytype, p_message: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_data: *anyopaque) void {
                return gobject.ext.as(SocketControlMessage.Class, p_class).f_serialize.?(gobject.ext.as(SocketControlMessage, p_message), p_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_message: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_data: *anyopaque) callconv(.c) void) void {
                gobject.ext.as(SocketControlMessage.Class, p_class).f_serialize = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Tries to deserialize a socket control message of a given
    /// `level` and `type`. This will ask all known (to GType) subclasses
    /// of `gio.SocketControlMessage` if they can understand this kind
    /// of message and if so deserialize it into a `gio.SocketControlMessage`.
    ///
    /// If there is no implementation for this kind of control message, `NULL`
    /// will be returned.
    extern fn g_socket_control_message_deserialize(p_level: c_int, p_type: c_int, p_size: usize, p_data: [*]u8) ?*gio.SocketControlMessage;
    pub const deserialize = g_socket_control_message_deserialize;

    /// Returns the "level" (i.e. the originating protocol) of the control message.
    /// This is often SOL_SOCKET.
    extern fn g_socket_control_message_get_level(p_message: *SocketControlMessage) c_int;
    pub const getLevel = g_socket_control_message_get_level;

    /// Returns the protocol specific type of the control message.
    /// For instance, for UNIX fd passing this would be SCM_RIGHTS.
    extern fn g_socket_control_message_get_msg_type(p_message: *SocketControlMessage) c_int;
    pub const getMsgType = g_socket_control_message_get_msg_type;

    /// Returns the space required for the control message, not including
    /// headers or alignment.
    extern fn g_socket_control_message_get_size(p_message: *SocketControlMessage) usize;
    pub const getSize = g_socket_control_message_get_size;

    /// Converts the data in the message to bytes placed in the
    /// message.
    ///
    /// `data` is guaranteed to have enough space to fit the size
    /// returned by `gio.SocketControlMessage.getSize` on this
    /// object.
    extern fn g_socket_control_message_serialize(p_message: *SocketControlMessage, p_data: *anyopaque) void;
    pub const serialize = g_socket_control_message_serialize;

    extern fn g_socket_control_message_get_type() usize;
    pub const getGObjectType = g_socket_control_message_get_type;

    extern fn g_object_ref(p_self: *gio.SocketControlMessage) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SocketControlMessage) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SocketControlMessage, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `GSocketListener` is an object that keeps track of a set
/// of server sockets and helps you accept sockets from any of the
/// socket, either sync or async.
///
/// Add addresses and ports to listen on using
/// `gio.SocketListener.addAddress` and
/// `gio.SocketListener.addInetPort`. These will be listened on until
/// `gio.SocketListener.close` is called. Dropping your final reference to
/// the `GSocketListener` will not cause `gio.SocketListener.close` to be
/// called implicitly, as some references to the `GSocketListener` may be held
/// internally.
///
/// If you want to implement a network server, also look at
/// `gio.SocketService` and `gio.ThreadedSocketService` which are
/// subclasses of `GSocketListener` that make this even easier.
pub const SocketListener = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.SocketListenerClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.SocketListenerPrivate,

    pub const virtual_methods = struct {
        /// virtual method called when the set of socket listened to changes
        pub const changed = struct {
            pub fn call(p_class: anytype, p_listener: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(SocketListener.Class, p_class).f_changed.?(gobject.ext.as(SocketListener, p_listener));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_listener: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(SocketListener.Class, p_class).f_changed = @ptrCast(p_implementation);
            }
        };

        pub const event = struct {
            pub fn call(p_class: anytype, p_listener: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: gio.SocketListenerEvent, p_socket: *gio.Socket) void {
                return gobject.ext.as(SocketListener.Class, p_class).f_event.?(gobject.ext.as(SocketListener, p_listener), p_event, p_socket);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_listener: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_event: gio.SocketListenerEvent, p_socket: *gio.Socket) callconv(.c) void) void {
                gobject.ext.as(SocketListener.Class, p_class).f_event = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The number of outstanding connections in the listen queue.
        pub const listen_backlog = struct {
            pub const name = "listen-backlog";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted when `listener`'s activity on `socket` changes state.
        /// Note that when `listener` is used to listen on both IPv4 and
        /// IPv6, a separate set of signals will be emitted for each, and
        /// the order they happen in is undefined.
        pub const event = struct {
            pub const name = "event";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_event: gio.SocketListenerEvent, p_socket: *gio.Socket, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(SocketListener, p_instance))),
                    gobject.signalLookup("event", SocketListener.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gio.SocketListener` with no sockets to listen for.
    /// New listeners can be added with e.g. `gio.SocketListener.addAddress`
    /// or `gio.SocketListener.addInetPort`.
    extern fn g_socket_listener_new() *gio.SocketListener;
    pub const new = g_socket_listener_new;

    /// Blocks waiting for a client to connect to any of the sockets added
    /// to the listener. Returns a `gio.SocketConnection` for the socket that was
    /// accepted.
    ///
    /// If `source_object` is not `NULL` it will be filled out with the source
    /// object specified when the corresponding socket or address was added
    /// to the listener.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_socket_listener_accept(p_listener: *SocketListener, p_source_object: ?**gobject.Object, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.SocketConnection;
    pub const accept = g_socket_listener_accept;

    /// This is the asynchronous version of `gio.SocketListener.accept`.
    ///
    /// When the operation is finished `callback` will be
    /// called. You can then call `gio.SocketListener.acceptFinish`
    /// to get the result of the operation.
    extern fn g_socket_listener_accept_async(p_listener: *SocketListener, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const acceptAsync = g_socket_listener_accept_async;

    /// Finishes an async accept operation. See `gio.SocketListener.acceptAsync`
    extern fn g_socket_listener_accept_finish(p_listener: *SocketListener, p_result: *gio.AsyncResult, p_source_object: ?**gobject.Object, p_error: ?*?*glib.Error) ?*gio.SocketConnection;
    pub const acceptFinish = g_socket_listener_accept_finish;

    /// Blocks waiting for a client to connect to any of the sockets added
    /// to the listener. Returns the `gio.Socket` that was accepted.
    ///
    /// If you want to accept the high-level `gio.SocketConnection`, not a `gio.Socket`,
    /// which is often the case, then you should use `gio.SocketListener.accept`
    /// instead.
    ///
    /// If `source_object` is not `NULL` it will be filled out with the source
    /// object specified when the corresponding socket or address was added
    /// to the listener.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_socket_listener_accept_socket(p_listener: *SocketListener, p_source_object: ?**gobject.Object, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.Socket;
    pub const acceptSocket = g_socket_listener_accept_socket;

    /// This is the asynchronous version of `gio.SocketListener.acceptSocket`.
    ///
    /// When the operation is finished `callback` will be
    /// called. You can then call `gio.SocketListener.acceptSocketFinish`
    /// to get the result of the operation.
    extern fn g_socket_listener_accept_socket_async(p_listener: *SocketListener, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const acceptSocketAsync = g_socket_listener_accept_socket_async;

    /// Finishes an async accept operation. See `gio.SocketListener.acceptSocketAsync`
    extern fn g_socket_listener_accept_socket_finish(p_listener: *SocketListener, p_result: *gio.AsyncResult, p_source_object: ?**gobject.Object, p_error: ?*?*glib.Error) ?*gio.Socket;
    pub const acceptSocketFinish = g_socket_listener_accept_socket_finish;

    /// Creates a socket of type `type` and protocol `protocol`, binds
    /// it to `address` and adds it to the set of sockets we're accepting
    /// sockets from.
    ///
    /// Note that adding an IPv6 address, depending on the platform,
    /// may or may not result in a listener that also accepts IPv4
    /// connections.  For more deterministic behavior, see
    /// `gio.SocketListener.addInetPort`.
    ///
    /// `source_object` will be passed out in the various calls
    /// to accept to identify this particular source, which is
    /// useful if you're listening on multiple addresses and do
    /// different things depending on what address is connected to.
    ///
    /// If successful and `effective_address` is non-`NULL` then it will
    /// be set to the address that the binding actually occurred at.  This
    /// is helpful for determining the port number that was used for when
    /// requesting a binding to port 0 (ie: "any port").  This address, if
    /// requested, belongs to the caller and must be freed.
    ///
    /// Call `gio.SocketListener.close` to stop listening on `address`; this will not
    /// be done automatically when you drop your final reference to `listener`, as
    /// references may be held internally.
    extern fn g_socket_listener_add_address(p_listener: *SocketListener, p_address: *gio.SocketAddress, p_type: gio.SocketType, p_protocol: gio.SocketProtocol, p_source_object: ?*gobject.Object, p_effective_address: ?**gio.SocketAddress, p_error: ?*?*glib.Error) c_int;
    pub const addAddress = g_socket_listener_add_address;

    /// Listens for TCP connections on any available port number for both
    /// IPv6 and IPv4 (if each is available).
    ///
    /// This is useful if you need to have a socket for incoming connections
    /// but don't care about the specific port number.
    ///
    /// `source_object` will be passed out in the various calls
    /// to accept to identify this particular source, which is
    /// useful if you're listening on multiple addresses and do
    /// different things depending on what address is connected to.
    extern fn g_socket_listener_add_any_inet_port(p_listener: *SocketListener, p_source_object: ?*gobject.Object, p_error: ?*?*glib.Error) u16;
    pub const addAnyInetPort = g_socket_listener_add_any_inet_port;

    /// Helper function for `gio.SocketListener.addAddress` that
    /// creates a TCP/IP socket listening on IPv4 and IPv6 (if
    /// supported) on the specified port on all interfaces.
    ///
    /// `source_object` will be passed out in the various calls
    /// to accept to identify this particular source, which is
    /// useful if you're listening on multiple addresses and do
    /// different things depending on what address is connected to.
    ///
    /// Call `gio.SocketListener.close` to stop listening on `port`; this will not
    /// be done automatically when you drop your final reference to `listener`, as
    /// references may be held internally.
    extern fn g_socket_listener_add_inet_port(p_listener: *SocketListener, p_port: u16, p_source_object: ?*gobject.Object, p_error: ?*?*glib.Error) c_int;
    pub const addInetPort = g_socket_listener_add_inet_port;

    /// Adds `socket` to the set of sockets that we try to accept
    /// new clients from. The socket must be bound to a local
    /// address and listened to.
    ///
    /// `source_object` will be passed out in the various calls
    /// to accept to identify this particular source, which is
    /// useful if you're listening on multiple addresses and do
    /// different things depending on what address is connected to.
    ///
    /// The `socket` will not be automatically closed when the `listener` is finalized
    /// unless the listener held the final reference to the socket. Before GLib 2.42,
    /// the `socket` was automatically closed on finalization of the `listener`, even
    /// if references to it were held elsewhere.
    extern fn g_socket_listener_add_socket(p_listener: *SocketListener, p_socket: *gio.Socket, p_source_object: ?*gobject.Object, p_error: ?*?*glib.Error) c_int;
    pub const addSocket = g_socket_listener_add_socket;

    /// Closes all the sockets in the listener.
    extern fn g_socket_listener_close(p_listener: *SocketListener) void;
    pub const close = g_socket_listener_close;

    /// Sets the listen backlog on the sockets in the listener. This must be called
    /// before adding any sockets, addresses or ports to the `gio.SocketListener` (for
    /// example, by calling `gio.SocketListener.addInetPort`) to be effective.
    ///
    /// See `gio.Socket.setListenBacklog` for details
    extern fn g_socket_listener_set_backlog(p_listener: *SocketListener, p_listen_backlog: c_int) void;
    pub const setBacklog = g_socket_listener_set_backlog;

    extern fn g_socket_listener_get_type() usize;
    pub const getGObjectType = g_socket_listener_get_type;

    extern fn g_object_ref(p_self: *gio.SocketListener) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SocketListener) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SocketListener, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `GSocketService` is an object that represents a service that
/// is provided to the network or over local sockets.  When a new
/// connection is made to the service the `gio.SocketService.signals.incoming`
/// signal is emitted.
///
/// A `GSocketService` is a subclass of `gio.SocketListener` and you need
/// to add the addresses you want to accept connections on with the
/// `gio.SocketListener` APIs.
///
/// There are two options for implementing a network service based on
/// `GSocketService`. The first is to create the service using
/// `gio.SocketService.new` and to connect to the
/// `gio.SocketService.signals.incoming` signal. The second is to subclass
/// `GSocketService` and override the default signal handler implementation.
///
/// In either case, the handler must immediately return, or else it
/// will block additional incoming connections from being serviced.
/// If you are interested in writing connection handlers that contain
/// blocking code then see `gio.ThreadedSocketService`.
///
/// The socket service runs on the main loop of the
/// thread-default context (see
/// `glib.MainContext.pushThreadDefault`) of the thread it is
/// created in, and is not threadsafe in general. However, the calls to start and
/// stop the service are thread-safe so these can be used from threads that
/// handle incoming clients.
pub const SocketService = extern struct {
    pub const Parent = gio.SocketListener;
    pub const Implements = [_]type{};
    pub const Class = gio.SocketServiceClass;
    f_parent_instance: gio.SocketListener,
    f_priv: ?*gio.SocketServicePrivate,

    pub const virtual_methods = struct {
        /// signal emitted when new connections are accepted
        pub const incoming = struct {
            pub fn call(p_class: anytype, p_service: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.SocketConnection, p_source_object: *gobject.Object) c_int {
                return gobject.ext.as(SocketService.Class, p_class).f_incoming.?(gobject.ext.as(SocketService, p_service), p_connection, p_source_object);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_service: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.SocketConnection, p_source_object: *gobject.Object) callconv(.c) c_int) void {
                gobject.ext.as(SocketService.Class, p_class).f_incoming = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Whether the service is currently accepting connections.
        pub const active = struct {
            pub const name = "active";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::incoming signal is emitted when a new incoming connection
        /// to `service` needs to be handled. The handler must initiate the
        /// handling of `connection`, but may not block; in essence,
        /// asynchronous operations must be used.
        ///
        /// `connection` will be unreffed once the signal handler returns,
        /// so you need to ref it yourself if you are planning to use it.
        pub const incoming = struct {
            pub const name = "incoming";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_connection: *gio.SocketConnection, p_source_object: ?*gobject.Object, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(SocketService, p_instance))),
                    gobject.signalLookup("incoming", SocketService.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gio.SocketService` with no sockets to listen for.
    /// New listeners can be added with e.g. `gio.SocketListener.addAddress`
    /// or `gio.SocketListener.addInetPort`.
    ///
    /// New services are created active, there is no need to call
    /// `gio.SocketService.start`, unless `gio.SocketService.stop` has been
    /// called before.
    extern fn g_socket_service_new() *gio.SocketService;
    pub const new = g_socket_service_new;

    /// Check whether the service is active or not. An active
    /// service will accept new clients that connect, while
    /// a non-active service will let connecting clients queue
    /// up until the service is started.
    extern fn g_socket_service_is_active(p_service: *SocketService) c_int;
    pub const isActive = g_socket_service_is_active;

    /// Restarts the service, i.e. start accepting connections
    /// from the added sockets when the mainloop runs. This only needs
    /// to be called after the service has been stopped from
    /// `gio.SocketService.stop`.
    ///
    /// This call is thread-safe, so it may be called from a thread
    /// handling an incoming client request.
    extern fn g_socket_service_start(p_service: *SocketService) void;
    pub const start = g_socket_service_start;

    /// Stops the service, i.e. stops accepting connections
    /// from the added sockets when the mainloop runs.
    ///
    /// This call is thread-safe, so it may be called from a thread
    /// handling an incoming client request.
    ///
    /// Note that this only stops accepting new connections; it does not
    /// close the listening sockets, and you can call
    /// `gio.SocketService.start` again later to begin listening again. To
    /// close the listening sockets, call `gio.SocketListener.close`. (This
    /// will happen automatically when the `gio.SocketService` is finalized.)
    ///
    /// This must be called before calling `gio.SocketListener.close` as
    /// the socket service will start accepting connections immediately
    /// when a new socket is added.
    extern fn g_socket_service_stop(p_service: *SocketService) void;
    pub const stop = g_socket_service_stop;

    extern fn g_socket_service_get_type() usize;
    pub const getGObjectType = g_socket_service_get_type;

    extern fn g_object_ref(p_self: *gio.SocketService) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SocketService) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SocketService, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GSubprocess` allows the creation of and interaction with child
/// processes.
///
/// Processes can be communicated with using standard GIO-style APIs (ie:
/// `gio.InputStream`, `gio.OutputStream`). There are GIO-style APIs
/// to wait for process termination (ie: cancellable and with an asynchronous
/// variant).
///
/// There is an API to force a process to terminate, as well as a
/// race-free API for sending UNIX signals to a subprocess.
///
/// One major advantage that GIO brings over the core GLib library is
/// comprehensive API for asynchronous I/O, such
/// `gio.OutputStream.spliceAsync`.  This makes `GSubprocess`
/// significantly more powerful and flexible than equivalent APIs in
/// some other languages such as the `subprocess.py`
/// included with Python.  For example, using `GSubprocess` one could
/// create two child processes, reading standard output from the first,
/// processing it, and writing to the input stream of the second, all
/// without blocking the main loop.
///
/// A powerful `gio.Subprocess.communicate` API is provided similar to the
/// ``communicate`` method of `subprocess.py`. This enables very easy
/// interaction with a subprocess that has been opened with pipes.
///
/// `GSubprocess` defaults to tight control over the file descriptors open
/// in the child process, avoiding dangling-FD issues that are caused by
/// a simple ``fork``/``exec``.  The only open file descriptors in the
/// spawned process are ones that were explicitly specified by the
/// `GSubprocess` API (unless `G_SUBPROCESS_FLAGS_INHERIT_FDS` was
/// specified).
///
/// `GSubprocess` will quickly reap all child processes as they exit,
/// avoiding ‘zombie processes’ remaining around for long periods of
/// time.  `gio.Subprocess.wait` can be used to wait for this to happen,
/// but it will happen even without the call being explicitly made.
///
/// As a matter of principle, `GSubprocess` has no API that accepts
/// shell-style space-separated strings.  It will, however, match the
/// typical shell behaviour of searching the `PATH` for executables that do
/// not contain a directory separator in their name. By default, the `PATH`
/// of the current process is used.  You can specify
/// `G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP` to use the `PATH` of the
/// launcher environment instead.
///
/// `GSubprocess` attempts to have a very simple API for most uses (ie:
/// spawning a subprocess with arguments and support for most typical
/// kinds of input and output redirection).  See `gio.Subprocess.new`. The
/// `gio.SubprocessLauncher` API is provided for more complicated cases
/// (advanced types of redirection, environment variable manipulation,
/// change of working directory, child setup functions, etc).
///
/// A typical use of `GSubprocess` will involve calling
/// `gio.Subprocess.new`, followed by `gio.Subprocess.waitAsync` or
/// `gio.Subprocess.wait`.  After the process exits, the status can be
/// checked using functions such as `gio.Subprocess.getIfExited` (which
/// are similar to the familiar `WIFEXITED`-style POSIX macros).
///
/// Note that as of GLib 2.82, creating a `GSubprocess` causes the signal
/// `SIGPIPE` to be ignored for the remainder of the program. If you are writing
/// a command-line utility that uses `GSubprocess`, you may need to take into
/// account the fact that your program will not automatically be killed
/// if it tries to write to `stdout` after it has been closed.
pub const Subprocess = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.Initable};
    pub const Class = opaque {
        pub const Instance = Subprocess;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Argument vector.
        pub const argv = struct {
            pub const name = "argv";

            pub const Type = ?[*][*:0]u8;
        };

        /// Subprocess flags.
        pub const flags = struct {
            pub const name = "flags";

            pub const Type = gio.SubprocessFlags;
        };
    };

    pub const signals = struct {};

    /// Create a new process with the given flags and varargs argument
    /// list.  By default, matching the `glib.spawnAsync` defaults, the
    /// child's stdin will be set to the system null device, and
    /// stdout/stderr will be inherited from the parent.  You can use
    /// `flags` to control this behavior.
    ///
    /// The argument list must be terminated with `NULL`.
    extern fn g_subprocess_new(p_flags: gio.SubprocessFlags, p_error: ?**glib.Error, p_argv0: [*:0]const u8, ...) *gio.Subprocess;
    pub const new = g_subprocess_new;

    /// Create a new process with the given flags and argument list.
    ///
    /// The argument list is expected to be `NULL`-terminated.
    extern fn g_subprocess_newv(p_argv: [*]const [*:0]const u8, p_flags: gio.SubprocessFlags, p_error: ?*?*glib.Error) ?*gio.Subprocess;
    pub const newv = g_subprocess_newv;

    /// Communicate with the subprocess until it terminates, and all input
    /// and output has been completed.
    ///
    /// If `stdin_buf` is given, the subprocess must have been created with
    /// `G_SUBPROCESS_FLAGS_STDIN_PIPE`.  The given data is fed to the
    /// stdin of the subprocess and the pipe is closed (ie: EOF).
    ///
    /// At the same time (as not to cause blocking when dealing with large
    /// amounts of data), if `G_SUBPROCESS_FLAGS_STDOUT_PIPE` or
    /// `G_SUBPROCESS_FLAGS_STDERR_PIPE` were used, reads from those
    /// streams.  The data that was read is returned in `stdout` and/or
    /// the `stderr`.
    ///
    /// If the subprocess was created with `G_SUBPROCESS_FLAGS_STDOUT_PIPE`,
    /// `stdout_buf` will contain the data read from stdout.  Otherwise, for
    /// subprocesses not created with `G_SUBPROCESS_FLAGS_STDOUT_PIPE`,
    /// `stdout_buf` will be set to `NULL`.  Similar provisions apply to
    /// `stderr_buf` and `G_SUBPROCESS_FLAGS_STDERR_PIPE`.
    ///
    /// As usual, any output variable may be given as `NULL` to ignore it.
    ///
    /// If you desire the stdout and stderr data to be interleaved, create
    /// the subprocess with `G_SUBPROCESS_FLAGS_STDOUT_PIPE` and
    /// `G_SUBPROCESS_FLAGS_STDERR_MERGE`.  The merged result will be returned
    /// in `stdout_buf` and `stderr_buf` will be set to `NULL`.
    ///
    /// In case of any error (including cancellation), `FALSE` will be
    /// returned with `error` set.  Some or all of the stdin data may have
    /// been written.  Any stdout or stderr data that has been read will be
    /// discarded. None of the out variables (aside from `error`) will have
    /// been set to anything in particular and should not be inspected.
    ///
    /// In the case that `TRUE` is returned, the subprocess has exited and the
    /// exit status inspection APIs (eg: `gio.Subprocess.getIfExited`,
    /// `gio.Subprocess.getExitStatus`) may be used.
    ///
    /// You should not attempt to use any of the subprocess pipes after
    /// starting this function, since they may be left in strange states,
    /// even if the operation was cancelled.  You should especially not
    /// attempt to interact with the pipes while the operation is in progress
    /// (either from another thread or if using the asynchronous version).
    extern fn g_subprocess_communicate(p_subprocess: *Subprocess, p_stdin_buf: ?*glib.Bytes, p_cancellable: ?*gio.Cancellable, p_stdout_buf: ?**glib.Bytes, p_stderr_buf: ?**glib.Bytes, p_error: ?*?*glib.Error) c_int;
    pub const communicate = g_subprocess_communicate;

    /// Asynchronous version of `gio.Subprocess.communicate`.  Complete
    /// invocation with `gio.Subprocess.communicateFinish`.
    extern fn g_subprocess_communicate_async(p_subprocess: *Subprocess, p_stdin_buf: ?*glib.Bytes, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const communicateAsync = g_subprocess_communicate_async;

    /// Complete an invocation of `gio.Subprocess.communicateAsync`.
    extern fn g_subprocess_communicate_finish(p_subprocess: *Subprocess, p_result: *gio.AsyncResult, p_stdout_buf: ?**glib.Bytes, p_stderr_buf: ?**glib.Bytes, p_error: ?*?*glib.Error) c_int;
    pub const communicateFinish = g_subprocess_communicate_finish;

    /// Like `gio.Subprocess.communicate`, but validates the output of the
    /// process as UTF-8, and returns it as a regular NUL terminated string.
    ///
    /// On error, `stdout_buf` and `stderr_buf` will be set to undefined values and
    /// should not be used.
    extern fn g_subprocess_communicate_utf8(p_subprocess: *Subprocess, p_stdin_buf: ?[*:0]const u8, p_cancellable: ?*gio.Cancellable, p_stdout_buf: ?*[*:0]u8, p_stderr_buf: ?*[*:0]u8, p_error: ?*?*glib.Error) c_int;
    pub const communicateUtf8 = g_subprocess_communicate_utf8;

    /// Asynchronous version of `gio.Subprocess.communicateUtf8`.  Complete
    /// invocation with `gio.Subprocess.communicateUtf8Finish`.
    extern fn g_subprocess_communicate_utf8_async(p_subprocess: *Subprocess, p_stdin_buf: ?[*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const communicateUtf8Async = g_subprocess_communicate_utf8_async;

    /// Complete an invocation of `gio.Subprocess.communicateUtf8Async`.
    extern fn g_subprocess_communicate_utf8_finish(p_subprocess: *Subprocess, p_result: *gio.AsyncResult, p_stdout_buf: ?*[*:0]u8, p_stderr_buf: ?*[*:0]u8, p_error: ?*?*glib.Error) c_int;
    pub const communicateUtf8Finish = g_subprocess_communicate_utf8_finish;

    /// Use an operating-system specific method to attempt an immediate,
    /// forceful termination of the process.  There is no mechanism to
    /// determine whether or not the request itself was successful;
    /// however, you can use `gio.Subprocess.wait` to monitor the status of
    /// the process after calling this function.
    ///
    /// On Unix, this function sends `SIGKILL`.
    extern fn g_subprocess_force_exit(p_subprocess: *Subprocess) void;
    pub const forceExit = g_subprocess_force_exit;

    /// Check the exit status of the subprocess, given that it exited
    /// normally.  This is the value passed to the `exit` system call or the
    /// return value from main.
    ///
    /// This is equivalent to the system WEXITSTATUS macro.
    ///
    /// It is an error to call this function before `gio.Subprocess.wait` and
    /// unless `gio.Subprocess.getIfExited` returned `TRUE`.
    extern fn g_subprocess_get_exit_status(p_subprocess: *Subprocess) c_int;
    pub const getExitStatus = g_subprocess_get_exit_status;

    /// On UNIX, returns the process ID as a decimal string.
    /// On Windows, returns the result of `GetProcessId` also as a string.
    /// If the subprocess has terminated, this will return `NULL`.
    extern fn g_subprocess_get_identifier(p_subprocess: *Subprocess) ?[*:0]const u8;
    pub const getIdentifier = g_subprocess_get_identifier;

    /// Check if the given subprocess exited normally (ie: by way of `exit`
    /// or return from `main`).
    ///
    /// This is equivalent to the system WIFEXITED macro.
    ///
    /// It is an error to call this function before `gio.Subprocess.wait` has
    /// returned.
    extern fn g_subprocess_get_if_exited(p_subprocess: *Subprocess) c_int;
    pub const getIfExited = g_subprocess_get_if_exited;

    /// Check if the given subprocess terminated in response to a signal.
    ///
    /// This is equivalent to the system WIFSIGNALED macro.
    ///
    /// It is an error to call this function before `gio.Subprocess.wait` has
    /// returned.
    extern fn g_subprocess_get_if_signaled(p_subprocess: *Subprocess) c_int;
    pub const getIfSignaled = g_subprocess_get_if_signaled;

    /// Gets the raw status code of the process, as from `waitpid`.
    ///
    /// This value has no particular meaning, but it can be used with the
    /// macros defined by the system headers such as WIFEXITED.  It can also
    /// be used with `glib.spawnCheckWaitStatus`.
    ///
    /// It is more likely that you want to use `gio.Subprocess.getIfExited`
    /// followed by `gio.Subprocess.getExitStatus`.
    ///
    /// It is an error to call this function before `gio.Subprocess.wait` has
    /// returned.
    extern fn g_subprocess_get_status(p_subprocess: *Subprocess) c_int;
    pub const getStatus = g_subprocess_get_status;

    /// Gets the `gio.InputStream` from which to read the stderr output of
    /// `subprocess`.
    ///
    /// The process must have been created with `G_SUBPROCESS_FLAGS_STDERR_PIPE`,
    /// otherwise `NULL` will be returned.
    extern fn g_subprocess_get_stderr_pipe(p_subprocess: *Subprocess) ?*gio.InputStream;
    pub const getStderrPipe = g_subprocess_get_stderr_pipe;

    /// Gets the `gio.OutputStream` that you can write to in order to give data
    /// to the stdin of `subprocess`.
    ///
    /// The process must have been created with `G_SUBPROCESS_FLAGS_STDIN_PIPE` and
    /// not `G_SUBPROCESS_FLAGS_STDIN_INHERIT`, otherwise `NULL` will be returned.
    extern fn g_subprocess_get_stdin_pipe(p_subprocess: *Subprocess) ?*gio.OutputStream;
    pub const getStdinPipe = g_subprocess_get_stdin_pipe;

    /// Gets the `gio.InputStream` from which to read the stdout output of
    /// `subprocess`.
    ///
    /// The process must have been created with `G_SUBPROCESS_FLAGS_STDOUT_PIPE`,
    /// otherwise `NULL` will be returned.
    extern fn g_subprocess_get_stdout_pipe(p_subprocess: *Subprocess) ?*gio.InputStream;
    pub const getStdoutPipe = g_subprocess_get_stdout_pipe;

    /// Checks if the process was "successful".  A process is considered
    /// successful if it exited cleanly with an exit status of 0, either by
    /// way of the `exit` system call or return from `main`.
    ///
    /// It is an error to call this function before `gio.Subprocess.wait` has
    /// returned.
    extern fn g_subprocess_get_successful(p_subprocess: *Subprocess) c_int;
    pub const getSuccessful = g_subprocess_get_successful;

    /// Get the signal number that caused the subprocess to terminate, given
    /// that it terminated due to a signal.
    ///
    /// This is equivalent to the system WTERMSIG macro.
    ///
    /// It is an error to call this function before `gio.Subprocess.wait` and
    /// unless `gio.Subprocess.getIfSignaled` returned `TRUE`.
    extern fn g_subprocess_get_term_sig(p_subprocess: *Subprocess) c_int;
    pub const getTermSig = g_subprocess_get_term_sig;

    /// Sends the UNIX signal `signal_num` to the subprocess, if it is still
    /// running.
    ///
    /// This API is race-free.  If the subprocess has terminated, it will not
    /// be signalled.
    ///
    /// This API is not available on Windows.
    extern fn g_subprocess_send_signal(p_subprocess: *Subprocess, p_signal_num: c_int) void;
    pub const sendSignal = g_subprocess_send_signal;

    /// Synchronously wait for the subprocess to terminate.
    ///
    /// After the process terminates you can query its exit status with
    /// functions such as `gio.Subprocess.getIfExited` and
    /// `gio.Subprocess.getExitStatus`.
    ///
    /// This function does not fail in the case of the subprocess having
    /// abnormal termination.  See `gio.Subprocess.waitCheck` for that.
    ///
    /// Cancelling `cancellable` doesn't kill the subprocess.  Call
    /// `gio.Subprocess.forceExit` if it is desirable.
    extern fn g_subprocess_wait(p_subprocess: *Subprocess, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const wait = g_subprocess_wait;

    /// Wait for the subprocess to terminate.
    ///
    /// This is the asynchronous version of `gio.Subprocess.wait`.
    extern fn g_subprocess_wait_async(p_subprocess: *Subprocess, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const waitAsync = g_subprocess_wait_async;

    /// Combines `gio.Subprocess.wait` with `glib.spawnCheckWaitStatus`.
    extern fn g_subprocess_wait_check(p_subprocess: *Subprocess, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const waitCheck = g_subprocess_wait_check;

    /// Combines `gio.Subprocess.waitAsync` with `glib.spawnCheckWaitStatus`.
    ///
    /// This is the asynchronous version of `gio.Subprocess.waitCheck`.
    extern fn g_subprocess_wait_check_async(p_subprocess: *Subprocess, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const waitCheckAsync = g_subprocess_wait_check_async;

    /// Collects the result of a previous call to
    /// `gio.Subprocess.waitCheckAsync`.
    extern fn g_subprocess_wait_check_finish(p_subprocess: *Subprocess, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const waitCheckFinish = g_subprocess_wait_check_finish;

    /// Collects the result of a previous call to
    /// `gio.Subprocess.waitAsync`.
    extern fn g_subprocess_wait_finish(p_subprocess: *Subprocess, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const waitFinish = g_subprocess_wait_finish;

    extern fn g_subprocess_get_type() usize;
    pub const getGObjectType = g_subprocess_get_type;

    extern fn g_object_ref(p_self: *gio.Subprocess) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Subprocess) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Subprocess, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// This class contains a set of options for launching child processes,
/// such as where its standard input and output will be directed, the
/// argument list, the environment, and more.
///
/// While the `gio.Subprocess` class has high level functions covering
/// popular cases, use of this class allows access to more advanced
/// options.  It can also be used to launch multiple subprocesses with
/// a similar configuration.
pub const SubprocessLauncher = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = SubprocessLauncher;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// `gio.SubprocessFlags` for launched processes.
        pub const flags = struct {
            pub const name = "flags";

            pub const Type = gio.SubprocessFlags;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.SubprocessLauncher`.
    ///
    /// The launcher is created with the default options.  A copy of the
    /// environment of the calling process is made at the time of this call
    /// and will be used as the environment that the process is launched in.
    extern fn g_subprocess_launcher_new(p_flags: gio.SubprocessFlags) *gio.SubprocessLauncher;
    pub const new = g_subprocess_launcher_new;

    /// Closes all the file descriptors previously passed to the object with
    /// `gio.SubprocessLauncher.takeFd`, `gio.SubprocessLauncher.takeStderrFd`, etc.
    ///
    /// After calling this method, any subsequent calls to `gio.SubprocessLauncher.spawn` or `gio.SubprocessLauncher.spawnv` will
    /// return `G_IO_ERROR_CLOSED`. This method is idempotent if
    /// called more than once.
    ///
    /// This function is called automatically when the `gio.SubprocessLauncher`
    /// is disposed, but is provided separately so that garbage collected
    /// language bindings can call it earlier to guarantee when FDs are closed.
    extern fn g_subprocess_launcher_close(p_self: *SubprocessLauncher) void;
    pub const close = g_subprocess_launcher_close;

    /// Returns the value of the environment variable `variable` in the
    /// environment of processes launched from this launcher.
    ///
    /// On UNIX, the returned string can be an arbitrary byte string.
    /// On Windows, it will be UTF-8.
    extern fn g_subprocess_launcher_getenv(p_self: *SubprocessLauncher, p_variable: [*:0]const u8) ?[*:0]const u8;
    pub const getenv = g_subprocess_launcher_getenv;

    /// Sets up a child setup function.
    ///
    /// The child setup function will be called after `fork` but before
    /// `exec` on the child's side.
    ///
    /// `destroy_notify` will not be automatically called on the child's side
    /// of the `fork`.  It will only be called when the last reference on the
    /// `gio.SubprocessLauncher` is dropped or when a new child setup function is
    /// given.
    ///
    /// `NULL` can be given as `child_setup` to disable the functionality.
    ///
    /// Child setup functions are only available on UNIX.
    extern fn g_subprocess_launcher_set_child_setup(p_self: *SubprocessLauncher, p_child_setup: glib.SpawnChildSetupFunc, p_user_data: ?*anyopaque, p_destroy_notify: ?glib.DestroyNotify) void;
    pub const setChildSetup = g_subprocess_launcher_set_child_setup;

    /// Sets the current working directory that processes will be launched
    /// with.
    ///
    /// By default processes are launched with the current working directory
    /// of the launching process at the time of launch.
    extern fn g_subprocess_launcher_set_cwd(p_self: *SubprocessLauncher, p_cwd: [*:0]const u8) void;
    pub const setCwd = g_subprocess_launcher_set_cwd;

    /// Replace the entire environment of processes launched from this
    /// launcher with the given 'environ' variable.
    ///
    /// Typically you will build this variable by using `glib.listenv` to copy
    /// the process 'environ' and using the functions `glib.environSetenv`,
    /// `glib.environUnsetenv`, etc.
    ///
    /// As an alternative, you can use `gio.SubprocessLauncher.setenv`,
    /// `gio.SubprocessLauncher.unsetenv`, etc.
    ///
    /// Pass an empty array to set an empty environment. Pass `NULL` to inherit the
    /// parent process’ environment. As of GLib 2.54, the parent process’ environment
    /// will be copied when `gio.SubprocessLauncher.setEnviron` is called.
    /// Previously, it was copied when the subprocess was executed. This means the
    /// copied environment may now be modified (using `gio.SubprocessLauncher.setenv`,
    /// etc.) before launching the subprocess.
    ///
    /// On UNIX, all strings in this array can be arbitrary byte strings.
    /// On Windows, they should be in UTF-8.
    extern fn g_subprocess_launcher_set_environ(p_self: *SubprocessLauncher, p_env: [*][*:0]u8) void;
    pub const setEnviron = g_subprocess_launcher_set_environ;

    /// Sets the flags on the launcher.
    ///
    /// The default flags are `G_SUBPROCESS_FLAGS_NONE`.
    ///
    /// You may not set flags that specify conflicting options for how to
    /// handle a particular stdio stream (eg: specifying both
    /// `G_SUBPROCESS_FLAGS_STDIN_PIPE` and
    /// `G_SUBPROCESS_FLAGS_STDIN_INHERIT`).
    ///
    /// You may also not set a flag that conflicts with a previous call to a
    /// function like `gio.SubprocessLauncher.setStdinFilePath` or
    /// `gio.SubprocessLauncher.takeStdoutFd`.
    extern fn g_subprocess_launcher_set_flags(p_self: *SubprocessLauncher, p_flags: gio.SubprocessFlags) void;
    pub const setFlags = g_subprocess_launcher_set_flags;

    /// Sets the file path to use as the stderr for spawned processes.
    ///
    /// If `path` is `NULL` then any previously given path is unset.
    ///
    /// The file will be created or truncated when the process is spawned, as
    /// would be the case if using '2>' at the shell.
    ///
    /// If you want to send both stdout and stderr to the same file then use
    /// `G_SUBPROCESS_FLAGS_STDERR_MERGE`.
    ///
    /// You may not set a stderr file path if a stderr fd is already set or
    /// if the launcher flags contain any flags directing stderr elsewhere.
    ///
    /// This feature is only available on UNIX.
    extern fn g_subprocess_launcher_set_stderr_file_path(p_self: *SubprocessLauncher, p_path: ?[*:0]const u8) void;
    pub const setStderrFilePath = g_subprocess_launcher_set_stderr_file_path;

    /// Sets the file path to use as the stdin for spawned processes.
    ///
    /// If `path` is `NULL` then any previously given path is unset.
    ///
    /// The file must exist or spawning the process will fail.
    ///
    /// You may not set a stdin file path if a stdin fd is already set or if
    /// the launcher flags contain any flags directing stdin elsewhere.
    ///
    /// This feature is only available on UNIX.
    extern fn g_subprocess_launcher_set_stdin_file_path(p_self: *SubprocessLauncher, p_path: ?[*:0]const u8) void;
    pub const setStdinFilePath = g_subprocess_launcher_set_stdin_file_path;

    /// Sets the file path to use as the stdout for spawned processes.
    ///
    /// If `path` is `NULL` then any previously given path is unset.
    ///
    /// The file will be created or truncated when the process is spawned, as
    /// would be the case if using '>' at the shell.
    ///
    /// You may not set a stdout file path if a stdout fd is already set or
    /// if the launcher flags contain any flags directing stdout elsewhere.
    ///
    /// This feature is only available on UNIX.
    extern fn g_subprocess_launcher_set_stdout_file_path(p_self: *SubprocessLauncher, p_path: ?[*:0]const u8) void;
    pub const setStdoutFilePath = g_subprocess_launcher_set_stdout_file_path;

    /// Sets the environment variable `variable` in the environment of
    /// processes launched from this launcher.
    ///
    /// On UNIX, both the variable's name and value can be arbitrary byte
    /// strings, except that the variable's name cannot contain '='.
    /// On Windows, they should be in UTF-8.
    extern fn g_subprocess_launcher_setenv(p_self: *SubprocessLauncher, p_variable: [*:0]const u8, p_value: [*:0]const u8, p_overwrite: c_int) void;
    pub const setenv = g_subprocess_launcher_setenv;

    /// Creates a `gio.Subprocess` given a provided varargs list of arguments.
    extern fn g_subprocess_launcher_spawn(p_self: *SubprocessLauncher, p_error: **glib.Error, p_argv0: [*:0]const u8, ...) *gio.Subprocess;
    pub const spawn = g_subprocess_launcher_spawn;

    /// Creates a `gio.Subprocess` given a provided array of arguments.
    extern fn g_subprocess_launcher_spawnv(p_self: *SubprocessLauncher, p_argv: [*]const [*:0]const u8, p_error: ?*?*glib.Error) ?*gio.Subprocess;
    pub const spawnv = g_subprocess_launcher_spawnv;

    /// Transfer an arbitrary file descriptor from parent process to the
    /// child.  This function takes ownership of the `source_fd`; it will be closed
    /// in the parent when `self` is freed.
    ///
    /// By default, all file descriptors from the parent will be closed.
    /// This function allows you to create (for example) a custom ``pipe`` or
    /// ``socketpair`` before launching the process, and choose the target
    /// descriptor in the child.
    ///
    /// An example use case is GNUPG, which has a command line argument
    /// `--passphrase-fd` providing a file descriptor number where it expects
    /// the passphrase to be written.
    extern fn g_subprocess_launcher_take_fd(p_self: *SubprocessLauncher, p_source_fd: c_int, p_target_fd: c_int) void;
    pub const takeFd = g_subprocess_launcher_take_fd;

    /// Sets the file descriptor to use as the stderr for spawned processes.
    ///
    /// If `fd` is -1 then any previously given fd is unset.
    ///
    /// Note that the default behaviour is to pass stderr through to the
    /// stderr of the parent process.
    ///
    /// The passed `fd` belongs to the `gio.SubprocessLauncher`.  It will be
    /// automatically closed when the launcher is finalized.  The file
    /// descriptor will also be closed on the child side when executing the
    /// spawned process.
    ///
    /// You may not set a stderr fd if a stderr file path is already set or
    /// if the launcher flags contain any flags directing stderr elsewhere.
    ///
    /// This feature is only available on UNIX.
    extern fn g_subprocess_launcher_take_stderr_fd(p_self: *SubprocessLauncher, p_fd: c_int) void;
    pub const takeStderrFd = g_subprocess_launcher_take_stderr_fd;

    /// Sets the file descriptor to use as the stdin for spawned processes.
    ///
    /// If `fd` is -1 then any previously given fd is unset.
    ///
    /// Note that if your intention is to have the stdin of the calling
    /// process inherited by the child then `G_SUBPROCESS_FLAGS_STDIN_INHERIT`
    /// is a better way to go about doing that.
    ///
    /// The passed `fd` is noted but will not be touched in the current
    /// process.  It is therefore necessary that it be kept open by the
    /// caller until the subprocess is spawned.  The file descriptor will
    /// also not be explicitly closed on the child side, so it must be marked
    /// O_CLOEXEC if that's what you want.
    ///
    /// You may not set a stdin fd if a stdin file path is already set or if
    /// the launcher flags contain any flags directing stdin elsewhere.
    ///
    /// This feature is only available on UNIX.
    extern fn g_subprocess_launcher_take_stdin_fd(p_self: *SubprocessLauncher, p_fd: c_int) void;
    pub const takeStdinFd = g_subprocess_launcher_take_stdin_fd;

    /// Sets the file descriptor to use as the stdout for spawned processes.
    ///
    /// If `fd` is -1 then any previously given fd is unset.
    ///
    /// Note that the default behaviour is to pass stdout through to the
    /// stdout of the parent process.
    ///
    /// The passed `fd` is noted but will not be touched in the current
    /// process.  It is therefore necessary that it be kept open by the
    /// caller until the subprocess is spawned.  The file descriptor will
    /// also not be explicitly closed on the child side, so it must be marked
    /// O_CLOEXEC if that's what you want.
    ///
    /// You may not set a stdout fd if a stdout file path is already set or
    /// if the launcher flags contain any flags directing stdout elsewhere.
    ///
    /// This feature is only available on UNIX.
    extern fn g_subprocess_launcher_take_stdout_fd(p_self: *SubprocessLauncher, p_fd: c_int) void;
    pub const takeStdoutFd = g_subprocess_launcher_take_stdout_fd;

    /// Removes the environment variable `variable` from the environment of
    /// processes launched from this launcher.
    ///
    /// On UNIX, the variable's name can be an arbitrary byte string not
    /// containing '='. On Windows, it should be in UTF-8.
    extern fn g_subprocess_launcher_unsetenv(p_self: *SubprocessLauncher, p_variable: [*:0]const u8) void;
    pub const unsetenv = g_subprocess_launcher_unsetenv;

    extern fn g_subprocess_launcher_get_type() usize;
    pub const getGObjectType = g_subprocess_launcher_get_type;

    extern fn g_object_ref(p_self: *gio.SubprocessLauncher) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SubprocessLauncher) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SubprocessLauncher, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `GTask` represents and manages a cancellable ‘task’.
///
/// ## Asynchronous operations
///
/// The most common usage of `GTask` is as a `gio.AsyncResult`, to
/// manage data during an asynchronous operation. You call
/// `gio.Task.new` in the ‘start’ method, followed by
/// `gio.Task.setTaskData` and the like if you need to keep some
/// additional data associated with the task, and then pass the
/// task object around through your asynchronous operation.
/// Eventually, you will call a method such as
/// `gio.Task.returnPointer` or `gio.Task.returnError`, which
/// will save the value you give it and then invoke the task’s callback
/// function in the thread-default main context (see
/// `glib.MainContext.pushThreadDefault`)
/// where it was created (waiting until the next iteration of the main
/// loop first, if necessary). The caller will pass the `GTask` back to
/// the operation’s finish function (as a `gio.AsyncResult`), and you can
/// use `gio.Task.propagatePointer` or the like to extract the
/// return value.
///
/// Using `GTask` requires the thread-default `glib.MainContext` from when
/// the `GTask` was constructed to be running at least until the task has
/// completed and its data has been freed.
///
/// If a `GTask` has been constructed and its callback set, it is an error to
/// not call `g_task_return_*()` on it. GLib will warn at runtime if this happens
/// (since 2.76).
///
/// Here is an example for using `GTask` as a `gio.AsyncResult`:
/// ```c
/// typedef struct {
///   CakeFrostingType frosting;
///   char *message;
/// } DecorationData;
///
/// static void
/// decoration_data_free (DecorationData *decoration)
/// {
///   g_free (decoration->message);
///   g_slice_free (DecorationData, decoration);
/// }
///
/// static void
/// baked_cb (Cake     *cake,
///           gpointer  user_data)
/// {
///   GTask *task = user_data;
///   DecorationData *decoration = g_task_get_task_data (task);
///   GError *error = NULL;
///
///   if (cake == NULL)
///     {
///       g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
///                                "Go to the supermarket");
///       g_object_unref (task);
///       return;
///     }
///
///   if (!cake_decorate (cake, decoration->frosting, decoration->message, &error))
///     {
///       g_object_unref (cake);
///       // `gio.Task.returnError` takes ownership of error
///       g_task_return_error (task, error);
///       g_object_unref (task);
///       return;
///     }
///
///   g_task_return_pointer (task, cake, g_object_unref);
///   g_object_unref (task);
/// }
///
/// void
/// baker_bake_cake_async (Baker               *self,
///                        guint                radius,
///                        CakeFlavor           flavor,
///                        CakeFrostingType     frosting,
///                        const char          *message,
///                        GCancellable        *cancellable,
///                        GAsyncReadyCallback  callback,
///                        gpointer             user_data)
/// {
///   GTask *task;
///   DecorationData *decoration;
///   Cake  *cake;
///
///   task = g_task_new (self, cancellable, callback, user_data);
///   if (radius < 3)
///     {
///       g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,
///                                "`ucm` radius cakes are silly",
///                                radius);
///       g_object_unref (task);
///       return;
///     }
///
///   cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);
///   if (cake != NULL)
///     {
///       // `_baker_get_cached_cake` returns a reffed cake
///       g_task_return_pointer (task, cake, g_object_unref);
///       g_object_unref (task);
///       return;
///     }
///
///   decoration = g_slice_new (DecorationData);
///   decoration->frosting = frosting;
///   decoration->message = g_strdup (message);
///   g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);
///
///   _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
/// }
///
/// Cake *
/// baker_bake_cake_finish (Baker         *self,
///                         GAsyncResult  *result,
///                         GError       **error)
/// {
///   g_return_val_if_fail (g_task_is_valid (result, self), NULL);
///
///   return g_task_propagate_pointer (G_TASK (result), error);
/// }
/// ```
///
/// ## Chained asynchronous operations
///
/// `GTask` also tries to simplify asynchronous operations that
/// internally chain together several smaller asynchronous
/// operations. `gio.Task.getCancellable`, `gio.Task.getContext`,
/// and `gio.Task.getPriority` allow you to get back the task’s
/// `gio.Cancellable`, `glib.MainContext`, and
/// [I/O priority](iface.AsyncResult.html`io`-priority)
/// when starting a new subtask, so you don’t have to keep track
/// of them yourself. `gio.Task.attachSource` simplifies the case
/// of waiting for a source to fire (automatically using the correct
/// `glib.MainContext` and priority).
///
/// Here is an example for chained asynchronous operations:
/// ```c
/// typedef struct {
///   Cake *cake;
///   CakeFrostingType frosting;
///   char *message;
/// } BakingData;
///
/// static void
/// decoration_data_free (BakingData *bd)
/// {
///   if (bd->cake)
///     g_object_unref (bd->cake);
///   g_free (bd->message);
///   g_slice_free (BakingData, bd);
/// }
///
/// static void
/// decorated_cb (Cake         *cake,
///               GAsyncResult *result,
///               gpointer      user_data)
/// {
///   GTask *task = user_data;
///   GError *error = NULL;
///
///   if (!cake_decorate_finish (cake, result, &error))
///     {
///       g_object_unref (cake);
///       g_task_return_error (task, error);
///       g_object_unref (task);
///       return;
///     }
///
///   // `baking_data_free` will drop its ref on the cake, so we have to
///   // take another here to give to the caller.
///   g_task_return_pointer (task, g_object_ref (cake), g_object_unref);
///   g_object_unref (task);
/// }
///
/// static gboolean
/// decorator_ready (gpointer user_data)
/// {
///   GTask *task = user_data;
///   BakingData *bd = g_task_get_task_data (task);
///
///   cake_decorate_async (bd->cake, bd->frosting, bd->message,
///                        g_task_get_cancellable (task),
///                        decorated_cb, task);
///
///   return G_SOURCE_REMOVE;
/// }
///
/// static void
/// baked_cb (Cake     *cake,
///           gpointer  user_data)
/// {
///   GTask *task = user_data;
///   BakingData *bd = g_task_get_task_data (task);
///   GError *error = NULL;
///
///   if (cake == NULL)
///     {
///       g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
///                                "Go to the supermarket");
///       g_object_unref (task);
///       return;
///     }
///
///   bd->cake = cake;
///
///   // Bail out now if the user has already cancelled
///   if (g_task_return_error_if_cancelled (task))
///     {
///       g_object_unref (task);
///       return;
///     }
///
///   if (cake_decorator_available (cake))
///     decorator_ready (task);
///   else
///     {
///       GSource *source;
///
///       source = cake_decorator_wait_source_new (cake);
///       // Attach `source` to `task`’s GMainContext and have it call
///       // `decorator_ready` when it is ready.
///       g_task_attach_source (task, source, decorator_ready);
///       g_source_unref (source);
///     }
/// }
///
/// void
/// baker_bake_cake_async (Baker               *self,
///                        guint                radius,
///                        CakeFlavor           flavor,
///                        CakeFrostingType     frosting,
///                        const char          *message,
///                        gint                 priority,
///                        GCancellable        *cancellable,
///                        GAsyncReadyCallback  callback,
///                        gpointer             user_data)
/// {
///   GTask *task;
///   BakingData *bd;
///
///   task = g_task_new (self, cancellable, callback, user_data);
///   g_task_set_priority (task, priority);
///
///   bd = g_slice_new0 (BakingData);
///   bd->frosting = frosting;
///   bd->message = g_strdup (message);
///   g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);
///
///   _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
/// }
///
/// Cake *
/// baker_bake_cake_finish (Baker         *self,
///                         GAsyncResult  *result,
///                         GError       **error)
/// {
///   g_return_val_if_fail (g_task_is_valid (result, self), NULL);
///
///   return g_task_propagate_pointer (G_TASK (result), error);
/// }
/// ```
///
/// ## Asynchronous operations from synchronous ones
///
/// You can use `gio.Task.runInThread` to turn a synchronous
/// operation into an asynchronous one, by running it in a thread.
/// When it completes, the result will be dispatched to the thread-default
/// main context (see `glib.MainContext.pushThreadDefault`)
/// where the `GTask` was created.
///
/// Running a task in a thread:
/// ```c
/// typedef struct {
///   guint radius;
///   CakeFlavor flavor;
///   CakeFrostingType frosting;
///   char *message;
/// } CakeData;
///
/// static void
/// cake_data_free (CakeData *cake_data)
/// {
///   g_free (cake_data->message);
///   g_slice_free (CakeData, cake_data);
/// }
///
/// static void
/// bake_cake_thread (GTask         *task,
///                   gpointer       source_object,
///                   gpointer       task_data,
///                   GCancellable  *cancellable)
/// {
///   Baker *self = source_object;
///   CakeData *cake_data = task_data;
///   Cake *cake;
///   GError *error = NULL;
///
///   cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
///                     cake_data->frosting, cake_data->message,
///                     cancellable, &error);
///   if (cake)
///     g_task_return_pointer (task, cake, g_object_unref);
///   else
///     g_task_return_error (task, error);
/// }
///
/// void
/// baker_bake_cake_async (Baker               *self,
///                        guint                radius,
///                        CakeFlavor           flavor,
///                        CakeFrostingType     frosting,
///                        const char          *message,
///                        GCancellable        *cancellable,
///                        GAsyncReadyCallback  callback,
///                        gpointer             user_data)
/// {
///   CakeData *cake_data;
///   GTask *task;
///
///   cake_data = g_slice_new (CakeData);
///   cake_data->radius = radius;
///   cake_data->flavor = flavor;
///   cake_data->frosting = frosting;
///   cake_data->message = g_strdup (message);
///   task = g_task_new (self, cancellable, callback, user_data);
///   g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
///   g_task_run_in_thread (task, bake_cake_thread);
///   g_object_unref (task);
/// }
///
/// Cake *
/// baker_bake_cake_finish (Baker         *self,
///                         GAsyncResult  *result,
///                         GError       **error)
/// {
///   g_return_val_if_fail (g_task_is_valid (result, self), NULL);
///
///   return g_task_propagate_pointer (G_TASK (result), error);
/// }
/// ```
///
/// ## Adding cancellability to uncancellable tasks
///
/// Finally, `gio.Task.runInThread` and
/// `gio.Task.runInThreadSync` can be used to turn an uncancellable
/// operation into a cancellable one. If you call
/// `gio.Task.setReturnOnCancel`, passing `TRUE`, then if the task’s
/// `gio.Cancellable` is cancelled, it will return control back to the
/// caller immediately, while allowing the task thread to continue running in the
/// background (and simply discarding its result when it finally does finish).
/// Provided that the task thread is careful about how it uses
/// locks and other externally-visible resources, this allows you
/// to make ‘GLib-friendly’ asynchronous and cancellable
/// synchronous variants of blocking APIs.
///
/// Cancelling a task:
/// ```c
/// static void
/// bake_cake_thread (GTask         *task,
///                   gpointer       source_object,
///                   gpointer       task_data,
///                   GCancellable  *cancellable)
/// {
///   Baker *self = source_object;
///   CakeData *cake_data = task_data;
///   Cake *cake;
///   GError *error = NULL;
///
///   cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
///                     cake_data->frosting, cake_data->message,
///                     &error);
///   if (error)
///     {
///       g_task_return_error (task, error);
///       return;
///     }
///
///   // If the task has already been cancelled, then we don’t want to add
///   // the cake to the cake cache. Likewise, we don’t  want to have the
///   // task get cancelled in the middle of updating the cache.
///   // `gio.Task.setReturnOnCancel` will return `TRUE` here if it managed
///   // to disable return-on-cancel, or `FALSE` if the task was cancelled
///   // before it could.
///   if (g_task_set_return_on_cancel (task, FALSE))
///     {
///       // If the caller cancels at this point, their
///       // GAsyncReadyCallback won’t be invoked until we return,
///       // so we don’t have to worry that this code will run at
///       // the same time as that code does. But if there were
///       // other functions that might look at the cake cache,
///       // then we’d probably need a GMutex here as well.
///       baker_add_cake_to_cache (baker, cake);
///       g_task_return_pointer (task, cake, g_object_unref);
///     }
/// }
///
/// void
/// baker_bake_cake_async (Baker               *self,
///                        guint                radius,
///                        CakeFlavor           flavor,
///                        CakeFrostingType     frosting,
///                        const char          *message,
///                        GCancellable        *cancellable,
///                        GAsyncReadyCallback  callback,
///                        gpointer             user_data)
/// {
///   CakeData *cake_data;
///   GTask *task;
///
///   cake_data = g_slice_new (CakeData);
///
///   ...
///
///   task = g_task_new (self, cancellable, callback, user_data);
///   g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
///   g_task_set_return_on_cancel (task, TRUE);
///   g_task_run_in_thread (task, bake_cake_thread);
/// }
///
/// Cake *
/// baker_bake_cake_sync (Baker               *self,
///                       guint                radius,
///                       CakeFlavor           flavor,
///                       CakeFrostingType     frosting,
///                       const char          *message,
///                       GCancellable        *cancellable,
///                       GError             **error)
/// {
///   CakeData *cake_data;
///   GTask *task;
///   Cake *cake;
///
///   cake_data = g_slice_new (CakeData);
///
///   ...
///
///   task = g_task_new (self, cancellable, NULL, NULL);
///   g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
///   g_task_set_return_on_cancel (task, TRUE);
///   g_task_run_in_thread_sync (task, bake_cake_thread);
///
///   cake = g_task_propagate_pointer (task, error);
///   g_object_unref (task);
///   return cake;
/// }
/// ```
///
/// ## Porting from [class@Gio.SimpleAsyncResult]
///
/// `GTask`’s API attempts to be simpler than `gio.SimpleAsyncResult`’s
/// in several ways:
///
/// - You can save task-specific data with `gio.Task.setTaskData`, and
///   retrieve it later with `gio.Task.getTaskData`. This replaces the
///   abuse of `gio.SimpleAsyncResult.setOpResGpointer` for the same
///   purpose with `gio.SimpleAsyncResult`.
/// - In addition to the task data, `GTask` also keeps track of the
///   [priority](iface.AsyncResult.html`io`-priority), `gio.Cancellable`,
///   and `glib.MainContext` associated with the task, so tasks that
///   consist of a chain of simpler asynchronous operations will have easy access
///   to those values when starting each sub-task.
/// - `gio.Task.returnErrorIfCancelled` provides simplified
///   handling for cancellation. In addition, cancellation
///   overrides any other `GTask` return value by default, like
///   `gio.SimpleAsyncResult` does when
///   `gio.SimpleAsyncResult.setCheckCancellable` is called.
///   (You can use `gio.Task.setCheckCancellable` to turn off that
///   behavior.) On the other hand, `gio.Task.runInThread`
///   guarantees that it will always run your
///   `task_func`, even if the task’s `gio.Cancellable`
///   is already cancelled before the task gets a chance to run;
///   you can start your `task_func` with a
///   `gio.Task.returnErrorIfCancelled` check if you need the
///   old behavior.
/// - The ‘return’ methods (eg, `gio.Task.returnPointer`)
///   automatically cause the task to be ‘completed’ as well, and
///   there is no need to worry about the ‘complete’ vs ‘complete in idle’
///   distinction. (`GTask` automatically figures out
///   whether the task’s callback can be invoked directly, or
///   if it needs to be sent to another `glib.MainContext`, or delayed
///   until the next iteration of the current `glib.MainContext`.)
/// - The ‘finish’ functions for `GTask` based operations are generally
///   much simpler than `gio.SimpleAsyncResult` ones, normally consisting
///   of only a single call to `gio.Task.propagatePointer` or the like.
///   Since `gio.Task.propagatePointer` ‘steals’ the return value from
///   the `GTask`, it is not necessary to juggle pointers around to
///   prevent it from being freed twice.
/// - With `gio.SimpleAsyncResult`, it was common to call
///   `gio.SimpleAsyncResult.propagateError` from the
///   ``_finish`` wrapper function, and have
///   virtual method implementations only deal with successful
///   returns. This behavior is deprecated, because it makes it
///   difficult for a subclass to chain to a parent class’s async
///   methods. Instead, the wrapper function should just be a
///   simple wrapper, and the virtual method should call an
///   appropriate `g_task_propagate_` function.
///   Note that wrapper methods can now use
///   `gio.AsyncResult.legacyPropagateError` to do old-style
///   `gio.SimpleAsyncResult` error-returning behavior, and
///   `gio.AsyncResult.isTagged` to check if a result is tagged as
///   having come from the ``_async`` wrapper
///   function (for ‘short-circuit’ results, such as when passing
///   `0` to `gio.InputStream.readAsync`).
///
/// ## Thread-safety considerations
///
/// Due to some infelicities in the API design, there is a
/// thread-safety concern that users of `GTask` have to be aware of:
///
/// If the `main` thread drops its last reference to the source object
/// or the task data before the task is finalized, then the finalizers
/// of these objects may be called on the worker thread.
///
/// This is a problem if the finalizers use non-threadsafe API, and
/// can lead to hard-to-debug crashes. Possible workarounds include:
///
/// - Clear task data in a signal handler for `notify::completed`
/// - Keep iterating a main context in the main thread and defer
///   dropping the reference to the source object to that main
///   context when the task is finalized
pub const Task = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.AsyncResult};
    pub const Class = gio.TaskClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Whether the task has completed, meaning its callback (if set) has been
        /// invoked.
        ///
        /// This can only happen after `gio.Task.returnPointer`,
        /// `gio.Task.returnError` or one of the other return functions have been called
        /// on the task. However, it is not guaranteed to happen immediately after
        /// those functions are called, as the task’s callback may need to be scheduled
        /// to run in a different thread.
        ///
        /// That means it is **not safe** to use this property to track whether a
        /// return function has been called on the `gio.Task`. Callers must do that
        /// tracking themselves, typically by linking the lifetime of the `gio.Task` to the
        /// control flow of their code.
        ///
        /// This property is guaranteed to change from `FALSE` to `TRUE` exactly once.
        ///
        /// The `gobject.Object.signals.notify` signal for this change is emitted in the same main
        /// context as the task’s callback, immediately after that callback is invoked.
        pub const completed = struct {
            pub const name = "completed";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Checks that `result` is a `gio.Task`, and that `source_object` is its
    /// source object (or that `source_object` is `NULL` and `result` has no
    /// source object). This can be used in `g_return_if_fail` checks.
    extern fn g_task_is_valid(p_result: *gio.AsyncResult, p_source_object: ?*gobject.Object) c_int;
    pub const isValid = g_task_is_valid;

    /// Creates a `gio.Task` and then immediately calls `gio.Task.returnError`
    /// on it. Use this in the wrapper function of an asynchronous method
    /// when you want to avoid even calling the virtual method. You can
    /// then use `gio.AsyncResult.isTagged` in the finish method wrapper to
    /// check if the result there is tagged as having been created by the
    /// wrapper method, and deal with it appropriately if so.
    ///
    /// See also `gio.Task.reportNewError`.
    extern fn g_task_report_error(p_source_object: ?*gobject.Object, p_callback: ?gio.AsyncReadyCallback, p_callback_data: ?*anyopaque, p_source_tag: ?*anyopaque, p_error: *glib.Error) void;
    pub const reportError = g_task_report_error;

    /// Creates a `gio.Task` and then immediately calls
    /// `gio.Task.returnNewError` on it. Use this in the wrapper function
    /// of an asynchronous method when you want to avoid even calling the
    /// virtual method. You can then use `gio.AsyncResult.isTagged` in the
    /// finish method wrapper to check if the result there is tagged as
    /// having been created by the wrapper method, and deal with it
    /// appropriately if so.
    ///
    /// See also `gio.Task.reportError`.
    extern fn g_task_report_new_error(p_source_object: ?*gobject.Object, p_callback: ?gio.AsyncReadyCallback, p_callback_data: ?*anyopaque, p_source_tag: ?*anyopaque, p_domain: glib.Quark, p_code: c_int, p_format: [*:0]const u8, ...) void;
    pub const reportNewError = g_task_report_new_error;

    /// Creates a `gio.Task` acting on `source_object`, which will eventually be
    /// used to invoke `callback` in the current thread-default main context
    /// (see `glib.MainContext.pushThreadDefault`).
    ///
    /// Call this in the "start" method of your asynchronous method, and
    /// pass the `gio.Task` around throughout the asynchronous operation. You
    /// can use `gio.Task.setTaskData` to attach task-specific data to the
    /// object, which you can retrieve later via `gio.Task.getTaskData`.
    ///
    /// By default, if `cancellable` is cancelled, then the return value of
    /// the task will always be `G_IO_ERROR_CANCELLED`, even if the task had
    /// already completed before the cancellation. This allows for
    /// simplified handling in cases where cancellation may imply that
    /// other objects that the task depends on have been destroyed. If you
    /// do not want this behavior, you can use
    /// `gio.Task.setCheckCancellable` to change it.
    extern fn g_task_new(p_source_object: ?*gobject.Object, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_callback_data: ?*anyopaque) *gio.Task;
    pub const new = g_task_new;

    /// A utility function for dealing with async operations where you need
    /// to wait for a `glib.Source` to trigger. Attaches `source` to `task`'s
    /// `glib.MainContext` with `task`'s [priority](iface.AsyncResult.html`io`-priority),
    /// and sets `source`'s callback to `callback`, with `task` as the callback's
    /// `user_data`.
    ///
    /// It will set the `source`’s name to the task’s name (as set with
    /// `gio.Task.setName`), if one has been set on the task and the source doesn’t
    /// yet have a name.
    ///
    /// This takes a reference on `task` until `source` is destroyed.
    extern fn g_task_attach_source(p_task: *Task, p_source: *glib.Source, p_callback: glib.SourceFunc) void;
    pub const attachSource = g_task_attach_source;

    /// Gets `task`'s `gio.Cancellable`
    extern fn g_task_get_cancellable(p_task: *Task) ?*gio.Cancellable;
    pub const getCancellable = g_task_get_cancellable;

    /// Gets `task`'s check-cancellable flag. See
    /// `gio.Task.setCheckCancellable` for more details.
    extern fn g_task_get_check_cancellable(p_task: *Task) c_int;
    pub const getCheckCancellable = g_task_get_check_cancellable;

    /// Gets the value of `gio.Task.properties.completed`. This changes from `FALSE` to `TRUE` after
    /// the task’s callback is invoked, and will return `FALSE` if called from inside
    /// the callback.
    extern fn g_task_get_completed(p_task: *Task) c_int;
    pub const getCompleted = g_task_get_completed;

    /// Gets the `glib.MainContext` that `task` will return its result in (that
    /// is, the context that was the thread-default main context
    /// (see `glib.MainContext.pushThreadDefault`)
    /// at the point when `task` was created).
    ///
    /// This will always return a non-`NULL` value, even if the task's
    /// context is the default `glib.MainContext`.
    extern fn g_task_get_context(p_task: *Task) *glib.MainContext;
    pub const getContext = g_task_get_context;

    /// Gets `task`’s name. See `gio.Task.setName`.
    extern fn g_task_get_name(p_task: *Task) ?[*:0]const u8;
    pub const getName = g_task_get_name;

    /// Gets `task`'s priority
    extern fn g_task_get_priority(p_task: *Task) c_int;
    pub const getPriority = g_task_get_priority;

    /// Gets `task`'s return-on-cancel flag. See
    /// `gio.Task.setReturnOnCancel` for more details.
    extern fn g_task_get_return_on_cancel(p_task: *Task) c_int;
    pub const getReturnOnCancel = g_task_get_return_on_cancel;

    /// Gets the source object from `task`. Like
    /// `gio.AsyncResult.getSourceObject`, but does not ref the object.
    extern fn g_task_get_source_object(p_task: *Task) ?*gobject.Object;
    pub const getSourceObject = g_task_get_source_object;

    /// Gets `task`'s source tag. See `gio.Task.setSourceTag`.
    extern fn g_task_get_source_tag(p_task: *Task) ?*anyopaque;
    pub const getSourceTag = g_task_get_source_tag;

    /// Gets `task`'s `task_data`.
    extern fn g_task_get_task_data(p_task: *Task) ?*anyopaque;
    pub const getTaskData = g_task_get_task_data;

    /// Tests if `task` resulted in an error.
    extern fn g_task_had_error(p_task: *Task) c_int;
    pub const hadError = g_task_had_error;

    /// Gets the result of `task` as a `gboolean`.
    ///
    /// If the task resulted in an error, or was cancelled, then this will
    /// instead return `FALSE` and set `error`.
    ///
    /// Since this method transfers ownership of the return value (or
    /// error) to the caller, you may only call it once.
    extern fn g_task_propagate_boolean(p_task: *Task, p_error: ?*?*glib.Error) c_int;
    pub const propagateBoolean = g_task_propagate_boolean;

    /// Gets the result of `task` as an integer (`gssize`).
    ///
    /// If the task resulted in an error, or was cancelled, then this will
    /// instead return -1 and set `error`.
    ///
    /// Since this method transfers ownership of the return value (or
    /// error) to the caller, you may only call it once.
    extern fn g_task_propagate_int(p_task: *Task, p_error: ?*?*glib.Error) isize;
    pub const propagateInt = g_task_propagate_int;

    /// Gets the result of `task` as a pointer, and transfers ownership
    /// of that value to the caller.
    ///
    /// If the task resulted in an error, or was cancelled, then this will
    /// instead return `NULL` and set `error`.
    ///
    /// Since this method transfers ownership of the return value (or
    /// error) to the caller, you may only call it once.
    extern fn g_task_propagate_pointer(p_task: *Task, p_error: ?*?*glib.Error) ?*anyopaque;
    pub const propagatePointer = g_task_propagate_pointer;

    /// Gets the result of `task` as a `gobject.Value`, and transfers ownership of
    /// that value to the caller. As with `gio.Task.returnValue`, this is
    /// a generic low-level method; `gio.Task.propagatePointer` and the like
    /// will usually be more useful for C code.
    ///
    /// If the task resulted in an error, or was cancelled, then this will
    /// instead set `error` and return `FALSE`.
    ///
    /// Since this method transfers ownership of the return value (or
    /// error) to the caller, you may only call it once.
    extern fn g_task_propagate_value(p_task: *Task, p_value: *gobject.Value, p_error: ?*?*glib.Error) c_int;
    pub const propagateValue = g_task_propagate_value;

    /// Sets `task`'s result to `result` and completes the task (see
    /// `gio.Task.returnPointer` for more discussion of exactly what this
    /// means).
    extern fn g_task_return_boolean(p_task: *Task, p_result: c_int) void;
    pub const returnBoolean = g_task_return_boolean;

    /// Sets `task`'s result to `error` (which `task` assumes ownership of)
    /// and completes the task (see `gio.Task.returnPointer` for more
    /// discussion of exactly what this means).
    ///
    /// Note that since the task takes ownership of `error`, and since the
    /// task may be completed before returning from `gio.Task.returnError`,
    /// you cannot assume that `error` is still valid after calling this.
    /// Call `glib.Error.copy` on the error if you need to keep a local copy
    /// as well.
    ///
    /// See also `gio.Task.returnNewError`,
    /// `gio.Task.returnNewErrorLiteral`.
    extern fn g_task_return_error(p_task: *Task, p_error: *glib.Error) void;
    pub const returnError = g_task_return_error;

    /// Checks if `task`'s `gio.Cancellable` has been cancelled, and if so, sets
    /// `task`'s error accordingly and completes the task (see
    /// `gio.Task.returnPointer` for more discussion of exactly what this
    /// means).
    extern fn g_task_return_error_if_cancelled(p_task: *Task) c_int;
    pub const returnErrorIfCancelled = g_task_return_error_if_cancelled;

    /// Sets `task`'s result to `result` and completes the task (see
    /// `gio.Task.returnPointer` for more discussion of exactly what this
    /// means).
    extern fn g_task_return_int(p_task: *Task, p_result: isize) void;
    pub const returnInt = g_task_return_int;

    /// Sets `task`'s result to a new `glib.Error` created from `domain`, `code`,
    /// `format`, and the remaining arguments, and completes the task (see
    /// `gio.Task.returnPointer` for more discussion of exactly what this
    /// means).
    ///
    /// See also `gio.Task.returnError`.
    extern fn g_task_return_new_error(p_task: *Task, p_domain: glib.Quark, p_code: c_int, p_format: [*:0]const u8, ...) void;
    pub const returnNewError = g_task_return_new_error;

    /// Sets `task`’s result to a new `glib.Error` created from `domain`, `code`,
    /// `message` and completes the task.
    ///
    /// See `gio.Task.returnPointer` for more discussion of exactly what
    /// ‘completing the task’ means.
    ///
    /// See also `gio.Task.returnNewError`.
    extern fn g_task_return_new_error_literal(p_task: *Task, p_domain: glib.Quark, p_code: c_int, p_message: [*:0]const u8) void;
    pub const returnNewErrorLiteral = g_task_return_new_error_literal;

    /// Sets `task`'s result to `result` and completes the task. If `result`
    /// is not `NULL`, then `result_destroy` will be used to free `result` if
    /// the caller does not take ownership of it with
    /// `gio.Task.propagatePointer`.
    ///
    /// "Completes the task" means that for an ordinary asynchronous task
    /// it will either invoke the task's callback, or else queue that
    /// callback to be invoked in the proper `glib.MainContext`, or in the next
    /// iteration of the current `glib.MainContext`. For a task run via
    /// `gio.Task.runInThread` or `gio.Task.runInThreadSync`, calling this
    /// method will save `result` to be returned to the caller later, but
    /// the task will not actually be completed until the `gio.TaskThreadFunc`
    /// exits.
    ///
    /// Note that since the task may be completed before returning from
    /// `gio.Task.returnPointer`, you cannot assume that `result` is still
    /// valid after calling this, unless you are still holding another
    /// reference on it.
    extern fn g_task_return_pointer(p_task: *Task, p_result: ?*anyopaque, p_result_destroy: ?glib.DestroyNotify) void;
    pub const returnPointer = g_task_return_pointer;

    /// Sets `task`'s result to `error` (which `task` assumes ownership of), with
    /// the message prefixed according to `format`, and completes the task
    /// (see `gio.Task.returnPointer` for more discussion of exactly what this
    /// means).
    ///
    /// Note that since the task takes ownership of `error`, and since the
    /// task may be completed before returning from `gio.Task.returnPrefixedError`,
    /// you cannot assume that `error` is still valid after calling this.
    /// Call `glib.Error.copy` on the error if you need to keep a local copy
    /// as well.
    ///
    /// See also `gio.Task.returnError`, `glib.prefixError`.
    extern fn g_task_return_prefixed_error(p_task: *Task, p_error: *glib.Error, p_format: [*:0]const u8, ...) void;
    pub const returnPrefixedError = g_task_return_prefixed_error;

    /// Sets `task`'s result to `result` (by copying it) and completes the task.
    ///
    /// If `result` is `NULL` then a `gobject.Value` of type `G_TYPE_POINTER`
    /// with a value of `NULL` will be used for the result.
    ///
    /// This is a very generic low-level method intended primarily for use
    /// by language bindings; for C code, `gio.Task.returnPointer` and the
    /// like will normally be much easier to use.
    extern fn g_task_return_value(p_task: *Task, p_result: ?*gobject.Value) void;
    pub const returnValue = g_task_return_value;

    /// Runs `task_func` in another thread. When `task_func` returns, `task`'s
    /// `gio.AsyncReadyCallback` will be invoked in `task`'s `glib.MainContext`.
    ///
    /// This takes a ref on `task` until the task completes.
    ///
    /// See `gio.TaskThreadFunc` for more details about how `task_func` is handled.
    ///
    /// Although GLib currently rate-limits the tasks queued via
    /// `gio.Task.runInThread`, you should not assume that it will always
    /// do this. If you have a very large number of tasks to run (several tens of
    /// tasks), but don't want them to all run at once, you should only queue a
    /// limited number of them (around ten) at a time.
    ///
    /// Be aware that if your task depends on other tasks to complete, use of this
    /// function could lead to a livelock if the other tasks also use this function
    /// and enough of them (around 10) execute in a dependency chain, as that will
    /// exhaust the thread pool. If this situation is possible, consider using a
    /// separate worker thread or thread pool explicitly, rather than using
    /// `gio.Task.runInThread`.
    extern fn g_task_run_in_thread(p_task: *Task, p_task_func: gio.TaskThreadFunc) void;
    pub const runInThread = g_task_run_in_thread;

    /// Runs `task_func` in another thread, and waits for it to return or be
    /// cancelled. You can use `gio.Task.propagatePointer`, etc, afterward
    /// to get the result of `task_func`.
    ///
    /// See `gio.TaskThreadFunc` for more details about how `task_func` is handled.
    ///
    /// Normally this is used with tasks created with a `NULL`
    /// `callback`, but note that even if the task does
    /// have a callback, it will not be invoked when `task_func` returns.
    /// `gio.Task.properties.completed` will be set to `TRUE` just before this function returns.
    ///
    /// Although GLib currently rate-limits the tasks queued via
    /// `gio.Task.runInThreadSync`, you should not assume that it will
    /// always do this. If you have a very large number of tasks to run,
    /// but don't want them to all run at once, you should only queue a
    /// limited number of them at a time.
    extern fn g_task_run_in_thread_sync(p_task: *Task, p_task_func: gio.TaskThreadFunc) void;
    pub const runInThreadSync = g_task_run_in_thread_sync;

    /// Sets or clears `task`'s check-cancellable flag. If this is `TRUE`
    /// (the default), then `gio.Task.propagatePointer`, etc, and
    /// `gio.Task.hadError` will check the task's `gio.Cancellable` first, and
    /// if it has been cancelled, then they will consider the task to have
    /// returned an "Operation was cancelled" error
    /// (`G_IO_ERROR_CANCELLED`), regardless of any other error or return
    /// value the task may have had.
    ///
    /// If `check_cancellable` is `FALSE`, then the `gio.Task` will not check the
    /// cancellable itself, and it is up to `task`'s owner to do this (eg,
    /// via `gio.Task.returnErrorIfCancelled`).
    ///
    /// If you are using `gio.Task.setReturnOnCancel` as well, then
    /// you must leave check-cancellable set `TRUE`.
    extern fn g_task_set_check_cancellable(p_task: *Task, p_check_cancellable: c_int) void;
    pub const setCheckCancellable = g_task_set_check_cancellable;

    /// Sets `task`’s name, used in debugging and profiling. The name defaults to
    /// `NULL`.
    ///
    /// The task name should describe in a human readable way what the task does.
    /// For example, ‘Open file’ or ‘Connect to network host’. It is used to set the
    /// name of the `glib.Source` used for idle completion of the task.
    ///
    /// This function may only be called before the `task` is first used in a thread
    /// other than the one it was constructed in.
    extern fn g_task_set_name(p_task: *Task, p_name: ?[*:0]const u8) void;
    pub const setName = g_task_set_name;

    /// Sets `task`'s priority. If you do not call this, it will default to
    /// `G_PRIORITY_DEFAULT`.
    ///
    /// This will affect the priority of `GSources` created with
    /// `gio.Task.attachSource` and the scheduling of tasks run in threads,
    /// and can also be explicitly retrieved later via
    /// `gio.Task.getPriority`.
    extern fn g_task_set_priority(p_task: *Task, p_priority: c_int) void;
    pub const setPriority = g_task_set_priority;

    /// Sets or clears `task`'s return-on-cancel flag. This is only
    /// meaningful for tasks run via `gio.Task.runInThread` or
    /// `gio.Task.runInThreadSync`.
    ///
    /// If `return_on_cancel` is `TRUE`, then cancelling `task`'s
    /// `gio.Cancellable` will immediately cause it to return, as though the
    /// task's `gio.TaskThreadFunc` had called
    /// `gio.Task.returnErrorIfCancelled` and then returned.
    ///
    /// This allows you to create a cancellable wrapper around an
    /// uninterruptible function. The `gio.TaskThreadFunc` just needs to be
    /// careful that it does not modify any externally-visible state after
    /// it has been cancelled. To do that, the thread should call
    /// `gio.Task.setReturnOnCancel` again to (atomically) set
    /// return-on-cancel `FALSE` before making externally-visible changes;
    /// if the task gets cancelled before the return-on-cancel flag could
    /// be changed, `gio.Task.setReturnOnCancel` will indicate this by
    /// returning `FALSE`.
    ///
    /// You can disable and re-enable this flag multiple times if you wish.
    /// If the task's `gio.Cancellable` is cancelled while return-on-cancel is
    /// `FALSE`, then calling `gio.Task.setReturnOnCancel` to set it `TRUE`
    /// again will cause the task to be cancelled at that point.
    ///
    /// If the task's `gio.Cancellable` is already cancelled before you call
    /// `gio.Task.runInThread`/`gio.Task.runInThreadSync`, then the
    /// `gio.TaskThreadFunc` will still be run (for consistency), but the task
    /// will also be completed right away.
    extern fn g_task_set_return_on_cancel(p_task: *Task, p_return_on_cancel: c_int) c_int;
    pub const setReturnOnCancel = g_task_set_return_on_cancel;

    /// Sets `task`'s source tag.
    ///
    /// You can use this to tag a task return
    /// value with a particular pointer (usually a pointer to the function
    /// doing the tagging) and then later check it using
    /// `gio.Task.getSourceTag` (or `gio.AsyncResult.isTagged`) in the
    /// task's "finish" function, to figure out if the response came from a
    /// particular place.
    ///
    /// A macro wrapper around this function will automatically set the
    /// task’s name to the string form of `source_tag` if it’s not already
    /// set, for convenience.
    extern fn g_task_set_source_tag(p_task: *Task, p_source_tag: ?*anyopaque) void;
    pub const setSourceTag = g_task_set_source_tag;

    /// Sets `task`’s name, used in debugging and profiling.
    ///
    /// This is a variant of `gio.Task.setName` that avoids copying `name`.
    ///
    /// This function is called automatically by `gio.Task.setSourceTag`
    /// unless a name is set.
    extern fn g_task_set_static_name(p_task: *Task, p_name: ?[*:0]const u8) void;
    pub const setStaticName = g_task_set_static_name;

    /// Sets `task`'s task data (freeing the existing task data, if any).
    extern fn g_task_set_task_data(p_task: *Task, p_task_data: ?*anyopaque, p_task_data_destroy: ?glib.DestroyNotify) void;
    pub const setTaskData = g_task_set_task_data;

    extern fn g_task_get_type() usize;
    pub const getGObjectType = g_task_get_type;

    extern fn g_object_ref(p_self: *gio.Task) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Task) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Task, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// This is the subclass of `gio.SocketConnection` that is created
/// for TCP/IP sockets.
pub const TcpConnection = extern struct {
    pub const Parent = gio.SocketConnection;
    pub const Implements = [_]type{};
    pub const Class = gio.TcpConnectionClass;
    f_parent_instance: gio.SocketConnection,
    f_priv: ?*gio.TcpConnectionPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Whether `gio.IOStream.close` does a graceful disconnect.
        pub const graceful_disconnect = struct {
            pub const name = "graceful-disconnect";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Checks if graceful disconnects are used. See
    /// `gio.TcpConnection.setGracefulDisconnect`.
    extern fn g_tcp_connection_get_graceful_disconnect(p_connection: *TcpConnection) c_int;
    pub const getGracefulDisconnect = g_tcp_connection_get_graceful_disconnect;

    /// This enables graceful disconnects on close. A graceful disconnect
    /// means that we signal the receiving end that the connection is terminated
    /// and wait for it to close the connection before closing the connection.
    ///
    /// A graceful disconnect means that we can be sure that we successfully sent
    /// all the outstanding data to the other end, or get an error reported.
    /// However, it also means we have to wait for all the data to reach the
    /// other side and for it to acknowledge this by closing the socket, which may
    /// take a while. For this reason it is disabled by default.
    extern fn g_tcp_connection_set_graceful_disconnect(p_connection: *TcpConnection, p_graceful_disconnect: c_int) void;
    pub const setGracefulDisconnect = g_tcp_connection_set_graceful_disconnect;

    extern fn g_tcp_connection_get_type() usize;
    pub const getGObjectType = g_tcp_connection_get_type;

    extern fn g_object_ref(p_self: *gio.TcpConnection) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.TcpConnection) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TcpConnection, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `GTcpWrapperConnection` can be used to wrap a `gio.IOStream` that is
/// based on a `gio.Socket`, but which is not actually a
/// `gio.SocketConnection`. This is used by `gio.SocketClient` so
/// that it can always return a `gio.SocketConnection`, even when the
/// connection it has actually created is not directly a
/// `gio.SocketConnection`.
pub const TcpWrapperConnection = extern struct {
    pub const Parent = gio.TcpConnection;
    pub const Implements = [_]type{};
    pub const Class = gio.TcpWrapperConnectionClass;
    f_parent_instance: gio.TcpConnection,
    f_priv: ?*gio.TcpWrapperConnectionPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The wrapped `gio.IOStream`.
        pub const base_io_stream = struct {
            pub const name = "base-io-stream";

            pub const Type = ?*gio.IOStream;
        };
    };

    pub const signals = struct {};

    /// Wraps `base_io_stream` and `socket` together as a `gio.SocketConnection`.
    extern fn g_tcp_wrapper_connection_new(p_base_io_stream: *gio.IOStream, p_socket: *gio.Socket) *gio.TcpWrapperConnection;
    pub const new = g_tcp_wrapper_connection_new;

    /// Gets `conn`'s base `gio.IOStream`
    extern fn g_tcp_wrapper_connection_get_base_io_stream(p_conn: *TcpWrapperConnection) *gio.IOStream;
    pub const getBaseIoStream = g_tcp_wrapper_connection_get_base_io_stream;

    extern fn g_tcp_wrapper_connection_get_type() usize;
    pub const getGObjectType = g_tcp_wrapper_connection_get_type;

    extern fn g_object_ref(p_self: *gio.TcpWrapperConnection) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.TcpWrapperConnection) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TcpWrapperConnection, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A helper class for testing code which uses D-Bus without touching the user’s
/// session bus.
///
/// Note that `GTestDBus` modifies the user’s environment, calling
/// [``setenv``](man:setenv(3)). This is not thread-safe, so all `GTestDBus`
/// calls should be completed before threads are spawned, or should have
/// appropriate locking to ensure no access conflicts to environment variables
/// shared between `GTestDBus` and other threads.
///
/// ## Creating unit tests using `GTestDBus`
///
/// Testing of D-Bus services can be tricky because normally we only ever run
/// D-Bus services over an existing instance of the D-Bus daemon thus we
/// usually don’t activate D-Bus services that are not yet installed into the
/// target system. The `GTestDBus` object makes this easier for us by taking care
/// of the lower level tasks such as running a private D-Bus daemon and looking
/// up uninstalled services in customizable locations, typically in your source
/// code tree.
///
/// The first thing you will need is a separate service description file for the
/// D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
/// is a good place to put this file.
///
/// The service file should list your service along with an absolute path to the
/// uninstalled service executable in your source tree. Using autotools we would
/// achieve this by adding a file such as `my-server.service.in` in the services
/// directory and have it processed by configure.
///
/// ```
/// [D-BUS Service]
/// Name=org.gtk.GDBus.Examples.ObjectManager
/// Exec=`abs_top_builddir`@/gio/tests/gdbus-example-objectmanager-server
/// ```
///
/// You will also need to indicate this service directory in your test
/// fixtures, so you will need to pass the path while compiling your
/// test cases. Typically this is done with autotools with an added
/// preprocessor flag specified to compile your tests such as:
///
/// ```
/// -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
/// ```
///
/// Once you have a service definition file which is local to your source tree,
/// you can proceed to set up a GTest fixture using the `GTestDBus` scaffolding.
///
/// An example of a test fixture for D-Bus services can be found
/// here:
/// [gdbus-test-fixture.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-test-fixture.c)
///
/// Note that these examples only deal with isolating the D-Bus aspect of your
/// service. To successfully run isolated unit tests on your service you may need
/// some additional modifications to your test case fixture. For example; if your
/// service uses `gio.Settings` and installs a schema then it is important
/// that your test service not load the schema in the ordinary installed location
/// (chances are that your service and schema files are not yet installed, or
/// worse; there is an older version of the schema file sitting in the install
/// location).
///
/// Most of the time we can work around these obstacles using the
/// environment. Since the environment is inherited by the D-Bus daemon
/// created by `GTestDBus` and then in turn inherited by any services the
/// D-Bus daemon activates, using the setup routine for your fixture is
/// a practical place to help sandbox your runtime environment. For the
/// rather typical GSettings case we can work around this by setting
/// `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your schemas
/// in the above ``fixture_setup`` routine.
///
/// The GSettings schemas need to be locally pre-compiled for this to work. This
/// can be achieved by compiling the schemas locally as a step before running
/// test cases, an autotools setup might do the following in the directory
/// holding schemas:
///
/// ```
///     all-am:
///             $(GLIB_COMPILE_SCHEMAS) .
///
///     CLEANFILES += gschemas.compiled
/// ```
pub const TestDBus = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = opaque {
        pub const Instance = TestDBus;
    };
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// `gio.TestDBusFlags` specifying the behaviour of the D-Bus session.
        pub const flags = struct {
            pub const name = "flags";

            pub const Type = gio.TestDBusFlags;
        };
    };

    pub const signals = struct {};

    /// Unset DISPLAY and DBUS_SESSION_BUS_ADDRESS env variables to ensure the test
    /// won't use user's session bus.
    ///
    /// This is useful for unit tests that want to verify behaviour when no session
    /// bus is running. It is not necessary to call this if unit test already calls
    /// `gio.TestDBus.up` before acquiring the session bus.
    extern fn g_test_dbus_unset() void;
    pub const unset = g_test_dbus_unset;

    /// Create a new `gio.TestDBus` object.
    extern fn g_test_dbus_new(p_flags: gio.TestDBusFlags) *gio.TestDBus;
    pub const new = g_test_dbus_new;

    /// Add a path where dbus-daemon will look up .service files. This can't be
    /// called after `gio.TestDBus.up`.
    extern fn g_test_dbus_add_service_dir(p_self: *TestDBus, p_path: [*:0]const u8) void;
    pub const addServiceDir = g_test_dbus_add_service_dir;

    /// Stop the session bus started by `gio.TestDBus.up`.
    ///
    /// This will wait for the singleton returned by `gio.busGet` or `gio.busGetSync`
    /// to be destroyed. This is done to ensure that the next unit test won't get a
    /// leaked singleton from this test.
    extern fn g_test_dbus_down(p_self: *TestDBus) void;
    pub const down = g_test_dbus_down;

    /// Get the address on which dbus-daemon is running. If `gio.TestDBus.up` has not
    /// been called yet, `NULL` is returned. This can be used with
    /// `gio.DBusConnection.newForAddress`.
    extern fn g_test_dbus_get_bus_address(p_self: *TestDBus) ?[*:0]const u8;
    pub const getBusAddress = g_test_dbus_get_bus_address;

    /// Get the flags of the `gio.TestDBus` object.
    extern fn g_test_dbus_get_flags(p_self: *TestDBus) gio.TestDBusFlags;
    pub const getFlags = g_test_dbus_get_flags;

    /// Stop the session bus started by `gio.TestDBus.up`.
    ///
    /// Unlike `gio.TestDBus.down`, this won't verify the `gio.DBusConnection`
    /// singleton returned by `gio.busGet` or `gio.busGetSync` is destroyed. Unit
    /// tests wanting to verify behaviour after the session bus has been stopped
    /// can use this function but should still call `gio.TestDBus.down` when done.
    extern fn g_test_dbus_stop(p_self: *TestDBus) void;
    pub const stop = g_test_dbus_stop;

    /// Start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After this
    /// call, it is safe for unit tests to start sending messages on the session bus.
    ///
    /// If this function is called from setup callback of `g_test_add`,
    /// `gio.TestDBus.down` must be called in its teardown callback.
    ///
    /// If this function is called from unit test's `main`, then `gio.TestDBus.down`
    /// must be called after `glib.testRun`.
    extern fn g_test_dbus_up(p_self: *TestDBus) void;
    pub const up = g_test_dbus_up;

    extern fn g_test_dbus_get_type() usize;
    pub const getGObjectType = g_test_dbus_get_type;

    extern fn g_object_ref(p_self: *gio.TestDBus) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.TestDBus) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TestDBus, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GThemedIcon` is an implementation of `gio.Icon` that supports icon
/// themes.
///
/// `GThemedIcon` contains a list of all of the icons present in an icon
/// theme, so that icons can be looked up quickly. `GThemedIcon` does
/// not provide actual pixmaps for icons, just the icon names.
/// Ideally something like `gtk.IconTheme.chooseIcon` should be used to
/// resolve the list of names so that fallback icons work nicely with
/// themes that inherit other themes.
pub const ThemedIcon = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.Icon};
    pub const Class = gio.ThemedIconClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The icon name.
        pub const name = struct {
            pub const name = "name";

            pub const Type = ?[*:0]u8;
        };

        /// A `NULL`-terminated array of icon names.
        pub const names = struct {
            pub const name = "names";

            pub const Type = ?[*][*:0]u8;
        };

        /// Whether to use the default fallbacks found by shortening the icon name
        /// at '-' characters. If the "names" array has more than one element,
        /// ignores any past the first.
        ///
        /// For example, if the icon name was "gnome-dev-cdrom-audio", the array
        /// would become
        /// ```
        /// {
        ///   "gnome-dev-cdrom-audio",
        ///   "gnome-dev-cdrom",
        ///   "gnome-dev",
        ///   "gnome",
        ///   NULL
        /// };
        /// ```
        pub const use_default_fallbacks = struct {
            pub const name = "use-default-fallbacks";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new themed icon for `iconname`.
    extern fn g_themed_icon_new(p_iconname: [*:0]const u8) *gio.ThemedIcon;
    pub const new = g_themed_icon_new;

    /// Creates a new themed icon for `iconnames`.
    extern fn g_themed_icon_new_from_names(p_iconnames: [*][*:0]u8, p_len: c_int) *gio.ThemedIcon;
    pub const newFromNames = g_themed_icon_new_from_names;

    /// Creates a new themed icon for `iconname`, and all the names
    /// that can be created by shortening `iconname` at '-' characters.
    ///
    /// In the following example, `icon1` and `icon2` are equivalent:
    /// ```
    /// const char *names[] = {
    ///   "gnome-dev-cdrom-audio",
    ///   "gnome-dev-cdrom",
    ///   "gnome-dev",
    ///   "gnome"
    /// };
    ///
    /// icon1 = g_themed_icon_new_from_names (names, 4);
    /// icon2 = g_themed_icon_new_with_default_fallbacks ("gnome-dev-cdrom-audio");
    /// ```
    extern fn g_themed_icon_new_with_default_fallbacks(p_iconname: [*:0]const u8) *gio.ThemedIcon;
    pub const newWithDefaultFallbacks = g_themed_icon_new_with_default_fallbacks;

    /// Append a name to the list of icons from within `icon`.
    ///
    /// Note that doing so invalidates the hash computed by prior calls
    /// to `gio.Icon.hash`.
    extern fn g_themed_icon_append_name(p_icon: *ThemedIcon, p_iconname: [*:0]const u8) void;
    pub const appendName = g_themed_icon_append_name;

    /// Gets the names of icons from within `icon`.
    extern fn g_themed_icon_get_names(p_icon: *ThemedIcon) [*]const [*:0]const u8;
    pub const getNames = g_themed_icon_get_names;

    /// Prepend a name to the list of icons from within `icon`.
    ///
    /// Note that doing so invalidates the hash computed by prior calls
    /// to `gio.Icon.hash`.
    extern fn g_themed_icon_prepend_name(p_icon: *ThemedIcon, p_iconname: [*:0]const u8) void;
    pub const prependName = g_themed_icon_prepend_name;

    extern fn g_themed_icon_get_type() usize;
    pub const getGObjectType = g_themed_icon_get_type;

    extern fn g_object_ref(p_self: *gio.ThemedIcon) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.ThemedIcon) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ThemedIcon, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gio.ThreadedResolver` is an implementation of `gio.Resolver` which calls the libc
/// lookup functions in threads to allow them to run asynchronously.
pub const ThreadedResolver = opaque {
    pub const Parent = gio.Resolver;
    pub const Implements = [_]type{};
    pub const Class = gio.ThreadedResolverClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    extern fn g_threaded_resolver_get_type() usize;
    pub const getGObjectType = g_threaded_resolver_get_type;

    extern fn g_object_ref(p_self: *gio.ThreadedResolver) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.ThreadedResolver) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ThreadedResolver, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `GThreadedSocketService` is a simple subclass of `gio.SocketService`
/// that handles incoming connections by creating a worker thread and
/// dispatching the connection to it by emitting the
/// `gio.ThreadedSocketService.signals.@"run signal"` in the new thread.
///
/// The signal handler may perform blocking I/O and need not return
/// until the connection is closed.
///
/// The service is implemented using a thread pool, so there is a
/// limited amount of threads available to serve incoming requests.
/// The service automatically stops the `gio.SocketService` from accepting
/// new connections when all threads are busy.
///
/// As with `gio.SocketService`, you may connect to
/// `gio.ThreadedSocketService.signals.run`, or subclass and override the default
/// handler.
pub const ThreadedSocketService = extern struct {
    pub const Parent = gio.SocketService;
    pub const Implements = [_]type{};
    pub const Class = gio.ThreadedSocketServiceClass;
    f_parent_instance: gio.SocketService,
    f_priv: ?*gio.ThreadedSocketServicePrivate,

    pub const virtual_methods = struct {
        pub const run = struct {
            pub fn call(p_class: anytype, p_service: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.SocketConnection, p_source_object: *gobject.Object) c_int {
                return gobject.ext.as(ThreadedSocketService.Class, p_class).f_run.?(gobject.ext.as(ThreadedSocketService, p_service), p_connection, p_source_object);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_service: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.SocketConnection, p_source_object: *gobject.Object) callconv(.c) c_int) void {
                gobject.ext.as(ThreadedSocketService.Class, p_class).f_run = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The maximum number of threads handling clients for this service.
        pub const max_threads = struct {
            pub const name = "max-threads";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// The ::run signal is emitted in a worker thread in response to an
        /// incoming connection. This thread is dedicated to handling
        /// `connection` and may perform blocking IO. The signal handler need
        /// not return until the connection is closed.
        pub const run = struct {
            pub const name = "run";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_connection: *gio.SocketConnection, p_source_object: ?*gobject.Object, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ThreadedSocketService, p_instance))),
                    gobject.signalLookup("run", ThreadedSocketService.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Creates a new `gio.ThreadedSocketService` with no listeners. Listeners
    /// must be added with one of the `gio.SocketListener` "add" methods.
    extern fn g_threaded_socket_service_new(p_max_threads: c_int) *gio.ThreadedSocketService;
    pub const new = g_threaded_socket_service_new;

    extern fn g_threaded_socket_service_get_type() usize;
    pub const getGObjectType = g_threaded_socket_service_get_type;

    extern fn g_object_ref(p_self: *gio.ThreadedSocketService) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.ThreadedSocketService) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ThreadedSocketService, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A certificate used for TLS authentication and encryption.
/// This can represent either a certificate only (eg, the certificate
/// received by a client from a server), or the combination of
/// a certificate and a private key (which is needed when acting as a
/// `gio.TlsServerConnection`).
pub const TlsCertificate = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.TlsCertificateClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.TlsCertificatePrivate,

    pub const virtual_methods = struct {
        /// This verifies `cert` and returns a set of `gio.TlsCertificateFlags`
        /// indicating any problems found with it. This can be used to verify a
        /// certificate outside the context of making a connection, or to
        /// check a certificate against a CA that is not part of the system
        /// CA database.
        ///
        /// If `cert` is valid, `G_TLS_CERTIFICATE_NO_FLAGS` is returned.
        ///
        /// If `identity` is not `NULL`, `cert`'s name(s) will be compared against
        /// it, and `G_TLS_CERTIFICATE_BAD_IDENTITY` will be set in the return
        /// value if it does not match. If `identity` is `NULL`, that bit will
        /// never be set in the return value.
        ///
        /// If `trusted_ca` is not `NULL`, then `cert` (or one of the certificates
        /// in its chain) must be signed by it, or else
        /// `G_TLS_CERTIFICATE_UNKNOWN_CA` will be set in the return value. If
        /// `trusted_ca` is `NULL`, that bit will never be set in the return
        /// value.
        ///
        /// GLib guarantees that if certificate verification fails, at least one
        /// error will be set in the return value, but it does not guarantee
        /// that all possible errors will be set. Accordingly, you may not safely
        /// decide to ignore any particular type of error. For example, it would
        /// be incorrect to mask `G_TLS_CERTIFICATE_EXPIRED` if you want to allow
        /// expired certificates, because this could potentially be the only
        /// error flag set even if other problems exist with the certificate.
        ///
        /// Because TLS session context is not used, `gio.TlsCertificate` may not
        /// perform as many checks on the certificates as `gio.TlsConnection` would.
        /// For example, certificate constraints may not be honored, and
        /// revocation checks may not be performed. The best way to verify TLS
        /// certificates used by a TLS connection is to let `gio.TlsConnection`
        /// handle the verification.
        pub const verify = struct {
            pub fn call(p_class: anytype, p_cert: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_identity: ?*gio.SocketConnectable, p_trusted_ca: ?*gio.TlsCertificate) gio.TlsCertificateFlags {
                return gobject.ext.as(TlsCertificate.Class, p_class).f_verify.?(gobject.ext.as(TlsCertificate, p_cert), p_identity, p_trusted_ca);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_cert: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_identity: ?*gio.SocketConnectable, p_trusted_ca: ?*gio.TlsCertificate) callconv(.c) gio.TlsCertificateFlags) void {
                gobject.ext.as(TlsCertificate.Class, p_class).f_verify = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The DER (binary) encoded representation of the certificate.
        /// This property and the `gio.TlsCertificate.properties.certificate`-pem property
        /// represent the same data, just in different forms.
        pub const certificate = struct {
            pub const name = "certificate";

            pub const Type = ?[*]u8;
        };

        /// The PEM (ASCII) encoded representation of the certificate.
        /// This property and the `gio.TlsCertificate.properties.certificate`
        /// property represent the same data, just in different forms.
        pub const certificate_pem = struct {
            pub const name = "certificate-pem";

            pub const Type = ?[*:0]u8;
        };

        /// The DNS names from the certificate's Subject Alternative Names (SANs),
        /// `NULL` if unavailable.
        pub const dns_names = struct {
            pub const name = "dns-names";

            pub const Type = ?[*]*anyopaque;
        };

        /// The IP addresses from the certificate's Subject Alternative Names (SANs),
        /// `NULL` if unavailable.
        pub const ip_addresses = struct {
            pub const name = "ip-addresses";

            pub const Type = ?[*]*anyopaque;
        };

        /// A `gio.TlsCertificate` representing the entity that issued this
        /// certificate. If `NULL`, this means that the certificate is either
        /// self-signed, or else the certificate of the issuer is not
        /// available.
        ///
        /// Beware the issuer certificate may not be the same as the
        /// certificate that would actually be used to construct a valid
        /// certification path during certificate verification.
        /// [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
        /// why an issuer certificate cannot be naively assumed to be part of the
        /// the certification path (though GLib's TLS backends may not follow the
        /// path building strategies outlined in this RFC). Due to the complexity
        /// of certification path building, GLib does not provide any way to know
        /// which certification path will actually be used. Accordingly, this
        /// property cannot be used to make security-related decisions. Only
        /// GLib itself should make security decisions about TLS certificates.
        pub const issuer = struct {
            pub const name = "issuer";

            pub const Type = ?*gio.TlsCertificate;
        };

        /// The issuer from the certificate,
        /// `NULL` if unavailable.
        pub const issuer_name = struct {
            pub const name = "issuer-name";

            pub const Type = ?[*:0]u8;
        };

        /// The time at which this cert is no longer valid,
        /// `NULL` if unavailable.
        pub const not_valid_after = struct {
            pub const name = "not-valid-after";

            pub const Type = ?*glib.DateTime;
        };

        /// The time at which this cert is considered to be valid,
        /// `NULL` if unavailable.
        pub const not_valid_before = struct {
            pub const name = "not-valid-before";

            pub const Type = ?*glib.DateTime;
        };

        /// An optional password used when constructed with GTlsCertificate:pkcs12-data.
        pub const password = struct {
            pub const name = "password";

            pub const Type = ?[*:0]u8;
        };

        /// A URI referencing the [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
        /// objects containing an X.509 certificate and optionally a private key.
        ///
        /// If `NULL`, the certificate is either not backed by PKCS \#11 or the
        /// `gio.TlsBackend` does not support PKCS \#11.
        pub const pkcs11_uri = struct {
            pub const name = "pkcs11-uri";

            pub const Type = ?[*:0]u8;
        };

        /// The PKCS `@"12"` formatted data used to construct the object.
        ///
        /// See also: `gio.TlsCertificate.newFromPkcs12`
        pub const pkcs12_data = struct {
            pub const name = "pkcs12-data";

            pub const Type = ?[*]u8;
        };

        /// The DER (binary) encoded representation of the certificate's
        /// private key, in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
        /// or unencrypted [PKCS \#8 format.](https://datatracker.ietf.org/doc/html/rfc5208)
        /// PKCS \#8 format is supported since 2.32; earlier releases only
        /// support PKCS \#1. You can use the `openssl rsa` tool to convert
        /// PKCS \#8 keys to PKCS \#1.
        ///
        /// This property (or the `gio.TlsCertificate.properties.private`-key-pem property)
        /// can be set when constructing a key (for example, from a file).
        /// Since GLib 2.70, it is now also readable; however, be aware that if
        /// the private key is backed by a PKCS \#11 URI – for example, if it
        /// is stored on a smartcard – then this property will be `NULL`. If so,
        /// the private key must be referenced via its PKCS \#11 URI,
        /// `gio.TlsCertificate.properties.private`-key-pkcs11-uri. You must check both
        /// properties to see if the certificate really has a private key.
        /// When this property is read, the output format will be unencrypted
        /// PKCS \#8.
        pub const private_key = struct {
            pub const name = "private-key";

            pub const Type = ?[*]u8;
        };

        /// The PEM (ASCII) encoded representation of the certificate's
        /// private key in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
        /// ("`BEGIN RSA PRIVATE KEY`") or unencrypted
        /// [PKCS \#8 format](https://datatracker.ietf.org/doc/html/rfc5208)
        /// ("`BEGIN PRIVATE KEY`"). PKCS \#8 format is supported since 2.32;
        /// earlier releases only support PKCS \#1. You can use the `openssl rsa`
        /// tool to convert PKCS \#8 keys to PKCS \#1.
        ///
        /// This property (or the `gio.TlsCertificate.properties.private`-key property)
        /// can be set when constructing a key (for example, from a file).
        /// Since GLib 2.70, it is now also readable; however, be aware that if
        /// the private key is backed by a PKCS \#11 URI - for example, if it
        /// is stored on a smartcard - then this property will be `NULL`. If so,
        /// the private key must be referenced via its PKCS \#11 URI,
        /// `gio.TlsCertificate.properties.private`-key-pkcs11-uri. You must check both
        /// properties to see if the certificate really has a private key.
        /// When this property is read, the output format will be unencrypted
        /// PKCS \#8.
        pub const private_key_pem = struct {
            pub const name = "private-key-pem";

            pub const Type = ?[*:0]u8;
        };

        /// A URI referencing a [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
        /// object containing a private key.
        pub const private_key_pkcs11_uri = struct {
            pub const name = "private-key-pkcs11-uri";

            pub const Type = ?[*:0]u8;
        };

        /// The subject from the cert,
        /// `NULL` if unavailable.
        pub const subject_name = struct {
            pub const name = "subject-name";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates one or more `GTlsCertificates` from the PEM-encoded
    /// data in `file`. If `file` cannot be read or parsed, the function will
    /// return `NULL` and set `error`. If `file` does not contain any
    /// PEM-encoded certificates, this will return an empty list and not
    /// set `error`.
    extern fn g_tls_certificate_list_new_from_file(p_file: [*:0]const u8, p_error: ?*?*glib.Error) ?*glib.List;
    pub const listNewFromFile = g_tls_certificate_list_new_from_file;

    /// Creates a `gio.TlsCertificate` from the data in `file`.
    ///
    /// As of 2.72, if the filename ends in `.p12` or `.pfx` the data is loaded by
    /// `gio.TlsCertificate.newFromPkcs12` otherwise it is loaded by
    /// `gio.TlsCertificate.newFromPem`. See those functions for
    /// exact details.
    ///
    /// If `file` cannot be read or parsed, the function will return `NULL` and
    /// set `error`.
    extern fn g_tls_certificate_new_from_file(p_file: [*:0]const u8, p_error: ?*?*glib.Error) ?*gio.TlsCertificate;
    pub const newFromFile = g_tls_certificate_new_from_file;

    /// Creates a `gio.TlsCertificate` from the data in `file`.
    ///
    /// If `file` cannot be read or parsed, the function will return `NULL` and
    /// set `error`.
    ///
    /// Any unknown file types will error with `G_IO_ERROR_NOT_SUPPORTED`.
    /// Currently only `.p12` and `.pfx` files are supported.
    /// See `gio.TlsCertificate.newFromPkcs12` for more details.
    extern fn g_tls_certificate_new_from_file_with_password(p_file: [*:0]const u8, p_password: [*:0]const u8, p_error: ?*?*glib.Error) ?*gio.TlsCertificate;
    pub const newFromFileWithPassword = g_tls_certificate_new_from_file_with_password;

    /// Creates a `gio.TlsCertificate` from the PEM-encoded data in `cert_file`
    /// and `key_file`. The returned certificate will be the first certificate
    /// found in `cert_file`. As of GLib 2.44, if `cert_file` contains more
    /// certificates it will try to load a certificate chain. All
    /// certificates will be verified in the order found (top-level
    /// certificate should be the last one in the file) and the
    /// `gio.TlsCertificate.properties.issuer` property of each certificate will be set
    /// accordingly if the verification succeeds. If any certificate in the
    /// chain cannot be verified, the first certificate in the file will
    /// still be returned.
    ///
    /// If either file cannot be read or parsed, the function will return
    /// `NULL` and set `error`. Otherwise, this behaves like
    /// `gio.TlsCertificate.newFromPem`.
    extern fn g_tls_certificate_new_from_files(p_cert_file: [*:0]const u8, p_key_file: [*:0]const u8, p_error: ?*?*glib.Error) ?*gio.TlsCertificate;
    pub const newFromFiles = g_tls_certificate_new_from_files;

    /// Creates a `gio.TlsCertificate` from the PEM-encoded data in `data`. If
    /// `data` includes both a certificate and a private key, then the
    /// returned certificate will include the private key data as well. (See
    /// the `gio.TlsCertificate.properties.private`-key-pem property for information about
    /// supported formats.)
    ///
    /// The returned certificate will be the first certificate found in
    /// `data`. As of GLib 2.44, if `data` contains more certificates it will
    /// try to load a certificate chain. All certificates will be verified in
    /// the order found (top-level certificate should be the last one in the
    /// file) and the `gio.TlsCertificate.properties.issuer` property of each certificate
    /// will be set accordingly if the verification succeeds. If any
    /// certificate in the chain cannot be verified, the first certificate in
    /// the file will still be returned.
    extern fn g_tls_certificate_new_from_pem(p_data: [*:0]const u8, p_length: isize, p_error: ?*?*glib.Error) ?*gio.TlsCertificate;
    pub const newFromPem = g_tls_certificate_new_from_pem;

    /// Creates a `gio.TlsCertificate` from a
    /// [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html) URI.
    ///
    /// An example `pkcs11_uri` would be `pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My`@"20Client"``@"20Certificate"`;id=`@"01"``
    ///
    /// Where the token’s layout is:
    ///
    /// ```
    /// Object 0:
    ///   URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My`@"20Client"``@"20Certificate"`;id=`@"01"`;object=private`@"20key"`;type=private
    ///   Type: Private key (RSA-2048)
    ///   ID: 01
    ///
    /// Object 1:
    ///   URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My`@"20Client"``@"20Certificate"`;id=`@"01"`;object=Certificate`@"20for"``@"20Authentication"`;type=cert
    ///   Type: X.509 Certificate (RSA-2048)
    ///   ID: 01
    /// ```
    ///
    /// In this case the certificate and private key would both be detected and used as expected.
    /// `pkcs_uri` may also just reference an X.509 certificate object and then optionally
    /// `private_key_pkcs11_uri` allows using a private key exposed under a different URI.
    ///
    /// Note that the private key is not accessed until usage and may fail or require a PIN later.
    extern fn g_tls_certificate_new_from_pkcs11_uris(p_pkcs11_uri: [*:0]const u8, p_private_key_pkcs11_uri: ?[*:0]const u8, p_error: ?*?*glib.Error) ?*gio.TlsCertificate;
    pub const newFromPkcs11Uris = g_tls_certificate_new_from_pkcs11_uris;

    /// Creates a `gio.TlsCertificate` from the data in `data`. It must contain
    /// a certificate and matching private key.
    ///
    /// If extra certificates are included they will be verified as a chain
    /// and the `gio.TlsCertificate.properties.issuer` property will be set.
    /// All other data will be ignored.
    ///
    /// You can pass as single password for all of the data which will be
    /// used both for the PKCS `@"12"` container as well as encrypted
    /// private keys. If decryption fails it will error with
    /// `G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD`.
    ///
    /// This constructor requires support in the current `gio.TlsBackend`.
    /// If support is missing it will error with
    /// `G_IO_ERROR_NOT_SUPPORTED`.
    ///
    /// Other parsing failures will error with `G_TLS_ERROR_BAD_CERTIFICATE`.
    extern fn g_tls_certificate_new_from_pkcs12(p_data: [*]const u8, p_length: usize, p_password: ?[*:0]const u8, p_error: ?*?*glib.Error) ?*gio.TlsCertificate;
    pub const newFromPkcs12 = g_tls_certificate_new_from_pkcs12;

    /// Gets the value of `gio.TlsCertificate.properties.dns`-names.
    extern fn g_tls_certificate_get_dns_names(p_cert: *TlsCertificate) ?*glib.PtrArray;
    pub const getDnsNames = g_tls_certificate_get_dns_names;

    /// Gets the value of `gio.TlsCertificate.properties.ip`-addresses.
    extern fn g_tls_certificate_get_ip_addresses(p_cert: *TlsCertificate) ?*glib.PtrArray;
    pub const getIpAddresses = g_tls_certificate_get_ip_addresses;

    /// Gets the `gio.TlsCertificate` representing `cert`'s issuer, if known
    extern fn g_tls_certificate_get_issuer(p_cert: *TlsCertificate) ?*gio.TlsCertificate;
    pub const getIssuer = g_tls_certificate_get_issuer;

    /// Returns the issuer name from the certificate.
    extern fn g_tls_certificate_get_issuer_name(p_cert: *TlsCertificate) ?[*:0]u8;
    pub const getIssuerName = g_tls_certificate_get_issuer_name;

    /// Returns the time at which the certificate became or will become invalid.
    extern fn g_tls_certificate_get_not_valid_after(p_cert: *TlsCertificate) ?*glib.DateTime;
    pub const getNotValidAfter = g_tls_certificate_get_not_valid_after;

    /// Returns the time at which the certificate became or will become valid.
    extern fn g_tls_certificate_get_not_valid_before(p_cert: *TlsCertificate) ?*glib.DateTime;
    pub const getNotValidBefore = g_tls_certificate_get_not_valid_before;

    /// Returns the subject name from the certificate.
    extern fn g_tls_certificate_get_subject_name(p_cert: *TlsCertificate) ?[*:0]u8;
    pub const getSubjectName = g_tls_certificate_get_subject_name;

    /// Check if two `gio.TlsCertificate` objects represent the same certificate.
    /// The raw DER byte data of the two certificates are checked for equality.
    /// This has the effect that two certificates may compare equal even if
    /// their `gio.TlsCertificate.properties.issuer`, `gio.TlsCertificate.properties.private`-key, or
    /// `gio.TlsCertificate.properties.private`-key-pem properties differ.
    extern fn g_tls_certificate_is_same(p_cert_one: *TlsCertificate, p_cert_two: *gio.TlsCertificate) c_int;
    pub const isSame = g_tls_certificate_is_same;

    /// This verifies `cert` and returns a set of `gio.TlsCertificateFlags`
    /// indicating any problems found with it. This can be used to verify a
    /// certificate outside the context of making a connection, or to
    /// check a certificate against a CA that is not part of the system
    /// CA database.
    ///
    /// If `cert` is valid, `G_TLS_CERTIFICATE_NO_FLAGS` is returned.
    ///
    /// If `identity` is not `NULL`, `cert`'s name(s) will be compared against
    /// it, and `G_TLS_CERTIFICATE_BAD_IDENTITY` will be set in the return
    /// value if it does not match. If `identity` is `NULL`, that bit will
    /// never be set in the return value.
    ///
    /// If `trusted_ca` is not `NULL`, then `cert` (or one of the certificates
    /// in its chain) must be signed by it, or else
    /// `G_TLS_CERTIFICATE_UNKNOWN_CA` will be set in the return value. If
    /// `trusted_ca` is `NULL`, that bit will never be set in the return
    /// value.
    ///
    /// GLib guarantees that if certificate verification fails, at least one
    /// error will be set in the return value, but it does not guarantee
    /// that all possible errors will be set. Accordingly, you may not safely
    /// decide to ignore any particular type of error. For example, it would
    /// be incorrect to mask `G_TLS_CERTIFICATE_EXPIRED` if you want to allow
    /// expired certificates, because this could potentially be the only
    /// error flag set even if other problems exist with the certificate.
    ///
    /// Because TLS session context is not used, `gio.TlsCertificate` may not
    /// perform as many checks on the certificates as `gio.TlsConnection` would.
    /// For example, certificate constraints may not be honored, and
    /// revocation checks may not be performed. The best way to verify TLS
    /// certificates used by a TLS connection is to let `gio.TlsConnection`
    /// handle the verification.
    extern fn g_tls_certificate_verify(p_cert: *TlsCertificate, p_identity: ?*gio.SocketConnectable, p_trusted_ca: ?*gio.TlsCertificate) gio.TlsCertificateFlags;
    pub const verify = g_tls_certificate_verify;

    extern fn g_tls_certificate_get_type() usize;
    pub const getGObjectType = g_tls_certificate_get_type;

    extern fn g_object_ref(p_self: *gio.TlsCertificate) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.TlsCertificate) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TlsCertificate, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GTlsConnection` is the base TLS connection class type, which wraps
/// a `gio.IOStream` and provides TLS encryption on top of it. Its
/// subclasses, `gio.TlsClientConnection` and
/// `gio.TlsServerConnection`, implement client-side and server-side TLS,
/// respectively.
///
/// For DTLS (Datagram TLS) support, see `gio.DtlsConnection`.
pub const TlsConnection = extern struct {
    pub const Parent = gio.IOStream;
    pub const Implements = [_]type{};
    pub const Class = gio.TlsConnectionClass;
    f_parent_instance: gio.IOStream,
    f_priv: ?*gio.TlsConnectionPrivate,

    pub const virtual_methods = struct {
        /// Check whether to accept a certificate.
        pub const accept_certificate = struct {
            pub fn call(p_class: anytype, p_connection: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_peer_cert: *gio.TlsCertificate, p_errors: gio.TlsCertificateFlags) c_int {
                return gobject.ext.as(TlsConnection.Class, p_class).f_accept_certificate.?(gobject.ext.as(TlsConnection, p_connection), p_peer_cert, p_errors);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_connection: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_peer_cert: *gio.TlsCertificate, p_errors: gio.TlsCertificateFlags) callconv(.c) c_int) void {
                gobject.ext.as(TlsConnection.Class, p_class).f_accept_certificate = @ptrCast(p_implementation);
            }
        };

        /// Retrieve TLS channel binding data (Since: 2.66)
        pub const get_binding_data = struct {
            pub fn call(p_class: anytype, p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_type: gio.TlsChannelBindingType, p_data: *glib.ByteArray, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(TlsConnection.Class, p_class).f_get_binding_data.?(gobject.ext.as(TlsConnection, p_conn), p_type, p_data, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_type: gio.TlsChannelBindingType, p_data: *glib.ByteArray, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(TlsConnection.Class, p_class).f_get_binding_data = @ptrCast(p_implementation);
            }
        };

        /// Gets the name of the application-layer protocol negotiated during
        /// the handshake.
        ///
        /// If the peer did not use the ALPN extension, or did not advertise a
        /// protocol that matched one of `conn`'s protocols, or the TLS backend
        /// does not support ALPN, then this will be `NULL`. See
        /// `gio.TlsConnection.setAdvertisedProtocols`.
        pub const get_negotiated_protocol = struct {
            pub fn call(p_class: anytype, p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]const u8 {
                return gobject.ext.as(TlsConnection.Class, p_class).f_get_negotiated_protocol.?(gobject.ext.as(TlsConnection, p_conn));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]const u8) void {
                gobject.ext.as(TlsConnection.Class, p_class).f_get_negotiated_protocol = @ptrCast(p_implementation);
            }
        };

        /// Attempts a TLS handshake on `conn`.
        ///
        /// On the client side, it is never necessary to call this method;
        /// although the connection needs to perform a handshake after
        /// connecting (or after sending a "STARTTLS"-type command),
        /// `gio.TlsConnection` will handle this for you automatically when you try
        /// to send or receive data on the connection. You can call
        /// `gio.TlsConnection.handshake` manually if you want to know whether
        /// the initial handshake succeeded or failed (as opposed to just
        /// immediately trying to use `conn` to read or write, in which case,
        /// if it fails, it may not be possible to tell if it failed before or
        /// after completing the handshake), but beware that servers may reject
        /// client authentication after the handshake has completed, so a
        /// successful handshake does not indicate the connection will be usable.
        ///
        /// Likewise, on the server side, although a handshake is necessary at
        /// the beginning of the communication, you do not need to call this
        /// function explicitly unless you want clearer error reporting.
        ///
        /// Previously, calling `gio.TlsConnection.handshake` after the initial
        /// handshake would trigger a rehandshake; however, this usage was
        /// deprecated in GLib 2.60 because rehandshaking was removed from the
        /// TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
        /// the initial handshake will no longer do anything.
        ///
        /// When using a `gio.TlsConnection` created by `gio.SocketClient`, the
        /// `gio.SocketClient` performs the initial handshake, so calling this
        /// function manually is not recommended.
        ///
        /// `gio.TlsConnection.signals.accept_certificate` may be emitted during the
        /// handshake.
        pub const handshake = struct {
            pub fn call(p_class: anytype, p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(TlsConnection.Class, p_class).f_handshake.?(gobject.ext.as(TlsConnection, p_conn), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(TlsConnection.Class, p_class).f_handshake = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously performs a TLS handshake on `conn`. See
        /// `gio.TlsConnection.handshake` for more information.
        pub const handshake_async = struct {
            pub fn call(p_class: anytype, p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(TlsConnection.Class, p_class).f_handshake_async.?(gobject.ext.as(TlsConnection, p_conn), p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(TlsConnection.Class, p_class).f_handshake_async = @ptrCast(p_implementation);
            }
        };

        /// Finish an asynchronous TLS handshake operation. See
        /// `gio.TlsConnection.handshake` for more information.
        pub const handshake_finish = struct {
            pub fn call(p_class: anytype, p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(TlsConnection.Class, p_class).f_handshake_finish.?(gobject.ext.as(TlsConnection, p_conn), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(TlsConnection.Class, p_class).f_handshake_finish = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The list of application-layer protocols that the connection
        /// advertises that it is willing to speak. See
        /// `gio.TlsConnection.setAdvertisedProtocols`.
        pub const advertised_protocols = struct {
            pub const name = "advertised-protocols";

            pub const Type = ?[*][*:0]u8;
        };

        /// The `gio.IOStream` that the connection wraps. The connection holds a reference
        /// to this stream, and may run operations on the stream from other threads
        /// throughout its lifetime. Consequently, after the `gio.IOStream` has been
        /// constructed, application code may only run its own operations on this
        /// stream when no `gio.IOStream` operations are running.
        pub const base_io_stream = struct {
            pub const name = "base-io-stream";

            pub const Type = ?*gio.IOStream;
        };

        /// The connection's certificate; see
        /// `gio.TlsConnection.setCertificate`.
        pub const certificate = struct {
            pub const name = "certificate";

            pub const Type = ?*gio.TlsCertificate;
        };

        /// The name of the TLS ciphersuite in use. See `gio.TlsConnection.getCiphersuiteName`.
        pub const ciphersuite_name = struct {
            pub const name = "ciphersuite-name";

            pub const Type = ?[*:0]u8;
        };

        /// The certificate database to use when verifying this TLS connection.
        /// If no certificate database is set, then the default database will be
        /// used. See `gio.TlsBackend.getDefaultDatabase`.
        ///
        /// When using a non-default database, `gio.TlsConnection` must fall back to using
        /// the `gio.TlsDatabase` to perform certificate verification using
        /// `gio.TlsDatabase.verifyChain`, which means certificate verification will
        /// not be able to make use of TLS session context. This may be less secure.
        /// For example, if you create your own `gio.TlsDatabase` that just wraps the
        /// default `gio.TlsDatabase`, you might expect that you have not changed anything,
        /// but this is not true because you may have altered the behavior of
        /// `gio.TlsConnection` by causing it to use `gio.TlsDatabase.verifyChain`. See the
        /// documentation of `gio.TlsDatabase.verifyChain` for more details on specific
        /// security checks that may not be performed. Accordingly, setting a
        /// non-default database is discouraged except for specialty applications with
        /// unusual security requirements.
        pub const database = struct {
            pub const name = "database";

            pub const Type = ?*gio.TlsDatabase;
        };

        /// A `gio.TlsInteraction` object to be used when the connection or certificate
        /// database need to interact with the user. This will be used to prompt the
        /// user for passwords where necessary.
        pub const interaction = struct {
            pub const name = "interaction";

            pub const Type = ?*gio.TlsInteraction;
        };

        /// The application-layer protocol negotiated during the TLS
        /// handshake. See `gio.TlsConnection.getNegotiatedProtocol`.
        pub const negotiated_protocol = struct {
            pub const name = "negotiated-protocol";

            pub const Type = ?[*:0]u8;
        };

        /// The connection's peer's certificate, after the TLS handshake has
        /// completed or failed. Note in particular that this is not yet set
        /// during the emission of `gio.TlsConnection.signals.accept`-certificate.
        ///
        /// (You can watch for a `gobject.Object.signals.notify` signal on this property to
        /// detect when a handshake has occurred.)
        pub const peer_certificate = struct {
            pub const name = "peer-certificate";

            pub const Type = ?*gio.TlsCertificate;
        };

        /// The errors noticed while verifying
        /// `gio.TlsConnection.properties.peer`-certificate. Normally this should be 0, but
        /// it may not be if `gio.TlsClientConnection.properties.validation`-flags is not
        /// `G_TLS_CERTIFICATE_VALIDATE_ALL`, or if
        /// `gio.TlsConnection.signals.accept`-certificate overrode the default
        /// behavior.
        ///
        /// GLib guarantees that if certificate verification fails, at least
        /// one error will be set, but it does not guarantee that all possible
        /// errors will be set. Accordingly, you may not safely decide to
        /// ignore any particular type of error. For example, it would be
        /// incorrect to mask `G_TLS_CERTIFICATE_EXPIRED` if you want to allow
        /// expired certificates, because this could potentially be the only
        /// error flag set even if other problems exist with the certificate.
        pub const peer_certificate_errors = struct {
            pub const name = "peer-certificate-errors";

            pub const Type = gio.TlsCertificateFlags;
        };

        /// The TLS protocol version in use. See `gio.TlsConnection.getProtocolVersion`.
        pub const protocol_version = struct {
            pub const name = "protocol-version";

            pub const Type = gio.TlsProtocolVersion;
        };

        /// The rehandshaking mode. See
        /// `gio.TlsConnection.setRehandshakeMode`.
        pub const rehandshake_mode = struct {
            pub const name = "rehandshake-mode";

            pub const Type = gio.TlsRehandshakeMode;
        };

        /// Whether or not proper TLS close notification is required.
        /// See `gio.TlsConnection.setRequireCloseNotify`.
        pub const require_close_notify = struct {
            pub const name = "require-close-notify";

            pub const Type = c_int;
        };

        /// Whether or not the system certificate database will be used to
        /// verify peer certificates. See
        /// `gio.TlsConnection.setUseSystemCertdb`.
        pub const use_system_certdb = struct {
            pub const name = "use-system-certdb";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted during the TLS handshake after the peer certificate has
        /// been received. You can examine `peer_cert`'s certification path by
        /// calling `gio.TlsCertificate.getIssuer` on it.
        ///
        /// For a client-side connection, `peer_cert` is the server's
        /// certificate, and the signal will only be emitted if the
        /// certificate was not acceptable according to `conn`'s
        /// `gio.TlsClientConnection.properties.validation_flags`. If you would like the
        /// certificate to be accepted despite `errors`, return `TRUE` from the
        /// signal handler. Otherwise, if no handler accepts the certificate,
        /// the handshake will fail with `G_TLS_ERROR_BAD_CERTIFICATE`.
        ///
        /// GLib guarantees that if certificate verification fails, this signal
        /// will be emitted with at least one error will be set in `errors`, but
        /// it does not guarantee that all possible errors will be set.
        /// Accordingly, you may not safely decide to ignore any particular
        /// type of error. For example, it would be incorrect to ignore
        /// `G_TLS_CERTIFICATE_EXPIRED` if you want to allow expired
        /// certificates, because this could potentially be the only error flag
        /// set even if other problems exist with the certificate.
        ///
        /// For a server-side connection, `peer_cert` is the certificate
        /// presented by the client, if this was requested via the server's
        /// `gio.TlsServerConnection.properties.authentication_mode`. On the server side,
        /// the signal is always emitted when the client presents a
        /// certificate, and the certificate will only be accepted if a
        /// handler returns `TRUE`.
        ///
        /// Note that if this signal is emitted as part of asynchronous I/O
        /// in the main thread, then you should not attempt to interact with
        /// the user before returning from the signal handler. If you want to
        /// let the user decide whether or not to accept the certificate, you
        /// would have to return `FALSE` from the signal handler on the first
        /// attempt, and then after the connection attempt returns a
        /// `G_TLS_ERROR_BAD_CERTIFICATE`, you can interact with the user, and
        /// if the user decides to accept the certificate, remember that fact,
        /// create a new connection, and return `TRUE` from the signal handler
        /// the next time.
        ///
        /// If you are doing I/O in another thread, you do not
        /// need to worry about this, and can simply block in the signal
        /// handler until the UI thread returns an answer.
        pub const accept_certificate = struct {
            pub const name = "accept-certificate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_peer_cert: *gio.TlsCertificate, p_errors: gio.TlsCertificateFlags, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(TlsConnection, p_instance))),
                    gobject.signalLookup("accept-certificate", TlsConnection.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Used by `gio.TlsConnection` implementations to emit the
    /// `gio.TlsConnection.signals.accept`-certificate signal.
    extern fn g_tls_connection_emit_accept_certificate(p_conn: *TlsConnection, p_peer_cert: *gio.TlsCertificate, p_errors: gio.TlsCertificateFlags) c_int;
    pub const emitAcceptCertificate = g_tls_connection_emit_accept_certificate;

    /// Gets `conn`'s certificate, as set by
    /// `gio.TlsConnection.setCertificate`.
    extern fn g_tls_connection_get_certificate(p_conn: *TlsConnection) ?*gio.TlsCertificate;
    pub const getCertificate = g_tls_connection_get_certificate;

    /// Query the TLS backend for TLS channel binding data of `type` for `conn`.
    ///
    /// This call retrieves TLS channel binding data as specified in RFC
    /// [5056](https://tools.ietf.org/html/rfc5056), RFC
    /// [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
    /// binding data is returned in `data`.  The `data` is resized by the callee
    /// using `glib.ByteArray` buffer management and will be freed when the `data`
    /// is destroyed by `glib.byteArrayUnref`. If `data` is `NULL`, it will only
    /// check whether TLS backend is able to fetch the data (e.g. whether `type`
    /// is supported by the TLS backend). It does not guarantee that the data
    /// will be available though.  That could happen if TLS connection does not
    /// support `type` or the binding data is not available yet due to additional
    /// negotiation or input required.
    extern fn g_tls_connection_get_channel_binding_data(p_conn: *TlsConnection, p_type: gio.TlsChannelBindingType, p_data: ?*glib.ByteArray, p_error: ?*?*glib.Error) c_int;
    pub const getChannelBindingData = g_tls_connection_get_channel_binding_data;

    /// Returns the name of the current TLS ciphersuite, or `NULL` if the
    /// connection has not handshaked or has been closed. Beware that the TLS
    /// backend may use any of multiple different naming conventions, because
    /// OpenSSL and GnuTLS have their own ciphersuite naming conventions that
    /// are different from each other and different from the standard, IANA-
    /// registered ciphersuite names. The ciphersuite name is intended to be
    /// displayed to the user for informative purposes only, and parsing it
    /// is not recommended.
    extern fn g_tls_connection_get_ciphersuite_name(p_conn: *TlsConnection) ?[*:0]u8;
    pub const getCiphersuiteName = g_tls_connection_get_ciphersuite_name;

    /// Gets the certificate database that `conn` uses to verify
    /// peer certificates. See `gio.TlsConnection.setDatabase`.
    extern fn g_tls_connection_get_database(p_conn: *TlsConnection) ?*gio.TlsDatabase;
    pub const getDatabase = g_tls_connection_get_database;

    /// Get the object that will be used to interact with the user. It will be used
    /// for things like prompting the user for passwords. If `NULL` is returned, then
    /// no user interaction will occur for this connection.
    extern fn g_tls_connection_get_interaction(p_conn: *TlsConnection) ?*gio.TlsInteraction;
    pub const getInteraction = g_tls_connection_get_interaction;

    /// Gets the name of the application-layer protocol negotiated during
    /// the handshake.
    ///
    /// If the peer did not use the ALPN extension, or did not advertise a
    /// protocol that matched one of `conn`'s protocols, or the TLS backend
    /// does not support ALPN, then this will be `NULL`. See
    /// `gio.TlsConnection.setAdvertisedProtocols`.
    extern fn g_tls_connection_get_negotiated_protocol(p_conn: *TlsConnection) ?[*:0]const u8;
    pub const getNegotiatedProtocol = g_tls_connection_get_negotiated_protocol;

    /// Gets `conn`'s peer's certificate after the handshake has completed
    /// or failed. (It is not set during the emission of
    /// `gio.TlsConnection.signals.accept`-certificate.)
    extern fn g_tls_connection_get_peer_certificate(p_conn: *TlsConnection) ?*gio.TlsCertificate;
    pub const getPeerCertificate = g_tls_connection_get_peer_certificate;

    /// Gets the errors associated with validating `conn`'s peer's
    /// certificate, after the handshake has completed or failed. (It is
    /// not set during the emission of `gio.TlsConnection.signals.accept`-certificate.)
    ///
    /// See `gio.TlsConnection.properties.peer`-certificate-errors for more information.
    extern fn g_tls_connection_get_peer_certificate_errors(p_conn: *TlsConnection) gio.TlsCertificateFlags;
    pub const getPeerCertificateErrors = g_tls_connection_get_peer_certificate_errors;

    /// Returns the current TLS protocol version, which may be
    /// `G_TLS_PROTOCOL_VERSION_UNKNOWN` if the connection has not handshaked, or
    /// has been closed, or if the TLS backend has implemented a protocol version
    /// that is not a recognized `gio.TlsProtocolVersion`.
    extern fn g_tls_connection_get_protocol_version(p_conn: *TlsConnection) gio.TlsProtocolVersion;
    pub const getProtocolVersion = g_tls_connection_get_protocol_version;

    /// Gets `conn` rehandshaking mode. See
    /// `gio.TlsConnection.setRehandshakeMode` for details.
    extern fn g_tls_connection_get_rehandshake_mode(p_conn: *TlsConnection) gio.TlsRehandshakeMode;
    pub const getRehandshakeMode = g_tls_connection_get_rehandshake_mode;

    /// Tests whether or not `conn` expects a proper TLS close notification
    /// when the connection is closed. See
    /// `gio.TlsConnection.setRequireCloseNotify` for details.
    extern fn g_tls_connection_get_require_close_notify(p_conn: *TlsConnection) c_int;
    pub const getRequireCloseNotify = g_tls_connection_get_require_close_notify;

    /// Gets whether `conn` uses the system certificate database to verify
    /// peer certificates. See `gio.TlsConnection.setUseSystemCertdb`.
    extern fn g_tls_connection_get_use_system_certdb(p_conn: *TlsConnection) c_int;
    pub const getUseSystemCertdb = g_tls_connection_get_use_system_certdb;

    /// Attempts a TLS handshake on `conn`.
    ///
    /// On the client side, it is never necessary to call this method;
    /// although the connection needs to perform a handshake after
    /// connecting (or after sending a "STARTTLS"-type command),
    /// `gio.TlsConnection` will handle this for you automatically when you try
    /// to send or receive data on the connection. You can call
    /// `gio.TlsConnection.handshake` manually if you want to know whether
    /// the initial handshake succeeded or failed (as opposed to just
    /// immediately trying to use `conn` to read or write, in which case,
    /// if it fails, it may not be possible to tell if it failed before or
    /// after completing the handshake), but beware that servers may reject
    /// client authentication after the handshake has completed, so a
    /// successful handshake does not indicate the connection will be usable.
    ///
    /// Likewise, on the server side, although a handshake is necessary at
    /// the beginning of the communication, you do not need to call this
    /// function explicitly unless you want clearer error reporting.
    ///
    /// Previously, calling `gio.TlsConnection.handshake` after the initial
    /// handshake would trigger a rehandshake; however, this usage was
    /// deprecated in GLib 2.60 because rehandshaking was removed from the
    /// TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
    /// the initial handshake will no longer do anything.
    ///
    /// When using a `gio.TlsConnection` created by `gio.SocketClient`, the
    /// `gio.SocketClient` performs the initial handshake, so calling this
    /// function manually is not recommended.
    ///
    /// `gio.TlsConnection.signals.accept_certificate` may be emitted during the
    /// handshake.
    extern fn g_tls_connection_handshake(p_conn: *TlsConnection, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const handshake = g_tls_connection_handshake;

    /// Asynchronously performs a TLS handshake on `conn`. See
    /// `gio.TlsConnection.handshake` for more information.
    extern fn g_tls_connection_handshake_async(p_conn: *TlsConnection, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const handshakeAsync = g_tls_connection_handshake_async;

    /// Finish an asynchronous TLS handshake operation. See
    /// `gio.TlsConnection.handshake` for more information.
    extern fn g_tls_connection_handshake_finish(p_conn: *TlsConnection, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const handshakeFinish = g_tls_connection_handshake_finish;

    /// Sets the list of application-layer protocols to advertise that the
    /// caller is willing to speak on this connection. The
    /// Application-Layer Protocol Negotiation (ALPN) extension will be
    /// used to negotiate a compatible protocol with the peer; use
    /// `gio.TlsConnection.getNegotiatedProtocol` to find the negotiated
    /// protocol after the handshake.  Specifying `NULL` for the the value
    /// of `protocols` will disable ALPN negotiation.
    ///
    /// See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml`alpn`-protocol-ids)
    /// for a list of registered protocol IDs.
    extern fn g_tls_connection_set_advertised_protocols(p_conn: *TlsConnection, p_protocols: ?[*]const [*:0]const u8) void;
    pub const setAdvertisedProtocols = g_tls_connection_set_advertised_protocols;

    /// This sets the certificate that `conn` will present to its peer
    /// during the TLS handshake. For a `gio.TlsServerConnection`, it is
    /// mandatory to set this, and that will normally be done at construct
    /// time.
    ///
    /// For a `gio.TlsClientConnection`, this is optional. If a handshake fails
    /// with `G_TLS_ERROR_CERTIFICATE_REQUIRED`, that means that the server
    /// requires a certificate, and if you try connecting again, you should
    /// call this method first. You can call
    /// `gio.TlsClientConnection.getAcceptedCas` on the failed connection
    /// to get a list of Certificate Authorities that the server will
    /// accept certificates from.
    ///
    /// (It is also possible that a server will allow the connection with
    /// or without a certificate; in that case, if you don't provide a
    /// certificate, you can tell that the server requested one by the fact
    /// that `gio.TlsClientConnection.getAcceptedCas` will return
    /// non-`NULL`.)
    extern fn g_tls_connection_set_certificate(p_conn: *TlsConnection, p_certificate: *gio.TlsCertificate) void;
    pub const setCertificate = g_tls_connection_set_certificate;

    /// Sets the certificate database that is used to verify peer certificates.
    /// This is set to the default database by default. See
    /// `gio.TlsBackend.getDefaultDatabase`. If set to `NULL`, then
    /// peer certificate validation will always set the
    /// `G_TLS_CERTIFICATE_UNKNOWN_CA` error (meaning
    /// `gio.TlsConnection.signals.accept`-certificate will always be emitted on
    /// client-side connections, unless that bit is not set in
    /// `gio.TlsClientConnection.properties.validation`-flags).
    ///
    /// There are nonintuitive security implications when using a non-default
    /// database. See `gio.TlsConnection.properties.database` for details.
    extern fn g_tls_connection_set_database(p_conn: *TlsConnection, p_database: ?*gio.TlsDatabase) void;
    pub const setDatabase = g_tls_connection_set_database;

    /// Set the object that will be used to interact with the user. It will be used
    /// for things like prompting the user for passwords.
    ///
    /// The `interaction` argument will normally be a derived subclass of
    /// `gio.TlsInteraction`. `NULL` can also be provided if no user interaction
    /// should occur for this connection.
    extern fn g_tls_connection_set_interaction(p_conn: *TlsConnection, p_interaction: ?*gio.TlsInteraction) void;
    pub const setInteraction = g_tls_connection_set_interaction;

    /// Since GLib 2.64, changing the rehandshake mode is no longer supported
    /// and will have no effect. With TLS 1.3, rehandshaking has been removed from
    /// the TLS protocol, replaced by separate post-handshake authentication and
    /// rekey operations.
    extern fn g_tls_connection_set_rehandshake_mode(p_conn: *TlsConnection, p_mode: gio.TlsRehandshakeMode) void;
    pub const setRehandshakeMode = g_tls_connection_set_rehandshake_mode;

    /// Sets whether or not `conn` expects a proper TLS close notification
    /// before the connection is closed. If this is `TRUE` (the default),
    /// then `conn` will expect to receive a TLS close notification from its
    /// peer before the connection is closed, and will return a
    /// `G_TLS_ERROR_EOF` error if the connection is closed without proper
    /// notification (since this may indicate a network error, or
    /// man-in-the-middle attack).
    ///
    /// In some protocols, the application will know whether or not the
    /// connection was closed cleanly based on application-level data
    /// (because the application-level data includes a length field, or is
    /// somehow self-delimiting); in this case, the close notify is
    /// redundant and sometimes omitted. (TLS 1.1 explicitly allows this;
    /// in TLS 1.0 it is technically an error, but often done anyway.) You
    /// can use `gio.TlsConnection.setRequireCloseNotify` to tell `conn`
    /// to allow an "unannounced" connection close, in which case the close
    /// will show up as a 0-length read, as in a non-TLS
    /// `gio.SocketConnection`, and it is up to the application to check that
    /// the data has been fully received.
    ///
    /// Note that this only affects the behavior when the peer closes the
    /// connection; when the application calls `gio.IOStream.close` itself
    /// on `conn`, this will send a close notification regardless of the
    /// setting of this property. If you explicitly want to do an unclean
    /// close, you can close `conn`'s `gio.TlsConnection.properties.base`-io-stream rather
    /// than closing `conn` itself, but note that this may only be done when no other
    /// operations are pending on `conn` or the base I/O stream.
    extern fn g_tls_connection_set_require_close_notify(p_conn: *TlsConnection, p_require_close_notify: c_int) void;
    pub const setRequireCloseNotify = g_tls_connection_set_require_close_notify;

    /// Sets whether `conn` uses the system certificate database to verify
    /// peer certificates. This is `TRUE` by default. If set to `FALSE`, then
    /// peer certificate validation will always set the
    /// `G_TLS_CERTIFICATE_UNKNOWN_CA` error (meaning
    /// `gio.TlsConnection.signals.accept`-certificate will always be emitted on
    /// client-side connections, unless that bit is not set in
    /// `gio.TlsClientConnection.properties.validation`-flags).
    extern fn g_tls_connection_set_use_system_certdb(p_conn: *TlsConnection, p_use_system_certdb: c_int) void;
    pub const setUseSystemCertdb = g_tls_connection_set_use_system_certdb;

    extern fn g_tls_connection_get_type() usize;
    pub const getGObjectType = g_tls_connection_get_type;

    extern fn g_object_ref(p_self: *gio.TlsConnection) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.TlsConnection) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TlsConnection, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GTlsDatabase` is used to look up certificates and other information
/// from a certificate or key store. It is an abstract base class which
/// TLS library specific subtypes override.
///
/// A `GTlsDatabase` may be accessed from multiple threads by the TLS backend.
/// All implementations are required to be fully thread-safe.
///
/// Most common client applications will not directly interact with
/// `GTlsDatabase`. It is used internally by `gio.TlsConnection`.
pub const TlsDatabase = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.TlsDatabaseClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.TlsDatabasePrivate,

    pub const virtual_methods = struct {
        /// Create a handle string for the certificate. The database will only be able
        /// to create a handle for certificates that originate from the database. In
        /// cases where the database cannot create a handle for a certificate, `NULL`
        /// will be returned.
        ///
        /// This handle should be stable across various instances of the application,
        /// and between applications. If a certificate is modified in the database,
        /// then it is not guaranteed that this handle will continue to point to it.
        pub const create_certificate_handle = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_certificate: *gio.TlsCertificate) ?[*:0]u8 {
                return gobject.ext.as(TlsDatabase.Class, p_class).f_create_certificate_handle.?(gobject.ext.as(TlsDatabase, p_self), p_certificate);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_certificate: *gio.TlsCertificate) callconv(.c) ?[*:0]u8) void {
                gobject.ext.as(TlsDatabase.Class, p_class).f_create_certificate_handle = @ptrCast(p_implementation);
            }
        };

        /// Look up a certificate by its handle.
        ///
        /// The handle should have been created by calling
        /// `gio.TlsDatabase.createCertificateHandle` on a `gio.TlsDatabase` object of
        /// the same TLS backend. The handle is designed to remain valid across
        /// instantiations of the database.
        ///
        /// If the handle is no longer valid, or does not point to a certificate in
        /// this database, then `NULL` will be returned.
        ///
        /// This function can block, use `gio.TlsDatabase.lookupCertificateForHandleAsync` to perform
        /// the lookup operation asynchronously.
        pub const lookup_certificate_for_handle = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_handle: [*:0]const u8, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.TlsCertificate {
                return gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificate_for_handle.?(gobject.ext.as(TlsDatabase, p_self), p_handle, p_interaction, p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_handle: [*:0]const u8, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.TlsCertificate) void {
                gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificate_for_handle = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously look up a certificate by its handle in the database. See
        /// `gio.TlsDatabase.lookupCertificateForHandle` for more information.
        pub const lookup_certificate_for_handle_async = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_handle: [*:0]const u8, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificate_for_handle_async.?(gobject.ext.as(TlsDatabase, p_self), p_handle, p_interaction, p_flags, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_handle: [*:0]const u8, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificate_for_handle_async = @ptrCast(p_implementation);
            }
        };

        /// Finish an asynchronous lookup of a certificate by its handle. See
        /// `gio.TlsDatabase.lookupCertificateForHandle` for more information.
        ///
        /// If the handle is no longer valid, or does not point to a certificate in
        /// this database, then `NULL` will be returned.
        pub const lookup_certificate_for_handle_finish = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.TlsCertificate {
                return gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificate_for_handle_finish.?(gobject.ext.as(TlsDatabase, p_self), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.TlsCertificate) void {
                gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificate_for_handle_finish = @ptrCast(p_implementation);
            }
        };

        /// Look up the issuer of `certificate` in the database. The
        /// `gio.TlsCertificate.properties.issuer` property of `certificate` is not modified, and
        /// the two certificates are not hooked into a chain.
        ///
        /// This function can block. Use `gio.TlsDatabase.lookupCertificateIssuerAsync`
        /// to perform the lookup operation asynchronously.
        ///
        /// Beware this function cannot be used to build certification paths. The
        /// issuer certificate returned by this function may not be the same as
        /// the certificate that would actually be used to construct a valid
        /// certification path during certificate verification.
        /// [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
        /// why an issuer certificate cannot be naively assumed to be part of the
        /// the certification path (though GLib's TLS backends may not follow the
        /// path building strategies outlined in this RFC). Due to the complexity
        /// of certification path building, GLib does not provide any way to know
        /// which certification path will actually be used when verifying a TLS
        /// certificate. Accordingly, this function cannot be used to make
        /// security-related decisions. Only GLib itself should make security
        /// decisions about TLS certificates.
        pub const lookup_certificate_issuer = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_certificate: *gio.TlsCertificate, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.TlsCertificate {
                return gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificate_issuer.?(gobject.ext.as(TlsDatabase, p_self), p_certificate, p_interaction, p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_certificate: *gio.TlsCertificate, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.TlsCertificate) void {
                gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificate_issuer = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously look up the issuer of `certificate` in the database. See
        /// `gio.TlsDatabase.lookupCertificateIssuer` for more information.
        pub const lookup_certificate_issuer_async = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_certificate: *gio.TlsCertificate, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificate_issuer_async.?(gobject.ext.as(TlsDatabase, p_self), p_certificate, p_interaction, p_flags, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_certificate: *gio.TlsCertificate, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificate_issuer_async = @ptrCast(p_implementation);
            }
        };

        /// Finish an asynchronous lookup issuer operation. See
        /// `gio.TlsDatabase.lookupCertificateIssuer` for more information.
        pub const lookup_certificate_issuer_finish = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.TlsCertificate {
                return gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificate_issuer_finish.?(gobject.ext.as(TlsDatabase, p_self), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.TlsCertificate) void {
                gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificate_issuer_finish = @ptrCast(p_implementation);
            }
        };

        /// Look up certificates issued by this issuer in the database.
        ///
        /// This function can block, use `gio.TlsDatabase.lookupCertificatesIssuedByAsync` to perform
        /// the lookup operation asynchronously.
        pub const lookup_certificates_issued_by = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_issuer_raw_dn: *glib.ByteArray, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.List {
                return gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificates_issued_by.?(gobject.ext.as(TlsDatabase, p_self), p_issuer_raw_dn, p_interaction, p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_issuer_raw_dn: *glib.ByteArray, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List) void {
                gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificates_issued_by = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously look up certificates issued by this issuer in the database. See
        /// `gio.TlsDatabase.lookupCertificatesIssuedBy` for more information.
        ///
        /// The database may choose to hold a reference to the issuer byte array for the duration
        /// of this asynchronous operation. The byte array should not be modified during
        /// this time.
        pub const lookup_certificates_issued_by_async = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_issuer_raw_dn: *glib.ByteArray, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificates_issued_by_async.?(gobject.ext.as(TlsDatabase, p_self), p_issuer_raw_dn, p_interaction, p_flags, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_issuer_raw_dn: *glib.ByteArray, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificates_issued_by_async = @ptrCast(p_implementation);
            }
        };

        /// Finish an asynchronous lookup of certificates. See
        /// `gio.TlsDatabase.lookupCertificatesIssuedBy` for more information.
        pub const lookup_certificates_issued_by_finish = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.List {
                return gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificates_issued_by_finish.?(gobject.ext.as(TlsDatabase, p_self), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List) void {
                gobject.ext.as(TlsDatabase.Class, p_class).f_lookup_certificates_issued_by_finish = @ptrCast(p_implementation);
            }
        };

        /// Determines the validity of a certificate chain, outside the context
        /// of a TLS session.
        ///
        /// `chain` is a chain of `gio.TlsCertificate` objects each pointing to the next
        /// certificate in the chain by its `gio.TlsCertificate.properties.issuer` property.
        ///
        /// `purpose` describes the purpose (or usage) for which the certificate
        /// is being used. Typically `purpose` will be set to `G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER`
        /// which means that the certificate is being used to authenticate a server
        /// (and we are acting as the client).
        ///
        /// The `identity` is used to ensure the server certificate is valid for
        /// the expected peer identity. If the identity does not match the
        /// certificate, `G_TLS_CERTIFICATE_BAD_IDENTITY` will be set in the
        /// return value. If `identity` is `NULL`, that bit will never be set in
        /// the return value. The peer identity may also be used to check for
        /// pinned certificates (trust exceptions) in the database. These may
        /// override the normal verification process on a host-by-host basis.
        ///
        /// Currently there are no `flags`, and `G_TLS_DATABASE_VERIFY_NONE` should be
        /// used.
        ///
        /// If `chain` is found to be valid, then the return value will be 0. If
        /// `chain` is found to be invalid, then the return value will indicate at
        /// least one problem found. If the function is unable to determine
        /// whether `chain` is valid (for example, because `cancellable` is
        /// triggered before it completes) then the return value will be
        /// `G_TLS_CERTIFICATE_GENERIC_ERROR` and `error` will be set accordingly.
        /// `error` is not set when `chain` is successfully analyzed but found to
        /// be invalid.
        ///
        /// GLib guarantees that if certificate verification fails, at least one
        /// error will be set in the return value, but it does not guarantee
        /// that all possible errors will be set. Accordingly, you may not safely
        /// decide to ignore any particular type of error. For example, it would
        /// be incorrect to mask `G_TLS_CERTIFICATE_EXPIRED` if you want to allow
        /// expired certificates, because this could potentially be the only
        /// error flag set even if other problems exist with the certificate.
        ///
        /// Prior to GLib 2.48, GLib's default TLS backend modified `chain` to
        /// represent the certification path built by `gio.TlsDatabase` during
        /// certificate verification by adjusting the `gio.TlsCertificate.properties.issuer`
        /// property of each certificate in `chain`. Since GLib 2.48, this no
        /// longer occurs, so you cannot rely on `gio.TlsCertificate.properties.issuer` to
        /// represent the actual certification path used during certificate
        /// verification.
        ///
        /// Because TLS session context is not used, `gio.TlsDatabase` may not
        /// perform as many checks on the certificates as `gio.TlsConnection` would.
        /// For example, certificate constraints may not be honored, and
        /// revocation checks may not be performed. The best way to verify TLS
        /// certificates used by a TLS connection is to let `gio.TlsConnection`
        /// handle the verification.
        ///
        /// The TLS backend may attempt to look up and add missing certificates
        /// to the chain. This may involve HTTP requests to download missing
        /// certificates.
        ///
        /// This function can block. Use `gio.TlsDatabase.verifyChainAsync` to
        /// perform the verification operation asynchronously.
        pub const verify_chain = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_chain: *gio.TlsCertificate, p_purpose: [*:0]const u8, p_identity: ?*gio.SocketConnectable, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseVerifyFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) gio.TlsCertificateFlags {
                return gobject.ext.as(TlsDatabase.Class, p_class).f_verify_chain.?(gobject.ext.as(TlsDatabase, p_self), p_chain, p_purpose, p_identity, p_interaction, p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_chain: *gio.TlsCertificate, p_purpose: [*:0]const u8, p_identity: ?*gio.SocketConnectable, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseVerifyFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) gio.TlsCertificateFlags) void {
                gobject.ext.as(TlsDatabase.Class, p_class).f_verify_chain = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously determines the validity of a certificate chain after
        /// looking up and adding any missing certificates to the chain. See
        /// `gio.TlsDatabase.verifyChain` for more information.
        pub const verify_chain_async = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_chain: *gio.TlsCertificate, p_purpose: [*:0]const u8, p_identity: ?*gio.SocketConnectable, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseVerifyFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(TlsDatabase.Class, p_class).f_verify_chain_async.?(gobject.ext.as(TlsDatabase, p_self), p_chain, p_purpose, p_identity, p_interaction, p_flags, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_chain: *gio.TlsCertificate, p_purpose: [*:0]const u8, p_identity: ?*gio.SocketConnectable, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseVerifyFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(TlsDatabase.Class, p_class).f_verify_chain_async = @ptrCast(p_implementation);
            }
        };

        /// Finish an asynchronous verify chain operation. See
        /// `gio.TlsDatabase.verifyChain` for more information.
        ///
        /// If `chain` is found to be valid, then the return value will be 0. If
        /// `chain` is found to be invalid, then the return value will indicate
        /// the problems found. If the function is unable to determine whether
        /// `chain` is valid or not (eg, because `cancellable` is triggered
        /// before it completes) then the return value will be
        /// `G_TLS_CERTIFICATE_GENERIC_ERROR` and `error` will be set
        /// accordingly. `error` is not set when `chain` is successfully analyzed
        /// but found to be invalid.
        pub const verify_chain_finish = struct {
            pub fn call(p_class: anytype, p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) gio.TlsCertificateFlags {
                return gobject.ext.as(TlsDatabase.Class, p_class).f_verify_chain_finish.?(gobject.ext.as(TlsDatabase, p_self), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_self: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) gio.TlsCertificateFlags) void {
                gobject.ext.as(TlsDatabase.Class, p_class).f_verify_chain_finish = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Create a handle string for the certificate. The database will only be able
    /// to create a handle for certificates that originate from the database. In
    /// cases where the database cannot create a handle for a certificate, `NULL`
    /// will be returned.
    ///
    /// This handle should be stable across various instances of the application,
    /// and between applications. If a certificate is modified in the database,
    /// then it is not guaranteed that this handle will continue to point to it.
    extern fn g_tls_database_create_certificate_handle(p_self: *TlsDatabase, p_certificate: *gio.TlsCertificate) ?[*:0]u8;
    pub const createCertificateHandle = g_tls_database_create_certificate_handle;

    /// Look up a certificate by its handle.
    ///
    /// The handle should have been created by calling
    /// `gio.TlsDatabase.createCertificateHandle` on a `gio.TlsDatabase` object of
    /// the same TLS backend. The handle is designed to remain valid across
    /// instantiations of the database.
    ///
    /// If the handle is no longer valid, or does not point to a certificate in
    /// this database, then `NULL` will be returned.
    ///
    /// This function can block, use `gio.TlsDatabase.lookupCertificateForHandleAsync` to perform
    /// the lookup operation asynchronously.
    extern fn g_tls_database_lookup_certificate_for_handle(p_self: *TlsDatabase, p_handle: [*:0]const u8, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.TlsCertificate;
    pub const lookupCertificateForHandle = g_tls_database_lookup_certificate_for_handle;

    /// Asynchronously look up a certificate by its handle in the database. See
    /// `gio.TlsDatabase.lookupCertificateForHandle` for more information.
    extern fn g_tls_database_lookup_certificate_for_handle_async(p_self: *TlsDatabase, p_handle: [*:0]const u8, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const lookupCertificateForHandleAsync = g_tls_database_lookup_certificate_for_handle_async;

    /// Finish an asynchronous lookup of a certificate by its handle. See
    /// `gio.TlsDatabase.lookupCertificateForHandle` for more information.
    ///
    /// If the handle is no longer valid, or does not point to a certificate in
    /// this database, then `NULL` will be returned.
    extern fn g_tls_database_lookup_certificate_for_handle_finish(p_self: *TlsDatabase, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.TlsCertificate;
    pub const lookupCertificateForHandleFinish = g_tls_database_lookup_certificate_for_handle_finish;

    /// Look up the issuer of `certificate` in the database. The
    /// `gio.TlsCertificate.properties.issuer` property of `certificate` is not modified, and
    /// the two certificates are not hooked into a chain.
    ///
    /// This function can block. Use `gio.TlsDatabase.lookupCertificateIssuerAsync`
    /// to perform the lookup operation asynchronously.
    ///
    /// Beware this function cannot be used to build certification paths. The
    /// issuer certificate returned by this function may not be the same as
    /// the certificate that would actually be used to construct a valid
    /// certification path during certificate verification.
    /// [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
    /// why an issuer certificate cannot be naively assumed to be part of the
    /// the certification path (though GLib's TLS backends may not follow the
    /// path building strategies outlined in this RFC). Due to the complexity
    /// of certification path building, GLib does not provide any way to know
    /// which certification path will actually be used when verifying a TLS
    /// certificate. Accordingly, this function cannot be used to make
    /// security-related decisions. Only GLib itself should make security
    /// decisions about TLS certificates.
    extern fn g_tls_database_lookup_certificate_issuer(p_self: *TlsDatabase, p_certificate: *gio.TlsCertificate, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.TlsCertificate;
    pub const lookupCertificateIssuer = g_tls_database_lookup_certificate_issuer;

    /// Asynchronously look up the issuer of `certificate` in the database. See
    /// `gio.TlsDatabase.lookupCertificateIssuer` for more information.
    extern fn g_tls_database_lookup_certificate_issuer_async(p_self: *TlsDatabase, p_certificate: *gio.TlsCertificate, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const lookupCertificateIssuerAsync = g_tls_database_lookup_certificate_issuer_async;

    /// Finish an asynchronous lookup issuer operation. See
    /// `gio.TlsDatabase.lookupCertificateIssuer` for more information.
    extern fn g_tls_database_lookup_certificate_issuer_finish(p_self: *TlsDatabase, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.TlsCertificate;
    pub const lookupCertificateIssuerFinish = g_tls_database_lookup_certificate_issuer_finish;

    /// Look up certificates issued by this issuer in the database.
    ///
    /// This function can block, use `gio.TlsDatabase.lookupCertificatesIssuedByAsync` to perform
    /// the lookup operation asynchronously.
    extern fn g_tls_database_lookup_certificates_issued_by(p_self: *TlsDatabase, p_issuer_raw_dn: *glib.ByteArray, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*glib.List;
    pub const lookupCertificatesIssuedBy = g_tls_database_lookup_certificates_issued_by;

    /// Asynchronously look up certificates issued by this issuer in the database. See
    /// `gio.TlsDatabase.lookupCertificatesIssuedBy` for more information.
    ///
    /// The database may choose to hold a reference to the issuer byte array for the duration
    /// of this asynchronous operation. The byte array should not be modified during
    /// this time.
    extern fn g_tls_database_lookup_certificates_issued_by_async(p_self: *TlsDatabase, p_issuer_raw_dn: *glib.ByteArray, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const lookupCertificatesIssuedByAsync = g_tls_database_lookup_certificates_issued_by_async;

    /// Finish an asynchronous lookup of certificates. See
    /// `gio.TlsDatabase.lookupCertificatesIssuedBy` for more information.
    extern fn g_tls_database_lookup_certificates_issued_by_finish(p_self: *TlsDatabase, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*glib.List;
    pub const lookupCertificatesIssuedByFinish = g_tls_database_lookup_certificates_issued_by_finish;

    /// Determines the validity of a certificate chain, outside the context
    /// of a TLS session.
    ///
    /// `chain` is a chain of `gio.TlsCertificate` objects each pointing to the next
    /// certificate in the chain by its `gio.TlsCertificate.properties.issuer` property.
    ///
    /// `purpose` describes the purpose (or usage) for which the certificate
    /// is being used. Typically `purpose` will be set to `G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER`
    /// which means that the certificate is being used to authenticate a server
    /// (and we are acting as the client).
    ///
    /// The `identity` is used to ensure the server certificate is valid for
    /// the expected peer identity. If the identity does not match the
    /// certificate, `G_TLS_CERTIFICATE_BAD_IDENTITY` will be set in the
    /// return value. If `identity` is `NULL`, that bit will never be set in
    /// the return value. The peer identity may also be used to check for
    /// pinned certificates (trust exceptions) in the database. These may
    /// override the normal verification process on a host-by-host basis.
    ///
    /// Currently there are no `flags`, and `G_TLS_DATABASE_VERIFY_NONE` should be
    /// used.
    ///
    /// If `chain` is found to be valid, then the return value will be 0. If
    /// `chain` is found to be invalid, then the return value will indicate at
    /// least one problem found. If the function is unable to determine
    /// whether `chain` is valid (for example, because `cancellable` is
    /// triggered before it completes) then the return value will be
    /// `G_TLS_CERTIFICATE_GENERIC_ERROR` and `error` will be set accordingly.
    /// `error` is not set when `chain` is successfully analyzed but found to
    /// be invalid.
    ///
    /// GLib guarantees that if certificate verification fails, at least one
    /// error will be set in the return value, but it does not guarantee
    /// that all possible errors will be set. Accordingly, you may not safely
    /// decide to ignore any particular type of error. For example, it would
    /// be incorrect to mask `G_TLS_CERTIFICATE_EXPIRED` if you want to allow
    /// expired certificates, because this could potentially be the only
    /// error flag set even if other problems exist with the certificate.
    ///
    /// Prior to GLib 2.48, GLib's default TLS backend modified `chain` to
    /// represent the certification path built by `gio.TlsDatabase` during
    /// certificate verification by adjusting the `gio.TlsCertificate.properties.issuer`
    /// property of each certificate in `chain`. Since GLib 2.48, this no
    /// longer occurs, so you cannot rely on `gio.TlsCertificate.properties.issuer` to
    /// represent the actual certification path used during certificate
    /// verification.
    ///
    /// Because TLS session context is not used, `gio.TlsDatabase` may not
    /// perform as many checks on the certificates as `gio.TlsConnection` would.
    /// For example, certificate constraints may not be honored, and
    /// revocation checks may not be performed. The best way to verify TLS
    /// certificates used by a TLS connection is to let `gio.TlsConnection`
    /// handle the verification.
    ///
    /// The TLS backend may attempt to look up and add missing certificates
    /// to the chain. This may involve HTTP requests to download missing
    /// certificates.
    ///
    /// This function can block. Use `gio.TlsDatabase.verifyChainAsync` to
    /// perform the verification operation asynchronously.
    extern fn g_tls_database_verify_chain(p_self: *TlsDatabase, p_chain: *gio.TlsCertificate, p_purpose: [*:0]const u8, p_identity: ?*gio.SocketConnectable, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseVerifyFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) gio.TlsCertificateFlags;
    pub const verifyChain = g_tls_database_verify_chain;

    /// Asynchronously determines the validity of a certificate chain after
    /// looking up and adding any missing certificates to the chain. See
    /// `gio.TlsDatabase.verifyChain` for more information.
    extern fn g_tls_database_verify_chain_async(p_self: *TlsDatabase, p_chain: *gio.TlsCertificate, p_purpose: [*:0]const u8, p_identity: ?*gio.SocketConnectable, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseVerifyFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const verifyChainAsync = g_tls_database_verify_chain_async;

    /// Finish an asynchronous verify chain operation. See
    /// `gio.TlsDatabase.verifyChain` for more information.
    ///
    /// If `chain` is found to be valid, then the return value will be 0. If
    /// `chain` is found to be invalid, then the return value will indicate
    /// the problems found. If the function is unable to determine whether
    /// `chain` is valid or not (eg, because `cancellable` is triggered
    /// before it completes) then the return value will be
    /// `G_TLS_CERTIFICATE_GENERIC_ERROR` and `error` will be set
    /// accordingly. `error` is not set when `chain` is successfully analyzed
    /// but found to be invalid.
    extern fn g_tls_database_verify_chain_finish(p_self: *TlsDatabase, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) gio.TlsCertificateFlags;
    pub const verifyChainFinish = g_tls_database_verify_chain_finish;

    extern fn g_tls_database_get_type() usize;
    pub const getGObjectType = g_tls_database_get_type;

    extern fn g_object_ref(p_self: *gio.TlsDatabase) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.TlsDatabase) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TlsDatabase, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GTlsInteraction` provides a mechanism for the TLS connection and database
/// code to interact with the user. It can be used to ask the user for passwords.
///
/// To use a `GTlsInteraction` with a TLS connection use
/// `gio.TlsConnection.setInteraction`.
///
/// Callers should instantiate a derived class that implements the various
/// interaction methods to show the required dialogs.
///
/// Callers should use the 'invoke' functions like
/// `gio.TlsInteraction.invokeAskPassword` to run interaction methods.
/// These functions make sure that the interaction is invoked in the main loop
/// and not in the current thread, if the current thread is not running the
/// main loop.
///
/// Derived classes can choose to implement whichever interactions methods they’d
/// like to support by overriding those virtual methods in their class
/// initialization function. Any interactions not implemented will return
/// `G_TLS_INTERACTION_UNHANDLED`. If a derived class implements an async method,
/// it must also implement the corresponding finish method.
pub const TlsInteraction = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.TlsInteractionClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.TlsInteractionPrivate,

    pub const virtual_methods = struct {
        /// Run synchronous interaction to ask the user for a password. In general,
        /// `gio.TlsInteraction.invokeAskPassword` should be used instead of this
        /// function.
        ///
        /// Derived subclasses usually implement a password prompt, although they may
        /// also choose to provide a password from elsewhere. The `password` value will
        /// be filled in and then `callback` will be called. Alternatively the user may
        /// abort this password request, which will usually abort the TLS connection.
        ///
        /// If the interaction is cancelled by the cancellation object, or by the
        /// user then `G_TLS_INTERACTION_FAILED` will be returned with an error that
        /// contains a `G_IO_ERROR_CANCELLED` error code. Certain implementations may
        /// not support immediate cancellation.
        pub const ask_password = struct {
            pub fn call(p_class: anytype, p_interaction: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_password: *gio.TlsPassword, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) gio.TlsInteractionResult {
                return gobject.ext.as(TlsInteraction.Class, p_class).f_ask_password.?(gobject.ext.as(TlsInteraction, p_interaction), p_password, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_interaction: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_password: *gio.TlsPassword, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) gio.TlsInteractionResult) void {
                gobject.ext.as(TlsInteraction.Class, p_class).f_ask_password = @ptrCast(p_implementation);
            }
        };

        /// Run asynchronous interaction to ask the user for a password. In general,
        /// `gio.TlsInteraction.invokeAskPassword` should be used instead of this
        /// function.
        ///
        /// Derived subclasses usually implement a password prompt, although they may
        /// also choose to provide a password from elsewhere. The `password` value will
        /// be filled in and then `callback` will be called. Alternatively the user may
        /// abort this password request, which will usually abort the TLS connection.
        ///
        /// If the interaction is cancelled by the cancellation object, or by the
        /// user then `G_TLS_INTERACTION_FAILED` will be returned with an error that
        /// contains a `G_IO_ERROR_CANCELLED` error code. Certain implementations may
        /// not support immediate cancellation.
        ///
        /// Certain implementations may not support immediate cancellation.
        pub const ask_password_async = struct {
            pub fn call(p_class: anytype, p_interaction: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_password: *gio.TlsPassword, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(TlsInteraction.Class, p_class).f_ask_password_async.?(gobject.ext.as(TlsInteraction, p_interaction), p_password, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_interaction: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_password: *gio.TlsPassword, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(TlsInteraction.Class, p_class).f_ask_password_async = @ptrCast(p_implementation);
            }
        };

        /// Complete an ask password user interaction request. This should be once
        /// the `gio.TlsInteraction.askPasswordAsync` completion callback is called.
        ///
        /// If `G_TLS_INTERACTION_HANDLED` is returned, then the `gio.TlsPassword` passed
        /// to `gio.TlsInteraction.askPassword` will have its password filled in.
        ///
        /// If the interaction is cancelled by the cancellation object, or by the
        /// user then `G_TLS_INTERACTION_FAILED` will be returned with an error that
        /// contains a `G_IO_ERROR_CANCELLED` error code.
        pub const ask_password_finish = struct {
            pub fn call(p_class: anytype, p_interaction: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) gio.TlsInteractionResult {
                return gobject.ext.as(TlsInteraction.Class, p_class).f_ask_password_finish.?(gobject.ext.as(TlsInteraction, p_interaction), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_interaction: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) gio.TlsInteractionResult) void {
                gobject.ext.as(TlsInteraction.Class, p_class).f_ask_password_finish = @ptrCast(p_implementation);
            }
        };

        /// Run synchronous interaction to ask the user to choose a certificate to use
        /// with the connection. In general, `gio.TlsInteraction.invokeRequestCertificate`
        /// should be used instead of this function.
        ///
        /// Derived subclasses usually implement a certificate selector, although they may
        /// also choose to provide a certificate from elsewhere. Alternatively the user may
        /// abort this certificate request, which will usually abort the TLS connection.
        ///
        /// If `G_TLS_INTERACTION_HANDLED` is returned, then the `gio.TlsConnection`
        /// passed to `gio.TlsInteraction.requestCertificate` will have had its
        /// `gio.TlsConnection.properties.certificate` filled in.
        ///
        /// If the interaction is cancelled by the cancellation object, or by the
        /// user then `G_TLS_INTERACTION_FAILED` will be returned with an error that
        /// contains a `G_IO_ERROR_CANCELLED` error code. Certain implementations may
        /// not support immediate cancellation.
        pub const request_certificate = struct {
            pub fn call(p_class: anytype, p_interaction: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.TlsConnection, p_flags: gio.TlsCertificateRequestFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) gio.TlsInteractionResult {
                return gobject.ext.as(TlsInteraction.Class, p_class).f_request_certificate.?(gobject.ext.as(TlsInteraction, p_interaction), p_connection, p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_interaction: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.TlsConnection, p_flags: gio.TlsCertificateRequestFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) gio.TlsInteractionResult) void {
                gobject.ext.as(TlsInteraction.Class, p_class).f_request_certificate = @ptrCast(p_implementation);
            }
        };

        /// Run asynchronous interaction to ask the user for a certificate to use with
        /// the connection. In general, `gio.TlsInteraction.invokeRequestCertificate` should
        /// be used instead of this function.
        ///
        /// Derived subclasses usually implement a certificate selector, although they may
        /// also choose to provide a certificate from elsewhere. `callback` will be called
        /// when the operation completes. Alternatively the user may abort this certificate
        /// request, which will usually abort the TLS connection.
        pub const request_certificate_async = struct {
            pub fn call(p_class: anytype, p_interaction: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.TlsConnection, p_flags: gio.TlsCertificateRequestFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(TlsInteraction.Class, p_class).f_request_certificate_async.?(gobject.ext.as(TlsInteraction, p_interaction), p_connection, p_flags, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_interaction: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.TlsConnection, p_flags: gio.TlsCertificateRequestFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(TlsInteraction.Class, p_class).f_request_certificate_async = @ptrCast(p_implementation);
            }
        };

        /// Complete a request certificate user interaction request. This should be once
        /// the `gio.TlsInteraction.requestCertificateAsync` completion callback is called.
        ///
        /// If `G_TLS_INTERACTION_HANDLED` is returned, then the `gio.TlsConnection`
        /// passed to `gio.TlsInteraction.requestCertificateAsync` will have had its
        /// `gio.TlsConnection.properties.certificate` filled in.
        ///
        /// If the interaction is cancelled by the cancellation object, or by the
        /// user then `G_TLS_INTERACTION_FAILED` will be returned with an error that
        /// contains a `G_IO_ERROR_CANCELLED` error code.
        pub const request_certificate_finish = struct {
            pub fn call(p_class: anytype, p_interaction: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) gio.TlsInteractionResult {
                return gobject.ext.as(TlsInteraction.Class, p_class).f_request_certificate_finish.?(gobject.ext.as(TlsInteraction, p_interaction), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_interaction: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) gio.TlsInteractionResult) void {
                gobject.ext.as(TlsInteraction.Class, p_class).f_request_certificate_finish = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Run synchronous interaction to ask the user for a password. In general,
    /// `gio.TlsInteraction.invokeAskPassword` should be used instead of this
    /// function.
    ///
    /// Derived subclasses usually implement a password prompt, although they may
    /// also choose to provide a password from elsewhere. The `password` value will
    /// be filled in and then `callback` will be called. Alternatively the user may
    /// abort this password request, which will usually abort the TLS connection.
    ///
    /// If the interaction is cancelled by the cancellation object, or by the
    /// user then `G_TLS_INTERACTION_FAILED` will be returned with an error that
    /// contains a `G_IO_ERROR_CANCELLED` error code. Certain implementations may
    /// not support immediate cancellation.
    extern fn g_tls_interaction_ask_password(p_interaction: *TlsInteraction, p_password: *gio.TlsPassword, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) gio.TlsInteractionResult;
    pub const askPassword = g_tls_interaction_ask_password;

    /// Run asynchronous interaction to ask the user for a password. In general,
    /// `gio.TlsInteraction.invokeAskPassword` should be used instead of this
    /// function.
    ///
    /// Derived subclasses usually implement a password prompt, although they may
    /// also choose to provide a password from elsewhere. The `password` value will
    /// be filled in and then `callback` will be called. Alternatively the user may
    /// abort this password request, which will usually abort the TLS connection.
    ///
    /// If the interaction is cancelled by the cancellation object, or by the
    /// user then `G_TLS_INTERACTION_FAILED` will be returned with an error that
    /// contains a `G_IO_ERROR_CANCELLED` error code. Certain implementations may
    /// not support immediate cancellation.
    ///
    /// Certain implementations may not support immediate cancellation.
    extern fn g_tls_interaction_ask_password_async(p_interaction: *TlsInteraction, p_password: *gio.TlsPassword, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const askPasswordAsync = g_tls_interaction_ask_password_async;

    /// Complete an ask password user interaction request. This should be once
    /// the `gio.TlsInteraction.askPasswordAsync` completion callback is called.
    ///
    /// If `G_TLS_INTERACTION_HANDLED` is returned, then the `gio.TlsPassword` passed
    /// to `gio.TlsInteraction.askPassword` will have its password filled in.
    ///
    /// If the interaction is cancelled by the cancellation object, or by the
    /// user then `G_TLS_INTERACTION_FAILED` will be returned with an error that
    /// contains a `G_IO_ERROR_CANCELLED` error code.
    extern fn g_tls_interaction_ask_password_finish(p_interaction: *TlsInteraction, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) gio.TlsInteractionResult;
    pub const askPasswordFinish = g_tls_interaction_ask_password_finish;

    /// Invoke the interaction to ask the user for a password. It invokes this
    /// interaction in the main loop, specifically the `glib.MainContext` returned by
    /// `glib.mainContextGetThreadDefault` when the interaction is created. This
    /// is called by called by `gio.TlsConnection` or `gio.TlsDatabase` to ask the user
    /// for a password.
    ///
    /// Derived subclasses usually implement a password prompt, although they may
    /// also choose to provide a password from elsewhere. The `password` value will
    /// be filled in and then `callback` will be called. Alternatively the user may
    /// abort this password request, which will usually abort the TLS connection.
    ///
    /// The implementation can either be a synchronous (eg: modal dialog) or an
    /// asynchronous one (eg: modeless dialog). This function will take care of
    /// calling which ever one correctly.
    ///
    /// If the interaction is cancelled by the cancellation object, or by the
    /// user then `G_TLS_INTERACTION_FAILED` will be returned with an error that
    /// contains a `G_IO_ERROR_CANCELLED` error code. Certain implementations may
    /// not support immediate cancellation.
    extern fn g_tls_interaction_invoke_ask_password(p_interaction: *TlsInteraction, p_password: *gio.TlsPassword, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) gio.TlsInteractionResult;
    pub const invokeAskPassword = g_tls_interaction_invoke_ask_password;

    /// Invoke the interaction to ask the user to choose a certificate to
    /// use with the connection. It invokes this interaction in the main
    /// loop, specifically the `glib.MainContext` returned by
    /// `glib.mainContextGetThreadDefault` when the interaction is
    /// created. This is called by called by `gio.TlsConnection` when the peer
    /// requests a certificate during the handshake.
    ///
    /// Derived subclasses usually implement a certificate selector,
    /// although they may also choose to provide a certificate from
    /// elsewhere. Alternatively the user may abort this certificate
    /// request, which may or may not abort the TLS connection.
    ///
    /// The implementation can either be a synchronous (eg: modal dialog) or an
    /// asynchronous one (eg: modeless dialog). This function will take care of
    /// calling which ever one correctly.
    ///
    /// If the interaction is cancelled by the cancellation object, or by the
    /// user then `G_TLS_INTERACTION_FAILED` will be returned with an error that
    /// contains a `G_IO_ERROR_CANCELLED` error code. Certain implementations may
    /// not support immediate cancellation.
    extern fn g_tls_interaction_invoke_request_certificate(p_interaction: *TlsInteraction, p_connection: *gio.TlsConnection, p_flags: gio.TlsCertificateRequestFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) gio.TlsInteractionResult;
    pub const invokeRequestCertificate = g_tls_interaction_invoke_request_certificate;

    /// Run synchronous interaction to ask the user to choose a certificate to use
    /// with the connection. In general, `gio.TlsInteraction.invokeRequestCertificate`
    /// should be used instead of this function.
    ///
    /// Derived subclasses usually implement a certificate selector, although they may
    /// also choose to provide a certificate from elsewhere. Alternatively the user may
    /// abort this certificate request, which will usually abort the TLS connection.
    ///
    /// If `G_TLS_INTERACTION_HANDLED` is returned, then the `gio.TlsConnection`
    /// passed to `gio.TlsInteraction.requestCertificate` will have had its
    /// `gio.TlsConnection.properties.certificate` filled in.
    ///
    /// If the interaction is cancelled by the cancellation object, or by the
    /// user then `G_TLS_INTERACTION_FAILED` will be returned with an error that
    /// contains a `G_IO_ERROR_CANCELLED` error code. Certain implementations may
    /// not support immediate cancellation.
    extern fn g_tls_interaction_request_certificate(p_interaction: *TlsInteraction, p_connection: *gio.TlsConnection, p_flags: gio.TlsCertificateRequestFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) gio.TlsInteractionResult;
    pub const requestCertificate = g_tls_interaction_request_certificate;

    /// Run asynchronous interaction to ask the user for a certificate to use with
    /// the connection. In general, `gio.TlsInteraction.invokeRequestCertificate` should
    /// be used instead of this function.
    ///
    /// Derived subclasses usually implement a certificate selector, although they may
    /// also choose to provide a certificate from elsewhere. `callback` will be called
    /// when the operation completes. Alternatively the user may abort this certificate
    /// request, which will usually abort the TLS connection.
    extern fn g_tls_interaction_request_certificate_async(p_interaction: *TlsInteraction, p_connection: *gio.TlsConnection, p_flags: gio.TlsCertificateRequestFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const requestCertificateAsync = g_tls_interaction_request_certificate_async;

    /// Complete a request certificate user interaction request. This should be once
    /// the `gio.TlsInteraction.requestCertificateAsync` completion callback is called.
    ///
    /// If `G_TLS_INTERACTION_HANDLED` is returned, then the `gio.TlsConnection`
    /// passed to `gio.TlsInteraction.requestCertificateAsync` will have had its
    /// `gio.TlsConnection.properties.certificate` filled in.
    ///
    /// If the interaction is cancelled by the cancellation object, or by the
    /// user then `G_TLS_INTERACTION_FAILED` will be returned with an error that
    /// contains a `G_IO_ERROR_CANCELLED` error code.
    extern fn g_tls_interaction_request_certificate_finish(p_interaction: *TlsInteraction, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) gio.TlsInteractionResult;
    pub const requestCertificateFinish = g_tls_interaction_request_certificate_finish;

    extern fn g_tls_interaction_get_type() usize;
    pub const getGObjectType = g_tls_interaction_get_type;

    extern fn g_object_ref(p_self: *gio.TlsInteraction) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.TlsInteraction) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TlsInteraction, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// An abstract interface representing a password used in TLS. Often used in
/// user interaction such as unlocking a key storage token.
pub const TlsPassword = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.TlsPasswordClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.TlsPasswordPrivate,

    pub const virtual_methods = struct {
        /// virtual method for `gio.TlsPassword.getWarning` if no
        ///  value has been set using `gio.TlsPassword.setWarning`
        pub const get_default_warning = struct {
            pub fn call(p_class: anytype, p_password: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]const u8 {
                return gobject.ext.as(TlsPassword.Class, p_class).f_get_default_warning.?(gobject.ext.as(TlsPassword, p_password));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_password: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]const u8) void {
                gobject.ext.as(TlsPassword.Class, p_class).f_get_default_warning = @ptrCast(p_implementation);
            }
        };

        /// Get the password value. If `length` is not `NULL` then it will be
        /// filled in with the length of the password value. (Note that the
        /// password value is not nul-terminated, so you can only pass `NULL`
        /// for `length` in contexts where you know the password will have a
        /// certain fixed length.)
        pub const get_value = struct {
            pub fn call(p_class: anytype, p_password: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_length: ?*usize) [*]const u8 {
                return gobject.ext.as(TlsPassword.Class, p_class).f_get_value.?(gobject.ext.as(TlsPassword, p_password), p_length);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_password: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_length: ?*usize) callconv(.c) [*]const u8) void {
                gobject.ext.as(TlsPassword.Class, p_class).f_get_value = @ptrCast(p_implementation);
            }
        };

        /// Provide the value for this password.
        ///
        /// The `value` will be owned by the password object, and later freed using
        /// the `destroy` function callback.
        ///
        /// Specify the `length`, for a non-nul-terminated password. Pass -1 as
        /// `length` if using a nul-terminated password, and `length` will be
        /// calculated automatically. (Note that the terminating nul is not
        /// considered part of the password in this case.)
        pub const set_value = struct {
            pub fn call(p_class: anytype, p_password: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_value: [*]u8, p_length: isize, p_destroy: ?glib.DestroyNotify) void {
                return gobject.ext.as(TlsPassword.Class, p_class).f_set_value.?(gobject.ext.as(TlsPassword, p_password), p_value, p_length, p_destroy);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_password: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_value: [*]u8, p_length: isize, p_destroy: ?glib.DestroyNotify) callconv(.c) void) void {
                gobject.ext.as(TlsPassword.Class, p_class).f_set_value = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// Description of what the password is for.
        pub const description = struct {
            pub const name = "description";

            pub const Type = ?[*:0]u8;
        };

        /// Flags about the password.
        pub const flags = struct {
            pub const name = "flags";

            pub const Type = gio.TlsPasswordFlags;
        };

        /// Warning about the password.
        pub const warning = struct {
            pub const name = "warning";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Create a new `gio.TlsPassword` object.
    extern fn g_tls_password_new(p_flags: gio.TlsPasswordFlags, p_description: [*:0]const u8) *gio.TlsPassword;
    pub const new = g_tls_password_new;

    /// Get a description string about what the password will be used for.
    extern fn g_tls_password_get_description(p_password: *TlsPassword) [*:0]const u8;
    pub const getDescription = g_tls_password_get_description;

    /// Get flags about the password.
    extern fn g_tls_password_get_flags(p_password: *TlsPassword) gio.TlsPasswordFlags;
    pub const getFlags = g_tls_password_get_flags;

    /// Get the password value. If `length` is not `NULL` then it will be
    /// filled in with the length of the password value. (Note that the
    /// password value is not nul-terminated, so you can only pass `NULL`
    /// for `length` in contexts where you know the password will have a
    /// certain fixed length.)
    extern fn g_tls_password_get_value(p_password: *TlsPassword, p_length: ?*usize) [*]const u8;
    pub const getValue = g_tls_password_get_value;

    /// Get a user readable translated warning. Usually this warning is a
    /// representation of the password flags returned from
    /// `gio.TlsPassword.getFlags`.
    extern fn g_tls_password_get_warning(p_password: *TlsPassword) [*:0]const u8;
    pub const getWarning = g_tls_password_get_warning;

    /// Set a description string about what the password will be used for.
    extern fn g_tls_password_set_description(p_password: *TlsPassword, p_description: [*:0]const u8) void;
    pub const setDescription = g_tls_password_set_description;

    /// Set flags about the password.
    extern fn g_tls_password_set_flags(p_password: *TlsPassword, p_flags: gio.TlsPasswordFlags) void;
    pub const setFlags = g_tls_password_set_flags;

    /// Set the value for this password. The `value` will be copied by the password
    /// object.
    ///
    /// Specify the `length`, for a non-nul-terminated password. Pass -1 as
    /// `length` if using a nul-terminated password, and `length` will be
    /// calculated automatically. (Note that the terminating nul is not
    /// considered part of the password in this case.)
    extern fn g_tls_password_set_value(p_password: *TlsPassword, p_value: [*]const u8, p_length: isize) void;
    pub const setValue = g_tls_password_set_value;

    /// Provide the value for this password.
    ///
    /// The `value` will be owned by the password object, and later freed using
    /// the `destroy` function callback.
    ///
    /// Specify the `length`, for a non-nul-terminated password. Pass -1 as
    /// `length` if using a nul-terminated password, and `length` will be
    /// calculated automatically. (Note that the terminating nul is not
    /// considered part of the password in this case.)
    extern fn g_tls_password_set_value_full(p_password: *TlsPassword, p_value: [*]u8, p_length: isize, p_destroy: ?glib.DestroyNotify) void;
    pub const setValueFull = g_tls_password_set_value_full;

    /// Set a user readable translated warning. Usually this warning is a
    /// representation of the password flags returned from
    /// `gio.TlsPassword.getFlags`.
    extern fn g_tls_password_set_warning(p_password: *TlsPassword, p_warning: [*:0]const u8) void;
    pub const setWarning = g_tls_password_set_warning;

    extern fn g_tls_password_get_type() usize;
    pub const getGObjectType = g_tls_password_get_type;

    extern fn g_object_ref(p_self: *gio.TlsPassword) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.TlsPassword) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TlsPassword, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// This is the subclass of `gio.SocketConnection` that is created
/// for UNIX domain sockets.
///
/// It contains functions to do some of the UNIX socket specific
/// functionality like passing file descriptors.
///
/// Since GLib 2.72, `GUnixConnection` is available on all platforms. It requires
/// underlying system support (such as Windows 10 with `AF_UNIX`) at run time.
///
/// Before GLib 2.72, `<gio/gunixconnection.h>` belonged to the UNIX-specific GIO
/// interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file when
/// using it. This is no longer necessary since GLib 2.72.
pub const UnixConnection = extern struct {
    pub const Parent = gio.SocketConnection;
    pub const Implements = [_]type{};
    pub const Class = gio.UnixConnectionClass;
    f_parent_instance: gio.SocketConnection,
    f_priv: ?*gio.UnixConnectionPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Receives credentials from the sending end of the connection.  The
    /// sending end has to call `gio.UnixConnection.sendCredentials` (or
    /// similar) for this to work.
    ///
    /// As well as reading the credentials this also reads (and discards) a
    /// single byte from the stream, as this is required for credentials
    /// passing to work on some implementations.
    ///
    /// This method can be expected to be available on the following platforms:
    ///
    /// - Linux since GLib 2.26
    /// - FreeBSD since GLib 2.26
    /// - GNU/kFreeBSD since GLib 2.36
    /// - Solaris, Illumos and OpenSolaris since GLib 2.40
    /// - GNU/Hurd since GLib 2.40
    ///
    /// Other ways to exchange credentials with a foreign peer includes the
    /// `gio.UnixCredentialsMessage` type and `gio.Socket.getCredentials` function.
    extern fn g_unix_connection_receive_credentials(p_connection: *UnixConnection, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.Credentials;
    pub const receiveCredentials = g_unix_connection_receive_credentials;

    /// Asynchronously receive credentials.
    ///
    /// For more details, see `gio.UnixConnection.receiveCredentials` which is
    /// the synchronous version of this call.
    ///
    /// When the operation is finished, `callback` will be called. You can then call
    /// `gio.UnixConnection.receiveCredentialsFinish` to get the result of the operation.
    extern fn g_unix_connection_receive_credentials_async(p_connection: *UnixConnection, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const receiveCredentialsAsync = g_unix_connection_receive_credentials_async;

    /// Finishes an asynchronous receive credentials operation started with
    /// `gio.UnixConnection.receiveCredentialsAsync`.
    extern fn g_unix_connection_receive_credentials_finish(p_connection: *UnixConnection, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.Credentials;
    pub const receiveCredentialsFinish = g_unix_connection_receive_credentials_finish;

    /// Receives a file descriptor from the sending end of the connection.
    /// The sending end has to call `gio.UnixConnection.sendFd` for this
    /// to work.
    ///
    /// As well as reading the fd this also reads a single byte from the
    /// stream, as this is required for fd passing to work on some
    /// implementations.
    extern fn g_unix_connection_receive_fd(p_connection: *UnixConnection, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const receiveFd = g_unix_connection_receive_fd;

    /// Passes the credentials of the current user the receiving side
    /// of the connection. The receiving end has to call
    /// `gio.UnixConnection.receiveCredentials` (or similar) to accept the
    /// credentials.
    ///
    /// As well as sending the credentials this also writes a single NUL
    /// byte to the stream, as this is required for credentials passing to
    /// work on some implementations.
    ///
    /// This method can be expected to be available on the following platforms:
    ///
    /// - Linux since GLib 2.26
    /// - FreeBSD since GLib 2.26
    /// - GNU/kFreeBSD since GLib 2.36
    /// - Solaris, Illumos and OpenSolaris since GLib 2.40
    /// - GNU/Hurd since GLib 2.40
    ///
    /// Other ways to exchange credentials with a foreign peer includes the
    /// `gio.UnixCredentialsMessage` type and `gio.Socket.getCredentials` function.
    extern fn g_unix_connection_send_credentials(p_connection: *UnixConnection, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const sendCredentials = g_unix_connection_send_credentials;

    /// Asynchronously send credentials.
    ///
    /// For more details, see `gio.UnixConnection.sendCredentials` which is
    /// the synchronous version of this call.
    ///
    /// When the operation is finished, `callback` will be called. You can then call
    /// `gio.UnixConnection.sendCredentialsFinish` to get the result of the operation.
    extern fn g_unix_connection_send_credentials_async(p_connection: *UnixConnection, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const sendCredentialsAsync = g_unix_connection_send_credentials_async;

    /// Finishes an asynchronous send credentials operation started with
    /// `gio.UnixConnection.sendCredentialsAsync`.
    extern fn g_unix_connection_send_credentials_finish(p_connection: *UnixConnection, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const sendCredentialsFinish = g_unix_connection_send_credentials_finish;

    /// Passes a file descriptor to the receiving side of the
    /// connection. The receiving end has to call `gio.UnixConnection.receiveFd`
    /// to accept the file descriptor.
    ///
    /// As well as sending the fd this also writes a single byte to the
    /// stream, as this is required for fd passing to work on some
    /// implementations.
    extern fn g_unix_connection_send_fd(p_connection: *UnixConnection, p_fd: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const sendFd = g_unix_connection_send_fd;

    extern fn g_unix_connection_get_type() usize;
    pub const getGObjectType = g_unix_connection_get_type;

    extern fn g_object_ref(p_self: *gio.UnixConnection) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.UnixConnection) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *UnixConnection, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// This `gio.SocketControlMessage` contains a `gio.Credentials`
/// instance.  It may be sent using `gio.Socket.sendMessage` and received
/// using `gio.Socket.receiveMessage` over UNIX sockets (ie: sockets in
/// the `G_SOCKET_FAMILY_UNIX` family).
///
/// For an easier way to send and receive credentials over
/// stream-oriented UNIX sockets, see
/// `gio.UnixConnection.sendCredentials` and
/// `gio.UnixConnection.receiveCredentials`. To receive credentials of
/// a foreign process connected to a socket, use
/// `gio.Socket.getCredentials`.
///
/// Since GLib 2.72, `GUnixCredentialMessage` is available on all platforms. It
/// requires underlying system support (such as Windows 10 with `AF_UNIX`) at run
/// time.
///
/// Before GLib 2.72, `<gio/gunixcredentialsmessage.h>` belonged to the UNIX-specific
/// GIO interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file
/// when using it. This is no longer necessary since GLib 2.72.
pub const UnixCredentialsMessage = extern struct {
    pub const Parent = gio.SocketControlMessage;
    pub const Implements = [_]type{};
    pub const Class = gio.UnixCredentialsMessageClass;
    f_parent_instance: gio.SocketControlMessage,
    f_priv: ?*gio.UnixCredentialsMessagePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The credentials stored in the message.
        pub const credentials = struct {
            pub const name = "credentials";

            pub const Type = ?*gio.Credentials;
        };
    };

    pub const signals = struct {};

    /// Checks if passing `gio.Credentials` on a `gio.Socket` is supported on this platform.
    extern fn g_unix_credentials_message_is_supported() c_int;
    pub const isSupported = g_unix_credentials_message_is_supported;

    /// Creates a new `gio.UnixCredentialsMessage` with credentials matching the current processes.
    extern fn g_unix_credentials_message_new() *gio.UnixCredentialsMessage;
    pub const new = g_unix_credentials_message_new;

    /// Creates a new `gio.UnixCredentialsMessage` holding `credentials`.
    extern fn g_unix_credentials_message_new_with_credentials(p_credentials: *gio.Credentials) *gio.UnixCredentialsMessage;
    pub const newWithCredentials = g_unix_credentials_message_new_with_credentials;

    /// Gets the credentials stored in `message`.
    extern fn g_unix_credentials_message_get_credentials(p_message: *UnixCredentialsMessage) *gio.Credentials;
    pub const getCredentials = g_unix_credentials_message_get_credentials;

    extern fn g_unix_credentials_message_get_type() usize;
    pub const getGObjectType = g_unix_credentials_message_get_type;

    extern fn g_object_ref(p_self: *gio.UnixCredentialsMessage) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.UnixCredentialsMessage) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *UnixCredentialsMessage, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `GUnixFDList` contains a list of file descriptors.  It owns the file
/// descriptors that it contains, closing them when finalized.
///
/// It may be wrapped in a
/// [`GUnixFDMessage`](../gio-unix/class.UnixFDMessage.html) and sent over a
/// `gio.Socket` in the `G_SOCKET_FAMILY_UNIX` family by using
/// `gio.Socket.sendMessage` and received using
/// `gio.Socket.receiveMessage`.
///
/// Before 2.74, `<gio/gunixfdlist.h>` belonged to the UNIX-specific GIO
/// interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file when
/// using it.
///
/// Since 2.74, the API is available for Windows.
pub const UnixFDList = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.UnixFDListClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*gio.UnixFDListPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gio.UnixFDList` containing no file descriptors.
    extern fn g_unix_fd_list_new() *gio.UnixFDList;
    pub const new = g_unix_fd_list_new;

    /// Creates a new `gio.UnixFDList` containing the file descriptors given in
    /// `fds`.  The file descriptors become the property of the new list and
    /// may no longer be used by the caller.  The array itself is owned by
    /// the caller.
    ///
    /// Each file descriptor in the array should be set to close-on-exec.
    ///
    /// If `n_fds` is -1 then `fds` must be terminated with -1.
    extern fn g_unix_fd_list_new_from_array(p_fds: [*]const c_int, p_n_fds: c_int) *gio.UnixFDList;
    pub const newFromArray = g_unix_fd_list_new_from_array;

    /// Adds a file descriptor to `list`.
    ///
    /// The file descriptor is duplicated using `dup`. You keep your copy
    /// of the descriptor and the copy contained in `list` will be closed
    /// when `list` is finalized.
    ///
    /// A possible cause of failure is exceeding the per-process or
    /// system-wide file descriptor limit.
    ///
    /// The index of the file descriptor in the list is returned.  If you use
    /// this index with `gio.UnixFDList.get` then you will receive back a
    /// duplicated copy of the same file descriptor.
    extern fn g_unix_fd_list_append(p_list: *UnixFDList, p_fd: c_int, p_error: ?*?*glib.Error) c_int;
    pub const append = g_unix_fd_list_append;

    /// Gets a file descriptor out of `list`.
    ///
    /// `index_` specifies the index of the file descriptor to get.  It is a
    /// programmer error for `index_` to be out of range; see
    /// `gio.UnixFDList.getLength`.
    ///
    /// The file descriptor is duplicated using `dup` and set as
    /// close-on-exec before being returned.  You must call `close` on it
    /// when you are done.
    ///
    /// A possible cause of failure is exceeding the per-process or
    /// system-wide file descriptor limit.
    extern fn g_unix_fd_list_get(p_list: *UnixFDList, p_index_: c_int, p_error: ?*?*glib.Error) c_int;
    pub const get = g_unix_fd_list_get;

    /// Gets the length of `list` (ie: the number of file descriptors
    /// contained within).
    extern fn g_unix_fd_list_get_length(p_list: *UnixFDList) c_int;
    pub const getLength = g_unix_fd_list_get_length;

    /// Returns the array of file descriptors that is contained in this
    /// object.
    ///
    /// After this call, the descriptors remain the property of `list`.  The
    /// caller must not close them and must not free the array.  The array is
    /// valid only until `list` is changed in any way.
    ///
    /// If `length` is non-`NULL` then it is set to the number of file
    /// descriptors in the returned array. The returned array is also
    /// terminated with -1.
    ///
    /// This function never returns `NULL`. In case there are no file
    /// descriptors contained in `list`, an empty array is returned.
    extern fn g_unix_fd_list_peek_fds(p_list: *UnixFDList, p_length: ?*c_int) [*]const c_int;
    pub const peekFds = g_unix_fd_list_peek_fds;

    /// Returns the array of file descriptors that is contained in this
    /// object.
    ///
    /// After this call, the descriptors are no longer contained in
    /// `list`. Further calls will return an empty list (unless more
    /// descriptors have been added).
    ///
    /// The return result of this function must be freed with `glib.free`.
    /// The caller is also responsible for closing all of the file
    /// descriptors.  The file descriptors in the array are set to
    /// close-on-exec.
    ///
    /// If `length` is non-`NULL` then it is set to the number of file
    /// descriptors in the returned array. The returned array is also
    /// terminated with -1.
    ///
    /// This function never returns `NULL`. In case there are no file
    /// descriptors contained in `list`, an empty array is returned.
    extern fn g_unix_fd_list_steal_fds(p_list: *UnixFDList, p_length: ?*c_int) [*]c_int;
    pub const stealFds = g_unix_fd_list_steal_fds;

    extern fn g_unix_fd_list_get_type() usize;
    pub const getGObjectType = g_unix_fd_list_get_type;

    extern fn g_object_ref(p_self: *gio.UnixFDList) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.UnixFDList) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *UnixFDList, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// This `gio.SocketControlMessage` contains a `gio.UnixFDList`.
/// It may be sent using `gio.Socket.sendMessage` and received using
/// `gio.Socket.receiveMessage` over UNIX sockets (ie: sockets in the
/// `G_SOCKET_FAMILY_UNIX` family). The file descriptors are copied
/// between processes by the kernel.
///
/// For an easier way to send and receive file descriptors over
/// stream-oriented UNIX sockets, see `gio.UnixConnection.sendFd` and
/// `gio.UnixConnection.receiveFd`.
///
/// Note that `<gio/gunixfdmessage.h>` belongs to the UNIX-specific GIO
/// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
/// file or the `GioUnix-2.0` GIR namespace when using it.
pub const UnixFDMessage = extern struct {
    pub const Parent = gio.SocketControlMessage;
    pub const Implements = [_]type{};
    pub const Class = gio.UnixFDMessageClass;
    f_parent_instance: gio.SocketControlMessage,
    f_priv: ?*gio.UnixFDMessagePrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The `gio.UnixFDList` object to send with the message.
        pub const fd_list = struct {
            pub const name = "fd-list";

            pub const Type = ?*gio.UnixFDList;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.UnixFDMessage` containing an empty file descriptor
    /// list.
    extern fn g_unix_fd_message_new() *gio.UnixFDMessage;
    pub const new = g_unix_fd_message_new;

    /// Creates a new `gio.UnixFDMessage` containing `list`.
    extern fn g_unix_fd_message_new_with_fd_list(p_fd_list: *gio.UnixFDList) *gio.UnixFDMessage;
    pub const newWithFdList = g_unix_fd_message_new_with_fd_list;

    /// Adds a file descriptor to `message`.
    ///
    /// The file descriptor is duplicated using `dup`. You keep your copy
    /// of the descriptor and the copy contained in `message` will be closed
    /// when `message` is finalized.
    ///
    /// A possible cause of failure is exceeding the per-process or
    /// system-wide file descriptor limit.
    extern fn g_unix_fd_message_append_fd(p_message: *UnixFDMessage, p_fd: c_int, p_error: ?*?*glib.Error) c_int;
    pub const appendFd = g_unix_fd_message_append_fd;

    /// Gets the `gio.UnixFDList` contained in `message`.  This function does not
    /// return a reference to the caller, but the returned list is valid for
    /// the lifetime of `message`.
    extern fn g_unix_fd_message_get_fd_list(p_message: *UnixFDMessage) *gio.UnixFDList;
    pub const getFdList = g_unix_fd_message_get_fd_list;

    /// Returns the array of file descriptors that is contained in this
    /// object.
    ///
    /// After this call, the descriptors are no longer contained in
    /// `message`. Further calls will return an empty list (unless more
    /// descriptors have been added).
    ///
    /// The return result of this function must be freed with `glib.free`.
    /// The caller is also responsible for closing all of the file
    /// descriptors.
    ///
    /// If `length` is non-`NULL` then it is set to the number of file
    /// descriptors in the returned array. The returned array is also
    /// terminated with -1.
    ///
    /// This function never returns `NULL`. In case there are no file
    /// descriptors contained in `message`, an empty array is returned.
    extern fn g_unix_fd_message_steal_fds(p_message: *UnixFDMessage, p_length: ?*c_int) [*]c_int;
    pub const stealFds = g_unix_fd_message_steal_fds;

    extern fn g_unix_fd_message_get_type() usize;
    pub const getGObjectType = g_unix_fd_message_get_type;

    extern fn g_object_ref(p_self: *gio.UnixFDMessage) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.UnixFDMessage) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *UnixFDMessage, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GUnixInputStream` implements `gio.InputStream` for reading from a UNIX
/// file descriptor, including asynchronous operations. (If the file
/// descriptor refers to a socket or pipe, this will use ``poll`` to do
/// asynchronous I/O. If it refers to a regular file, it will fall back
/// to doing asynchronous I/O in another thread.)
///
/// Note that `<gio/gunixinputstream.h>` belongs to the UNIX-specific GIO
/// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
/// file or the `GioUnix-2.0` GIR namespace when using it.
pub const UnixInputStream = extern struct {
    pub const Parent = gio.InputStream;
    pub const Implements = [_]type{ gio.FileDescriptorBased, gio.PollableInputStream };
    pub const Class = gio.UnixInputStreamClass;
    f_parent_instance: gio.InputStream,
    f_priv: ?*gio.UnixInputStreamPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Whether to close the file descriptor when the stream is closed.
        pub const close_fd = struct {
            pub const name = "close-fd";

            pub const Type = c_int;
        };

        /// The file descriptor that the stream reads from.
        pub const fd = struct {
            pub const name = "fd";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.UnixInputStream` for the given `fd`.
    ///
    /// If `close_fd` is `TRUE`, the file descriptor will be closed
    /// when the stream is closed.
    extern fn g_unix_input_stream_new(p_fd: c_int, p_close_fd: c_int) *gio.UnixInputStream;
    pub const new = g_unix_input_stream_new;

    /// Returns whether the file descriptor of `stream` will be
    /// closed when the stream is closed.
    extern fn g_unix_input_stream_get_close_fd(p_stream: *UnixInputStream) c_int;
    pub const getCloseFd = g_unix_input_stream_get_close_fd;

    /// Return the UNIX file descriptor that the stream reads from.
    extern fn g_unix_input_stream_get_fd(p_stream: *UnixInputStream) c_int;
    pub const getFd = g_unix_input_stream_get_fd;

    /// Sets whether the file descriptor of `stream` shall be closed
    /// when the stream is closed.
    extern fn g_unix_input_stream_set_close_fd(p_stream: *UnixInputStream, p_close_fd: c_int) void;
    pub const setCloseFd = g_unix_input_stream_set_close_fd;

    extern fn g_unix_input_stream_get_type() usize;
    pub const getGObjectType = g_unix_input_stream_get_type;

    extern fn g_object_ref(p_self: *gio.UnixInputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.UnixInputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *UnixInputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Watches for changes to the set of mount entries and mount points in the
/// system.
///
/// Connect to the `giounix.MountMonitor.signals.mounts_changed` signal to be
/// notified of changes to the `giounix.MountEntry` list.
///
/// Connect to the `giounix.MountMonitor.signals.mountpoints_changed` signal to
/// be notified of changes to the `giounix.MountPoint` list.
pub const UnixMountMonitor = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.UnixMountMonitorClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {};

    pub const signals = struct {
        /// Emitted when the Unix mount points have changed.
        pub const mountpoints_changed = struct {
            pub const name = "mountpoints-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(UnixMountMonitor, p_instance))),
                    gobject.signalLookup("mountpoints-changed", UnixMountMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the Unix mount entries have changed.
        pub const mounts_changed = struct {
            pub const name = "mounts-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(UnixMountMonitor, p_instance))),
                    gobject.signalLookup("mounts-changed", UnixMountMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Gets the `giounix.MountMonitor` for the current thread-default main
    /// context.
    ///
    /// The mount monitor can be used to monitor for changes to the list of
    /// mounted filesystems as well as the list of mount points (ie: fstab
    /// entries).
    ///
    /// You must only call `gobject.Object.unref` on the return value from
    /// under the same main context as you called this function.
    extern fn g_unix_mount_monitor_get() *gio.UnixMountMonitor;
    pub const get = g_unix_mount_monitor_get;

    /// Deprecated alias for `giounix.MountMonitor.get`.
    ///
    /// This function was never a true constructor, which is why it was
    /// renamed.
    extern fn g_unix_mount_monitor_new() *gio.UnixMountMonitor;
    pub const new = g_unix_mount_monitor_new;

    /// This function does nothing.
    ///
    /// Before 2.44, this was a partially-effective way of controlling the
    /// rate at which events would be reported under some uncommon
    /// circumstances.  Since `mount_monitor` is a singleton, it also meant
    /// that calling this function would have side effects for other users of
    /// the monitor.
    extern fn g_unix_mount_monitor_set_rate_limit(p_mount_monitor: *UnixMountMonitor, p_limit_msec: c_int) void;
    pub const setRateLimit = g_unix_mount_monitor_set_rate_limit;

    extern fn g_unix_mount_monitor_get_type() usize;
    pub const getGObjectType = g_unix_mount_monitor_get_type;

    extern fn g_object_ref(p_self: *gio.UnixMountMonitor) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.UnixMountMonitor) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *UnixMountMonitor, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GUnixOutputStream` implements `gio.OutputStream` for writing to a UNIX
/// file descriptor, including asynchronous operations. (If the file
/// descriptor refers to a socket or pipe, this will use ``poll`` to do
/// asynchronous I/O. If it refers to a regular file, it will fall back
/// to doing asynchronous I/O in another thread.)
///
/// Note that `<gio/gunixoutputstream.h>` belongs to the UNIX-specific GIO
/// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file
/// file or the `GioUnix-2.0` GIR namespace when using it.
pub const UnixOutputStream = extern struct {
    pub const Parent = gio.OutputStream;
    pub const Implements = [_]type{ gio.FileDescriptorBased, gio.PollableOutputStream };
    pub const Class = gio.UnixOutputStreamClass;
    f_parent_instance: gio.OutputStream,
    f_priv: ?*gio.UnixOutputStreamPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Whether to close the file descriptor when the stream is closed.
        pub const close_fd = struct {
            pub const name = "close-fd";

            pub const Type = c_int;
        };

        /// The file descriptor that the stream writes to.
        pub const fd = struct {
            pub const name = "fd";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.UnixOutputStream` for the given `fd`.
    ///
    /// If `close_fd`, is `TRUE`, the file descriptor will be closed when
    /// the output stream is destroyed.
    extern fn g_unix_output_stream_new(p_fd: c_int, p_close_fd: c_int) *gio.UnixOutputStream;
    pub const new = g_unix_output_stream_new;

    /// Returns whether the file descriptor of `stream` will be
    /// closed when the stream is closed.
    extern fn g_unix_output_stream_get_close_fd(p_stream: *UnixOutputStream) c_int;
    pub const getCloseFd = g_unix_output_stream_get_close_fd;

    /// Return the UNIX file descriptor that the stream writes to.
    extern fn g_unix_output_stream_get_fd(p_stream: *UnixOutputStream) c_int;
    pub const getFd = g_unix_output_stream_get_fd;

    /// Sets whether the file descriptor of `stream` shall be closed
    /// when the stream is closed.
    extern fn g_unix_output_stream_set_close_fd(p_stream: *UnixOutputStream, p_close_fd: c_int) void;
    pub const setCloseFd = g_unix_output_stream_set_close_fd;

    extern fn g_unix_output_stream_get_type() usize;
    pub const getGObjectType = g_unix_output_stream_get_type;

    extern fn g_object_ref(p_self: *gio.UnixOutputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.UnixOutputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *UnixOutputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Support for UNIX-domain (also known as local) sockets, corresponding to
/// `struct sockaddr_un`.
///
/// UNIX domain sockets are generally visible in the filesystem.
/// However, some systems support abstract socket names which are not
/// visible in the filesystem and not affected by the filesystem
/// permissions, visibility, etc. Currently this is only supported
/// under Linux. If you attempt to use abstract sockets on other
/// systems, function calls may return `G_IO_ERROR_NOT_SUPPORTED`
/// errors. You can use `gio.UnixSocketAddress.abstractNamesSupported`
/// to see if abstract names are supported.
///
/// Since GLib 2.72, `GUnixSocketAddress` is available on all platforms. It
/// requires underlying system support (such as Windows 10 with `AF_UNIX`) at
/// run time.
///
/// Before GLib 2.72, `<gio/gunixsocketaddress.h>` belonged to the UNIX-specific
/// GIO interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file
/// when using it. This is no longer necessary since GLib 2.72.
pub const UnixSocketAddress = extern struct {
    pub const Parent = gio.SocketAddress;
    pub const Implements = [_]type{gio.SocketConnectable};
    pub const Class = gio.UnixSocketAddressClass;
    f_parent_instance: gio.SocketAddress,
    f_priv: ?*gio.UnixSocketAddressPrivate,

    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Whether or not this is an abstract address
        pub const abstract = struct {
            pub const name = "abstract";

            pub const Type = c_int;
        };

        /// The type of Unix socket address.
        pub const address_type = struct {
            pub const name = "address-type";

            pub const Type = gio.UnixSocketAddressType;
        };

        /// Unix socket path.
        pub const path = struct {
            pub const name = "path";

            pub const Type = ?[*:0]u8;
        };

        /// Unix socket path, as a byte array.
        pub const path_as_array = struct {
            pub const name = "path-as-array";

            pub const Type = ?[*]u8;
        };
    };

    pub const signals = struct {};

    /// Checks if abstract UNIX domain socket names are supported.
    extern fn g_unix_socket_address_abstract_names_supported() c_int;
    pub const abstractNamesSupported = g_unix_socket_address_abstract_names_supported;

    /// Creates a new `gio.UnixSocketAddress` for `path`.
    ///
    /// To create abstract socket addresses, on systems that support that,
    /// use `gio.UnixSocketAddress.newAbstract`.
    extern fn g_unix_socket_address_new(p_path: [*:0]const u8) *gio.UnixSocketAddress;
    pub const new = g_unix_socket_address_new;

    /// Creates a new `G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED`
    /// `gio.UnixSocketAddress` for `path`.
    extern fn g_unix_socket_address_new_abstract(p_path: [*]const u8, p_path_len: c_int) *gio.UnixSocketAddress;
    pub const newAbstract = g_unix_socket_address_new_abstract;

    /// Creates a new `gio.UnixSocketAddress` of type `type` with name `path`.
    ///
    /// If `type` is `G_UNIX_SOCKET_ADDRESS_PATH`, this is equivalent to
    /// calling `gio.UnixSocketAddress.new`.
    ///
    /// If `type` is `G_UNIX_SOCKET_ADDRESS_ANONYMOUS`, `path` and `path_len` will be
    /// ignored.
    ///
    /// If `path_type` is `G_UNIX_SOCKET_ADDRESS_ABSTRACT`, then `path_len`
    /// bytes of `path` will be copied to the socket's path, and only those
    /// bytes will be considered part of the name. (If `path_len` is -1,
    /// then `path` is assumed to be NUL-terminated.) For example, if `path`
    /// was "test", then calling `gio.SocketAddress.getNativeSize` on the
    /// returned socket would return 7 (2 bytes of overhead, 1 byte for the
    /// abstract-socket indicator byte, and 4 bytes for the name "test").
    ///
    /// If `path_type` is `G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED`, then
    /// `path_len` bytes of `path` will be copied to the socket's path, the
    /// rest of the path will be padded with 0 bytes, and the entire
    /// zero-padded buffer will be considered the name. (As above, if
    /// `path_len` is -1, then `path` is assumed to be NUL-terminated.) In
    /// this case, `gio.SocketAddress.getNativeSize` will always return
    /// the full size of a `struct sockaddr_un`, although
    /// `gio.UnixSocketAddress.getPathLen` will still return just the
    /// length of `path`.
    ///
    /// `G_UNIX_SOCKET_ADDRESS_ABSTRACT` is preferred over
    /// `G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED` for new programs. Of course,
    /// when connecting to a server created by another process, you must
    /// use the appropriate type corresponding to how that process created
    /// its listening socket.
    extern fn g_unix_socket_address_new_with_type(p_path: [*]const u8, p_path_len: c_int, p_type: gio.UnixSocketAddressType) *gio.UnixSocketAddress;
    pub const newWithType = g_unix_socket_address_new_with_type;

    /// Gets `address`'s type.
    extern fn g_unix_socket_address_get_address_type(p_address: *UnixSocketAddress) gio.UnixSocketAddressType;
    pub const getAddressType = g_unix_socket_address_get_address_type;

    /// Tests if `address` is abstract.
    extern fn g_unix_socket_address_get_is_abstract(p_address: *UnixSocketAddress) c_int;
    pub const getIsAbstract = g_unix_socket_address_get_is_abstract;

    /// Gets `address`'s path, or for abstract sockets the "name".
    ///
    /// Guaranteed to be zero-terminated, but an abstract socket
    /// may contain embedded zeros, and thus you should use
    /// `gio.UnixSocketAddress.getPathLen` to get the true length
    /// of this string.
    extern fn g_unix_socket_address_get_path(p_address: *UnixSocketAddress) [*:0]const u8;
    pub const getPath = g_unix_socket_address_get_path;

    /// Gets the length of `address`'s path.
    ///
    /// For details, see `gio.UnixSocketAddress.getPath`.
    extern fn g_unix_socket_address_get_path_len(p_address: *UnixSocketAddress) usize;
    pub const getPathLen = g_unix_socket_address_get_path_len;

    extern fn g_unix_socket_address_get_type() usize;
    pub const getGObjectType = g_unix_socket_address_get_type;

    extern fn g_object_ref(p_self: *gio.UnixSocketAddress) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.UnixSocketAddress) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *UnixSocketAddress, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Entry point for using GIO functionality.
pub const Vfs = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.VfsClass;
    f_parent_instance: gobject.Object,

    pub const virtual_methods = struct {
        pub const add_writable_namespaces = struct {
            pub fn call(p_class: anytype, p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_list: *gio.FileAttributeInfoList) void {
                return gobject.ext.as(Vfs.Class, p_class).f_add_writable_namespaces.?(gobject.ext.as(Vfs, p_vfs), p_list);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_list: *gio.FileAttributeInfoList) callconv(.c) void) void {
                gobject.ext.as(Vfs.Class, p_class).f_add_writable_namespaces = @ptrCast(p_implementation);
            }
        };

        pub const deserialize_icon = struct {
            pub fn call(p_class: anytype, p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_value: *glib.Variant) *gio.Icon {
                return gobject.ext.as(Vfs.Class, p_class).f_deserialize_icon.?(gobject.ext.as(Vfs, p_vfs), p_value);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_value: *glib.Variant) callconv(.c) *gio.Icon) void {
                gobject.ext.as(Vfs.Class, p_class).f_deserialize_icon = @ptrCast(p_implementation);
            }
        };

        /// Gets a `gio.File` for `path`.
        pub const get_file_for_path = struct {
            pub fn call(p_class: anytype, p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: [*:0]const u8) *gio.File {
                return gobject.ext.as(Vfs.Class, p_class).f_get_file_for_path.?(gobject.ext.as(Vfs, p_vfs), p_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_path: [*:0]const u8) callconv(.c) *gio.File) void {
                gobject.ext.as(Vfs.Class, p_class).f_get_file_for_path = @ptrCast(p_implementation);
            }
        };

        /// Gets a `gio.File` for `uri`.
        ///
        /// This operation never fails, but the returned object
        /// might not support any I/O operation if the URI
        /// is malformed or if the URI scheme is not supported.
        pub const get_file_for_uri = struct {
            pub fn call(p_class: anytype, p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8) *gio.File {
                return gobject.ext.as(Vfs.Class, p_class).f_get_file_for_uri.?(gobject.ext.as(Vfs, p_vfs), p_uri);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8) callconv(.c) *gio.File) void {
                gobject.ext.as(Vfs.Class, p_class).f_get_file_for_uri = @ptrCast(p_implementation);
            }
        };

        /// Gets a list of URI schemes supported by `vfs`.
        pub const get_supported_uri_schemes = struct {
            pub fn call(p_class: anytype, p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*]const [*:0]const u8 {
                return gobject.ext.as(Vfs.Class, p_class).f_get_supported_uri_schemes.?(gobject.ext.as(Vfs, p_vfs));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*]const [*:0]const u8) void {
                gobject.ext.as(Vfs.Class, p_class).f_get_supported_uri_schemes = @ptrCast(p_implementation);
            }
        };

        /// Checks if the VFS is active.
        pub const is_active = struct {
            pub fn call(p_class: anytype, p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Vfs.Class, p_class).f_is_active.?(gobject.ext.as(Vfs, p_vfs));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Vfs.Class, p_class).f_is_active = @ptrCast(p_implementation);
            }
        };

        pub const local_file_add_info = struct {
            pub fn call(p_class: anytype, p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_filename: [*:0]const u8, p_device: u64, p_attribute_matcher: *gio.FileAttributeMatcher, p_info: *gio.FileInfo, p_cancellable: ?*gio.Cancellable, p_extra_data: ?*anyopaque, p_free_extra_data: *glib.DestroyNotify) void {
                return gobject.ext.as(Vfs.Class, p_class).f_local_file_add_info.?(gobject.ext.as(Vfs, p_vfs), p_filename, p_device, p_attribute_matcher, p_info, p_cancellable, p_extra_data, p_free_extra_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_filename: [*:0]const u8, p_device: u64, p_attribute_matcher: *gio.FileAttributeMatcher, p_info: *gio.FileInfo, p_cancellable: ?*gio.Cancellable, p_extra_data: ?*anyopaque, p_free_extra_data: *glib.DestroyNotify) callconv(.c) void) void {
                gobject.ext.as(Vfs.Class, p_class).f_local_file_add_info = @ptrCast(p_implementation);
            }
        };

        pub const local_file_moved = struct {
            pub fn call(p_class: anytype, p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_source: [*:0]const u8, p_dest: [*:0]const u8) void {
                return gobject.ext.as(Vfs.Class, p_class).f_local_file_moved.?(gobject.ext.as(Vfs, p_vfs), p_source, p_dest);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_source: [*:0]const u8, p_dest: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(Vfs.Class, p_class).f_local_file_moved = @ptrCast(p_implementation);
            }
        };

        pub const local_file_removed = struct {
            pub fn call(p_class: anytype, p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_filename: [*:0]const u8) void {
                return gobject.ext.as(Vfs.Class, p_class).f_local_file_removed.?(gobject.ext.as(Vfs, p_vfs), p_filename);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_filename: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(Vfs.Class, p_class).f_local_file_removed = @ptrCast(p_implementation);
            }
        };

        pub const local_file_set_attributes = struct {
            pub fn call(p_class: anytype, p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_filename: [*:0]const u8, p_info: *gio.FileInfo, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Vfs.Class, p_class).f_local_file_set_attributes.?(gobject.ext.as(Vfs, p_vfs), p_filename, p_info, p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_filename: [*:0]const u8, p_info: *gio.FileInfo, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Vfs.Class, p_class).f_local_file_set_attributes = @ptrCast(p_implementation);
            }
        };

        /// This operation never fails, but the returned object might
        /// not support any I/O operations if the `parse_name` cannot
        /// be parsed by the `gio.Vfs` module.
        pub const parse_name = struct {
            pub fn call(p_class: anytype, p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_parse_name: [*:0]const u8) *gio.File {
                return gobject.ext.as(Vfs.Class, p_class).f_parse_name.?(gobject.ext.as(Vfs, p_vfs), p_parse_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_vfs: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_parse_name: [*:0]const u8) callconv(.c) *gio.File) void {
                gobject.ext.as(Vfs.Class, p_class).f_parse_name = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Gets the default `gio.Vfs` for the system.
    extern fn g_vfs_get_default() *gio.Vfs;
    pub const getDefault = g_vfs_get_default;

    /// Gets the local `gio.Vfs` for the system.
    extern fn g_vfs_get_local() *gio.Vfs;
    pub const getLocal = g_vfs_get_local;

    /// Gets a `gio.File` for `path`.
    extern fn g_vfs_get_file_for_path(p_vfs: *Vfs, p_path: [*:0]const u8) *gio.File;
    pub const getFileForPath = g_vfs_get_file_for_path;

    /// Gets a `gio.File` for `uri`.
    ///
    /// This operation never fails, but the returned object
    /// might not support any I/O operation if the URI
    /// is malformed or if the URI scheme is not supported.
    extern fn g_vfs_get_file_for_uri(p_vfs: *Vfs, p_uri: [*:0]const u8) *gio.File;
    pub const getFileForUri = g_vfs_get_file_for_uri;

    /// Gets a list of URI schemes supported by `vfs`.
    extern fn g_vfs_get_supported_uri_schemes(p_vfs: *Vfs) [*]const [*:0]const u8;
    pub const getSupportedUriSchemes = g_vfs_get_supported_uri_schemes;

    /// Checks if the VFS is active.
    extern fn g_vfs_is_active(p_vfs: *Vfs) c_int;
    pub const isActive = g_vfs_is_active;

    /// This operation never fails, but the returned object might
    /// not support any I/O operations if the `parse_name` cannot
    /// be parsed by the `gio.Vfs` module.
    extern fn g_vfs_parse_name(p_vfs: *Vfs, p_parse_name: [*:0]const u8) *gio.File;
    pub const parseName = g_vfs_parse_name;

    /// Registers `uri_func` and `parse_name_func` as the `gio.File` URI and parse name
    /// lookup functions for URIs with a scheme matching `scheme`.
    /// Note that `scheme` is registered only within the running application, as
    /// opposed to desktop-wide as it happens with GVfs backends.
    ///
    /// When a `gio.File` is requested with an URI containing `scheme` (e.g. through
    /// `gio.fileNewForUri`), `uri_func` will be called to allow a custom
    /// constructor. The implementation of `uri_func` should not be blocking, and
    /// must not call `gio.Vfs.registerUriScheme` or `gio.Vfs.unregisterUriScheme`.
    ///
    /// When `gio.fileParseName` is called with a parse name obtained from such file,
    /// `parse_name_func` will be called to allow the `gio.File` to be created again. In
    /// that case, it's responsibility of `parse_name_func` to make sure the parse
    /// name matches what the custom `gio.File` implementation returned when
    /// `gio.File.getParseName` was previously called. The implementation of
    /// `parse_name_func` should not be blocking, and must not call
    /// `gio.Vfs.registerUriScheme` or `gio.Vfs.unregisterUriScheme`.
    ///
    /// It's an error to call this function twice with the same scheme. To unregister
    /// a custom URI scheme, use `gio.Vfs.unregisterUriScheme`.
    extern fn g_vfs_register_uri_scheme(p_vfs: *Vfs, p_scheme: [*:0]const u8, p_uri_func: ?gio.VfsFileLookupFunc, p_uri_data: ?*anyopaque, p_uri_destroy: ?glib.DestroyNotify, p_parse_name_func: ?gio.VfsFileLookupFunc, p_parse_name_data: ?*anyopaque, p_parse_name_destroy: ?glib.DestroyNotify) c_int;
    pub const registerUriScheme = g_vfs_register_uri_scheme;

    /// Unregisters the URI handler for `scheme` previously registered with
    /// `gio.Vfs.registerUriScheme`.
    extern fn g_vfs_unregister_uri_scheme(p_vfs: *Vfs, p_scheme: [*:0]const u8) c_int;
    pub const unregisterUriScheme = g_vfs_unregister_uri_scheme;

    extern fn g_vfs_get_type() usize;
    pub const getGObjectType = g_vfs_get_type;

    extern fn g_object_ref(p_self: *gio.Vfs) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Vfs) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Vfs, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GVolumeMonitor` is for listing the user interesting devices and volumes
/// on the computer. In other words, what a file selector or file manager
/// would show in a sidebar.
///
/// `GVolumeMonitor` is not
/// thread-default-context aware (see
/// `glib.MainContext.pushThreadDefault`), and so should not be used
/// other than from the main thread, with no thread-default-context active.
///
/// In order to receive updates about volumes and mounts monitored through GVFS,
/// a main loop must be running.
pub const VolumeMonitor = extern struct {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{};
    pub const Class = gio.VolumeMonitorClass;
    f_parent_instance: gobject.Object,
    f_priv: ?*anyopaque,

    pub const virtual_methods = struct {
        pub const drive_changed = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_drive: *gio.Drive) void {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_drive_changed.?(gobject.ext.as(VolumeMonitor, p_volume_monitor), p_drive);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_drive: *gio.Drive) callconv(.c) void) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_drive_changed = @ptrCast(p_implementation);
            }
        };

        pub const drive_connected = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_drive: *gio.Drive) void {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_drive_connected.?(gobject.ext.as(VolumeMonitor, p_volume_monitor), p_drive);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_drive: *gio.Drive) callconv(.c) void) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_drive_connected = @ptrCast(p_implementation);
            }
        };

        pub const drive_disconnected = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_drive: *gio.Drive) void {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_drive_disconnected.?(gobject.ext.as(VolumeMonitor, p_volume_monitor), p_drive);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_drive: *gio.Drive) callconv(.c) void) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_drive_disconnected = @ptrCast(p_implementation);
            }
        };

        pub const drive_eject_button = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_drive: *gio.Drive) void {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_drive_eject_button.?(gobject.ext.as(VolumeMonitor, p_volume_monitor), p_drive);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_drive: *gio.Drive) callconv(.c) void) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_drive_eject_button = @ptrCast(p_implementation);
            }
        };

        pub const drive_stop_button = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_drive: *gio.Drive) void {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_drive_stop_button.?(gobject.ext.as(VolumeMonitor, p_volume_monitor), p_drive);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_drive: *gio.Drive) callconv(.c) void) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_drive_stop_button = @ptrCast(p_implementation);
            }
        };

        /// Gets a list of drives connected to the system.
        ///
        /// The returned list should be freed with `glib.List.free`, after
        /// its elements have been unreffed with `gobject.Object.unref`.
        pub const get_connected_drives = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *glib.List {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_get_connected_drives.?(gobject.ext.as(VolumeMonitor, p_volume_monitor));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *glib.List) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_get_connected_drives = @ptrCast(p_implementation);
            }
        };

        /// Finds a `gio.Mount` object by its UUID (see `gio.Mount.getUuid`)
        pub const get_mount_for_uuid = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uuid: [*:0]const u8) ?*gio.Mount {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_get_mount_for_uuid.?(gobject.ext.as(VolumeMonitor, p_volume_monitor), p_uuid);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uuid: [*:0]const u8) callconv(.c) ?*gio.Mount) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_get_mount_for_uuid = @ptrCast(p_implementation);
            }
        };

        /// Gets a list of the mounts on the system.
        ///
        /// The returned list should be freed with `glib.List.free`, after
        /// its elements have been unreffed with `gobject.Object.unref`.
        pub const get_mounts = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *glib.List {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_get_mounts.?(gobject.ext.as(VolumeMonitor, p_volume_monitor));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *glib.List) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_get_mounts = @ptrCast(p_implementation);
            }
        };

        /// Finds a `gio.Volume` object by its UUID (see `gio.Volume.getUuid`)
        pub const get_volume_for_uuid = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uuid: [*:0]const u8) ?*gio.Volume {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_get_volume_for_uuid.?(gobject.ext.as(VolumeMonitor, p_volume_monitor), p_uuid);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uuid: [*:0]const u8) callconv(.c) ?*gio.Volume) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_get_volume_for_uuid = @ptrCast(p_implementation);
            }
        };

        /// Gets a list of the volumes on the system.
        ///
        /// The returned list should be freed with `glib.List.free`, after
        /// its elements have been unreffed with `gobject.Object.unref`.
        pub const get_volumes = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *glib.List {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_get_volumes.?(gobject.ext.as(VolumeMonitor, p_volume_monitor));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *glib.List) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_get_volumes = @ptrCast(p_implementation);
            }
        };

        pub const mount_added = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_mount: *gio.Mount) void {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_mount_added.?(gobject.ext.as(VolumeMonitor, p_volume_monitor), p_mount);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_mount: *gio.Mount) callconv(.c) void) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_mount_added = @ptrCast(p_implementation);
            }
        };

        pub const mount_changed = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_mount: *gio.Mount) void {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_mount_changed.?(gobject.ext.as(VolumeMonitor, p_volume_monitor), p_mount);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_mount: *gio.Mount) callconv(.c) void) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_mount_changed = @ptrCast(p_implementation);
            }
        };

        pub const mount_pre_unmount = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_mount: *gio.Mount) void {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_mount_pre_unmount.?(gobject.ext.as(VolumeMonitor, p_volume_monitor), p_mount);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_mount: *gio.Mount) callconv(.c) void) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_mount_pre_unmount = @ptrCast(p_implementation);
            }
        };

        pub const mount_removed = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_mount: *gio.Mount) void {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_mount_removed.?(gobject.ext.as(VolumeMonitor, p_volume_monitor), p_mount);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_mount: *gio.Mount) callconv(.c) void) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_mount_removed = @ptrCast(p_implementation);
            }
        };

        pub const volume_added = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_volume: *gio.Volume) void {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_volume_added.?(gobject.ext.as(VolumeMonitor, p_volume_monitor), p_volume);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_volume: *gio.Volume) callconv(.c) void) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_volume_added = @ptrCast(p_implementation);
            }
        };

        pub const volume_changed = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_volume: *gio.Volume) void {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_volume_changed.?(gobject.ext.as(VolumeMonitor, p_volume_monitor), p_volume);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_volume: *gio.Volume) callconv(.c) void) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_volume_changed = @ptrCast(p_implementation);
            }
        };

        pub const volume_removed = struct {
            pub fn call(p_class: anytype, p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_volume: *gio.Volume) void {
                return gobject.ext.as(VolumeMonitor.Class, p_class).f_volume_removed.?(gobject.ext.as(VolumeMonitor, p_volume_monitor), p_volume);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_volume: *gio.Volume) callconv(.c) void) void {
                gobject.ext.as(VolumeMonitor.Class, p_class).f_volume_removed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// Emitted when a drive changes.
        pub const drive_changed = struct {
            pub const name = "drive-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_drive: *gio.Drive, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(VolumeMonitor, p_instance))),
                    gobject.signalLookup("drive-changed", VolumeMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when a drive is connected to the system.
        pub const drive_connected = struct {
            pub const name = "drive-connected";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_drive: *gio.Drive, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(VolumeMonitor, p_instance))),
                    gobject.signalLookup("drive-connected", VolumeMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when a drive is disconnected from the system.
        pub const drive_disconnected = struct {
            pub const name = "drive-disconnected";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_drive: *gio.Drive, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(VolumeMonitor, p_instance))),
                    gobject.signalLookup("drive-disconnected", VolumeMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the eject button is pressed on `drive`.
        pub const drive_eject_button = struct {
            pub const name = "drive-eject-button";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_drive: *gio.Drive, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(VolumeMonitor, p_instance))),
                    gobject.signalLookup("drive-eject-button", VolumeMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the stop button is pressed on `drive`.
        pub const drive_stop_button = struct {
            pub const name = "drive-stop-button";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_drive: *gio.Drive, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(VolumeMonitor, p_instance))),
                    gobject.signalLookup("drive-stop-button", VolumeMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when a mount is added.
        pub const mount_added = struct {
            pub const name = "mount-added";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_mount: *gio.Mount, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(VolumeMonitor, p_instance))),
                    gobject.signalLookup("mount-added", VolumeMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when a mount changes.
        pub const mount_changed = struct {
            pub const name = "mount-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_mount: *gio.Mount, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(VolumeMonitor, p_instance))),
                    gobject.signalLookup("mount-changed", VolumeMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// May be emitted when a mount is about to be removed.
        ///
        /// This signal depends on the backend and is only emitted if
        /// GIO was used to unmount.
        pub const mount_pre_unmount = struct {
            pub const name = "mount-pre-unmount";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_mount: *gio.Mount, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(VolumeMonitor, p_instance))),
                    gobject.signalLookup("mount-pre-unmount", VolumeMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when a mount is removed.
        pub const mount_removed = struct {
            pub const name = "mount-removed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_mount: *gio.Mount, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(VolumeMonitor, p_instance))),
                    gobject.signalLookup("mount-removed", VolumeMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when a mountable volume is added to the system.
        pub const volume_added = struct {
            pub const name = "volume-added";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_volume: *gio.Volume, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(VolumeMonitor, p_instance))),
                    gobject.signalLookup("volume-added", VolumeMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when mountable volume is changed.
        pub const volume_changed = struct {
            pub const name = "volume-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_volume: *gio.Volume, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(VolumeMonitor, p_instance))),
                    gobject.signalLookup("volume-changed", VolumeMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when a mountable volume is removed from the system.
        pub const volume_removed = struct {
            pub const name = "volume-removed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_volume: *gio.Volume, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(VolumeMonitor, p_instance))),
                    gobject.signalLookup("volume-removed", VolumeMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// This function should be called by any `gio.VolumeMonitor`
    /// implementation when a new `gio.Mount` object is created that is not
    /// associated with a `gio.Volume` object. It must be called just before
    /// emitting the `mount_added` signal.
    ///
    /// If the return value is not `NULL`, the caller must associate the
    /// returned `gio.Volume` object with the `gio.Mount`. This involves returning
    /// it in its `gio.Mount.getVolume` implementation. The caller must
    /// also listen for the "removed" signal on the returned object
    /// and give up its reference when handling that signal
    ///
    /// Similarly, if implementing `gio.VolumeMonitor.adoptOrphanMount`,
    /// the implementor must take a reference to `mount` and return it in
    /// its `gio.Volume.getMount` implemented. Also, the implementor must
    /// listen for the "unmounted" signal on `mount` and give up its
    /// reference upon handling that signal.
    ///
    /// There are two main use cases for this function.
    ///
    /// One is when implementing a user space file system driver that reads
    /// blocks of a block device that is already represented by the native
    /// volume monitor (for example a CD Audio file system driver). Such
    /// a driver will generate its own `gio.Mount` object that needs to be
    /// associated with the `gio.Volume` object that represents the volume.
    ///
    /// The other is for implementing a `gio.VolumeMonitor` whose sole purpose
    /// is to return `gio.Volume` objects representing entries in the users
    /// "favorite servers" list or similar.
    extern fn g_volume_monitor_adopt_orphan_mount(p_mount: *gio.Mount) *gio.Volume;
    pub const adoptOrphanMount = g_volume_monitor_adopt_orphan_mount;

    /// Gets the volume monitor used by gio.
    extern fn g_volume_monitor_get() *gio.VolumeMonitor;
    pub const get = g_volume_monitor_get;

    /// Gets a list of drives connected to the system.
    ///
    /// The returned list should be freed with `glib.List.free`, after
    /// its elements have been unreffed with `gobject.Object.unref`.
    extern fn g_volume_monitor_get_connected_drives(p_volume_monitor: *VolumeMonitor) *glib.List;
    pub const getConnectedDrives = g_volume_monitor_get_connected_drives;

    /// Finds a `gio.Mount` object by its UUID (see `gio.Mount.getUuid`)
    extern fn g_volume_monitor_get_mount_for_uuid(p_volume_monitor: *VolumeMonitor, p_uuid: [*:0]const u8) ?*gio.Mount;
    pub const getMountForUuid = g_volume_monitor_get_mount_for_uuid;

    /// Gets a list of the mounts on the system.
    ///
    /// The returned list should be freed with `glib.List.free`, after
    /// its elements have been unreffed with `gobject.Object.unref`.
    extern fn g_volume_monitor_get_mounts(p_volume_monitor: *VolumeMonitor) *glib.List;
    pub const getMounts = g_volume_monitor_get_mounts;

    /// Finds a `gio.Volume` object by its UUID (see `gio.Volume.getUuid`)
    extern fn g_volume_monitor_get_volume_for_uuid(p_volume_monitor: *VolumeMonitor, p_uuid: [*:0]const u8) ?*gio.Volume;
    pub const getVolumeForUuid = g_volume_monitor_get_volume_for_uuid;

    /// Gets a list of the volumes on the system.
    ///
    /// The returned list should be freed with `glib.List.free`, after
    /// its elements have been unreffed with `gobject.Object.unref`.
    extern fn g_volume_monitor_get_volumes(p_volume_monitor: *VolumeMonitor) *glib.List;
    pub const getVolumes = g_volume_monitor_get_volumes;

    extern fn g_volume_monitor_get_type() usize;
    pub const getGObjectType = g_volume_monitor_get_type;

    extern fn g_object_ref(p_self: *gio.VolumeMonitor) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.VolumeMonitor) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *VolumeMonitor, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GZlibCompressor` is an implementation of `gio.Converter` that
/// compresses data using zlib.
pub const ZlibCompressor = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.Converter};
    pub const Class = gio.ZlibCompressorClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// If set to a non-`NULL` `gio.FileInfo` object, and `gio.ZlibCompressor.properties.format` is
        /// `G_ZLIB_COMPRESSOR_FORMAT_GZIP`, the compressor will write the file name
        /// and modification time from the file info to the GZIP header.
        pub const file_info = struct {
            pub const name = "file-info";

            pub const Type = ?*gio.FileInfo;
        };

        /// The format of the compressed data.
        pub const format = struct {
            pub const name = "format";

            pub const Type = gio.ZlibCompressorFormat;
        };

        /// The level of compression from `0` (no compression) to `9` (most
        /// compression). `-1` for the default level.
        pub const level = struct {
            pub const name = "level";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.ZlibCompressor`.
    extern fn g_zlib_compressor_new(p_format: gio.ZlibCompressorFormat, p_level: c_int) *gio.ZlibCompressor;
    pub const new = g_zlib_compressor_new;

    /// Returns the `gio.ZlibCompressor.properties.file`-info property.
    extern fn g_zlib_compressor_get_file_info(p_compressor: *ZlibCompressor) ?*gio.FileInfo;
    pub const getFileInfo = g_zlib_compressor_get_file_info;

    /// Sets `file_info` in `compressor`. If non-`NULL`, and `compressor`'s
    /// `gio.ZlibCompressor.properties.format` property is `G_ZLIB_COMPRESSOR_FORMAT_GZIP`,
    /// it will be used to set the file name and modification time in
    /// the GZIP header of the compressed data.
    ///
    /// Note: it is an error to call this function while a compression is in
    /// progress; it may only be called immediately after creation of `compressor`,
    /// or after resetting it with `gio.Converter.reset`.
    extern fn g_zlib_compressor_set_file_info(p_compressor: *ZlibCompressor, p_file_info: ?*gio.FileInfo) void;
    pub const setFileInfo = g_zlib_compressor_set_file_info;

    extern fn g_zlib_compressor_get_type() usize;
    pub const getGObjectType = g_zlib_compressor_get_type;

    extern fn g_object_ref(p_self: *gio.ZlibCompressor) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.ZlibCompressor) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ZlibCompressor, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GZlibDecompressor` is an implementation of `gio.Converter` that
/// decompresses data compressed with zlib.
pub const ZlibDecompressor = opaque {
    pub const Parent = gobject.Object;
    pub const Implements = [_]type{gio.Converter};
    pub const Class = gio.ZlibDecompressorClass;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// A `gio.FileInfo` containing the information found in the GZIP header
        /// of the data stream processed, or `NULL` if the header was not yet
        /// fully processed, is not present at all, or the compressor's
        /// `gio.ZlibDecompressor.properties.format` property is not `G_ZLIB_COMPRESSOR_FORMAT_GZIP`.
        pub const file_info = struct {
            pub const name = "file-info";

            pub const Type = ?*gio.FileInfo;
        };

        /// The format of the compressed data.
        pub const format = struct {
            pub const name = "format";

            pub const Type = gio.ZlibCompressorFormat;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.ZlibDecompressor`.
    extern fn g_zlib_decompressor_new(p_format: gio.ZlibCompressorFormat) *gio.ZlibDecompressor;
    pub const new = g_zlib_decompressor_new;

    /// Retrieves the `gio.FileInfo` constructed from the GZIP header data
    /// of compressed data processed by `compressor`, or `NULL` if `decompressor`'s
    /// `gio.ZlibDecompressor.properties.format` property is not `G_ZLIB_COMPRESSOR_FORMAT_GZIP`,
    /// or the header data was not fully processed yet, or it not present in the
    /// data stream at all.
    extern fn g_zlib_decompressor_get_file_info(p_decompressor: *ZlibDecompressor) ?*gio.FileInfo;
    pub const getFileInfo = g_zlib_decompressor_get_file_info;

    extern fn g_zlib_decompressor_get_type() usize;
    pub const getGObjectType = g_zlib_decompressor_get_type;

    extern fn g_object_ref(p_self: *gio.ZlibDecompressor) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.ZlibDecompressor) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ZlibDecompressor, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GAction` represents a single named action.
///
/// The main interface to an action is that it can be activated with
/// `gio.Action.activate`. This results in the 'activate' signal being
/// emitted. An activation has a `GVariant` parameter (which may be
/// `NULL`). The correct type for the parameter is determined by a static
/// parameter type (which is given at construction time).
///
/// An action may optionally have a state, in which case the state may be
/// set with `gio.Action.changeState`. This call takes a `glib.Variant`. The
/// correct type for the state is determined by a static state type
/// (which is given at construction time).
///
/// The state may have a hint associated with it, specifying its valid
/// range.
///
/// `GAction` is merely the interface to the concept of an action, as
/// described above.  Various implementations of actions exist, including
/// `gio.SimpleAction`.
///
/// In all cases, the implementing class is responsible for storing the
/// name of the action, the parameter type, the enabled state, the optional
/// state type and the state and emitting the appropriate signals when these
/// change. The implementor is responsible for filtering calls to
/// `gio.Action.activate` and `gio.Action.changeState`
/// for type safety and for the state being enabled.
///
/// Probably the only useful thing to do with a `GAction` is to put it
/// inside of a `gio.SimpleActionGroup`.
pub const Action = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.ActionInterface;
    pub const virtual_methods = struct {
        /// Activates the action.
        ///
        /// `parameter` must be the correct type of parameter for the action (ie:
        /// the parameter type given at construction time).  If the parameter
        /// type was `NULL` then `parameter` must also be `NULL`.
        ///
        /// If the `parameter` `glib.Variant` is floating, it is consumed.
        pub const activate = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_parameter: ?*glib.Variant) void {
                return gobject.ext.as(Action.Iface, p_class).f_activate.?(gobject.ext.as(Action, p_action), p_parameter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_parameter: ?*glib.Variant) callconv(.c) void) void {
                gobject.ext.as(Action.Iface, p_class).f_activate = @ptrCast(p_implementation);
            }
        };

        /// Request for the state of `action` to be changed to `value`.
        ///
        /// The action must be stateful and `value` must be of the correct type.
        /// See `gio.Action.getStateType`.
        ///
        /// This call merely requests a change.  The action may refuse to change
        /// its state or may change its state to something other than `value`.
        /// See `gio.Action.getStateHint`.
        ///
        /// If the `value` `glib.Variant` is floating, it is consumed.
        pub const change_state = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_value: *glib.Variant) void {
                return gobject.ext.as(Action.Iface, p_class).f_change_state.?(gobject.ext.as(Action, p_action), p_value);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_value: *glib.Variant) callconv(.c) void) void {
                gobject.ext.as(Action.Iface, p_class).f_change_state = @ptrCast(p_implementation);
            }
        };

        /// Checks if `action` is currently enabled.
        ///
        /// An action must be enabled in order to be activated or in order to
        /// have its state changed from outside callers.
        pub const get_enabled = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Action.Iface, p_class).f_get_enabled.?(gobject.ext.as(Action, p_action));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Action.Iface, p_class).f_get_enabled = @ptrCast(p_implementation);
            }
        };

        /// Queries the name of `action`.
        pub const get_name = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]const u8 {
                return gobject.ext.as(Action.Iface, p_class).f_get_name.?(gobject.ext.as(Action, p_action));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]const u8) void {
                gobject.ext.as(Action.Iface, p_class).f_get_name = @ptrCast(p_implementation);
            }
        };

        /// Queries the type of the parameter that must be given when activating
        /// `action`.
        ///
        /// When activating the action using `gio.Action.activate`, the
        /// `glib.Variant` given to that function must be of the type returned by
        /// this function.
        ///
        /// In the case that this function returns `NULL`, you must not give any
        /// `glib.Variant`, but `NULL` instead.
        pub const get_parameter_type = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*const glib.VariantType {
                return gobject.ext.as(Action.Iface, p_class).f_get_parameter_type.?(gobject.ext.as(Action, p_action));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*const glib.VariantType) void {
                gobject.ext.as(Action.Iface, p_class).f_get_parameter_type = @ptrCast(p_implementation);
            }
        };

        /// Queries the current state of `action`.
        ///
        /// If the action is not stateful then `NULL` will be returned.  If the
        /// action is stateful then the type of the return value is the type
        /// given by `gio.Action.getStateType`.
        ///
        /// The return value (if non-`NULL`) should be freed with
        /// `glib.Variant.unref` when it is no longer required.
        pub const get_state = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*glib.Variant {
                return gobject.ext.as(Action.Iface, p_class).f_get_state.?(gobject.ext.as(Action, p_action));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*glib.Variant) void {
                gobject.ext.as(Action.Iface, p_class).f_get_state = @ptrCast(p_implementation);
            }
        };

        /// Requests a hint about the valid range of values for the state of
        /// `action`.
        ///
        /// If `NULL` is returned it either means that the action is not stateful
        /// or that there is no hint about the valid range of values for the
        /// state of the action.
        ///
        /// If a `glib.Variant` array is returned then each item in the array is a
        /// possible value for the state.  If a `glib.Variant` pair (ie: two-tuple) is
        /// returned then the tuple specifies the inclusive lower and upper bound
        /// of valid values for the state.
        ///
        /// In any case, the information is merely a hint.  It may be possible to
        /// have a state value outside of the hinted range and setting a value
        /// within the range may fail.
        ///
        /// The return value (if non-`NULL`) should be freed with
        /// `glib.Variant.unref` when it is no longer required.
        pub const get_state_hint = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*glib.Variant {
                return gobject.ext.as(Action.Iface, p_class).f_get_state_hint.?(gobject.ext.as(Action, p_action));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*glib.Variant) void {
                gobject.ext.as(Action.Iface, p_class).f_get_state_hint = @ptrCast(p_implementation);
            }
        };

        /// Queries the type of the state of `action`.
        ///
        /// If the action is stateful (e.g. created with
        /// `gio.SimpleAction.newStateful`) then this function returns the
        /// `glib.VariantType` of the state.  This is the type of the initial value
        /// given as the state. All calls to `gio.Action.changeState` must give a
        /// `glib.Variant` of this type and `gio.Action.getState` will return a
        /// `glib.Variant` of the same type.
        ///
        /// If the action is not stateful (e.g. created with `gio.SimpleAction.new`)
        /// then this function will return `NULL`. In that case, `gio.Action.getState`
        /// will return `NULL` and you must not call `gio.Action.changeState`.
        pub const get_state_type = struct {
            pub fn call(p_class: anytype, p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*const glib.VariantType {
                return gobject.ext.as(Action.Iface, p_class).f_get_state_type.?(gobject.ext.as(Action, p_action));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*const glib.VariantType) void {
                gobject.ext.as(Action.Iface, p_class).f_get_state_type = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// If `action` is currently enabled.
        ///
        /// If the action is disabled then calls to `gio.Action.activate` and
        /// `gio.Action.changeState` have no effect.
        pub const enabled = struct {
            pub const name = "enabled";

            pub const Type = c_int;
        };

        /// The name of the action.  This is mostly meaningful for identifying
        /// the action once it has been added to a `gio.ActionGroup`. It is immutable.
        pub const name = struct {
            pub const name = "name";

            pub const Type = ?[*:0]u8;
        };

        /// The type of the parameter that must be given when activating the
        /// action. This is immutable, and may be `NULL` if no parameter is needed when
        /// activating the action.
        pub const parameter_type = struct {
            pub const name = "parameter-type";

            pub const Type = ?*glib.VariantType;
        };

        /// The state of the action, or `NULL` if the action is stateless.
        pub const state = struct {
            pub const name = "state";

            pub const Type = ?*glib.Variant;
        };

        /// The `glib.VariantType` of the state that the action has, or `NULL` if the
        /// action is stateless. This is immutable.
        pub const state_type = struct {
            pub const name = "state-type";

            pub const Type = ?*glib.VariantType;
        };
    };

    pub const signals = struct {};

    /// Checks if `action_name` is valid.
    ///
    /// `action_name` is valid if it consists only of alphanumeric characters,
    /// plus `-` and `.`.  The empty string is not a valid action name.
    ///
    /// It is an error to call this function with a non-UTF-8 `action_name`.
    /// `action_name` must not be `NULL`.
    extern fn g_action_name_is_valid(p_action_name: [*:0]const u8) c_int;
    pub const nameIsValid = g_action_name_is_valid;

    /// Parses a detailed action name into its separate name and target
    /// components.
    ///
    /// Detailed action names can have three formats.
    ///
    /// The first format is used to represent an action name with no target
    /// value and consists of just an action name containing no whitespace
    /// nor the characters `:`, `(` or `)`.  For example: `app.action`.
    ///
    /// The second format is used to represent an action with a target value
    /// that is a non-empty string consisting only of alphanumerics, plus `-`
    /// and `.`.  In that case, the action name and target value are
    /// separated by a double colon (`::`).  For example:
    /// `app.action::target`.
    ///
    /// The third format is used to represent an action with any type of
    /// target value, including strings.  The target value follows the action
    /// name, surrounded in parens.  For example: `app.action(42)`.  The
    /// target value is parsed using `glib.Variant.parse`.  If a tuple-typed
    /// value is desired, it must be specified in the same way, resulting in
    /// two sets of parens, for example: `app.action((1,2,3))`.  A string
    /// target can be specified this way as well: `app.action('target')`.
    /// For strings, this third format must be used if target value is
    /// empty or contains characters other than alphanumerics, `-` and `.`.
    ///
    /// If this function returns `TRUE`, a non-`NULL` value is guaranteed to be returned
    /// in `action_name` (if a pointer is passed in). A `NULL` value may still be
    /// returned in `target_value`, as the `detailed_name` may not contain a target.
    ///
    /// If returned, the `glib.Variant` in `target_value` is guaranteed to not be floating.
    extern fn g_action_parse_detailed_name(p_detailed_name: [*:0]const u8, p_action_name: ?*[*:0]u8, p_target_value: ?**glib.Variant, p_error: ?*?*glib.Error) c_int;
    pub const parseDetailedName = g_action_parse_detailed_name;

    /// Formats a detailed action name from `action_name` and `target_value`.
    ///
    /// It is an error to call this function with an invalid action name.
    ///
    /// This function is the opposite of `gio.Action.parseDetailedName`.
    /// It will produce a string that can be parsed back to the `action_name`
    /// and `target_value` by that function.
    ///
    /// See that function for the types of strings that will be printed by
    /// this function.
    extern fn g_action_print_detailed_name(p_action_name: [*:0]const u8, p_target_value: ?*glib.Variant) [*:0]u8;
    pub const printDetailedName = g_action_print_detailed_name;

    /// Activates the action.
    ///
    /// `parameter` must be the correct type of parameter for the action (ie:
    /// the parameter type given at construction time).  If the parameter
    /// type was `NULL` then `parameter` must also be `NULL`.
    ///
    /// If the `parameter` `glib.Variant` is floating, it is consumed.
    extern fn g_action_activate(p_action: *Action, p_parameter: ?*glib.Variant) void;
    pub const activate = g_action_activate;

    /// Request for the state of `action` to be changed to `value`.
    ///
    /// The action must be stateful and `value` must be of the correct type.
    /// See `gio.Action.getStateType`.
    ///
    /// This call merely requests a change.  The action may refuse to change
    /// its state or may change its state to something other than `value`.
    /// See `gio.Action.getStateHint`.
    ///
    /// If the `value` `glib.Variant` is floating, it is consumed.
    extern fn g_action_change_state(p_action: *Action, p_value: *glib.Variant) void;
    pub const changeState = g_action_change_state;

    /// Checks if `action` is currently enabled.
    ///
    /// An action must be enabled in order to be activated or in order to
    /// have its state changed from outside callers.
    extern fn g_action_get_enabled(p_action: *Action) c_int;
    pub const getEnabled = g_action_get_enabled;

    /// Queries the name of `action`.
    extern fn g_action_get_name(p_action: *Action) [*:0]const u8;
    pub const getName = g_action_get_name;

    /// Queries the type of the parameter that must be given when activating
    /// `action`.
    ///
    /// When activating the action using `gio.Action.activate`, the
    /// `glib.Variant` given to that function must be of the type returned by
    /// this function.
    ///
    /// In the case that this function returns `NULL`, you must not give any
    /// `glib.Variant`, but `NULL` instead.
    extern fn g_action_get_parameter_type(p_action: *Action) ?*const glib.VariantType;
    pub const getParameterType = g_action_get_parameter_type;

    /// Queries the current state of `action`.
    ///
    /// If the action is not stateful then `NULL` will be returned.  If the
    /// action is stateful then the type of the return value is the type
    /// given by `gio.Action.getStateType`.
    ///
    /// The return value (if non-`NULL`) should be freed with
    /// `glib.Variant.unref` when it is no longer required.
    extern fn g_action_get_state(p_action: *Action) ?*glib.Variant;
    pub const getState = g_action_get_state;

    /// Requests a hint about the valid range of values for the state of
    /// `action`.
    ///
    /// If `NULL` is returned it either means that the action is not stateful
    /// or that there is no hint about the valid range of values for the
    /// state of the action.
    ///
    /// If a `glib.Variant` array is returned then each item in the array is a
    /// possible value for the state.  If a `glib.Variant` pair (ie: two-tuple) is
    /// returned then the tuple specifies the inclusive lower and upper bound
    /// of valid values for the state.
    ///
    /// In any case, the information is merely a hint.  It may be possible to
    /// have a state value outside of the hinted range and setting a value
    /// within the range may fail.
    ///
    /// The return value (if non-`NULL`) should be freed with
    /// `glib.Variant.unref` when it is no longer required.
    extern fn g_action_get_state_hint(p_action: *Action) ?*glib.Variant;
    pub const getStateHint = g_action_get_state_hint;

    /// Queries the type of the state of `action`.
    ///
    /// If the action is stateful (e.g. created with
    /// `gio.SimpleAction.newStateful`) then this function returns the
    /// `glib.VariantType` of the state.  This is the type of the initial value
    /// given as the state. All calls to `gio.Action.changeState` must give a
    /// `glib.Variant` of this type and `gio.Action.getState` will return a
    /// `glib.Variant` of the same type.
    ///
    /// If the action is not stateful (e.g. created with `gio.SimpleAction.new`)
    /// then this function will return `NULL`. In that case, `gio.Action.getState`
    /// will return `NULL` and you must not call `gio.Action.changeState`.
    extern fn g_action_get_state_type(p_action: *Action) ?*const glib.VariantType;
    pub const getStateType = g_action_get_state_type;

    extern fn g_action_get_type() usize;
    pub const getGObjectType = g_action_get_type;

    extern fn g_object_ref(p_self: *gio.Action) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Action) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Action, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GActionGroup` represents a group of actions.
///
/// Actions can be used to expose functionality in a structured way, either
/// from one part of a program to another, or to the outside world. Action
/// groups are often used together with a `gio.MenuModel` that provides additional
/// representation data for displaying the actions to the user, e.g. in a menu.
///
/// The main way to interact with the actions in a `GActionGroup` is to
/// activate them with `gio.ActionGroup.activateAction`. Activating an
/// action may require a `glib.Variant` parameter. The required type of the
/// parameter can be inquired with `gio.ActionGroup.getActionParameterType`.
/// Actions may be disabled, see `gio.ActionGroup.getActionEnabled`.
/// Activating a disabled action has no effect.
///
/// Actions may optionally have a state in the form of a `glib.Variant`. The current
/// state of an action can be inquired with `gio.ActionGroup.getActionState`.
/// Activating a stateful action may change its state, but it is also possible to
/// set the state by calling `gio.ActionGroup.changeActionState`.
///
/// As typical example, consider a text editing application which has an
/// option to change the current font to ‘bold’. A good way to represent
/// this would be a stateful action, with a boolean state. Activating the
/// action would toggle the state.
///
/// Each action in the group has a unique name (which is a string).  All
/// method calls, except `gio.ActionGroup.listActions` take the name of
/// an action as an argument.
///
/// The `GActionGroup` API is meant to be the ‘public’ API to the action
/// group. The calls here are exactly the interaction that ‘external
/// forces’ (eg: UI, incoming D-Bus messages, etc.) are supposed to have
/// with actions. ‘Internal’ APIs (ie: ones meant only to be accessed by
/// the action group implementation) are found on subclasses. This is
/// why you will find – for example – `gio.ActionGroup.getActionEnabled`
/// but not an equivalent ``set_action_enabled`` method.
///
/// Signals are emitted on the action group in response to state changes
/// on individual actions.
///
/// Implementations of `GActionGroup` should provide implementations for
/// the virtual functions `gio.ActionGroup.listActions` and
/// `gio.ActionGroup.queryAction`. The other virtual functions should
/// not be implemented — their ‘wrappers’ are actually implemented with
/// calls to `gio.ActionGroup.queryAction`.
pub const ActionGroup = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.ActionGroupInterface;
    pub const virtual_methods = struct {
        /// Emits the `gio.ActionGroup.signals.action_added` signal on `action_group`.
        ///
        /// This function should only be called by `gio.ActionGroup` implementations.
        pub const action_added = struct {
            pub fn call(p_class: anytype, p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) void {
                return gobject.ext.as(ActionGroup.Iface, p_class).f_action_added.?(gobject.ext.as(ActionGroup, p_action_group), p_action_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(ActionGroup.Iface, p_class).f_action_added = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gio.ActionGroup.signals.action_enabled_changed` signal on `action_group`.
        ///
        /// This function should only be called by `gio.ActionGroup` implementations.
        pub const action_enabled_changed = struct {
            pub fn call(p_class: anytype, p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8, p_enabled: c_int) void {
                return gobject.ext.as(ActionGroup.Iface, p_class).f_action_enabled_changed.?(gobject.ext.as(ActionGroup, p_action_group), p_action_name, p_enabled);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8, p_enabled: c_int) callconv(.c) void) void {
                gobject.ext.as(ActionGroup.Iface, p_class).f_action_enabled_changed = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gio.ActionGroup.signals.action_removed` signal on `action_group`.
        ///
        /// This function should only be called by `gio.ActionGroup` implementations.
        pub const action_removed = struct {
            pub fn call(p_class: anytype, p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) void {
                return gobject.ext.as(ActionGroup.Iface, p_class).f_action_removed.?(gobject.ext.as(ActionGroup, p_action_group), p_action_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(ActionGroup.Iface, p_class).f_action_removed = @ptrCast(p_implementation);
            }
        };

        /// Emits the `gio.ActionGroup.signals.action_state_changed` signal on `action_group`.
        ///
        /// This function should only be called by `gio.ActionGroup` implementations.
        pub const action_state_changed = struct {
            pub fn call(p_class: anytype, p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8, p_state: *glib.Variant) void {
                return gobject.ext.as(ActionGroup.Iface, p_class).f_action_state_changed.?(gobject.ext.as(ActionGroup, p_action_group), p_action_name, p_state);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8, p_state: *glib.Variant) callconv(.c) void) void {
                gobject.ext.as(ActionGroup.Iface, p_class).f_action_state_changed = @ptrCast(p_implementation);
            }
        };

        /// Activate the named action within `action_group`.
        ///
        /// If the action is expecting a parameter, then the correct type of
        /// parameter must be given as `parameter`.  If the action is expecting no
        /// parameters then `parameter` must be `NULL`.  See
        /// `gio.ActionGroup.getActionParameterType`.
        ///
        /// If the `gio.ActionGroup` implementation supports asynchronous remote
        /// activation over D-Bus, this call may return before the relevant
        /// D-Bus traffic has been sent, or any replies have been received. In
        /// order to block on such asynchronous activation calls,
        /// `gio.DBusConnection.flush` should be called prior to the code, which
        /// depends on the result of the action activation. Without flushing
        /// the D-Bus connection, there is no guarantee that the action would
        /// have been activated.
        ///
        /// The following code which runs in a remote app instance, shows an
        /// example of a ‘quit’ action being activated on the primary app
        /// instance over D-Bus. Here `gio.DBusConnection.flush` is called
        /// before ``exit``. Without ``gio.DBusConnection.flush``, the ‘quit’ action
        /// may fail to be activated on the primary instance.
        ///
        /// ```c
        /// // call ‘quit’ action on primary instance
        /// g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
        ///
        /// // make sure the action is activated now
        /// g_dbus_connection_flush (…);
        ///
        /// g_debug ("Application has been terminated. Exiting.");
        ///
        /// exit (0);
        /// ```
        pub const activate_action = struct {
            pub fn call(p_class: anytype, p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8, p_parameter: ?*glib.Variant) void {
                return gobject.ext.as(ActionGroup.Iface, p_class).f_activate_action.?(gobject.ext.as(ActionGroup, p_action_group), p_action_name, p_parameter);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8, p_parameter: ?*glib.Variant) callconv(.c) void) void {
                gobject.ext.as(ActionGroup.Iface, p_class).f_activate_action = @ptrCast(p_implementation);
            }
        };

        /// Request for the state of the named action within `action_group` to be
        /// changed to `value`.
        ///
        /// The action must be stateful and `value` must be of the correct type.
        /// See `gio.ActionGroup.getActionStateType`.
        ///
        /// This call merely requests a change.  The action may refuse to change
        /// its state or may change its state to something other than `value`.
        /// See `gio.ActionGroup.getActionStateHint`.
        ///
        /// If the `value` GVariant is floating, it is consumed.
        pub const change_action_state = struct {
            pub fn call(p_class: anytype, p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8, p_value: *glib.Variant) void {
                return gobject.ext.as(ActionGroup.Iface, p_class).f_change_action_state.?(gobject.ext.as(ActionGroup, p_action_group), p_action_name, p_value);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8, p_value: *glib.Variant) callconv(.c) void) void {
                gobject.ext.as(ActionGroup.Iface, p_class).f_change_action_state = @ptrCast(p_implementation);
            }
        };

        /// Checks if the named action within `action_group` is currently enabled.
        ///
        /// An action must be enabled in order to be activated or in order to
        /// have its state changed from outside callers.
        pub const get_action_enabled = struct {
            pub fn call(p_class: anytype, p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) c_int {
                return gobject.ext.as(ActionGroup.Iface, p_class).f_get_action_enabled.?(gobject.ext.as(ActionGroup, p_action_group), p_action_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) callconv(.c) c_int) void {
                gobject.ext.as(ActionGroup.Iface, p_class).f_get_action_enabled = @ptrCast(p_implementation);
            }
        };

        /// Queries the type of the parameter that must be given when activating
        /// the named action within `action_group`.
        ///
        /// When activating the action using `gio.ActionGroup.activateAction`,
        /// the `glib.Variant` given to that function must be of the type returned
        /// by this function.
        ///
        /// In the case that this function returns `NULL`, you must not give any
        /// `glib.Variant`, but `NULL` instead.
        ///
        /// The parameter type of a particular action will never change but it is
        /// possible for an action to be removed and for a new action to be added
        /// with the same name but a different parameter type.
        pub const get_action_parameter_type = struct {
            pub fn call(p_class: anytype, p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) ?*const glib.VariantType {
                return gobject.ext.as(ActionGroup.Iface, p_class).f_get_action_parameter_type.?(gobject.ext.as(ActionGroup, p_action_group), p_action_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) callconv(.c) ?*const glib.VariantType) void {
                gobject.ext.as(ActionGroup.Iface, p_class).f_get_action_parameter_type = @ptrCast(p_implementation);
            }
        };

        /// Queries the current state of the named action within `action_group`.
        ///
        /// If the action is not stateful then `NULL` will be returned.  If the
        /// action is stateful then the type of the return value is the type
        /// given by `gio.ActionGroup.getActionStateType`.
        ///
        /// The return value (if non-`NULL`) should be freed with
        /// `glib.Variant.unref` when it is no longer required.
        pub const get_action_state = struct {
            pub fn call(p_class: anytype, p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) ?*glib.Variant {
                return gobject.ext.as(ActionGroup.Iface, p_class).f_get_action_state.?(gobject.ext.as(ActionGroup, p_action_group), p_action_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) callconv(.c) ?*glib.Variant) void {
                gobject.ext.as(ActionGroup.Iface, p_class).f_get_action_state = @ptrCast(p_implementation);
            }
        };

        /// Requests a hint about the valid range of values for the state of the
        /// named action within `action_group`.
        ///
        /// If `NULL` is returned it either means that the action is not stateful
        /// or that there is no hint about the valid range of values for the
        /// state of the action.
        ///
        /// If a `glib.Variant` array is returned then each item in the array is a
        /// possible value for the state.  If a `glib.Variant` pair (ie: two-tuple) is
        /// returned then the tuple specifies the inclusive lower and upper bound
        /// of valid values for the state.
        ///
        /// In any case, the information is merely a hint.  It may be possible to
        /// have a state value outside of the hinted range and setting a value
        /// within the range may fail.
        ///
        /// The return value (if non-`NULL`) should be freed with
        /// `glib.Variant.unref` when it is no longer required.
        pub const get_action_state_hint = struct {
            pub fn call(p_class: anytype, p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) ?*glib.Variant {
                return gobject.ext.as(ActionGroup.Iface, p_class).f_get_action_state_hint.?(gobject.ext.as(ActionGroup, p_action_group), p_action_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) callconv(.c) ?*glib.Variant) void {
                gobject.ext.as(ActionGroup.Iface, p_class).f_get_action_state_hint = @ptrCast(p_implementation);
            }
        };

        /// Queries the type of the state of the named action within
        /// `action_group`.
        ///
        /// If the action is stateful then this function returns the
        /// `glib.VariantType` of the state.  All calls to
        /// `gio.ActionGroup.changeActionState` must give a `glib.Variant` of this
        /// type and `gio.ActionGroup.getActionState` will return a `glib.Variant`
        /// of the same type.
        ///
        /// If the action is not stateful then this function will return `NULL`.
        /// In that case, `gio.ActionGroup.getActionState` will return `NULL`
        /// and you must not call `gio.ActionGroup.changeActionState`.
        ///
        /// The state type of a particular action will never change but it is
        /// possible for an action to be removed and for a new action to be added
        /// with the same name but a different state type.
        pub const get_action_state_type = struct {
            pub fn call(p_class: anytype, p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) ?*const glib.VariantType {
                return gobject.ext.as(ActionGroup.Iface, p_class).f_get_action_state_type.?(gobject.ext.as(ActionGroup, p_action_group), p_action_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) callconv(.c) ?*const glib.VariantType) void {
                gobject.ext.as(ActionGroup.Iface, p_class).f_get_action_state_type = @ptrCast(p_implementation);
            }
        };

        /// Checks if the named action exists within `action_group`.
        pub const has_action = struct {
            pub fn call(p_class: anytype, p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) c_int {
                return gobject.ext.as(ActionGroup.Iface, p_class).f_has_action.?(gobject.ext.as(ActionGroup, p_action_group), p_action_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) callconv(.c) c_int) void {
                gobject.ext.as(ActionGroup.Iface, p_class).f_has_action = @ptrCast(p_implementation);
            }
        };

        /// Lists the actions contained within `action_group`.
        ///
        /// The caller is responsible for freeing the list with `glib.strfreev` when
        /// it is no longer required.
        pub const list_actions = struct {
            pub fn call(p_class: anytype, p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*][*:0]u8 {
                return gobject.ext.as(ActionGroup.Iface, p_class).f_list_actions.?(gobject.ext.as(ActionGroup, p_action_group));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*][*:0]u8) void {
                gobject.ext.as(ActionGroup.Iface, p_class).f_list_actions = @ptrCast(p_implementation);
            }
        };

        /// Queries all aspects of the named action within an `action_group`.
        ///
        /// This function acquires the information available from
        /// `gio.ActionGroup.hasAction`, `gio.ActionGroup.getActionEnabled`,
        /// `gio.ActionGroup.getActionParameterType`,
        /// `gio.ActionGroup.getActionStateType`,
        /// `gio.ActionGroup.getActionStateHint` and
        /// `gio.ActionGroup.getActionState` with a single function call.
        ///
        /// This provides two main benefits.
        ///
        /// The first is the improvement in efficiency that comes with not having
        /// to perform repeated lookups of the action in order to discover
        /// different things about it.  The second is that implementing
        /// `gio.ActionGroup` can now be done by only overriding this one virtual
        /// function.
        ///
        /// The interface provides a default implementation of this function that
        /// calls the individual functions, as required, to fetch the
        /// information.  The interface also provides default implementations of
        /// those functions that call this function.  All implementations,
        /// therefore, must override either this function or all of the others.
        ///
        /// If the action exists, `TRUE` is returned and any of the requested
        /// fields (as indicated by having a non-`NULL` reference passed in) are
        /// filled.  If the action doesn’t exist, `FALSE` is returned and the
        /// fields may or may not have been modified.
        pub const query_action = struct {
            pub fn call(p_class: anytype, p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8, p_enabled: *c_int, p_parameter_type: ?**const glib.VariantType, p_state_type: ?**const glib.VariantType, p_state_hint: ?**glib.Variant, p_state: ?**glib.Variant) c_int {
                return gobject.ext.as(ActionGroup.Iface, p_class).f_query_action.?(gobject.ext.as(ActionGroup, p_action_group), p_action_name, p_enabled, p_parameter_type, p_state_type, p_state_hint, p_state);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_group: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8, p_enabled: *c_int, p_parameter_type: ?**const glib.VariantType, p_state_type: ?**const glib.VariantType, p_state_hint: ?**glib.Variant, p_state: ?**glib.Variant) callconv(.c) c_int) void {
                gobject.ext.as(ActionGroup.Iface, p_class).f_query_action = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// Signals that a new action was just added to the group.
        ///
        /// This signal is emitted after the action has been added
        /// and is now visible.
        pub const action_added = struct {
            pub const name = "action-added";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_action_name: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ActionGroup, p_instance))),
                    gobject.signalLookup("action-added", ActionGroup.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Signals that the enabled status of the named action has changed.
        pub const action_enabled_changed = struct {
            pub const name = "action-enabled-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_action_name: [*:0]u8, p_enabled: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ActionGroup, p_instance))),
                    gobject.signalLookup("action-enabled-changed", ActionGroup.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Signals that an action is just about to be removed from the group.
        ///
        /// This signal is emitted before the action is removed, so the action
        /// is still visible and can be queried from the signal handler.
        pub const action_removed = struct {
            pub const name = "action-removed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_action_name: [*:0]u8, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ActionGroup, p_instance))),
                    gobject.signalLookup("action-removed", ActionGroup.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Signals that the state of the named action has changed.
        pub const action_state_changed = struct {
            pub const name = "action-state-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_action_name: [*:0]u8, p_value: *glib.Variant, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ActionGroup, p_instance))),
                    gobject.signalLookup("action-state-changed", ActionGroup.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Emits the `gio.ActionGroup.signals.action_added` signal on `action_group`.
    ///
    /// This function should only be called by `gio.ActionGroup` implementations.
    extern fn g_action_group_action_added(p_action_group: *ActionGroup, p_action_name: [*:0]const u8) void;
    pub const actionAdded = g_action_group_action_added;

    /// Emits the `gio.ActionGroup.signals.action_enabled_changed` signal on `action_group`.
    ///
    /// This function should only be called by `gio.ActionGroup` implementations.
    extern fn g_action_group_action_enabled_changed(p_action_group: *ActionGroup, p_action_name: [*:0]const u8, p_enabled: c_int) void;
    pub const actionEnabledChanged = g_action_group_action_enabled_changed;

    /// Emits the `gio.ActionGroup.signals.action_removed` signal on `action_group`.
    ///
    /// This function should only be called by `gio.ActionGroup` implementations.
    extern fn g_action_group_action_removed(p_action_group: *ActionGroup, p_action_name: [*:0]const u8) void;
    pub const actionRemoved = g_action_group_action_removed;

    /// Emits the `gio.ActionGroup.signals.action_state_changed` signal on `action_group`.
    ///
    /// This function should only be called by `gio.ActionGroup` implementations.
    extern fn g_action_group_action_state_changed(p_action_group: *ActionGroup, p_action_name: [*:0]const u8, p_state: *glib.Variant) void;
    pub const actionStateChanged = g_action_group_action_state_changed;

    /// Activate the named action within `action_group`.
    ///
    /// If the action is expecting a parameter, then the correct type of
    /// parameter must be given as `parameter`.  If the action is expecting no
    /// parameters then `parameter` must be `NULL`.  See
    /// `gio.ActionGroup.getActionParameterType`.
    ///
    /// If the `gio.ActionGroup` implementation supports asynchronous remote
    /// activation over D-Bus, this call may return before the relevant
    /// D-Bus traffic has been sent, or any replies have been received. In
    /// order to block on such asynchronous activation calls,
    /// `gio.DBusConnection.flush` should be called prior to the code, which
    /// depends on the result of the action activation. Without flushing
    /// the D-Bus connection, there is no guarantee that the action would
    /// have been activated.
    ///
    /// The following code which runs in a remote app instance, shows an
    /// example of a ‘quit’ action being activated on the primary app
    /// instance over D-Bus. Here `gio.DBusConnection.flush` is called
    /// before ``exit``. Without ``gio.DBusConnection.flush``, the ‘quit’ action
    /// may fail to be activated on the primary instance.
    ///
    /// ```c
    /// // call ‘quit’ action on primary instance
    /// g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
    ///
    /// // make sure the action is activated now
    /// g_dbus_connection_flush (…);
    ///
    /// g_debug ("Application has been terminated. Exiting.");
    ///
    /// exit (0);
    /// ```
    extern fn g_action_group_activate_action(p_action_group: *ActionGroup, p_action_name: [*:0]const u8, p_parameter: ?*glib.Variant) void;
    pub const activateAction = g_action_group_activate_action;

    /// Request for the state of the named action within `action_group` to be
    /// changed to `value`.
    ///
    /// The action must be stateful and `value` must be of the correct type.
    /// See `gio.ActionGroup.getActionStateType`.
    ///
    /// This call merely requests a change.  The action may refuse to change
    /// its state or may change its state to something other than `value`.
    /// See `gio.ActionGroup.getActionStateHint`.
    ///
    /// If the `value` GVariant is floating, it is consumed.
    extern fn g_action_group_change_action_state(p_action_group: *ActionGroup, p_action_name: [*:0]const u8, p_value: *glib.Variant) void;
    pub const changeActionState = g_action_group_change_action_state;

    /// Checks if the named action within `action_group` is currently enabled.
    ///
    /// An action must be enabled in order to be activated or in order to
    /// have its state changed from outside callers.
    extern fn g_action_group_get_action_enabled(p_action_group: *ActionGroup, p_action_name: [*:0]const u8) c_int;
    pub const getActionEnabled = g_action_group_get_action_enabled;

    /// Queries the type of the parameter that must be given when activating
    /// the named action within `action_group`.
    ///
    /// When activating the action using `gio.ActionGroup.activateAction`,
    /// the `glib.Variant` given to that function must be of the type returned
    /// by this function.
    ///
    /// In the case that this function returns `NULL`, you must not give any
    /// `glib.Variant`, but `NULL` instead.
    ///
    /// The parameter type of a particular action will never change but it is
    /// possible for an action to be removed and for a new action to be added
    /// with the same name but a different parameter type.
    extern fn g_action_group_get_action_parameter_type(p_action_group: *ActionGroup, p_action_name: [*:0]const u8) ?*const glib.VariantType;
    pub const getActionParameterType = g_action_group_get_action_parameter_type;

    /// Queries the current state of the named action within `action_group`.
    ///
    /// If the action is not stateful then `NULL` will be returned.  If the
    /// action is stateful then the type of the return value is the type
    /// given by `gio.ActionGroup.getActionStateType`.
    ///
    /// The return value (if non-`NULL`) should be freed with
    /// `glib.Variant.unref` when it is no longer required.
    extern fn g_action_group_get_action_state(p_action_group: *ActionGroup, p_action_name: [*:0]const u8) ?*glib.Variant;
    pub const getActionState = g_action_group_get_action_state;

    /// Requests a hint about the valid range of values for the state of the
    /// named action within `action_group`.
    ///
    /// If `NULL` is returned it either means that the action is not stateful
    /// or that there is no hint about the valid range of values for the
    /// state of the action.
    ///
    /// If a `glib.Variant` array is returned then each item in the array is a
    /// possible value for the state.  If a `glib.Variant` pair (ie: two-tuple) is
    /// returned then the tuple specifies the inclusive lower and upper bound
    /// of valid values for the state.
    ///
    /// In any case, the information is merely a hint.  It may be possible to
    /// have a state value outside of the hinted range and setting a value
    /// within the range may fail.
    ///
    /// The return value (if non-`NULL`) should be freed with
    /// `glib.Variant.unref` when it is no longer required.
    extern fn g_action_group_get_action_state_hint(p_action_group: *ActionGroup, p_action_name: [*:0]const u8) ?*glib.Variant;
    pub const getActionStateHint = g_action_group_get_action_state_hint;

    /// Queries the type of the state of the named action within
    /// `action_group`.
    ///
    /// If the action is stateful then this function returns the
    /// `glib.VariantType` of the state.  All calls to
    /// `gio.ActionGroup.changeActionState` must give a `glib.Variant` of this
    /// type and `gio.ActionGroup.getActionState` will return a `glib.Variant`
    /// of the same type.
    ///
    /// If the action is not stateful then this function will return `NULL`.
    /// In that case, `gio.ActionGroup.getActionState` will return `NULL`
    /// and you must not call `gio.ActionGroup.changeActionState`.
    ///
    /// The state type of a particular action will never change but it is
    /// possible for an action to be removed and for a new action to be added
    /// with the same name but a different state type.
    extern fn g_action_group_get_action_state_type(p_action_group: *ActionGroup, p_action_name: [*:0]const u8) ?*const glib.VariantType;
    pub const getActionStateType = g_action_group_get_action_state_type;

    /// Checks if the named action exists within `action_group`.
    extern fn g_action_group_has_action(p_action_group: *ActionGroup, p_action_name: [*:0]const u8) c_int;
    pub const hasAction = g_action_group_has_action;

    /// Lists the actions contained within `action_group`.
    ///
    /// The caller is responsible for freeing the list with `glib.strfreev` when
    /// it is no longer required.
    extern fn g_action_group_list_actions(p_action_group: *ActionGroup) [*][*:0]u8;
    pub const listActions = g_action_group_list_actions;

    /// Queries all aspects of the named action within an `action_group`.
    ///
    /// This function acquires the information available from
    /// `gio.ActionGroup.hasAction`, `gio.ActionGroup.getActionEnabled`,
    /// `gio.ActionGroup.getActionParameterType`,
    /// `gio.ActionGroup.getActionStateType`,
    /// `gio.ActionGroup.getActionStateHint` and
    /// `gio.ActionGroup.getActionState` with a single function call.
    ///
    /// This provides two main benefits.
    ///
    /// The first is the improvement in efficiency that comes with not having
    /// to perform repeated lookups of the action in order to discover
    /// different things about it.  The second is that implementing
    /// `gio.ActionGroup` can now be done by only overriding this one virtual
    /// function.
    ///
    /// The interface provides a default implementation of this function that
    /// calls the individual functions, as required, to fetch the
    /// information.  The interface also provides default implementations of
    /// those functions that call this function.  All implementations,
    /// therefore, must override either this function or all of the others.
    ///
    /// If the action exists, `TRUE` is returned and any of the requested
    /// fields (as indicated by having a non-`NULL` reference passed in) are
    /// filled.  If the action doesn’t exist, `FALSE` is returned and the
    /// fields may or may not have been modified.
    extern fn g_action_group_query_action(p_action_group: *ActionGroup, p_action_name: [*:0]const u8, p_enabled: *c_int, p_parameter_type: ?**const glib.VariantType, p_state_type: ?**const glib.VariantType, p_state_hint: ?**glib.Variant, p_state: ?**glib.Variant) c_int;
    pub const queryAction = g_action_group_query_action;

    extern fn g_action_group_get_type() usize;
    pub const getGObjectType = g_action_group_get_type;

    extern fn g_object_ref(p_self: *gio.ActionGroup) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.ActionGroup) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ActionGroup, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GActionMap` is an interface for action containers.
///
/// The `GActionMap` interface is implemented by `gio.ActionGroup`
/// implementations that operate by containing a number of named
/// `gio.Action` instances, such as `gio.SimpleActionGroup`.
///
/// One useful application of this interface is to map the
/// names of actions from various action groups to unique,
/// prefixed names (e.g. by prepending "app." or "win.").
/// This is the motivation for the ‘Map’ part of the interface
/// name.
pub const ActionMap = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.ActionMapInterface;
    pub const virtual_methods = struct {
        /// Adds an action to the `action_map`.
        ///
        /// If the action map already contains an action with the same name
        /// as `action` then the old action is dropped from the action map.
        ///
        /// The action map takes its own reference on `action`.
        pub const add_action = struct {
            pub fn call(p_class: anytype, p_action_map: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action: *gio.Action) void {
                return gobject.ext.as(ActionMap.Iface, p_class).f_add_action.?(gobject.ext.as(ActionMap, p_action_map), p_action);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_map: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action: *gio.Action) callconv(.c) void) void {
                gobject.ext.as(ActionMap.Iface, p_class).f_add_action = @ptrCast(p_implementation);
            }
        };

        /// Looks up the action with the name `action_name` in `action_map`.
        ///
        /// If no such action exists, returns `NULL`.
        pub const lookup_action = struct {
            pub fn call(p_class: anytype, p_action_map: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) ?*gio.Action {
                return gobject.ext.as(ActionMap.Iface, p_class).f_lookup_action.?(gobject.ext.as(ActionMap, p_action_map), p_action_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_map: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) callconv(.c) ?*gio.Action) void {
                gobject.ext.as(ActionMap.Iface, p_class).f_lookup_action = @ptrCast(p_implementation);
            }
        };

        /// Removes the named action from the action map.
        ///
        /// If no action of this name is in the map then nothing happens.
        pub const remove_action = struct {
            pub fn call(p_class: anytype, p_action_map: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) void {
                return gobject.ext.as(ActionMap.Iface, p_class).f_remove_action.?(gobject.ext.as(ActionMap, p_action_map), p_action_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_action_map: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(ActionMap.Iface, p_class).f_remove_action = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Adds an action to the `action_map`.
    ///
    /// If the action map already contains an action with the same name
    /// as `action` then the old action is dropped from the action map.
    ///
    /// The action map takes its own reference on `action`.
    extern fn g_action_map_add_action(p_action_map: *ActionMap, p_action: *gio.Action) void;
    pub const addAction = g_action_map_add_action;

    /// A convenience function for creating multiple `gio.SimpleAction`
    /// instances and adding them to a `gio.ActionMap`.
    ///
    /// Each action is constructed as per one `gio.ActionEntry`.
    ///
    /// ```c
    /// static void
    /// activate_quit (GSimpleAction *simple,
    ///                GVariant      *parameter,
    ///                gpointer       user_data)
    /// {
    ///   exit (0);
    /// }
    ///
    /// static void
    /// activate_print_string (GSimpleAction *simple,
    ///                        GVariant      *parameter,
    ///                        gpointer       user_data)
    /// {
    ///   g_print ("`s`\n", g_variant_get_string (parameter, NULL));
    /// }
    ///
    /// static GActionGroup *
    /// create_action_group (void)
    /// {
    ///   const GActionEntry entries[] = {
    ///     { "quit",         activate_quit              },
    ///     { "print-string", activate_print_string, "s" }
    ///   };
    ///   GSimpleActionGroup *group;
    ///
    ///   group = g_simple_action_group_new ();
    ///   g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);
    ///
    ///   return G_ACTION_GROUP (group);
    /// }
    /// ```
    extern fn g_action_map_add_action_entries(p_action_map: *ActionMap, p_entries: [*]const gio.ActionEntry, p_n_entries: c_int, p_user_data: ?*anyopaque) void;
    pub const addActionEntries = g_action_map_add_action_entries;

    /// Looks up the action with the name `action_name` in `action_map`.
    ///
    /// If no such action exists, returns `NULL`.
    extern fn g_action_map_lookup_action(p_action_map: *ActionMap, p_action_name: [*:0]const u8) ?*gio.Action;
    pub const lookupAction = g_action_map_lookup_action;

    /// Removes the named action from the action map.
    ///
    /// If no action of this name is in the map then nothing happens.
    extern fn g_action_map_remove_action(p_action_map: *ActionMap, p_action_name: [*:0]const u8) void;
    pub const removeAction = g_action_map_remove_action;

    /// Remove actions from a `gio.ActionMap`. This is meant as the reverse of
    /// `gio.ActionMap.addActionEntries`.
    ///
    ///
    /// ```c
    /// static const GActionEntry entries[] = {
    ///     { "quit",         activate_quit              },
    ///     { "print-string", activate_print_string, "s" }
    /// };
    ///
    /// void
    /// add_actions (GActionMap *map)
    /// {
    ///   g_action_map_add_action_entries (map, entries, G_N_ELEMENTS (entries), NULL);
    /// }
    ///
    /// void
    /// remove_actions (GActionMap *map)
    /// {
    ///   g_action_map_remove_action_entries (map, entries, G_N_ELEMENTS (entries));
    /// }
    /// ```
    extern fn g_action_map_remove_action_entries(p_action_map: *ActionMap, p_entries: [*]const gio.ActionEntry, p_n_entries: c_int) void;
    pub const removeActionEntries = g_action_map_remove_action_entries;

    extern fn g_action_map_get_type() usize;
    pub const getGObjectType = g_action_map_get_type;

    extern fn g_object_ref(p_self: *gio.ActionMap) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.ActionMap) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ActionMap, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Information about an installed application and methods to launch
/// it (with file arguments).
///
/// `GAppInfo` and `GAppLaunchContext` are used for describing and launching
/// applications installed on the system.
///
/// As of GLib 2.20, URIs will always be converted to POSIX paths
/// (using `gio.File.getPath`) when using `gio.AppInfo.launch`
/// even if the application requested an URI and not a POSIX path. For example
/// for a desktop-file based application with the following Exec key:
///
/// ```
/// Exec=totem `U`
/// ```
///
/// and a single URI, `sftp://foo/file.avi`, then
/// `/home/user/.gvfs/sftp on foo/file.avi` will be passed. This will only work
/// if a set of suitable GIO extensions (such as GVfs 2.26 compiled with FUSE
/// support), is available and operational; if this is not the case, the URI
/// will be passed unmodified to the application. Some URIs, such as `mailto:`,
/// of course cannot be mapped to a POSIX path (in GVfs there’s no FUSE mount
/// for it); such URIs will be passed unmodified to the application.
///
/// Specifically for GVfs 2.26 and later, the POSIX URI will be mapped
/// back to the GIO URI in the `gio.File` constructors (since GVfs
/// implements the GVfs extension point). As such, if the application
/// needs to examine the URI, it needs to use `gio.File.getUri`
/// or similar on `gio.File`. In other words, an application cannot
/// assume that the URI passed to e.g. `gio.File.newForCommandlineArg`
/// is equal to the result of `gio.File.getUri`. The following snippet
/// illustrates this:
///
/// ```c
/// GFile *f;
/// char *uri;
///
/// file = g_file_new_for_commandline_arg (uri_from_commandline);
///
/// uri = g_file_get_uri (file);
/// strcmp (uri, uri_from_commandline) == 0;
/// g_free (uri);
///
/// if (g_file_has_uri_scheme (file, "cdda"))
///   {
///     // do something special with uri
///   }
/// g_object_unref (file);
/// ```
///
/// This code will work when both `cdda://sr0/Track 1.wav` and
/// `/home/user/.gvfs/cdda on sr0/Track 1.wav` is passed to the
/// application. It should be noted that it’s generally not safe
/// for applications to rely on the format of a particular URIs.
/// Different launcher applications (e.g. file managers) may have
/// different ideas of what a given URI means.
pub const AppInfo = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.AppInfoIface;
    pub const virtual_methods = struct {
        /// Adds a content type to the application information to indicate the
        /// application is capable of opening files with the given content type.
        pub const add_supports_type = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(AppInfo.Iface, p_class).f_add_supports_type.?(gobject.ext.as(AppInfo, p_appinfo), p_content_type, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_add_supports_type = @ptrCast(p_implementation);
            }
        };

        /// Obtains the information whether the `gio.AppInfo` can be deleted.
        /// See `gio.AppInfo.delete`.
        pub const can_delete = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(AppInfo.Iface, p_class).f_can_delete.?(gobject.ext.as(AppInfo, p_appinfo));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_can_delete = @ptrCast(p_implementation);
            }
        };

        /// Checks if a supported content type can be removed from an application.
        pub const can_remove_supports_type = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(AppInfo.Iface, p_class).f_can_remove_supports_type.?(gobject.ext.as(AppInfo, p_appinfo));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_can_remove_supports_type = @ptrCast(p_implementation);
            }
        };

        /// Tries to delete a `gio.AppInfo`.
        ///
        /// On some platforms, there may be a difference between user-defined
        /// `gio.AppInfo`s which can be deleted, and system-wide ones which cannot.
        /// See `gio.AppInfo.canDelete`.
        pub const do_delete = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(AppInfo.Iface, p_class).f_do_delete.?(gobject.ext.as(AppInfo, p_appinfo));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_do_delete = @ptrCast(p_implementation);
            }
        };

        /// Creates a duplicate of a `gio.AppInfo`.
        pub const dup = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.AppInfo {
                return gobject.ext.as(AppInfo.Iface, p_class).f_dup.?(gobject.ext.as(AppInfo, p_appinfo));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.AppInfo) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_dup = @ptrCast(p_implementation);
            }
        };

        /// Checks if two `gio.AppInfo`s are equal.
        ///
        /// Note that the check *may not* compare each individual field, and only does
        /// an identity check. In case detecting changes in the contents is needed,
        /// program code must additionally compare relevant fields.
        pub const equal = struct {
            pub fn call(p_class: anytype, p_appinfo1: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_appinfo2: *gio.AppInfo) c_int {
                return gobject.ext.as(AppInfo.Iface, p_class).f_equal.?(gobject.ext.as(AppInfo, p_appinfo1), p_appinfo2);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo1: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_appinfo2: *gio.AppInfo) callconv(.c) c_int) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_equal = @ptrCast(p_implementation);
            }
        };

        /// Gets the commandline with which the application will be
        /// started.
        pub const get_commandline = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]const u8 {
                return gobject.ext.as(AppInfo.Iface, p_class).f_get_commandline.?(gobject.ext.as(AppInfo, p_appinfo));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]const u8) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_get_commandline = @ptrCast(p_implementation);
            }
        };

        /// Gets a human-readable description of an installed application.
        pub const get_description = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]const u8 {
                return gobject.ext.as(AppInfo.Iface, p_class).f_get_description.?(gobject.ext.as(AppInfo, p_appinfo));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]const u8) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_get_description = @ptrCast(p_implementation);
            }
        };

        /// Gets the display name of the application. The display name is often more
        /// descriptive to the user than the name itself.
        pub const get_display_name = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]const u8 {
                return gobject.ext.as(AppInfo.Iface, p_class).f_get_display_name.?(gobject.ext.as(AppInfo, p_appinfo));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]const u8) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_get_display_name = @ptrCast(p_implementation);
            }
        };

        /// Gets the executable’s name for the installed application.
        ///
        /// This is intended to be used for debugging or labelling what program is going
        /// to be run. To launch the executable, use `gio.AppInfo.launch` and related
        /// functions, rather than spawning the return value from this function.
        pub const get_executable = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]const u8 {
                return gobject.ext.as(AppInfo.Iface, p_class).f_get_executable.?(gobject.ext.as(AppInfo, p_appinfo));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]const u8) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_get_executable = @ptrCast(p_implementation);
            }
        };

        /// Gets the icon for the application.
        pub const get_icon = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*gio.Icon {
                return gobject.ext.as(AppInfo.Iface, p_class).f_get_icon.?(gobject.ext.as(AppInfo, p_appinfo));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*gio.Icon) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_get_icon = @ptrCast(p_implementation);
            }
        };

        /// Gets the ID of an application. An id is a string that identifies the
        /// application. The exact format of the id is platform dependent. For instance,
        /// on Unix this is the desktop file id from the xdg menu specification.
        ///
        /// Note that the returned ID may be `NULL`, depending on how the `appinfo` has
        /// been constructed.
        pub const get_id = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]const u8 {
                return gobject.ext.as(AppInfo.Iface, p_class).f_get_id.?(gobject.ext.as(AppInfo, p_appinfo));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]const u8) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_get_id = @ptrCast(p_implementation);
            }
        };

        /// Gets the installed name of the application.
        pub const get_name = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]const u8 {
                return gobject.ext.as(AppInfo.Iface, p_class).f_get_name.?(gobject.ext.as(AppInfo, p_appinfo));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]const u8) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_get_name = @ptrCast(p_implementation);
            }
        };

        /// Retrieves the list of content types that `app_info` claims to support.
        /// If this information is not provided by the environment, this function
        /// will return `NULL`.
        ///
        /// This function does not take in consideration associations added with
        /// `gio.AppInfo.addSupportsType`, but only those exported directly by
        /// the application.
        pub const get_supported_types = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*][*:0]const u8 {
                return gobject.ext.as(AppInfo.Iface, p_class).f_get_supported_types.?(gobject.ext.as(AppInfo, p_appinfo));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*][*:0]const u8) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_get_supported_types = @ptrCast(p_implementation);
            }
        };

        /// Launches the application. Passes `files` to the launched application
        /// as arguments, using the optional `context` to get information
        /// about the details of the launcher (like what screen it is on).
        /// On error, `error` will be set accordingly.
        ///
        /// To launch the application without arguments pass a `NULL` `files` list.
        ///
        /// Note that even if the launch is successful the application launched
        /// can fail to start if it runs into problems during startup. There is
        /// no way to detect this.
        ///
        /// Some URIs can be changed when passed through a GFile (for instance
        /// unsupported URIs with strange formats like mailto:), so if you have
        /// a textual URI you want to pass in as argument, consider using
        /// `gio.AppInfo.launchUris` instead.
        ///
        /// The launched application inherits the environment of the launching
        /// process, but it can be modified with `gio.AppLaunchContext.setenv`
        /// and `gio.AppLaunchContext.unsetenv`.
        ///
        /// On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
        /// environment variable with the path of the launched desktop file and
        /// `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
        /// process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
        /// should it be inherited by further processes. The `DISPLAY`,
        /// `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
        /// variables are also set, based on information provided in `context`.
        pub const launch = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_files: ?*glib.List, p_context: ?*gio.AppLaunchContext, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(AppInfo.Iface, p_class).f_launch.?(gobject.ext.as(AppInfo, p_appinfo), p_files, p_context, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_files: ?*glib.List, p_context: ?*gio.AppLaunchContext, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_launch = @ptrCast(p_implementation);
            }
        };

        /// Launches the application. This passes the `uris` to the launched application
        /// as arguments, using the optional `context` to get information
        /// about the details of the launcher (like what screen it is on).
        /// On error, `error` will be set accordingly. If the application only supports
        /// one URI per invocation as part of their command-line, multiple instances
        /// of the application will be spawned.
        ///
        /// To launch the application without arguments pass a `NULL` `uris` list.
        ///
        /// Note that even if the launch is successful the application launched
        /// can fail to start if it runs into problems during startup. There is
        /// no way to detect this.
        pub const launch_uris = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uris: ?*glib.List, p_context: ?*gio.AppLaunchContext, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(AppInfo.Iface, p_class).f_launch_uris.?(gobject.ext.as(AppInfo, p_appinfo), p_uris, p_context, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uris: ?*glib.List, p_context: ?*gio.AppLaunchContext, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_launch_uris = @ptrCast(p_implementation);
            }
        };

        /// Async version of `gio.AppInfo.launchUris`.
        ///
        /// The `callback` is invoked immediately after the application launch, but it
        /// waits for activation in case of D-Bus–activated applications and also provides
        /// extended error information for sandboxed applications, see notes for
        /// `gio.AppInfo.launchDefaultForUriAsync`.
        pub const launch_uris_async = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uris: ?*glib.List, p_context: ?*gio.AppLaunchContext, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(AppInfo.Iface, p_class).f_launch_uris_async.?(gobject.ext.as(AppInfo, p_appinfo), p_uris, p_context, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uris: ?*glib.List, p_context: ?*gio.AppLaunchContext, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_launch_uris_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes a `gio.AppInfo.launchUrisAsync` operation.
        pub const launch_uris_finish = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(AppInfo.Iface, p_class).f_launch_uris_finish.?(gobject.ext.as(AppInfo, p_appinfo), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_launch_uris_finish = @ptrCast(p_implementation);
            }
        };

        /// Removes a supported type from an application, if possible.
        pub const remove_supports_type = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(AppInfo.Iface, p_class).f_remove_supports_type.?(gobject.ext.as(AppInfo, p_appinfo), p_content_type, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_remove_supports_type = @ptrCast(p_implementation);
            }
        };

        /// Sets the application as the default handler for the given file extension.
        pub const set_as_default_for_extension = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_extension: [*:0]const u8, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(AppInfo.Iface, p_class).f_set_as_default_for_extension.?(gobject.ext.as(AppInfo, p_appinfo), p_extension, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_extension: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_set_as_default_for_extension = @ptrCast(p_implementation);
            }
        };

        /// Sets the application as the default handler for a given type.
        pub const set_as_default_for_type = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(AppInfo.Iface, p_class).f_set_as_default_for_type.?(gobject.ext.as(AppInfo, p_appinfo), p_content_type, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_set_as_default_for_type = @ptrCast(p_implementation);
            }
        };

        /// Sets the application as the last used application for a given type. This
        /// will make the application appear as first in the list returned by
        /// `gio.AppInfo.getRecommendedForType`, regardless of the default
        /// application for that content type.
        pub const set_as_last_used_for_type = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(AppInfo.Iface, p_class).f_set_as_last_used_for_type.?(gobject.ext.as(AppInfo, p_appinfo), p_content_type, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_set_as_last_used_for_type = @ptrCast(p_implementation);
            }
        };

        /// Checks if the application info should be shown in menus that
        /// list available applications.
        pub const should_show = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(AppInfo.Iface, p_class).f_should_show.?(gobject.ext.as(AppInfo, p_appinfo));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_should_show = @ptrCast(p_implementation);
            }
        };

        /// Checks if the application accepts files as arguments.
        pub const supports_files = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(AppInfo.Iface, p_class).f_supports_files.?(gobject.ext.as(AppInfo, p_appinfo));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_supports_files = @ptrCast(p_implementation);
            }
        };

        /// Checks if the application supports reading files and directories from URIs.
        pub const supports_uris = struct {
            pub fn call(p_class: anytype, p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(AppInfo.Iface, p_class).f_supports_uris.?(gobject.ext.as(AppInfo, p_appinfo));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_appinfo: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(AppInfo.Iface, p_class).f_supports_uris = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a new `gio.AppInfo` from the given information.
    ///
    /// Note that for `commandline`, the quoting rules of the `Exec` key of the
    /// [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
    /// are applied. For example, if the `commandline` contains
    /// percent-encoded URIs, the percent-character must be doubled in order to prevent it from
    /// being swallowed by `Exec` key unquoting. See
    /// [the specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s07.html)
    /// for exact quoting rules.
    extern fn g_app_info_create_from_commandline(p_commandline: [*:0]const u8, p_application_name: ?[*:0]const u8, p_flags: gio.AppInfoCreateFlags, p_error: ?*?*glib.Error) ?*gio.AppInfo;
    pub const createFromCommandline = g_app_info_create_from_commandline;

    /// Gets a list of all of the applications currently registered
    /// on this system.
    ///
    /// For desktop files, this includes applications that have
    /// [`NoDisplay=true`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html`key`-nodisplay)
    /// set or are excluded from display by means of
    /// [`OnlyShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html`key`-onlyshowin)
    /// or [`NotShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html`key`-notshowin).
    /// See `gio.AppInfo.shouldShow`.
    ///
    /// The returned list does not include applications which have the
    /// [`Hidden` key](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html`key`-hidden)
    /// set.
    extern fn g_app_info_get_all() *glib.List;
    pub const getAll = g_app_info_get_all;

    /// Gets a list of all `gio.AppInfo`s for a given content type,
    /// including the recommended and fallback `gio.AppInfo`s. See
    /// `gio.AppInfo.getRecommendedForType` and
    /// `gio.AppInfo.getFallbackForType`.
    extern fn g_app_info_get_all_for_type(p_content_type: [*:0]const u8) *glib.List;
    pub const getAllForType = g_app_info_get_all_for_type;

    /// Gets the default `gio.AppInfo` for a given content type.
    extern fn g_app_info_get_default_for_type(p_content_type: [*:0]const u8, p_must_support_uris: c_int) ?*gio.AppInfo;
    pub const getDefaultForType = g_app_info_get_default_for_type;

    /// Asynchronously gets the default `gio.AppInfo` for a given content
    /// type.
    extern fn g_app_info_get_default_for_type_async(p_content_type: [*:0]const u8, p_must_support_uris: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const getDefaultForTypeAsync = g_app_info_get_default_for_type_async;

    /// Finishes a default `gio.AppInfo` lookup started by
    /// `gio.AppInfo.getDefaultForTypeAsync`.
    ///
    /// If no #`gio.AppInfo` is found, then `error` will be set to
    /// `gio.@"IOErrorEnum.NOT_FOUND"`.
    extern fn g_app_info_get_default_for_type_finish(p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.AppInfo;
    pub const getDefaultForTypeFinish = g_app_info_get_default_for_type_finish;

    /// Gets the default application for handling URIs with the given URI scheme.
    ///
    /// A URI scheme is the initial part of the URI, up to but not including the `:`.
    /// For example, `http`, `ftp` or `sip`.
    extern fn g_app_info_get_default_for_uri_scheme(p_uri_scheme: [*:0]const u8) ?*gio.AppInfo;
    pub const getDefaultForUriScheme = g_app_info_get_default_for_uri_scheme;

    /// Asynchronously gets the default application for handling URIs with
    /// the given URI scheme. A URI scheme is the initial part
    /// of the URI, up to but not including the `:`, e.g. `http`,
    /// `ftp` or `sip`.
    extern fn g_app_info_get_default_for_uri_scheme_async(p_uri_scheme: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const getDefaultForUriSchemeAsync = g_app_info_get_default_for_uri_scheme_async;

    /// Finishes a default `gio.AppInfo` lookup started by
    /// `gio.AppInfo.getDefaultForUriSchemeAsync`.
    ///
    /// If no `gio.AppInfo` is found, then `error` will be set to
    /// `gio.@"IOErrorEnum.NOT_FOUND"`.
    extern fn g_app_info_get_default_for_uri_scheme_finish(p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.AppInfo;
    pub const getDefaultForUriSchemeFinish = g_app_info_get_default_for_uri_scheme_finish;

    /// Gets a list of fallback `gio.AppInfo`s for a given content type, i.e.
    /// those applications which claim to support the given content type by MIME
    /// type subclassing and not directly.
    extern fn g_app_info_get_fallback_for_type(p_content_type: [*:0]const u8) *glib.List;
    pub const getFallbackForType = g_app_info_get_fallback_for_type;

    /// Gets a list of recommended `gio.AppInfo`s for a given content type,
    /// i.e. those applications which claim to support the given content type
    /// exactly, and not by MIME type subclassing.
    ///
    /// Note that the first application of the list is the last used one, i.e.
    /// the last one for which `gio.AppInfo.setAsLastUsedForType` has
    /// been called.
    extern fn g_app_info_get_recommended_for_type(p_content_type: [*:0]const u8) *glib.List;
    pub const getRecommendedForType = g_app_info_get_recommended_for_type;

    /// Utility function that launches the default application registered to handle
    /// the specified uri. Synchronous I/O is done on the uri to detect the type of
    /// the file if required.
    ///
    /// The D-Bus–activated applications don’t have to be started if your application
    /// terminates too soon after this function. To prevent this, use
    /// `gio.AppInfo.launchDefaultForUriAsync` instead.
    extern fn g_app_info_launch_default_for_uri(p_uri: [*:0]const u8, p_context: ?*gio.AppLaunchContext, p_error: ?*?*glib.Error) c_int;
    pub const launchDefaultForUri = g_app_info_launch_default_for_uri;

    /// Async version of `gio.AppInfo.launchDefaultForUri`.
    ///
    /// This version is useful if you are interested in receiving error information
    /// in the case where the application is sandboxed and the portal may present an
    /// application chooser dialog to the user.
    ///
    /// This is also useful if you want to be sure that the D-Bus–activated
    /// applications are really started before termination and if you are interested
    /// in receiving error information from their activation.
    extern fn g_app_info_launch_default_for_uri_async(p_uri: [*:0]const u8, p_context: ?*gio.AppLaunchContext, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const launchDefaultForUriAsync = g_app_info_launch_default_for_uri_async;

    /// Finishes an asynchronous launch-default-for-uri operation.
    extern fn g_app_info_launch_default_for_uri_finish(p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const launchDefaultForUriFinish = g_app_info_launch_default_for_uri_finish;

    /// Removes all changes to the type associations done by
    /// `gio.AppInfo.setAsDefaultForType`,
    /// `gio.AppInfo.setAsDefaultForExtension`,
    /// `gio.AppInfo.addSupportsType` or
    /// `gio.AppInfo.removeSupportsType`.
    extern fn g_app_info_reset_type_associations(p_content_type: [*:0]const u8) void;
    pub const resetTypeAssociations = g_app_info_reset_type_associations;

    /// Adds a content type to the application information to indicate the
    /// application is capable of opening files with the given content type.
    extern fn g_app_info_add_supports_type(p_appinfo: *AppInfo, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const addSupportsType = g_app_info_add_supports_type;

    /// Obtains the information whether the `gio.AppInfo` can be deleted.
    /// See `gio.AppInfo.delete`.
    extern fn g_app_info_can_delete(p_appinfo: *AppInfo) c_int;
    pub const canDelete = g_app_info_can_delete;

    /// Checks if a supported content type can be removed from an application.
    extern fn g_app_info_can_remove_supports_type(p_appinfo: *AppInfo) c_int;
    pub const canRemoveSupportsType = g_app_info_can_remove_supports_type;

    /// Tries to delete a `gio.AppInfo`.
    ///
    /// On some platforms, there may be a difference between user-defined
    /// `gio.AppInfo`s which can be deleted, and system-wide ones which cannot.
    /// See `gio.AppInfo.canDelete`.
    extern fn g_app_info_delete(p_appinfo: *AppInfo) c_int;
    pub const delete = g_app_info_delete;

    /// Creates a duplicate of a `gio.AppInfo`.
    extern fn g_app_info_dup(p_appinfo: *AppInfo) *gio.AppInfo;
    pub const dup = g_app_info_dup;

    /// Checks if two `gio.AppInfo`s are equal.
    ///
    /// Note that the check *may not* compare each individual field, and only does
    /// an identity check. In case detecting changes in the contents is needed,
    /// program code must additionally compare relevant fields.
    extern fn g_app_info_equal(p_appinfo1: *AppInfo, p_appinfo2: *gio.AppInfo) c_int;
    pub const equal = g_app_info_equal;

    /// Gets the commandline with which the application will be
    /// started.
    extern fn g_app_info_get_commandline(p_appinfo: *AppInfo) ?[*:0]const u8;
    pub const getCommandline = g_app_info_get_commandline;

    /// Gets a human-readable description of an installed application.
    extern fn g_app_info_get_description(p_appinfo: *AppInfo) ?[*:0]const u8;
    pub const getDescription = g_app_info_get_description;

    /// Gets the display name of the application. The display name is often more
    /// descriptive to the user than the name itself.
    extern fn g_app_info_get_display_name(p_appinfo: *AppInfo) [*:0]const u8;
    pub const getDisplayName = g_app_info_get_display_name;

    /// Gets the executable’s name for the installed application.
    ///
    /// This is intended to be used for debugging or labelling what program is going
    /// to be run. To launch the executable, use `gio.AppInfo.launch` and related
    /// functions, rather than spawning the return value from this function.
    extern fn g_app_info_get_executable(p_appinfo: *AppInfo) [*:0]const u8;
    pub const getExecutable = g_app_info_get_executable;

    /// Gets the icon for the application.
    extern fn g_app_info_get_icon(p_appinfo: *AppInfo) ?*gio.Icon;
    pub const getIcon = g_app_info_get_icon;

    /// Gets the ID of an application. An id is a string that identifies the
    /// application. The exact format of the id is platform dependent. For instance,
    /// on Unix this is the desktop file id from the xdg menu specification.
    ///
    /// Note that the returned ID may be `NULL`, depending on how the `appinfo` has
    /// been constructed.
    extern fn g_app_info_get_id(p_appinfo: *AppInfo) ?[*:0]const u8;
    pub const getId = g_app_info_get_id;

    /// Gets the installed name of the application.
    extern fn g_app_info_get_name(p_appinfo: *AppInfo) [*:0]const u8;
    pub const getName = g_app_info_get_name;

    /// Retrieves the list of content types that `app_info` claims to support.
    /// If this information is not provided by the environment, this function
    /// will return `NULL`.
    ///
    /// This function does not take in consideration associations added with
    /// `gio.AppInfo.addSupportsType`, but only those exported directly by
    /// the application.
    extern fn g_app_info_get_supported_types(p_appinfo: *AppInfo) [*][*:0]const u8;
    pub const getSupportedTypes = g_app_info_get_supported_types;

    /// Launches the application. Passes `files` to the launched application
    /// as arguments, using the optional `context` to get information
    /// about the details of the launcher (like what screen it is on).
    /// On error, `error` will be set accordingly.
    ///
    /// To launch the application without arguments pass a `NULL` `files` list.
    ///
    /// Note that even if the launch is successful the application launched
    /// can fail to start if it runs into problems during startup. There is
    /// no way to detect this.
    ///
    /// Some URIs can be changed when passed through a GFile (for instance
    /// unsupported URIs with strange formats like mailto:), so if you have
    /// a textual URI you want to pass in as argument, consider using
    /// `gio.AppInfo.launchUris` instead.
    ///
    /// The launched application inherits the environment of the launching
    /// process, but it can be modified with `gio.AppLaunchContext.setenv`
    /// and `gio.AppLaunchContext.unsetenv`.
    ///
    /// On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
    /// environment variable with the path of the launched desktop file and
    /// `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
    /// process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
    /// should it be inherited by further processes. The `DISPLAY`,
    /// `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
    /// variables are also set, based on information provided in `context`.
    extern fn g_app_info_launch(p_appinfo: *AppInfo, p_files: ?*glib.List, p_context: ?*gio.AppLaunchContext, p_error: ?*?*glib.Error) c_int;
    pub const launch = g_app_info_launch;

    /// Launches the application. This passes the `uris` to the launched application
    /// as arguments, using the optional `context` to get information
    /// about the details of the launcher (like what screen it is on).
    /// On error, `error` will be set accordingly. If the application only supports
    /// one URI per invocation as part of their command-line, multiple instances
    /// of the application will be spawned.
    ///
    /// To launch the application without arguments pass a `NULL` `uris` list.
    ///
    /// Note that even if the launch is successful the application launched
    /// can fail to start if it runs into problems during startup. There is
    /// no way to detect this.
    extern fn g_app_info_launch_uris(p_appinfo: *AppInfo, p_uris: ?*glib.List, p_context: ?*gio.AppLaunchContext, p_error: ?*?*glib.Error) c_int;
    pub const launchUris = g_app_info_launch_uris;

    /// Async version of `gio.AppInfo.launchUris`.
    ///
    /// The `callback` is invoked immediately after the application launch, but it
    /// waits for activation in case of D-Bus–activated applications and also provides
    /// extended error information for sandboxed applications, see notes for
    /// `gio.AppInfo.launchDefaultForUriAsync`.
    extern fn g_app_info_launch_uris_async(p_appinfo: *AppInfo, p_uris: ?*glib.List, p_context: ?*gio.AppLaunchContext, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const launchUrisAsync = g_app_info_launch_uris_async;

    /// Finishes a `gio.AppInfo.launchUrisAsync` operation.
    extern fn g_app_info_launch_uris_finish(p_appinfo: *AppInfo, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const launchUrisFinish = g_app_info_launch_uris_finish;

    /// Removes a supported type from an application, if possible.
    extern fn g_app_info_remove_supports_type(p_appinfo: *AppInfo, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const removeSupportsType = g_app_info_remove_supports_type;

    /// Sets the application as the default handler for the given file extension.
    extern fn g_app_info_set_as_default_for_extension(p_appinfo: *AppInfo, p_extension: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const setAsDefaultForExtension = g_app_info_set_as_default_for_extension;

    /// Sets the application as the default handler for a given type.
    extern fn g_app_info_set_as_default_for_type(p_appinfo: *AppInfo, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const setAsDefaultForType = g_app_info_set_as_default_for_type;

    /// Sets the application as the last used application for a given type. This
    /// will make the application appear as first in the list returned by
    /// `gio.AppInfo.getRecommendedForType`, regardless of the default
    /// application for that content type.
    extern fn g_app_info_set_as_last_used_for_type(p_appinfo: *AppInfo, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
    pub const setAsLastUsedForType = g_app_info_set_as_last_used_for_type;

    /// Checks if the application info should be shown in menus that
    /// list available applications.
    extern fn g_app_info_should_show(p_appinfo: *AppInfo) c_int;
    pub const shouldShow = g_app_info_should_show;

    /// Checks if the application accepts files as arguments.
    extern fn g_app_info_supports_files(p_appinfo: *AppInfo) c_int;
    pub const supportsFiles = g_app_info_supports_files;

    /// Checks if the application supports reading files and directories from URIs.
    extern fn g_app_info_supports_uris(p_appinfo: *AppInfo) c_int;
    pub const supportsUris = g_app_info_supports_uris;

    extern fn g_app_info_get_type() usize;
    pub const getGObjectType = g_app_info_get_type;

    extern fn g_object_ref(p_self: *gio.AppInfo) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.AppInfo) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *AppInfo, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GAsyncInitable` is an interface for asynchronously initializable objects.
///
/// This is the asynchronous version of `gio.Initable`; it behaves the same
/// in all ways except that initialization is asynchronous. For more details
/// see the descriptions on `GInitable`.
///
/// A class may implement both the `GInitable` and `GAsyncInitable` interfaces.
///
/// Users of objects implementing this are not intended to use the interface
/// method directly; instead it will be used automatically in various ways.
/// For C applications you generally just call `gio.AsyncInitable.newAsync`
/// directly, or indirectly via a `foo_thing_new_async` wrapper. This will call
/// `gio.AsyncInitable.initAsync` under the covers, calling back with `NULL`
/// and a set `GError` on failure.
///
/// A typical implementation might look something like this:
///
/// ```c
/// enum {
///    NOT_INITIALIZED,
///    INITIALIZING,
///    INITIALIZED
/// };
///
/// static void
/// _foo_ready_cb (Foo *self)
/// {
///   GList *l;
///
///   self->priv->state = INITIALIZED;
///
///   for (l = self->priv->init_results; l != NULL; l = l->next)
///     {
///       GTask *task = l->data;
///
///       if (self->priv->success)
///         g_task_return_boolean (task, TRUE);
///       else
///         g_task_return_new_error (task, ...);
///       g_object_unref (task);
///     }
///
///   g_list_free (self->priv->init_results);
///   self->priv->init_results = NULL;
/// }
///
/// static void
/// foo_init_async (GAsyncInitable       *initable,
///                 int                   io_priority,
///                 GCancellable         *cancellable,
///                 GAsyncReadyCallback   callback,
///                 gpointer              user_data)
/// {
///   Foo *self = FOO (initable);
///   GTask *task;
///
///   task = g_task_new (initable, cancellable, callback, user_data);
///   g_task_set_name (task, G_STRFUNC);
///
///   switch (self->priv->state)
///     {
///       case NOT_INITIALIZED:
///         _foo_get_ready (self);
///         self->priv->init_results = g_list_append (self->priv->init_results,
///                                                   task);
///         self->priv->state = INITIALIZING;
///         break;
///       case INITIALIZING:
///         self->priv->init_results = g_list_append (self->priv->init_results,
///                                                   task);
///         break;
///       case INITIALIZED:
///         if (!self->priv->success)
///           g_task_return_new_error (task, ...);
///         else
///           g_task_return_boolean (task, TRUE);
///         g_object_unref (task);
///         break;
///     }
/// }
///
/// static gboolean
/// foo_init_finish (GAsyncInitable       *initable,
///                  GAsyncResult         *result,
///                  GError              **error)
/// {
///   g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);
///
///   return g_task_propagate_boolean (G_TASK (result), error);
/// }
///
/// static void
/// foo_async_initable_iface_init (gpointer g_iface,
///                                gpointer data)
/// {
///   GAsyncInitableIface *iface = g_iface;
///
///   iface->init_async = foo_init_async;
///   iface->init_finish = foo_init_finish;
/// }
/// ```
pub const AsyncInitable = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.AsyncInitableIface;
    pub const virtual_methods = struct {
        /// Starts asynchronous initialization of the object implementing the
        /// interface. This must be done before any real use of the object after
        /// initial construction. If the object also implements `gio.Initable` you can
        /// optionally call `gio.Initable.init` instead.
        ///
        /// This method is intended for language bindings. If writing in C,
        /// `gio.AsyncInitable.newAsync` should typically be used instead.
        ///
        /// When the initialization is finished, `callback` will be called. You can
        /// then call `gio.AsyncInitable.initFinish` to get the result of the
        /// initialization.
        ///
        /// Implementations may also support cancellation. If `cancellable` is not
        /// `NULL`, then initialization can be cancelled by triggering the cancellable
        /// object from another thread. If the operation was cancelled, the error
        /// `G_IO_ERROR_CANCELLED` will be returned. If `cancellable` is not `NULL`, and
        /// the object doesn't support cancellable initialization, the error
        /// `G_IO_ERROR_NOT_SUPPORTED` will be returned.
        ///
        /// As with `gio.Initable`, if the object is not initialized, or initialization
        /// returns with an error, then all operations on the object except
        /// `gobject.Object.ref` and `gobject.Object.unref` are considered to be invalid, and
        /// have undefined behaviour. They will often fail with `g_critical` or
        /// `g_warning`, but this must not be relied on.
        ///
        /// Callers should not assume that a class which implements `gio.AsyncInitable` can
        /// be initialized multiple times; for more information, see `gio.Initable.init`.
        /// If a class explicitly supports being initialized multiple times,
        /// implementation requires yielding all subsequent calls to `init_async` on the
        /// results of the first call.
        ///
        /// For classes that also support the `gio.Initable` interface, the default
        /// implementation of this method will run the `gio.Initable.init` function
        /// in a thread, so if you want to support asynchronous initialization via
        /// threads, just implement the `gio.AsyncInitable` interface without overriding
        /// any interface methods.
        pub const init_async = struct {
            pub fn call(p_class: anytype, p_initable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(AsyncInitable.Iface, p_class).f_init_async.?(gobject.ext.as(AsyncInitable, p_initable), p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_initable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(AsyncInitable.Iface, p_class).f_init_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes asynchronous initialization and returns the result.
        /// See `gio.AsyncInitable.initAsync`.
        pub const init_finish = struct {
            pub fn call(p_class: anytype, p_initable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(AsyncInitable.Iface, p_class).f_init_finish.?(gobject.ext.as(AsyncInitable, p_initable), p_res, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_initable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(AsyncInitable.Iface, p_class).f_init_finish = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Helper function for constructing `gio.AsyncInitable` object. This is
    /// similar to `gobject.Object.new` but also initializes the object asynchronously.
    ///
    /// When the initialization is finished, `callback` will be called. You can
    /// then call `gio.AsyncInitable.newFinish` to get the new object and check
    /// for any errors.
    extern fn g_async_initable_new_async(p_object_type: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque, p_first_property_name: ?[*:0]const u8, ...) void;
    pub const newAsync = g_async_initable_new_async;

    /// Helper function for constructing `gio.AsyncInitable` object. This is
    /// similar to `gobject.Object.newValist` but also initializes the object
    /// asynchronously.
    ///
    /// When the initialization is finished, `callback` will be called. You can
    /// then call `gio.AsyncInitable.newFinish` to get the new object and check
    /// for any errors.
    extern fn g_async_initable_new_valist_async(p_object_type: usize, p_first_property_name: [*:0]const u8, p_var_args: std.builtin.VaList, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const newValistAsync = g_async_initable_new_valist_async;

    /// Helper function for constructing `gio.AsyncInitable` object. This is
    /// similar to `gobject.Object.newv` but also initializes the object asynchronously.
    ///
    /// When the initialization is finished, `callback` will be called. You can
    /// then call `gio.AsyncInitable.newFinish` to get the new object and check
    /// for any errors.
    extern fn g_async_initable_newv_async(p_object_type: usize, p_n_parameters: c_uint, p_parameters: *gobject.Parameter, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const newvAsync = g_async_initable_newv_async;

    /// Starts asynchronous initialization of the object implementing the
    /// interface. This must be done before any real use of the object after
    /// initial construction. If the object also implements `gio.Initable` you can
    /// optionally call `gio.Initable.init` instead.
    ///
    /// This method is intended for language bindings. If writing in C,
    /// `gio.AsyncInitable.newAsync` should typically be used instead.
    ///
    /// When the initialization is finished, `callback` will be called. You can
    /// then call `gio.AsyncInitable.initFinish` to get the result of the
    /// initialization.
    ///
    /// Implementations may also support cancellation. If `cancellable` is not
    /// `NULL`, then initialization can be cancelled by triggering the cancellable
    /// object from another thread. If the operation was cancelled, the error
    /// `G_IO_ERROR_CANCELLED` will be returned. If `cancellable` is not `NULL`, and
    /// the object doesn't support cancellable initialization, the error
    /// `G_IO_ERROR_NOT_SUPPORTED` will be returned.
    ///
    /// As with `gio.Initable`, if the object is not initialized, or initialization
    /// returns with an error, then all operations on the object except
    /// `gobject.Object.ref` and `gobject.Object.unref` are considered to be invalid, and
    /// have undefined behaviour. They will often fail with `g_critical` or
    /// `g_warning`, but this must not be relied on.
    ///
    /// Callers should not assume that a class which implements `gio.AsyncInitable` can
    /// be initialized multiple times; for more information, see `gio.Initable.init`.
    /// If a class explicitly supports being initialized multiple times,
    /// implementation requires yielding all subsequent calls to `init_async` on the
    /// results of the first call.
    ///
    /// For classes that also support the `gio.Initable` interface, the default
    /// implementation of this method will run the `gio.Initable.init` function
    /// in a thread, so if you want to support asynchronous initialization via
    /// threads, just implement the `gio.AsyncInitable` interface without overriding
    /// any interface methods.
    extern fn g_async_initable_init_async(p_initable: *AsyncInitable, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const initAsync = g_async_initable_init_async;

    /// Finishes asynchronous initialization and returns the result.
    /// See `gio.AsyncInitable.initAsync`.
    extern fn g_async_initable_init_finish(p_initable: *AsyncInitable, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const initFinish = g_async_initable_init_finish;

    /// Finishes the async construction for the various g_async_initable_new
    /// calls, returning the created object or `NULL` on error.
    extern fn g_async_initable_new_finish(p_initable: *AsyncInitable, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gobject.Object;
    pub const newFinish = g_async_initable_new_finish;

    extern fn g_async_initable_get_type() usize;
    pub const getGObjectType = g_async_initable_get_type;

    extern fn g_object_ref(p_self: *gio.AsyncInitable) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.AsyncInitable) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *AsyncInitable, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GAsyncResult` provides a base class for implementing asynchronous function results.
///
/// Asynchronous operations are broken up into two separate operations
/// which are chained together by a `GAsyncReadyCallback`. To begin
/// an asynchronous operation, provide a `GAsyncReadyCallback` to the
/// asynchronous function. This callback will be triggered when the
/// operation has completed, and must be run in a later iteration of
/// the thread-default main context (see
/// `glib.MainContext.pushThreadDefault`) from where the operation was
/// initiated. It will be passed a `GAsyncResult` instance filled with the
/// details of the operation's success or failure, the object the asynchronous
/// function was started for and any error codes returned. The asynchronous
/// callback function is then expected to call the corresponding ``_finish``
/// function, passing the object the function was called for, the
/// `GAsyncResult` instance, and (optionally) an `error` to grab any
/// error conditions that may have occurred.
///
/// The ``_finish`` function for an operation takes the generic result
/// (of type `GAsyncResult`) and returns the specific result that the
/// operation in question yields (e.g. a `gio.FileEnumerator` for a
/// "enumerate children" operation). If the result or error status of the
/// operation is not needed, there is no need to call the ``_finish``
/// function; GIO will take care of cleaning up the result and error
/// information after the `GAsyncReadyCallback` returns. You can pass
/// `NULL` for the `GAsyncReadyCallback` if you don't need to take any
/// action at all after the operation completes. Applications may also
/// take a reference to the `GAsyncResult` and call ``_finish`` later;
/// however, the ``_finish`` function may be called at most once.
///
/// Example of a typical asynchronous operation flow:
///
/// ```c
/// void _theoretical_frobnitz_async (Theoretical         *t,
///                                   GCancellable        *c,
///                                   GAsyncReadyCallback  cb,
///                                   gpointer             u);
///
/// gboolean _theoretical_frobnitz_finish (Theoretical   *t,
///                                        GAsyncResult  *res,
///                                        GError       **e);
///
/// static void
/// frobnitz_result_func (GObject      *source_object,
///          GAsyncResult *res,
///          gpointer      user_data)
/// {
///   gboolean success = FALSE;
///
///   success = _theoretical_frobnitz_finish (source_object, res, NULL);
///
///   if (success)
///     g_printf ("Hurray!\n");
///   else
///     g_printf ("Uh oh!\n");
///
///   ...
///
/// }
///
/// int main (int argc, void *argv[])
/// {
///    ...
///
///    _theoretical_frobnitz_async (theoretical_data,
///                                 NULL,
///                                 frobnitz_result_func,
///                                 NULL);
///
///    ...
/// }
/// ```
///
/// The callback for an asynchronous operation is called only once, and is
/// always called, even in the case of a cancelled operation. On cancellation
/// the result is a `G_IO_ERROR_CANCELLED` error.
///
/// ## I/O Priority
///
/// Many I/O-related asynchronous operations have a priority parameter,
/// which is used in certain cases to determine the order in which
/// operations are executed. They are not used to determine system-wide
/// I/O scheduling. Priorities are integers, with lower numbers indicating
/// higher priority. It is recommended to choose priorities between
/// `G_PRIORITY_LOW` and `G_PRIORITY_HIGH`, with `G_PRIORITY_DEFAULT`
/// as a default.
pub const AsyncResult = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.AsyncResultIface;
    pub const virtual_methods = struct {
        /// Gets the source object from a `gio.AsyncResult`.
        pub const get_source_object = struct {
            pub fn call(p_class: anytype, p_res: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*gobject.Object {
                return gobject.ext.as(AsyncResult.Iface, p_class).f_get_source_object.?(gobject.ext.as(AsyncResult, p_res));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_res: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*gobject.Object) void {
                gobject.ext.as(AsyncResult.Iface, p_class).f_get_source_object = @ptrCast(p_implementation);
            }
        };

        /// Gets the user data from a `gio.AsyncResult`.
        pub const get_user_data = struct {
            pub fn call(p_class: anytype, p_res: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*anyopaque {
                return gobject.ext.as(AsyncResult.Iface, p_class).f_get_user_data.?(gobject.ext.as(AsyncResult, p_res));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_res: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*anyopaque) void {
                gobject.ext.as(AsyncResult.Iface, p_class).f_get_user_data = @ptrCast(p_implementation);
            }
        };

        /// Checks if `res` has the given `source_tag` (generally a function
        /// pointer indicating the function `res` was created by).
        pub const is_tagged = struct {
            pub fn call(p_class: anytype, p_res: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_source_tag: ?*anyopaque) c_int {
                return gobject.ext.as(AsyncResult.Iface, p_class).f_is_tagged.?(gobject.ext.as(AsyncResult, p_res), p_source_tag);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_res: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_source_tag: ?*anyopaque) callconv(.c) c_int) void {
                gobject.ext.as(AsyncResult.Iface, p_class).f_is_tagged = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Gets the source object from a `gio.AsyncResult`.
    extern fn g_async_result_get_source_object(p_res: *AsyncResult) ?*gobject.Object;
    pub const getSourceObject = g_async_result_get_source_object;

    /// Gets the user data from a `gio.AsyncResult`.
    extern fn g_async_result_get_user_data(p_res: *AsyncResult) ?*anyopaque;
    pub const getUserData = g_async_result_get_user_data;

    /// Checks if `res` has the given `source_tag` (generally a function
    /// pointer indicating the function `res` was created by).
    extern fn g_async_result_is_tagged(p_res: *AsyncResult, p_source_tag: ?*anyopaque) c_int;
    pub const isTagged = g_async_result_is_tagged;

    /// If `res` is a `gio.SimpleAsyncResult`, this is equivalent to
    /// `gio.SimpleAsyncResult.propagateError`. Otherwise it returns
    /// `FALSE`.
    ///
    /// This can be used for legacy error handling in async `*`_finish``
    /// wrapper functions that traditionally handled `gio.SimpleAsyncResult`
    /// error returns themselves rather than calling into the virtual method.
    /// This should not be used in new code; `gio.AsyncResult` errors that are
    /// set by virtual methods should also be extracted by virtual methods,
    /// to enable subclasses to chain up correctly.
    extern fn g_async_result_legacy_propagate_error(p_res: *AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const legacyPropagateError = g_async_result_legacy_propagate_error;

    extern fn g_async_result_get_type() usize;
    pub const getGObjectType = g_async_result_get_type;

    extern fn g_object_ref(p_self: *gio.AsyncResult) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.AsyncResult) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *AsyncResult, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GConverter` is an interface for streaming conversions.
///
/// `GConverter` is implemented by objects that convert
/// binary data in various ways. The conversion can be
/// stateful and may fail at any place.
///
/// Some example conversions are: character set conversion,
/// compression, decompression and regular expression
/// replace.
pub const Converter = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.ConverterIface;
    pub const virtual_methods = struct {
        /// This is the main operation used when converting data. It is to be called
        /// multiple times in a loop, and each time it will do some work, i.e.
        /// producing some output (in `outbuf`) or consuming some input (from `inbuf`) or
        /// both. If its not possible to do any work an error is returned.
        ///
        /// Note that a single call may not consume all input (or any input at all).
        /// Also a call may produce output even if given no input, due to state stored
        /// in the converter producing output.
        ///
        /// If any data was either produced or consumed, and then an error happens, then
        /// only the successful conversion is reported and the error is returned on the
        /// next call.
        ///
        /// A full conversion loop involves calling this method repeatedly, each time
        /// giving it new input and space output space. When there is no more input
        /// data after the data in `inbuf`, the flag `G_CONVERTER_INPUT_AT_END` must be set.
        /// The loop will be (unless some error happens) returning `G_CONVERTER_CONVERTED`
        /// each time until all data is consumed and all output is produced, then
        /// `G_CONVERTER_FINISHED` is returned instead. Note, that `G_CONVERTER_FINISHED`
        /// may be returned even if `G_CONVERTER_INPUT_AT_END` is not set, for instance
        /// in a decompression converter where the end of data is detectable from the
        /// data (and there might even be other data after the end of the compressed data).
        ///
        /// When some data has successfully been converted `bytes_read` and is set to
        /// the number of bytes read from `inbuf`, and `bytes_written` is set to indicate
        /// how many bytes was written to `outbuf`. If there are more data to output
        /// or consume (i.e. unless the `G_CONVERTER_INPUT_AT_END` is specified) then
        /// `G_CONVERTER_CONVERTED` is returned, and if no more data is to be output
        /// then `G_CONVERTER_FINISHED` is returned.
        ///
        /// On error `G_CONVERTER_ERROR` is returned and `error` is set accordingly.
        /// Some errors need special handling:
        ///
        /// `G_IO_ERROR_NO_SPACE` is returned if there is not enough space
        /// to write the resulting converted data, the application should
        /// call the function again with a larger `outbuf` to continue.
        ///
        /// `G_IO_ERROR_PARTIAL_INPUT` is returned if there is not enough
        /// input to fully determine what the conversion should produce,
        /// and the `G_CONVERTER_INPUT_AT_END` flag is not set. This happens for
        /// example with an incomplete multibyte sequence when converting text,
        /// or when a regexp matches up to the end of the input (and may match
        /// further input). It may also happen when `inbuf_size` is zero and
        /// there is no more data to produce.
        ///
        /// When this happens the application should read more input and then
        /// call the function again. If further input shows that there is no
        /// more data call the function again with the same data but with
        /// the `G_CONVERTER_INPUT_AT_END` flag set. This may cause the conversion
        /// to finish as e.g. in the regexp match case (or, to fail again with
        /// `G_IO_ERROR_PARTIAL_INPUT` in e.g. a charset conversion where the
        /// input is actually partial).
        ///
        /// After `gio.Converter.convert` has returned `G_CONVERTER_FINISHED` the
        /// converter object is in an invalid state where its not allowed
        /// to call `gio.Converter.convert` anymore. At this time you can only
        /// free the object or call `gio.Converter.reset` to reset it to the
        /// initial state.
        ///
        /// If the flag `G_CONVERTER_FLUSH` is set then conversion is modified
        /// to try to write out all internal state to the output. The application
        /// has to call the function multiple times with the flag set, and when
        /// the available input has been consumed and all internal state has
        /// been produced then `G_CONVERTER_FLUSHED` (or `G_CONVERTER_FINISHED` if
        /// really at the end) is returned instead of `G_CONVERTER_CONVERTED`.
        /// This is somewhat similar to what happens at the end of the input stream,
        /// but done in the middle of the data.
        ///
        /// This has different meanings for different conversions. For instance
        /// in a compression converter it would mean that we flush all the
        /// compression state into output such that if you uncompress the
        /// compressed data you get back all the input data. Doing this may
        /// make the final file larger due to padding though. Another example
        /// is a regexp conversion, where if you at the end of the flushed data
        /// have a match, but there is also a potential longer match. In the
        /// non-flushed case we would ask for more input, but when flushing we
        /// treat this as the end of input and do the match.
        ///
        /// Flushing is not always possible (like if a charset converter flushes
        /// at a partial multibyte sequence). Converters are supposed to try
        /// to produce as much output as possible and then return an error
        /// (typically `G_IO_ERROR_PARTIAL_INPUT`).
        pub const convert = struct {
            pub fn call(p_class: anytype, p_converter: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_inbuf: ?[*]u8, p_inbuf_size: usize, p_outbuf: [*]u8, p_outbuf_size: usize, p_flags: gio.ConverterFlags, p_bytes_read: *usize, p_bytes_written: *usize, p_error: ?*?*glib.Error) gio.ConverterResult {
                return gobject.ext.as(Converter.Iface, p_class).f_convert.?(gobject.ext.as(Converter, p_converter), p_inbuf, p_inbuf_size, p_outbuf, p_outbuf_size, p_flags, p_bytes_read, p_bytes_written, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_converter: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_inbuf: ?[*]u8, p_inbuf_size: usize, p_outbuf: [*]u8, p_outbuf_size: usize, p_flags: gio.ConverterFlags, p_bytes_read: *usize, p_bytes_written: *usize, p_error: ?*?*glib.Error) callconv(.c) gio.ConverterResult) void {
                gobject.ext.as(Converter.Iface, p_class).f_convert = @ptrCast(p_implementation);
            }
        };

        /// Resets all internal state in the converter, making it behave
        /// as if it was just created. If the converter has any internal
        /// state that would produce output then that output is lost.
        pub const reset = struct {
            pub fn call(p_class: anytype, p_converter: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Converter.Iface, p_class).f_reset.?(gobject.ext.as(Converter, p_converter));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_converter: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Converter.Iface, p_class).f_reset = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// This is the main operation used when converting data. It is to be called
    /// multiple times in a loop, and each time it will do some work, i.e.
    /// producing some output (in `outbuf`) or consuming some input (from `inbuf`) or
    /// both. If its not possible to do any work an error is returned.
    ///
    /// Note that a single call may not consume all input (or any input at all).
    /// Also a call may produce output even if given no input, due to state stored
    /// in the converter producing output.
    ///
    /// If any data was either produced or consumed, and then an error happens, then
    /// only the successful conversion is reported and the error is returned on the
    /// next call.
    ///
    /// A full conversion loop involves calling this method repeatedly, each time
    /// giving it new input and space output space. When there is no more input
    /// data after the data in `inbuf`, the flag `G_CONVERTER_INPUT_AT_END` must be set.
    /// The loop will be (unless some error happens) returning `G_CONVERTER_CONVERTED`
    /// each time until all data is consumed and all output is produced, then
    /// `G_CONVERTER_FINISHED` is returned instead. Note, that `G_CONVERTER_FINISHED`
    /// may be returned even if `G_CONVERTER_INPUT_AT_END` is not set, for instance
    /// in a decompression converter where the end of data is detectable from the
    /// data (and there might even be other data after the end of the compressed data).
    ///
    /// When some data has successfully been converted `bytes_read` and is set to
    /// the number of bytes read from `inbuf`, and `bytes_written` is set to indicate
    /// how many bytes was written to `outbuf`. If there are more data to output
    /// or consume (i.e. unless the `G_CONVERTER_INPUT_AT_END` is specified) then
    /// `G_CONVERTER_CONVERTED` is returned, and if no more data is to be output
    /// then `G_CONVERTER_FINISHED` is returned.
    ///
    /// On error `G_CONVERTER_ERROR` is returned and `error` is set accordingly.
    /// Some errors need special handling:
    ///
    /// `G_IO_ERROR_NO_SPACE` is returned if there is not enough space
    /// to write the resulting converted data, the application should
    /// call the function again with a larger `outbuf` to continue.
    ///
    /// `G_IO_ERROR_PARTIAL_INPUT` is returned if there is not enough
    /// input to fully determine what the conversion should produce,
    /// and the `G_CONVERTER_INPUT_AT_END` flag is not set. This happens for
    /// example with an incomplete multibyte sequence when converting text,
    /// or when a regexp matches up to the end of the input (and may match
    /// further input). It may also happen when `inbuf_size` is zero and
    /// there is no more data to produce.
    ///
    /// When this happens the application should read more input and then
    /// call the function again. If further input shows that there is no
    /// more data call the function again with the same data but with
    /// the `G_CONVERTER_INPUT_AT_END` flag set. This may cause the conversion
    /// to finish as e.g. in the regexp match case (or, to fail again with
    /// `G_IO_ERROR_PARTIAL_INPUT` in e.g. a charset conversion where the
    /// input is actually partial).
    ///
    /// After `gio.Converter.convert` has returned `G_CONVERTER_FINISHED` the
    /// converter object is in an invalid state where its not allowed
    /// to call `gio.Converter.convert` anymore. At this time you can only
    /// free the object or call `gio.Converter.reset` to reset it to the
    /// initial state.
    ///
    /// If the flag `G_CONVERTER_FLUSH` is set then conversion is modified
    /// to try to write out all internal state to the output. The application
    /// has to call the function multiple times with the flag set, and when
    /// the available input has been consumed and all internal state has
    /// been produced then `G_CONVERTER_FLUSHED` (or `G_CONVERTER_FINISHED` if
    /// really at the end) is returned instead of `G_CONVERTER_CONVERTED`.
    /// This is somewhat similar to what happens at the end of the input stream,
    /// but done in the middle of the data.
    ///
    /// This has different meanings for different conversions. For instance
    /// in a compression converter it would mean that we flush all the
    /// compression state into output such that if you uncompress the
    /// compressed data you get back all the input data. Doing this may
    /// make the final file larger due to padding though. Another example
    /// is a regexp conversion, where if you at the end of the flushed data
    /// have a match, but there is also a potential longer match. In the
    /// non-flushed case we would ask for more input, but when flushing we
    /// treat this as the end of input and do the match.
    ///
    /// Flushing is not always possible (like if a charset converter flushes
    /// at a partial multibyte sequence). Converters are supposed to try
    /// to produce as much output as possible and then return an error
    /// (typically `G_IO_ERROR_PARTIAL_INPUT`).
    extern fn g_converter_convert(p_converter: *Converter, p_inbuf: [*]u8, p_inbuf_size: usize, p_outbuf: [*]u8, p_outbuf_size: usize, p_flags: gio.ConverterFlags, p_bytes_read: *usize, p_bytes_written: *usize, p_error: ?*?*glib.Error) gio.ConverterResult;
    pub const convert = g_converter_convert;

    /// Applies `converter` to the data in `bytes`.
    extern fn g_converter_convert_bytes(p_converter: *Converter, p_bytes: *glib.Bytes, p_error: ?*?*glib.Error) ?*glib.Bytes;
    pub const convertBytes = g_converter_convert_bytes;

    /// Resets all internal state in the converter, making it behave
    /// as if it was just created. If the converter has any internal
    /// state that would produce output then that output is lost.
    extern fn g_converter_reset(p_converter: *Converter) void;
    pub const reset = g_converter_reset;

    extern fn g_converter_get_type() usize;
    pub const getGObjectType = g_converter_get_type;

    extern fn g_object_ref(p_self: *gio.Converter) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Converter) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Converter, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Base type for D-Bus interfaces.
///
/// The `GDBusInterface` type is the base type for D-Bus interfaces both
/// on the service side (see `gio.DBusInterfaceSkeleton`) and client side
/// (see `gio.DBusProxy`).
pub const DBusInterface = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.DBusInterfaceIface;
    pub const virtual_methods = struct {
        /// Gets the `gio.DBusObject` that `interface_` belongs to, if any.
        pub const dup_object = struct {
            pub fn call(p_class: anytype, p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*gio.DBusObject {
                return gobject.ext.as(DBusInterface.Iface, p_class).f_dup_object.?(gobject.ext.as(DBusInterface, p_interface_));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*gio.DBusObject) void {
                gobject.ext.as(DBusInterface.Iface, p_class).f_dup_object = @ptrCast(p_implementation);
            }
        };

        /// Gets D-Bus introspection information for the D-Bus interface
        /// implemented by `interface_`.
        pub const get_info = struct {
            pub fn call(p_class: anytype, p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.DBusInterfaceInfo {
                return gobject.ext.as(DBusInterface.Iface, p_class).f_get_info.?(gobject.ext.as(DBusInterface, p_interface_));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.DBusInterfaceInfo) void {
                gobject.ext.as(DBusInterface.Iface, p_class).f_get_info = @ptrCast(p_implementation);
            }
        };

        /// Gets the `gio.DBusObject` that `interface_` belongs to, if any.
        ///
        /// It is not safe to use the returned object if `interface_` or
        /// the returned object is being used from other threads. See
        /// `gio.DBusInterface.dupObject` for a thread-safe alternative.
        pub const get_object = struct {
            pub fn call(p_class: anytype, p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*gio.DBusObject {
                return gobject.ext.as(DBusInterface.Iface, p_class).f_get_object.?(gobject.ext.as(DBusInterface, p_interface_));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*gio.DBusObject) void {
                gobject.ext.as(DBusInterface.Iface, p_class).f_get_object = @ptrCast(p_implementation);
            }
        };

        /// Sets the `gio.DBusObject` for `interface_` to `object`.
        ///
        /// Note that `interface_` will hold a weak reference to `object`.
        pub const set_object = struct {
            pub fn call(p_class: anytype, p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object: ?*gio.DBusObject) void {
                return gobject.ext.as(DBusInterface.Iface, p_class).f_set_object.?(gobject.ext.as(DBusInterface, p_interface_), p_object);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_interface_: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object: ?*gio.DBusObject) callconv(.c) void) void {
                gobject.ext.as(DBusInterface.Iface, p_class).f_set_object = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Gets the `gio.DBusObject` that `interface_` belongs to, if any.
    extern fn g_dbus_interface_dup_object(p_interface_: *DBusInterface) ?*gio.DBusObject;
    pub const dupObject = g_dbus_interface_dup_object;

    /// Gets D-Bus introspection information for the D-Bus interface
    /// implemented by `interface_`.
    extern fn g_dbus_interface_get_info(p_interface_: *DBusInterface) *gio.DBusInterfaceInfo;
    pub const getInfo = g_dbus_interface_get_info;

    /// Gets the `gio.DBusObject` that `interface_` belongs to, if any.
    ///
    /// It is not safe to use the returned object if `interface_` or
    /// the returned object is being used from other threads. See
    /// `gio.DBusInterface.dupObject` for a thread-safe alternative.
    extern fn g_dbus_interface_get_object(p_interface_: *DBusInterface) ?*gio.DBusObject;
    pub const getObject = g_dbus_interface_get_object;

    /// Sets the `gio.DBusObject` for `interface_` to `object`.
    ///
    /// Note that `interface_` will hold a weak reference to `object`.
    extern fn g_dbus_interface_set_object(p_interface_: *DBusInterface, p_object: ?*gio.DBusObject) void;
    pub const setObject = g_dbus_interface_set_object;

    extern fn g_dbus_interface_get_type() usize;
    pub const getGObjectType = g_dbus_interface_get_type;

    extern fn g_object_ref(p_self: *gio.DBusInterface) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusInterface) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `GDBusObject` type is the base type for D-Bus objects on both
/// the service side (see `gio.DBusObjectSkeleton`) and the client side
/// (see `gio.DBusObjectProxy`). It is essentially just a container of
/// interfaces.
pub const DBusObject = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.DBusObjectIface;
    pub const virtual_methods = struct {
        /// Gets the D-Bus interface with name `interface_name` associated with
        /// `object`, if any.
        pub const get_interface = struct {
            pub fn call(p_class: anytype, p_object: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_interface_name: [*:0]const u8) ?*gio.DBusInterface {
                return gobject.ext.as(DBusObject.Iface, p_class).f_get_interface.?(gobject.ext.as(DBusObject, p_object), p_interface_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_object: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_interface_name: [*:0]const u8) callconv(.c) ?*gio.DBusInterface) void {
                gobject.ext.as(DBusObject.Iface, p_class).f_get_interface = @ptrCast(p_implementation);
            }
        };

        /// Gets the D-Bus interfaces associated with `object`.
        pub const get_interfaces = struct {
            pub fn call(p_class: anytype, p_object: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *glib.List {
                return gobject.ext.as(DBusObject.Iface, p_class).f_get_interfaces.?(gobject.ext.as(DBusObject, p_object));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_object: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *glib.List) void {
                gobject.ext.as(DBusObject.Iface, p_class).f_get_interfaces = @ptrCast(p_implementation);
            }
        };

        /// Gets the object path for `object`.
        pub const get_object_path = struct {
            pub fn call(p_class: anytype, p_object: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]const u8 {
                return gobject.ext.as(DBusObject.Iface, p_class).f_get_object_path.?(gobject.ext.as(DBusObject, p_object));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_object: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]const u8) void {
                gobject.ext.as(DBusObject.Iface, p_class).f_get_object_path = @ptrCast(p_implementation);
            }
        };

        /// Signal handler for the `gio.DBusObject.signals.interface`-added signal.
        pub const interface_added = struct {
            pub fn call(p_class: anytype, p_object: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_interface_: *gio.DBusInterface) void {
                return gobject.ext.as(DBusObject.Iface, p_class).f_interface_added.?(gobject.ext.as(DBusObject, p_object), p_interface_);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_object: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_interface_: *gio.DBusInterface) callconv(.c) void) void {
                gobject.ext.as(DBusObject.Iface, p_class).f_interface_added = @ptrCast(p_implementation);
            }
        };

        /// Signal handler for the `gio.DBusObject.signals.interface`-removed signal.
        pub const interface_removed = struct {
            pub fn call(p_class: anytype, p_object: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_interface_: *gio.DBusInterface) void {
                return gobject.ext.as(DBusObject.Iface, p_class).f_interface_removed.?(gobject.ext.as(DBusObject, p_object), p_interface_);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_object: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_interface_: *gio.DBusInterface) callconv(.c) void) void {
                gobject.ext.as(DBusObject.Iface, p_class).f_interface_removed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// Emitted when `interface` is added to `object`.
        pub const interface_added = struct {
            pub const name = "interface-added";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_interface: *gio.DBusInterface, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusObject, p_instance))),
                    gobject.signalLookup("interface-added", DBusObject.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when `interface` is removed from `object`.
        pub const interface_removed = struct {
            pub const name = "interface-removed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_interface: *gio.DBusInterface, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusObject, p_instance))),
                    gobject.signalLookup("interface-removed", DBusObject.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Gets the D-Bus interface with name `interface_name` associated with
    /// `object`, if any.
    extern fn g_dbus_object_get_interface(p_object: *DBusObject, p_interface_name: [*:0]const u8) ?*gio.DBusInterface;
    pub const getInterface = g_dbus_object_get_interface;

    /// Gets the D-Bus interfaces associated with `object`.
    extern fn g_dbus_object_get_interfaces(p_object: *DBusObject) *glib.List;
    pub const getInterfaces = g_dbus_object_get_interfaces;

    /// Gets the object path for `object`.
    extern fn g_dbus_object_get_object_path(p_object: *DBusObject) [*:0]const u8;
    pub const getObjectPath = g_dbus_object_get_object_path;

    extern fn g_dbus_object_get_type() usize;
    pub const getGObjectType = g_dbus_object_get_type;

    extern fn g_object_ref(p_self: *gio.DBusObject) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusObject) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusObject, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `GDBusObjectManager` type is the base type for service- and
/// client-side implementations of the standardized
/// [`org.freedesktop.DBus.ObjectManager`](http://dbus.freedesktop.org/doc/dbus-specification.html`standard`-interfaces-objectmanager)
/// interface.
///
/// See `gio.DBusObjectManagerClient` for the client-side implementation
/// and `gio.DBusObjectManagerServer` for the service-side implementation.
pub const DBusObjectManager = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.DBusObjectManagerIface;
    pub const virtual_methods = struct {
        /// Gets the interface proxy for `interface_name` at `object_path`, if
        /// any.
        pub const get_interface = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8) ?*gio.DBusInterface {
                return gobject.ext.as(DBusObjectManager.Iface, p_class).f_get_interface.?(gobject.ext.as(DBusObjectManager, p_manager), p_object_path, p_interface_name);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8) callconv(.c) ?*gio.DBusInterface) void {
                gobject.ext.as(DBusObjectManager.Iface, p_class).f_get_interface = @ptrCast(p_implementation);
            }
        };

        /// Gets the `gio.DBusObject` at `object_path`, if any.
        pub const get_object = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object_path: [*:0]const u8) ?*gio.DBusObject {
                return gobject.ext.as(DBusObjectManager.Iface, p_class).f_get_object.?(gobject.ext.as(DBusObjectManager, p_manager), p_object_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object_path: [*:0]const u8) callconv(.c) ?*gio.DBusObject) void {
                gobject.ext.as(DBusObjectManager.Iface, p_class).f_get_object = @ptrCast(p_implementation);
            }
        };

        /// Gets the object path that `manager` is for.
        pub const get_object_path = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]const u8 {
                return gobject.ext.as(DBusObjectManager.Iface, p_class).f_get_object_path.?(gobject.ext.as(DBusObjectManager, p_manager));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]const u8) void {
                gobject.ext.as(DBusObjectManager.Iface, p_class).f_get_object_path = @ptrCast(p_implementation);
            }
        };

        /// Gets all `gio.DBusObject` objects known to `manager`.
        pub const get_objects = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *glib.List {
                return gobject.ext.as(DBusObjectManager.Iface, p_class).f_get_objects.?(gobject.ext.as(DBusObjectManager, p_manager));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *glib.List) void {
                gobject.ext.as(DBusObjectManager.Iface, p_class).f_get_objects = @ptrCast(p_implementation);
            }
        };

        /// Signal handler for the `gio.DBusObjectManager.signals.interface`-added signal.
        pub const interface_added = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object: *gio.DBusObject, p_interface_: *gio.DBusInterface) void {
                return gobject.ext.as(DBusObjectManager.Iface, p_class).f_interface_added.?(gobject.ext.as(DBusObjectManager, p_manager), p_object, p_interface_);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object: *gio.DBusObject, p_interface_: *gio.DBusInterface) callconv(.c) void) void {
                gobject.ext.as(DBusObjectManager.Iface, p_class).f_interface_added = @ptrCast(p_implementation);
            }
        };

        /// Signal handler for the `gio.DBusObjectManager.signals.interface`-removed signal.
        pub const interface_removed = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object: *gio.DBusObject, p_interface_: *gio.DBusInterface) void {
                return gobject.ext.as(DBusObjectManager.Iface, p_class).f_interface_removed.?(gobject.ext.as(DBusObjectManager, p_manager), p_object, p_interface_);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object: *gio.DBusObject, p_interface_: *gio.DBusInterface) callconv(.c) void) void {
                gobject.ext.as(DBusObjectManager.Iface, p_class).f_interface_removed = @ptrCast(p_implementation);
            }
        };

        /// Signal handler for the `gio.DBusObjectManager.signals.object`-added signal.
        pub const object_added = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object: *gio.DBusObject) void {
                return gobject.ext.as(DBusObjectManager.Iface, p_class).f_object_added.?(gobject.ext.as(DBusObjectManager, p_manager), p_object);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object: *gio.DBusObject) callconv(.c) void) void {
                gobject.ext.as(DBusObjectManager.Iface, p_class).f_object_added = @ptrCast(p_implementation);
            }
        };

        /// Signal handler for the `gio.DBusObjectManager.signals.object`-removed signal.
        pub const object_removed = struct {
            pub fn call(p_class: anytype, p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object: *gio.DBusObject) void {
                return gobject.ext.as(DBusObjectManager.Iface, p_class).f_object_removed.?(gobject.ext.as(DBusObjectManager, p_manager), p_object);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_manager: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_object: *gio.DBusObject) callconv(.c) void) void {
                gobject.ext.as(DBusObjectManager.Iface, p_class).f_object_removed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// Emitted when `interface` is added to `object`.
        ///
        /// This signal exists purely as a convenience to avoid having to
        /// connect signals to all objects managed by `manager`.
        pub const interface_added = struct {
            pub const name = "interface-added";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: *gio.DBusObject, p_interface: *gio.DBusInterface, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusObjectManager, p_instance))),
                    gobject.signalLookup("interface-added", DBusObjectManager.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when `interface` has been removed from `object`.
        ///
        /// This signal exists purely as a convenience to avoid having to
        /// connect signals to all objects managed by `manager`.
        pub const interface_removed = struct {
            pub const name = "interface-removed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: *gio.DBusObject, p_interface: *gio.DBusInterface, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusObjectManager, p_instance))),
                    gobject.signalLookup("interface-removed", DBusObjectManager.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when `object` is added to `manager`.
        pub const object_added = struct {
            pub const name = "object-added";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: *gio.DBusObject, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusObjectManager, p_instance))),
                    gobject.signalLookup("object-added", DBusObjectManager.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when `object` is removed from `manager`.
        pub const object_removed = struct {
            pub const name = "object-removed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_object: *gio.DBusObject, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DBusObjectManager, p_instance))),
                    gobject.signalLookup("object-removed", DBusObjectManager.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Gets the interface proxy for `interface_name` at `object_path`, if
    /// any.
    extern fn g_dbus_object_manager_get_interface(p_manager: *DBusObjectManager, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8) ?*gio.DBusInterface;
    pub const getInterface = g_dbus_object_manager_get_interface;

    /// Gets the `gio.DBusObject` at `object_path`, if any.
    extern fn g_dbus_object_manager_get_object(p_manager: *DBusObjectManager, p_object_path: [*:0]const u8) ?*gio.DBusObject;
    pub const getObject = g_dbus_object_manager_get_object;

    /// Gets the object path that `manager` is for.
    extern fn g_dbus_object_manager_get_object_path(p_manager: *DBusObjectManager) [*:0]const u8;
    pub const getObjectPath = g_dbus_object_manager_get_object_path;

    /// Gets all `gio.DBusObject` objects known to `manager`.
    extern fn g_dbus_object_manager_get_objects(p_manager: *DBusObjectManager) *glib.List;
    pub const getObjects = g_dbus_object_manager_get_objects;

    extern fn g_dbus_object_manager_get_type() usize;
    pub const getGObjectType = g_dbus_object_manager_get_type;

    extern fn g_object_ref(p_self: *gio.DBusObjectManager) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DBusObjectManager) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DBusObjectManager, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Interface for socket-like objects with datagram semantics.
///
/// A `GDatagramBased` is a networking interface for representing datagram-based
/// communications. It is a more or less direct mapping of the core parts of the
/// BSD socket API in a portable GObject interface. It is implemented by
/// `gio.Socket`, which wraps the UNIX socket API on UNIX and winsock2 on Windows.
///
/// `GDatagramBased` is entirely platform independent, and is intended to be used
/// alongside higher-level networking APIs such as `gio.IOStream`.
///
/// It uses vectored scatter/gather I/O by default, allowing for many messages
/// to be sent or received in a single call. Where possible, implementations of
/// the interface should take advantage of vectored I/O to minimise processing
/// or system calls. For example, `GSocket` uses ``recvmmsg`` and ``sendmmsg``
/// where possible. Callers should take advantage of scatter/gather I/O (the use of
/// multiple buffers per message) to avoid unnecessary copying of data to
/// assemble or disassemble a message.
///
/// Each `GDatagramBased` operation has a timeout parameter which may be negative
/// for blocking behaviour, zero for non-blocking behaviour, or positive for
/// timeout behaviour. A blocking operation blocks until finished or there is an
/// error. A non-blocking operation will return immediately with a
/// `G_IO_ERROR_WOULD_BLOCK` error if it cannot make progress. A timeout operation
/// will block until the operation is complete or the timeout expires; if the
/// timeout expires it will return what progress it made, or
/// `G_IO_ERROR_TIMED_OUT` if no progress was made. To know when a call would
/// successfully run you can call `gio.DatagramBased.conditionCheck` or
/// `gio.DatagramBased.conditionWait`. You can also use
/// `gio.DatagramBased.createSource` and attach it to a `glib.MainContext`
/// to get callbacks when I/O is possible.
///
/// When running a non-blocking operation applications should always be able to
/// handle getting a `G_IO_ERROR_WOULD_BLOCK` error even when some other function
/// said that I/O was possible. This can easily happen in case of a race
/// condition in the application, but it can also happen for other reasons. For
/// instance, on Windows a socket is always seen as writable until a write
/// returns `G_IO_ERROR_WOULD_BLOCK`.
///
/// As with `GSocket`, `GDatagramBased`s can be either connection oriented (for
/// example, SCTP) or connectionless (for example, UDP). `GDatagramBased`s must be
/// datagram-based, not stream-based. The interface does not cover connection
/// establishment — use methods on the underlying type to establish a connection
/// before sending and receiving data through the `GDatagramBased` API. For
/// connectionless socket types the target/source address is specified or
/// received in each I/O operation.
///
/// Like most other APIs in GLib, `GDatagramBased` is not inherently thread safe.
/// To use a `GDatagramBased` concurrently from multiple threads, you must
/// implement your own locking.
pub const DatagramBased = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.DatagramBasedInterface;
    pub const virtual_methods = struct {
        /// Checks on the readiness of `datagram_based` to perform operations. The
        /// operations specified in `condition` are checked for and masked against the
        /// currently-satisfied conditions on `datagram_based`. The result is returned.
        ///
        /// `G_IO_IN` will be set in the return value if data is available to read with
        /// `gio.DatagramBased.receiveMessages`, or if the connection is closed remotely
        /// (EOS); and if the datagram_based has not been closed locally using some
        /// implementation-specific method (such as `gio.Socket.close` or
        /// `gio.Socket.shutdown` with `shutdown_read` set, if it’s a `gio.Socket`).
        ///
        /// If the connection is shut down or closed (by calling `gio.Socket.close` or
        /// `gio.Socket.shutdown` with `shutdown_read` set, if it’s a `gio.Socket`, for
        /// example), all calls to this function will return `G_IO_ERROR_CLOSED`.
        ///
        /// `G_IO_OUT` will be set if it is expected that at least one byte can be sent
        /// using `gio.DatagramBased.sendMessages` without blocking. It will not be set
        /// if the datagram_based has been closed locally.
        ///
        /// `G_IO_HUP` will be set if the connection has been closed locally.
        ///
        /// `G_IO_ERR` will be set if there was an asynchronous error in transmitting data
        /// previously enqueued using `gio.DatagramBased.sendMessages`.
        ///
        /// Note that on Windows, it is possible for an operation to return
        /// `G_IO_ERROR_WOULD_BLOCK` even immediately after
        /// `gio.DatagramBased.conditionCheck` has claimed that the `gio.DatagramBased` is
        /// ready for writing. Rather than calling `gio.DatagramBased.conditionCheck` and
        /// then writing to the `gio.DatagramBased` if it succeeds, it is generally better to
        /// simply try writing right away, and try again later if the initial attempt
        /// returns `G_IO_ERROR_WOULD_BLOCK`.
        ///
        /// It is meaningless to specify `G_IO_ERR` or `G_IO_HUP` in `condition`; these
        /// conditions will always be set in the output if they are true. Apart from
        /// these flags, the output is guaranteed to be masked by `condition`.
        ///
        /// This call never blocks.
        pub const condition_check = struct {
            pub fn call(p_class: anytype, p_datagram_based: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_condition: glib.IOCondition) glib.IOCondition {
                return gobject.ext.as(DatagramBased.Iface, p_class).f_condition_check.?(gobject.ext.as(DatagramBased, p_datagram_based), p_condition);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_datagram_based: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_condition: glib.IOCondition) callconv(.c) glib.IOCondition) void {
                gobject.ext.as(DatagramBased.Iface, p_class).f_condition_check = @ptrCast(p_implementation);
            }
        };

        /// Waits for up to `timeout` microseconds for condition to become true on
        /// `datagram_based`. If the condition is met, `TRUE` is returned.
        ///
        /// If `cancellable` is cancelled before the condition is met, or if `timeout` is
        /// reached before the condition is met, then `FALSE` is returned and `error` is
        /// set appropriately (`G_IO_ERROR_CANCELLED` or `G_IO_ERROR_TIMED_OUT`).
        pub const condition_wait = struct {
            pub fn call(p_class: anytype, p_datagram_based: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_condition: glib.IOCondition, p_timeout: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(DatagramBased.Iface, p_class).f_condition_wait.?(gobject.ext.as(DatagramBased, p_datagram_based), p_condition, p_timeout, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_datagram_based: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_condition: glib.IOCondition, p_timeout: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(DatagramBased.Iface, p_class).f_condition_wait = @ptrCast(p_implementation);
            }
        };

        /// Creates a `glib.Source` that can be attached to a `glib.MainContext` to monitor for
        /// the availability of the specified `condition` on the `gio.DatagramBased`. The
        /// `glib.Source` keeps a reference to the `datagram_based`.
        ///
        /// The callback on the source is of the `gio.DatagramBasedSourceFunc` type.
        ///
        /// It is meaningless to specify `G_IO_ERR` or `G_IO_HUP` in `condition`; these
        /// conditions will always be reported in the callback if they are true.
        ///
        /// If non-`NULL`, `cancellable` can be used to cancel the source, which will
        /// cause the source to trigger, reporting the current condition (which is
        /// likely 0 unless cancellation happened at the same time as a condition
        /// change). You can check for this in the callback using
        /// `gio.Cancellable.isCancelled`.
        pub const create_source = struct {
            pub fn call(p_class: anytype, p_datagram_based: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_condition: glib.IOCondition, p_cancellable: ?*gio.Cancellable) *glib.Source {
                return gobject.ext.as(DatagramBased.Iface, p_class).f_create_source.?(gobject.ext.as(DatagramBased, p_datagram_based), p_condition, p_cancellable);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_datagram_based: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_condition: glib.IOCondition, p_cancellable: ?*gio.Cancellable) callconv(.c) *glib.Source) void {
                gobject.ext.as(DatagramBased.Iface, p_class).f_create_source = @ptrCast(p_implementation);
            }
        };

        /// Receive one or more data messages from `datagram_based` in one go.
        ///
        /// `messages` must point to an array of `gio.InputMessage` structs and
        /// `num_messages` must be the length of this array. Each `gio.InputMessage`
        /// contains a pointer to an array of `gio.InputVector` structs describing the
        /// buffers that the data received in each message will be written to.
        ///
        /// `flags` modify how all messages are received. The commonly available
        /// arguments for this are available in the `gio.SocketMsgFlags` enum, but the
        /// values there are the same as the system values, and the flags
        /// are passed in as-is, so you can pass in system-specific flags too. These
        /// flags affect the overall receive operation. Flags affecting individual
        /// messages are returned in `gio.InputMessage.flags`.
        ///
        /// The other members of `gio.InputMessage` are treated as described in its
        /// documentation.
        ///
        /// If `timeout` is negative the call will block until `num_messages` have been
        /// received, the connection is closed remotely (EOS), `cancellable` is cancelled,
        /// or an error occurs.
        ///
        /// If `timeout` is 0 the call will return up to `num_messages` without blocking,
        /// or `G_IO_ERROR_WOULD_BLOCK` if no messages are queued in the operating system
        /// to be received.
        ///
        /// If `timeout` is positive the call will block on the same conditions as if
        /// `timeout` were negative. If the timeout is reached
        /// before any messages are received, `G_IO_ERROR_TIMED_OUT` is returned,
        /// otherwise it will return the number of messages received before timing out.
        /// (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
        /// `recvmmsg`.)
        ///
        /// To be notified when messages are available, wait for the `G_IO_IN` condition.
        /// Note though that you may still receive `G_IO_ERROR_WOULD_BLOCK` from
        /// `gio.DatagramBased.receiveMessages` even if you were previously notified of a
        /// `G_IO_IN` condition.
        ///
        /// If the remote peer closes the connection, any messages queued in the
        /// underlying receive buffer will be returned, and subsequent calls to
        /// `gio.DatagramBased.receiveMessages` will return 0 (with no error set).
        ///
        /// If the connection is shut down or closed (by calling `gio.Socket.close` or
        /// `gio.Socket.shutdown` with `shutdown_read` set, if it’s a `gio.Socket`, for
        /// example), all calls to this function will return `G_IO_ERROR_CLOSED`.
        ///
        /// On error -1 is returned and `error` is set accordingly. An error will only
        /// be returned if zero messages could be received; otherwise the number of
        /// messages successfully received before the error will be returned. If
        /// `cancellable` is cancelled, `G_IO_ERROR_CANCELLED` is returned as with any
        /// other error.
        pub const receive_messages = struct {
            pub fn call(p_class: anytype, p_datagram_based: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_messages: [*]gio.InputMessage, p_num_messages: c_uint, p_flags: c_int, p_timeout: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(DatagramBased.Iface, p_class).f_receive_messages.?(gobject.ext.as(DatagramBased, p_datagram_based), p_messages, p_num_messages, p_flags, p_timeout, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_datagram_based: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_messages: [*]gio.InputMessage, p_num_messages: c_uint, p_flags: c_int, p_timeout: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(DatagramBased.Iface, p_class).f_receive_messages = @ptrCast(p_implementation);
            }
        };

        /// Send one or more data messages from `datagram_based` in one go.
        ///
        /// `messages` must point to an array of `gio.OutputMessage` structs and
        /// `num_messages` must be the length of this array. Each `gio.OutputMessage`
        /// contains an address to send the data to, and a pointer to an array of
        /// `gio.OutputVector` structs to describe the buffers that the data to be sent
        /// for each message will be gathered from.
        ///
        /// `flags` modify how the message is sent. The commonly available arguments
        /// for this are available in the `gio.SocketMsgFlags` enum, but the
        /// values there are the same as the system values, and the flags
        /// are passed in as-is, so you can pass in system-specific flags too.
        ///
        /// The other members of `gio.OutputMessage` are treated as described in its
        /// documentation.
        ///
        /// If `timeout` is negative the call will block until `num_messages` have been
        /// sent, `cancellable` is cancelled, or an error occurs.
        ///
        /// If `timeout` is 0 the call will send up to `num_messages` without blocking,
        /// or will return `G_IO_ERROR_WOULD_BLOCK` if there is no space to send messages.
        ///
        /// If `timeout` is positive the call will block on the same conditions as if
        /// `timeout` were negative. If the timeout is reached before any messages are
        /// sent, `G_IO_ERROR_TIMED_OUT` is returned, otherwise it will return the number
        /// of messages sent before timing out.
        ///
        /// To be notified when messages can be sent, wait for the `G_IO_OUT` condition.
        /// Note though that you may still receive `G_IO_ERROR_WOULD_BLOCK` from
        /// `gio.DatagramBased.sendMessages` even if you were previously notified of a
        /// `G_IO_OUT` condition. (On Windows in particular, this is very common due to
        /// the way the underlying APIs work.)
        ///
        /// If the connection is shut down or closed (by calling `gio.Socket.close` or
        /// `gio.Socket.shutdown` with `shutdown_write` set, if it’s a `gio.Socket`, for
        /// example), all calls to this function will return `G_IO_ERROR_CLOSED`.
        ///
        /// On error -1 is returned and `error` is set accordingly. An error will only
        /// be returned if zero messages could be sent; otherwise the number of messages
        /// successfully sent before the error will be returned. If `cancellable` is
        /// cancelled, `G_IO_ERROR_CANCELLED` is returned as with any other error.
        pub const send_messages = struct {
            pub fn call(p_class: anytype, p_datagram_based: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_messages: [*]gio.OutputMessage, p_num_messages: c_uint, p_flags: c_int, p_timeout: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(DatagramBased.Iface, p_class).f_send_messages.?(gobject.ext.as(DatagramBased, p_datagram_based), p_messages, p_num_messages, p_flags, p_timeout, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_datagram_based: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_messages: [*]gio.OutputMessage, p_num_messages: c_uint, p_flags: c_int, p_timeout: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(DatagramBased.Iface, p_class).f_send_messages = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Checks on the readiness of `datagram_based` to perform operations. The
    /// operations specified in `condition` are checked for and masked against the
    /// currently-satisfied conditions on `datagram_based`. The result is returned.
    ///
    /// `G_IO_IN` will be set in the return value if data is available to read with
    /// `gio.DatagramBased.receiveMessages`, or if the connection is closed remotely
    /// (EOS); and if the datagram_based has not been closed locally using some
    /// implementation-specific method (such as `gio.Socket.close` or
    /// `gio.Socket.shutdown` with `shutdown_read` set, if it’s a `gio.Socket`).
    ///
    /// If the connection is shut down or closed (by calling `gio.Socket.close` or
    /// `gio.Socket.shutdown` with `shutdown_read` set, if it’s a `gio.Socket`, for
    /// example), all calls to this function will return `G_IO_ERROR_CLOSED`.
    ///
    /// `G_IO_OUT` will be set if it is expected that at least one byte can be sent
    /// using `gio.DatagramBased.sendMessages` without blocking. It will not be set
    /// if the datagram_based has been closed locally.
    ///
    /// `G_IO_HUP` will be set if the connection has been closed locally.
    ///
    /// `G_IO_ERR` will be set if there was an asynchronous error in transmitting data
    /// previously enqueued using `gio.DatagramBased.sendMessages`.
    ///
    /// Note that on Windows, it is possible for an operation to return
    /// `G_IO_ERROR_WOULD_BLOCK` even immediately after
    /// `gio.DatagramBased.conditionCheck` has claimed that the `gio.DatagramBased` is
    /// ready for writing. Rather than calling `gio.DatagramBased.conditionCheck` and
    /// then writing to the `gio.DatagramBased` if it succeeds, it is generally better to
    /// simply try writing right away, and try again later if the initial attempt
    /// returns `G_IO_ERROR_WOULD_BLOCK`.
    ///
    /// It is meaningless to specify `G_IO_ERR` or `G_IO_HUP` in `condition`; these
    /// conditions will always be set in the output if they are true. Apart from
    /// these flags, the output is guaranteed to be masked by `condition`.
    ///
    /// This call never blocks.
    extern fn g_datagram_based_condition_check(p_datagram_based: *DatagramBased, p_condition: glib.IOCondition) glib.IOCondition;
    pub const conditionCheck = g_datagram_based_condition_check;

    /// Waits for up to `timeout` microseconds for condition to become true on
    /// `datagram_based`. If the condition is met, `TRUE` is returned.
    ///
    /// If `cancellable` is cancelled before the condition is met, or if `timeout` is
    /// reached before the condition is met, then `FALSE` is returned and `error` is
    /// set appropriately (`G_IO_ERROR_CANCELLED` or `G_IO_ERROR_TIMED_OUT`).
    extern fn g_datagram_based_condition_wait(p_datagram_based: *DatagramBased, p_condition: glib.IOCondition, p_timeout: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const conditionWait = g_datagram_based_condition_wait;

    /// Creates a `glib.Source` that can be attached to a `glib.MainContext` to monitor for
    /// the availability of the specified `condition` on the `gio.DatagramBased`. The
    /// `glib.Source` keeps a reference to the `datagram_based`.
    ///
    /// The callback on the source is of the `gio.DatagramBasedSourceFunc` type.
    ///
    /// It is meaningless to specify `G_IO_ERR` or `G_IO_HUP` in `condition`; these
    /// conditions will always be reported in the callback if they are true.
    ///
    /// If non-`NULL`, `cancellable` can be used to cancel the source, which will
    /// cause the source to trigger, reporting the current condition (which is
    /// likely 0 unless cancellation happened at the same time as a condition
    /// change). You can check for this in the callback using
    /// `gio.Cancellable.isCancelled`.
    extern fn g_datagram_based_create_source(p_datagram_based: *DatagramBased, p_condition: glib.IOCondition, p_cancellable: ?*gio.Cancellable) *glib.Source;
    pub const createSource = g_datagram_based_create_source;

    /// Receive one or more data messages from `datagram_based` in one go.
    ///
    /// `messages` must point to an array of `gio.InputMessage` structs and
    /// `num_messages` must be the length of this array. Each `gio.InputMessage`
    /// contains a pointer to an array of `gio.InputVector` structs describing the
    /// buffers that the data received in each message will be written to.
    ///
    /// `flags` modify how all messages are received. The commonly available
    /// arguments for this are available in the `gio.SocketMsgFlags` enum, but the
    /// values there are the same as the system values, and the flags
    /// are passed in as-is, so you can pass in system-specific flags too. These
    /// flags affect the overall receive operation. Flags affecting individual
    /// messages are returned in `gio.InputMessage.flags`.
    ///
    /// The other members of `gio.InputMessage` are treated as described in its
    /// documentation.
    ///
    /// If `timeout` is negative the call will block until `num_messages` have been
    /// received, the connection is closed remotely (EOS), `cancellable` is cancelled,
    /// or an error occurs.
    ///
    /// If `timeout` is 0 the call will return up to `num_messages` without blocking,
    /// or `G_IO_ERROR_WOULD_BLOCK` if no messages are queued in the operating system
    /// to be received.
    ///
    /// If `timeout` is positive the call will block on the same conditions as if
    /// `timeout` were negative. If the timeout is reached
    /// before any messages are received, `G_IO_ERROR_TIMED_OUT` is returned,
    /// otherwise it will return the number of messages received before timing out.
    /// (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
    /// `recvmmsg`.)
    ///
    /// To be notified when messages are available, wait for the `G_IO_IN` condition.
    /// Note though that you may still receive `G_IO_ERROR_WOULD_BLOCK` from
    /// `gio.DatagramBased.receiveMessages` even if you were previously notified of a
    /// `G_IO_IN` condition.
    ///
    /// If the remote peer closes the connection, any messages queued in the
    /// underlying receive buffer will be returned, and subsequent calls to
    /// `gio.DatagramBased.receiveMessages` will return 0 (with no error set).
    ///
    /// If the connection is shut down or closed (by calling `gio.Socket.close` or
    /// `gio.Socket.shutdown` with `shutdown_read` set, if it’s a `gio.Socket`, for
    /// example), all calls to this function will return `G_IO_ERROR_CLOSED`.
    ///
    /// On error -1 is returned and `error` is set accordingly. An error will only
    /// be returned if zero messages could be received; otherwise the number of
    /// messages successfully received before the error will be returned. If
    /// `cancellable` is cancelled, `G_IO_ERROR_CANCELLED` is returned as with any
    /// other error.
    extern fn g_datagram_based_receive_messages(p_datagram_based: *DatagramBased, p_messages: [*]gio.InputMessage, p_num_messages: c_uint, p_flags: c_int, p_timeout: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const receiveMessages = g_datagram_based_receive_messages;

    /// Send one or more data messages from `datagram_based` in one go.
    ///
    /// `messages` must point to an array of `gio.OutputMessage` structs and
    /// `num_messages` must be the length of this array. Each `gio.OutputMessage`
    /// contains an address to send the data to, and a pointer to an array of
    /// `gio.OutputVector` structs to describe the buffers that the data to be sent
    /// for each message will be gathered from.
    ///
    /// `flags` modify how the message is sent. The commonly available arguments
    /// for this are available in the `gio.SocketMsgFlags` enum, but the
    /// values there are the same as the system values, and the flags
    /// are passed in as-is, so you can pass in system-specific flags too.
    ///
    /// The other members of `gio.OutputMessage` are treated as described in its
    /// documentation.
    ///
    /// If `timeout` is negative the call will block until `num_messages` have been
    /// sent, `cancellable` is cancelled, or an error occurs.
    ///
    /// If `timeout` is 0 the call will send up to `num_messages` without blocking,
    /// or will return `G_IO_ERROR_WOULD_BLOCK` if there is no space to send messages.
    ///
    /// If `timeout` is positive the call will block on the same conditions as if
    /// `timeout` were negative. If the timeout is reached before any messages are
    /// sent, `G_IO_ERROR_TIMED_OUT` is returned, otherwise it will return the number
    /// of messages sent before timing out.
    ///
    /// To be notified when messages can be sent, wait for the `G_IO_OUT` condition.
    /// Note though that you may still receive `G_IO_ERROR_WOULD_BLOCK` from
    /// `gio.DatagramBased.sendMessages` even if you were previously notified of a
    /// `G_IO_OUT` condition. (On Windows in particular, this is very common due to
    /// the way the underlying APIs work.)
    ///
    /// If the connection is shut down or closed (by calling `gio.Socket.close` or
    /// `gio.Socket.shutdown` with `shutdown_write` set, if it’s a `gio.Socket`, for
    /// example), all calls to this function will return `G_IO_ERROR_CLOSED`.
    ///
    /// On error -1 is returned and `error` is set accordingly. An error will only
    /// be returned if zero messages could be sent; otherwise the number of messages
    /// successfully sent before the error will be returned. If `cancellable` is
    /// cancelled, `G_IO_ERROR_CANCELLED` is returned as with any other error.
    extern fn g_datagram_based_send_messages(p_datagram_based: *DatagramBased, p_messages: [*]gio.OutputMessage, p_num_messages: c_uint, p_flags: c_int, p_timeout: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const sendMessages = g_datagram_based_send_messages;

    extern fn g_datagram_based_get_type() usize;
    pub const getGObjectType = g_datagram_based_get_type;

    extern fn g_object_ref(p_self: *gio.DatagramBased) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DatagramBased) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DatagramBased, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GDebugController` is an interface to expose control of debugging features and
/// debug output.
///
/// It is implemented on Linux using `gio.DebugControllerDBus`, which
/// exposes a D-Bus interface to allow authenticated peers to control debug
/// features in this process.
///
/// Whether debug output is enabled is exposed as
/// `gio.DebugController.properties.debug_enabled`. This controls
/// `glib.logSetDebugEnabled` by default. Application code may
/// connect to the `gobject.Object.signals.notify` signal for it
/// to control other parts of its debug infrastructure as necessary.
///
/// If your application or service is using the default GLib log writer function,
/// creating one of the built-in implementations of `GDebugController` should be
/// all that’s needed to dynamically enable or disable debug output.
pub const DebugController = opaque {
    pub const Prerequisites = [_]type{gio.Initable};
    pub const Iface = gio.DebugControllerInterface;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// `TRUE` if debug output should be exposed (for example by forwarding it to
        /// the journal), `FALSE` otherwise.
        pub const debug_enabled = struct {
            pub const name = "debug-enabled";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Get the value of `gio.DebugController.properties.debug`-enabled.
    extern fn g_debug_controller_get_debug_enabled(p_self: *DebugController) c_int;
    pub const getDebugEnabled = g_debug_controller_get_debug_enabled;

    /// Set the value of `gio.DebugController.properties.debug`-enabled.
    extern fn g_debug_controller_set_debug_enabled(p_self: *DebugController, p_debug_enabled: c_int) void;
    pub const setDebugEnabled = g_debug_controller_set_debug_enabled;

    extern fn g_debug_controller_get_type() usize;
    pub const getGObjectType = g_debug_controller_get_type;

    extern fn g_object_ref(p_self: *gio.DebugController) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DebugController) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DebugController, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gio.DesktopAppInfoLookup` is an opaque data structure and can only be accessed
/// using the following functions.
pub const DesktopAppInfoLookup = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.DesktopAppInfoLookupIface;
    pub const virtual_methods = struct {
        /// Gets the default application for launching applications
        /// using this URI scheme for a particular `gio.DesktopAppInfoLookup`
        /// implementation.
        ///
        /// The `gio.DesktopAppInfoLookup` interface and this function is used
        /// to implement `gio.AppInfo.getDefaultForUriScheme` backends
        /// in a GIO module. There is no reason for applications to use it
        /// directly. Applications should use
        /// `gio.AppInfo.getDefaultForUriScheme`.
        pub const get_default_for_uri_scheme = struct {
            pub fn call(p_class: anytype, p_lookup: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri_scheme: [*:0]const u8) ?*gio.AppInfo {
                return gobject.ext.as(DesktopAppInfoLookup.Iface, p_class).f_get_default_for_uri_scheme.?(gobject.ext.as(DesktopAppInfoLookup, p_lookup), p_uri_scheme);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_lookup: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri_scheme: [*:0]const u8) callconv(.c) ?*gio.AppInfo) void {
                gobject.ext.as(DesktopAppInfoLookup.Iface, p_class).f_get_default_for_uri_scheme = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Gets the default application for launching applications
    /// using this URI scheme for a particular `gio.DesktopAppInfoLookup`
    /// implementation.
    ///
    /// The `gio.DesktopAppInfoLookup` interface and this function is used
    /// to implement `gio.AppInfo.getDefaultForUriScheme` backends
    /// in a GIO module. There is no reason for applications to use it
    /// directly. Applications should use
    /// `gio.AppInfo.getDefaultForUriScheme`.
    extern fn g_desktop_app_info_lookup_get_default_for_uri_scheme(p_lookup: *DesktopAppInfoLookup, p_uri_scheme: [*:0]const u8) ?*gio.AppInfo;
    pub const getDefaultForUriScheme = g_desktop_app_info_lookup_get_default_for_uri_scheme;

    extern fn g_desktop_app_info_lookup_get_type() usize;
    pub const getGObjectType = g_desktop_app_info_lookup_get_type;

    extern fn g_object_ref(p_self: *gio.DesktopAppInfoLookup) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DesktopAppInfoLookup) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DesktopAppInfoLookup, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GDrive` represents a piece of hardware connected to the machine.
/// It’s generally only created for removable hardware or hardware with
/// removable media. For example, an optical disc drive, or a USB flash drive.
///
/// `GDrive` is a container class for `gio.Volume` objects that stem from
/// the same piece of media. As such, `GDrive` abstracts a drive with
/// (or without) removable media and provides operations for querying
/// whether media is available, determining whether media change is
/// automatically detected and ejecting the media.
///
/// If the `GDrive` reports that media isn’t automatically detected, one
/// can poll for media; typically one should not do this periodically
/// as a poll for media operation is potentially expensive and may
/// spin up the drive creating noise.
///
/// `GDrive` supports starting and stopping drives with authentication
/// support for the former. This can be used to support a diverse set
/// of use cases including connecting/disconnecting iSCSI devices,
/// powering down external disk enclosures and starting/stopping
/// multi-disk devices such as RAID devices. Note that the actual
/// semantics and side-effects of starting/stopping a `GDrive` may vary
/// according to implementation. To choose the correct verbs in e.g. a
/// file manager, use `gio.Drive.getStartStopType`.
///
/// For [porting from GnomeVFS](migrating-gnome-vfs.html) note that there is no
/// equivalent of `GDrive` in that API.
pub const Drive = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.DriveIface;
    pub const virtual_methods = struct {
        /// Checks if a drive can be ejected.
        pub const can_eject = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Drive.Iface, p_class).f_can_eject.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Drive.Iface, p_class).f_can_eject = @ptrCast(p_implementation);
            }
        };

        /// Checks if a drive can be polled for media changes.
        pub const can_poll_for_media = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Drive.Iface, p_class).f_can_poll_for_media.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Drive.Iface, p_class).f_can_poll_for_media = @ptrCast(p_implementation);
            }
        };

        /// Checks if a drive can be started.
        pub const can_start = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Drive.Iface, p_class).f_can_start.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Drive.Iface, p_class).f_can_start = @ptrCast(p_implementation);
            }
        };

        /// Checks if a drive can be started degraded.
        pub const can_start_degraded = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Drive.Iface, p_class).f_can_start_degraded.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Drive.Iface, p_class).f_can_start_degraded = @ptrCast(p_implementation);
            }
        };

        /// Checks if a drive can be stopped.
        pub const can_stop = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Drive.Iface, p_class).f_can_stop.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Drive.Iface, p_class).f_can_stop = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the drive is changed.
        pub const changed = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Drive.Iface, p_class).f_changed.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Drive.Iface, p_class).f_changed = @ptrCast(p_implementation);
            }
        };

        /// The removed signal that is emitted when the `gio.Drive` have been disconnected. If the recipient is holding references to the object they should release them so the object can be finalized.
        pub const disconnected = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Drive.Iface, p_class).f_disconnected.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Drive.Iface, p_class).f_disconnected = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously ejects a drive.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.Drive.ejectFinish` to obtain the
        /// result of the operation.
        pub const eject = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Drive.Iface, p_class).f_eject.?(gobject.ext.as(Drive, p_drive), p_flags, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Drive.Iface, p_class).f_eject = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the physical eject button (if any) of a drive have been pressed.
        pub const eject_button = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Drive.Iface, p_class).f_eject_button.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Drive.Iface, p_class).f_eject_button = @ptrCast(p_implementation);
            }
        };

        /// Finishes ejecting a drive.
        pub const eject_finish = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Drive.Iface, p_class).f_eject_finish.?(gobject.ext.as(Drive, p_drive), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Drive.Iface, p_class).f_eject_finish = @ptrCast(p_implementation);
            }
        };

        /// Ejects a drive. This is an asynchronous operation, and is
        /// finished by calling `gio.Drive.ejectWithOperationFinish` with the `drive`
        /// and `gio.AsyncResult` data returned in the `callback`.
        pub const eject_with_operation = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Drive.Iface, p_class).f_eject_with_operation.?(gobject.ext.as(Drive, p_drive), p_flags, p_mount_operation, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Drive.Iface, p_class).f_eject_with_operation = @ptrCast(p_implementation);
            }
        };

        /// Finishes ejecting a drive. If any errors occurred during the operation,
        /// `error` will be set to contain the errors and `FALSE` will be returned.
        pub const eject_with_operation_finish = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Drive.Iface, p_class).f_eject_with_operation_finish.?(gobject.ext.as(Drive, p_drive), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Drive.Iface, p_class).f_eject_with_operation_finish = @ptrCast(p_implementation);
            }
        };

        /// Gets the kinds of identifiers that `drive` has.
        /// Use `gio.Drive.getIdentifier` to obtain the identifiers
        /// themselves.
        pub const enumerate_identifiers = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*][*:0]u8 {
                return gobject.ext.as(Drive.Iface, p_class).f_enumerate_identifiers.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*][*:0]u8) void {
                gobject.ext.as(Drive.Iface, p_class).f_enumerate_identifiers = @ptrCast(p_implementation);
            }
        };

        /// Gets the icon for `drive`.
        pub const get_icon = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.Icon {
                return gobject.ext.as(Drive.Iface, p_class).f_get_icon.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.Icon) void {
                gobject.ext.as(Drive.Iface, p_class).f_get_icon = @ptrCast(p_implementation);
            }
        };

        /// Gets the identifier of the given kind for `drive`. The only
        /// identifier currently available is
        /// `G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE`.
        pub const get_identifier = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_kind: [*:0]const u8) ?[*:0]u8 {
                return gobject.ext.as(Drive.Iface, p_class).f_get_identifier.?(gobject.ext.as(Drive, p_drive), p_kind);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_kind: [*:0]const u8) callconv(.c) ?[*:0]u8) void {
                gobject.ext.as(Drive.Iface, p_class).f_get_identifier = @ptrCast(p_implementation);
            }
        };

        /// Gets the name of `drive`.
        pub const get_name = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]u8 {
                return gobject.ext.as(Drive.Iface, p_class).f_get_name.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]u8) void {
                gobject.ext.as(Drive.Iface, p_class).f_get_name = @ptrCast(p_implementation);
            }
        };

        /// Gets the sort key for `drive`, if any.
        pub const get_sort_key = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]const u8 {
                return gobject.ext.as(Drive.Iface, p_class).f_get_sort_key.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]const u8) void {
                gobject.ext.as(Drive.Iface, p_class).f_get_sort_key = @ptrCast(p_implementation);
            }
        };

        /// Gets a hint about how a drive can be started/stopped.
        pub const get_start_stop_type = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) gio.DriveStartStopType {
                return gobject.ext.as(Drive.Iface, p_class).f_get_start_stop_type.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) gio.DriveStartStopType) void {
                gobject.ext.as(Drive.Iface, p_class).f_get_start_stop_type = @ptrCast(p_implementation);
            }
        };

        /// Gets the icon for `drive`.
        pub const get_symbolic_icon = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.Icon {
                return gobject.ext.as(Drive.Iface, p_class).f_get_symbolic_icon.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.Icon) void {
                gobject.ext.as(Drive.Iface, p_class).f_get_symbolic_icon = @ptrCast(p_implementation);
            }
        };

        /// Get a list of mountable volumes for `drive`.
        ///
        /// The returned list should be freed with `glib.List.free`, after
        /// its elements have been unreffed with `gobject.Object.unref`.
        pub const get_volumes = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *glib.List {
                return gobject.ext.as(Drive.Iface, p_class).f_get_volumes.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *glib.List) void {
                gobject.ext.as(Drive.Iface, p_class).f_get_volumes = @ptrCast(p_implementation);
            }
        };

        /// Checks if the `drive` has media. Note that the OS may not be polling
        /// the drive for media changes; see `gio.Drive.isMediaCheckAutomatic`
        /// for more details.
        pub const has_media = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Drive.Iface, p_class).f_has_media.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Drive.Iface, p_class).f_has_media = @ptrCast(p_implementation);
            }
        };

        /// Check if `drive` has any mountable volumes.
        pub const has_volumes = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Drive.Iface, p_class).f_has_volumes.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Drive.Iface, p_class).f_has_volumes = @ptrCast(p_implementation);
            }
        };

        /// Checks if `drive` is capable of automatically detecting media changes.
        pub const is_media_check_automatic = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Drive.Iface, p_class).f_is_media_check_automatic.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Drive.Iface, p_class).f_is_media_check_automatic = @ptrCast(p_implementation);
            }
        };

        /// Checks if the `drive` supports removable media.
        pub const is_media_removable = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Drive.Iface, p_class).f_is_media_removable.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Drive.Iface, p_class).f_is_media_removable = @ptrCast(p_implementation);
            }
        };

        /// Checks if the `gio.Drive` and/or its media is considered removable by the user.
        /// See `gio.Drive.isMediaRemovable`.
        pub const is_removable = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Drive.Iface, p_class).f_is_removable.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Drive.Iface, p_class).f_is_removable = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously polls `drive` to see if media has been inserted or removed.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.Drive.pollForMediaFinish` to obtain the
        /// result of the operation.
        pub const poll_for_media = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Drive.Iface, p_class).f_poll_for_media.?(gobject.ext.as(Drive, p_drive), p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Drive.Iface, p_class).f_poll_for_media = @ptrCast(p_implementation);
            }
        };

        /// Finishes an operation started with `gio.Drive.pollForMedia` on a drive.
        pub const poll_for_media_finish = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Drive.Iface, p_class).f_poll_for_media_finish.?(gobject.ext.as(Drive, p_drive), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Drive.Iface, p_class).f_poll_for_media_finish = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously starts a drive.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.Drive.startFinish` to obtain the
        /// result of the operation.
        pub const start = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.DriveStartFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Drive.Iface, p_class).f_start.?(gobject.ext.as(Drive, p_drive), p_flags, p_mount_operation, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.DriveStartFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Drive.Iface, p_class).f_start = @ptrCast(p_implementation);
            }
        };

        /// Finishes starting a drive.
        pub const start_finish = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Drive.Iface, p_class).f_start_finish.?(gobject.ext.as(Drive, p_drive), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Drive.Iface, p_class).f_start_finish = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously stops a drive.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.Drive.stopFinish` to obtain the
        /// result of the operation.
        pub const stop = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Drive.Iface, p_class).f_stop.?(gobject.ext.as(Drive, p_drive), p_flags, p_mount_operation, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Drive.Iface, p_class).f_stop = @ptrCast(p_implementation);
            }
        };

        /// Signal emitted when the physical stop button (if any) of a drive have been pressed. Since 2.22.
        pub const stop_button = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Drive.Iface, p_class).f_stop_button.?(gobject.ext.as(Drive, p_drive));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Drive.Iface, p_class).f_stop_button = @ptrCast(p_implementation);
            }
        };

        /// Finishes stopping a drive.
        pub const stop_finish = struct {
            pub fn call(p_class: anytype, p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Drive.Iface, p_class).f_stop_finish.?(gobject.ext.as(Drive, p_drive), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_drive: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Drive.Iface, p_class).f_stop_finish = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// Emitted when the drive's state has changed.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Drive, p_instance))),
                    gobject.signalLookup("changed", Drive.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when the `gio.Drive` have been
        /// disconnected. If the recipient is holding references to the
        /// object they should release them so the object can be
        /// finalized.
        pub const disconnected = struct {
            pub const name = "disconnected";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Drive, p_instance))),
                    gobject.signalLookup("disconnected", Drive.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the physical eject button (if any) of a drive has
        /// been pressed.
        pub const eject_button = struct {
            pub const name = "eject-button";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Drive, p_instance))),
                    gobject.signalLookup("eject-button", Drive.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// Emitted when the physical stop button (if any) of a drive has
        /// been pressed.
        pub const stop_button = struct {
            pub const name = "stop-button";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Drive, p_instance))),
                    gobject.signalLookup("stop-button", Drive.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Checks if a drive can be ejected.
    extern fn g_drive_can_eject(p_drive: *Drive) c_int;
    pub const canEject = g_drive_can_eject;

    /// Checks if a drive can be polled for media changes.
    extern fn g_drive_can_poll_for_media(p_drive: *Drive) c_int;
    pub const canPollForMedia = g_drive_can_poll_for_media;

    /// Checks if a drive can be started.
    extern fn g_drive_can_start(p_drive: *Drive) c_int;
    pub const canStart = g_drive_can_start;

    /// Checks if a drive can be started degraded.
    extern fn g_drive_can_start_degraded(p_drive: *Drive) c_int;
    pub const canStartDegraded = g_drive_can_start_degraded;

    /// Checks if a drive can be stopped.
    extern fn g_drive_can_stop(p_drive: *Drive) c_int;
    pub const canStop = g_drive_can_stop;

    /// Asynchronously ejects a drive.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.Drive.ejectFinish` to obtain the
    /// result of the operation.
    extern fn g_drive_eject(p_drive: *Drive, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const eject = g_drive_eject;

    /// Finishes ejecting a drive.
    extern fn g_drive_eject_finish(p_drive: *Drive, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const ejectFinish = g_drive_eject_finish;

    /// Ejects a drive. This is an asynchronous operation, and is
    /// finished by calling `gio.Drive.ejectWithOperationFinish` with the `drive`
    /// and `gio.AsyncResult` data returned in the `callback`.
    extern fn g_drive_eject_with_operation(p_drive: *Drive, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const ejectWithOperation = g_drive_eject_with_operation;

    /// Finishes ejecting a drive. If any errors occurred during the operation,
    /// `error` will be set to contain the errors and `FALSE` will be returned.
    extern fn g_drive_eject_with_operation_finish(p_drive: *Drive, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const ejectWithOperationFinish = g_drive_eject_with_operation_finish;

    /// Gets the kinds of identifiers that `drive` has.
    /// Use `gio.Drive.getIdentifier` to obtain the identifiers
    /// themselves.
    extern fn g_drive_enumerate_identifiers(p_drive: *Drive) [*][*:0]u8;
    pub const enumerateIdentifiers = g_drive_enumerate_identifiers;

    /// Gets the icon for `drive`.
    extern fn g_drive_get_icon(p_drive: *Drive) *gio.Icon;
    pub const getIcon = g_drive_get_icon;

    /// Gets the identifier of the given kind for `drive`. The only
    /// identifier currently available is
    /// `G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE`.
    extern fn g_drive_get_identifier(p_drive: *Drive, p_kind: [*:0]const u8) ?[*:0]u8;
    pub const getIdentifier = g_drive_get_identifier;

    /// Gets the name of `drive`.
    extern fn g_drive_get_name(p_drive: *Drive) [*:0]u8;
    pub const getName = g_drive_get_name;

    /// Gets the sort key for `drive`, if any.
    extern fn g_drive_get_sort_key(p_drive: *Drive) ?[*:0]const u8;
    pub const getSortKey = g_drive_get_sort_key;

    /// Gets a hint about how a drive can be started/stopped.
    extern fn g_drive_get_start_stop_type(p_drive: *Drive) gio.DriveStartStopType;
    pub const getStartStopType = g_drive_get_start_stop_type;

    /// Gets the icon for `drive`.
    extern fn g_drive_get_symbolic_icon(p_drive: *Drive) *gio.Icon;
    pub const getSymbolicIcon = g_drive_get_symbolic_icon;

    /// Get a list of mountable volumes for `drive`.
    ///
    /// The returned list should be freed with `glib.List.free`, after
    /// its elements have been unreffed with `gobject.Object.unref`.
    extern fn g_drive_get_volumes(p_drive: *Drive) *glib.List;
    pub const getVolumes = g_drive_get_volumes;

    /// Checks if the `drive` has media. Note that the OS may not be polling
    /// the drive for media changes; see `gio.Drive.isMediaCheckAutomatic`
    /// for more details.
    extern fn g_drive_has_media(p_drive: *Drive) c_int;
    pub const hasMedia = g_drive_has_media;

    /// Check if `drive` has any mountable volumes.
    extern fn g_drive_has_volumes(p_drive: *Drive) c_int;
    pub const hasVolumes = g_drive_has_volumes;

    /// Checks if `drive` is capable of automatically detecting media changes.
    extern fn g_drive_is_media_check_automatic(p_drive: *Drive) c_int;
    pub const isMediaCheckAutomatic = g_drive_is_media_check_automatic;

    /// Checks if the `drive` supports removable media.
    extern fn g_drive_is_media_removable(p_drive: *Drive) c_int;
    pub const isMediaRemovable = g_drive_is_media_removable;

    /// Checks if the `gio.Drive` and/or its media is considered removable by the user.
    /// See `gio.Drive.isMediaRemovable`.
    extern fn g_drive_is_removable(p_drive: *Drive) c_int;
    pub const isRemovable = g_drive_is_removable;

    /// Asynchronously polls `drive` to see if media has been inserted or removed.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.Drive.pollForMediaFinish` to obtain the
    /// result of the operation.
    extern fn g_drive_poll_for_media(p_drive: *Drive, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const pollForMedia = g_drive_poll_for_media;

    /// Finishes an operation started with `gio.Drive.pollForMedia` on a drive.
    extern fn g_drive_poll_for_media_finish(p_drive: *Drive, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const pollForMediaFinish = g_drive_poll_for_media_finish;

    /// Asynchronously starts a drive.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.Drive.startFinish` to obtain the
    /// result of the operation.
    extern fn g_drive_start(p_drive: *Drive, p_flags: gio.DriveStartFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const start = g_drive_start;

    /// Finishes starting a drive.
    extern fn g_drive_start_finish(p_drive: *Drive, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const startFinish = g_drive_start_finish;

    /// Asynchronously stops a drive.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.Drive.stopFinish` to obtain the
    /// result of the operation.
    extern fn g_drive_stop(p_drive: *Drive, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const stop = g_drive_stop;

    /// Finishes stopping a drive.
    extern fn g_drive_stop_finish(p_drive: *Drive, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const stopFinish = g_drive_stop_finish;

    extern fn g_drive_get_type() usize;
    pub const getGObjectType = g_drive_get_type;

    extern fn g_object_ref(p_self: *gio.Drive) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Drive) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Drive, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GDtlsClientConnection` is the client-side subclass of
/// `gio.DtlsConnection`, representing a client-side DTLS connection.
pub const DtlsClientConnection = opaque {
    pub const Prerequisites = [_]type{ gio.DatagramBased, gio.DtlsConnection };
    pub const Iface = gio.DtlsClientConnectionInterface;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// A list of the distinguished names of the Certificate Authorities
        /// that the server will accept client certificates signed by. If the
        /// server requests a client certificate during the handshake, then
        /// this property will be set after the handshake completes.
        ///
        /// Each item in the list is a `glib.ByteArray` which contains the complete
        /// subject DN of the certificate authority.
        pub const accepted_cas = struct {
            pub const name = "accepted-cas";

            pub const Type = ?**glib.List;
        };

        /// A `gio.SocketConnectable` describing the identity of the server that
        /// is expected on the other end of the connection.
        ///
        /// If the `G_TLS_CERTIFICATE_BAD_IDENTITY` flag is set in
        /// `gio.DtlsClientConnection.properties.validation`-flags, this object will be used
        /// to determine the expected identify of the remote end of the
        /// connection; if `gio.DtlsClientConnection.properties.server`-identity is not set,
        /// or does not match the identity presented by the server, then the
        /// `G_TLS_CERTIFICATE_BAD_IDENTITY` validation will fail.
        ///
        /// In addition to its use in verifying the server certificate,
        /// this is also used to give a hint to the server about what
        /// certificate we expect, which is useful for servers that serve
        /// virtual hosts.
        pub const server_identity = struct {
            pub const name = "server-identity";

            pub const Type = ?*gio.SocketConnectable;
        };

        /// What steps to perform when validating a certificate received from
        /// a server. Server certificates that fail to validate in any of the
        /// ways indicated here will be rejected unless the application
        /// overrides the default via `gio.DtlsConnection.signals.accept`-certificate.
        ///
        /// GLib guarantees that if certificate verification fails, at least one
        /// flag will be set, but it does not guarantee that all possible flags
        /// will be set. Accordingly, you may not safely decide to ignore any
        /// particular type of error. For example, it would be incorrect to mask
        /// `G_TLS_CERTIFICATE_EXPIRED` if you want to allow expired certificates,
        /// because this could potentially be the only error flag set even if
        /// other problems exist with the certificate. Therefore, there is no
        /// safe way to use this property. This is not a horrible problem,
        /// though, because you should not be attempting to ignore validation
        /// errors anyway. If you really must ignore TLS certificate errors,
        /// connect to `gio.DtlsConnection.signals.accept`-certificate.
        pub const validation_flags = struct {
            pub const name = "validation-flags";

            pub const Type = gio.TlsCertificateFlags;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.DtlsClientConnection` wrapping `base_socket` which is
    /// assumed to communicate with the server identified by `server_identity`.
    extern fn g_dtls_client_connection_new(p_base_socket: *gio.DatagramBased, p_server_identity: ?*gio.SocketConnectable, p_error: ?*?*glib.Error) ?*gio.DtlsClientConnection;
    pub const new = g_dtls_client_connection_new;

    /// Gets the list of distinguished names of the Certificate Authorities
    /// that the server will accept certificates from. This will be set
    /// during the TLS handshake if the server requests a certificate.
    /// Otherwise, it will be `NULL`.
    ///
    /// Each item in the list is a `glib.ByteArray` which contains the complete
    /// subject DN of the certificate authority.
    extern fn g_dtls_client_connection_get_accepted_cas(p_conn: *DtlsClientConnection) *glib.List;
    pub const getAcceptedCas = g_dtls_client_connection_get_accepted_cas;

    /// Gets `conn`'s expected server identity
    extern fn g_dtls_client_connection_get_server_identity(p_conn: *DtlsClientConnection) *gio.SocketConnectable;
    pub const getServerIdentity = g_dtls_client_connection_get_server_identity;

    /// Gets `conn`'s validation flags
    ///
    /// This function does not work as originally designed and is impossible
    /// to use correctly. See `gio.DtlsClientConnection.properties.validation`-flags for more
    /// information.
    extern fn g_dtls_client_connection_get_validation_flags(p_conn: *DtlsClientConnection) gio.TlsCertificateFlags;
    pub const getValidationFlags = g_dtls_client_connection_get_validation_flags;

    /// Sets `conn`'s expected server identity, which is used both to tell
    /// servers on virtual hosts which certificate to present, and also
    /// to let `conn` know what name to look for in the certificate when
    /// performing `G_TLS_CERTIFICATE_BAD_IDENTITY` validation, if enabled.
    extern fn g_dtls_client_connection_set_server_identity(p_conn: *DtlsClientConnection, p_identity: *gio.SocketConnectable) void;
    pub const setServerIdentity = g_dtls_client_connection_set_server_identity;

    /// Sets `conn`'s validation flags, to override the default set of
    /// checks performed when validating a server certificate. By default,
    /// `G_TLS_CERTIFICATE_VALIDATE_ALL` is used.
    ///
    /// This function does not work as originally designed and is impossible
    /// to use correctly. See `gio.DtlsClientConnection.properties.validation`-flags for more
    /// information.
    extern fn g_dtls_client_connection_set_validation_flags(p_conn: *DtlsClientConnection, p_flags: gio.TlsCertificateFlags) void;
    pub const setValidationFlags = g_dtls_client_connection_set_validation_flags;

    extern fn g_dtls_client_connection_get_type() usize;
    pub const getGObjectType = g_dtls_client_connection_get_type;

    extern fn g_object_ref(p_self: *gio.DtlsClientConnection) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DtlsClientConnection) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DtlsClientConnection, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GDtlsConnection` is the base DTLS connection class type, which wraps
/// a `gio.DatagramBased` and provides DTLS encryption on top of it. Its
/// subclasses, `gio.DtlsClientConnection` and
/// `gio.DtlsServerConnection`, implement client-side and server-side DTLS,
/// respectively.
///
/// For TLS support, see `gio.TlsConnection`.
///
/// As DTLS is datagram based, `GDtlsConnection` implements
/// `gio.DatagramBased`, presenting a datagram-socket-like API for the
/// encrypted connection. This operates over a base datagram connection, which is
/// also a `GDatagramBased` (`gio.DtlsConnection.properties.base_socket`).
///
/// To close a DTLS connection, use `gio.DtlsConnection.close`.
///
/// Neither `gio.DtlsServerConnection` or `gio.DtlsClientConnection`
/// set the peer address on their base `gio.DatagramBased` if it is a
/// `gio.Socket` — it is up to the caller to do that if they wish. If they
/// do not, and `gio.Socket.close` is called on the base socket, the
/// `GDtlsConnection` will not raise a `G_IO_ERROR_NOT_CONNECTED` error on
/// further I/O.
pub const DtlsConnection = opaque {
    pub const Prerequisites = [_]type{gio.DatagramBased};
    pub const Iface = gio.DtlsConnectionInterface;
    pub const virtual_methods = struct {
        /// Check whether to accept a certificate.
        pub const accept_certificate = struct {
            pub fn call(p_class: anytype, p_connection: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_peer_cert: *gio.TlsCertificate, p_errors: gio.TlsCertificateFlags) c_int {
                return gobject.ext.as(DtlsConnection.Iface, p_class).f_accept_certificate.?(gobject.ext.as(DtlsConnection, p_connection), p_peer_cert, p_errors);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_connection: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_peer_cert: *gio.TlsCertificate, p_errors: gio.TlsCertificateFlags) callconv(.c) c_int) void {
                gobject.ext.as(DtlsConnection.Iface, p_class).f_accept_certificate = @ptrCast(p_implementation);
            }
        };

        /// Retrieve TLS channel binding data (Since: 2.66)
        pub const get_binding_data = struct {
            pub fn call(p_class: anytype, p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_type: gio.TlsChannelBindingType, p_data: *glib.ByteArray, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(DtlsConnection.Iface, p_class).f_get_binding_data.?(gobject.ext.as(DtlsConnection, p_conn), p_type, p_data, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_type: gio.TlsChannelBindingType, p_data: *glib.ByteArray, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(DtlsConnection.Iface, p_class).f_get_binding_data = @ptrCast(p_implementation);
            }
        };

        /// Gets the name of the application-layer protocol negotiated during
        /// the handshake.
        ///
        /// If the peer did not use the ALPN extension, or did not advertise a
        /// protocol that matched one of `conn`'s protocols, or the TLS backend
        /// does not support ALPN, then this will be `NULL`. See
        /// `gio.DtlsConnection.setAdvertisedProtocols`.
        pub const get_negotiated_protocol = struct {
            pub fn call(p_class: anytype, p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]const u8 {
                return gobject.ext.as(DtlsConnection.Iface, p_class).f_get_negotiated_protocol.?(gobject.ext.as(DtlsConnection, p_conn));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]const u8) void {
                gobject.ext.as(DtlsConnection.Iface, p_class).f_get_negotiated_protocol = @ptrCast(p_implementation);
            }
        };

        /// Attempts a TLS handshake on `conn`.
        ///
        /// On the client side, it is never necessary to call this method;
        /// although the connection needs to perform a handshake after
        /// connecting, `gio.DtlsConnection` will handle this for you automatically
        /// when you try to send or receive data on the connection. You can call
        /// `gio.DtlsConnection.handshake` manually if you want to know whether
        /// the initial handshake succeeded or failed (as opposed to just
        /// immediately trying to use `conn` to read or write, in which case,
        /// if it fails, it may not be possible to tell if it failed before
        /// or after completing the handshake), but beware that servers may reject
        /// client authentication after the handshake has completed, so a
        /// successful handshake does not indicate the connection will be usable.
        ///
        /// Likewise, on the server side, although a handshake is necessary at
        /// the beginning of the communication, you do not need to call this
        /// function explicitly unless you want clearer error reporting.
        ///
        /// Previously, calling `gio.DtlsConnection.handshake` after the initial
        /// handshake would trigger a rehandshake; however, this usage was
        /// deprecated in GLib 2.60 because rehandshaking was removed from the
        /// TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
        /// the initial handshake will no longer do anything.
        ///
        /// `gio.DtlsConnection.signals.accept_certificate` may be emitted during the
        /// handshake.
        pub const handshake = struct {
            pub fn call(p_class: anytype, p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(DtlsConnection.Iface, p_class).f_handshake.?(gobject.ext.as(DtlsConnection, p_conn), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(DtlsConnection.Iface, p_class).f_handshake = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously performs a TLS handshake on `conn`. See
        /// `gio.DtlsConnection.handshake` for more information.
        pub const handshake_async = struct {
            pub fn call(p_class: anytype, p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(DtlsConnection.Iface, p_class).f_handshake_async.?(gobject.ext.as(DtlsConnection, p_conn), p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(DtlsConnection.Iface, p_class).f_handshake_async = @ptrCast(p_implementation);
            }
        };

        /// Finish an asynchronous TLS handshake operation. See
        /// `gio.DtlsConnection.handshake` for more information.
        pub const handshake_finish = struct {
            pub fn call(p_class: anytype, p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(DtlsConnection.Iface, p_class).f_handshake_finish.?(gobject.ext.as(DtlsConnection, p_conn), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(DtlsConnection.Iface, p_class).f_handshake_finish = @ptrCast(p_implementation);
            }
        };

        /// Sets the list of application-layer protocols to advertise that the
        /// caller is willing to speak on this connection. The
        /// Application-Layer Protocol Negotiation (ALPN) extension will be
        /// used to negotiate a compatible protocol with the peer; use
        /// `gio.DtlsConnection.getNegotiatedProtocol` to find the negotiated
        /// protocol after the handshake.  Specifying `NULL` for the the value
        /// of `protocols` will disable ALPN negotiation.
        ///
        /// See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml`alpn`-protocol-ids)
        /// for a list of registered protocol IDs.
        pub const set_advertised_protocols = struct {
            pub fn call(p_class: anytype, p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_protocols: ?[*]const [*:0]const u8) void {
                return gobject.ext.as(DtlsConnection.Iface, p_class).f_set_advertised_protocols.?(gobject.ext.as(DtlsConnection, p_conn), p_protocols);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_protocols: ?[*]const [*:0]const u8) callconv(.c) void) void {
                gobject.ext.as(DtlsConnection.Iface, p_class).f_set_advertised_protocols = @ptrCast(p_implementation);
            }
        };

        /// Shut down part or all of a DTLS connection.
        ///
        /// If `shutdown_read` is `TRUE` then the receiving side of the connection is shut
        /// down, and further reading is disallowed. Subsequent calls to
        /// `gio.DatagramBased.receiveMessages` will return `G_IO_ERROR_CLOSED`.
        ///
        /// If `shutdown_write` is `TRUE` then the sending side of the connection is shut
        /// down, and further writing is disallowed. Subsequent calls to
        /// `gio.DatagramBased.sendMessages` will return `G_IO_ERROR_CLOSED`.
        ///
        /// It is allowed for both `shutdown_read` and `shutdown_write` to be TRUE — this
        /// is equivalent to calling `gio.DtlsConnection.close`.
        ///
        /// If `cancellable` is cancelled, the `gio.DtlsConnection` may be left
        /// partially-closed and any pending untransmitted data may be lost. Call
        /// `gio.DtlsConnection.shutdown` again to complete closing the `gio.DtlsConnection`.
        pub const shutdown = struct {
            pub fn call(p_class: anytype, p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_shutdown_read: c_int, p_shutdown_write: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(DtlsConnection.Iface, p_class).f_shutdown.?(gobject.ext.as(DtlsConnection, p_conn), p_shutdown_read, p_shutdown_write, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_shutdown_read: c_int, p_shutdown_write: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(DtlsConnection.Iface, p_class).f_shutdown = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously shut down part or all of the DTLS connection. See
        /// `gio.DtlsConnection.shutdown` for more information.
        pub const shutdown_async = struct {
            pub fn call(p_class: anytype, p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_shutdown_read: c_int, p_shutdown_write: c_int, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(DtlsConnection.Iface, p_class).f_shutdown_async.?(gobject.ext.as(DtlsConnection, p_conn), p_shutdown_read, p_shutdown_write, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_shutdown_read: c_int, p_shutdown_write: c_int, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(DtlsConnection.Iface, p_class).f_shutdown_async = @ptrCast(p_implementation);
            }
        };

        /// Finish an asynchronous TLS shutdown operation. See
        /// `gio.DtlsConnection.shutdown` for more information.
        pub const shutdown_finish = struct {
            pub fn call(p_class: anytype, p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(DtlsConnection.Iface, p_class).f_shutdown_finish.?(gobject.ext.as(DtlsConnection, p_conn), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(DtlsConnection.Iface, p_class).f_shutdown_finish = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// The list of application-layer protocols that the connection
        /// advertises that it is willing to speak. See
        /// `gio.DtlsConnection.setAdvertisedProtocols`.
        pub const advertised_protocols = struct {
            pub const name = "advertised-protocols";

            pub const Type = ?[*][*:0]u8;
        };

        /// The `gio.DatagramBased` that the connection wraps. Note that this may be any
        /// implementation of `gio.DatagramBased`, not just a `gio.Socket`.
        pub const base_socket = struct {
            pub const name = "base-socket";

            pub const Type = ?*gio.DatagramBased;
        };

        /// The connection's certificate; see
        /// `gio.DtlsConnection.setCertificate`.
        pub const certificate = struct {
            pub const name = "certificate";

            pub const Type = ?*gio.TlsCertificate;
        };

        /// The name of the DTLS ciphersuite in use. See `gio.DtlsConnection.getCiphersuiteName`.
        pub const ciphersuite_name = struct {
            pub const name = "ciphersuite-name";

            pub const Type = ?[*:0]u8;
        };

        /// The certificate database to use when verifying this TLS connection.
        /// If no certificate database is set, then the default database will be
        /// used. See `gio.TlsBackend.getDefaultDatabase`.
        ///
        /// When using a non-default database, `gio.DtlsConnection` must fall back to using
        /// the `gio.TlsDatabase` to perform certificate verification using
        /// `gio.TlsDatabase.verifyChain`, which means certificate verification will
        /// not be able to make use of TLS session context. This may be less secure.
        /// For example, if you create your own `gio.TlsDatabase` that just wraps the
        /// default `gio.TlsDatabase`, you might expect that you have not changed anything,
        /// but this is not true because you may have altered the behavior of
        /// `gio.DtlsConnection` by causing it to use `gio.TlsDatabase.verifyChain`. See the
        /// documentation of `gio.TlsDatabase.verifyChain` for more details on specific
        /// security checks that may not be performed. Accordingly, setting a
        /// non-default database is discouraged except for specialty applications with
        /// unusual security requirements.
        pub const database = struct {
            pub const name = "database";

            pub const Type = ?*gio.TlsDatabase;
        };

        /// A `gio.TlsInteraction` object to be used when the connection or certificate
        /// database need to interact with the user. This will be used to prompt the
        /// user for passwords where necessary.
        pub const interaction = struct {
            pub const name = "interaction";

            pub const Type = ?*gio.TlsInteraction;
        };

        /// The application-layer protocol negotiated during the TLS
        /// handshake. See `gio.DtlsConnection.getNegotiatedProtocol`.
        pub const negotiated_protocol = struct {
            pub const name = "negotiated-protocol";

            pub const Type = ?[*:0]u8;
        };

        /// The connection's peer's certificate, after the TLS handshake has
        /// completed or failed. Note in particular that this is not yet set
        /// during the emission of `gio.DtlsConnection.signals.accept`-certificate.
        ///
        /// (You can watch for a `gobject.Object.signals.notify` signal on this property to
        /// detect when a handshake has occurred.)
        pub const peer_certificate = struct {
            pub const name = "peer-certificate";

            pub const Type = ?*gio.TlsCertificate;
        };

        /// The errors noticed while verifying
        /// `gio.DtlsConnection.properties.peer`-certificate. Normally this should be 0, but
        /// it may not be if `gio.DtlsClientConnection.properties.validation`-flags is not
        /// `G_TLS_CERTIFICATE_VALIDATE_ALL`, or if
        /// `gio.DtlsConnection.signals.accept`-certificate overrode the default
        /// behavior.
        ///
        /// GLib guarantees that if certificate verification fails, at least
        /// one error will be set, but it does not guarantee that all possible
        /// errors will be set. Accordingly, you may not safely decide to
        /// ignore any particular type of error. For example, it would be
        /// incorrect to mask `G_TLS_CERTIFICATE_EXPIRED` if you want to allow
        /// expired certificates, because this could potentially be the only
        /// error flag set even if other problems exist with the certificate.
        pub const peer_certificate_errors = struct {
            pub const name = "peer-certificate-errors";

            pub const Type = gio.TlsCertificateFlags;
        };

        /// The DTLS protocol version in use. See `gio.DtlsConnection.getProtocolVersion`.
        pub const protocol_version = struct {
            pub const name = "protocol-version";

            pub const Type = gio.TlsProtocolVersion;
        };

        /// The rehandshaking mode. See
        /// `gio.DtlsConnection.setRehandshakeMode`.
        pub const rehandshake_mode = struct {
            pub const name = "rehandshake-mode";

            pub const Type = gio.TlsRehandshakeMode;
        };

        /// Whether or not proper TLS close notification is required.
        /// See `gio.DtlsConnection.setRequireCloseNotify`.
        pub const require_close_notify = struct {
            pub const name = "require-close-notify";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted during the TLS handshake after the peer certificate has
        /// been received. You can examine `peer_cert`'s certification path by
        /// calling `gio.TlsCertificate.getIssuer` on it.
        ///
        /// For a client-side connection, `peer_cert` is the server's
        /// certificate, and the signal will only be emitted if the
        /// certificate was not acceptable according to `conn`'s
        /// `gio.DtlsClientConnection.properties.validation_flags`. If you would like the
        /// certificate to be accepted despite `errors`, return `TRUE` from the
        /// signal handler. Otherwise, if no handler accepts the certificate,
        /// the handshake will fail with `G_TLS_ERROR_BAD_CERTIFICATE`.
        ///
        /// GLib guarantees that if certificate verification fails, this signal
        /// will be emitted with at least one error will be set in `errors`, but
        /// it does not guarantee that all possible errors will be set.
        /// Accordingly, you may not safely decide to ignore any particular
        /// type of error. For example, it would be incorrect to ignore
        /// `G_TLS_CERTIFICATE_EXPIRED` if you want to allow expired
        /// certificates, because this could potentially be the only error flag
        /// set even if other problems exist with the certificate.
        ///
        /// For a server-side connection, `peer_cert` is the certificate
        /// presented by the client, if this was requested via the server's
        /// `gio.DtlsServerConnection.properties.authentication_mode`. On the server side,
        /// the signal is always emitted when the client presents a
        /// certificate, and the certificate will only be accepted if a
        /// handler returns `TRUE`.
        ///
        /// Note that if this signal is emitted as part of asynchronous I/O
        /// in the main thread, then you should not attempt to interact with
        /// the user before returning from the signal handler. If you want to
        /// let the user decide whether or not to accept the certificate, you
        /// would have to return `FALSE` from the signal handler on the first
        /// attempt, and then after the connection attempt returns a
        /// `G_TLS_ERROR_BAD_CERTIFICATE`, you can interact with the user, and
        /// if the user decides to accept the certificate, remember that fact,
        /// create a new connection, and return `TRUE` from the signal handler
        /// the next time.
        ///
        /// If you are doing I/O in another thread, you do not
        /// need to worry about this, and can simply block in the signal
        /// handler until the UI thread returns an answer.
        pub const accept_certificate = struct {
            pub const name = "accept-certificate";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_peer_cert: *gio.TlsCertificate, p_errors: gio.TlsCertificateFlags, P_Data) callconv(.c) c_int, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(DtlsConnection, p_instance))),
                    gobject.signalLookup("accept-certificate", DtlsConnection.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Close the DTLS connection. This is equivalent to calling
    /// `gio.DtlsConnection.shutdown` to shut down both sides of the connection.
    ///
    /// Closing a `gio.DtlsConnection` waits for all buffered but untransmitted data to
    /// be sent before it completes. It then sends a `close_notify` DTLS alert to the
    /// peer and may wait for a `close_notify` to be received from the peer. It does
    /// not close the underlying `gio.DtlsConnection.properties.base`-socket; that must be closed
    /// separately.
    ///
    /// Once `conn` is closed, all other operations will return `G_IO_ERROR_CLOSED`.
    /// Closing a `gio.DtlsConnection` multiple times will not return an error.
    ///
    /// `GDtlsConnections` will be automatically closed when the last reference is
    /// dropped, but you might want to call this function to make sure resources are
    /// released as early as possible.
    ///
    /// If `cancellable` is cancelled, the `gio.DtlsConnection` may be left
    /// partially-closed and any pending untransmitted data may be lost. Call
    /// `gio.DtlsConnection.close` again to complete closing the `gio.DtlsConnection`.
    extern fn g_dtls_connection_close(p_conn: *DtlsConnection, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const close = g_dtls_connection_close;

    /// Asynchronously close the DTLS connection. See `gio.DtlsConnection.close` for
    /// more information.
    extern fn g_dtls_connection_close_async(p_conn: *DtlsConnection, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const closeAsync = g_dtls_connection_close_async;

    /// Finish an asynchronous TLS close operation. See `gio.DtlsConnection.close`
    /// for more information.
    extern fn g_dtls_connection_close_finish(p_conn: *DtlsConnection, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const closeFinish = g_dtls_connection_close_finish;

    /// Used by `gio.DtlsConnection` implementations to emit the
    /// `gio.DtlsConnection.signals.accept`-certificate signal.
    extern fn g_dtls_connection_emit_accept_certificate(p_conn: *DtlsConnection, p_peer_cert: *gio.TlsCertificate, p_errors: gio.TlsCertificateFlags) c_int;
    pub const emitAcceptCertificate = g_dtls_connection_emit_accept_certificate;

    /// Gets `conn`'s certificate, as set by
    /// `gio.DtlsConnection.setCertificate`.
    extern fn g_dtls_connection_get_certificate(p_conn: *DtlsConnection) ?*gio.TlsCertificate;
    pub const getCertificate = g_dtls_connection_get_certificate;

    /// Query the TLS backend for TLS channel binding data of `type` for `conn`.
    ///
    /// This call retrieves TLS channel binding data as specified in RFC
    /// [5056](https://tools.ietf.org/html/rfc5056), RFC
    /// [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
    /// binding data is returned in `data`.  The `data` is resized by the callee
    /// using `glib.ByteArray` buffer management and will be freed when the `data`
    /// is destroyed by `glib.byteArrayUnref`. If `data` is `NULL`, it will only
    /// check whether TLS backend is able to fetch the data (e.g. whether `type`
    /// is supported by the TLS backend). It does not guarantee that the data
    /// will be available though.  That could happen if TLS connection does not
    /// support `type` or the binding data is not available yet due to additional
    /// negotiation or input required.
    extern fn g_dtls_connection_get_channel_binding_data(p_conn: *DtlsConnection, p_type: gio.TlsChannelBindingType, p_data: ?*glib.ByteArray, p_error: ?*?*glib.Error) c_int;
    pub const getChannelBindingData = g_dtls_connection_get_channel_binding_data;

    /// Returns the name of the current DTLS ciphersuite, or `NULL` if the
    /// connection has not handshaked or has been closed. Beware that the TLS
    /// backend may use any of multiple different naming conventions, because
    /// OpenSSL and GnuTLS have their own ciphersuite naming conventions that
    /// are different from each other and different from the standard, IANA-
    /// registered ciphersuite names. The ciphersuite name is intended to be
    /// displayed to the user for informative purposes only, and parsing it
    /// is not recommended.
    extern fn g_dtls_connection_get_ciphersuite_name(p_conn: *DtlsConnection) ?[*:0]u8;
    pub const getCiphersuiteName = g_dtls_connection_get_ciphersuite_name;

    /// Gets the certificate database that `conn` uses to verify
    /// peer certificates. See `gio.DtlsConnection.setDatabase`.
    extern fn g_dtls_connection_get_database(p_conn: *DtlsConnection) ?*gio.TlsDatabase;
    pub const getDatabase = g_dtls_connection_get_database;

    /// Get the object that will be used to interact with the user. It will be used
    /// for things like prompting the user for passwords. If `NULL` is returned, then
    /// no user interaction will occur for this connection.
    extern fn g_dtls_connection_get_interaction(p_conn: *DtlsConnection) ?*gio.TlsInteraction;
    pub const getInteraction = g_dtls_connection_get_interaction;

    /// Gets the name of the application-layer protocol negotiated during
    /// the handshake.
    ///
    /// If the peer did not use the ALPN extension, or did not advertise a
    /// protocol that matched one of `conn`'s protocols, or the TLS backend
    /// does not support ALPN, then this will be `NULL`. See
    /// `gio.DtlsConnection.setAdvertisedProtocols`.
    extern fn g_dtls_connection_get_negotiated_protocol(p_conn: *DtlsConnection) ?[*:0]const u8;
    pub const getNegotiatedProtocol = g_dtls_connection_get_negotiated_protocol;

    /// Gets `conn`'s peer's certificate after the handshake has completed
    /// or failed. (It is not set during the emission of
    /// `gio.DtlsConnection.signals.accept`-certificate.)
    extern fn g_dtls_connection_get_peer_certificate(p_conn: *DtlsConnection) ?*gio.TlsCertificate;
    pub const getPeerCertificate = g_dtls_connection_get_peer_certificate;

    /// Gets the errors associated with validating `conn`'s peer's
    /// certificate, after the handshake has completed or failed. (It is
    /// not set during the emission of `gio.DtlsConnection.signals.accept`-certificate.)
    extern fn g_dtls_connection_get_peer_certificate_errors(p_conn: *DtlsConnection) gio.TlsCertificateFlags;
    pub const getPeerCertificateErrors = g_dtls_connection_get_peer_certificate_errors;

    /// Returns the current DTLS protocol version, which may be
    /// `G_TLS_PROTOCOL_VERSION_UNKNOWN` if the connection has not handshaked, or
    /// has been closed, or if the TLS backend has implemented a protocol version
    /// that is not a recognized `gio.TlsProtocolVersion`.
    extern fn g_dtls_connection_get_protocol_version(p_conn: *DtlsConnection) gio.TlsProtocolVersion;
    pub const getProtocolVersion = g_dtls_connection_get_protocol_version;

    /// Gets `conn` rehandshaking mode. See
    /// `gio.DtlsConnection.setRehandshakeMode` for details.
    extern fn g_dtls_connection_get_rehandshake_mode(p_conn: *DtlsConnection) gio.TlsRehandshakeMode;
    pub const getRehandshakeMode = g_dtls_connection_get_rehandshake_mode;

    /// Tests whether or not `conn` expects a proper TLS close notification
    /// when the connection is closed. See
    /// `gio.DtlsConnection.setRequireCloseNotify` for details.
    extern fn g_dtls_connection_get_require_close_notify(p_conn: *DtlsConnection) c_int;
    pub const getRequireCloseNotify = g_dtls_connection_get_require_close_notify;

    /// Attempts a TLS handshake on `conn`.
    ///
    /// On the client side, it is never necessary to call this method;
    /// although the connection needs to perform a handshake after
    /// connecting, `gio.DtlsConnection` will handle this for you automatically
    /// when you try to send or receive data on the connection. You can call
    /// `gio.DtlsConnection.handshake` manually if you want to know whether
    /// the initial handshake succeeded or failed (as opposed to just
    /// immediately trying to use `conn` to read or write, in which case,
    /// if it fails, it may not be possible to tell if it failed before
    /// or after completing the handshake), but beware that servers may reject
    /// client authentication after the handshake has completed, so a
    /// successful handshake does not indicate the connection will be usable.
    ///
    /// Likewise, on the server side, although a handshake is necessary at
    /// the beginning of the communication, you do not need to call this
    /// function explicitly unless you want clearer error reporting.
    ///
    /// Previously, calling `gio.DtlsConnection.handshake` after the initial
    /// handshake would trigger a rehandshake; however, this usage was
    /// deprecated in GLib 2.60 because rehandshaking was removed from the
    /// TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
    /// the initial handshake will no longer do anything.
    ///
    /// `gio.DtlsConnection.signals.accept_certificate` may be emitted during the
    /// handshake.
    extern fn g_dtls_connection_handshake(p_conn: *DtlsConnection, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const handshake = g_dtls_connection_handshake;

    /// Asynchronously performs a TLS handshake on `conn`. See
    /// `gio.DtlsConnection.handshake` for more information.
    extern fn g_dtls_connection_handshake_async(p_conn: *DtlsConnection, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const handshakeAsync = g_dtls_connection_handshake_async;

    /// Finish an asynchronous TLS handshake operation. See
    /// `gio.DtlsConnection.handshake` for more information.
    extern fn g_dtls_connection_handshake_finish(p_conn: *DtlsConnection, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const handshakeFinish = g_dtls_connection_handshake_finish;

    /// Sets the list of application-layer protocols to advertise that the
    /// caller is willing to speak on this connection. The
    /// Application-Layer Protocol Negotiation (ALPN) extension will be
    /// used to negotiate a compatible protocol with the peer; use
    /// `gio.DtlsConnection.getNegotiatedProtocol` to find the negotiated
    /// protocol after the handshake.  Specifying `NULL` for the the value
    /// of `protocols` will disable ALPN negotiation.
    ///
    /// See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml`alpn`-protocol-ids)
    /// for a list of registered protocol IDs.
    extern fn g_dtls_connection_set_advertised_protocols(p_conn: *DtlsConnection, p_protocols: ?[*]const [*:0]const u8) void;
    pub const setAdvertisedProtocols = g_dtls_connection_set_advertised_protocols;

    /// This sets the certificate that `conn` will present to its peer
    /// during the TLS handshake. For a `gio.DtlsServerConnection`, it is
    /// mandatory to set this, and that will normally be done at construct
    /// time.
    ///
    /// For a `gio.DtlsClientConnection`, this is optional. If a handshake fails
    /// with `G_TLS_ERROR_CERTIFICATE_REQUIRED`, that means that the server
    /// requires a certificate, and if you try connecting again, you should
    /// call this method first. You can call
    /// `gio.DtlsClientConnection.getAcceptedCas` on the failed connection
    /// to get a list of Certificate Authorities that the server will
    /// accept certificates from.
    ///
    /// (It is also possible that a server will allow the connection with
    /// or without a certificate; in that case, if you don't provide a
    /// certificate, you can tell that the server requested one by the fact
    /// that `gio.DtlsClientConnection.getAcceptedCas` will return
    /// non-`NULL`.)
    extern fn g_dtls_connection_set_certificate(p_conn: *DtlsConnection, p_certificate: *gio.TlsCertificate) void;
    pub const setCertificate = g_dtls_connection_set_certificate;

    /// Sets the certificate database that is used to verify peer certificates.
    /// This is set to the default database by default. See
    /// `gio.TlsBackend.getDefaultDatabase`. If set to `NULL`, then
    /// peer certificate validation will always set the
    /// `G_TLS_CERTIFICATE_UNKNOWN_CA` error (meaning
    /// `gio.DtlsConnection.signals.accept`-certificate will always be emitted on
    /// client-side connections, unless that bit is not set in
    /// `gio.DtlsClientConnection.properties.validation`-flags).
    ///
    /// There are nonintuitive security implications when using a non-default
    /// database. See `gio.DtlsConnection.properties.database` for details.
    extern fn g_dtls_connection_set_database(p_conn: *DtlsConnection, p_database: ?*gio.TlsDatabase) void;
    pub const setDatabase = g_dtls_connection_set_database;

    /// Set the object that will be used to interact with the user. It will be used
    /// for things like prompting the user for passwords.
    ///
    /// The `interaction` argument will normally be a derived subclass of
    /// `gio.TlsInteraction`. `NULL` can also be provided if no user interaction
    /// should occur for this connection.
    extern fn g_dtls_connection_set_interaction(p_conn: *DtlsConnection, p_interaction: ?*gio.TlsInteraction) void;
    pub const setInteraction = g_dtls_connection_set_interaction;

    /// Since GLib 2.64, changing the rehandshake mode is no longer supported
    /// and will have no effect. With TLS 1.3, rehandshaking has been removed from
    /// the TLS protocol, replaced by separate post-handshake authentication and
    /// rekey operations.
    extern fn g_dtls_connection_set_rehandshake_mode(p_conn: *DtlsConnection, p_mode: gio.TlsRehandshakeMode) void;
    pub const setRehandshakeMode = g_dtls_connection_set_rehandshake_mode;

    /// Sets whether or not `conn` expects a proper TLS close notification
    /// before the connection is closed. If this is `TRUE` (the default),
    /// then `conn` will expect to receive a TLS close notification from its
    /// peer before the connection is closed, and will return a
    /// `G_TLS_ERROR_EOF` error if the connection is closed without proper
    /// notification (since this may indicate a network error, or
    /// man-in-the-middle attack).
    ///
    /// In some protocols, the application will know whether or not the
    /// connection was closed cleanly based on application-level data
    /// (because the application-level data includes a length field, or is
    /// somehow self-delimiting); in this case, the close notify is
    /// redundant and may be omitted. You
    /// can use `gio.DtlsConnection.setRequireCloseNotify` to tell `conn`
    /// to allow an "unannounced" connection close, in which case the close
    /// will show up as a 0-length read, as in a non-TLS
    /// `gio.DatagramBased`, and it is up to the application to check that
    /// the data has been fully received.
    ///
    /// Note that this only affects the behavior when the peer closes the
    /// connection; when the application calls `gio.DtlsConnection.closeAsync` on
    /// `conn` itself, this will send a close notification regardless of the
    /// setting of this property. If you explicitly want to do an unclean
    /// close, you can close `conn`'s `gio.DtlsConnection.properties.base`-socket rather
    /// than closing `conn` itself.
    extern fn g_dtls_connection_set_require_close_notify(p_conn: *DtlsConnection, p_require_close_notify: c_int) void;
    pub const setRequireCloseNotify = g_dtls_connection_set_require_close_notify;

    /// Shut down part or all of a DTLS connection.
    ///
    /// If `shutdown_read` is `TRUE` then the receiving side of the connection is shut
    /// down, and further reading is disallowed. Subsequent calls to
    /// `gio.DatagramBased.receiveMessages` will return `G_IO_ERROR_CLOSED`.
    ///
    /// If `shutdown_write` is `TRUE` then the sending side of the connection is shut
    /// down, and further writing is disallowed. Subsequent calls to
    /// `gio.DatagramBased.sendMessages` will return `G_IO_ERROR_CLOSED`.
    ///
    /// It is allowed for both `shutdown_read` and `shutdown_write` to be TRUE — this
    /// is equivalent to calling `gio.DtlsConnection.close`.
    ///
    /// If `cancellable` is cancelled, the `gio.DtlsConnection` may be left
    /// partially-closed and any pending untransmitted data may be lost. Call
    /// `gio.DtlsConnection.shutdown` again to complete closing the `gio.DtlsConnection`.
    extern fn g_dtls_connection_shutdown(p_conn: *DtlsConnection, p_shutdown_read: c_int, p_shutdown_write: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const shutdown = g_dtls_connection_shutdown;

    /// Asynchronously shut down part or all of the DTLS connection. See
    /// `gio.DtlsConnection.shutdown` for more information.
    extern fn g_dtls_connection_shutdown_async(p_conn: *DtlsConnection, p_shutdown_read: c_int, p_shutdown_write: c_int, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const shutdownAsync = g_dtls_connection_shutdown_async;

    /// Finish an asynchronous TLS shutdown operation. See
    /// `gio.DtlsConnection.shutdown` for more information.
    extern fn g_dtls_connection_shutdown_finish(p_conn: *DtlsConnection, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const shutdownFinish = g_dtls_connection_shutdown_finish;

    extern fn g_dtls_connection_get_type() usize;
    pub const getGObjectType = g_dtls_connection_get_type;

    extern fn g_object_ref(p_self: *gio.DtlsConnection) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DtlsConnection) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DtlsConnection, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GDtlsServerConnection` is the server-side subclass of
/// `gio.DtlsConnection`, representing a server-side DTLS connection.
pub const DtlsServerConnection = opaque {
    pub const Prerequisites = [_]type{ gio.DatagramBased, gio.DtlsConnection };
    pub const Iface = gio.DtlsServerConnectionInterface;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The `gio.TlsAuthenticationMode` for the server. This can be changed
        /// before calling `gio.DtlsConnection.handshake` if you want to
        /// rehandshake with a different mode from the initial handshake.
        pub const authentication_mode = struct {
            pub const name = "authentication-mode";

            pub const Type = gio.TlsAuthenticationMode;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.DtlsServerConnection` wrapping `base_socket`.
    extern fn g_dtls_server_connection_new(p_base_socket: *gio.DatagramBased, p_certificate: ?*gio.TlsCertificate, p_error: ?*?*glib.Error) ?*gio.DtlsServerConnection;
    pub const new = g_dtls_server_connection_new;

    extern fn g_dtls_server_connection_get_type() usize;
    pub const getGObjectType = g_dtls_server_connection_get_type;

    extern fn g_object_ref(p_self: *gio.DtlsServerConnection) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.DtlsServerConnection) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *DtlsServerConnection, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GFile` is a high level abstraction for manipulating files on a
/// virtual file system. `GFile`s are lightweight, immutable objects
/// that do no I/O upon creation. It is necessary to understand that
/// `GFile` objects do not represent files, merely an identifier for a
/// file. All file content I/O is implemented as streaming operations
/// (see `gio.InputStream` and `gio.OutputStream`).
///
/// To construct a `GFile`, you can use:
///
/// - `gio.File.newForPath` if you have a path.
/// - `gio.File.newForUri` if you have a URI.
/// - `gio.File.newForCommandlineArg` or
///   `gio.File.newForCommandlineArgAndCwd` for a command line
///   argument.
/// - `gio.File.newTmp` to create a temporary file from a template.
/// - `gio.File.newTmpAsync` to asynchronously create a temporary file.
/// - `gio.File.newTmpDirAsync` to asynchronously create a temporary
///   directory.
/// - `gio.File.parseName` from a UTF-8 string gotten from
///   `gio.File.getParseName`.
/// - `gio.File.newBuildFilename` or `gio.File.newBuildFilenamev`
///   to create a file from path elements.
///
/// One way to think of a `GFile` is as an abstraction of a pathname. For
/// normal files the system pathname is what is stored internally, but as
/// `GFile`s are extensible it could also be something else that corresponds
/// to a pathname in a userspace implementation of a filesystem.
///
/// `GFile`s make up hierarchies of directories and files that correspond to
/// the files on a filesystem. You can move through the file system with
/// `GFile` using `gio.File.getParent` to get an identifier for the
/// parent directory, `gio.File.getChild` to get a child within a
/// directory, and `gio.File.resolveRelativePath` to resolve a relative
/// path between two `GFile`s. There can be multiple hierarchies, so you may not
/// end up at the same root if you repeatedly call `gio.File.getParent`
/// on two different files.
///
/// All `GFile`s have a basename (get with `gio.File.getBasename`). These
/// names are byte strings that are used to identify the file on the filesystem
/// (relative to its parent directory) and there is no guarantees that they
/// have any particular charset encoding or even make any sense at all. If
/// you want to use filenames in a user interface you should use the display
/// name that you can get by requesting the
/// `G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME` attribute with
/// `gio.File.queryInfo`. This is guaranteed to be in UTF-8 and can be
/// used in a user interface. But always store the real basename or the `GFile`
/// to use to actually access the file, because there is no way to go from a
/// display name to the actual name.
///
/// Using `GFile` as an identifier has the same weaknesses as using a path
/// in that there may be multiple aliases for the same file. For instance,
/// hard or soft links may cause two different `GFile`s to refer to the same
/// file. Other possible causes for aliases are: case insensitive filesystems,
/// short and long names on FAT/NTFS, or bind mounts in Linux. If you want to
/// check if two `GFile`s point to the same file you can query for the
/// `G_FILE_ATTRIBUTE_ID_FILE` attribute. Note that `GFile` does some trivial
/// canonicalization of pathnames passed in, so that trivial differences in
/// the path string used at creation (duplicated slashes, slash at end of
/// path, `.` or `..` path segments, etc) does not create different `GFile`s.
///
/// Many `GFile` operations have both synchronous and asynchronous versions
/// to suit your application. Asynchronous versions of synchronous functions
/// simply have ``_async`` appended to their function names. The asynchronous
/// I/O functions call a `gio.AsyncReadyCallback` which is then used to
/// finalize the operation, producing a `gio.AsyncResult` which is then
/// passed to the function’s matching ``_finish`` operation.
///
/// It is highly recommended to use asynchronous calls when running within a
/// shared main loop, such as in the main thread of an application. This avoids
/// I/O operations blocking other sources on the main loop from being dispatched.
/// Synchronous I/O operations should be performed from worker threads. See the
/// [introduction to asynchronous programming section](overview.html`asynchronous`-programming)
/// for more.
///
/// Some `GFile` operations almost always take a noticeable amount of time, and
/// so do not have synchronous analogs. Notable cases include:
///
/// - `gio.File.mountMountable` to mount a mountable file.
/// - `gio.File.unmountMountableWithOperation` to unmount a mountable
///   file.
/// - `gio.File.ejectMountableWithOperation` to eject a mountable file.
///
/// ## Entity Tags
///
/// One notable feature of `GFile`s are entity tags, or ‘etags’ for
/// short. Entity tags are somewhat like a more abstract version of the
/// traditional mtime, and can be used to quickly determine if the file
/// has been modified from the version on the file system. See the
/// HTTP 1.1
/// [specification](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)
/// for HTTP `ETag` headers, which are a very similar concept.
pub const File = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.FileIface;
    pub const virtual_methods = struct {
        /// Gets an output stream for appending data to the file.
        /// If the file doesn't already exist it is created.
        ///
        /// By default files created are generally readable by everyone,
        /// but if you pass `G_FILE_CREATE_PRIVATE` in `flags` the file
        /// will be made readable only to the current user, to the level that
        /// is supported on the target filesystem.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled
        /// by triggering the cancellable object from another thread. If the
        /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
        /// returned.
        ///
        /// Some file systems don't allow all file names, and may return an
        /// `G_IO_ERROR_INVALID_FILENAME` error. If the file is a directory the
        /// `G_IO_ERROR_IS_DIRECTORY` error will be returned. Other errors are
        /// possible too, and depend on what kind of filesystem the file is on.
        pub const append_to = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileOutputStream {
                return gobject.ext.as(File.Iface, p_class).f_append_to.?(gobject.ext.as(File, p_file), p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileOutputStream) void {
                gobject.ext.as(File.Iface, p_class).f_append_to = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously opens `file` for appending.
        ///
        /// For more details, see `gio.File.appendTo` which is
        /// the synchronous version of this call.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.appendToFinish` to get the result
        /// of the operation.
        pub const append_to_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_append_to_async.?(gobject.ext.as(File, p_file), p_flags, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_append_to_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous file append operation started with
        /// `gio.File.appendToAsync`.
        pub const append_to_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileOutputStream {
                return gobject.ext.as(File.Iface, p_class).f_append_to_finish.?(gobject.ext.as(File, p_file), p_res, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileOutputStream) void {
                gobject.ext.as(File.Iface, p_class).f_append_to_finish = @ptrCast(p_implementation);
            }
        };

        /// Copies the file `source` to the location specified by `destination`.
        /// Can not handle recursive copies of directories.
        ///
        /// If the flag `G_FILE_COPY_OVERWRITE` is specified an already
        /// existing `destination` file is overwritten.
        ///
        /// If the flag `G_FILE_COPY_NOFOLLOW_SYMLINKS` is specified then symlinks
        /// will be copied as symlinks, otherwise the target of the
        /// `source` symlink will be copied.
        ///
        /// If the flag `G_FILE_COPY_ALL_METADATA` is specified then all the metadata
        /// that is possible to copy is copied, not just the default subset (which,
        /// for instance, does not include the owner, see `gio.FileInfo`).
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        ///
        /// If `progress_callback` is not `NULL`, then the operation can be monitored
        /// by setting this to a `gio.FileProgressCallback` function.
        /// `progress_callback_data` will be passed to this function. It is guaranteed
        /// that this callback will be called after all data has been transferred with
        /// the total number of bytes copied during the operation.
        ///
        /// If the `source` file does not exist, then the `G_IO_ERROR_NOT_FOUND` error
        /// is returned, independent on the status of the `destination`.
        ///
        /// If `G_FILE_COPY_OVERWRITE` is not specified and the target exists, then
        /// the error `G_IO_ERROR_EXISTS` is returned.
        ///
        /// If trying to overwrite a file over a directory, the `G_IO_ERROR_IS_DIRECTORY`
        /// error is returned. If trying to overwrite a directory with a directory the
        /// `G_IO_ERROR_WOULD_MERGE` error is returned.
        ///
        /// If the source is a directory and the target does not exist, or
        /// `G_FILE_COPY_OVERWRITE` is specified and the target is a file, then the
        /// `G_IO_ERROR_WOULD_RECURSE` error is returned.
        ///
        /// If you are interested in copying the `gio.File` object itself (not the on-disk
        /// file), see `gio.File.dup`.
        pub const copy = struct {
            pub fn call(p_class: anytype, p_source: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_copy.?(gobject.ext.as(File, p_source), p_destination, p_flags, p_cancellable, p_progress_callback, p_progress_callback_data, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_source: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_copy = @ptrCast(p_implementation);
            }
        };

        /// Copies the file `source` to the location specified by `destination`
        /// asynchronously. For details of the behaviour, see `gio.File.copy`.
        ///
        /// If `progress_callback` is not `NULL`, then that function that will be called
        /// just like in `gio.File.copy`. The callback will run in the default main context
        /// of the thread calling `gio.File.copyAsync` — the same context as `callback` is
        /// run in.
        ///
        /// When the operation is finished, `callback` will be called. You can then call
        /// `gio.File.copyFinish` to get the result of the operation.
        pub const copy_async = struct {
            pub fn call(p_class: anytype, p_source: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_copy_async.?(gobject.ext.as(File, p_source), p_destination, p_flags, p_io_priority, p_cancellable, p_progress_callback, p_progress_callback_data, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_source: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_copy_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes copying the file started with `gio.File.copyAsync`.
        pub const copy_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_copy_finish.?(gobject.ext.as(File, p_file), p_res, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_copy_finish = @ptrCast(p_implementation);
            }
        };

        /// Creates a new file and returns an output stream for writing to it.
        /// The file must not already exist.
        ///
        /// By default files created are generally readable by everyone,
        /// but if you pass `G_FILE_CREATE_PRIVATE` in `flags` the file
        /// will be made readable only to the current user, to the level
        /// that is supported on the target filesystem.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled
        /// by triggering the cancellable object from another thread. If the
        /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
        /// returned.
        ///
        /// If a file or directory with this name already exists the
        /// `G_IO_ERROR_EXISTS` error will be returned. Some file systems don't
        /// allow all file names, and may return an `G_IO_ERROR_INVALID_FILENAME`
        /// error, and if the name is to long `G_IO_ERROR_FILENAME_TOO_LONG` will
        /// be returned. Other errors are possible too, and depend on what kind
        /// of filesystem the file is on.
        pub const create = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileOutputStream {
                return gobject.ext.as(File.Iface, p_class).f_create.?(gobject.ext.as(File, p_file), p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileOutputStream) void {
                gobject.ext.as(File.Iface, p_class).f_create = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously creates a new file and returns an output stream
        /// for writing to it. The file must not already exist.
        ///
        /// For more details, see `gio.File.create` which is
        /// the synchronous version of this call.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.createFinish` to get the result
        /// of the operation.
        pub const create_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_create_async.?(gobject.ext.as(File, p_file), p_flags, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_create_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous file create operation started with
        /// `gio.File.createAsync`.
        pub const create_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileOutputStream {
                return gobject.ext.as(File.Iface, p_class).f_create_finish.?(gobject.ext.as(File, p_file), p_res, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileOutputStream) void {
                gobject.ext.as(File.Iface, p_class).f_create_finish = @ptrCast(p_implementation);
            }
        };

        /// Creates a new file and returns a stream for reading and
        /// writing to it. The file must not already exist.
        ///
        /// By default files created are generally readable by everyone,
        /// but if you pass `G_FILE_CREATE_PRIVATE` in `flags` the file
        /// will be made readable only to the current user, to the level
        /// that is supported on the target filesystem.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled
        /// by triggering the cancellable object from another thread. If the
        /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
        /// returned.
        ///
        /// If a file or directory with this name already exists, the
        /// `G_IO_ERROR_EXISTS` error will be returned. Some file systems don't
        /// allow all file names, and may return an `G_IO_ERROR_INVALID_FILENAME`
        /// error, and if the name is too long, `G_IO_ERROR_FILENAME_TOO_LONG`
        /// will be returned. Other errors are possible too, and depend on what
        /// kind of filesystem the file is on.
        ///
        /// Note that in many non-local file cases read and write streams are
        /// not supported, so make sure you really need to do read and write
        /// streaming, rather than just opening for reading or writing.
        pub const create_readwrite = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileIOStream {
                return gobject.ext.as(File.Iface, p_class).f_create_readwrite.?(gobject.ext.as(File, p_file), p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileIOStream) void {
                gobject.ext.as(File.Iface, p_class).f_create_readwrite = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously creates a new file and returns a stream
        /// for reading and writing to it. The file must not already exist.
        ///
        /// For more details, see `gio.File.createReadwrite` which is
        /// the synchronous version of this call.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.createReadwriteFinish` to get
        /// the result of the operation.
        pub const create_readwrite_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_create_readwrite_async.?(gobject.ext.as(File, p_file), p_flags, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_create_readwrite_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous file create operation started with
        /// `gio.File.createReadwriteAsync`.
        pub const create_readwrite_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileIOStream {
                return gobject.ext.as(File.Iface, p_class).f_create_readwrite_finish.?(gobject.ext.as(File, p_file), p_res, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileIOStream) void {
                gobject.ext.as(File.Iface, p_class).f_create_readwrite_finish = @ptrCast(p_implementation);
            }
        };

        /// Deletes a file. If the `file` is a directory, it will only be
        /// deleted if it is empty. This has the same semantics as `glib.unlink`.
        ///
        /// If `file` doesn’t exist, `G_IO_ERROR_NOT_FOUND` will be returned. This allows
        /// for deletion to be implemented avoiding
        /// [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
        /// ```
        /// g_autoptr(GError) local_error = NULL;
        /// if (!g_file_delete (my_file, my_cancellable, &local_error) &&
        ///     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
        ///   {
        ///     // deletion failed for some reason other than the file not existing:
        ///     // so report the error
        ///     g_warning ("Failed to delete `s`: `s`",
        ///                g_file_peek_path (my_file), local_error->message);
        ///   }
        /// ```
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        pub const delete_file = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_delete_file.?(gobject.ext.as(File, p_file), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_delete_file = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously delete a file. If the `file` is a directory, it will
        /// only be deleted if it is empty.  This has the same semantics as
        /// `glib.unlink`.
        pub const delete_file_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_delete_file_async.?(gobject.ext.as(File, p_file), p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_delete_file_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes deleting a file started with `gio.File.deleteAsync`.
        pub const delete_file_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_delete_file_finish.?(gobject.ext.as(File, p_file), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_delete_file_finish = @ptrCast(p_implementation);
            }
        };

        /// Duplicates a `gio.File` handle. This operation does not duplicate
        /// the actual file or directory represented by the `gio.File`; see
        /// `gio.File.copy` if attempting to copy a file.
        ///
        /// `gio.File.dup` is useful when a second handle is needed to the same underlying
        /// file, for use in a separate thread (`gio.File` is not thread-safe). For use
        /// within the same thread, use `gobject.Object.ref` to increment the existing object’s
        /// reference count.
        ///
        /// This call does no blocking I/O.
        pub const dup = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.File {
                return gobject.ext.as(File.Iface, p_class).f_dup.?(gobject.ext.as(File, p_file));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.File) void {
                gobject.ext.as(File.Iface, p_class).f_dup = @ptrCast(p_implementation);
            }
        };

        /// Starts an asynchronous eject on a mountable.
        /// When this operation has completed, `callback` will be called with
        /// `user_user` data, and the operation can be finalized with
        /// `gio.File.ejectMountableFinish`.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        pub const eject_mountable = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_eject_mountable.?(gobject.ext.as(File, p_file), p_flags, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_eject_mountable = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous eject operation started by
        /// `gio.File.ejectMountable`.
        pub const eject_mountable_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_eject_mountable_finish.?(gobject.ext.as(File, p_file), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_eject_mountable_finish = @ptrCast(p_implementation);
            }
        };

        /// Starts an asynchronous eject on a mountable.
        /// When this operation has completed, `callback` will be called with
        /// `user_user` data, and the operation can be finalized with
        /// `gio.File.ejectMountableWithOperationFinish`.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        pub const eject_mountable_with_operation = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_eject_mountable_with_operation.?(gobject.ext.as(File, p_file), p_flags, p_mount_operation, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_eject_mountable_with_operation = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous eject operation started by
        /// `gio.File.ejectMountableWithOperation`.
        pub const eject_mountable_with_operation_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_eject_mountable_with_operation_finish.?(gobject.ext.as(File, p_file), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_eject_mountable_with_operation_finish = @ptrCast(p_implementation);
            }
        };

        /// Gets the requested information about the files in a directory.
        /// The result is a `gio.FileEnumerator` object that will give out
        /// `gio.FileInfo` objects for all the files in the directory.
        ///
        /// The `attributes` value is a string that specifies the file
        /// attributes that should be gathered. It is not an error if
        /// it's not possible to read a particular requested attribute
        /// from a file - it just won't be set. `attributes` should
        /// be a comma-separated list of attributes or attribute wildcards.
        /// The wildcard "*" means all attributes, and a wildcard like
        /// "standard::*" means all attributes in the standard namespace.
        /// An example attribute query be "standard::*,owner::user".
        /// The standard attributes are available as defines, like
        /// `G_FILE_ATTRIBUTE_STANDARD_NAME`. `G_FILE_ATTRIBUTE_STANDARD_NAME` should
        /// always be specified if you plan to call `gio.FileEnumerator.getChild` or
        /// `gio.FileEnumerator.iterate` on the returned enumerator.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled
        /// by triggering the cancellable object from another thread. If the
        /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
        /// returned.
        ///
        /// If the file does not exist, the `G_IO_ERROR_NOT_FOUND` error will
        /// be returned. If the file is not a directory, the `G_IO_ERROR_NOT_DIRECTORY`
        /// error will be returned. Other errors are possible too.
        pub const enumerate_children = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileEnumerator {
                return gobject.ext.as(File.Iface, p_class).f_enumerate_children.?(gobject.ext.as(File, p_file), p_attributes, p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileEnumerator) void {
                gobject.ext.as(File.Iface, p_class).f_enumerate_children = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously gets the requested information about the files
        /// in a directory. The result is a `gio.FileEnumerator` object that will
        /// give out `gio.FileInfo` objects for all the files in the directory.
        ///
        /// For more details, see `gio.File.enumerateChildren` which is
        /// the synchronous version of this call.
        ///
        /// When the operation is finished, `callback` will be called. You can
        /// then call `gio.File.enumerateChildrenFinish` to get the result of
        /// the operation.
        pub const enumerate_children_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_enumerate_children_async.?(gobject.ext.as(File, p_file), p_attributes, p_flags, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_enumerate_children_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an async enumerate children operation.
        /// See `gio.File.enumerateChildrenAsync`.
        pub const enumerate_children_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileEnumerator {
                return gobject.ext.as(File.Iface, p_class).f_enumerate_children_finish.?(gobject.ext.as(File, p_file), p_res, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileEnumerator) void {
                gobject.ext.as(File.Iface, p_class).f_enumerate_children_finish = @ptrCast(p_implementation);
            }
        };

        /// Checks if the two given `GFiles` refer to the same file.
        ///
        /// Note that two `GFiles` that differ can still refer to the same
        /// file on the filesystem due to various forms of filename
        /// aliasing.
        ///
        /// This call does no blocking I/O.
        pub const equal = struct {
            pub fn call(p_class: anytype, p_file1: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_file2: *gio.File) c_int {
                return gobject.ext.as(File.Iface, p_class).f_equal.?(gobject.ext.as(File, p_file1), p_file2);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file1: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_file2: *gio.File) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_equal = @ptrCast(p_implementation);
            }
        };

        /// Gets a `gio.Mount` for the `gio.File`.
        ///
        /// `gio.Mount` is returned only for user interesting locations, see
        /// `gio.VolumeMonitor`. If the `gio.FileIface` for `file` does not have a `mount`,
        /// `error` will be set to `G_IO_ERROR_NOT_FOUND` and `NULL` `will` be returned.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        pub const find_enclosing_mount = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.Mount {
                return gobject.ext.as(File.Iface, p_class).f_find_enclosing_mount.?(gobject.ext.as(File, p_file), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.Mount) void {
                gobject.ext.as(File.Iface, p_class).f_find_enclosing_mount = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously gets the mount for the file.
        ///
        /// For more details, see `gio.File.findEnclosingMount` which is
        /// the synchronous version of this call.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.findEnclosingMountFinish` to
        /// get the result of the operation.
        pub const find_enclosing_mount_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_find_enclosing_mount_async.?(gobject.ext.as(File, p_file), p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_find_enclosing_mount_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous find mount request.
        /// See `gio.File.findEnclosingMountAsync`.
        pub const find_enclosing_mount_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.Mount {
                return gobject.ext.as(File.Iface, p_class).f_find_enclosing_mount_finish.?(gobject.ext.as(File, p_file), p_res, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.Mount) void {
                gobject.ext.as(File.Iface, p_class).f_find_enclosing_mount_finish = @ptrCast(p_implementation);
            }
        };

        /// Gets the base name (the last component of the path) for a given `gio.File`.
        ///
        /// If called for the top level of a system (such as the filesystem root
        /// or a uri like sftp://host/) it will return a single directory separator
        /// (and on Windows, possibly a drive letter).
        ///
        /// The base name is a byte string (not UTF-8). It has no defined encoding
        /// or rules other than it may not contain zero bytes.  If you want to use
        /// filenames in a user interface you should use the display name that you
        /// can get by requesting the `G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME`
        /// attribute with `gio.File.queryInfo`.
        ///
        /// This call does no blocking I/O.
        pub const get_basename = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]u8 {
                return gobject.ext.as(File.Iface, p_class).f_get_basename.?(gobject.ext.as(File, p_file));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]u8) void {
                gobject.ext.as(File.Iface, p_class).f_get_basename = @ptrCast(p_implementation);
            }
        };

        /// Gets the child of `file` for a given `display_name` (i.e. a UTF-8
        /// version of the name). If this function fails, it returns `NULL`
        /// and `error` will be set. This is very useful when constructing a
        /// `gio.File` for a new file and the user entered the filename in the
        /// user interface, for instance when you select a directory and
        /// type a filename in the file selector.
        ///
        /// This call does no blocking I/O.
        pub const get_child_for_display_name = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_display_name: [*:0]const u8, p_error: ?*?*glib.Error) ?*gio.File {
                return gobject.ext.as(File.Iface, p_class).f_get_child_for_display_name.?(gobject.ext.as(File, p_file), p_display_name, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_display_name: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) ?*gio.File) void {
                gobject.ext.as(File.Iface, p_class).f_get_child_for_display_name = @ptrCast(p_implementation);
            }
        };

        /// Gets the parent directory for the `file`.
        /// If the `file` represents the root directory of the
        /// file system, then `NULL` will be returned.
        ///
        /// This call does no blocking I/O.
        pub const get_parent = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*gio.File {
                return gobject.ext.as(File.Iface, p_class).f_get_parent.?(gobject.ext.as(File, p_file));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*gio.File) void {
                gobject.ext.as(File.Iface, p_class).f_get_parent = @ptrCast(p_implementation);
            }
        };

        /// Gets the parse name of the `file`.
        /// A parse name is a UTF-8 string that describes the
        /// file such that one can get the `gio.File` back using
        /// `gio.fileParseName`.
        ///
        /// This is generally used to show the `gio.File` as a nice
        /// full-pathname kind of string in a user interface,
        /// like in a location entry.
        ///
        /// For local files with names that can safely be converted
        /// to UTF-8 the pathname is used, otherwise the IRI is used
        /// (a form of URI that allows UTF-8 characters unescaped).
        ///
        /// This call does no blocking I/O.
        pub const get_parse_name = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]u8 {
                return gobject.ext.as(File.Iface, p_class).f_get_parse_name.?(gobject.ext.as(File, p_file));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]u8) void {
                gobject.ext.as(File.Iface, p_class).f_get_parse_name = @ptrCast(p_implementation);
            }
        };

        /// Gets the local pathname for `gio.File`, if one exists. If non-`NULL`, this is
        /// guaranteed to be an absolute, canonical path. It might contain symlinks.
        ///
        /// This call does no blocking I/O.
        pub const get_path = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]u8 {
                return gobject.ext.as(File.Iface, p_class).f_get_path.?(gobject.ext.as(File, p_file));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]u8) void {
                gobject.ext.as(File.Iface, p_class).f_get_path = @ptrCast(p_implementation);
            }
        };

        /// Gets the path for `descendant` relative to `parent`.
        ///
        /// This call does no blocking I/O.
        pub const get_relative_path = struct {
            pub fn call(p_class: anytype, p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_descendant: *gio.File) ?[*:0]u8 {
                return gobject.ext.as(File.Iface, p_class).f_get_relative_path.?(gobject.ext.as(File, p_parent), p_descendant);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_parent: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_descendant: *gio.File) callconv(.c) ?[*:0]u8) void {
                gobject.ext.as(File.Iface, p_class).f_get_relative_path = @ptrCast(p_implementation);
            }
        };

        /// Gets the URI for the `file`.
        ///
        /// This call does no blocking I/O.
        pub const get_uri = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]u8 {
                return gobject.ext.as(File.Iface, p_class).f_get_uri.?(gobject.ext.as(File, p_file));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]u8) void {
                gobject.ext.as(File.Iface, p_class).f_get_uri = @ptrCast(p_implementation);
            }
        };

        /// Gets the URI scheme for a `gio.File`.
        /// RFC 3986 decodes the scheme as:
        /// ```
        /// URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
        /// ```
        /// Common schemes include "file", "http", "ftp", etc.
        ///
        /// The scheme can be different from the one used to construct the `gio.File`,
        /// in that it might be replaced with one that is logically equivalent to the `gio.File`.
        ///
        /// This call does no blocking I/O.
        pub const get_uri_scheme = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]u8 {
                return gobject.ext.as(File.Iface, p_class).f_get_uri_scheme.?(gobject.ext.as(File, p_file));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]u8) void {
                gobject.ext.as(File.Iface, p_class).f_get_uri_scheme = @ptrCast(p_implementation);
            }
        };

        /// Checks to see if a `gio.File` has a given URI scheme.
        ///
        /// This call does no blocking I/O.
        pub const has_uri_scheme = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri_scheme: [*:0]const u8) c_int {
                return gobject.ext.as(File.Iface, p_class).f_has_uri_scheme.?(gobject.ext.as(File, p_file), p_uri_scheme);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri_scheme: [*:0]const u8) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_has_uri_scheme = @ptrCast(p_implementation);
            }
        };

        /// Creates a hash value for a `gio.File`.
        ///
        /// This call does no blocking I/O.
        pub const hash = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_uint {
                return gobject.ext.as(File.Iface, p_class).f_hash.?(gobject.ext.as(File, p_file));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_uint) void {
                gobject.ext.as(File.Iface, p_class).f_hash = @ptrCast(p_implementation);
            }
        };

        /// Checks to see if a file is native to the platform.
        ///
        /// A native file is one expressed in the platform-native filename format,
        /// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
        /// as it might be on a locally mounted remote filesystem.
        ///
        /// On some systems non-native files may be available using the native
        /// filesystem via a userspace filesystem (FUSE), in these cases this call
        /// will return `FALSE`, but `gio.File.getPath` will still return a native path.
        ///
        /// This call does no blocking I/O.
        pub const is_native = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(File.Iface, p_class).f_is_native.?(gobject.ext.as(File, p_file));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_is_native = @ptrCast(p_implementation);
            }
        };

        /// Creates a directory. Note that this will only create a child directory
        /// of the immediate parent directory of the path or URI given by the `gio.File`.
        /// To recursively create directories, see `gio.File.makeDirectoryWithParents`.
        /// This function will fail if the parent directory does not exist, setting
        /// `error` to `G_IO_ERROR_NOT_FOUND`. If the file system doesn't support
        /// creating directories, this function will fail, setting `error` to
        /// `G_IO_ERROR_NOT_SUPPORTED`.
        ///
        /// For a local `gio.File` the newly created directory will have the default
        /// (current) ownership and permissions of the current process.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        pub const make_directory = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_make_directory.?(gobject.ext.as(File, p_file), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_make_directory = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously creates a directory.
        pub const make_directory_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_make_directory_async.?(gobject.ext.as(File, p_file), p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_make_directory_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous directory creation, started with
        /// `gio.File.makeDirectoryAsync`.
        pub const make_directory_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_make_directory_finish.?(gobject.ext.as(File, p_file), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_make_directory_finish = @ptrCast(p_implementation);
            }
        };

        /// Creates a symbolic link named `file` which contains the string
        /// `symlink_value`.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        pub const make_symbolic_link = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_symlink_value: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_make_symbolic_link.?(gobject.ext.as(File, p_file), p_symlink_value, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_symlink_value: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_make_symbolic_link = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously creates a symbolic link named `file` which contains the
        /// string `symlink_value`.
        pub const make_symbolic_link_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_symlink_value: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_make_symbolic_link_async.?(gobject.ext.as(File, p_file), p_symlink_value, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_symlink_value: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_make_symbolic_link_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous symbolic link creation, started with
        /// `gio.File.makeSymbolicLinkAsync`.
        pub const make_symbolic_link_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_make_symbolic_link_finish.?(gobject.ext.as(File, p_file), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_make_symbolic_link_finish = @ptrCast(p_implementation);
            }
        };

        /// Recursively measures the disk usage of `file`.
        ///
        /// This is essentially an analog of the 'du' command, but it also
        /// reports the number of directories and non-directory files encountered
        /// (including things like symbolic links).
        ///
        /// By default, errors are only reported against the toplevel file
        /// itself.  Errors found while recursing are silently ignored, unless
        /// `G_FILE_MEASURE_REPORT_ANY_ERROR` is given in `flags`.
        ///
        /// The returned size, `disk_usage`, is in bytes and should be formatted
        /// with `glib.formatSize` in order to get something reasonable for showing
        /// in a user interface.
        ///
        /// `progress_callback` and `progress_data` can be given to request
        /// periodic progress updates while scanning.  See the documentation for
        /// `gio.FileMeasureProgressCallback` for information about when and how the
        /// callback will be invoked.
        pub const measure_disk_usage = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileMeasureFlags, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileMeasureProgressCallback, p_progress_data: ?*anyopaque, p_disk_usage: ?*u64, p_num_dirs: ?*u64, p_num_files: ?*u64, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_measure_disk_usage.?(gobject.ext.as(File, p_file), p_flags, p_cancellable, p_progress_callback, p_progress_data, p_disk_usage, p_num_dirs, p_num_files, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileMeasureFlags, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileMeasureProgressCallback, p_progress_data: ?*anyopaque, p_disk_usage: ?*u64, p_num_dirs: ?*u64, p_num_files: ?*u64, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_measure_disk_usage = @ptrCast(p_implementation);
            }
        };

        /// Recursively measures the disk usage of `file`.
        ///
        /// This is the asynchronous version of `gio.File.measureDiskUsage`.  See
        /// there for more information.
        pub const measure_disk_usage_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileMeasureFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileMeasureProgressCallback, p_progress_data: ?*anyopaque, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_measure_disk_usage_async.?(gobject.ext.as(File, p_file), p_flags, p_io_priority, p_cancellable, p_progress_callback, p_progress_data, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileMeasureFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileMeasureProgressCallback, p_progress_data: ?*anyopaque, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_measure_disk_usage_async = @ptrCast(p_implementation);
            }
        };

        /// Collects the results from an earlier call to
        /// `gio.File.measureDiskUsageAsync`.  See `gio.File.measureDiskUsage` for
        /// more information.
        pub const measure_disk_usage_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_disk_usage: ?*u64, p_num_dirs: ?*u64, p_num_files: ?*u64, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_measure_disk_usage_finish.?(gobject.ext.as(File, p_file), p_result, p_disk_usage, p_num_dirs, p_num_files, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_disk_usage: ?*u64, p_num_dirs: ?*u64, p_num_files: ?*u64, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_measure_disk_usage_finish = @ptrCast(p_implementation);
            }
        };

        /// Obtains a directory monitor for the given file.
        /// This may fail if directory monitoring is not supported.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        ///
        /// It does not make sense for `flags` to contain
        /// `G_FILE_MONITOR_WATCH_HARD_LINKS`, since hard links can not be made to
        /// directories.  It is not possible to monitor all the files in a
        /// directory for changes made via hard links; if you want to do this then
        /// you must register individual watches with `gio.File.monitor`.
        pub const monitor_dir = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileMonitorFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileMonitor {
                return gobject.ext.as(File.Iface, p_class).f_monitor_dir.?(gobject.ext.as(File, p_file), p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileMonitorFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileMonitor) void {
                gobject.ext.as(File.Iface, p_class).f_monitor_dir = @ptrCast(p_implementation);
            }
        };

        /// Obtains a file monitor for the given file. If no file notification
        /// mechanism exists, then regular polling of the file is used.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        ///
        /// If `flags` contains `G_FILE_MONITOR_WATCH_HARD_LINKS` then the monitor
        /// will also attempt to report changes made to the file via another
        /// filename (ie, a hard link). Without this flag, you can only rely on
        /// changes made through the filename contained in `file` to be
        /// reported. Using this flag may result in an increase in resource
        /// usage, and may not have any effect depending on the `gio.FileMonitor`
        /// backend and/or filesystem type.
        pub const monitor_file = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileMonitorFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileMonitor {
                return gobject.ext.as(File.Iface, p_class).f_monitor_file.?(gobject.ext.as(File, p_file), p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.FileMonitorFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileMonitor) void {
                gobject.ext.as(File.Iface, p_class).f_monitor_file = @ptrCast(p_implementation);
            }
        };

        /// Starts a `mount_operation`, mounting the volume that contains
        /// the file `location`.
        ///
        /// When this operation has completed, `callback` will be called with
        /// `user_user` data, and the operation can be finalized with
        /// `gio.File.mountEnclosingVolumeFinish`.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        pub const mount_enclosing_volume = struct {
            pub fn call(p_class: anytype, p_location: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_mount_enclosing_volume.?(gobject.ext.as(File, p_location), p_flags, p_mount_operation, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_location: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_mount_enclosing_volume = @ptrCast(p_implementation);
            }
        };

        /// Finishes a mount operation started by `gio.File.mountEnclosingVolume`.
        pub const mount_enclosing_volume_finish = struct {
            pub fn call(p_class: anytype, p_location: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_mount_enclosing_volume_finish.?(gobject.ext.as(File, p_location), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_location: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_mount_enclosing_volume_finish = @ptrCast(p_implementation);
            }
        };

        /// Mounts a file of type G_FILE_TYPE_MOUNTABLE.
        /// Using `mount_operation`, you can request callbacks when, for instance,
        /// passwords are needed during authentication.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.mountMountableFinish` to get
        /// the result of the operation.
        pub const mount_mountable = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_mount_mountable.?(gobject.ext.as(File, p_file), p_flags, p_mount_operation, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_mount_mountable = @ptrCast(p_implementation);
            }
        };

        /// Finishes a mount operation. See `gio.File.mountMountable` for details.
        ///
        /// Finish an asynchronous mount operation that was started
        /// with `gio.File.mountMountable`.
        pub const mount_mountable_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.File {
                return gobject.ext.as(File.Iface, p_class).f_mount_mountable_finish.?(gobject.ext.as(File, p_file), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.File) void {
                gobject.ext.as(File.Iface, p_class).f_mount_mountable_finish = @ptrCast(p_implementation);
            }
        };

        /// Tries to move the file or directory `source` to the location specified
        /// by `destination`. If native move operations are supported then this is
        /// used, otherwise a copy + delete fallback is used. The native
        /// implementation may support moving directories (for instance on moves
        /// inside the same filesystem), but the fallback code does not.
        ///
        /// If the flag `G_FILE_COPY_OVERWRITE` is specified an already
        /// existing `destination` file is overwritten.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        ///
        /// If `progress_callback` is not `NULL`, then the operation can be monitored
        /// by setting this to a `gio.FileProgressCallback` function.
        /// `progress_callback_data` will be passed to this function. It is
        /// guaranteed that this callback will be called after all data has been
        /// transferred with the total number of bytes copied during the operation.
        ///
        /// If the `source` file does not exist, then the `G_IO_ERROR_NOT_FOUND`
        /// error is returned, independent on the status of the `destination`.
        ///
        /// If `G_FILE_COPY_OVERWRITE` is not specified and the target exists,
        /// then the error `G_IO_ERROR_EXISTS` is returned.
        ///
        /// If trying to overwrite a file over a directory, the `G_IO_ERROR_IS_DIRECTORY`
        /// error is returned. If trying to overwrite a directory with a directory the
        /// `G_IO_ERROR_WOULD_MERGE` error is returned.
        ///
        /// If the source is a directory and the target does not exist, or
        /// `G_FILE_COPY_OVERWRITE` is specified and the target is a file, then
        /// the `G_IO_ERROR_WOULD_RECURSE` error may be returned (if the native
        /// move operation isn't available).
        pub const move = struct {
            pub fn call(p_class: anytype, p_source: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_move.?(gobject.ext.as(File, p_source), p_destination, p_flags, p_cancellable, p_progress_callback, p_progress_callback_data, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_source: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_move = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously moves a file `source` to the location of `destination`. For details of the behaviour, see `gio.File.move`.
        ///
        /// If `progress_callback` is not `NULL`, then that function that will be called
        /// just like in `gio.File.move`. The callback will run in the default main context
        /// of the thread calling `gio.File.moveAsync` — the same context as `callback` is
        /// run in.
        ///
        /// When the operation is finished, `callback` will be called. You can then call
        /// `gio.File.moveFinish` to get the result of the operation.
        pub const move_async = struct {
            pub fn call(p_class: anytype, p_source: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_move_async.?(gobject.ext.as(File, p_source), p_destination, p_flags, p_io_priority, p_cancellable, p_progress_callback, p_progress_callback_data, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_source: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_move_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous file movement, started with
        /// `gio.File.moveAsync`.
        pub const move_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_move_finish.?(gobject.ext.as(File, p_file), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_move_finish = @ptrCast(p_implementation);
            }
        };

        /// Opens an existing file for reading and writing. The result is
        /// a `gio.FileIOStream` that can be used to read and write the contents
        /// of the file.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled
        /// by triggering the cancellable object from another thread. If the
        /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
        /// returned.
        ///
        /// If the file does not exist, the `G_IO_ERROR_NOT_FOUND` error will
        /// be returned. If the file is a directory, the `G_IO_ERROR_IS_DIRECTORY`
        /// error will be returned. Other errors are possible too, and depend on
        /// what kind of filesystem the file is on. Note that in many non-local
        /// file cases read and write streams are not supported, so make sure you
        /// really need to do read and write streaming, rather than just opening
        /// for reading or writing.
        pub const open_readwrite = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileIOStream {
                return gobject.ext.as(File.Iface, p_class).f_open_readwrite.?(gobject.ext.as(File, p_file), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileIOStream) void {
                gobject.ext.as(File.Iface, p_class).f_open_readwrite = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously opens `file` for reading and writing.
        ///
        /// For more details, see `gio.File.openReadwrite` which is
        /// the synchronous version of this call.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.openReadwriteFinish` to get
        /// the result of the operation.
        pub const open_readwrite_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_open_readwrite_async.?(gobject.ext.as(File, p_file), p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_open_readwrite_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous file read operation started with
        /// `gio.File.openReadwriteAsync`.
        pub const open_readwrite_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileIOStream {
                return gobject.ext.as(File.Iface, p_class).f_open_readwrite_finish.?(gobject.ext.as(File, p_file), p_res, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileIOStream) void {
                gobject.ext.as(File.Iface, p_class).f_open_readwrite_finish = @ptrCast(p_implementation);
            }
        };

        /// Polls a file of type `G_FILE_TYPE_MOUNTABLE`.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.mountMountableFinish` to get
        /// the result of the operation.
        pub const poll_mountable = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_poll_mountable.?(gobject.ext.as(File, p_file), p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_poll_mountable = @ptrCast(p_implementation);
            }
        };

        /// Finishes a poll operation. See `gio.File.pollMountable` for details.
        ///
        /// Finish an asynchronous poll operation that was polled
        /// with `gio.File.pollMountable`.
        pub const poll_mountable_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_poll_mountable_finish.?(gobject.ext.as(File, p_file), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_poll_mountable_finish = @ptrCast(p_implementation);
            }
        };

        /// Checks whether `file` has the prefix specified by `prefix`.
        ///
        /// In other words, if the names of initial elements of `file`'s
        /// pathname match `prefix`. Only full pathname elements are matched,
        /// so a path like /foo is not considered a prefix of /foobar, only
        /// of /foo/bar.
        ///
        /// A `gio.File` is not a prefix of itself. If you want to check for
        /// equality, use `gio.File.equal`.
        ///
        /// This call does no I/O, as it works purely on names. As such it can
        /// sometimes return `FALSE` even if `file` is inside a `prefix` (from a
        /// filesystem point of view), because the prefix of `file` is an alias
        /// of `prefix`.
        pub const prefix_matches = struct {
            pub fn call(p_class: anytype, p_prefix: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_file: *gio.File) c_int {
                return gobject.ext.as(File.Iface, p_class).f_prefix_matches.?(gobject.ext.as(File, p_prefix), p_file);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_prefix: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_file: *gio.File) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_prefix_matches = @ptrCast(p_implementation);
            }
        };

        /// Utility function to check if a particular file exists.
        ///
        /// The fallback implementation of this API is using `gio.File.queryInfo`
        /// and therefore may do blocking I/O. To asynchronously query the existence
        /// of a file, use `gio.File.queryInfoAsync`.
        ///
        /// Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
        /// and then execute something based on the outcome of that, because the
        /// file might have been created or removed in between the operations. The
        /// general approach to handling that is to not check, but just do the
        /// operation and handle the errors as they come.
        ///
        /// As an example of race-free checking, take the case of reading a file,
        /// and if it doesn't exist, creating it. There are two racy versions: read
        /// it, and on error create it; and: check if it exists, if not create it.
        /// These can both result in two processes creating the file (with perhaps
        /// a partially written file as the result). The correct approach is to
        /// always try to create the file with `gio.File.create` which will either
        /// atomically create the file or fail with a `G_IO_ERROR_EXISTS` error.
        ///
        /// However, in many cases an existence check is useful in a user interface,
        /// for instance to make a menu item sensitive/insensitive, so that you don't
        /// have to fool users that something is possible and then just show an error
        /// dialog. If you do this, you should make sure to also handle the errors
        /// that can happen due to races when you execute the operation.
        pub const query_exists = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable) c_int {
                return gobject.ext.as(File.Iface, p_class).f_query_exists.?(gobject.ext.as(File, p_file), p_cancellable);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_query_exists = @ptrCast(p_implementation);
            }
        };

        /// Similar to `gio.File.queryInfo`, but obtains information
        /// about the filesystem the `file` is on, rather than the file itself.
        /// For instance the amount of space available and the type of
        /// the filesystem.
        ///
        /// The `attributes` value is a string that specifies the attributes
        /// that should be gathered. It is not an error if it's not possible
        /// to read a particular requested attribute from a file - it just
        /// won't be set. `attributes` should be a comma-separated list of
        /// attributes or attribute wildcards. The wildcard "*" means all
        /// attributes, and a wildcard like "filesystem::*" means all attributes
        /// in the filesystem namespace. The standard namespace for filesystem
        /// attributes is "filesystem". Common attributes of interest are
        /// `G_FILE_ATTRIBUTE_FILESYSTEM_SIZE` (the total size of the filesystem
        /// in bytes), `G_FILE_ATTRIBUTE_FILESYSTEM_FREE` (number of bytes available),
        /// and `G_FILE_ATTRIBUTE_FILESYSTEM_TYPE` (type of the filesystem).
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled
        /// by triggering the cancellable object from another thread. If the
        /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
        /// returned.
        ///
        /// If the file does not exist, the `G_IO_ERROR_NOT_FOUND` error will
        /// be returned. Other errors are possible too, and depend on what
        /// kind of filesystem the file is on.
        pub const query_filesystem_info = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileInfo {
                return gobject.ext.as(File.Iface, p_class).f_query_filesystem_info.?(gobject.ext.as(File, p_file), p_attributes, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo) void {
                gobject.ext.as(File.Iface, p_class).f_query_filesystem_info = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously gets the requested information about the filesystem
        /// that the specified `file` is on. The result is a `gio.FileInfo` object
        /// that contains key-value attributes (such as type or size for the
        /// file).
        ///
        /// For more details, see `gio.File.queryFilesystemInfo` which is the
        /// synchronous version of this call.
        ///
        /// When the operation is finished, `callback` will be called. You can
        /// then call `gio.File.queryInfoFinish` to get the result of the
        /// operation.
        pub const query_filesystem_info_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_query_filesystem_info_async.?(gobject.ext.as(File, p_file), p_attributes, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_query_filesystem_info_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous filesystem info query.
        /// See `gio.File.queryFilesystemInfoAsync`.
        pub const query_filesystem_info_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileInfo {
                return gobject.ext.as(File.Iface, p_class).f_query_filesystem_info_finish.?(gobject.ext.as(File, p_file), p_res, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo) void {
                gobject.ext.as(File.Iface, p_class).f_query_filesystem_info_finish = @ptrCast(p_implementation);
            }
        };

        /// Gets the requested information about specified `file`.
        /// The result is a `gio.FileInfo` object that contains key-value
        /// attributes (such as the type or size of the file).
        ///
        /// The `attributes` value is a string that specifies the file
        /// attributes that should be gathered. It is not an error if
        /// it's not possible to read a particular requested attribute
        /// from a file - it just won't be set. `attributes` should be a
        /// comma-separated list of attributes or attribute wildcards.
        /// The wildcard "*" means all attributes, and a wildcard like
        /// "standard::*" means all attributes in the standard namespace.
        /// An example attribute query be "standard::*,owner::user".
        /// The standard attributes are available as defines, like
        /// `G_FILE_ATTRIBUTE_STANDARD_NAME`.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled
        /// by triggering the cancellable object from another thread. If the
        /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
        /// returned.
        ///
        /// For symlinks, normally the information about the target of the
        /// symlink is returned, rather than information about the symlink
        /// itself. However if you pass `G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS`
        /// in `flags` the information about the symlink itself will be returned.
        /// Also, for symlinks that point to non-existing files the information
        /// about the symlink itself will be returned.
        ///
        /// If the file does not exist, the `G_IO_ERROR_NOT_FOUND` error will be
        /// returned. Other errors are possible too, and depend on what kind of
        /// filesystem the file is on.
        pub const query_info = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileInfo {
                return gobject.ext.as(File.Iface, p_class).f_query_info.?(gobject.ext.as(File, p_file), p_attributes, p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo) void {
                gobject.ext.as(File.Iface, p_class).f_query_info = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously gets the requested information about specified `file`.
        /// The result is a `gio.FileInfo` object that contains key-value attributes
        /// (such as type or size for the file).
        ///
        /// For more details, see `gio.File.queryInfo` which is the synchronous
        /// version of this call.
        ///
        /// When the operation is finished, `callback` will be called. You can
        /// then call `gio.File.queryInfoFinish` to get the result of the operation.
        pub const query_info_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_query_info_async.?(gobject.ext.as(File, p_file), p_attributes, p_flags, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_query_info_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous file info query.
        /// See `gio.File.queryInfoAsync`.
        pub const query_info_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileInfo {
                return gobject.ext.as(File.Iface, p_class).f_query_info_finish.?(gobject.ext.as(File, p_file), p_res, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo) void {
                gobject.ext.as(File.Iface, p_class).f_query_info_finish = @ptrCast(p_implementation);
            }
        };

        /// Obtain the list of settable attributes for the file.
        ///
        /// Returns the type and full attribute name of all the attributes
        /// that can be set on this file. This doesn't mean setting it will
        /// always succeed though, you might get an access failure, or some
        /// specific file may not support a specific attribute.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        pub const query_settable_attributes = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileAttributeInfoList {
                return gobject.ext.as(File.Iface, p_class).f_query_settable_attributes.?(gobject.ext.as(File, p_file), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileAttributeInfoList) void {
                gobject.ext.as(File.Iface, p_class).f_query_settable_attributes = @ptrCast(p_implementation);
            }
        };

        /// Obtain the list of attribute namespaces where new attributes
        /// can be created by a user. An example of this is extended
        /// attributes (in the "xattr" namespace).
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        pub const query_writable_namespaces = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileAttributeInfoList {
                return gobject.ext.as(File.Iface, p_class).f_query_writable_namespaces.?(gobject.ext.as(File, p_file), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileAttributeInfoList) void {
                gobject.ext.as(File.Iface, p_class).f_query_writable_namespaces = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously opens `file` for reading.
        ///
        /// For more details, see `gio.File.read` which is
        /// the synchronous version of this call.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.readFinish` to get the result
        /// of the operation.
        pub const read_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_read_async.?(gobject.ext.as(File, p_file), p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_read_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous file read operation started with
        /// `gio.File.readAsync`.
        pub const read_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileInputStream {
                return gobject.ext.as(File.Iface, p_class).f_read_finish.?(gobject.ext.as(File, p_file), p_res, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInputStream) void {
                gobject.ext.as(File.Iface, p_class).f_read_finish = @ptrCast(p_implementation);
            }
        };

        /// Opens a file for reading. The result is a `gio.FileInputStream` that
        /// can be used to read the contents of the file.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        ///
        /// If the file does not exist, the `G_IO_ERROR_NOT_FOUND` error will be
        /// returned. If the file is a directory, the `G_IO_ERROR_IS_DIRECTORY`
        /// error will be returned. Other errors are possible too, and depend
        /// on what kind of filesystem the file is on.
        pub const read_fn = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileInputStream {
                return gobject.ext.as(File.Iface, p_class).f_read_fn.?(gobject.ext.as(File, p_file), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInputStream) void {
                gobject.ext.as(File.Iface, p_class).f_read_fn = @ptrCast(p_implementation);
            }
        };

        /// Returns an output stream for overwriting the file, possibly
        /// creating a backup copy of the file first. If the file doesn't exist,
        /// it will be created.
        ///
        /// This will try to replace the file in the safest way possible so
        /// that any errors during the writing will not affect an already
        /// existing copy of the file. For instance, for local files it
        /// may write to a temporary file and then atomically rename over
        /// the destination when the stream is closed.
        ///
        /// By default files created are generally readable by everyone,
        /// but if you pass `G_FILE_CREATE_PRIVATE` in `flags` the file
        /// will be made readable only to the current user, to the level that
        /// is supported on the target filesystem.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled
        /// by triggering the cancellable object from another thread. If the
        /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
        /// returned.
        ///
        /// If you pass in a non-`NULL` `etag` value and `file` already exists, then
        /// this value is compared to the current entity tag of the file, and if
        /// they differ an `G_IO_ERROR_WRONG_ETAG` error is returned. This
        /// generally means that the file has been changed since you last read
        /// it. You can get the new etag from `gio.FileOutputStream.getEtag`
        /// after you've finished writing and closed the `gio.FileOutputStream`. When
        /// you load a new file you can use `gio.FileInputStream.queryInfo` to
        /// get the etag of the file.
        ///
        /// If `make_backup` is `TRUE`, this function will attempt to make a
        /// backup of the current file before overwriting it. If this fails
        /// a `G_IO_ERROR_CANT_CREATE_BACKUP` error will be returned. If you
        /// want to replace anyway, try again with `make_backup` set to `FALSE`.
        ///
        /// If the file is a directory the `G_IO_ERROR_IS_DIRECTORY` error will
        /// be returned, and if the file is some other form of non-regular file
        /// then a `G_IO_ERROR_NOT_REGULAR_FILE` error will be returned. Some
        /// file systems don't allow all file names, and may return an
        /// `G_IO_ERROR_INVALID_FILENAME` error, and if the name is to long
        /// `G_IO_ERROR_FILENAME_TOO_LONG` will be returned. Other errors are
        /// possible too, and depend on what kind of filesystem the file is on.
        pub const replace = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileOutputStream {
                return gobject.ext.as(File.Iface, p_class).f_replace.?(gobject.ext.as(File, p_file), p_etag, p_make_backup, p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileOutputStream) void {
                gobject.ext.as(File.Iface, p_class).f_replace = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously overwrites the file, replacing the contents,
        /// possibly creating a backup copy of the file first.
        ///
        /// For more details, see `gio.File.replace` which is
        /// the synchronous version of this call.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.replaceFinish` to get the result
        /// of the operation.
        pub const replace_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_replace_async.?(gobject.ext.as(File, p_file), p_etag, p_make_backup, p_flags, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_replace_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous file replace operation started with
        /// `gio.File.replaceAsync`.
        pub const replace_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileOutputStream {
                return gobject.ext.as(File.Iface, p_class).f_replace_finish.?(gobject.ext.as(File, p_file), p_res, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileOutputStream) void {
                gobject.ext.as(File.Iface, p_class).f_replace_finish = @ptrCast(p_implementation);
            }
        };

        /// Returns an output stream for overwriting the file in readwrite mode,
        /// possibly creating a backup copy of the file first. If the file doesn't
        /// exist, it will be created.
        ///
        /// For details about the behaviour, see `gio.File.replace` which does the
        /// same thing but returns an output stream only.
        ///
        /// Note that in many non-local file cases read and write streams are not
        /// supported, so make sure you really need to do read and write streaming,
        /// rather than just opening for reading or writing.
        pub const replace_readwrite = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileIOStream {
                return gobject.ext.as(File.Iface, p_class).f_replace_readwrite.?(gobject.ext.as(File, p_file), p_etag, p_make_backup, p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileIOStream) void {
                gobject.ext.as(File.Iface, p_class).f_replace_readwrite = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously overwrites the file in read-write mode,
        /// replacing the contents, possibly creating a backup copy
        /// of the file first.
        ///
        /// For more details, see `gio.File.replaceReadwrite` which is
        /// the synchronous version of this call.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.replaceReadwriteFinish` to get
        /// the result of the operation.
        pub const replace_readwrite_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_replace_readwrite_async.?(gobject.ext.as(File, p_file), p_etag, p_make_backup, p_flags, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_replace_readwrite_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous file replace operation started with
        /// `gio.File.replaceReadwriteAsync`.
        pub const replace_readwrite_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileIOStream {
                return gobject.ext.as(File.Iface, p_class).f_replace_readwrite_finish.?(gobject.ext.as(File, p_file), p_res, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileIOStream) void {
                gobject.ext.as(File.Iface, p_class).f_replace_readwrite_finish = @ptrCast(p_implementation);
            }
        };

        /// Resolves a relative path for `file` to an absolute path.
        ///
        /// This call does no blocking I/O.
        ///
        /// If the `relative_path` is an absolute path name, the resolution
        /// is done absolutely (without taking `file` path as base).
        pub const resolve_relative_path = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_relative_path: [*:0]const u8) *gio.File {
                return gobject.ext.as(File.Iface, p_class).f_resolve_relative_path.?(gobject.ext.as(File, p_file), p_relative_path);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_relative_path: [*:0]const u8) callconv(.c) *gio.File) void {
                gobject.ext.as(File.Iface, p_class).f_resolve_relative_path = @ptrCast(p_implementation);
            }
        };

        /// Sets an attribute in the file with attribute name `attribute` to `value_p`.
        ///
        /// Some attributes can be unset by setting `type` to
        /// `G_FILE_ATTRIBUTE_TYPE_INVALID` and `value_p` to `NULL`.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        pub const set_attribute = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attribute: [*:0]const u8, p_type: gio.FileAttributeType, p_value_p: ?*anyopaque, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_set_attribute.?(gobject.ext.as(File, p_file), p_attribute, p_type, p_value_p, p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_attribute: [*:0]const u8, p_type: gio.FileAttributeType, p_value_p: ?*anyopaque, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_set_attribute = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously sets the attributes of `file` with `info`.
        ///
        /// For more details, see `gio.File.setAttributesFromInfo`,
        /// which is the synchronous version of this call.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.setAttributesFinish` to get
        /// the result of the operation.
        pub const set_attributes_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_info: *gio.FileInfo, p_flags: gio.FileQueryInfoFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_set_attributes_async.?(gobject.ext.as(File, p_file), p_info, p_flags, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_info: *gio.FileInfo, p_flags: gio.FileQueryInfoFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_set_attributes_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes setting an attribute started in `gio.File.setAttributesAsync`.
        pub const set_attributes_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_info: **gio.FileInfo, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_set_attributes_finish.?(gobject.ext.as(File, p_file), p_result, p_info, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_info: **gio.FileInfo, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_set_attributes_finish = @ptrCast(p_implementation);
            }
        };

        /// Tries to set all attributes in the `gio.FileInfo` on the target
        /// values, not stopping on the first error.
        ///
        /// If there is any error during this operation then `error` will
        /// be set to the first error. Error on particular fields are flagged
        /// by setting the "status" field in the attribute value to
        /// `G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING`, which means you can
        /// also detect further errors.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        pub const set_attributes_from_info = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_info: *gio.FileInfo, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_set_attributes_from_info.?(gobject.ext.as(File, p_file), p_info, p_flags, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_info: *gio.FileInfo, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_set_attributes_from_info = @ptrCast(p_implementation);
            }
        };

        /// Renames `file` to the specified display name.
        ///
        /// The display name is converted from UTF-8 to the correct encoding
        /// for the target filesystem if possible and the `file` is renamed to this.
        ///
        /// If you want to implement a rename operation in the user interface the
        /// edit name (`G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME`) should be used as the
        /// initial value in the rename widget, and then the result after editing
        /// should be passed to `gio.File.setDisplayName`.
        ///
        /// On success the resulting converted filename is returned.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        pub const set_display_name = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_display_name: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.File {
                return gobject.ext.as(File.Iface, p_class).f_set_display_name.?(gobject.ext.as(File, p_file), p_display_name, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_display_name: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.File) void {
                gobject.ext.as(File.Iface, p_class).f_set_display_name = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously sets the display name for a given `gio.File`.
        ///
        /// For more details, see `gio.File.setDisplayName` which is
        /// the synchronous version of this call.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.setDisplayNameFinish` to get
        /// the result of the operation.
        pub const set_display_name_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_display_name: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_set_display_name_async.?(gobject.ext.as(File, p_file), p_display_name, p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_display_name: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_set_display_name_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes setting a display name started with
        /// `gio.File.setDisplayNameAsync`.
        pub const set_display_name_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.File {
                return gobject.ext.as(File.Iface, p_class).f_set_display_name_finish.?(gobject.ext.as(File, p_file), p_res, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.File) void {
                gobject.ext.as(File.Iface, p_class).f_set_display_name_finish = @ptrCast(p_implementation);
            }
        };

        /// Starts a file of type `G_FILE_TYPE_MOUNTABLE`.
        /// Using `start_operation`, you can request callbacks when, for instance,
        /// passwords are needed during authentication.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.mountMountableFinish` to get
        /// the result of the operation.
        pub const start_mountable = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.DriveStartFlags, p_start_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_start_mountable.?(gobject.ext.as(File, p_file), p_flags, p_start_operation, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.DriveStartFlags, p_start_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_start_mountable = @ptrCast(p_implementation);
            }
        };

        /// Finishes a start operation. See `gio.File.startMountable` for details.
        ///
        /// Finish an asynchronous start operation that was started
        /// with `gio.File.startMountable`.
        pub const start_mountable_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_start_mountable_finish.?(gobject.ext.as(File, p_file), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_start_mountable_finish = @ptrCast(p_implementation);
            }
        };

        /// Stops a file of type `G_FILE_TYPE_MOUNTABLE`.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.stopMountableFinish` to get
        /// the result of the operation.
        pub const stop_mountable = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_stop_mountable.?(gobject.ext.as(File, p_file), p_flags, p_mount_operation, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_stop_mountable = @ptrCast(p_implementation);
            }
        };

        /// Finishes a stop operation, see `gio.File.stopMountable` for details.
        ///
        /// Finish an asynchronous stop operation that was started
        /// with `gio.File.stopMountable`.
        pub const stop_mountable_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_stop_mountable_finish.?(gobject.ext.as(File, p_file), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_stop_mountable_finish = @ptrCast(p_implementation);
            }
        };

        /// Sends `file` to the "Trashcan", if possible. This is similar to
        /// deleting it, but the user can recover it before emptying the trashcan.
        /// Trashing is disabled for system mounts by default (see
        /// `gio.UnixMountEntry.isSystemInternal`), so this call can return the
        /// `G_IO_ERROR_NOT_SUPPORTED` error. Since GLib 2.66, the `x-gvfs-notrash` unix
        /// mount option can be used to disable `gio.File.trash` support for particular
        /// mounts, the `G_IO_ERROR_NOT_SUPPORTED` error will be returned in that case.
        /// Since 2.82, the `x-gvfs-trash` unix mount option can be used to enable
        /// `gio.File.trash` support for particular system mounts.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        pub const trash = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_trash.?(gobject.ext.as(File, p_file), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_trash = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously sends `file` to the Trash location, if possible.
        pub const trash_async = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_trash_async.?(gobject.ext.as(File, p_file), p_io_priority, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_trash_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous file trashing operation, started with
        /// `gio.File.trashAsync`.
        pub const trash_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_trash_finish.?(gobject.ext.as(File, p_file), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_trash_finish = @ptrCast(p_implementation);
            }
        };

        /// Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.unmountMountableFinish` to get
        /// the result of the operation.
        pub const unmount_mountable = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_unmount_mountable.?(gobject.ext.as(File, p_file), p_flags, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_unmount_mountable = @ptrCast(p_implementation);
            }
        };

        /// Finishes an unmount operation, see `gio.File.unmountMountable` for details.
        ///
        /// Finish an asynchronous unmount operation that was started
        /// with `gio.File.unmountMountable`.
        pub const unmount_mountable_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_unmount_mountable_finish.?(gobject.ext.as(File, p_file), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_unmount_mountable_finish = @ptrCast(p_implementation);
            }
        };

        /// Unmounts a file of type `G_FILE_TYPE_MOUNTABLE`.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.File.unmountMountableFinish` to get
        /// the result of the operation.
        pub const unmount_mountable_with_operation = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(File.Iface, p_class).f_unmount_mountable_with_operation.?(gobject.ext.as(File, p_file), p_flags, p_mount_operation, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(File.Iface, p_class).f_unmount_mountable_with_operation = @ptrCast(p_implementation);
            }
        };

        /// Finishes an unmount operation,
        /// see `gio.File.unmountMountableWithOperation` for details.
        ///
        /// Finish an asynchronous unmount operation that was started
        /// with `gio.File.unmountMountableWithOperation`.
        pub const unmount_mountable_with_operation_finish = struct {
            pub fn call(p_class: anytype, p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(File.Iface, p_class).f_unmount_mountable_with_operation_finish.?(gobject.ext.as(File, p_file), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_file: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(File.Iface, p_class).f_unmount_mountable_with_operation_finish = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Constructs a `gio.File` from a series of elements using the correct
    /// separator for filenames.
    ///
    /// Using this function is equivalent to calling `glib.buildFilename`,
    /// followed by `gio.fileNewForPath` on the result.
    extern fn g_file_new_build_filename(p_first_element: [*:0]const u8, ...) *gio.File;
    pub const newBuildFilename = g_file_new_build_filename;

    /// Constructs a `gio.File` from a vector of elements using the correct
    /// separator for filenames.
    ///
    /// Using this function is equivalent to calling `glib.buildFilenamev`,
    /// followed by `gio.fileNewForPath` on the result.
    extern fn g_file_new_build_filenamev(p_args: [*]const [*:0]const u8) *gio.File;
    pub const newBuildFilenamev = g_file_new_build_filenamev;

    /// Creates a `gio.File` with the given argument from the command line.
    /// The value of `arg` can be either a URI, an absolute path or a
    /// relative path resolved relative to the current working directory.
    /// This operation never fails, but the returned object might not
    /// support any I/O operation if `arg` points to a malformed path.
    ///
    /// Note that on Windows, this function expects its argument to be in
    /// UTF-8 -- not the system code page.  This means that you
    /// should not use this function with string from argv as it is passed
    /// to `main`.  `g_win32_get_command_line` will return a UTF-8 version of
    /// the commandline.  `gio.Application` also uses UTF-8 but
    /// `gio.ApplicationCommandLine.createFileForArg` may be more useful
    /// for you there.  It is also always possible to use this function with
    /// `glib.OptionContext` arguments of type `G_OPTION_ARG_FILENAME`.
    extern fn g_file_new_for_commandline_arg(p_arg: [*:0]const u8) *gio.File;
    pub const newForCommandlineArg = g_file_new_for_commandline_arg;

    /// Creates a `gio.File` with the given argument from the command line.
    ///
    /// This function is similar to `gio.fileNewForCommandlineArg` except
    /// that it allows for passing the current working directory as an
    /// argument instead of using the current working directory of the
    /// process.
    ///
    /// This is useful if the commandline argument was given in a context
    /// other than the invocation of the current process.
    ///
    /// See also `gio.ApplicationCommandLine.createFileForArg`.
    extern fn g_file_new_for_commandline_arg_and_cwd(p_arg: [*:0]const u8, p_cwd: [*:0]const u8) *gio.File;
    pub const newForCommandlineArgAndCwd = g_file_new_for_commandline_arg_and_cwd;

    /// Constructs a `gio.File` for a given path. This operation never
    /// fails, but the returned object might not support any I/O
    /// operation if `path` is malformed.
    extern fn g_file_new_for_path(p_path: [*:0]const u8) *gio.File;
    pub const newForPath = g_file_new_for_path;

    /// Constructs a `gio.File` for a given URI. This operation never
    /// fails, but the returned object might not support any I/O
    /// operation if `uri` is malformed or if the uri type is
    /// not supported.
    extern fn g_file_new_for_uri(p_uri: [*:0]const u8) *gio.File;
    pub const newForUri = g_file_new_for_uri;

    /// Opens a file in the preferred directory for temporary files (as
    /// returned by `glib.getTmpDir`) and returns a `gio.File` and
    /// `gio.FileIOStream` pointing to it.
    ///
    /// `tmpl` should be a string in the GLib file name encoding
    /// containing a sequence of six 'X' characters, and containing no
    /// directory components. If it is `NULL`, a default template is used.
    ///
    /// Unlike the other `gio.File` constructors, this will return `NULL` if
    /// a temporary file could not be created.
    extern fn g_file_new_tmp(p_tmpl: ?[*:0]const u8, p_iostream: **gio.FileIOStream, p_error: ?*?*glib.Error) ?*gio.File;
    pub const newTmp = g_file_new_tmp;

    /// Asynchronously opens a file in the preferred directory for temporary files
    ///  (as returned by `glib.getTmpDir`) as `gio.fileNewTmp`.
    ///
    /// `tmpl` should be a string in the GLib file name encoding
    /// containing a sequence of six 'X' characters, and containing no
    /// directory components. If it is `NULL`, a default template is used.
    extern fn g_file_new_tmp_async(p_tmpl: ?[*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const newTmpAsync = g_file_new_tmp_async;

    /// Asynchronously creates a directory in the preferred directory for
    /// temporary files (as returned by `glib.getTmpDir`) as `glib.dirMakeTmp`.
    ///
    /// `tmpl` should be a string in the GLib file name encoding
    /// containing a sequence of six 'X' characters, and containing no
    /// directory components. If it is `NULL`, a default template is used.
    extern fn g_file_new_tmp_dir_async(p_tmpl: ?[*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const newTmpDirAsync = g_file_new_tmp_dir_async;

    /// Finishes a temporary directory creation started by
    /// `gio.fileNewTmpDirAsync`.
    extern fn g_file_new_tmp_dir_finish(p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.File;
    pub const newTmpDirFinish = g_file_new_tmp_dir_finish;

    /// Finishes a temporary file creation started by `gio.fileNewTmpAsync`.
    extern fn g_file_new_tmp_finish(p_result: *gio.AsyncResult, p_iostream: **gio.FileIOStream, p_error: ?*?*glib.Error) ?*gio.File;
    pub const newTmpFinish = g_file_new_tmp_finish;

    /// Constructs a `gio.File` with the given `parse_name` (i.e. something
    /// given by `gio.File.getParseName`). This operation never fails,
    /// but the returned object might not support any I/O operation if
    /// the `parse_name` cannot be parsed.
    extern fn g_file_parse_name(p_parse_name: [*:0]const u8) *gio.File;
    pub const parseName = g_file_parse_name;

    /// Gets an output stream for appending data to the file.
    /// If the file doesn't already exist it is created.
    ///
    /// By default files created are generally readable by everyone,
    /// but if you pass `G_FILE_CREATE_PRIVATE` in `flags` the file
    /// will be made readable only to the current user, to the level that
    /// is supported on the target filesystem.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled
    /// by triggering the cancellable object from another thread. If the
    /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
    /// returned.
    ///
    /// Some file systems don't allow all file names, and may return an
    /// `G_IO_ERROR_INVALID_FILENAME` error. If the file is a directory the
    /// `G_IO_ERROR_IS_DIRECTORY` error will be returned. Other errors are
    /// possible too, and depend on what kind of filesystem the file is on.
    extern fn g_file_append_to(p_file: *File, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileOutputStream;
    pub const appendTo = g_file_append_to;

    /// Asynchronously opens `file` for appending.
    ///
    /// For more details, see `gio.File.appendTo` which is
    /// the synchronous version of this call.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.appendToFinish` to get the result
    /// of the operation.
    extern fn g_file_append_to_async(p_file: *File, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const appendToAsync = g_file_append_to_async;

    /// Finishes an asynchronous file append operation started with
    /// `gio.File.appendToAsync`.
    extern fn g_file_append_to_finish(p_file: *File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileOutputStream;
    pub const appendToFinish = g_file_append_to_finish;

    /// Prepares the file attribute query string for copying to `file`.
    ///
    /// This function prepares an attribute query string to be
    /// passed to `gio.File.queryInfo` to get a list of attributes
    /// normally copied with the file (see `gio.File.copyAttributes`
    /// for the detailed description). This function is used by the
    /// implementation of `gio.File.copyAttributes` and is useful
    /// when one needs to query and set the attributes in two
    /// stages (e.g., for recursive move of a directory).
    extern fn g_file_build_attribute_list_for_copy(p_file: *File, p_flags: gio.FileCopyFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?[*:0]u8;
    pub const buildAttributeListForCopy = g_file_build_attribute_list_for_copy;

    /// Copies the file `source` to the location specified by `destination`.
    /// Can not handle recursive copies of directories.
    ///
    /// If the flag `G_FILE_COPY_OVERWRITE` is specified an already
    /// existing `destination` file is overwritten.
    ///
    /// If the flag `G_FILE_COPY_NOFOLLOW_SYMLINKS` is specified then symlinks
    /// will be copied as symlinks, otherwise the target of the
    /// `source` symlink will be copied.
    ///
    /// If the flag `G_FILE_COPY_ALL_METADATA` is specified then all the metadata
    /// that is possible to copy is copied, not just the default subset (which,
    /// for instance, does not include the owner, see `gio.FileInfo`).
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    ///
    /// If `progress_callback` is not `NULL`, then the operation can be monitored
    /// by setting this to a `gio.FileProgressCallback` function.
    /// `progress_callback_data` will be passed to this function. It is guaranteed
    /// that this callback will be called after all data has been transferred with
    /// the total number of bytes copied during the operation.
    ///
    /// If the `source` file does not exist, then the `G_IO_ERROR_NOT_FOUND` error
    /// is returned, independent on the status of the `destination`.
    ///
    /// If `G_FILE_COPY_OVERWRITE` is not specified and the target exists, then
    /// the error `G_IO_ERROR_EXISTS` is returned.
    ///
    /// If trying to overwrite a file over a directory, the `G_IO_ERROR_IS_DIRECTORY`
    /// error is returned. If trying to overwrite a directory with a directory the
    /// `G_IO_ERROR_WOULD_MERGE` error is returned.
    ///
    /// If the source is a directory and the target does not exist, or
    /// `G_FILE_COPY_OVERWRITE` is specified and the target is a file, then the
    /// `G_IO_ERROR_WOULD_RECURSE` error is returned.
    ///
    /// If you are interested in copying the `gio.File` object itself (not the on-disk
    /// file), see `gio.File.dup`.
    extern fn g_file_copy(p_source: *File, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_error: ?*?*glib.Error) c_int;
    pub const copy = g_file_copy;

    /// Copies the file `source` to the location specified by `destination`
    /// asynchronously. For details of the behaviour, see `gio.File.copy`.
    ///
    /// If `progress_callback` is not `NULL`, then that function that will be called
    /// just like in `gio.File.copy`. The callback will run in the default main context
    /// of the thread calling `gio.File.copyAsync` — the same context as `callback` is
    /// run in.
    ///
    /// When the operation is finished, `callback` will be called. You can then call
    /// `gio.File.copyFinish` to get the result of the operation.
    extern fn g_file_copy_async(p_source: *File, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const copyAsync = g_file_copy_async;

    /// Version of `gio.File.copyAsync` using closures instead of callbacks for
    /// easier binding in other languages.
    extern fn g_file_copy_async_with_closures(p_source: *File, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_progress_callback_closure: ?*gobject.Closure, p_ready_callback_closure: *gobject.Closure) void;
    pub const copyAsyncWithClosures = g_file_copy_async_with_closures;

    /// Copies the file attributes from `source` to `destination`.
    ///
    /// Normally only a subset of the file attributes are copied,
    /// those that are copies in a normal file copy operation
    /// (which for instance does not include e.g. owner). However
    /// if `G_FILE_COPY_ALL_METADATA` is specified in `flags`, then
    /// all the metadata that is possible to copy is copied. This
    /// is useful when implementing move by copy + delete source.
    extern fn g_file_copy_attributes(p_source: *File, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const copyAttributes = g_file_copy_attributes;

    /// Finishes copying the file started with `gio.File.copyAsync`.
    extern fn g_file_copy_finish(p_file: *File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const copyFinish = g_file_copy_finish;

    /// Creates a new file and returns an output stream for writing to it.
    /// The file must not already exist.
    ///
    /// By default files created are generally readable by everyone,
    /// but if you pass `G_FILE_CREATE_PRIVATE` in `flags` the file
    /// will be made readable only to the current user, to the level
    /// that is supported on the target filesystem.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled
    /// by triggering the cancellable object from another thread. If the
    /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
    /// returned.
    ///
    /// If a file or directory with this name already exists the
    /// `G_IO_ERROR_EXISTS` error will be returned. Some file systems don't
    /// allow all file names, and may return an `G_IO_ERROR_INVALID_FILENAME`
    /// error, and if the name is to long `G_IO_ERROR_FILENAME_TOO_LONG` will
    /// be returned. Other errors are possible too, and depend on what kind
    /// of filesystem the file is on.
    extern fn g_file_create(p_file: *File, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileOutputStream;
    pub const create = g_file_create;

    /// Asynchronously creates a new file and returns an output stream
    /// for writing to it. The file must not already exist.
    ///
    /// For more details, see `gio.File.create` which is
    /// the synchronous version of this call.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.createFinish` to get the result
    /// of the operation.
    extern fn g_file_create_async(p_file: *File, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const createAsync = g_file_create_async;

    /// Finishes an asynchronous file create operation started with
    /// `gio.File.createAsync`.
    extern fn g_file_create_finish(p_file: *File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileOutputStream;
    pub const createFinish = g_file_create_finish;

    /// Creates a new file and returns a stream for reading and
    /// writing to it. The file must not already exist.
    ///
    /// By default files created are generally readable by everyone,
    /// but if you pass `G_FILE_CREATE_PRIVATE` in `flags` the file
    /// will be made readable only to the current user, to the level
    /// that is supported on the target filesystem.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled
    /// by triggering the cancellable object from another thread. If the
    /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
    /// returned.
    ///
    /// If a file or directory with this name already exists, the
    /// `G_IO_ERROR_EXISTS` error will be returned. Some file systems don't
    /// allow all file names, and may return an `G_IO_ERROR_INVALID_FILENAME`
    /// error, and if the name is too long, `G_IO_ERROR_FILENAME_TOO_LONG`
    /// will be returned. Other errors are possible too, and depend on what
    /// kind of filesystem the file is on.
    ///
    /// Note that in many non-local file cases read and write streams are
    /// not supported, so make sure you really need to do read and write
    /// streaming, rather than just opening for reading or writing.
    extern fn g_file_create_readwrite(p_file: *File, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileIOStream;
    pub const createReadwrite = g_file_create_readwrite;

    /// Asynchronously creates a new file and returns a stream
    /// for reading and writing to it. The file must not already exist.
    ///
    /// For more details, see `gio.File.createReadwrite` which is
    /// the synchronous version of this call.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.createReadwriteFinish` to get
    /// the result of the operation.
    extern fn g_file_create_readwrite_async(p_file: *File, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const createReadwriteAsync = g_file_create_readwrite_async;

    /// Finishes an asynchronous file create operation started with
    /// `gio.File.createReadwriteAsync`.
    extern fn g_file_create_readwrite_finish(p_file: *File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileIOStream;
    pub const createReadwriteFinish = g_file_create_readwrite_finish;

    /// Deletes a file. If the `file` is a directory, it will only be
    /// deleted if it is empty. This has the same semantics as `glib.unlink`.
    ///
    /// If `file` doesn’t exist, `G_IO_ERROR_NOT_FOUND` will be returned. This allows
    /// for deletion to be implemented avoiding
    /// [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
    /// ```
    /// g_autoptr(GError) local_error = NULL;
    /// if (!g_file_delete (my_file, my_cancellable, &local_error) &&
    ///     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
    ///   {
    ///     // deletion failed for some reason other than the file not existing:
    ///     // so report the error
    ///     g_warning ("Failed to delete `s`: `s`",
    ///                g_file_peek_path (my_file), local_error->message);
    ///   }
    /// ```
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_delete(p_file: *File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const delete = g_file_delete;

    /// Asynchronously delete a file. If the `file` is a directory, it will
    /// only be deleted if it is empty.  This has the same semantics as
    /// `glib.unlink`.
    extern fn g_file_delete_async(p_file: *File, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const deleteAsync = g_file_delete_async;

    /// Finishes deleting a file started with `gio.File.deleteAsync`.
    extern fn g_file_delete_finish(p_file: *File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const deleteFinish = g_file_delete_finish;

    /// Duplicates a `gio.File` handle. This operation does not duplicate
    /// the actual file or directory represented by the `gio.File`; see
    /// `gio.File.copy` if attempting to copy a file.
    ///
    /// `gio.File.dup` is useful when a second handle is needed to the same underlying
    /// file, for use in a separate thread (`gio.File` is not thread-safe). For use
    /// within the same thread, use `gobject.Object.ref` to increment the existing object’s
    /// reference count.
    ///
    /// This call does no blocking I/O.
    extern fn g_file_dup(p_file: *File) *gio.File;
    pub const dup = g_file_dup;

    /// Starts an asynchronous eject on a mountable.
    /// When this operation has completed, `callback` will be called with
    /// `user_user` data, and the operation can be finalized with
    /// `gio.File.ejectMountableFinish`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_eject_mountable(p_file: *File, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const ejectMountable = g_file_eject_mountable;

    /// Finishes an asynchronous eject operation started by
    /// `gio.File.ejectMountable`.
    extern fn g_file_eject_mountable_finish(p_file: *File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const ejectMountableFinish = g_file_eject_mountable_finish;

    /// Starts an asynchronous eject on a mountable.
    /// When this operation has completed, `callback` will be called with
    /// `user_user` data, and the operation can be finalized with
    /// `gio.File.ejectMountableWithOperationFinish`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_eject_mountable_with_operation(p_file: *File, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const ejectMountableWithOperation = g_file_eject_mountable_with_operation;

    /// Finishes an asynchronous eject operation started by
    /// `gio.File.ejectMountableWithOperation`.
    extern fn g_file_eject_mountable_with_operation_finish(p_file: *File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const ejectMountableWithOperationFinish = g_file_eject_mountable_with_operation_finish;

    /// Gets the requested information about the files in a directory.
    /// The result is a `gio.FileEnumerator` object that will give out
    /// `gio.FileInfo` objects for all the files in the directory.
    ///
    /// The `attributes` value is a string that specifies the file
    /// attributes that should be gathered. It is not an error if
    /// it's not possible to read a particular requested attribute
    /// from a file - it just won't be set. `attributes` should
    /// be a comma-separated list of attributes or attribute wildcards.
    /// The wildcard "*" means all attributes, and a wildcard like
    /// "standard::*" means all attributes in the standard namespace.
    /// An example attribute query be "standard::*,owner::user".
    /// The standard attributes are available as defines, like
    /// `G_FILE_ATTRIBUTE_STANDARD_NAME`. `G_FILE_ATTRIBUTE_STANDARD_NAME` should
    /// always be specified if you plan to call `gio.FileEnumerator.getChild` or
    /// `gio.FileEnumerator.iterate` on the returned enumerator.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled
    /// by triggering the cancellable object from another thread. If the
    /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
    /// returned.
    ///
    /// If the file does not exist, the `G_IO_ERROR_NOT_FOUND` error will
    /// be returned. If the file is not a directory, the `G_IO_ERROR_NOT_DIRECTORY`
    /// error will be returned. Other errors are possible too.
    extern fn g_file_enumerate_children(p_file: *File, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileEnumerator;
    pub const enumerateChildren = g_file_enumerate_children;

    /// Asynchronously gets the requested information about the files
    /// in a directory. The result is a `gio.FileEnumerator` object that will
    /// give out `gio.FileInfo` objects for all the files in the directory.
    ///
    /// For more details, see `gio.File.enumerateChildren` which is
    /// the synchronous version of this call.
    ///
    /// When the operation is finished, `callback` will be called. You can
    /// then call `gio.File.enumerateChildrenFinish` to get the result of
    /// the operation.
    extern fn g_file_enumerate_children_async(p_file: *File, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const enumerateChildrenAsync = g_file_enumerate_children_async;

    /// Finishes an async enumerate children operation.
    /// See `gio.File.enumerateChildrenAsync`.
    extern fn g_file_enumerate_children_finish(p_file: *File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileEnumerator;
    pub const enumerateChildrenFinish = g_file_enumerate_children_finish;

    /// Checks if the two given `GFiles` refer to the same file.
    ///
    /// Note that two `GFiles` that differ can still refer to the same
    /// file on the filesystem due to various forms of filename
    /// aliasing.
    ///
    /// This call does no blocking I/O.
    extern fn g_file_equal(p_file1: *File, p_file2: *gio.File) c_int;
    pub const equal = g_file_equal;

    /// Gets a `gio.Mount` for the `gio.File`.
    ///
    /// `gio.Mount` is returned only for user interesting locations, see
    /// `gio.VolumeMonitor`. If the `gio.FileIface` for `file` does not have a `mount`,
    /// `error` will be set to `G_IO_ERROR_NOT_FOUND` and `NULL` `will` be returned.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_find_enclosing_mount(p_file: *File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.Mount;
    pub const findEnclosingMount = g_file_find_enclosing_mount;

    /// Asynchronously gets the mount for the file.
    ///
    /// For more details, see `gio.File.findEnclosingMount` which is
    /// the synchronous version of this call.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.findEnclosingMountFinish` to
    /// get the result of the operation.
    extern fn g_file_find_enclosing_mount_async(p_file: *File, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const findEnclosingMountAsync = g_file_find_enclosing_mount_async;

    /// Finishes an asynchronous find mount request.
    /// See `gio.File.findEnclosingMountAsync`.
    extern fn g_file_find_enclosing_mount_finish(p_file: *File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.Mount;
    pub const findEnclosingMountFinish = g_file_find_enclosing_mount_finish;

    /// Gets the base name (the last component of the path) for a given `gio.File`.
    ///
    /// If called for the top level of a system (such as the filesystem root
    /// or a uri like sftp://host/) it will return a single directory separator
    /// (and on Windows, possibly a drive letter).
    ///
    /// The base name is a byte string (not UTF-8). It has no defined encoding
    /// or rules other than it may not contain zero bytes.  If you want to use
    /// filenames in a user interface you should use the display name that you
    /// can get by requesting the `G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME`
    /// attribute with `gio.File.queryInfo`.
    ///
    /// This call does no blocking I/O.
    extern fn g_file_get_basename(p_file: *File) ?[*:0]u8;
    pub const getBasename = g_file_get_basename;

    /// Gets a child of `file` with basename equal to `name`.
    ///
    /// Note that the file with that specific name might not exist, but
    /// you can still have a `gio.File` that points to it. You can use this
    /// for instance to create that file.
    ///
    /// This call does no blocking I/O.
    extern fn g_file_get_child(p_file: *File, p_name: [*:0]const u8) *gio.File;
    pub const getChild = g_file_get_child;

    /// Gets the child of `file` for a given `display_name` (i.e. a UTF-8
    /// version of the name). If this function fails, it returns `NULL`
    /// and `error` will be set. This is very useful when constructing a
    /// `gio.File` for a new file and the user entered the filename in the
    /// user interface, for instance when you select a directory and
    /// type a filename in the file selector.
    ///
    /// This call does no blocking I/O.
    extern fn g_file_get_child_for_display_name(p_file: *File, p_display_name: [*:0]const u8, p_error: ?*?*glib.Error) ?*gio.File;
    pub const getChildForDisplayName = g_file_get_child_for_display_name;

    /// Gets the parent directory for the `file`.
    /// If the `file` represents the root directory of the
    /// file system, then `NULL` will be returned.
    ///
    /// This call does no blocking I/O.
    extern fn g_file_get_parent(p_file: *File) ?*gio.File;
    pub const getParent = g_file_get_parent;

    /// Gets the parse name of the `file`.
    /// A parse name is a UTF-8 string that describes the
    /// file such that one can get the `gio.File` back using
    /// `gio.fileParseName`.
    ///
    /// This is generally used to show the `gio.File` as a nice
    /// full-pathname kind of string in a user interface,
    /// like in a location entry.
    ///
    /// For local files with names that can safely be converted
    /// to UTF-8 the pathname is used, otherwise the IRI is used
    /// (a form of URI that allows UTF-8 characters unescaped).
    ///
    /// This call does no blocking I/O.
    extern fn g_file_get_parse_name(p_file: *File) [*:0]u8;
    pub const getParseName = g_file_get_parse_name;

    /// Gets the local pathname for `gio.File`, if one exists. If non-`NULL`, this is
    /// guaranteed to be an absolute, canonical path. It might contain symlinks.
    ///
    /// This call does no blocking I/O.
    extern fn g_file_get_path(p_file: *File) ?[*:0]u8;
    pub const getPath = g_file_get_path;

    /// Gets the path for `descendant` relative to `parent`.
    ///
    /// This call does no blocking I/O.
    extern fn g_file_get_relative_path(p_parent: *File, p_descendant: *gio.File) ?[*:0]u8;
    pub const getRelativePath = g_file_get_relative_path;

    /// Gets the URI for the `file`.
    ///
    /// This call does no blocking I/O.
    extern fn g_file_get_uri(p_file: *File) [*:0]u8;
    pub const getUri = g_file_get_uri;

    /// Gets the URI scheme for a `gio.File`.
    /// RFC 3986 decodes the scheme as:
    /// ```
    /// URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
    /// ```
    /// Common schemes include "file", "http", "ftp", etc.
    ///
    /// The scheme can be different from the one used to construct the `gio.File`,
    /// in that it might be replaced with one that is logically equivalent to the `gio.File`.
    ///
    /// This call does no blocking I/O.
    extern fn g_file_get_uri_scheme(p_file: *File) ?[*:0]u8;
    pub const getUriScheme = g_file_get_uri_scheme;

    /// Checks if `file` has a parent, and optionally, if it is `parent`.
    ///
    /// If `parent` is `NULL` then this function returns `TRUE` if `file` has any
    /// parent at all.  If `parent` is non-`NULL` then `TRUE` is only returned
    /// if `file` is an immediate child of `parent`.
    extern fn g_file_has_parent(p_file: *File, p_parent: ?*gio.File) c_int;
    pub const hasParent = g_file_has_parent;

    /// Checks whether `file` has the prefix specified by `prefix`.
    ///
    /// In other words, if the names of initial elements of `file`'s
    /// pathname match `prefix`. Only full pathname elements are matched,
    /// so a path like /foo is not considered a prefix of /foobar, only
    /// of /foo/bar.
    ///
    /// A `gio.File` is not a prefix of itself. If you want to check for
    /// equality, use `gio.File.equal`.
    ///
    /// This call does no I/O, as it works purely on names. As such it can
    /// sometimes return `FALSE` even if `file` is inside a `prefix` (from a
    /// filesystem point of view), because the prefix of `file` is an alias
    /// of `prefix`.
    extern fn g_file_has_prefix(p_file: *File, p_prefix: *gio.File) c_int;
    pub const hasPrefix = g_file_has_prefix;

    /// Checks to see if a `gio.File` has a given URI scheme.
    ///
    /// This call does no blocking I/O.
    extern fn g_file_has_uri_scheme(p_file: *File, p_uri_scheme: [*:0]const u8) c_int;
    pub const hasUriScheme = g_file_has_uri_scheme;

    /// Creates a hash value for a `gio.File`.
    ///
    /// This call does no blocking I/O.
    extern fn g_file_hash(p_file: *const File) c_uint;
    pub const hash = g_file_hash;

    /// Checks to see if a file is native to the platform.
    ///
    /// A native file is one expressed in the platform-native filename format,
    /// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
    /// as it might be on a locally mounted remote filesystem.
    ///
    /// On some systems non-native files may be available using the native
    /// filesystem via a userspace filesystem (FUSE), in these cases this call
    /// will return `FALSE`, but `gio.File.getPath` will still return a native path.
    ///
    /// This call does no blocking I/O.
    extern fn g_file_is_native(p_file: *File) c_int;
    pub const isNative = g_file_is_native;

    /// Loads the contents of `file` and returns it as `glib.Bytes`.
    ///
    /// If `file` is a resource:// based URI, the resulting bytes will reference the
    /// embedded resource instead of a copy. Otherwise, this is equivalent to calling
    /// `gio.File.loadContents` and `glib.Bytes.newTake`.
    ///
    /// For resources, `etag_out` will be set to `NULL`.
    ///
    /// The data contained in the resulting `glib.Bytes` is always zero-terminated, but
    /// this is not included in the `glib.Bytes` length. The resulting `glib.Bytes` should be
    /// freed with `glib.Bytes.unref` when no longer in use.
    extern fn g_file_load_bytes(p_file: *File, p_cancellable: ?*gio.Cancellable, p_etag_out: ?*[*:0]u8, p_error: ?*?*glib.Error) ?*glib.Bytes;
    pub const loadBytes = g_file_load_bytes;

    /// Asynchronously loads the contents of `file` as `glib.Bytes`.
    ///
    /// If `file` is a resource:// based URI, the resulting bytes will reference the
    /// embedded resource instead of a copy. Otherwise, this is equivalent to calling
    /// `gio.File.loadContentsAsync` and `glib.Bytes.newTake`.
    ///
    /// `callback` should call `gio.File.loadBytesFinish` to get the result of this
    /// asynchronous operation.
    ///
    /// See `gio.File.loadBytes` for more information.
    extern fn g_file_load_bytes_async(p_file: *File, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const loadBytesAsync = g_file_load_bytes_async;

    /// Completes an asynchronous request to `gio.File.loadBytesAsync`.
    ///
    /// For resources, `etag_out` will be set to `NULL`.
    ///
    /// The data contained in the resulting `glib.Bytes` is always zero-terminated, but
    /// this is not included in the `glib.Bytes` length. The resulting `glib.Bytes` should be
    /// freed with `glib.Bytes.unref` when no longer in use.
    ///
    /// See `gio.File.loadBytes` for more information.
    extern fn g_file_load_bytes_finish(p_file: *File, p_result: *gio.AsyncResult, p_etag_out: ?*[*:0]u8, p_error: ?*?*glib.Error) ?*glib.Bytes;
    pub const loadBytesFinish = g_file_load_bytes_finish;

    /// Loads the content of the file into memory. The data is always
    /// zero-terminated, but this is not included in the resultant `length`.
    /// The returned `contents` should be freed with `glib.free` when no longer
    /// needed.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_load_contents(p_file: *File, p_cancellable: ?*gio.Cancellable, p_contents: *[*]u8, p_length: ?*usize, p_etag_out: ?*[*:0]u8, p_error: ?*?*glib.Error) c_int;
    pub const loadContents = g_file_load_contents;

    /// Starts an asynchronous load of the `file`'s contents.
    ///
    /// For more details, see `gio.File.loadContents` which is
    /// the synchronous version of this call.
    ///
    /// When the load operation has completed, `callback` will be called
    /// with `user` data. To finish the operation, call
    /// `gio.File.loadContentsFinish` with the `gio.AsyncResult` returned by
    /// the `callback`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_load_contents_async(p_file: *File, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const loadContentsAsync = g_file_load_contents_async;

    /// Finishes an asynchronous load of the `file`'s contents.
    /// The contents are placed in `contents`, and `length` is set to the
    /// size of the `contents` string. The `contents` should be freed with
    /// `glib.free` when no longer needed. If `etag_out` is present, it will be
    /// set to the new entity tag for the `file`.
    extern fn g_file_load_contents_finish(p_file: *File, p_res: *gio.AsyncResult, p_contents: *[*]u8, p_length: ?*usize, p_etag_out: ?*[*:0]u8, p_error: ?*?*glib.Error) c_int;
    pub const loadContentsFinish = g_file_load_contents_finish;

    /// Reads the partial contents of a file. A `gio.FileReadMoreCallback` should
    /// be used to stop reading from the file when appropriate, else this
    /// function will behave exactly as `gio.File.loadContentsAsync`. This
    /// operation can be finished by `gio.File.loadPartialContentsFinish`.
    ///
    /// Users of this function should be aware that `user_data` is passed to
    /// both the `read_more_callback` and the `callback`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_load_partial_contents_async(p_file: *File, p_cancellable: ?*gio.Cancellable, p_read_more_callback: gio.FileReadMoreCallback, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const loadPartialContentsAsync = g_file_load_partial_contents_async;

    /// Finishes an asynchronous partial load operation that was started
    /// with `gio.File.loadPartialContentsAsync`. The data is always
    /// zero-terminated, but this is not included in the resultant `length`.
    /// The returned `contents` should be freed with `glib.free` when no longer
    /// needed.
    extern fn g_file_load_partial_contents_finish(p_file: *File, p_res: *gio.AsyncResult, p_contents: *[*]u8, p_length: ?*usize, p_etag_out: ?*[*:0]u8, p_error: ?*?*glib.Error) c_int;
    pub const loadPartialContentsFinish = g_file_load_partial_contents_finish;

    /// Creates a directory. Note that this will only create a child directory
    /// of the immediate parent directory of the path or URI given by the `gio.File`.
    /// To recursively create directories, see `gio.File.makeDirectoryWithParents`.
    /// This function will fail if the parent directory does not exist, setting
    /// `error` to `G_IO_ERROR_NOT_FOUND`. If the file system doesn't support
    /// creating directories, this function will fail, setting `error` to
    /// `G_IO_ERROR_NOT_SUPPORTED`.
    ///
    /// For a local `gio.File` the newly created directory will have the default
    /// (current) ownership and permissions of the current process.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_make_directory(p_file: *File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const makeDirectory = g_file_make_directory;

    /// Asynchronously creates a directory.
    extern fn g_file_make_directory_async(p_file: *File, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const makeDirectoryAsync = g_file_make_directory_async;

    /// Finishes an asynchronous directory creation, started with
    /// `gio.File.makeDirectoryAsync`.
    extern fn g_file_make_directory_finish(p_file: *File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const makeDirectoryFinish = g_file_make_directory_finish;

    /// Creates a directory and any parent directories that may not
    /// exist similar to 'mkdir -p'. If the file system does not support
    /// creating directories, this function will fail, setting `error` to
    /// `G_IO_ERROR_NOT_SUPPORTED`. If the directory itself already exists,
    /// this function will fail setting `error` to `G_IO_ERROR_EXISTS`, unlike
    /// the similar `glib.mkdirWithParents`.
    ///
    /// For a local `gio.File` the newly created directories will have the default
    /// (current) ownership and permissions of the current process.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_make_directory_with_parents(p_file: *File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const makeDirectoryWithParents = g_file_make_directory_with_parents;

    /// Creates a symbolic link named `file` which contains the string
    /// `symlink_value`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_make_symbolic_link(p_file: *File, p_symlink_value: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const makeSymbolicLink = g_file_make_symbolic_link;

    /// Asynchronously creates a symbolic link named `file` which contains the
    /// string `symlink_value`.
    extern fn g_file_make_symbolic_link_async(p_file: *File, p_symlink_value: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const makeSymbolicLinkAsync = g_file_make_symbolic_link_async;

    /// Finishes an asynchronous symbolic link creation, started with
    /// `gio.File.makeSymbolicLinkAsync`.
    extern fn g_file_make_symbolic_link_finish(p_file: *File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const makeSymbolicLinkFinish = g_file_make_symbolic_link_finish;

    /// Recursively measures the disk usage of `file`.
    ///
    /// This is essentially an analog of the 'du' command, but it also
    /// reports the number of directories and non-directory files encountered
    /// (including things like symbolic links).
    ///
    /// By default, errors are only reported against the toplevel file
    /// itself.  Errors found while recursing are silently ignored, unless
    /// `G_FILE_MEASURE_REPORT_ANY_ERROR` is given in `flags`.
    ///
    /// The returned size, `disk_usage`, is in bytes and should be formatted
    /// with `glib.formatSize` in order to get something reasonable for showing
    /// in a user interface.
    ///
    /// `progress_callback` and `progress_data` can be given to request
    /// periodic progress updates while scanning.  See the documentation for
    /// `gio.FileMeasureProgressCallback` for information about when and how the
    /// callback will be invoked.
    extern fn g_file_measure_disk_usage(p_file: *File, p_flags: gio.FileMeasureFlags, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileMeasureProgressCallback, p_progress_data: ?*anyopaque, p_disk_usage: ?*u64, p_num_dirs: ?*u64, p_num_files: ?*u64, p_error: ?*?*glib.Error) c_int;
    pub const measureDiskUsage = g_file_measure_disk_usage;

    /// Recursively measures the disk usage of `file`.
    ///
    /// This is the asynchronous version of `gio.File.measureDiskUsage`.  See
    /// there for more information.
    extern fn g_file_measure_disk_usage_async(p_file: *File, p_flags: gio.FileMeasureFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileMeasureProgressCallback, p_progress_data: ?*anyopaque, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const measureDiskUsageAsync = g_file_measure_disk_usage_async;

    /// Collects the results from an earlier call to
    /// `gio.File.measureDiskUsageAsync`.  See `gio.File.measureDiskUsage` for
    /// more information.
    extern fn g_file_measure_disk_usage_finish(p_file: *File, p_result: *gio.AsyncResult, p_disk_usage: ?*u64, p_num_dirs: ?*u64, p_num_files: ?*u64, p_error: ?*?*glib.Error) c_int;
    pub const measureDiskUsageFinish = g_file_measure_disk_usage_finish;

    /// Obtains a file or directory monitor for the given file,
    /// depending on the type of the file.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_monitor(p_file: *File, p_flags: gio.FileMonitorFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileMonitor;
    pub const monitor = g_file_monitor;

    /// Obtains a directory monitor for the given file.
    /// This may fail if directory monitoring is not supported.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    ///
    /// It does not make sense for `flags` to contain
    /// `G_FILE_MONITOR_WATCH_HARD_LINKS`, since hard links can not be made to
    /// directories.  It is not possible to monitor all the files in a
    /// directory for changes made via hard links; if you want to do this then
    /// you must register individual watches with `gio.File.monitor`.
    extern fn g_file_monitor_directory(p_file: *File, p_flags: gio.FileMonitorFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileMonitor;
    pub const monitorDirectory = g_file_monitor_directory;

    /// Obtains a file monitor for the given file. If no file notification
    /// mechanism exists, then regular polling of the file is used.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    ///
    /// If `flags` contains `G_FILE_MONITOR_WATCH_HARD_LINKS` then the monitor
    /// will also attempt to report changes made to the file via another
    /// filename (ie, a hard link). Without this flag, you can only rely on
    /// changes made through the filename contained in `file` to be
    /// reported. Using this flag may result in an increase in resource
    /// usage, and may not have any effect depending on the `gio.FileMonitor`
    /// backend and/or filesystem type.
    extern fn g_file_monitor_file(p_file: *File, p_flags: gio.FileMonitorFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileMonitor;
    pub const monitorFile = g_file_monitor_file;

    /// Starts a `mount_operation`, mounting the volume that contains
    /// the file `location`.
    ///
    /// When this operation has completed, `callback` will be called with
    /// `user_user` data, and the operation can be finalized with
    /// `gio.File.mountEnclosingVolumeFinish`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_mount_enclosing_volume(p_location: *File, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const mountEnclosingVolume = g_file_mount_enclosing_volume;

    /// Finishes a mount operation started by `gio.File.mountEnclosingVolume`.
    extern fn g_file_mount_enclosing_volume_finish(p_location: *File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const mountEnclosingVolumeFinish = g_file_mount_enclosing_volume_finish;

    /// Mounts a file of type G_FILE_TYPE_MOUNTABLE.
    /// Using `mount_operation`, you can request callbacks when, for instance,
    /// passwords are needed during authentication.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.mountMountableFinish` to get
    /// the result of the operation.
    extern fn g_file_mount_mountable(p_file: *File, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const mountMountable = g_file_mount_mountable;

    /// Finishes a mount operation. See `gio.File.mountMountable` for details.
    ///
    /// Finish an asynchronous mount operation that was started
    /// with `gio.File.mountMountable`.
    extern fn g_file_mount_mountable_finish(p_file: *File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.File;
    pub const mountMountableFinish = g_file_mount_mountable_finish;

    /// Tries to move the file or directory `source` to the location specified
    /// by `destination`. If native move operations are supported then this is
    /// used, otherwise a copy + delete fallback is used. The native
    /// implementation may support moving directories (for instance on moves
    /// inside the same filesystem), but the fallback code does not.
    ///
    /// If the flag `G_FILE_COPY_OVERWRITE` is specified an already
    /// existing `destination` file is overwritten.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    ///
    /// If `progress_callback` is not `NULL`, then the operation can be monitored
    /// by setting this to a `gio.FileProgressCallback` function.
    /// `progress_callback_data` will be passed to this function. It is
    /// guaranteed that this callback will be called after all data has been
    /// transferred with the total number of bytes copied during the operation.
    ///
    /// If the `source` file does not exist, then the `G_IO_ERROR_NOT_FOUND`
    /// error is returned, independent on the status of the `destination`.
    ///
    /// If `G_FILE_COPY_OVERWRITE` is not specified and the target exists,
    /// then the error `G_IO_ERROR_EXISTS` is returned.
    ///
    /// If trying to overwrite a file over a directory, the `G_IO_ERROR_IS_DIRECTORY`
    /// error is returned. If trying to overwrite a directory with a directory the
    /// `G_IO_ERROR_WOULD_MERGE` error is returned.
    ///
    /// If the source is a directory and the target does not exist, or
    /// `G_FILE_COPY_OVERWRITE` is specified and the target is a file, then
    /// the `G_IO_ERROR_WOULD_RECURSE` error may be returned (if the native
    /// move operation isn't available).
    extern fn g_file_move(p_source: *File, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_error: ?*?*glib.Error) c_int;
    pub const move = g_file_move;

    /// Asynchronously moves a file `source` to the location of `destination`. For details of the behaviour, see `gio.File.move`.
    ///
    /// If `progress_callback` is not `NULL`, then that function that will be called
    /// just like in `gio.File.move`. The callback will run in the default main context
    /// of the thread calling `gio.File.moveAsync` — the same context as `callback` is
    /// run in.
    ///
    /// When the operation is finished, `callback` will be called. You can then call
    /// `gio.File.moveFinish` to get the result of the operation.
    extern fn g_file_move_async(p_source: *File, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const moveAsync = g_file_move_async;

    /// Version of `gio.File.moveAsync` using closures instead of callbacks for
    /// easier binding in other languages.
    extern fn g_file_move_async_with_closures(p_source: *File, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_progress_callback_closure: ?*gobject.Closure, p_ready_callback_closure: *gobject.Closure) void;
    pub const moveAsyncWithClosures = g_file_move_async_with_closures;

    /// Finishes an asynchronous file movement, started with
    /// `gio.File.moveAsync`.
    extern fn g_file_move_finish(p_file: *File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const moveFinish = g_file_move_finish;

    /// Opens an existing file for reading and writing. The result is
    /// a `gio.FileIOStream` that can be used to read and write the contents
    /// of the file.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled
    /// by triggering the cancellable object from another thread. If the
    /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
    /// returned.
    ///
    /// If the file does not exist, the `G_IO_ERROR_NOT_FOUND` error will
    /// be returned. If the file is a directory, the `G_IO_ERROR_IS_DIRECTORY`
    /// error will be returned. Other errors are possible too, and depend on
    /// what kind of filesystem the file is on. Note that in many non-local
    /// file cases read and write streams are not supported, so make sure you
    /// really need to do read and write streaming, rather than just opening
    /// for reading or writing.
    extern fn g_file_open_readwrite(p_file: *File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileIOStream;
    pub const openReadwrite = g_file_open_readwrite;

    /// Asynchronously opens `file` for reading and writing.
    ///
    /// For more details, see `gio.File.openReadwrite` which is
    /// the synchronous version of this call.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.openReadwriteFinish` to get
    /// the result of the operation.
    extern fn g_file_open_readwrite_async(p_file: *File, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const openReadwriteAsync = g_file_open_readwrite_async;

    /// Finishes an asynchronous file read operation started with
    /// `gio.File.openReadwriteAsync`.
    extern fn g_file_open_readwrite_finish(p_file: *File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileIOStream;
    pub const openReadwriteFinish = g_file_open_readwrite_finish;

    /// Exactly like `gio.File.getPath`, but caches the result via
    /// `gobject.Object.setQdataFull`.  This is useful for example in C
    /// applications which mix `g_file_*` APIs with native ones.  It
    /// also avoids an extra duplicated string when possible, so will be
    /// generally more efficient.
    ///
    /// This call does no blocking I/O.
    extern fn g_file_peek_path(p_file: *File) ?[*:0]const u8;
    pub const peekPath = g_file_peek_path;

    /// Polls a file of type `G_FILE_TYPE_MOUNTABLE`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.mountMountableFinish` to get
    /// the result of the operation.
    extern fn g_file_poll_mountable(p_file: *File, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const pollMountable = g_file_poll_mountable;

    /// Finishes a poll operation. See `gio.File.pollMountable` for details.
    ///
    /// Finish an asynchronous poll operation that was polled
    /// with `gio.File.pollMountable`.
    extern fn g_file_poll_mountable_finish(p_file: *File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const pollMountableFinish = g_file_poll_mountable_finish;

    /// Returns the `gio.AppInfo` that is registered as the default
    /// application to handle the file specified by `file`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_query_default_handler(p_file: *File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.AppInfo;
    pub const queryDefaultHandler = g_file_query_default_handler;

    /// Async version of `gio.File.queryDefaultHandler`.
    extern fn g_file_query_default_handler_async(p_file: *File, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const queryDefaultHandlerAsync = g_file_query_default_handler_async;

    /// Finishes a `gio.File.queryDefaultHandlerAsync` operation.
    extern fn g_file_query_default_handler_finish(p_file: *File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.AppInfo;
    pub const queryDefaultHandlerFinish = g_file_query_default_handler_finish;

    /// Utility function to check if a particular file exists.
    ///
    /// The fallback implementation of this API is using `gio.File.queryInfo`
    /// and therefore may do blocking I/O. To asynchronously query the existence
    /// of a file, use `gio.File.queryInfoAsync`.
    ///
    /// Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
    /// and then execute something based on the outcome of that, because the
    /// file might have been created or removed in between the operations. The
    /// general approach to handling that is to not check, but just do the
    /// operation and handle the errors as they come.
    ///
    /// As an example of race-free checking, take the case of reading a file,
    /// and if it doesn't exist, creating it. There are two racy versions: read
    /// it, and on error create it; and: check if it exists, if not create it.
    /// These can both result in two processes creating the file (with perhaps
    /// a partially written file as the result). The correct approach is to
    /// always try to create the file with `gio.File.create` which will either
    /// atomically create the file or fail with a `G_IO_ERROR_EXISTS` error.
    ///
    /// However, in many cases an existence check is useful in a user interface,
    /// for instance to make a menu item sensitive/insensitive, so that you don't
    /// have to fool users that something is possible and then just show an error
    /// dialog. If you do this, you should make sure to also handle the errors
    /// that can happen due to races when you execute the operation.
    extern fn g_file_query_exists(p_file: *File, p_cancellable: ?*gio.Cancellable) c_int;
    pub const queryExists = g_file_query_exists;

    /// Utility function to inspect the `gio.FileType` of a file. This is
    /// implemented using `gio.File.queryInfo` and as such does blocking I/O.
    ///
    /// The primary use case of this method is to check if a file is
    /// a regular file, directory, or symlink.
    extern fn g_file_query_file_type(p_file: *File, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable) gio.FileType;
    pub const queryFileType = g_file_query_file_type;

    /// Similar to `gio.File.queryInfo`, but obtains information
    /// about the filesystem the `file` is on, rather than the file itself.
    /// For instance the amount of space available and the type of
    /// the filesystem.
    ///
    /// The `attributes` value is a string that specifies the attributes
    /// that should be gathered. It is not an error if it's not possible
    /// to read a particular requested attribute from a file - it just
    /// won't be set. `attributes` should be a comma-separated list of
    /// attributes or attribute wildcards. The wildcard "*" means all
    /// attributes, and a wildcard like "filesystem::*" means all attributes
    /// in the filesystem namespace. The standard namespace for filesystem
    /// attributes is "filesystem". Common attributes of interest are
    /// `G_FILE_ATTRIBUTE_FILESYSTEM_SIZE` (the total size of the filesystem
    /// in bytes), `G_FILE_ATTRIBUTE_FILESYSTEM_FREE` (number of bytes available),
    /// and `G_FILE_ATTRIBUTE_FILESYSTEM_TYPE` (type of the filesystem).
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled
    /// by triggering the cancellable object from another thread. If the
    /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
    /// returned.
    ///
    /// If the file does not exist, the `G_IO_ERROR_NOT_FOUND` error will
    /// be returned. Other errors are possible too, and depend on what
    /// kind of filesystem the file is on.
    extern fn g_file_query_filesystem_info(p_file: *File, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileInfo;
    pub const queryFilesystemInfo = g_file_query_filesystem_info;

    /// Asynchronously gets the requested information about the filesystem
    /// that the specified `file` is on. The result is a `gio.FileInfo` object
    /// that contains key-value attributes (such as type or size for the
    /// file).
    ///
    /// For more details, see `gio.File.queryFilesystemInfo` which is the
    /// synchronous version of this call.
    ///
    /// When the operation is finished, `callback` will be called. You can
    /// then call `gio.File.queryInfoFinish` to get the result of the
    /// operation.
    extern fn g_file_query_filesystem_info_async(p_file: *File, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const queryFilesystemInfoAsync = g_file_query_filesystem_info_async;

    /// Finishes an asynchronous filesystem info query.
    /// See `gio.File.queryFilesystemInfoAsync`.
    extern fn g_file_query_filesystem_info_finish(p_file: *File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileInfo;
    pub const queryFilesystemInfoFinish = g_file_query_filesystem_info_finish;

    /// Gets the requested information about specified `file`.
    /// The result is a `gio.FileInfo` object that contains key-value
    /// attributes (such as the type or size of the file).
    ///
    /// The `attributes` value is a string that specifies the file
    /// attributes that should be gathered. It is not an error if
    /// it's not possible to read a particular requested attribute
    /// from a file - it just won't be set. `attributes` should be a
    /// comma-separated list of attributes or attribute wildcards.
    /// The wildcard "*" means all attributes, and a wildcard like
    /// "standard::*" means all attributes in the standard namespace.
    /// An example attribute query be "standard::*,owner::user".
    /// The standard attributes are available as defines, like
    /// `G_FILE_ATTRIBUTE_STANDARD_NAME`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled
    /// by triggering the cancellable object from another thread. If the
    /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
    /// returned.
    ///
    /// For symlinks, normally the information about the target of the
    /// symlink is returned, rather than information about the symlink
    /// itself. However if you pass `G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS`
    /// in `flags` the information about the symlink itself will be returned.
    /// Also, for symlinks that point to non-existing files the information
    /// about the symlink itself will be returned.
    ///
    /// If the file does not exist, the `G_IO_ERROR_NOT_FOUND` error will be
    /// returned. Other errors are possible too, and depend on what kind of
    /// filesystem the file is on.
    extern fn g_file_query_info(p_file: *File, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileInfo;
    pub const queryInfo = g_file_query_info;

    /// Asynchronously gets the requested information about specified `file`.
    /// The result is a `gio.FileInfo` object that contains key-value attributes
    /// (such as type or size for the file).
    ///
    /// For more details, see `gio.File.queryInfo` which is the synchronous
    /// version of this call.
    ///
    /// When the operation is finished, `callback` will be called. You can
    /// then call `gio.File.queryInfoFinish` to get the result of the operation.
    extern fn g_file_query_info_async(p_file: *File, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const queryInfoAsync = g_file_query_info_async;

    /// Finishes an asynchronous file info query.
    /// See `gio.File.queryInfoAsync`.
    extern fn g_file_query_info_finish(p_file: *File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileInfo;
    pub const queryInfoFinish = g_file_query_info_finish;

    /// Obtain the list of settable attributes for the file.
    ///
    /// Returns the type and full attribute name of all the attributes
    /// that can be set on this file. This doesn't mean setting it will
    /// always succeed though, you might get an access failure, or some
    /// specific file may not support a specific attribute.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_query_settable_attributes(p_file: *File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileAttributeInfoList;
    pub const querySettableAttributes = g_file_query_settable_attributes;

    /// Obtain the list of attribute namespaces where new attributes
    /// can be created by a user. An example of this is extended
    /// attributes (in the "xattr" namespace).
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_query_writable_namespaces(p_file: *File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileAttributeInfoList;
    pub const queryWritableNamespaces = g_file_query_writable_namespaces;

    /// Opens a file for reading. The result is a `gio.FileInputStream` that
    /// can be used to read the contents of the file.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    ///
    /// If the file does not exist, the `G_IO_ERROR_NOT_FOUND` error will be
    /// returned. If the file is a directory, the `G_IO_ERROR_IS_DIRECTORY`
    /// error will be returned. Other errors are possible too, and depend
    /// on what kind of filesystem the file is on.
    extern fn g_file_read(p_file: *File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileInputStream;
    pub const read = g_file_read;

    /// Asynchronously opens `file` for reading.
    ///
    /// For more details, see `gio.File.read` which is
    /// the synchronous version of this call.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.readFinish` to get the result
    /// of the operation.
    extern fn g_file_read_async(p_file: *File, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const readAsync = g_file_read_async;

    /// Finishes an asynchronous file read operation started with
    /// `gio.File.readAsync`.
    extern fn g_file_read_finish(p_file: *File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileInputStream;
    pub const readFinish = g_file_read_finish;

    /// Returns an output stream for overwriting the file, possibly
    /// creating a backup copy of the file first. If the file doesn't exist,
    /// it will be created.
    ///
    /// This will try to replace the file in the safest way possible so
    /// that any errors during the writing will not affect an already
    /// existing copy of the file. For instance, for local files it
    /// may write to a temporary file and then atomically rename over
    /// the destination when the stream is closed.
    ///
    /// By default files created are generally readable by everyone,
    /// but if you pass `G_FILE_CREATE_PRIVATE` in `flags` the file
    /// will be made readable only to the current user, to the level that
    /// is supported on the target filesystem.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled
    /// by triggering the cancellable object from another thread. If the
    /// operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
    /// returned.
    ///
    /// If you pass in a non-`NULL` `etag` value and `file` already exists, then
    /// this value is compared to the current entity tag of the file, and if
    /// they differ an `G_IO_ERROR_WRONG_ETAG` error is returned. This
    /// generally means that the file has been changed since you last read
    /// it. You can get the new etag from `gio.FileOutputStream.getEtag`
    /// after you've finished writing and closed the `gio.FileOutputStream`. When
    /// you load a new file you can use `gio.FileInputStream.queryInfo` to
    /// get the etag of the file.
    ///
    /// If `make_backup` is `TRUE`, this function will attempt to make a
    /// backup of the current file before overwriting it. If this fails
    /// a `G_IO_ERROR_CANT_CREATE_BACKUP` error will be returned. If you
    /// want to replace anyway, try again with `make_backup` set to `FALSE`.
    ///
    /// If the file is a directory the `G_IO_ERROR_IS_DIRECTORY` error will
    /// be returned, and if the file is some other form of non-regular file
    /// then a `G_IO_ERROR_NOT_REGULAR_FILE` error will be returned. Some
    /// file systems don't allow all file names, and may return an
    /// `G_IO_ERROR_INVALID_FILENAME` error, and if the name is to long
    /// `G_IO_ERROR_FILENAME_TOO_LONG` will be returned. Other errors are
    /// possible too, and depend on what kind of filesystem the file is on.
    extern fn g_file_replace(p_file: *File, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileOutputStream;
    pub const replace = g_file_replace;

    /// Asynchronously overwrites the file, replacing the contents,
    /// possibly creating a backup copy of the file first.
    ///
    /// For more details, see `gio.File.replace` which is
    /// the synchronous version of this call.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.replaceFinish` to get the result
    /// of the operation.
    extern fn g_file_replace_async(p_file: *File, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const replaceAsync = g_file_replace_async;

    /// Replaces the contents of `file` with `contents` of `length` bytes.
    ///
    /// If `etag` is specified (not `NULL`), any existing file must have that etag,
    /// or the error `G_IO_ERROR_WRONG_ETAG` will be returned.
    ///
    /// If `make_backup` is `TRUE`, this function will attempt to make a backup
    /// of `file`. Internally, it uses `gio.File.replace`, so will try to replace the
    /// file contents in the safest way possible. For example, atomic renames are
    /// used when replacing local files’ contents.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    ///
    /// The returned `new_etag` can be used to verify that the file hasn't
    /// changed the next time it is saved over.
    extern fn g_file_replace_contents(p_file: *File, p_contents: [*]const u8, p_length: usize, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_new_etag: ?*[*:0]u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const replaceContents = g_file_replace_contents;

    /// Starts an asynchronous replacement of `file` with the given
    /// `contents` of `length` bytes. `etag` will replace the document's
    /// current entity tag.
    ///
    /// When this operation has completed, `callback` will be called with
    /// `user_user` data, and the operation can be finalized with
    /// `gio.File.replaceContentsFinish`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    ///
    /// If `make_backup` is `TRUE`, this function will attempt to
    /// make a backup of `file`.
    ///
    /// Note that no copy of `contents` will be made, so it must stay valid
    /// until `callback` is called. See `gio.File.replaceContentsBytesAsync`
    /// for a `glib.Bytes` version that will automatically hold a reference to the
    /// contents (without copying) for the duration of the call.
    extern fn g_file_replace_contents_async(p_file: *File, p_contents: [*]const u8, p_length: usize, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const replaceContentsAsync = g_file_replace_contents_async;

    /// Same as `gio.File.replaceContentsAsync` but takes a `glib.Bytes` input instead.
    /// This function will keep a ref on `contents` until the operation is done.
    /// Unlike `gio.File.replaceContentsAsync` this allows forgetting about the
    /// content without waiting for the callback.
    ///
    /// When this operation has completed, `callback` will be called with
    /// `user_user` data, and the operation can be finalized with
    /// `gio.File.replaceContentsFinish`.
    extern fn g_file_replace_contents_bytes_async(p_file: *File, p_contents: *glib.Bytes, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const replaceContentsBytesAsync = g_file_replace_contents_bytes_async;

    /// Finishes an asynchronous replace of the given `file`. See
    /// `gio.File.replaceContentsAsync`. Sets `new_etag` to the new entity
    /// tag for the document, if present.
    extern fn g_file_replace_contents_finish(p_file: *File, p_res: *gio.AsyncResult, p_new_etag: ?*[*:0]u8, p_error: ?*?*glib.Error) c_int;
    pub const replaceContentsFinish = g_file_replace_contents_finish;

    /// Finishes an asynchronous file replace operation started with
    /// `gio.File.replaceAsync`.
    extern fn g_file_replace_finish(p_file: *File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileOutputStream;
    pub const replaceFinish = g_file_replace_finish;

    /// Returns an output stream for overwriting the file in readwrite mode,
    /// possibly creating a backup copy of the file first. If the file doesn't
    /// exist, it will be created.
    ///
    /// For details about the behaviour, see `gio.File.replace` which does the
    /// same thing but returns an output stream only.
    ///
    /// Note that in many non-local file cases read and write streams are not
    /// supported, so make sure you really need to do read and write streaming,
    /// rather than just opening for reading or writing.
    extern fn g_file_replace_readwrite(p_file: *File, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.FileIOStream;
    pub const replaceReadwrite = g_file_replace_readwrite;

    /// Asynchronously overwrites the file in read-write mode,
    /// replacing the contents, possibly creating a backup copy
    /// of the file first.
    ///
    /// For more details, see `gio.File.replaceReadwrite` which is
    /// the synchronous version of this call.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.replaceReadwriteFinish` to get
    /// the result of the operation.
    extern fn g_file_replace_readwrite_async(p_file: *File, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const replaceReadwriteAsync = g_file_replace_readwrite_async;

    /// Finishes an asynchronous file replace operation started with
    /// `gio.File.replaceReadwriteAsync`.
    extern fn g_file_replace_readwrite_finish(p_file: *File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.FileIOStream;
    pub const replaceReadwriteFinish = g_file_replace_readwrite_finish;

    /// Resolves a relative path for `file` to an absolute path.
    ///
    /// This call does no blocking I/O.
    ///
    /// If the `relative_path` is an absolute path name, the resolution
    /// is done absolutely (without taking `file` path as base).
    extern fn g_file_resolve_relative_path(p_file: *File, p_relative_path: [*:0]const u8) *gio.File;
    pub const resolveRelativePath = g_file_resolve_relative_path;

    /// Sets an attribute in the file with attribute name `attribute` to `value_p`.
    ///
    /// Some attributes can be unset by setting `type` to
    /// `G_FILE_ATTRIBUTE_TYPE_INVALID` and `value_p` to `NULL`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_set_attribute(p_file: *File, p_attribute: [*:0]const u8, p_type: gio.FileAttributeType, p_value_p: ?*anyopaque, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const setAttribute = g_file_set_attribute;

    /// Sets `attribute` of type `G_FILE_ATTRIBUTE_TYPE_BYTE_STRING` to `value`.
    /// If `attribute` is of a different type, this operation will fail,
    /// returning `FALSE`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_set_attribute_byte_string(p_file: *File, p_attribute: [*:0]const u8, p_value: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const setAttributeByteString = g_file_set_attribute_byte_string;

    /// Sets `attribute` of type `G_FILE_ATTRIBUTE_TYPE_INT32` to `value`.
    /// If `attribute` is of a different type, this operation will fail.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_set_attribute_int32(p_file: *File, p_attribute: [*:0]const u8, p_value: i32, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const setAttributeInt32 = g_file_set_attribute_int32;

    /// Sets `attribute` of type `G_FILE_ATTRIBUTE_TYPE_INT64` to `value`.
    /// If `attribute` is of a different type, this operation will fail.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_set_attribute_int64(p_file: *File, p_attribute: [*:0]const u8, p_value: i64, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const setAttributeInt64 = g_file_set_attribute_int64;

    /// Sets `attribute` of type `G_FILE_ATTRIBUTE_TYPE_STRING` to `value`.
    /// If `attribute` is of a different type, this operation will fail.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_set_attribute_string(p_file: *File, p_attribute: [*:0]const u8, p_value: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const setAttributeString = g_file_set_attribute_string;

    /// Sets `attribute` of type `G_FILE_ATTRIBUTE_TYPE_UINT32` to `value`.
    /// If `attribute` is of a different type, this operation will fail.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_set_attribute_uint32(p_file: *File, p_attribute: [*:0]const u8, p_value: u32, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const setAttributeUint32 = g_file_set_attribute_uint32;

    /// Sets `attribute` of type `G_FILE_ATTRIBUTE_TYPE_UINT64` to `value`.
    /// If `attribute` is of a different type, this operation will fail.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_set_attribute_uint64(p_file: *File, p_attribute: [*:0]const u8, p_value: u64, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const setAttributeUint64 = g_file_set_attribute_uint64;

    /// Asynchronously sets the attributes of `file` with `info`.
    ///
    /// For more details, see `gio.File.setAttributesFromInfo`,
    /// which is the synchronous version of this call.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.setAttributesFinish` to get
    /// the result of the operation.
    extern fn g_file_set_attributes_async(p_file: *File, p_info: *gio.FileInfo, p_flags: gio.FileQueryInfoFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const setAttributesAsync = g_file_set_attributes_async;

    /// Finishes setting an attribute started in `gio.File.setAttributesAsync`.
    extern fn g_file_set_attributes_finish(p_file: *File, p_result: *gio.AsyncResult, p_info: **gio.FileInfo, p_error: ?*?*glib.Error) c_int;
    pub const setAttributesFinish = g_file_set_attributes_finish;

    /// Tries to set all attributes in the `gio.FileInfo` on the target
    /// values, not stopping on the first error.
    ///
    /// If there is any error during this operation then `error` will
    /// be set to the first error. Error on particular fields are flagged
    /// by setting the "status" field in the attribute value to
    /// `G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING`, which means you can
    /// also detect further errors.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_set_attributes_from_info(p_file: *File, p_info: *gio.FileInfo, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const setAttributesFromInfo = g_file_set_attributes_from_info;

    /// Renames `file` to the specified display name.
    ///
    /// The display name is converted from UTF-8 to the correct encoding
    /// for the target filesystem if possible and the `file` is renamed to this.
    ///
    /// If you want to implement a rename operation in the user interface the
    /// edit name (`G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME`) should be used as the
    /// initial value in the rename widget, and then the result after editing
    /// should be passed to `gio.File.setDisplayName`.
    ///
    /// On success the resulting converted filename is returned.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_set_display_name(p_file: *File, p_display_name: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.File;
    pub const setDisplayName = g_file_set_display_name;

    /// Asynchronously sets the display name for a given `gio.File`.
    ///
    /// For more details, see `gio.File.setDisplayName` which is
    /// the synchronous version of this call.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.setDisplayNameFinish` to get
    /// the result of the operation.
    extern fn g_file_set_display_name_async(p_file: *File, p_display_name: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const setDisplayNameAsync = g_file_set_display_name_async;

    /// Finishes setting a display name started with
    /// `gio.File.setDisplayNameAsync`.
    extern fn g_file_set_display_name_finish(p_file: *File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.File;
    pub const setDisplayNameFinish = g_file_set_display_name_finish;

    /// Starts a file of type `G_FILE_TYPE_MOUNTABLE`.
    /// Using `start_operation`, you can request callbacks when, for instance,
    /// passwords are needed during authentication.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.mountMountableFinish` to get
    /// the result of the operation.
    extern fn g_file_start_mountable(p_file: *File, p_flags: gio.DriveStartFlags, p_start_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const startMountable = g_file_start_mountable;

    /// Finishes a start operation. See `gio.File.startMountable` for details.
    ///
    /// Finish an asynchronous start operation that was started
    /// with `gio.File.startMountable`.
    extern fn g_file_start_mountable_finish(p_file: *File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const startMountableFinish = g_file_start_mountable_finish;

    /// Stops a file of type `G_FILE_TYPE_MOUNTABLE`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.stopMountableFinish` to get
    /// the result of the operation.
    extern fn g_file_stop_mountable(p_file: *File, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const stopMountable = g_file_stop_mountable;

    /// Finishes a stop operation, see `gio.File.stopMountable` for details.
    ///
    /// Finish an asynchronous stop operation that was started
    /// with `gio.File.stopMountable`.
    extern fn g_file_stop_mountable_finish(p_file: *File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const stopMountableFinish = g_file_stop_mountable_finish;

    /// Checks if `file` supports thread-default main contexts
    /// (see `glib.MainContext.pushThreadDefault`)
    /// If this returns `FALSE`, you cannot perform asynchronous operations on
    /// `file` in a thread that has a thread-default context.
    extern fn g_file_supports_thread_contexts(p_file: *File) c_int;
    pub const supportsThreadContexts = g_file_supports_thread_contexts;

    /// Sends `file` to the "Trashcan", if possible. This is similar to
    /// deleting it, but the user can recover it before emptying the trashcan.
    /// Trashing is disabled for system mounts by default (see
    /// `gio.UnixMountEntry.isSystemInternal`), so this call can return the
    /// `G_IO_ERROR_NOT_SUPPORTED` error. Since GLib 2.66, the `x-gvfs-notrash` unix
    /// mount option can be used to disable `gio.File.trash` support for particular
    /// mounts, the `G_IO_ERROR_NOT_SUPPORTED` error will be returned in that case.
    /// Since 2.82, the `x-gvfs-trash` unix mount option can be used to enable
    /// `gio.File.trash` support for particular system mounts.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_file_trash(p_file: *File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const trash = g_file_trash;

    /// Asynchronously sends `file` to the Trash location, if possible.
    extern fn g_file_trash_async(p_file: *File, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const trashAsync = g_file_trash_async;

    /// Finishes an asynchronous file trashing operation, started with
    /// `gio.File.trashAsync`.
    extern fn g_file_trash_finish(p_file: *File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const trashFinish = g_file_trash_finish;

    /// Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.unmountMountableFinish` to get
    /// the result of the operation.
    extern fn g_file_unmount_mountable(p_file: *File, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const unmountMountable = g_file_unmount_mountable;

    /// Finishes an unmount operation, see `gio.File.unmountMountable` for details.
    ///
    /// Finish an asynchronous unmount operation that was started
    /// with `gio.File.unmountMountable`.
    extern fn g_file_unmount_mountable_finish(p_file: *File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const unmountMountableFinish = g_file_unmount_mountable_finish;

    /// Unmounts a file of type `G_FILE_TYPE_MOUNTABLE`.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.File.unmountMountableFinish` to get
    /// the result of the operation.
    extern fn g_file_unmount_mountable_with_operation(p_file: *File, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const unmountMountableWithOperation = g_file_unmount_mountable_with_operation;

    /// Finishes an unmount operation,
    /// see `gio.File.unmountMountableWithOperation` for details.
    ///
    /// Finish an asynchronous unmount operation that was started
    /// with `gio.File.unmountMountableWithOperation`.
    extern fn g_file_unmount_mountable_with_operation_finish(p_file: *File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const unmountMountableWithOperationFinish = g_file_unmount_mountable_with_operation_finish;

    extern fn g_file_get_type() usize;
    pub const getGObjectType = g_file_get_type;

    extern fn g_object_ref(p_self: *gio.File) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.File) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *File, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GFileDescriptorBased` is an interface for file descriptor based IO.
///
/// It is implemented by streams (implementations of `gio.InputStream` or
/// `gio.OutputStream`) that are based on file descriptors.
///
/// Note that `<gio/gfiledescriptorbased.h>` belongs to the UNIX-specific
/// GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
/// file or the `GioUnix-2.0` GIR namespace when using it.
pub const FileDescriptorBased = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.FileDescriptorBasedIface;
    pub const virtual_methods = struct {
        /// Gets the underlying file descriptor.
        pub const get_fd = struct {
            pub fn call(p_class: anytype, p_fd_based: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(FileDescriptorBased.Iface, p_class).f_get_fd.?(gobject.ext.as(FileDescriptorBased, p_fd_based));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_fd_based: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(FileDescriptorBased.Iface, p_class).f_get_fd = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Gets the underlying file descriptor.
    extern fn g_file_descriptor_based_get_fd(p_fd_based: *FileDescriptorBased) c_int;
    pub const getFd = g_file_descriptor_based_get_fd;

    extern fn g_file_descriptor_based_get_type() usize;
    pub const getGObjectType = g_file_descriptor_based_get_type;

    extern fn g_object_ref(p_self: *gio.FileDescriptorBased) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.FileDescriptorBased) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *FileDescriptorBased, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GIcon` is a very minimal interface for icons. It provides functions
/// for checking the equality of two icons, hashing of icons and
/// serializing an icon to and from strings.
///
/// `GIcon` does not provide the actual pixmap for the icon as this is out
/// of GIO's scope, however implementations of `GIcon` may contain the name
/// of an icon (see `gio.ThemedIcon`), or the path to an icon
/// (see `gio.LoadableIcon`).
///
/// To obtain a hash of a `GIcon`, see `gio.Icon.hash`.
///
/// To check if two `GIcon`s are equal, see `gio.Icon.equal`.
///
/// For serializing a `GIcon`, use `gio.Icon.serialize` and
/// `gio.Icon.deserialize`.
///
/// If you want to consume `GIcon` (for example, in a toolkit) you must
/// be prepared to handle at least the three following cases:
/// `gio.LoadableIcon`, `gio.ThemedIcon` and `gio.EmblemedIcon`.
/// It may also make sense to have fast-paths for other cases (like handling
/// [`GdkPixbuf`](https://docs.gtk.org/gdk-pixbuf/class.Pixbuf.html) directly,
/// for example) but all compliant `GIcon` implementations outside of GIO must
/// implement `gio.LoadableIcon`.
///
/// If your application or library provides one or more `GIcon`
/// implementations you need to ensure that your new implementation also
/// implements `gio.LoadableIcon`.  Additionally, you must provide an
/// implementation of `gio.Icon.serialize` that gives a result that is
/// understood by `gio.Icon.deserialize`, yielding one of the built-in
/// icon types.
pub const Icon = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.IconIface;
    pub const virtual_methods = struct {
        /// Checks if two icons are equal.
        pub const equal = struct {
            pub fn call(p_class: anytype, p_icon1: ?*@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_icon2: ?*gio.Icon) c_int {
                return gobject.ext.as(Icon.Iface, p_class).f_equal.?(gobject.ext.as(Icon, p_icon1), p_icon2);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon1: ?*@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_icon2: ?*gio.Icon) callconv(.c) c_int) void {
                gobject.ext.as(Icon.Iface, p_class).f_equal = @ptrCast(p_implementation);
            }
        };

        /// Gets a hash for an icon.
        pub const hash = struct {
            pub fn call(p_class: anytype, p_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_uint {
                return gobject.ext.as(Icon.Iface, p_class).f_hash.?(gobject.ext.as(Icon, p_icon));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_uint) void {
                gobject.ext.as(Icon.Iface, p_class).f_hash = @ptrCast(p_implementation);
            }
        };

        /// Serializes a `gio.Icon` into a `glib.Variant`. An equivalent `gio.Icon` can be retrieved
        /// back by calling `gio.iconDeserialize` on the returned value.
        /// As serialization will avoid using raw icon data when possible, it only
        /// makes sense to transfer the `glib.Variant` between processes on the same machine,
        /// (as opposed to over the network), and within the same file system namespace.
        pub const serialize = struct {
            pub fn call(p_class: anytype, p_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*glib.Variant {
                return gobject.ext.as(Icon.Iface, p_class).f_serialize.?(gobject.ext.as(Icon, p_icon));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*glib.Variant) void {
                gobject.ext.as(Icon.Iface, p_class).f_serialize = @ptrCast(p_implementation);
            }
        };

        /// Serializes the `icon` into string tokens.
        /// This is can be invoked when `gio.iconNewForString` is called.
        pub const to_tokens = struct {
            pub fn call(p_class: anytype, p_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tokens: *glib.PtrArray, p_out_version: *c_int) c_int {
                return gobject.ext.as(Icon.Iface, p_class).f_to_tokens.?(gobject.ext.as(Icon, p_icon), p_tokens, p_out_version);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_tokens: *glib.PtrArray, p_out_version: *c_int) callconv(.c) c_int) void {
                gobject.ext.as(Icon.Iface, p_class).f_to_tokens = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Deserializes a `gio.Icon` previously serialized using `gio.Icon.serialize`.
    extern fn g_icon_deserialize(p_value: *glib.Variant) ?*gio.Icon;
    pub const deserialize = g_icon_deserialize;

    /// Generate a `gio.Icon` instance from `str`. This function can fail if
    /// `str` is not valid - see `gio.Icon.toString` for discussion.
    ///
    /// If your application or library provides one or more `gio.Icon`
    /// implementations you need to ensure that each `gobject.Type` is registered
    /// with the type system prior to calling `gio.iconNewForString`.
    extern fn g_icon_new_for_string(p_str: [*:0]const u8, p_error: ?*?*glib.Error) ?*gio.Icon;
    pub const newForString = g_icon_new_for_string;

    /// Checks if two icons are equal.
    extern fn g_icon_equal(p_icon1: ?*Icon, p_icon2: ?*gio.Icon) c_int;
    pub const equal = g_icon_equal;

    /// Gets a hash for an icon.
    extern fn g_icon_hash(p_icon: *const Icon) c_uint;
    pub const hash = g_icon_hash;

    /// Serializes a `gio.Icon` into a `glib.Variant`. An equivalent `gio.Icon` can be retrieved
    /// back by calling `gio.iconDeserialize` on the returned value.
    /// As serialization will avoid using raw icon data when possible, it only
    /// makes sense to transfer the `glib.Variant` between processes on the same machine,
    /// (as opposed to over the network), and within the same file system namespace.
    extern fn g_icon_serialize(p_icon: *Icon) ?*glib.Variant;
    pub const serialize = g_icon_serialize;

    /// Generates a textual representation of `icon` that can be used for
    /// serialization such as when passing `icon` to a different process or
    /// saving it to persistent storage. Use `gio.iconNewForString` to
    /// get `icon` back from the returned string.
    ///
    /// The encoding of the returned string is proprietary to `gio.Icon` except
    /// in the following two cases
    ///
    /// - If `icon` is a `gio.FileIcon`, the returned string is a native path
    ///   (such as `/path/to/my icon.png`) without escaping
    ///   if the `gio.File` for `icon` is a native file.  If the file is not
    ///   native, the returned string is the result of `gio.File.getUri`
    ///   (such as `sftp://path/to/my`@"20icon"`.png`).
    ///
    /// - If `icon` is a `gio.ThemedIcon` with exactly one name and no fallbacks,
    ///   the encoding is simply the name (such as `network-server`).
    extern fn g_icon_to_string(p_icon: *Icon) ?[*:0]u8;
    pub const toString = g_icon_to_string;

    extern fn g_icon_get_type() usize;
    pub const getGObjectType = g_icon_get_type;

    extern fn g_object_ref(p_self: *gio.Icon) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Icon) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Icon, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GInitable` is implemented by objects that can fail during
/// initialization. If an object implements this interface then
/// it must be initialized as the first thing after construction,
/// either via `gio.Initable.init` or `gio.AsyncInitable.initAsync`
/// (the latter is only available if it also implements `gio.AsyncInitable`).
///
/// If the object is not initialized, or initialization returns with an
/// error, then all operations on the object except ``gobject.Object.ref`` and
/// ``gobject.Object.unref`` are considered to be invalid, and have undefined
/// behaviour. They will often fail with `glib.critical` or
/// `glib.warning`, but this must not be relied on.
///
/// Users of objects implementing this are not intended to use
/// the interface method directly, instead it will be used automatically
/// in various ways. For C applications you generally just call
/// `gio.Initable.new` directly, or indirectly via a ``foo_thing_new`` wrapper.
/// This will call `gio.Initable.init` under the cover, returning `NULL`
/// and setting a `GError` on failure (at which point the instance is
/// unreferenced).
///
/// For bindings in languages where the native constructor supports
/// exceptions the binding could check for objects implementing `GInitable`
/// during normal construction and automatically initialize them, throwing
/// an exception on failure.
pub const Initable = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.InitableIface;
    pub const virtual_methods = struct {
        /// Initializes the object implementing the interface.
        ///
        /// This method is intended for language bindings. If writing in C,
        /// `gio.Initable.new` should typically be used instead.
        ///
        /// The object must be initialized before any real use after initial
        /// construction, either with this function or `gio.AsyncInitable.initAsync`.
        ///
        /// Implementations may also support cancellation. If `cancellable` is not `NULL`,
        /// then initialization can be cancelled by triggering the cancellable object
        /// from another thread. If the operation was cancelled, the error
        /// `G_IO_ERROR_CANCELLED` will be returned. If `cancellable` is not `NULL` and
        /// the object doesn't support cancellable initialization the error
        /// `G_IO_ERROR_NOT_SUPPORTED` will be returned.
        ///
        /// If the object is not initialized, or initialization returns with an
        /// error, then all operations on the object except `gobject.Object.ref` and
        /// `gobject.Object.unref` are considered to be invalid, and have undefined
        /// behaviour. See the [description]`gio.@"Initable#description"` for more details.
        ///
        /// Callers should not assume that a class which implements `gio.Initable` can be
        /// initialized multiple times, unless the class explicitly documents itself as
        /// supporting this. Generally, a class’ implementation of `init` can assume
        /// (and assert) that it will only be called once. Previously, this documentation
        /// recommended all `gio.Initable` implementations should be idempotent; that
        /// recommendation was relaxed in GLib 2.54.
        ///
        /// If a class explicitly supports being initialized multiple times, it is
        /// recommended that the method is idempotent: multiple calls with the same
        /// arguments should return the same results. Only the first call initializes
        /// the object; further calls return the result of the first call.
        ///
        /// One reason why a class might need to support idempotent initialization is if
        /// it is designed to be used via the singleton pattern, with a
        /// `gobject.ObjectClass.constructor` that sometimes returns an existing instance.
        /// In this pattern, a caller would expect to be able to call `gio.Initable.init`
        /// on the result of `gobject.Object.new`, regardless of whether it is in fact a new
        /// instance.
        pub const init = struct {
            pub fn call(p_class: anytype, p_initable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Initable.Iface, p_class).f_init.?(gobject.ext.as(Initable, p_initable), p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_initable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Initable.Iface, p_class).f_init = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Helper function for constructing `gio.Initable` object. This is
    /// similar to `gobject.Object.new` but also initializes the object
    /// and returns `NULL`, setting an error on failure.
    extern fn g_initable_new(p_object_type: usize, p_cancellable: ?*gio.Cancellable, p_error: **glib.Error, p_first_property_name: ?[*:0]const u8, ...) *gobject.Object;
    pub const new = g_initable_new;

    /// Helper function for constructing `gio.Initable` object. This is
    /// similar to `gobject.Object.newValist` but also initializes the object
    /// and returns `NULL`, setting an error on failure.
    extern fn g_initable_new_valist(p_object_type: usize, p_first_property_name: [*:0]const u8, p_var_args: std.builtin.VaList, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gobject.Object;
    pub const newValist = g_initable_new_valist;

    /// Helper function for constructing `gio.Initable` object. This is
    /// similar to `gobject.Object.newv` but also initializes the object
    /// and returns `NULL`, setting an error on failure.
    extern fn g_initable_newv(p_object_type: usize, p_n_parameters: c_uint, p_parameters: [*]gobject.Parameter, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gobject.Object;
    pub const newv = g_initable_newv;

    /// Initializes the object implementing the interface.
    ///
    /// This method is intended for language bindings. If writing in C,
    /// `gio.Initable.new` should typically be used instead.
    ///
    /// The object must be initialized before any real use after initial
    /// construction, either with this function or `gio.AsyncInitable.initAsync`.
    ///
    /// Implementations may also support cancellation. If `cancellable` is not `NULL`,
    /// then initialization can be cancelled by triggering the cancellable object
    /// from another thread. If the operation was cancelled, the error
    /// `G_IO_ERROR_CANCELLED` will be returned. If `cancellable` is not `NULL` and
    /// the object doesn't support cancellable initialization the error
    /// `G_IO_ERROR_NOT_SUPPORTED` will be returned.
    ///
    /// If the object is not initialized, or initialization returns with an
    /// error, then all operations on the object except `gobject.Object.ref` and
    /// `gobject.Object.unref` are considered to be invalid, and have undefined
    /// behaviour. See the [description]`gio.@"Initable#description"` for more details.
    ///
    /// Callers should not assume that a class which implements `gio.Initable` can be
    /// initialized multiple times, unless the class explicitly documents itself as
    /// supporting this. Generally, a class’ implementation of `init` can assume
    /// (and assert) that it will only be called once. Previously, this documentation
    /// recommended all `gio.Initable` implementations should be idempotent; that
    /// recommendation was relaxed in GLib 2.54.
    ///
    /// If a class explicitly supports being initialized multiple times, it is
    /// recommended that the method is idempotent: multiple calls with the same
    /// arguments should return the same results. Only the first call initializes
    /// the object; further calls return the result of the first call.
    ///
    /// One reason why a class might need to support idempotent initialization is if
    /// it is designed to be used via the singleton pattern, with a
    /// `gobject.ObjectClass.constructor` that sometimes returns an existing instance.
    /// In this pattern, a caller would expect to be able to call `gio.Initable.init`
    /// on the result of `gobject.Object.new`, regardless of whether it is in fact a new
    /// instance.
    extern fn g_initable_init(p_initable: *Initable, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const init = g_initable_init;

    extern fn g_initable_get_type() usize;
    pub const getGObjectType = g_initable_get_type;

    extern fn g_object_ref(p_self: *gio.Initable) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Initable) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Initable, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GListModel` is an interface that represents a mutable list of
/// `gobject.Object`. Its main intention is as a model for various widgets
/// in user interfaces, such as list views, but it can also be used as a
/// convenient method of returning lists of data, with support for
/// updates.
///
/// Each object in the list may also report changes in itself via some
/// mechanism (normally the `gobject.Object.signals.notify` signal).  Taken
/// together with the `gio.ListModel.signals.items_changed` signal, this provides
/// for a list that can change its membership, and in which the members can
/// change their individual properties.
///
/// A good example would be the list of visible wireless network access
/// points, where each access point can report dynamic properties such as
/// signal strength.
///
/// It is important to note that the `GListModel` itself does not report
/// changes to the individual items.  It only reports changes to the list
/// membership.  If you want to observe changes to the objects themselves
/// then you need to connect signals to the objects that you are
/// interested in.
///
/// All items in a `GListModel` are of (or derived from) the same type.
/// `gio.ListModel.getItemType` returns that type.  The type may be an
/// interface, in which case all objects in the list must implement it.
///
/// The semantics are close to that of an array:
/// `gio.ListModel.getNItems` returns the number of items in the list
/// and `gio.ListModel.getItem` returns an item at a (0-based) position.
/// In order to allow implementations to calculate the list length lazily,
/// you can also iterate over items: starting from 0, repeatedly call
/// `gio.ListModel.getItem` until it returns `NULL`.
///
/// An implementation may create objects lazily, but must take care to
/// return the same object for a given position until all references to
/// it are gone.
///
/// On the other side, a consumer is expected only to hold references on
/// objects that are currently ‘user visible’, in order to facilitate the
/// maximum level of laziness in the implementation of the list and to
/// reduce the required number of signal connections at a given time.
///
/// This interface is intended only to be used from a single thread.  The
/// thread in which it is appropriate to use it depends on the particular
/// implementation, but typically it will be from the thread that owns
/// the thread-default main context (see
/// `glib.MainContext.pushThreadDefault`) in effect at the time that the
/// model was created.
///
/// Over time, it has established itself as good practice for list model
/// implementations to provide properties `item-type` and `n-items` to
/// ease working with them. While it is not required, it is recommended
/// that implementations provide these two properties. They should return
/// the values of `gio.ListModel.getItemType` and
/// `gio.ListModel.getNItems` respectively and be defined as such:
///
/// ```c
/// properties[PROP_ITEM_TYPE] =
///   g_param_spec_gtype ("item-type", NULL, NULL, G_TYPE_OBJECT,
///                       G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
/// properties[PROP_N_ITEMS] =
///   g_param_spec_uint ("n-items", NULL, NULL, 0, G_MAXUINT, 0,
///                      G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
/// ```
pub const ListModel = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.ListModelInterface;
    pub const virtual_methods = struct {
        /// Get the item at `position`. If `position` is greater than the number of
        /// items in `list`, `NULL` is returned.
        ///
        /// `NULL` is never returned for an index that is smaller than the length
        /// of the list.  See `gio.ListModel.getNItems`.
        ///
        /// The same `gobject.Object` instance may not appear more than once in a `gio.ListModel`.
        pub const get_item = struct {
            pub fn call(p_class: anytype, p_list: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_position: c_uint) ?*gobject.Object {
                return gobject.ext.as(ListModel.Iface, p_class).f_get_item.?(gobject.ext.as(ListModel, p_list), p_position);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_list: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_position: c_uint) callconv(.c) ?*gobject.Object) void {
                gobject.ext.as(ListModel.Iface, p_class).f_get_item = @ptrCast(p_implementation);
            }
        };

        /// Gets the type of the items in `list`.
        ///
        /// All items returned from `gio.ListModel.getItem` are of the type
        /// returned by this function, or a subtype, or if the type is an
        /// interface, they are an implementation of that interface.
        ///
        /// The item type of a `gio.ListModel` can not change during the life of the
        /// model.
        pub const get_item_type = struct {
            pub fn call(p_class: anytype, p_list: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) usize {
                return gobject.ext.as(ListModel.Iface, p_class).f_get_item_type.?(gobject.ext.as(ListModel, p_list));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_list: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) usize) void {
                gobject.ext.as(ListModel.Iface, p_class).f_get_item_type = @ptrCast(p_implementation);
            }
        };

        /// Gets the number of items in `list`.
        ///
        /// Depending on the model implementation, calling this function may be
        /// less efficient than iterating the list with increasing values for
        /// `position` until `gio.ListModel.getItem` returns `NULL`.
        pub const get_n_items = struct {
            pub fn call(p_class: anytype, p_list: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_uint {
                return gobject.ext.as(ListModel.Iface, p_class).f_get_n_items.?(gobject.ext.as(ListModel, p_list));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_list: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_uint) void {
                gobject.ext.as(ListModel.Iface, p_class).f_get_n_items = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// This signal is emitted whenever items were added to or removed
        /// from `list`. At `position`, `removed` items were removed and `added`
        /// items were added in their place.
        ///
        /// Note: If `removed != added`, the positions of all later items
        /// in the model change.
        pub const items_changed = struct {
            pub const name = "items-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_position: c_uint, p_removed: c_uint, p_added: c_uint, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(ListModel, p_instance))),
                    gobject.signalLookup("items-changed", ListModel.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Get the item at `position`.
    ///
    /// If `position` is greater than the number of items in `list`, `NULL` is
    /// returned.
    ///
    /// `NULL` is never returned for an index that is smaller than the length
    /// of the list.
    ///
    /// See also: `gio.ListModel.getNItems`
    extern fn g_list_model_get_item(p_list: *ListModel, p_position: c_uint) ?*anyopaque;
    pub const getItem = g_list_model_get_item;

    /// Gets the type of the items in `list`.
    ///
    /// All items returned from `gio.ListModel.getItem` are of the type
    /// returned by this function, or a subtype, or if the type is an
    /// interface, they are an implementation of that interface.
    ///
    /// The item type of a `gio.ListModel` can not change during the life of the
    /// model.
    extern fn g_list_model_get_item_type(p_list: *ListModel) usize;
    pub const getItemType = g_list_model_get_item_type;

    /// Gets the number of items in `list`.
    ///
    /// Depending on the model implementation, calling this function may be
    /// less efficient than iterating the list with increasing values for
    /// `position` until `gio.ListModel.getItem` returns `NULL`.
    extern fn g_list_model_get_n_items(p_list: *ListModel) c_uint;
    pub const getNItems = g_list_model_get_n_items;

    /// Get the item at `position`.
    ///
    /// If `position` is greater than the number of items in `list`, `NULL` is
    /// returned.
    ///
    /// `NULL` is never returned for an index that is smaller than the length
    /// of the list.
    ///
    /// This function is meant to be used by language bindings in place
    /// of `gio.ListModel.getItem`.
    ///
    /// See also: `gio.ListModel.getNItems`
    extern fn g_list_model_get_object(p_list: *ListModel, p_position: c_uint) ?*gobject.Object;
    pub const getObject = g_list_model_get_object;

    /// Emits the `gio.ListModel.signals.items`-changed signal on `list`.
    ///
    /// This function should only be called by classes implementing
    /// `gio.ListModel`. It has to be called after the internal representation
    /// of `list` has been updated, because handlers connected to this signal
    /// might query the new state of the list.
    ///
    /// Implementations must only make changes to the model (as visible to
    /// its consumer) in places that will not cause problems for that
    /// consumer.  For models that are driven directly by a write API (such
    /// as `gio.ListStore`), changes can be reported in response to uses of that
    /// API.  For models that represent remote data, changes should only be
    /// made from a fresh mainloop dispatch.  It is particularly not
    /// permitted to make changes in response to a call to the `gio.ListModel`
    /// consumer API.
    ///
    /// Stated another way: in general, it is assumed that code making a
    /// series of accesses to the model via the API, without returning to the
    /// mainloop, and without calling other code, will continue to view the
    /// same contents of the model.
    extern fn g_list_model_items_changed(p_list: *ListModel, p_position: c_uint, p_removed: c_uint, p_added: c_uint) void;
    pub const itemsChanged = g_list_model_items_changed;

    extern fn g_list_model_get_type() usize;
    pub const getGObjectType = g_list_model_get_type;

    extern fn g_object_ref(p_self: *gio.ListModel) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.ListModel) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ListModel, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GLoadableIcon` extends the `gio.Icon` interface and adds the ability
/// to load icons from streams.
pub const LoadableIcon = opaque {
    pub const Prerequisites = [_]type{gio.Icon};
    pub const Iface = gio.LoadableIconIface;
    pub const virtual_methods = struct {
        /// Loads a loadable icon. For the asynchronous version of this function,
        /// see `gio.LoadableIcon.loadAsync`.
        pub const load = struct {
            pub fn call(p_class: anytype, p_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_size: c_int, p_type: ?*[*:0]u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.InputStream {
                return gobject.ext.as(LoadableIcon.Iface, p_class).f_load.?(gobject.ext.as(LoadableIcon, p_icon), p_size, p_type, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_size: c_int, p_type: ?*[*:0]u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.InputStream) void {
                gobject.ext.as(LoadableIcon.Iface, p_class).f_load = @ptrCast(p_implementation);
            }
        };

        /// Loads an icon asynchronously. To finish this function, see
        /// `gio.LoadableIcon.loadFinish`. For the synchronous, blocking
        /// version of this function, see `gio.LoadableIcon.load`.
        pub const load_async = struct {
            pub fn call(p_class: anytype, p_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_size: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(LoadableIcon.Iface, p_class).f_load_async.?(gobject.ext.as(LoadableIcon, p_icon), p_size, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_size: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(LoadableIcon.Iface, p_class).f_load_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an asynchronous icon load started in `gio.LoadableIcon.loadAsync`.
        pub const load_finish = struct {
            pub fn call(p_class: anytype, p_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_type: ?*[*:0]u8, p_error: ?*?*glib.Error) ?*gio.InputStream {
                return gobject.ext.as(LoadableIcon.Iface, p_class).f_load_finish.?(gobject.ext.as(LoadableIcon, p_icon), p_res, p_type, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_icon: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_res: *gio.AsyncResult, p_type: ?*[*:0]u8, p_error: ?*?*glib.Error) callconv(.c) ?*gio.InputStream) void {
                gobject.ext.as(LoadableIcon.Iface, p_class).f_load_finish = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Loads a loadable icon. For the asynchronous version of this function,
    /// see `gio.LoadableIcon.loadAsync`.
    extern fn g_loadable_icon_load(p_icon: *LoadableIcon, p_size: c_int, p_type: ?*[*:0]u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.InputStream;
    pub const load = g_loadable_icon_load;

    /// Loads an icon asynchronously. To finish this function, see
    /// `gio.LoadableIcon.loadFinish`. For the synchronous, blocking
    /// version of this function, see `gio.LoadableIcon.load`.
    extern fn g_loadable_icon_load_async(p_icon: *LoadableIcon, p_size: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const loadAsync = g_loadable_icon_load_async;

    /// Finishes an asynchronous icon load started in `gio.LoadableIcon.loadAsync`.
    extern fn g_loadable_icon_load_finish(p_icon: *LoadableIcon, p_res: *gio.AsyncResult, p_type: ?*[*:0]u8, p_error: ?*?*glib.Error) ?*gio.InputStream;
    pub const loadFinish = g_loadable_icon_load_finish;

    extern fn g_loadable_icon_get_type() usize;
    pub const getGObjectType = g_loadable_icon_get_type;

    extern fn g_object_ref(p_self: *gio.LoadableIcon) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.LoadableIcon) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *LoadableIcon, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GMemoryMonitor` will monitor system memory and suggest to the application
/// when to free memory so as to leave more room for other applications.
/// It is implemented on Linux using the
/// [Low Memory Monitor](https://gitlab.freedesktop.org/hadess/low-memory-monitor/)
/// ([API documentation](https://hadess.pages.freedesktop.org/low-memory-monitor/)).
///
/// There is also an implementation for use inside Flatpak sandboxes.
///
/// Possible actions to take when the signal is received are:
///
///  - Free caches
///  - Save files that haven’t been looked at in a while to disk, ready to be reopened when needed
///  - Run a garbage collection cycle
///  - Try and compress fragmented allocations
///  - Exit on idle if the process has no reason to stay around
///  - Call [`malloc_trim(3)`](man:malloc_trim(3)) to return cached heap pages to
///    the kernel (if supported by your libc)
///
/// Note that some actions may not always improve system performance, and so
/// should be profiled for your application. ``malloc_trim``, for example, may
/// make future heap allocations slower (due to releasing cached heap pages back
/// to the kernel).
///
/// See `gio.MemoryMonitorWarningLevel` for details on the various warning
/// levels.
///
/// ```c
/// static void
/// warning_cb (GMemoryMonitor *m, GMemoryMonitorWarningLevel level)
/// {
///   g_debug ("Warning level: `d`", level);
///   if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
///     drop_caches ();
/// }
///
/// static GMemoryMonitor *
/// monitor_low_memory (void)
/// {
///   GMemoryMonitor *m;
///   m = g_memory_monitor_dup_default ();
///   g_signal_connect (G_OBJECT (m), "low-memory-warning",
///                     G_CALLBACK (warning_cb), NULL);
///   return m;
/// }
/// ```
///
/// Don’t forget to disconnect the `gio.MemoryMonitor.signals.low_memory_warning`
/// signal, and unref the `GMemoryMonitor` itself when exiting.
pub const MemoryMonitor = opaque {
    pub const Prerequisites = [_]type{gio.Initable};
    pub const Iface = gio.MemoryMonitorInterface;
    pub const virtual_methods = struct {
        /// the virtual function pointer for the
        ///  `gio.MemoryMonitor.signals.low`-memory-warning signal.
        pub const low_memory_warning = struct {
            pub fn call(p_class: anytype, p_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_level: gio.MemoryMonitorWarningLevel) void {
                return gobject.ext.as(MemoryMonitor.Iface, p_class).f_low_memory_warning.?(gobject.ext.as(MemoryMonitor, p_monitor), p_level);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_level: gio.MemoryMonitorWarningLevel) callconv(.c) void) void {
                gobject.ext.as(MemoryMonitor.Iface, p_class).f_low_memory_warning = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// Emitted when the system is running low on free memory. The signal
        /// handler should then take the appropriate action depending on the
        /// warning level. See the `gio.MemoryMonitorWarningLevel` documentation for
        /// details.
        pub const low_memory_warning = struct {
            pub const name = "low-memory-warning";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_level: gio.MemoryMonitorWarningLevel, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(MemoryMonitor, p_instance))),
                    gobject.signalLookup("low-memory-warning", MemoryMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Gets a reference to the default `gio.MemoryMonitor` for the system.
    extern fn g_memory_monitor_dup_default() *gio.MemoryMonitor;
    pub const dupDefault = g_memory_monitor_dup_default;

    extern fn g_memory_monitor_get_type() usize;
    pub const getGObjectType = g_memory_monitor_get_type;

    extern fn g_object_ref(p_self: *gio.MemoryMonitor) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.MemoryMonitor) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *MemoryMonitor, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `GMount` interface represents a user-visible mount, such as a mounted
/// file system.
///
/// `GMount` is a ‘mounted’ filesystem that you can access. Mounted is in
/// quotes because it’s not the same as a UNIX mount, it might be a GVFS
/// mount, but you can still access the files on it if you use GIO.
///
/// A `GMount` might be associated with a `gio.Volume` (such as a USB flash
/// drive) which hosts it.
///
/// Unmounting a `GMount` instance is an asynchronous operation. For
/// more information about asynchronous operations, see `gio.AsyncResult`
/// and `gio.Task`. To unmount a `GMount` instance, first call
/// `gio.Mount.unmountWithOperation` with (at least) the `GMount`
/// instance and a `gio.AsyncReadyCallback`.  The callback will be fired
/// when the operation has resolved (either with success or failure), and a
/// `gio.AsyncResult` structure will be passed to the callback.  That
/// callback should then call `gio.Mount.unmountWithOperationFinish`
/// with the `GMount` and the `gio.AsyncResult` data to see if the
/// operation was completed successfully.  If an `error` is present when
/// `gio.Mount.unmountWithOperationFinish` is called, then it will be
/// filled with any error information.
///
/// Note, when [porting from GnomeVFS](migrating-gnome-vfs.html), `GMount` is the
/// moral equivalent of `GnomeVFSVolume`.
pub const Mount = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.MountIface;
    pub const virtual_methods = struct {
        /// Checks if `mount` can be ejected.
        pub const can_eject = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Mount.Iface, p_class).f_can_eject.?(gobject.ext.as(Mount, p_mount));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Mount.Iface, p_class).f_can_eject = @ptrCast(p_implementation);
            }
        };

        /// Checks if `mount` can be unmounted.
        pub const can_unmount = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Mount.Iface, p_class).f_can_unmount.?(gobject.ext.as(Mount, p_mount));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Mount.Iface, p_class).f_can_unmount = @ptrCast(p_implementation);
            }
        };

        /// Changed signal that is emitted when the mount's state has changed.
        pub const changed = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Mount.Iface, p_class).f_changed.?(gobject.ext.as(Mount, p_mount));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Mount.Iface, p_class).f_changed = @ptrCast(p_implementation);
            }
        };

        /// Ejects a mount. This is an asynchronous operation, and is
        /// finished by calling `gio.Mount.ejectFinish` with the `mount`
        /// and `gio.AsyncResult` data returned in the `callback`.
        pub const eject = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Mount.Iface, p_class).f_eject.?(gobject.ext.as(Mount, p_mount), p_flags, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Mount.Iface, p_class).f_eject = @ptrCast(p_implementation);
            }
        };

        /// Finishes ejecting a mount. If any errors occurred during the operation,
        /// `error` will be set to contain the errors and `FALSE` will be returned.
        pub const eject_finish = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Mount.Iface, p_class).f_eject_finish.?(gobject.ext.as(Mount, p_mount), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Mount.Iface, p_class).f_eject_finish = @ptrCast(p_implementation);
            }
        };

        /// Ejects a mount. This is an asynchronous operation, and is
        /// finished by calling `gio.Mount.ejectWithOperationFinish` with the `mount`
        /// and `gio.AsyncResult` data returned in the `callback`.
        pub const eject_with_operation = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Mount.Iface, p_class).f_eject_with_operation.?(gobject.ext.as(Mount, p_mount), p_flags, p_mount_operation, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Mount.Iface, p_class).f_eject_with_operation = @ptrCast(p_implementation);
            }
        };

        /// Finishes ejecting a mount. If any errors occurred during the operation,
        /// `error` will be set to contain the errors and `FALSE` will be returned.
        pub const eject_with_operation_finish = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Mount.Iface, p_class).f_eject_with_operation_finish.?(gobject.ext.as(Mount, p_mount), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Mount.Iface, p_class).f_eject_with_operation_finish = @ptrCast(p_implementation);
            }
        };

        /// Gets the default location of `mount`. The default location of the given
        /// `mount` is a path that reflects the main entry point for the user (e.g.
        /// the home directory, or the root of the volume).
        pub const get_default_location = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.File {
                return gobject.ext.as(Mount.Iface, p_class).f_get_default_location.?(gobject.ext.as(Mount, p_mount));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.File) void {
                gobject.ext.as(Mount.Iface, p_class).f_get_default_location = @ptrCast(p_implementation);
            }
        };

        /// Gets the drive for the `mount`.
        ///
        /// This is a convenience method for getting the `gio.Volume` and then
        /// using that object to get the `gio.Drive`.
        pub const get_drive = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*gio.Drive {
                return gobject.ext.as(Mount.Iface, p_class).f_get_drive.?(gobject.ext.as(Mount, p_mount));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*gio.Drive) void {
                gobject.ext.as(Mount.Iface, p_class).f_get_drive = @ptrCast(p_implementation);
            }
        };

        /// Gets the icon for `mount`.
        pub const get_icon = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.Icon {
                return gobject.ext.as(Mount.Iface, p_class).f_get_icon.?(gobject.ext.as(Mount, p_mount));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.Icon) void {
                gobject.ext.as(Mount.Iface, p_class).f_get_icon = @ptrCast(p_implementation);
            }
        };

        /// Gets the name of `mount`.
        pub const get_name = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]u8 {
                return gobject.ext.as(Mount.Iface, p_class).f_get_name.?(gobject.ext.as(Mount, p_mount));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]u8) void {
                gobject.ext.as(Mount.Iface, p_class).f_get_name = @ptrCast(p_implementation);
            }
        };

        /// Gets the root directory on `mount`.
        pub const get_root = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.File {
                return gobject.ext.as(Mount.Iface, p_class).f_get_root.?(gobject.ext.as(Mount, p_mount));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.File) void {
                gobject.ext.as(Mount.Iface, p_class).f_get_root = @ptrCast(p_implementation);
            }
        };

        /// Gets the sort key for `mount`, if any.
        pub const get_sort_key = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]const u8 {
                return gobject.ext.as(Mount.Iface, p_class).f_get_sort_key.?(gobject.ext.as(Mount, p_mount));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]const u8) void {
                gobject.ext.as(Mount.Iface, p_class).f_get_sort_key = @ptrCast(p_implementation);
            }
        };

        /// Gets the symbolic icon for `mount`.
        pub const get_symbolic_icon = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.Icon {
                return gobject.ext.as(Mount.Iface, p_class).f_get_symbolic_icon.?(gobject.ext.as(Mount, p_mount));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.Icon) void {
                gobject.ext.as(Mount.Iface, p_class).f_get_symbolic_icon = @ptrCast(p_implementation);
            }
        };

        /// Gets the UUID for the `mount`. The reference is typically based on
        /// the file system UUID for the mount in question and should be
        /// considered an opaque string. Returns `NULL` if there is no UUID
        /// available.
        pub const get_uuid = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]u8 {
                return gobject.ext.as(Mount.Iface, p_class).f_get_uuid.?(gobject.ext.as(Mount, p_mount));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]u8) void {
                gobject.ext.as(Mount.Iface, p_class).f_get_uuid = @ptrCast(p_implementation);
            }
        };

        /// Gets the volume for the `mount`.
        pub const get_volume = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*gio.Volume {
                return gobject.ext.as(Mount.Iface, p_class).f_get_volume.?(gobject.ext.as(Mount, p_mount));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*gio.Volume) void {
                gobject.ext.as(Mount.Iface, p_class).f_get_volume = @ptrCast(p_implementation);
            }
        };

        /// Tries to guess the type of content stored on `mount`. Returns one or
        /// more textual identifiers of well-known content types (typically
        /// prefixed with "x-content/"), e.g. x-content/image-dcf for camera
        /// memory cards. See the
        /// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
        /// specification for more on x-content types.
        ///
        /// This is an asynchronous operation (see
        /// `gio.Mount.guessContentTypeSync` for the synchronous version), and
        /// is finished by calling `gio.Mount.guessContentTypeFinish` with the
        /// `mount` and `gio.AsyncResult` data returned in the `callback`.
        pub const guess_content_type = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_force_rescan: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Mount.Iface, p_class).f_guess_content_type.?(gobject.ext.as(Mount, p_mount), p_force_rescan, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_force_rescan: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Mount.Iface, p_class).f_guess_content_type = @ptrCast(p_implementation);
            }
        };

        /// Finishes guessing content types of `mount`. If any errors occurred
        /// during the operation, `error` will be set to contain the errors and
        /// `FALSE` will be returned. In particular, you may get an
        /// `G_IO_ERROR_NOT_SUPPORTED` if the mount does not support content
        /// guessing.
        pub const guess_content_type_finish = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?[*][*:0]u8 {
                return gobject.ext.as(Mount.Iface, p_class).f_guess_content_type_finish.?(gobject.ext.as(Mount, p_mount), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?[*][*:0]u8) void {
                gobject.ext.as(Mount.Iface, p_class).f_guess_content_type_finish = @ptrCast(p_implementation);
            }
        };

        /// Tries to guess the type of content stored on `mount`. Returns one or
        /// more textual identifiers of well-known content types (typically
        /// prefixed with "x-content/"), e.g. x-content/image-dcf for camera
        /// memory cards. See the
        /// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
        /// specification for more on x-content types.
        ///
        /// This is a synchronous operation and as such may block doing IO;
        /// see `gio.Mount.guessContentType` for the asynchronous version.
        pub const guess_content_type_sync = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_force_rescan: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?[*][*:0]u8 {
                return gobject.ext.as(Mount.Iface, p_class).f_guess_content_type_sync.?(gobject.ext.as(Mount, p_mount), p_force_rescan, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_force_rescan: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?[*][*:0]u8) void {
                gobject.ext.as(Mount.Iface, p_class).f_guess_content_type_sync = @ptrCast(p_implementation);
            }
        };

        /// The ::pre-unmount signal that is emitted when the `gio.Mount` will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file.
        pub const pre_unmount = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Mount.Iface, p_class).f_pre_unmount.?(gobject.ext.as(Mount, p_mount));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Mount.Iface, p_class).f_pre_unmount = @ptrCast(p_implementation);
            }
        };

        /// Remounts a mount. This is an asynchronous operation, and is
        /// finished by calling `gio.Mount.remountFinish` with the `mount`
        /// and `GAsyncResults` data returned in the `callback`.
        ///
        /// Remounting is useful when some setting affecting the operation
        /// of the volume has been changed, as these may need a remount to
        /// take affect. While this is semantically equivalent with unmounting
        /// and then remounting not all backends might need to actually be
        /// unmounted.
        pub const remount = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Mount.Iface, p_class).f_remount.?(gobject.ext.as(Mount, p_mount), p_flags, p_mount_operation, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Mount.Iface, p_class).f_remount = @ptrCast(p_implementation);
            }
        };

        /// Finishes remounting a mount. If any errors occurred during the operation,
        /// `error` will be set to contain the errors and `FALSE` will be returned.
        pub const remount_finish = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Mount.Iface, p_class).f_remount_finish.?(gobject.ext.as(Mount, p_mount), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Mount.Iface, p_class).f_remount_finish = @ptrCast(p_implementation);
            }
        };

        /// Unmounts a mount. This is an asynchronous operation, and is
        /// finished by calling `gio.Mount.unmountFinish` with the `mount`
        /// and `gio.AsyncResult` data returned in the `callback`.
        pub const unmount = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Mount.Iface, p_class).f_unmount.?(gobject.ext.as(Mount, p_mount), p_flags, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Mount.Iface, p_class).f_unmount = @ptrCast(p_implementation);
            }
        };

        /// Finishes unmounting a mount. If any errors occurred during the operation,
        /// `error` will be set to contain the errors and `FALSE` will be returned.
        pub const unmount_finish = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Mount.Iface, p_class).f_unmount_finish.?(gobject.ext.as(Mount, p_mount), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Mount.Iface, p_class).f_unmount_finish = @ptrCast(p_implementation);
            }
        };

        /// Unmounts a mount. This is an asynchronous operation, and is
        /// finished by calling `gio.Mount.unmountWithOperationFinish` with the `mount`
        /// and `gio.AsyncResult` data returned in the `callback`.
        pub const unmount_with_operation = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Mount.Iface, p_class).f_unmount_with_operation.?(gobject.ext.as(Mount, p_mount), p_flags, p_mount_operation, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Mount.Iface, p_class).f_unmount_with_operation = @ptrCast(p_implementation);
            }
        };

        /// Finishes unmounting a mount. If any errors occurred during the operation,
        /// `error` will be set to contain the errors and `FALSE` will be returned.
        pub const unmount_with_operation_finish = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Mount.Iface, p_class).f_unmount_with_operation_finish.?(gobject.ext.as(Mount, p_mount), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Mount.Iface, p_class).f_unmount_with_operation_finish = @ptrCast(p_implementation);
            }
        };

        /// The unmounted signal that is emitted when the `gio.Mount` have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.
        pub const unmounted = struct {
            pub fn call(p_class: anytype, p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Mount.Iface, p_class).f_unmounted.?(gobject.ext.as(Mount, p_mount));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_mount: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Mount.Iface, p_class).f_unmounted = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// Emitted when the mount has been changed.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Mount, p_instance))),
                    gobject.signalLookup("changed", Mount.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal may be emitted when the `gio.Mount` is about to be
        /// unmounted.
        ///
        /// This signal depends on the backend and is only emitted if
        /// GIO was used to unmount.
        pub const pre_unmount = struct {
            pub const name = "pre-unmount";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Mount, p_instance))),
                    gobject.signalLookup("pre-unmount", Mount.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when the `gio.Mount` have been
        /// unmounted. If the recipient is holding references to the
        /// object they should release them so the object can be
        /// finalized.
        pub const unmounted = struct {
            pub const name = "unmounted";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Mount, p_instance))),
                    gobject.signalLookup("unmounted", Mount.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Checks if `mount` can be ejected.
    extern fn g_mount_can_eject(p_mount: *Mount) c_int;
    pub const canEject = g_mount_can_eject;

    /// Checks if `mount` can be unmounted.
    extern fn g_mount_can_unmount(p_mount: *Mount) c_int;
    pub const canUnmount = g_mount_can_unmount;

    /// Ejects a mount. This is an asynchronous operation, and is
    /// finished by calling `gio.Mount.ejectFinish` with the `mount`
    /// and `gio.AsyncResult` data returned in the `callback`.
    extern fn g_mount_eject(p_mount: *Mount, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const eject = g_mount_eject;

    /// Finishes ejecting a mount. If any errors occurred during the operation,
    /// `error` will be set to contain the errors and `FALSE` will be returned.
    extern fn g_mount_eject_finish(p_mount: *Mount, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const ejectFinish = g_mount_eject_finish;

    /// Ejects a mount. This is an asynchronous operation, and is
    /// finished by calling `gio.Mount.ejectWithOperationFinish` with the `mount`
    /// and `gio.AsyncResult` data returned in the `callback`.
    extern fn g_mount_eject_with_operation(p_mount: *Mount, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const ejectWithOperation = g_mount_eject_with_operation;

    /// Finishes ejecting a mount. If any errors occurred during the operation,
    /// `error` will be set to contain the errors and `FALSE` will be returned.
    extern fn g_mount_eject_with_operation_finish(p_mount: *Mount, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const ejectWithOperationFinish = g_mount_eject_with_operation_finish;

    /// Gets the default location of `mount`. The default location of the given
    /// `mount` is a path that reflects the main entry point for the user (e.g.
    /// the home directory, or the root of the volume).
    extern fn g_mount_get_default_location(p_mount: *Mount) *gio.File;
    pub const getDefaultLocation = g_mount_get_default_location;

    /// Gets the drive for the `mount`.
    ///
    /// This is a convenience method for getting the `gio.Volume` and then
    /// using that object to get the `gio.Drive`.
    extern fn g_mount_get_drive(p_mount: *Mount) ?*gio.Drive;
    pub const getDrive = g_mount_get_drive;

    /// Gets the icon for `mount`.
    extern fn g_mount_get_icon(p_mount: *Mount) *gio.Icon;
    pub const getIcon = g_mount_get_icon;

    /// Gets the name of `mount`.
    extern fn g_mount_get_name(p_mount: *Mount) [*:0]u8;
    pub const getName = g_mount_get_name;

    /// Gets the root directory on `mount`.
    extern fn g_mount_get_root(p_mount: *Mount) *gio.File;
    pub const getRoot = g_mount_get_root;

    /// Gets the sort key for `mount`, if any.
    extern fn g_mount_get_sort_key(p_mount: *Mount) ?[*:0]const u8;
    pub const getSortKey = g_mount_get_sort_key;

    /// Gets the symbolic icon for `mount`.
    extern fn g_mount_get_symbolic_icon(p_mount: *Mount) *gio.Icon;
    pub const getSymbolicIcon = g_mount_get_symbolic_icon;

    /// Gets the UUID for the `mount`. The reference is typically based on
    /// the file system UUID for the mount in question and should be
    /// considered an opaque string. Returns `NULL` if there is no UUID
    /// available.
    extern fn g_mount_get_uuid(p_mount: *Mount) ?[*:0]u8;
    pub const getUuid = g_mount_get_uuid;

    /// Gets the volume for the `mount`.
    extern fn g_mount_get_volume(p_mount: *Mount) ?*gio.Volume;
    pub const getVolume = g_mount_get_volume;

    /// Tries to guess the type of content stored on `mount`. Returns one or
    /// more textual identifiers of well-known content types (typically
    /// prefixed with "x-content/"), e.g. x-content/image-dcf for camera
    /// memory cards. See the
    /// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
    /// specification for more on x-content types.
    ///
    /// This is an asynchronous operation (see
    /// `gio.Mount.guessContentTypeSync` for the synchronous version), and
    /// is finished by calling `gio.Mount.guessContentTypeFinish` with the
    /// `mount` and `gio.AsyncResult` data returned in the `callback`.
    extern fn g_mount_guess_content_type(p_mount: *Mount, p_force_rescan: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const guessContentType = g_mount_guess_content_type;

    /// Finishes guessing content types of `mount`. If any errors occurred
    /// during the operation, `error` will be set to contain the errors and
    /// `FALSE` will be returned. In particular, you may get an
    /// `G_IO_ERROR_NOT_SUPPORTED` if the mount does not support content
    /// guessing.
    extern fn g_mount_guess_content_type_finish(p_mount: *Mount, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?[*][*:0]u8;
    pub const guessContentTypeFinish = g_mount_guess_content_type_finish;

    /// Tries to guess the type of content stored on `mount`. Returns one or
    /// more textual identifiers of well-known content types (typically
    /// prefixed with "x-content/"), e.g. x-content/image-dcf for camera
    /// memory cards. See the
    /// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
    /// specification for more on x-content types.
    ///
    /// This is a synchronous operation and as such may block doing IO;
    /// see `gio.Mount.guessContentType` for the asynchronous version.
    extern fn g_mount_guess_content_type_sync(p_mount: *Mount, p_force_rescan: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?[*][*:0]u8;
    pub const guessContentTypeSync = g_mount_guess_content_type_sync;

    /// Determines if `mount` is shadowed. Applications or libraries should
    /// avoid displaying `mount` in the user interface if it is shadowed.
    ///
    /// A mount is said to be shadowed if there exists one or more user
    /// visible objects (currently `gio.Mount` objects) with a root that is
    /// inside the root of `mount`.
    ///
    /// One application of shadow mounts is when exposing a single file
    /// system that is used to address several logical volumes. In this
    /// situation, a `gio.VolumeMonitor` implementation would create two
    /// `gio.Volume` objects (for example, one for the camera functionality of
    /// the device and one for a SD card reader on the device) with
    /// activation URIs `gphoto2://[usb:001,002]/store1/`
    /// and `gphoto2://[usb:001,002]/store2/`. When the
    /// underlying mount (with root
    /// `gphoto2://[usb:001,002]/`) is mounted, said
    /// `gio.VolumeMonitor` implementation would create two `gio.Mount` objects
    /// (each with their root matching the corresponding volume activation
    /// root) that would shadow the original mount.
    ///
    /// The proxy monitor in GVfs 2.26 and later, automatically creates and
    /// manage shadow mounts (and shadows the underlying mount) if the
    /// activation root on a `gio.Volume` is set.
    extern fn g_mount_is_shadowed(p_mount: *Mount) c_int;
    pub const isShadowed = g_mount_is_shadowed;

    /// Remounts a mount. This is an asynchronous operation, and is
    /// finished by calling `gio.Mount.remountFinish` with the `mount`
    /// and `GAsyncResults` data returned in the `callback`.
    ///
    /// Remounting is useful when some setting affecting the operation
    /// of the volume has been changed, as these may need a remount to
    /// take affect. While this is semantically equivalent with unmounting
    /// and then remounting not all backends might need to actually be
    /// unmounted.
    extern fn g_mount_remount(p_mount: *Mount, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const remount = g_mount_remount;

    /// Finishes remounting a mount. If any errors occurred during the operation,
    /// `error` will be set to contain the errors and `FALSE` will be returned.
    extern fn g_mount_remount_finish(p_mount: *Mount, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const remountFinish = g_mount_remount_finish;

    /// Increments the shadow count on `mount`. Usually used by
    /// `gio.VolumeMonitor` implementations when creating a shadow mount for
    /// `mount`, see `gio.Mount.isShadowed` for more information. The caller
    /// will need to emit the `gio.Mount.signals.changed` signal on `mount` manually.
    extern fn g_mount_shadow(p_mount: *Mount) void;
    pub const shadow = g_mount_shadow;

    /// Unmounts a mount. This is an asynchronous operation, and is
    /// finished by calling `gio.Mount.unmountFinish` with the `mount`
    /// and `gio.AsyncResult` data returned in the `callback`.
    extern fn g_mount_unmount(p_mount: *Mount, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const unmount = g_mount_unmount;

    /// Finishes unmounting a mount. If any errors occurred during the operation,
    /// `error` will be set to contain the errors and `FALSE` will be returned.
    extern fn g_mount_unmount_finish(p_mount: *Mount, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const unmountFinish = g_mount_unmount_finish;

    /// Unmounts a mount. This is an asynchronous operation, and is
    /// finished by calling `gio.Mount.unmountWithOperationFinish` with the `mount`
    /// and `gio.AsyncResult` data returned in the `callback`.
    extern fn g_mount_unmount_with_operation(p_mount: *Mount, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const unmountWithOperation = g_mount_unmount_with_operation;

    /// Finishes unmounting a mount. If any errors occurred during the operation,
    /// `error` will be set to contain the errors and `FALSE` will be returned.
    extern fn g_mount_unmount_with_operation_finish(p_mount: *Mount, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const unmountWithOperationFinish = g_mount_unmount_with_operation_finish;

    /// Decrements the shadow count on `mount`. Usually used by
    /// `gio.VolumeMonitor` implementations when destroying a shadow mount for
    /// `mount`, see `gio.Mount.isShadowed` for more information. The caller
    /// will need to emit the `gio.Mount.signals.changed` signal on `mount` manually.
    extern fn g_mount_unshadow(p_mount: *Mount) void;
    pub const unshadow = g_mount_unshadow;

    extern fn g_mount_get_type() usize;
    pub const getGObjectType = g_mount_get_type;

    extern fn g_object_ref(p_self: *gio.Mount) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Mount) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Mount, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GNetworkMonitor` provides an easy-to-use cross-platform API
/// for monitoring network connectivity. On Linux, the available
/// implementations are based on the kernel's netlink interface and
/// on NetworkManager.
///
/// There is also an implementation for use inside Flatpak sandboxes.
pub const NetworkMonitor = opaque {
    pub const Prerequisites = [_]type{gio.Initable};
    pub const Iface = gio.NetworkMonitorInterface;
    pub const virtual_methods = struct {
        /// Attempts to determine whether or not the host pointed to by
        /// `connectable` can be reached, without actually trying to connect to
        /// it.
        ///
        /// This may return `TRUE` even when `gio.NetworkMonitor.properties.network`-available
        /// is `FALSE`, if, for example, `monitor` can determine that
        /// `connectable` refers to a host on a local network.
        ///
        /// If `monitor` believes that an attempt to connect to `connectable`
        /// will succeed, it will return `TRUE`. Otherwise, it will return
        /// `FALSE` and set `error` to an appropriate error (such as
        /// `G_IO_ERROR_HOST_UNREACHABLE`).
        ///
        /// Note that although this does not attempt to connect to
        /// `connectable`, it may still block for a brief period of time (eg,
        /// trying to do multicast DNS on the local network), so if you do not
        /// want to block, you should use `gio.NetworkMonitor.canReachAsync`.
        pub const can_reach = struct {
            pub fn call(p_class: anytype, p_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connectable: *gio.SocketConnectable, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(NetworkMonitor.Iface, p_class).f_can_reach.?(gobject.ext.as(NetworkMonitor, p_monitor), p_connectable, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connectable: *gio.SocketConnectable, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(NetworkMonitor.Iface, p_class).f_can_reach = @ptrCast(p_implementation);
            }
        };

        /// Asynchronously attempts to determine whether or not the host
        /// pointed to by `connectable` can be reached, without actually
        /// trying to connect to it.
        ///
        /// For more details, see `gio.NetworkMonitor.canReach`.
        ///
        /// When the operation is finished, `callback` will be called.
        /// You can then call `gio.NetworkMonitor.canReachFinish`
        /// to get the result of the operation.
        pub const can_reach_async = struct {
            pub fn call(p_class: anytype, p_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connectable: *gio.SocketConnectable, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(NetworkMonitor.Iface, p_class).f_can_reach_async.?(gobject.ext.as(NetworkMonitor, p_monitor), p_connectable, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connectable: *gio.SocketConnectable, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(NetworkMonitor.Iface, p_class).f_can_reach_async = @ptrCast(p_implementation);
            }
        };

        /// Finishes an async network connectivity test.
        /// See `gio.NetworkMonitor.canReachAsync`.
        pub const can_reach_finish = struct {
            pub fn call(p_class: anytype, p_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(NetworkMonitor.Iface, p_class).f_can_reach_finish.?(gobject.ext.as(NetworkMonitor, p_monitor), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(NetworkMonitor.Iface, p_class).f_can_reach_finish = @ptrCast(p_implementation);
            }
        };

        /// the virtual function pointer for the
        ///  GNetworkMonitor::network-changed signal.
        pub const network_changed = struct {
            pub fn call(p_class: anytype, p_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_network_available: c_int) void {
                return gobject.ext.as(NetworkMonitor.Iface, p_class).f_network_changed.?(gobject.ext.as(NetworkMonitor, p_monitor), p_network_available);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_monitor: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_network_available: c_int) callconv(.c) void) void {
                gobject.ext.as(NetworkMonitor.Iface, p_class).f_network_changed = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// More detailed information about the host's network connectivity.
        /// See `gio.NetworkMonitor.getConnectivity` and
        /// `gio.NetworkConnectivity` for more details.
        pub const connectivity = struct {
            pub const name = "connectivity";

            pub const Type = gio.NetworkConnectivity;
        };

        /// Whether the network is considered available. That is, whether the
        /// system has a default route for at least one of IPv4 or IPv6.
        ///
        /// Real-world networks are of course much more complicated than
        /// this; the machine may be connected to a wifi hotspot that
        /// requires payment before allowing traffic through, or may be
        /// connected to a functioning router that has lost its own upstream
        /// connectivity. Some hosts might only be accessible when a VPN is
        /// active. Other hosts might only be accessible when the VPN is
        /// not active. Thus, it is best to use `gio.NetworkMonitor.canReach`
        /// or `gio.NetworkMonitor.canReachAsync` to test for reachability
        /// on a host-by-host basis. (On the other hand, when the property is
        /// `FALSE`, the application can reasonably expect that no remote
        /// hosts at all are reachable, and should indicate this to the user
        /// in its UI.)
        ///
        /// See also `gio.NetworkMonitor.signals.network`-changed.
        pub const network_available = struct {
            pub const name = "network-available";

            pub const Type = c_int;
        };

        /// Whether the network is considered metered.
        ///
        /// That is, whether the
        /// system has traffic flowing through the default connection that is
        /// subject to limitations set by service providers. For example, traffic
        /// might be billed by the amount of data transmitted, or there might be a
        /// quota on the amount of traffic per month. This is typical with tethered
        /// connections (3G and 4G) and in such situations, bandwidth intensive
        /// applications may wish to avoid network activity where possible if it will
        /// cost the user money or use up their limited quota. Anything more than a
        /// few hundreds of kilobytes of data usage per hour should be avoided without
        /// asking permission from the user.
        ///
        /// If more information is required about specific devices then the
        /// system network management API should be used instead (for example,
        /// NetworkManager or ConnMan).
        ///
        /// If this information is not available then no networks will be
        /// marked as metered.
        ///
        /// See also `gio.NetworkMonitor.properties.network`-available.
        pub const network_metered = struct {
            pub const name = "network-metered";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {
        /// Emitted when the network configuration changes.
        pub const network_changed = struct {
            pub const name = "network-changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), p_network_available: c_int, P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(NetworkMonitor, p_instance))),
                    gobject.signalLookup("network-changed", NetworkMonitor.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Gets the default `gio.NetworkMonitor` for the system.
    extern fn g_network_monitor_get_default() *gio.NetworkMonitor;
    pub const getDefault = g_network_monitor_get_default;

    /// Attempts to determine whether or not the host pointed to by
    /// `connectable` can be reached, without actually trying to connect to
    /// it.
    ///
    /// This may return `TRUE` even when `gio.NetworkMonitor.properties.network`-available
    /// is `FALSE`, if, for example, `monitor` can determine that
    /// `connectable` refers to a host on a local network.
    ///
    /// If `monitor` believes that an attempt to connect to `connectable`
    /// will succeed, it will return `TRUE`. Otherwise, it will return
    /// `FALSE` and set `error` to an appropriate error (such as
    /// `G_IO_ERROR_HOST_UNREACHABLE`).
    ///
    /// Note that although this does not attempt to connect to
    /// `connectable`, it may still block for a brief period of time (eg,
    /// trying to do multicast DNS on the local network), so if you do not
    /// want to block, you should use `gio.NetworkMonitor.canReachAsync`.
    extern fn g_network_monitor_can_reach(p_monitor: *NetworkMonitor, p_connectable: *gio.SocketConnectable, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const canReach = g_network_monitor_can_reach;

    /// Asynchronously attempts to determine whether or not the host
    /// pointed to by `connectable` can be reached, without actually
    /// trying to connect to it.
    ///
    /// For more details, see `gio.NetworkMonitor.canReach`.
    ///
    /// When the operation is finished, `callback` will be called.
    /// You can then call `gio.NetworkMonitor.canReachFinish`
    /// to get the result of the operation.
    extern fn g_network_monitor_can_reach_async(p_monitor: *NetworkMonitor, p_connectable: *gio.SocketConnectable, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const canReachAsync = g_network_monitor_can_reach_async;

    /// Finishes an async network connectivity test.
    /// See `gio.NetworkMonitor.canReachAsync`.
    extern fn g_network_monitor_can_reach_finish(p_monitor: *NetworkMonitor, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const canReachFinish = g_network_monitor_can_reach_finish;

    /// Gets a more detailed networking state than
    /// `gio.NetworkMonitor.getNetworkAvailable`.
    ///
    /// If `gio.NetworkMonitor.properties.network`-available is `FALSE`, then the
    /// connectivity state will be `G_NETWORK_CONNECTIVITY_LOCAL`.
    ///
    /// If `gio.NetworkMonitor.properties.network`-available is `TRUE`, then the
    /// connectivity state will be `G_NETWORK_CONNECTIVITY_FULL` (if there
    /// is full Internet connectivity), `G_NETWORK_CONNECTIVITY_LIMITED` (if
    /// the host has a default route, but appears to be unable to actually
    /// reach the full Internet), or `G_NETWORK_CONNECTIVITY_PORTAL` (if the
    /// host is trapped behind a "captive portal" that requires some sort
    /// of login or acknowledgement before allowing full Internet access).
    ///
    /// Note that in the case of `G_NETWORK_CONNECTIVITY_LIMITED` and
    /// `G_NETWORK_CONNECTIVITY_PORTAL`, it is possible that some sites are
    /// reachable but others are not. In this case, applications can
    /// attempt to connect to remote servers, but should gracefully fall
    /// back to their "offline" behavior if the connection attempt fails.
    extern fn g_network_monitor_get_connectivity(p_monitor: *NetworkMonitor) gio.NetworkConnectivity;
    pub const getConnectivity = g_network_monitor_get_connectivity;

    /// Checks if the network is available. "Available" here means that the
    /// system has a default route available for at least one of IPv4 or
    /// IPv6. It does not necessarily imply that the public Internet is
    /// reachable. See `gio.NetworkMonitor.properties.network`-available for more details.
    extern fn g_network_monitor_get_network_available(p_monitor: *NetworkMonitor) c_int;
    pub const getNetworkAvailable = g_network_monitor_get_network_available;

    /// Checks if the network is metered.
    /// See `gio.NetworkMonitor.properties.network`-metered for more details.
    extern fn g_network_monitor_get_network_metered(p_monitor: *NetworkMonitor) c_int;
    pub const getNetworkMetered = g_network_monitor_get_network_metered;

    extern fn g_network_monitor_get_type() usize;
    pub const getGObjectType = g_network_monitor_get_type;

    extern fn g_object_ref(p_self: *gio.NetworkMonitor) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.NetworkMonitor) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *NetworkMonitor, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GPollableInputStream` is implemented by `gio.InputStream`s that
/// can be polled for readiness to read. This can be used when
/// interfacing with a non-GIO API that expects
/// UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
///
/// Some classes may implement `GPollableInputStream` but have only certain
/// instances of that class be pollable. If `gio.PollableInputStream.canPoll`
/// returns false, then the behavior of other `GPollableInputStream` methods is
/// undefined.
pub const PollableInputStream = opaque {
    pub const Prerequisites = [_]type{gio.InputStream};
    pub const Iface = gio.PollableInputStreamInterface;
    pub const virtual_methods = struct {
        /// Checks if `stream` is actually pollable. Some classes may implement
        /// `gio.PollableInputStream` but have only certain instances of that class
        /// be pollable. If this method returns `FALSE`, then the behavior of
        /// other `gio.PollableInputStream` methods is undefined.
        ///
        /// For any given stream, the value returned by this method is constant;
        /// a stream cannot switch from pollable to non-pollable or vice versa.
        pub const can_poll = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(PollableInputStream.Iface, p_class).f_can_poll.?(gobject.ext.as(PollableInputStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(PollableInputStream.Iface, p_class).f_can_poll = @ptrCast(p_implementation);
            }
        };

        /// Creates a `glib.Source` that triggers when `stream` can be read, or
        /// `cancellable` is triggered or an error occurs. The callback on the
        /// source is of the `gio.PollableSourceFunc` type.
        ///
        /// As with `gio.PollableInputStream.isReadable`, it is possible that
        /// the stream may not actually be readable even after the source
        /// triggers, so you should use `gio.PollableInputStream.readNonblocking`
        /// rather than `gio.InputStream.read` from the callback.
        ///
        /// The behaviour of this method is undefined if
        /// `gio.PollableInputStream.canPoll` returns `FALSE` for `stream`.
        pub const create_source = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable) *glib.Source {
                return gobject.ext.as(PollableInputStream.Iface, p_class).f_create_source.?(gobject.ext.as(PollableInputStream, p_stream), p_cancellable);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable) callconv(.c) *glib.Source) void {
                gobject.ext.as(PollableInputStream.Iface, p_class).f_create_source = @ptrCast(p_implementation);
            }
        };

        /// Checks if `stream` can be read.
        ///
        /// Note that some stream types may not be able to implement this 100%
        /// reliably, and it is possible that a call to `gio.InputStream.read`
        /// after this returns `TRUE` would still block. To guarantee
        /// non-blocking behavior, you should always use
        /// `gio.PollableInputStream.readNonblocking`, which will return a
        /// `G_IO_ERROR_WOULD_BLOCK` error rather than blocking.
        ///
        /// The behaviour of this method is undefined if
        /// `gio.PollableInputStream.canPoll` returns `FALSE` for `stream`.
        pub const is_readable = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(PollableInputStream.Iface, p_class).f_is_readable.?(gobject.ext.as(PollableInputStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(PollableInputStream.Iface, p_class).f_is_readable = @ptrCast(p_implementation);
            }
        };

        /// Attempts to read up to `count` bytes from `stream` into `buffer`, as
        /// with `gio.InputStream.read`. If `stream` is not currently readable,
        /// this will immediately return `G_IO_ERROR_WOULD_BLOCK`, and you can
        /// use `gio.PollableInputStream.createSource` to create a `glib.Source`
        /// that will be triggered when `stream` is readable.
        ///
        /// Note that since this method never blocks, you cannot actually
        /// use `cancellable` to cancel it. However, it will return an error
        /// if `cancellable` has already been cancelled when you call, which
        /// may happen if you call this method after a source triggers due
        /// to having been cancelled.
        ///
        /// The behaviour of this method is undefined if
        /// `gio.PollableInputStream.canPoll` returns `FALSE` for `stream`.
        pub const read_nonblocking = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_buffer: ?*[*]u8, p_count: usize, p_error: ?*?*glib.Error) isize {
                return gobject.ext.as(PollableInputStream.Iface, p_class).f_read_nonblocking.?(gobject.ext.as(PollableInputStream, p_stream), p_buffer, p_count, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_buffer: ?*[*]u8, p_count: usize, p_error: ?*?*glib.Error) callconv(.c) isize) void {
                gobject.ext.as(PollableInputStream.Iface, p_class).f_read_nonblocking = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Checks if `stream` is actually pollable. Some classes may implement
    /// `gio.PollableInputStream` but have only certain instances of that class
    /// be pollable. If this method returns `FALSE`, then the behavior of
    /// other `gio.PollableInputStream` methods is undefined.
    ///
    /// For any given stream, the value returned by this method is constant;
    /// a stream cannot switch from pollable to non-pollable or vice versa.
    extern fn g_pollable_input_stream_can_poll(p_stream: *PollableInputStream) c_int;
    pub const canPoll = g_pollable_input_stream_can_poll;

    /// Creates a `glib.Source` that triggers when `stream` can be read, or
    /// `cancellable` is triggered or an error occurs. The callback on the
    /// source is of the `gio.PollableSourceFunc` type.
    ///
    /// As with `gio.PollableInputStream.isReadable`, it is possible that
    /// the stream may not actually be readable even after the source
    /// triggers, so you should use `gio.PollableInputStream.readNonblocking`
    /// rather than `gio.InputStream.read` from the callback.
    ///
    /// The behaviour of this method is undefined if
    /// `gio.PollableInputStream.canPoll` returns `FALSE` for `stream`.
    extern fn g_pollable_input_stream_create_source(p_stream: *PollableInputStream, p_cancellable: ?*gio.Cancellable) *glib.Source;
    pub const createSource = g_pollable_input_stream_create_source;

    /// Checks if `stream` can be read.
    ///
    /// Note that some stream types may not be able to implement this 100%
    /// reliably, and it is possible that a call to `gio.InputStream.read`
    /// after this returns `TRUE` would still block. To guarantee
    /// non-blocking behavior, you should always use
    /// `gio.PollableInputStream.readNonblocking`, which will return a
    /// `G_IO_ERROR_WOULD_BLOCK` error rather than blocking.
    ///
    /// The behaviour of this method is undefined if
    /// `gio.PollableInputStream.canPoll` returns `FALSE` for `stream`.
    extern fn g_pollable_input_stream_is_readable(p_stream: *PollableInputStream) c_int;
    pub const isReadable = g_pollable_input_stream_is_readable;

    /// Attempts to read up to `count` bytes from `stream` into `buffer`, as
    /// with `gio.InputStream.read`. If `stream` is not currently readable,
    /// this will immediately return `G_IO_ERROR_WOULD_BLOCK`, and you can
    /// use `gio.PollableInputStream.createSource` to create a `glib.Source`
    /// that will be triggered when `stream` is readable.
    ///
    /// Note that since this method never blocks, you cannot actually
    /// use `cancellable` to cancel it. However, it will return an error
    /// if `cancellable` has already been cancelled when you call, which
    /// may happen if you call this method after a source triggers due
    /// to having been cancelled.
    ///
    /// The behaviour of this method is undefined if
    /// `gio.PollableInputStream.canPoll` returns `FALSE` for `stream`.
    extern fn g_pollable_input_stream_read_nonblocking(p_stream: *PollableInputStream, p_buffer: *[*]u8, p_count: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const readNonblocking = g_pollable_input_stream_read_nonblocking;

    extern fn g_pollable_input_stream_get_type() usize;
    pub const getGObjectType = g_pollable_input_stream_get_type;

    extern fn g_object_ref(p_self: *gio.PollableInputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.PollableInputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *PollableInputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GPollableOutputStream` is implemented by `gio.OutputStream`s that
/// can be polled for readiness to write. This can be used when
/// interfacing with a non-GIO API that expects
/// UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
///
/// Some classes may implement `GPollableOutputStream` but have only certain
/// instances of that class be pollable. If `gio.PollableOutputStream.canPoll`
/// returns false, then the behavior of other `GPollableOutputStream` methods is
/// undefined.
pub const PollableOutputStream = opaque {
    pub const Prerequisites = [_]type{gio.OutputStream};
    pub const Iface = gio.PollableOutputStreamInterface;
    pub const virtual_methods = struct {
        /// Checks if `stream` is actually pollable. Some classes may implement
        /// `gio.PollableOutputStream` but have only certain instances of that
        /// class be pollable. If this method returns `FALSE`, then the behavior
        /// of other `gio.PollableOutputStream` methods is undefined.
        ///
        /// For any given stream, the value returned by this method is constant;
        /// a stream cannot switch from pollable to non-pollable or vice versa.
        pub const can_poll = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(PollableOutputStream.Iface, p_class).f_can_poll.?(gobject.ext.as(PollableOutputStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(PollableOutputStream.Iface, p_class).f_can_poll = @ptrCast(p_implementation);
            }
        };

        /// Creates a `glib.Source` that triggers when `stream` can be written, or
        /// `cancellable` is triggered or an error occurs. The callback on the
        /// source is of the `gio.PollableSourceFunc` type.
        ///
        /// As with `gio.PollableOutputStream.isWritable`, it is possible that
        /// the stream may not actually be writable even after the source
        /// triggers, so you should use `gio.PollableOutputStream.writeNonblocking`
        /// rather than `gio.OutputStream.write` from the callback.
        ///
        /// The behaviour of this method is undefined if
        /// `gio.PollableOutputStream.canPoll` returns `FALSE` for `stream`.
        pub const create_source = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable) *glib.Source {
                return gobject.ext.as(PollableOutputStream.Iface, p_class).f_create_source.?(gobject.ext.as(PollableOutputStream, p_stream), p_cancellable);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_cancellable: ?*gio.Cancellable) callconv(.c) *glib.Source) void {
                gobject.ext.as(PollableOutputStream.Iface, p_class).f_create_source = @ptrCast(p_implementation);
            }
        };

        /// Checks if `stream` can be written.
        ///
        /// Note that some stream types may not be able to implement this 100%
        /// reliably, and it is possible that a call to `gio.OutputStream.write`
        /// after this returns `TRUE` would still block. To guarantee
        /// non-blocking behavior, you should always use
        /// `gio.PollableOutputStream.writeNonblocking`, which will return a
        /// `G_IO_ERROR_WOULD_BLOCK` error rather than blocking.
        ///
        /// The behaviour of this method is undefined if
        /// `gio.PollableOutputStream.canPoll` returns `FALSE` for `stream`.
        pub const is_writable = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(PollableOutputStream.Iface, p_class).f_is_writable.?(gobject.ext.as(PollableOutputStream, p_stream));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(PollableOutputStream.Iface, p_class).f_is_writable = @ptrCast(p_implementation);
            }
        };

        /// Attempts to write up to `count` bytes from `buffer` to `stream`, as
        /// with `gio.OutputStream.write`. If `stream` is not currently writable,
        /// this will immediately return `G_IO_ERROR_WOULD_BLOCK`, and you can
        /// use `gio.PollableOutputStream.createSource` to create a `glib.Source`
        /// that will be triggered when `stream` is writable.
        ///
        /// Note that since this method never blocks, you cannot actually
        /// use `cancellable` to cancel it. However, it will return an error
        /// if `cancellable` has already been cancelled when you call, which
        /// may happen if you call this method after a source triggers due
        /// to having been cancelled.
        ///
        /// Also note that if `G_IO_ERROR_WOULD_BLOCK` is returned some underlying
        /// transports like D/TLS require that you re-send the same `buffer` and
        /// `count` in the next write call.
        ///
        /// The behaviour of this method is undefined if
        /// `gio.PollableOutputStream.canPoll` returns `FALSE` for `stream`.
        pub const write_nonblocking = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_buffer: ?[*]u8, p_count: usize, p_error: ?*?*glib.Error) isize {
                return gobject.ext.as(PollableOutputStream.Iface, p_class).f_write_nonblocking.?(gobject.ext.as(PollableOutputStream, p_stream), p_buffer, p_count, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_buffer: ?[*]u8, p_count: usize, p_error: ?*?*glib.Error) callconv(.c) isize) void {
                gobject.ext.as(PollableOutputStream.Iface, p_class).f_write_nonblocking = @ptrCast(p_implementation);
            }
        };

        /// Attempts to write the bytes contained in the `n_vectors` `vectors` to `stream`,
        /// as with `gio.OutputStream.writev`. If `stream` is not currently writable,
        /// this will immediately return %`G_POLLABLE_RETURN_WOULD_BLOCK`, and you can
        /// use `gio.PollableOutputStream.createSource` to create a `glib.Source`
        /// that will be triggered when `stream` is writable. `error` will *not* be
        /// set in that case.
        ///
        /// Note that since this method never blocks, you cannot actually
        /// use `cancellable` to cancel it. However, it will return an error
        /// if `cancellable` has already been cancelled when you call, which
        /// may happen if you call this method after a source triggers due
        /// to having been cancelled.
        ///
        /// Also note that if `G_POLLABLE_RETURN_WOULD_BLOCK` is returned some underlying
        /// transports like D/TLS require that you re-send the same `vectors` and
        /// `n_vectors` in the next write call.
        ///
        /// The behaviour of this method is undefined if
        /// `gio.PollableOutputStream.canPoll` returns `FALSE` for `stream`.
        pub const writev_nonblocking = struct {
            pub fn call(p_class: anytype, p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_vectors: [*]const gio.OutputVector, p_n_vectors: usize, p_bytes_written: ?*usize, p_error: ?*?*glib.Error) gio.PollableReturn {
                return gobject.ext.as(PollableOutputStream.Iface, p_class).f_writev_nonblocking.?(gobject.ext.as(PollableOutputStream, p_stream), p_vectors, p_n_vectors, p_bytes_written, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_stream: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_vectors: [*]const gio.OutputVector, p_n_vectors: usize, p_bytes_written: ?*usize, p_error: ?*?*glib.Error) callconv(.c) gio.PollableReturn) void {
                gobject.ext.as(PollableOutputStream.Iface, p_class).f_writev_nonblocking = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Checks if `stream` is actually pollable. Some classes may implement
    /// `gio.PollableOutputStream` but have only certain instances of that
    /// class be pollable. If this method returns `FALSE`, then the behavior
    /// of other `gio.PollableOutputStream` methods is undefined.
    ///
    /// For any given stream, the value returned by this method is constant;
    /// a stream cannot switch from pollable to non-pollable or vice versa.
    extern fn g_pollable_output_stream_can_poll(p_stream: *PollableOutputStream) c_int;
    pub const canPoll = g_pollable_output_stream_can_poll;

    /// Creates a `glib.Source` that triggers when `stream` can be written, or
    /// `cancellable` is triggered or an error occurs. The callback on the
    /// source is of the `gio.PollableSourceFunc` type.
    ///
    /// As with `gio.PollableOutputStream.isWritable`, it is possible that
    /// the stream may not actually be writable even after the source
    /// triggers, so you should use `gio.PollableOutputStream.writeNonblocking`
    /// rather than `gio.OutputStream.write` from the callback.
    ///
    /// The behaviour of this method is undefined if
    /// `gio.PollableOutputStream.canPoll` returns `FALSE` for `stream`.
    extern fn g_pollable_output_stream_create_source(p_stream: *PollableOutputStream, p_cancellable: ?*gio.Cancellable) *glib.Source;
    pub const createSource = g_pollable_output_stream_create_source;

    /// Checks if `stream` can be written.
    ///
    /// Note that some stream types may not be able to implement this 100%
    /// reliably, and it is possible that a call to `gio.OutputStream.write`
    /// after this returns `TRUE` would still block. To guarantee
    /// non-blocking behavior, you should always use
    /// `gio.PollableOutputStream.writeNonblocking`, which will return a
    /// `G_IO_ERROR_WOULD_BLOCK` error rather than blocking.
    ///
    /// The behaviour of this method is undefined if
    /// `gio.PollableOutputStream.canPoll` returns `FALSE` for `stream`.
    extern fn g_pollable_output_stream_is_writable(p_stream: *PollableOutputStream) c_int;
    pub const isWritable = g_pollable_output_stream_is_writable;

    /// Attempts to write up to `count` bytes from `buffer` to `stream`, as
    /// with `gio.OutputStream.write`. If `stream` is not currently writable,
    /// this will immediately return `G_IO_ERROR_WOULD_BLOCK`, and you can
    /// use `gio.PollableOutputStream.createSource` to create a `glib.Source`
    /// that will be triggered when `stream` is writable.
    ///
    /// Note that since this method never blocks, you cannot actually
    /// use `cancellable` to cancel it. However, it will return an error
    /// if `cancellable` has already been cancelled when you call, which
    /// may happen if you call this method after a source triggers due
    /// to having been cancelled.
    ///
    /// Also note that if `G_IO_ERROR_WOULD_BLOCK` is returned some underlying
    /// transports like D/TLS require that you re-send the same `buffer` and
    /// `count` in the next write call.
    ///
    /// The behaviour of this method is undefined if
    /// `gio.PollableOutputStream.canPoll` returns `FALSE` for `stream`.
    extern fn g_pollable_output_stream_write_nonblocking(p_stream: *PollableOutputStream, p_buffer: [*]u8, p_count: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
    pub const writeNonblocking = g_pollable_output_stream_write_nonblocking;

    /// Attempts to write the bytes contained in the `n_vectors` `vectors` to `stream`,
    /// as with `gio.OutputStream.writev`. If `stream` is not currently writable,
    /// this will immediately return %`G_POLLABLE_RETURN_WOULD_BLOCK`, and you can
    /// use `gio.PollableOutputStream.createSource` to create a `glib.Source`
    /// that will be triggered when `stream` is writable. `error` will *not* be
    /// set in that case.
    ///
    /// Note that since this method never blocks, you cannot actually
    /// use `cancellable` to cancel it. However, it will return an error
    /// if `cancellable` has already been cancelled when you call, which
    /// may happen if you call this method after a source triggers due
    /// to having been cancelled.
    ///
    /// Also note that if `G_POLLABLE_RETURN_WOULD_BLOCK` is returned some underlying
    /// transports like D/TLS require that you re-send the same `vectors` and
    /// `n_vectors` in the next write call.
    ///
    /// The behaviour of this method is undefined if
    /// `gio.PollableOutputStream.canPoll` returns `FALSE` for `stream`.
    extern fn g_pollable_output_stream_writev_nonblocking(p_stream: *PollableOutputStream, p_vectors: [*]const gio.OutputVector, p_n_vectors: usize, p_bytes_written: ?*usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) gio.PollableReturn;
    pub const writevNonblocking = g_pollable_output_stream_writev_nonblocking;

    extern fn g_pollable_output_stream_get_type() usize;
    pub const getGObjectType = g_pollable_output_stream_get_type;

    extern fn g_object_ref(p_self: *gio.PollableOutputStream) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.PollableOutputStream) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *PollableOutputStream, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GPowerProfileMonitor` makes it possible for applications as well as OS
/// components to monitor system power profiles and act upon them. It currently
/// only exports whether the system is in “Power Saver” mode (known as
/// “Low Power” mode on some systems).
///
/// When in “Low Power” mode, it is recommended that applications:
///
/// - disable automatic downloads;
/// - reduce the rate of refresh from online sources such as calendar or
///   email synchronisation;
/// - reduce the use of expensive visual effects.
///
/// It is also likely that OS components providing services to applications will
/// lower their own background activity, for the sake of the system.
///
/// There are a variety of tools that exist for power consumption analysis, but those
/// usually depend on the OS and hardware used. On Linux, one could use `upower` to
/// monitor the battery discharge rate, `powertop` to check on the background activity
/// or activity at all), `sysprof` to inspect CPU usage, and `intel_gpu_time` to
/// profile GPU usage.
///
/// Don’t forget to disconnect the `gobject.Object.signals.notify` signal for
/// `gio.PowerProfileMonitor.properties.power_saver_enabled`, and unref the
/// `GPowerProfileMonitor` itself when exiting.
pub const PowerProfileMonitor = opaque {
    pub const Prerequisites = [_]type{gio.Initable};
    pub const Iface = gio.PowerProfileMonitorInterface;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// Whether “Power Saver” mode is enabled on the system.
        pub const power_saver_enabled = struct {
            pub const name = "power-saver-enabled";

            pub const Type = c_int;
        };
    };

    pub const signals = struct {};

    /// Gets a reference to the default `gio.PowerProfileMonitor` for the system.
    extern fn g_power_profile_monitor_dup_default() *gio.PowerProfileMonitor;
    pub const dupDefault = g_power_profile_monitor_dup_default;

    /// Gets whether the system is in “Power Saver” mode.
    ///
    /// You are expected to listen to the
    /// `gio.PowerProfileMonitor.signals.notify`::power-saver-enabled signal to know when the profile has
    /// changed.
    extern fn g_power_profile_monitor_get_power_saver_enabled(p_monitor: *PowerProfileMonitor) c_int;
    pub const getPowerSaverEnabled = g_power_profile_monitor_get_power_saver_enabled;

    extern fn g_power_profile_monitor_get_type() usize;
    pub const getGObjectType = g_power_profile_monitor_get_type;

    extern fn g_object_ref(p_self: *gio.PowerProfileMonitor) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.PowerProfileMonitor) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *PowerProfileMonitor, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A `GProxy` handles connecting to a remote host via a given type of
/// proxy server. It is implemented by the `gio-proxy` extension point.
/// The extensions are named after their proxy protocol name. As an
/// example, a SOCKS5 proxy implementation can be retrieved with the
/// name `socks5` using the function
/// `gio.IOExtensionPoint.getExtensionByName`.
pub const Proxy = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.ProxyInterface;
    pub const virtual_methods = struct {
        /// Given `connection` to communicate with a proxy (eg, a
        /// `gio.SocketConnection` that is connected to the proxy server), this
        /// does the necessary handshake to connect to `proxy_address`, and if
        /// required, wraps the `gio.IOStream` to handle proxy payload.
        pub const connect = struct {
            pub fn call(p_class: anytype, p_proxy: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.IOStream, p_proxy_address: *gio.ProxyAddress, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.IOStream {
                return gobject.ext.as(Proxy.Iface, p_class).f_connect.?(gobject.ext.as(Proxy, p_proxy), p_connection, p_proxy_address, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_proxy: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.IOStream, p_proxy_address: *gio.ProxyAddress, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.IOStream) void {
                gobject.ext.as(Proxy.Iface, p_class).f_connect = @ptrCast(p_implementation);
            }
        };

        /// Asynchronous version of `gio.Proxy.connect`.
        pub const connect_async = struct {
            pub fn call(p_class: anytype, p_proxy: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.IOStream, p_proxy_address: *gio.ProxyAddress, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Proxy.Iface, p_class).f_connect_async.?(gobject.ext.as(Proxy, p_proxy), p_connection, p_proxy_address, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_proxy: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_connection: *gio.IOStream, p_proxy_address: *gio.ProxyAddress, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Proxy.Iface, p_class).f_connect_async = @ptrCast(p_implementation);
            }
        };

        /// See `gio.Proxy.connect`.
        pub const connect_finish = struct {
            pub fn call(p_class: anytype, p_proxy: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.IOStream {
                return gobject.ext.as(Proxy.Iface, p_class).f_connect_finish.?(gobject.ext.as(Proxy, p_proxy), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_proxy: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.IOStream) void {
                gobject.ext.as(Proxy.Iface, p_class).f_connect_finish = @ptrCast(p_implementation);
            }
        };

        /// Some proxy protocols expect to be passed a hostname, which they
        /// will resolve to an IP address themselves. Others, like SOCKS4, do
        /// not allow this. This function will return `FALSE` if `proxy` is
        /// implementing such a protocol. When `FALSE` is returned, the caller
        /// should resolve the destination hostname first, and then pass a
        /// `gio.ProxyAddress` containing the stringified IP address to
        /// `gio.Proxy.connect` or `gio.Proxy.connectAsync`.
        pub const supports_hostname = struct {
            pub fn call(p_class: anytype, p_proxy: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Proxy.Iface, p_class).f_supports_hostname.?(gobject.ext.as(Proxy, p_proxy));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_proxy: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Proxy.Iface, p_class).f_supports_hostname = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Find the `gio-proxy` extension point for a proxy implementation that supports
    /// the specified protocol.
    extern fn g_proxy_get_default_for_protocol(p_protocol: [*:0]const u8) ?*gio.Proxy;
    pub const getDefaultForProtocol = g_proxy_get_default_for_protocol;

    /// Given `connection` to communicate with a proxy (eg, a
    /// `gio.SocketConnection` that is connected to the proxy server), this
    /// does the necessary handshake to connect to `proxy_address`, and if
    /// required, wraps the `gio.IOStream` to handle proxy payload.
    extern fn g_proxy_connect(p_proxy: *Proxy, p_connection: *gio.IOStream, p_proxy_address: *gio.ProxyAddress, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.IOStream;
    pub const connect = g_proxy_connect;

    /// Asynchronous version of `gio.Proxy.connect`.
    extern fn g_proxy_connect_async(p_proxy: *Proxy, p_connection: *gio.IOStream, p_proxy_address: *gio.ProxyAddress, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const connectAsync = g_proxy_connect_async;

    /// See `gio.Proxy.connect`.
    extern fn g_proxy_connect_finish(p_proxy: *Proxy, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.IOStream;
    pub const connectFinish = g_proxy_connect_finish;

    /// Some proxy protocols expect to be passed a hostname, which they
    /// will resolve to an IP address themselves. Others, like SOCKS4, do
    /// not allow this. This function will return `FALSE` if `proxy` is
    /// implementing such a protocol. When `FALSE` is returned, the caller
    /// should resolve the destination hostname first, and then pass a
    /// `gio.ProxyAddress` containing the stringified IP address to
    /// `gio.Proxy.connect` or `gio.Proxy.connectAsync`.
    extern fn g_proxy_supports_hostname(p_proxy: *Proxy) c_int;
    pub const supportsHostname = g_proxy_supports_hostname;

    extern fn g_proxy_get_type() usize;
    pub const getGObjectType = g_proxy_get_type;

    extern fn g_object_ref(p_self: *gio.Proxy) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Proxy) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Proxy, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GProxyResolver` provides synchronous and asynchronous network proxy
/// resolution. `GProxyResolver` is used within `gio.SocketClient` through
/// the method `gio.SocketConnectable.proxyEnumerate`.
///
/// Implementations of `GProxyResolver` based on
/// [libproxy](https://github.com/libproxy/libproxy) and GNOME settings can be
/// found in [glib-networking](https://gitlab.gnome.org/GNOME/glib-networking).
/// GIO comes with an implementation for use inside Flatpak portals.
pub const ProxyResolver = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.ProxyResolverInterface;
    pub const virtual_methods = struct {
        /// Checks if `resolver` can be used on this system. (This is used
        /// internally; `gio.proxyResolverGetDefault` will only return a proxy
        /// resolver that returns `TRUE` for this method.)
        pub const is_supported = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(ProxyResolver.Iface, p_class).f_is_supported.?(gobject.ext.as(ProxyResolver, p_resolver));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(ProxyResolver.Iface, p_class).f_is_supported = @ptrCast(p_implementation);
            }
        };

        /// Looks into the system proxy configuration to determine what proxy,
        /// if any, to use to connect to `uri`. The returned proxy URIs are of
        /// the form `<protocol>://[user[:password]@]host[:port]` or
        /// `direct://`, where `<protocol>` could be http, rtsp, socks
        /// or other proxying protocol.
        ///
        /// If you don't know what network protocol is being used on the
        /// socket, you should use `none` as the URI protocol.
        /// In this case, the resolver might still return a generic proxy type
        /// (such as SOCKS), but would not return protocol-specific proxy types
        /// (such as http).
        ///
        /// `direct://` is used when no proxy is needed.
        /// Direct connection should not be attempted unless it is part of the
        /// returned array of proxies.
        pub const lookup = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?[*][*:0]u8 {
                return gobject.ext.as(ProxyResolver.Iface, p_class).f_lookup.?(gobject.ext.as(ProxyResolver, p_resolver), p_uri, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?[*][*:0]u8) void {
                gobject.ext.as(ProxyResolver.Iface, p_class).f_lookup = @ptrCast(p_implementation);
            }
        };

        /// Asynchronous lookup of proxy. See `gio.ProxyResolver.lookup` for more
        /// details.
        pub const lookup_async = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(ProxyResolver.Iface, p_class).f_lookup_async.?(gobject.ext.as(ProxyResolver, p_resolver), p_uri, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_uri: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(ProxyResolver.Iface, p_class).f_lookup_async = @ptrCast(p_implementation);
            }
        };

        /// Call this function to obtain the array of proxy URIs when
        /// `gio.ProxyResolver.lookupAsync` is complete. See
        /// `gio.ProxyResolver.lookup` for more details.
        pub const lookup_finish = struct {
            pub fn call(p_class: anytype, p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?[*][*:0]u8 {
                return gobject.ext.as(ProxyResolver.Iface, p_class).f_lookup_finish.?(gobject.ext.as(ProxyResolver, p_resolver), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_resolver: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?[*][*:0]u8) void {
                gobject.ext.as(ProxyResolver.Iface, p_class).f_lookup_finish = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Gets the default `gio.ProxyResolver` for the system.
    extern fn g_proxy_resolver_get_default() *gio.ProxyResolver;
    pub const getDefault = g_proxy_resolver_get_default;

    /// Checks if `resolver` can be used on this system. (This is used
    /// internally; `gio.proxyResolverGetDefault` will only return a proxy
    /// resolver that returns `TRUE` for this method.)
    extern fn g_proxy_resolver_is_supported(p_resolver: *ProxyResolver) c_int;
    pub const isSupported = g_proxy_resolver_is_supported;

    /// Looks into the system proxy configuration to determine what proxy,
    /// if any, to use to connect to `uri`. The returned proxy URIs are of
    /// the form `<protocol>://[user[:password]@]host[:port]` or
    /// `direct://`, where `<protocol>` could be http, rtsp, socks
    /// or other proxying protocol.
    ///
    /// If you don't know what network protocol is being used on the
    /// socket, you should use `none` as the URI protocol.
    /// In this case, the resolver might still return a generic proxy type
    /// (such as SOCKS), but would not return protocol-specific proxy types
    /// (such as http).
    ///
    /// `direct://` is used when no proxy is needed.
    /// Direct connection should not be attempted unless it is part of the
    /// returned array of proxies.
    extern fn g_proxy_resolver_lookup(p_resolver: *ProxyResolver, p_uri: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?[*][*:0]u8;
    pub const lookup = g_proxy_resolver_lookup;

    /// Asynchronous lookup of proxy. See `gio.ProxyResolver.lookup` for more
    /// details.
    extern fn g_proxy_resolver_lookup_async(p_resolver: *ProxyResolver, p_uri: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const lookupAsync = g_proxy_resolver_lookup_async;

    /// Call this function to obtain the array of proxy URIs when
    /// `gio.ProxyResolver.lookupAsync` is complete. See
    /// `gio.ProxyResolver.lookup` for more details.
    extern fn g_proxy_resolver_lookup_finish(p_resolver: *ProxyResolver, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) ?[*][*:0]u8;
    pub const lookupFinish = g_proxy_resolver_lookup_finish;

    extern fn g_proxy_resolver_get_type() usize;
    pub const getGObjectType = g_proxy_resolver_get_type;

    extern fn g_object_ref(p_self: *gio.ProxyResolver) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.ProxyResolver) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *ProxyResolver, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `GRemoteActionGroup` interface is implemented by `gio.ActionGroup`
/// instances that either transmit action invocations to other processes
/// or receive action invocations in the local process from other
/// processes.
///
/// The interface has `_full` variants of the two
/// methods on `gio.ActionGroup` used to activate actions:
/// `gio.ActionGroup.activateAction` and
/// `gio.ActionGroup.changeActionState`. These variants allow a
/// ‘platform data’ `glib.Variant` to be specified: a dictionary providing
/// context for the action invocation (for example: timestamps, startup
/// notification IDs, etc).
///
/// `gio.DBusActionGroup` implements `GRemoteActionGroup`.  This provides a
/// mechanism to send platform data for action invocations over D-Bus.
///
/// Additionally, `gio.DBusConnection.exportActionGroup` will check if
/// the exported `gio.ActionGroup` implements `GRemoteActionGroup` and use
/// the `_full` variants of the calls if available.  This
/// provides a mechanism by which to receive platform data for action
/// invocations that arrive by way of D-Bus.
pub const RemoteActionGroup = opaque {
    pub const Prerequisites = [_]type{gio.ActionGroup};
    pub const Iface = gio.RemoteActionGroupInterface;
    pub const virtual_methods = struct {
        /// Activates the remote action.
        ///
        /// This is the same as `gio.ActionGroup.activateAction` except that it
        /// allows for provision of "platform data" to be sent along with the
        /// activation request.  This typically contains details such as the user
        /// interaction timestamp or startup notification information.
        ///
        /// `platform_data` must be non-`NULL` and must have the type
        /// `G_VARIANT_TYPE_VARDICT`.  If it is floating, it will be consumed.
        pub const activate_action_full = struct {
            pub fn call(p_class: anytype, p_remote: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8, p_parameter: ?*glib.Variant, p_platform_data: *glib.Variant) void {
                return gobject.ext.as(RemoteActionGroup.Iface, p_class).f_activate_action_full.?(gobject.ext.as(RemoteActionGroup, p_remote), p_action_name, p_parameter, p_platform_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_remote: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8, p_parameter: ?*glib.Variant, p_platform_data: *glib.Variant) callconv(.c) void) void {
                gobject.ext.as(RemoteActionGroup.Iface, p_class).f_activate_action_full = @ptrCast(p_implementation);
            }
        };

        /// Changes the state of a remote action.
        ///
        /// This is the same as `gio.ActionGroup.changeActionState` except that
        /// it allows for provision of "platform data" to be sent along with the
        /// state change request.  This typically contains details such as the
        /// user interaction timestamp or startup notification information.
        ///
        /// `platform_data` must be non-`NULL` and must have the type
        /// `G_VARIANT_TYPE_VARDICT`.  If it is floating, it will be consumed.
        pub const change_action_state_full = struct {
            pub fn call(p_class: anytype, p_remote: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8, p_value: *glib.Variant, p_platform_data: *glib.Variant) void {
                return gobject.ext.as(RemoteActionGroup.Iface, p_class).f_change_action_state_full.?(gobject.ext.as(RemoteActionGroup, p_remote), p_action_name, p_value, p_platform_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_remote: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_action_name: [*:0]const u8, p_value: *glib.Variant, p_platform_data: *glib.Variant) callconv(.c) void) void {
                gobject.ext.as(RemoteActionGroup.Iface, p_class).f_change_action_state_full = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Activates the remote action.
    ///
    /// This is the same as `gio.ActionGroup.activateAction` except that it
    /// allows for provision of "platform data" to be sent along with the
    /// activation request.  This typically contains details such as the user
    /// interaction timestamp or startup notification information.
    ///
    /// `platform_data` must be non-`NULL` and must have the type
    /// `G_VARIANT_TYPE_VARDICT`.  If it is floating, it will be consumed.
    extern fn g_remote_action_group_activate_action_full(p_remote: *RemoteActionGroup, p_action_name: [*:0]const u8, p_parameter: ?*glib.Variant, p_platform_data: *glib.Variant) void;
    pub const activateActionFull = g_remote_action_group_activate_action_full;

    /// Changes the state of a remote action.
    ///
    /// This is the same as `gio.ActionGroup.changeActionState` except that
    /// it allows for provision of "platform data" to be sent along with the
    /// state change request.  This typically contains details such as the
    /// user interaction timestamp or startup notification information.
    ///
    /// `platform_data` must be non-`NULL` and must have the type
    /// `G_VARIANT_TYPE_VARDICT`.  If it is floating, it will be consumed.
    extern fn g_remote_action_group_change_action_state_full(p_remote: *RemoteActionGroup, p_action_name: [*:0]const u8, p_value: *glib.Variant, p_platform_data: *glib.Variant) void;
    pub const changeActionStateFull = g_remote_action_group_change_action_state_full;

    extern fn g_remote_action_group_get_type() usize;
    pub const getGObjectType = g_remote_action_group_get_type;

    extern fn g_object_ref(p_self: *gio.RemoteActionGroup) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.RemoteActionGroup) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *RemoteActionGroup, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GSeekable` is implemented by streams (implementations of
/// `gio.InputStream` or `gio.OutputStream`) that support seeking.
///
/// Seekable streams largely fall into two categories: resizable and
/// fixed-size.
///
/// `GSeekable` on fixed-sized streams is approximately the same as POSIX
/// [``lseek``](man:lseek(2)) on a block device (for example: attempting to seek
/// past the end of the device is an error).  Fixed streams typically cannot be
/// truncated.
///
/// `GSeekable` on resizable streams is approximately the same as POSIX
/// [``lseek``](man:lseek(2)) on a normal file.  Seeking past the end and writing
/// data will usually cause the stream to resize by introducing zero bytes.
pub const Seekable = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.SeekableIface;
    pub const virtual_methods = struct {
        /// Tests if the stream supports the `gio.SeekableIface`.
        pub const can_seek = struct {
            pub fn call(p_class: anytype, p_seekable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Seekable.Iface, p_class).f_can_seek.?(gobject.ext.as(Seekable, p_seekable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_seekable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Seekable.Iface, p_class).f_can_seek = @ptrCast(p_implementation);
            }
        };

        /// Tests if the length of the stream can be adjusted with
        /// `gio.Seekable.truncate`.
        pub const can_truncate = struct {
            pub fn call(p_class: anytype, p_seekable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Seekable.Iface, p_class).f_can_truncate.?(gobject.ext.as(Seekable, p_seekable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_seekable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Seekable.Iface, p_class).f_can_truncate = @ptrCast(p_implementation);
            }
        };

        /// Seeks in the stream by the given `offset`, modified by `type`.
        ///
        /// Attempting to seek past the end of the stream will have different
        /// results depending on if the stream is fixed-sized or resizable.  If
        /// the stream is resizable then seeking past the end and then writing
        /// will result in zeros filling the empty space.  Seeking past the end
        /// of a resizable stream and reading will result in EOF.  Seeking past
        /// the end of a fixed-sized stream will fail.
        ///
        /// Any operation that would result in a negative offset will fail.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
        pub const seek = struct {
            pub fn call(p_class: anytype, p_seekable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_offset: i64, p_type: glib.SeekType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Seekable.Iface, p_class).f_seek.?(gobject.ext.as(Seekable, p_seekable), p_offset, p_type, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_seekable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_offset: i64, p_type: glib.SeekType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Seekable.Iface, p_class).f_seek = @ptrCast(p_implementation);
            }
        };

        /// Tells the current position within the stream.
        pub const tell = struct {
            pub fn call(p_class: anytype, p_seekable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) i64 {
                return gobject.ext.as(Seekable.Iface, p_class).f_tell.?(gobject.ext.as(Seekable, p_seekable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_seekable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) i64) void {
                gobject.ext.as(Seekable.Iface, p_class).f_tell = @ptrCast(p_implementation);
            }
        };

        /// Sets the length of the stream to `offset`. If the stream was previously
        /// larger than `offset`, the extra data is discarded. If the stream was
        /// previously shorter than `offset`, it is extended with NUL ('\0') bytes.
        ///
        /// If `cancellable` is not `NULL`, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned. If an
        /// operation was partially finished when the operation was cancelled the
        /// partial result will be returned, without an error.
        pub const truncate_fn = struct {
            pub fn call(p_class: anytype, p_seekable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_offset: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Seekable.Iface, p_class).f_truncate_fn.?(gobject.ext.as(Seekable, p_seekable), p_offset, p_cancellable, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_seekable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_offset: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Seekable.Iface, p_class).f_truncate_fn = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Tests if the stream supports the `gio.SeekableIface`.
    extern fn g_seekable_can_seek(p_seekable: *Seekable) c_int;
    pub const canSeek = g_seekable_can_seek;

    /// Tests if the length of the stream can be adjusted with
    /// `gio.Seekable.truncate`.
    extern fn g_seekable_can_truncate(p_seekable: *Seekable) c_int;
    pub const canTruncate = g_seekable_can_truncate;

    /// Seeks in the stream by the given `offset`, modified by `type`.
    ///
    /// Attempting to seek past the end of the stream will have different
    /// results depending on if the stream is fixed-sized or resizable.  If
    /// the stream is resizable then seeking past the end and then writing
    /// will result in zeros filling the empty space.  Seeking past the end
    /// of a resizable stream and reading will result in EOF.  Seeking past
    /// the end of a fixed-sized stream will fail.
    ///
    /// Any operation that would result in a negative offset will fail.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned.
    extern fn g_seekable_seek(p_seekable: *Seekable, p_offset: i64, p_type: glib.SeekType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const seek = g_seekable_seek;

    /// Tells the current position within the stream.
    extern fn g_seekable_tell(p_seekable: *Seekable) i64;
    pub const tell = g_seekable_tell;

    /// Sets the length of the stream to `offset`. If the stream was previously
    /// larger than `offset`, the extra data is discarded. If the stream was
    /// previously shorter than `offset`, it is extended with NUL ('\0') bytes.
    ///
    /// If `cancellable` is not `NULL`, then the operation can be cancelled by
    /// triggering the cancellable object from another thread. If the operation
    /// was cancelled, the error `G_IO_ERROR_CANCELLED` will be returned. If an
    /// operation was partially finished when the operation was cancelled the
    /// partial result will be returned, without an error.
    extern fn g_seekable_truncate(p_seekable: *Seekable, p_offset: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
    pub const truncate = g_seekable_truncate;

    extern fn g_seekable_get_type() usize;
    pub const getGObjectType = g_seekable_get_type;

    extern fn g_object_ref(p_self: *gio.Seekable) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Seekable) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Seekable, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Objects that describe one or more potential socket endpoints
/// implement `GSocketConnectable`. Callers can then use
/// `gio.SocketConnectable.enumerate` to get a
/// `gio.SocketAddressEnumerator` to try out each socket address in turn
/// until one succeeds, as shown in the sample code below.
///
/// ```c
/// MyConnectionType *
/// connect_to_host (const char    *hostname,
///                  guint16        port,
///                  GCancellable  *cancellable,
///                  GError       **error)
/// {
///   MyConnection *conn = NULL;
///   GSocketConnectable *addr;
///   GSocketAddressEnumerator *enumerator;
///   GSocketAddress *sockaddr;
///   GError *conn_error = NULL;
///
///   addr = g_network_address_new (hostname, port);
///   enumerator = g_socket_connectable_enumerate (addr);
///   g_object_unref (addr);
///
///   // Try each sockaddr until we succeed. Record the first connection error,
///   // but not any further ones (since they'll probably be basically the same
///   // as the first).
///   while (!conn && (sockaddr = g_socket_address_enumerator_next (enumerator, cancellable, error))
///     {
///       conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &conn_error);
///       g_object_unref (sockaddr);
///     }
///   g_object_unref (enumerator);
///
///   if (conn)
///     {
///       if (conn_error)
///         {
///           // We couldn't connect to the first address, but we succeeded
///           // in connecting to a later address.
///           g_error_free (conn_error);
///         }
///       return conn;
///     }
///   else if (error)
///     {
///       /// Either initial lookup failed, or else the caller cancelled us.
///       if (conn_error)
///         g_error_free (conn_error);
///       return NULL;
///     }
///   else
///     {
///       g_error_propagate (error, conn_error);
///       return NULL;
///     }
/// }
/// ```
pub const SocketConnectable = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.SocketConnectableIface;
    pub const virtual_methods = struct {
        /// Creates a `gio.SocketAddressEnumerator` for `connectable`.
        pub const enumerate = struct {
            pub fn call(p_class: anytype, p_connectable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.SocketAddressEnumerator {
                return gobject.ext.as(SocketConnectable.Iface, p_class).f_enumerate.?(gobject.ext.as(SocketConnectable, p_connectable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_connectable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.SocketAddressEnumerator) void {
                gobject.ext.as(SocketConnectable.Iface, p_class).f_enumerate = @ptrCast(p_implementation);
            }
        };

        /// Creates a `gio.SocketAddressEnumerator` for `connectable` that will
        /// return a `gio.ProxyAddress` for each of its addresses that you must connect
        /// to via a proxy.
        ///
        /// If `connectable` does not implement
        /// `gio.SocketConnectable.proxyEnumerate`, this will fall back to
        /// calling `gio.SocketConnectable.enumerate`.
        pub const proxy_enumerate = struct {
            pub fn call(p_class: anytype, p_connectable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.SocketAddressEnumerator {
                return gobject.ext.as(SocketConnectable.Iface, p_class).f_proxy_enumerate.?(gobject.ext.as(SocketConnectable, p_connectable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_connectable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.SocketAddressEnumerator) void {
                gobject.ext.as(SocketConnectable.Iface, p_class).f_proxy_enumerate = @ptrCast(p_implementation);
            }
        };

        /// Format a `gio.SocketConnectable` as a string. This is a human-readable format for
        /// use in debugging output, and is not a stable serialization format. It is not
        /// suitable for use in user interfaces as it exposes too much information for a
        /// user.
        ///
        /// If the `gio.SocketConnectable` implementation does not support string formatting,
        /// the implementation’s type name will be returned as a fallback.
        pub const to_string = struct {
            pub fn call(p_class: anytype, p_connectable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]u8 {
                return gobject.ext.as(SocketConnectable.Iface, p_class).f_to_string.?(gobject.ext.as(SocketConnectable, p_connectable));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_connectable: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]u8) void {
                gobject.ext.as(SocketConnectable.Iface, p_class).f_to_string = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Creates a `gio.SocketAddressEnumerator` for `connectable`.
    extern fn g_socket_connectable_enumerate(p_connectable: *SocketConnectable) *gio.SocketAddressEnumerator;
    pub const enumerate = g_socket_connectable_enumerate;

    /// Creates a `gio.SocketAddressEnumerator` for `connectable` that will
    /// return a `gio.ProxyAddress` for each of its addresses that you must connect
    /// to via a proxy.
    ///
    /// If `connectable` does not implement
    /// `gio.SocketConnectable.proxyEnumerate`, this will fall back to
    /// calling `gio.SocketConnectable.enumerate`.
    extern fn g_socket_connectable_proxy_enumerate(p_connectable: *SocketConnectable) *gio.SocketAddressEnumerator;
    pub const proxyEnumerate = g_socket_connectable_proxy_enumerate;

    /// Format a `gio.SocketConnectable` as a string. This is a human-readable format for
    /// use in debugging output, and is not a stable serialization format. It is not
    /// suitable for use in user interfaces as it exposes too much information for a
    /// user.
    ///
    /// If the `gio.SocketConnectable` implementation does not support string formatting,
    /// the implementation’s type name will be returned as a fallback.
    extern fn g_socket_connectable_to_string(p_connectable: *SocketConnectable) [*:0]u8;
    pub const toString = g_socket_connectable_to_string;

    extern fn g_socket_connectable_get_type() usize;
    pub const getGObjectType = g_socket_connectable_get_type;

    extern fn g_object_ref(p_self: *gio.SocketConnectable) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.SocketConnectable) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *SocketConnectable, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// TLS (Transport Layer Security, aka SSL) and DTLS backend. This is an
/// internal type used to coordinate the different classes implemented
/// by a TLS backend.
pub const TlsBackend = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.TlsBackendInterface;
    pub const virtual_methods = struct {
        /// Gets the default `gio.TlsDatabase` used to verify TLS connections.
        pub const get_default_database = struct {
            pub fn call(p_class: anytype, p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.TlsDatabase {
                return gobject.ext.as(TlsBackend.Iface, p_class).f_get_default_database.?(gobject.ext.as(TlsBackend, p_backend));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.TlsDatabase) void {
                gobject.ext.as(TlsBackend.Iface, p_class).f_get_default_database = @ptrCast(p_implementation);
            }
        };

        /// Checks if DTLS is supported. DTLS support may not be available even if TLS
        /// support is available, and vice-versa.
        pub const supports_dtls = struct {
            pub fn call(p_class: anytype, p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(TlsBackend.Iface, p_class).f_supports_dtls.?(gobject.ext.as(TlsBackend, p_backend));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(TlsBackend.Iface, p_class).f_supports_dtls = @ptrCast(p_implementation);
            }
        };

        /// Checks if TLS is supported; if this returns `FALSE` for the default
        /// `gio.TlsBackend`, it means no "real" TLS backend is available.
        pub const supports_tls = struct {
            pub fn call(p_class: anytype, p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(TlsBackend.Iface, p_class).f_supports_tls.?(gobject.ext.as(TlsBackend, p_backend));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_backend: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(TlsBackend.Iface, p_class).f_supports_tls = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {};

    /// Gets the default `gio.TlsBackend` for the system.
    extern fn g_tls_backend_get_default() *gio.TlsBackend;
    pub const getDefault = g_tls_backend_get_default;

    /// Gets the `gobject.Type` of `backend`'s `gio.TlsCertificate` implementation.
    extern fn g_tls_backend_get_certificate_type(p_backend: *TlsBackend) usize;
    pub const getCertificateType = g_tls_backend_get_certificate_type;

    /// Gets the `gobject.Type` of `backend`'s `gio.TlsClientConnection` implementation.
    extern fn g_tls_backend_get_client_connection_type(p_backend: *TlsBackend) usize;
    pub const getClientConnectionType = g_tls_backend_get_client_connection_type;

    /// Gets the default `gio.TlsDatabase` used to verify TLS connections.
    extern fn g_tls_backend_get_default_database(p_backend: *TlsBackend) *gio.TlsDatabase;
    pub const getDefaultDatabase = g_tls_backend_get_default_database;

    /// Gets the `gobject.Type` of `backend`’s `gio.DtlsClientConnection` implementation.
    extern fn g_tls_backend_get_dtls_client_connection_type(p_backend: *TlsBackend) usize;
    pub const getDtlsClientConnectionType = g_tls_backend_get_dtls_client_connection_type;

    /// Gets the `gobject.Type` of `backend`’s `gio.DtlsServerConnection` implementation.
    extern fn g_tls_backend_get_dtls_server_connection_type(p_backend: *TlsBackend) usize;
    pub const getDtlsServerConnectionType = g_tls_backend_get_dtls_server_connection_type;

    /// Gets the `gobject.Type` of `backend`'s `gio.TlsFileDatabase` implementation.
    extern fn g_tls_backend_get_file_database_type(p_backend: *TlsBackend) usize;
    pub const getFileDatabaseType = g_tls_backend_get_file_database_type;

    /// Gets the `gobject.Type` of `backend`'s `gio.TlsServerConnection` implementation.
    extern fn g_tls_backend_get_server_connection_type(p_backend: *TlsBackend) usize;
    pub const getServerConnectionType = g_tls_backend_get_server_connection_type;

    /// Set the default `gio.TlsDatabase` used to verify TLS connections
    ///
    /// Any subsequent call to `gio.TlsBackend.getDefaultDatabase` will return
    /// the database set in this call.  Existing databases and connections are not
    /// modified.
    ///
    /// Setting a `NULL` default database will reset to using the system default
    /// database as if `gio.TlsBackend.setDefaultDatabase` had never been called.
    extern fn g_tls_backend_set_default_database(p_backend: *TlsBackend, p_database: ?*gio.TlsDatabase) void;
    pub const setDefaultDatabase = g_tls_backend_set_default_database;

    /// Checks if DTLS is supported. DTLS support may not be available even if TLS
    /// support is available, and vice-versa.
    extern fn g_tls_backend_supports_dtls(p_backend: *TlsBackend) c_int;
    pub const supportsDtls = g_tls_backend_supports_dtls;

    /// Checks if TLS is supported; if this returns `FALSE` for the default
    /// `gio.TlsBackend`, it means no "real" TLS backend is available.
    extern fn g_tls_backend_supports_tls(p_backend: *TlsBackend) c_int;
    pub const supportsTls = g_tls_backend_supports_tls;

    extern fn g_tls_backend_get_type() usize;
    pub const getGObjectType = g_tls_backend_get_type;

    extern fn g_object_ref(p_self: *gio.TlsBackend) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.TlsBackend) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TlsBackend, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GTlsClientConnection` is the client-side subclass of
/// `gio.TlsConnection`, representing a client-side TLS connection.
pub const TlsClientConnection = opaque {
    pub const Prerequisites = [_]type{gio.TlsConnection};
    pub const Iface = gio.TlsClientConnectionInterface;
    pub const virtual_methods = struct {
        /// Possibly copies session state from one connection to another, for use
        /// in TLS session resumption. This is not normally needed, but may be
        /// used when the same session needs to be used between different
        /// endpoints, as is required by some protocols, such as FTP over TLS.
        /// `source` should have already completed a handshake and, since TLS 1.3,
        /// it should have been used to read data at least once. `conn` should not
        /// have completed a handshake.
        ///
        /// It is not possible to know whether a call to this function will
        /// actually do anything. Because session resumption is normally used
        /// only for performance benefit, the TLS backend might not implement
        /// this function. Even if implemented, it may not actually succeed in
        /// allowing `conn` to resume `source`'s TLS session, because the server
        /// may not have sent a session resumption token to `source`, or it may
        /// refuse to accept the token from `conn`. There is no way to know
        /// whether a call to this function is actually successful.
        ///
        /// Using this function is not required to benefit from session
        /// resumption. If the TLS backend supports session resumption, the
        /// session will be resumed automatically if it is possible to do so
        /// without weakening the privacy guarantees normally provided by TLS,
        /// without need to call this function. For example, with TLS 1.3,
        /// a session ticket will be automatically copied from any
        /// `gio.TlsClientConnection` that has previously received session tickets
        /// from the server, provided a ticket is available that has not
        /// previously been used for session resumption, since session ticket
        /// reuse would be a privacy weakness. Using this function causes the
        /// ticket to be copied without regard for privacy considerations.
        pub const copy_session_state = struct {
            pub fn call(p_class: anytype, p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_source: *gio.TlsClientConnection) void {
                return gobject.ext.as(TlsClientConnection.Iface, p_class).f_copy_session_state.?(gobject.ext.as(TlsClientConnection, p_conn), p_source);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_conn: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_source: *gio.TlsClientConnection) callconv(.c) void) void {
                gobject.ext.as(TlsClientConnection.Iface, p_class).f_copy_session_state = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {
        /// A list of the distinguished names of the Certificate Authorities
        /// that the server will accept client certificates signed by. If the
        /// server requests a client certificate during the handshake, then
        /// this property will be set after the handshake completes.
        ///
        /// Each item in the list is a `glib.ByteArray` which contains the complete
        /// subject DN of the certificate authority.
        pub const accepted_cas = struct {
            pub const name = "accepted-cas";

            pub const Type = ?**glib.List;
        };

        /// A `gio.SocketConnectable` describing the identity of the server that
        /// is expected on the other end of the connection.
        ///
        /// If the `G_TLS_CERTIFICATE_BAD_IDENTITY` flag is set in
        /// `gio.TlsClientConnection.properties.validation`-flags, this object will be used
        /// to determine the expected identify of the remote end of the
        /// connection; if `gio.TlsClientConnection.properties.server`-identity is not set,
        /// or does not match the identity presented by the server, then the
        /// `G_TLS_CERTIFICATE_BAD_IDENTITY` validation will fail.
        ///
        /// In addition to its use in verifying the server certificate,
        /// this is also used to give a hint to the server about what
        /// certificate we expect, which is useful for servers that serve
        /// virtual hosts.
        pub const server_identity = struct {
            pub const name = "server-identity";

            pub const Type = ?*gio.SocketConnectable;
        };

        /// SSL 3.0 is no longer supported. See
        /// `gio.TlsClientConnection.setUseSsl3` for details.
        pub const use_ssl3 = struct {
            pub const name = "use-ssl3";

            pub const Type = c_int;
        };

        /// What steps to perform when validating a certificate received from
        /// a server. Server certificates that fail to validate in any of the
        /// ways indicated here will be rejected unless the application
        /// overrides the default via `gio.TlsConnection.signals.accept`-certificate.
        ///
        /// GLib guarantees that if certificate verification fails, at least one
        /// flag will be set, but it does not guarantee that all possible flags
        /// will be set. Accordingly, you may not safely decide to ignore any
        /// particular type of error. For example, it would be incorrect to mask
        /// `G_TLS_CERTIFICATE_EXPIRED` if you want to allow expired certificates,
        /// because this could potentially be the only error flag set even if
        /// other problems exist with the certificate. Therefore, there is no
        /// safe way to use this property. This is not a horrible problem,
        /// though, because you should not be attempting to ignore validation
        /// errors anyway. If you really must ignore TLS certificate errors,
        /// connect to `gio.TlsConnection.signals.accept`-certificate.
        pub const validation_flags = struct {
            pub const name = "validation-flags";

            pub const Type = gio.TlsCertificateFlags;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.TlsClientConnection` wrapping `base_io_stream` (which
    /// must have pollable input and output streams) which is assumed to
    /// communicate with the server identified by `server_identity`.
    ///
    /// See the documentation for `gio.TlsConnection.properties.base`-io-stream for restrictions
    /// on when application code can run operations on the `base_io_stream` after
    /// this function has returned.
    extern fn g_tls_client_connection_new(p_base_io_stream: *gio.IOStream, p_server_identity: ?*gio.SocketConnectable, p_error: ?*?*glib.Error) ?*gio.TlsClientConnection;
    pub const new = g_tls_client_connection_new;

    /// Possibly copies session state from one connection to another, for use
    /// in TLS session resumption. This is not normally needed, but may be
    /// used when the same session needs to be used between different
    /// endpoints, as is required by some protocols, such as FTP over TLS.
    /// `source` should have already completed a handshake and, since TLS 1.3,
    /// it should have been used to read data at least once. `conn` should not
    /// have completed a handshake.
    ///
    /// It is not possible to know whether a call to this function will
    /// actually do anything. Because session resumption is normally used
    /// only for performance benefit, the TLS backend might not implement
    /// this function. Even if implemented, it may not actually succeed in
    /// allowing `conn` to resume `source`'s TLS session, because the server
    /// may not have sent a session resumption token to `source`, or it may
    /// refuse to accept the token from `conn`. There is no way to know
    /// whether a call to this function is actually successful.
    ///
    /// Using this function is not required to benefit from session
    /// resumption. If the TLS backend supports session resumption, the
    /// session will be resumed automatically if it is possible to do so
    /// without weakening the privacy guarantees normally provided by TLS,
    /// without need to call this function. For example, with TLS 1.3,
    /// a session ticket will be automatically copied from any
    /// `gio.TlsClientConnection` that has previously received session tickets
    /// from the server, provided a ticket is available that has not
    /// previously been used for session resumption, since session ticket
    /// reuse would be a privacy weakness. Using this function causes the
    /// ticket to be copied without regard for privacy considerations.
    extern fn g_tls_client_connection_copy_session_state(p_conn: *TlsClientConnection, p_source: *gio.TlsClientConnection) void;
    pub const copySessionState = g_tls_client_connection_copy_session_state;

    /// Gets the list of distinguished names of the Certificate Authorities
    /// that the server will accept certificates from. This will be set
    /// during the TLS handshake if the server requests a certificate.
    /// Otherwise, it will be `NULL`.
    ///
    /// Each item in the list is a `glib.ByteArray` which contains the complete
    /// subject DN of the certificate authority.
    extern fn g_tls_client_connection_get_accepted_cas(p_conn: *TlsClientConnection) *glib.List;
    pub const getAcceptedCas = g_tls_client_connection_get_accepted_cas;

    /// Gets `conn`'s expected server identity
    extern fn g_tls_client_connection_get_server_identity(p_conn: *TlsClientConnection) ?*gio.SocketConnectable;
    pub const getServerIdentity = g_tls_client_connection_get_server_identity;

    /// SSL 3.0 is no longer supported. See
    /// `gio.TlsClientConnection.setUseSsl3` for details.
    extern fn g_tls_client_connection_get_use_ssl3(p_conn: *TlsClientConnection) c_int;
    pub const getUseSsl3 = g_tls_client_connection_get_use_ssl3;

    /// Gets `conn`'s validation flags
    ///
    /// This function does not work as originally designed and is impossible
    /// to use correctly. See `gio.TlsClientConnection.properties.validation`-flags for more
    /// information.
    extern fn g_tls_client_connection_get_validation_flags(p_conn: *TlsClientConnection) gio.TlsCertificateFlags;
    pub const getValidationFlags = g_tls_client_connection_get_validation_flags;

    /// Sets `conn`'s expected server identity, which is used both to tell
    /// servers on virtual hosts which certificate to present, and also
    /// to let `conn` know what name to look for in the certificate when
    /// performing `G_TLS_CERTIFICATE_BAD_IDENTITY` validation, if enabled.
    extern fn g_tls_client_connection_set_server_identity(p_conn: *TlsClientConnection, p_identity: *gio.SocketConnectable) void;
    pub const setServerIdentity = g_tls_client_connection_set_server_identity;

    /// Since GLib 2.42.1, SSL 3.0 is no longer supported.
    ///
    /// From GLib 2.42.1 through GLib 2.62, this function could be used to
    /// force use of TLS 1.0, the lowest-supported TLS protocol version at
    /// the time. In the past, this was needed to connect to broken TLS
    /// servers that exhibited protocol version intolerance. Such servers
    /// are no longer common, and using TLS 1.0 is no longer considered
    /// acceptable.
    ///
    /// Since GLib 2.64, this function does nothing.
    extern fn g_tls_client_connection_set_use_ssl3(p_conn: *TlsClientConnection, p_use_ssl3: c_int) void;
    pub const setUseSsl3 = g_tls_client_connection_set_use_ssl3;

    /// Sets `conn`'s validation flags, to override the default set of
    /// checks performed when validating a server certificate. By default,
    /// `G_TLS_CERTIFICATE_VALIDATE_ALL` is used.
    ///
    /// This function does not work as originally designed and is impossible
    /// to use correctly. See `gio.TlsClientConnection.properties.validation`-flags for more
    /// information.
    extern fn g_tls_client_connection_set_validation_flags(p_conn: *TlsClientConnection, p_flags: gio.TlsCertificateFlags) void;
    pub const setValidationFlags = g_tls_client_connection_set_validation_flags;

    extern fn g_tls_client_connection_get_type() usize;
    pub const getGObjectType = g_tls_client_connection_get_type;

    extern fn g_object_ref(p_self: *gio.TlsClientConnection) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.TlsClientConnection) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TlsClientConnection, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GTlsFileDatabase` is implemented by `gio.TlsDatabase` objects which
/// load their certificate information from a file. It is an interface which
/// TLS library specific subtypes implement.
pub const TlsFileDatabase = opaque {
    pub const Prerequisites = [_]type{gio.TlsDatabase};
    pub const Iface = gio.TlsFileDatabaseInterface;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The path to a file containing PEM encoded certificate authority
        /// root anchors. The certificates in this file will be treated as
        /// root authorities for the purpose of verifying other certificates
        /// via the `gio.TlsDatabase.verifyChain` operation.
        pub const anchors = struct {
            pub const name = "anchors";

            pub const Type = ?[*:0]u8;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.TlsFileDatabase` which uses anchor certificate authorities
    /// in `anchors` to verify certificate chains.
    ///
    /// The certificates in `anchors` must be PEM encoded.
    extern fn g_tls_file_database_new(p_anchors: [*:0]const u8, p_error: ?*?*glib.Error) ?*gio.TlsFileDatabase;
    pub const new = g_tls_file_database_new;

    extern fn g_tls_file_database_get_type() usize;
    pub const getGObjectType = g_tls_file_database_get_type;

    extern fn g_object_ref(p_self: *gio.TlsFileDatabase) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.TlsFileDatabase) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TlsFileDatabase, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GTlsServerConnection` is the server-side subclass of
/// `gio.TlsConnection`, representing a server-side TLS connection.
pub const TlsServerConnection = opaque {
    pub const Prerequisites = [_]type{gio.TlsConnection};
    pub const Iface = gio.TlsServerConnectionInterface;
    pub const virtual_methods = struct {};

    pub const properties = struct {
        /// The `gio.TlsAuthenticationMode` for the server. This can be changed
        /// before calling `gio.TlsConnection.handshake` if you want to
        /// rehandshake with a different mode from the initial handshake.
        pub const authentication_mode = struct {
            pub const name = "authentication-mode";

            pub const Type = gio.TlsAuthenticationMode;
        };
    };

    pub const signals = struct {};

    /// Creates a new `gio.TlsServerConnection` wrapping `base_io_stream` (which
    /// must have pollable input and output streams).
    ///
    /// See the documentation for `gio.TlsConnection.properties.base`-io-stream for restrictions
    /// on when application code can run operations on the `base_io_stream` after
    /// this function has returned.
    extern fn g_tls_server_connection_new(p_base_io_stream: *gio.IOStream, p_certificate: ?*gio.TlsCertificate, p_error: ?*?*glib.Error) ?*gio.TlsServerConnection;
    pub const new = g_tls_server_connection_new;

    extern fn g_tls_server_connection_get_type() usize;
    pub const getGObjectType = g_tls_server_connection_get_type;

    extern fn g_object_ref(p_self: *gio.TlsServerConnection) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.TlsServerConnection) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *TlsServerConnection, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `GVolume` interface represents user-visible objects that can be
/// mounted. For example, a file system partition on a USB flash drive, or an
/// optical disc inserted into a disc drive.
///
/// If a `GVolume` is currently mounted, the corresponding `gio.Mount` can
/// be retrieved using `gio.Volume.getMount`.
///
/// Mounting a `GVolume` instance is an asynchronous operation. For more
/// information about asynchronous operations, see `gio.AsyncResult` and
/// `gio.Task`. To mount a `GVolume`, first call `gio.Volume.mount`
/// with (at least) the `GVolume` instance, optionally a
/// `gio.MountOperation` object and a `gio.AsyncReadyCallback`.
///
/// Typically, one will only want to pass `NULL` for the
/// `gio.MountOperation` if automounting all volumes when a desktop session
/// starts since it’s not desirable to put up a lot of dialogs asking
/// for credentials.
///
/// The callback will be fired when the operation has resolved (either
/// with success or failure), and a `gio.AsyncResult` instance will be
/// passed to the callback.  That callback should then call
/// `gio.Volume.mountFinish` with the `GVolume` instance and the
/// `gio.AsyncResult` data to see if the operation was completed
/// successfully.  If a `glib.Error` is present when
/// `gio.Volume.mountFinish` is called, then it will be filled with any
/// error information.
///
/// Note, when [porting from GnomeVFS](migrating-gnome-vfs.html),
/// `GVolume` is the moral equivalent of `GnomeVFSDrive`.
///
/// ## Volume Identifiers
///
/// It is sometimes necessary to directly access the underlying
/// operating system object behind a volume (e.g. for passing a volume
/// to an application via the command line). For this purpose, GIO
/// allows to obtain an ‘identifier’ for the volume. There can be
/// different kinds of identifiers, such as Hal UDIs, filesystem labels,
/// traditional Unix devices (e.g. `/dev/sda2`), UUIDs. GIO uses predefined
/// strings as names for the different kinds of identifiers:
/// `G_VOLUME_IDENTIFIER_KIND_UUID`, `G_VOLUME_IDENTIFIER_KIND_LABEL`, etc.
/// Use `gio.Volume.getIdentifier` to obtain an identifier for a volume.
///
/// Note that `G_VOLUME_IDENTIFIER_KIND_HAL_UDI` will only be available
/// when the GVFS hal volume monitor is in use. Other volume monitors
/// will generally be able to provide the `G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE`
/// identifier, which can be used to obtain a hal device by means of
/// ``libhal_manager_find_device_string_match``.
pub const Volume = opaque {
    pub const Prerequisites = [_]type{gobject.Object};
    pub const Iface = gio.VolumeIface;
    pub const virtual_methods = struct {
        /// Checks if a volume can be ejected.
        pub const can_eject = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Volume.Iface, p_class).f_can_eject.?(gobject.ext.as(Volume, p_volume));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Volume.Iface, p_class).f_can_eject = @ptrCast(p_implementation);
            }
        };

        /// Checks if a volume can be mounted.
        pub const can_mount = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Volume.Iface, p_class).f_can_mount.?(gobject.ext.as(Volume, p_volume));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Volume.Iface, p_class).f_can_mount = @ptrCast(p_implementation);
            }
        };

        /// Changed signal that is emitted when the volume's state has changed.
        pub const changed = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Volume.Iface, p_class).f_changed.?(gobject.ext.as(Volume, p_volume));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Volume.Iface, p_class).f_changed = @ptrCast(p_implementation);
            }
        };

        /// Ejects a volume. This is an asynchronous operation, and is
        /// finished by calling `gio.Volume.ejectFinish` with the `volume`
        /// and `gio.AsyncResult` returned in the `callback`.
        pub const eject = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Volume.Iface, p_class).f_eject.?(gobject.ext.as(Volume, p_volume), p_flags, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Volume.Iface, p_class).f_eject = @ptrCast(p_implementation);
            }
        };

        /// Finishes ejecting a volume. If any errors occurred during the operation,
        /// `error` will be set to contain the errors and `FALSE` will be returned.
        pub const eject_finish = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Volume.Iface, p_class).f_eject_finish.?(gobject.ext.as(Volume, p_volume), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Volume.Iface, p_class).f_eject_finish = @ptrCast(p_implementation);
            }
        };

        /// Ejects a volume. This is an asynchronous operation, and is
        /// finished by calling `gio.Volume.ejectWithOperationFinish` with the `volume`
        /// and `gio.AsyncResult` data returned in the `callback`.
        pub const eject_with_operation = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Volume.Iface, p_class).f_eject_with_operation.?(gobject.ext.as(Volume, p_volume), p_flags, p_mount_operation, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Volume.Iface, p_class).f_eject_with_operation = @ptrCast(p_implementation);
            }
        };

        /// Finishes ejecting a volume. If any errors occurred during the operation,
        /// `error` will be set to contain the errors and `FALSE` will be returned.
        pub const eject_with_operation_finish = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Volume.Iface, p_class).f_eject_with_operation_finish.?(gobject.ext.as(Volume, p_volume), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Volume.Iface, p_class).f_eject_with_operation_finish = @ptrCast(p_implementation);
            }
        };

        /// Gets the kinds of [identifiers](`volume`-identifiers) that `volume` has.
        /// Use `gio.Volume.getIdentifier` to obtain the identifiers themselves.
        pub const enumerate_identifiers = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*][*:0]u8 {
                return gobject.ext.as(Volume.Iface, p_class).f_enumerate_identifiers.?(gobject.ext.as(Volume, p_volume));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*][*:0]u8) void {
                gobject.ext.as(Volume.Iface, p_class).f_enumerate_identifiers = @ptrCast(p_implementation);
            }
        };

        /// Gets the activation root for a `gio.Volume` if it is known ahead of
        /// mount time. Returns `NULL` otherwise. If not `NULL` and if `volume`
        /// is mounted, then the result of `gio.Mount.getRoot` on the
        /// `gio.Mount` object obtained from `gio.Volume.getMount` will always
        /// either be equal or a prefix of what this function returns. In
        /// other words, in code
        ///
        /// ```
        ///   GMount *mount;
        ///   GFile *mount_root
        ///   GFile *volume_activation_root;
        ///
        ///   mount = g_volume_get_mount (volume); // mounted, so never NULL
        ///   mount_root = g_mount_get_root (mount);
        ///   volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
        /// ```
        /// then the expression
        /// ```
        ///   (g_file_has_prefix (volume_activation_root, mount_root) ||
        ///    g_file_equal (volume_activation_root, mount_root))
        /// ```
        /// will always be `TRUE`.
        ///
        /// Activation roots are typically used in `gio.VolumeMonitor`
        /// implementations to find the underlying mount to shadow, see
        /// `gio.Mount.isShadowed` for more details.
        pub const get_activation_root = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*gio.File {
                return gobject.ext.as(Volume.Iface, p_class).f_get_activation_root.?(gobject.ext.as(Volume, p_volume));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*gio.File) void {
                gobject.ext.as(Volume.Iface, p_class).f_get_activation_root = @ptrCast(p_implementation);
            }
        };

        /// Gets the drive for the `volume`.
        pub const get_drive = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*gio.Drive {
                return gobject.ext.as(Volume.Iface, p_class).f_get_drive.?(gobject.ext.as(Volume, p_volume));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*gio.Drive) void {
                gobject.ext.as(Volume.Iface, p_class).f_get_drive = @ptrCast(p_implementation);
            }
        };

        /// Gets the icon for `volume`.
        pub const get_icon = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.Icon {
                return gobject.ext.as(Volume.Iface, p_class).f_get_icon.?(gobject.ext.as(Volume, p_volume));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.Icon) void {
                gobject.ext.as(Volume.Iface, p_class).f_get_icon = @ptrCast(p_implementation);
            }
        };

        /// Gets the identifier of the given kind for `volume`.
        /// See the [introduction](`volume`-identifiers) for more
        /// information about volume identifiers.
        pub const get_identifier = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_kind: [*:0]const u8) ?[*:0]u8 {
                return gobject.ext.as(Volume.Iface, p_class).f_get_identifier.?(gobject.ext.as(Volume, p_volume), p_kind);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_kind: [*:0]const u8) callconv(.c) ?[*:0]u8) void {
                gobject.ext.as(Volume.Iface, p_class).f_get_identifier = @ptrCast(p_implementation);
            }
        };

        /// Gets the mount for the `volume`.
        pub const get_mount = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?*gio.Mount {
                return gobject.ext.as(Volume.Iface, p_class).f_get_mount.?(gobject.ext.as(Volume, p_volume));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?*gio.Mount) void {
                gobject.ext.as(Volume.Iface, p_class).f_get_mount = @ptrCast(p_implementation);
            }
        };

        /// Gets the name of `volume`.
        pub const get_name = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) [*:0]u8 {
                return gobject.ext.as(Volume.Iface, p_class).f_get_name.?(gobject.ext.as(Volume, p_volume));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) [*:0]u8) void {
                gobject.ext.as(Volume.Iface, p_class).f_get_name = @ptrCast(p_implementation);
            }
        };

        /// Gets the sort key for `volume`, if any.
        pub const get_sort_key = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]const u8 {
                return gobject.ext.as(Volume.Iface, p_class).f_get_sort_key.?(gobject.ext.as(Volume, p_volume));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]const u8) void {
                gobject.ext.as(Volume.Iface, p_class).f_get_sort_key = @ptrCast(p_implementation);
            }
        };

        /// Gets the symbolic icon for `volume`.
        pub const get_symbolic_icon = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) *gio.Icon {
                return gobject.ext.as(Volume.Iface, p_class).f_get_symbolic_icon.?(gobject.ext.as(Volume, p_volume));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) *gio.Icon) void {
                gobject.ext.as(Volume.Iface, p_class).f_get_symbolic_icon = @ptrCast(p_implementation);
            }
        };

        /// Gets the UUID for the `volume`. The reference is typically based on
        /// the file system UUID for the volume in question and should be
        /// considered an opaque string. Returns `NULL` if there is no UUID
        /// available.
        pub const get_uuid = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) ?[*:0]u8 {
                return gobject.ext.as(Volume.Iface, p_class).f_get_uuid.?(gobject.ext.as(Volume, p_volume));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) ?[*:0]u8) void {
                gobject.ext.as(Volume.Iface, p_class).f_get_uuid = @ptrCast(p_implementation);
            }
        };

        /// Finishes mounting a volume. If any errors occurred during the operation,
        /// `error` will be set to contain the errors and `FALSE` will be returned.
        ///
        /// If the mount operation succeeded, `gio.Volume.getMount` on `volume`
        /// is guaranteed to return the mount right after calling this
        /// function; there's no need to listen for the 'mount-added' signal on
        /// `gio.VolumeMonitor`.
        pub const mount_finish = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int {
                return gobject.ext.as(Volume.Iface, p_class).f_mount_finish.?(gobject.ext.as(Volume, p_volume), p_result, p_error);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int) void {
                gobject.ext.as(Volume.Iface, p_class).f_mount_finish = @ptrCast(p_implementation);
            }
        };

        /// Mounts a volume. This is an asynchronous operation, and is
        /// finished by calling `gio.Volume.mountFinish` with the `volume`
        /// and `gio.AsyncResult` returned in the `callback`.
        pub const mount_fn = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void {
                return gobject.ext.as(Volume.Iface, p_class).f_mount_fn.?(gobject.ext.as(Volume, p_volume), p_flags, p_mount_operation, p_cancellable, p_callback, p_user_data);
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void) void {
                gobject.ext.as(Volume.Iface, p_class).f_mount_fn = @ptrCast(p_implementation);
            }
        };

        /// The removed signal that is emitted when the `gio.Volume` have been removed. If the recipient is holding references to the object they should release them so the object can be finalized.
        pub const removed = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) void {
                return gobject.ext.as(Volume.Iface, p_class).f_removed.?(gobject.ext.as(Volume, p_volume));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) void) void {
                gobject.ext.as(Volume.Iface, p_class).f_removed = @ptrCast(p_implementation);
            }
        };

        /// Returns whether the volume should be automatically mounted.
        pub const should_automount = struct {
            pub fn call(p_class: anytype, p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) c_int {
                return gobject.ext.as(Volume.Iface, p_class).f_should_automount.?(gobject.ext.as(Volume, p_volume));
            }

            pub fn implement(p_class: anytype, p_implementation: *const fn (p_volume: *@typeInfo(@TypeOf(p_class)).pointer.child.Instance) callconv(.c) c_int) void {
                gobject.ext.as(Volume.Iface, p_class).f_should_automount = @ptrCast(p_implementation);
            }
        };
    };

    pub const properties = struct {};

    pub const signals = struct {
        /// Emitted when the volume has been changed.
        pub const changed = struct {
            pub const name = "changed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Volume, p_instance))),
                    gobject.signalLookup("changed", Volume.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };

        /// This signal is emitted when the `gio.Volume` have been removed. If
        /// the recipient is holding references to the object they should
        /// release them so the object can be finalized.
        pub const removed = struct {
            pub const name = "removed";

            pub fn connect(p_instance: anytype, comptime P_Data: type, p_callback: *const fn (@TypeOf(p_instance), P_Data) callconv(.c) void, p_data: P_Data, p_options: gobject.ext.ConnectSignalOptions(P_Data)) c_ulong {
                return gobject.signalConnectClosureById(
                    @ptrCast(@alignCast(gobject.ext.as(Volume, p_instance))),
                    gobject.signalLookup("removed", Volume.getGObjectType()),
                    glib.quarkFromString(p_options.detail orelse null),
                    gobject.CClosure.new(@ptrCast(p_callback), p_data, @ptrCast(p_options.destroyData)),
                    @intFromBool(p_options.after),
                );
            }
        };
    };

    /// Checks if a volume can be ejected.
    extern fn g_volume_can_eject(p_volume: *Volume) c_int;
    pub const canEject = g_volume_can_eject;

    /// Checks if a volume can be mounted.
    extern fn g_volume_can_mount(p_volume: *Volume) c_int;
    pub const canMount = g_volume_can_mount;

    /// Ejects a volume. This is an asynchronous operation, and is
    /// finished by calling `gio.Volume.ejectFinish` with the `volume`
    /// and `gio.AsyncResult` returned in the `callback`.
    extern fn g_volume_eject(p_volume: *Volume, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const eject = g_volume_eject;

    /// Finishes ejecting a volume. If any errors occurred during the operation,
    /// `error` will be set to contain the errors and `FALSE` will be returned.
    extern fn g_volume_eject_finish(p_volume: *Volume, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const ejectFinish = g_volume_eject_finish;

    /// Ejects a volume. This is an asynchronous operation, and is
    /// finished by calling `gio.Volume.ejectWithOperationFinish` with the `volume`
    /// and `gio.AsyncResult` data returned in the `callback`.
    extern fn g_volume_eject_with_operation(p_volume: *Volume, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const ejectWithOperation = g_volume_eject_with_operation;

    /// Finishes ejecting a volume. If any errors occurred during the operation,
    /// `error` will be set to contain the errors and `FALSE` will be returned.
    extern fn g_volume_eject_with_operation_finish(p_volume: *Volume, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const ejectWithOperationFinish = g_volume_eject_with_operation_finish;

    /// Gets the kinds of [identifiers](`volume`-identifiers) that `volume` has.
    /// Use `gio.Volume.getIdentifier` to obtain the identifiers themselves.
    extern fn g_volume_enumerate_identifiers(p_volume: *Volume) [*][*:0]u8;
    pub const enumerateIdentifiers = g_volume_enumerate_identifiers;

    /// Gets the activation root for a `gio.Volume` if it is known ahead of
    /// mount time. Returns `NULL` otherwise. If not `NULL` and if `volume`
    /// is mounted, then the result of `gio.Mount.getRoot` on the
    /// `gio.Mount` object obtained from `gio.Volume.getMount` will always
    /// either be equal or a prefix of what this function returns. In
    /// other words, in code
    ///
    /// ```
    ///   GMount *mount;
    ///   GFile *mount_root
    ///   GFile *volume_activation_root;
    ///
    ///   mount = g_volume_get_mount (volume); // mounted, so never NULL
    ///   mount_root = g_mount_get_root (mount);
    ///   volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
    /// ```
    /// then the expression
    /// ```
    ///   (g_file_has_prefix (volume_activation_root, mount_root) ||
    ///    g_file_equal (volume_activation_root, mount_root))
    /// ```
    /// will always be `TRUE`.
    ///
    /// Activation roots are typically used in `gio.VolumeMonitor`
    /// implementations to find the underlying mount to shadow, see
    /// `gio.Mount.isShadowed` for more details.
    extern fn g_volume_get_activation_root(p_volume: *Volume) ?*gio.File;
    pub const getActivationRoot = g_volume_get_activation_root;

    /// Gets the drive for the `volume`.
    extern fn g_volume_get_drive(p_volume: *Volume) ?*gio.Drive;
    pub const getDrive = g_volume_get_drive;

    /// Gets the icon for `volume`.
    extern fn g_volume_get_icon(p_volume: *Volume) *gio.Icon;
    pub const getIcon = g_volume_get_icon;

    /// Gets the identifier of the given kind for `volume`.
    /// See the [introduction](`volume`-identifiers) for more
    /// information about volume identifiers.
    extern fn g_volume_get_identifier(p_volume: *Volume, p_kind: [*:0]const u8) ?[*:0]u8;
    pub const getIdentifier = g_volume_get_identifier;

    /// Gets the mount for the `volume`.
    extern fn g_volume_get_mount(p_volume: *Volume) ?*gio.Mount;
    pub const getMount = g_volume_get_mount;

    /// Gets the name of `volume`.
    extern fn g_volume_get_name(p_volume: *Volume) [*:0]u8;
    pub const getName = g_volume_get_name;

    /// Gets the sort key for `volume`, if any.
    extern fn g_volume_get_sort_key(p_volume: *Volume) ?[*:0]const u8;
    pub const getSortKey = g_volume_get_sort_key;

    /// Gets the symbolic icon for `volume`.
    extern fn g_volume_get_symbolic_icon(p_volume: *Volume) *gio.Icon;
    pub const getSymbolicIcon = g_volume_get_symbolic_icon;

    /// Gets the UUID for the `volume`. The reference is typically based on
    /// the file system UUID for the volume in question and should be
    /// considered an opaque string. Returns `NULL` if there is no UUID
    /// available.
    extern fn g_volume_get_uuid(p_volume: *Volume) ?[*:0]u8;
    pub const getUuid = g_volume_get_uuid;

    /// Mounts a volume. This is an asynchronous operation, and is
    /// finished by calling `gio.Volume.mountFinish` with the `volume`
    /// and `gio.AsyncResult` returned in the `callback`.
    extern fn g_volume_mount(p_volume: *Volume, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
    pub const mount = g_volume_mount;

    /// Finishes mounting a volume. If any errors occurred during the operation,
    /// `error` will be set to contain the errors and `FALSE` will be returned.
    ///
    /// If the mount operation succeeded, `gio.Volume.getMount` on `volume`
    /// is guaranteed to return the mount right after calling this
    /// function; there's no need to listen for the 'mount-added' signal on
    /// `gio.VolumeMonitor`.
    extern fn g_volume_mount_finish(p_volume: *Volume, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) c_int;
    pub const mountFinish = g_volume_mount_finish;

    /// Returns whether the volume should be automatically mounted.
    extern fn g_volume_should_automount(p_volume: *Volume) c_int;
    pub const shouldAutomount = g_volume_should_automount;

    extern fn g_volume_get_type() usize;
    pub const getGObjectType = g_volume_get_type;

    extern fn g_object_ref(p_self: *gio.Volume) void;
    pub const ref = g_object_ref;

    extern fn g_object_unref(p_self: *gio.Volume) void;
    pub const unref = g_object_unref;

    pub fn as(p_instance: *Volume, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// This struct defines a single action.  It is for use with
/// `gio.ActionMap.addActionEntries`.
///
/// The order of the items in the structure are intended to reflect
/// frequency of use.  It is permissible to use an incomplete initialiser
/// in order to leave some of the later values as `NULL`.  All values
/// after `name` are optional.  Additional optional fields may be added in
/// the future.
///
/// See `gio.ActionMap.addActionEntries` for an example.
pub const ActionEntry = extern struct {
    /// the name of the action
    f_name: ?[*:0]const u8,
    /// the callback to connect to the "activate" signal of the action.
    ///   Since GLib 2.40, this can be `NULL` for stateful actions, in which case
    ///   the default handler is used. For boolean-stated actions with no
    ///   parameter, this is a toggle. For other state types (and parameter type
    ///   equal to the state type) this will be a function that just calls
    ///   `change_state` (which you should provide).
    f_activate: ?*const fn (p_action: *gio.SimpleAction, p_parameter: *glib.Variant, p_user_data: ?*anyopaque) callconv(.c) void,
    /// the type of the parameter that must be passed to the
    ///   activate function for this action, given as a single GVariant type string
    ///   (or `NULL` for no parameter)
    f_parameter_type: ?[*:0]const u8,
    /// the initial state for this action, given in
    ///   [GVariant text format](gvariant-text-format.html).  The state is parsed
    ///   with no extra type information, so type tags must be added to the string
    ///   if they are necessary.  Stateless actions should give `NULL` here.
    f_state: ?[*:0]const u8,
    /// the callback to connect to the "change-state" signal of the
    ///   action.  All stateful actions should provide a handler here; stateless
    ///   actions should not.
    f_change_state: ?*const fn (p_action: *gio.SimpleAction, p_value: *glib.Variant, p_user_data: ?*anyopaque) callconv(.c) void,
    f_padding: [3]usize,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The virtual function table for `gio.ActionGroup`.
pub const ActionGroupInterface = extern struct {
    pub const Instance = gio.ActionGroup;

    f_g_iface: gobject.TypeInterface,
    /// the virtual function pointer for `gio.ActionGroup.hasAction`
    f_has_action: ?*const fn (p_action_group: *gio.ActionGroup, p_action_name: [*:0]const u8) callconv(.c) c_int,
    /// the virtual function pointer for `gio.ActionGroup.listActions`
    f_list_actions: ?*const fn (p_action_group: *gio.ActionGroup) callconv(.c) [*][*:0]u8,
    /// the virtual function pointer for `gio.ActionGroup.getActionEnabled`
    f_get_action_enabled: ?*const fn (p_action_group: *gio.ActionGroup, p_action_name: [*:0]const u8) callconv(.c) c_int,
    /// the virtual function pointer for `gio.ActionGroup.getActionParameterType`
    f_get_action_parameter_type: ?*const fn (p_action_group: *gio.ActionGroup, p_action_name: [*:0]const u8) callconv(.c) ?*const glib.VariantType,
    /// the virtual function pointer for `gio.ActionGroup.getActionStateType`
    f_get_action_state_type: ?*const fn (p_action_group: *gio.ActionGroup, p_action_name: [*:0]const u8) callconv(.c) ?*const glib.VariantType,
    /// the virtual function pointer for `gio.ActionGroup.getActionStateHint`
    f_get_action_state_hint: ?*const fn (p_action_group: *gio.ActionGroup, p_action_name: [*:0]const u8) callconv(.c) ?*glib.Variant,
    /// the virtual function pointer for `gio.ActionGroup.getActionState`
    f_get_action_state: ?*const fn (p_action_group: *gio.ActionGroup, p_action_name: [*:0]const u8) callconv(.c) ?*glib.Variant,
    /// the virtual function pointer for `gio.ActionGroup.changeActionState`
    f_change_action_state: ?*const fn (p_action_group: *gio.ActionGroup, p_action_name: [*:0]const u8, p_value: *glib.Variant) callconv(.c) void,
    /// the virtual function pointer for `gio.ActionGroup.activateAction`
    f_activate_action: ?*const fn (p_action_group: *gio.ActionGroup, p_action_name: [*:0]const u8, p_parameter: ?*glib.Variant) callconv(.c) void,
    /// the class closure for the `gio.ActionGroup.signals.action_added` signal
    f_action_added: ?*const fn (p_action_group: *gio.ActionGroup, p_action_name: [*:0]const u8) callconv(.c) void,
    /// the class closure for the `gio.ActionGroup.signals.action_removed` signal
    f_action_removed: ?*const fn (p_action_group: *gio.ActionGroup, p_action_name: [*:0]const u8) callconv(.c) void,
    /// the class closure for the `gio.ActionGroup.signals.action_enabled_changed` signal
    f_action_enabled_changed: ?*const fn (p_action_group: *gio.ActionGroup, p_action_name: [*:0]const u8, p_enabled: c_int) callconv(.c) void,
    /// the class closure for the `gio.ActionGroup.signals.action_enabled_changed` signal
    f_action_state_changed: ?*const fn (p_action_group: *gio.ActionGroup, p_action_name: [*:0]const u8, p_state: *glib.Variant) callconv(.c) void,
    /// the virtual function pointer for `gio.ActionGroup.queryAction`
    f_query_action: ?*const fn (p_action_group: *gio.ActionGroup, p_action_name: [*:0]const u8, p_enabled: *c_int, p_parameter_type: ?**const glib.VariantType, p_state_type: ?**const glib.VariantType, p_state_hint: ?**glib.Variant, p_state: ?**glib.Variant) callconv(.c) c_int,

    pub fn as(p_instance: *ActionGroupInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The virtual function table for `gio.Action`.
pub const ActionInterface = extern struct {
    pub const Instance = gio.Action;

    f_g_iface: gobject.TypeInterface,
    /// the virtual function pointer for `gio.Action.getName`
    f_get_name: ?*const fn (p_action: *gio.Action) callconv(.c) [*:0]const u8,
    /// the virtual function pointer for `gio.Action.getParameterType`
    f_get_parameter_type: ?*const fn (p_action: *gio.Action) callconv(.c) ?*const glib.VariantType,
    /// the virtual function pointer for `gio.Action.getStateType`
    f_get_state_type: ?*const fn (p_action: *gio.Action) callconv(.c) ?*const glib.VariantType,
    /// the virtual function pointer for `gio.Action.getStateHint`
    f_get_state_hint: ?*const fn (p_action: *gio.Action) callconv(.c) ?*glib.Variant,
    /// the virtual function pointer for `gio.Action.getEnabled`
    f_get_enabled: ?*const fn (p_action: *gio.Action) callconv(.c) c_int,
    /// the virtual function pointer for `gio.Action.getState`
    f_get_state: ?*const fn (p_action: *gio.Action) callconv(.c) ?*glib.Variant,
    /// the virtual function pointer for `gio.Action.changeState`
    f_change_state: ?*const fn (p_action: *gio.Action, p_value: *glib.Variant) callconv(.c) void,
    /// the virtual function pointer for `gio.Action.activate`.  Note that `gio.Action` does not have an
    ///            'activate' signal but that implementations of it may have one.
    f_activate: ?*const fn (p_action: *gio.Action, p_parameter: ?*glib.Variant) callconv(.c) void,

    pub fn as(p_instance: *ActionInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The virtual function table for `gio.ActionMap`.
pub const ActionMapInterface = extern struct {
    pub const Instance = gio.ActionMap;

    f_g_iface: gobject.TypeInterface,
    /// the virtual function pointer for
    ///   `gio.ActionMap.lookupAction`
    f_lookup_action: ?*const fn (p_action_map: *gio.ActionMap, p_action_name: [*:0]const u8) callconv(.c) ?*gio.Action,
    /// the virtual function pointer for
    ///   `gio.ActionMap.addAction`
    f_add_action: ?*const fn (p_action_map: *gio.ActionMap, p_action: *gio.Action) callconv(.c) void,
    /// the virtual function pointer for
    ///   `gio.ActionMap.removeAction`
    f_remove_action: ?*const fn (p_action_map: *gio.ActionMap, p_action_name: [*:0]const u8) callconv(.c) void,

    pub fn as(p_instance: *ActionMapInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Application Information interface, for operating system portability.
pub const AppInfoIface = extern struct {
    pub const Instance = gio.AppInfo;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Copies a `gio.AppInfo`.
    f_dup: ?*const fn (p_appinfo: *gio.AppInfo) callconv(.c) *gio.AppInfo,
    /// Checks two `gio.AppInfo`s for equality.
    f_equal: ?*const fn (p_appinfo1: *gio.AppInfo, p_appinfo2: *gio.AppInfo) callconv(.c) c_int,
    /// Gets a string identifier for a `gio.AppInfo`.
    f_get_id: ?*const fn (p_appinfo: *gio.AppInfo) callconv(.c) ?[*:0]const u8,
    /// Gets the name of the application for a `gio.AppInfo`.
    f_get_name: ?*const fn (p_appinfo: *gio.AppInfo) callconv(.c) [*:0]const u8,
    /// Gets a short description for the application described by
    ///   the `gio.AppInfo`.
    f_get_description: ?*const fn (p_appinfo: *gio.AppInfo) callconv(.c) ?[*:0]const u8,
    /// Gets the executable name for the `gio.AppInfo`.
    f_get_executable: ?*const fn (p_appinfo: *gio.AppInfo) callconv(.c) [*:0]const u8,
    /// Gets the `gio.Icon` for the `gio.AppInfo`.
    f_get_icon: ?*const fn (p_appinfo: *gio.AppInfo) callconv(.c) ?*gio.Icon,
    /// Launches an application specified by the `gio.AppInfo`.
    f_launch: ?*const fn (p_appinfo: *gio.AppInfo, p_files: ?*glib.List, p_context: ?*gio.AppLaunchContext, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Indicates whether the application specified supports
    ///   launching URIs.
    f_supports_uris: ?*const fn (p_appinfo: *gio.AppInfo) callconv(.c) c_int,
    /// Indicates whether the application specified accepts
    ///   filename arguments.
    f_supports_files: ?*const fn (p_appinfo: *gio.AppInfo) callconv(.c) c_int,
    /// Launches an application with a list of URIs.
    f_launch_uris: ?*const fn (p_appinfo: *gio.AppInfo, p_uris: ?*glib.List, p_context: ?*gio.AppLaunchContext, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Returns whether an application should be shown (e.g. when
    ///   getting a list of installed applications).
    ///   [FreeDesktop.Org Startup Notification Specification](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
    f_should_show: ?*const fn (p_appinfo: *gio.AppInfo) callconv(.c) c_int,
    /// Sets an application as default for a given content
    ///   type.
    f_set_as_default_for_type: ?*const fn (p_appinfo: *gio.AppInfo, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Sets an application as default for a given
    ///   file extension.
    f_set_as_default_for_extension: ?*const fn (p_appinfo: *gio.AppInfo, p_extension: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Adds to the `gio.AppInfo` information about
    ///   supported file types.
    f_add_supports_type: ?*const fn (p_appinfo: *gio.AppInfo, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Checks for support for removing supported file
    ///   types from a `gio.AppInfo`.
    f_can_remove_supports_type: ?*const fn (p_appinfo: *gio.AppInfo) callconv(.c) c_int,
    /// Removes a supported application type from a
    ///   `gio.AppInfo`.
    f_remove_supports_type: ?*const fn (p_appinfo: *gio.AppInfo, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Checks if a `gio.AppInfo` can be deleted. (Since 2.20)
    f_can_delete: ?*const fn (p_appinfo: *gio.AppInfo) callconv(.c) c_int,
    /// Deletes a `gio.AppInfo`. (Since 2.20)
    f_do_delete: ?*const fn (p_appinfo: *gio.AppInfo) callconv(.c) c_int,
    /// Gets the commandline for the `gio.AppInfo`.
    ///   (Since 2.20)
    f_get_commandline: ?*const fn (p_appinfo: *gio.AppInfo) callconv(.c) ?[*:0]const u8,
    /// Gets the display name for the `gio.AppInfo`.
    ///   (Since 2.24)
    f_get_display_name: ?*const fn (p_appinfo: *gio.AppInfo) callconv(.c) [*:0]const u8,
    /// Sets the application as the last used. See
    ///   `gio.AppInfo.setAsLastUsedForType`.
    f_set_as_last_used_for_type: ?*const fn (p_appinfo: *gio.AppInfo, p_content_type: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Retrieves the list of content types that `app_info`
    ///   claims to support.
    f_get_supported_types: ?*const fn (p_appinfo: *gio.AppInfo) callconv(.c) [*][*:0]const u8,
    /// Asynchronously launches an application with a list of
    ///   URIs. (Since: 2.60)
    f_launch_uris_async: ?*const fn (p_appinfo: *gio.AppInfo, p_uris: ?*glib.List, p_context: ?*gio.AppLaunchContext, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an operation started with `launch_uris_async`.
    ///   (Since: 2.60)
    f_launch_uris_finish: ?*const fn (p_appinfo: *gio.AppInfo, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,

    pub fn as(p_instance: *AppInfoIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AppLaunchContextClass = extern struct {
    pub const Instance = gio.AppLaunchContext;

    f_parent_class: gobject.ObjectClass,
    f_get_display: ?*const fn (p_context: *gio.AppLaunchContext, p_info: *gio.AppInfo, p_files: *glib.List) callconv(.c) ?[*:0]u8,
    f_get_startup_notify_id: ?*const fn (p_context: *gio.AppLaunchContext, p_info: ?*gio.AppInfo, p_files: ?*glib.List) callconv(.c) ?[*:0]u8,
    f_launch_failed: ?*const fn (p_context: *gio.AppLaunchContext, p_startup_notify_id: [*:0]const u8) callconv(.c) void,
    f_launched: ?*const fn (p_context: *gio.AppLaunchContext, p_info: *gio.AppInfo, p_platform_data: *glib.Variant) callconv(.c) void,
    f_launch_started: ?*const fn (p_context: *gio.AppLaunchContext, p_info: *gio.AppInfo, p_platform_data: *glib.Variant) callconv(.c) void,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *AppLaunchContextClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const AppLaunchContextPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Virtual function table for `gio.Application`.
pub const ApplicationClass = extern struct {
    pub const Instance = gio.Application;

    f_parent_class: gobject.ObjectClass,
    /// invoked on the primary instance immediately after registration
    f_startup: ?*const fn (p_application: *gio.Application) callconv(.c) void,
    /// invoked on the primary instance when an activation occurs
    f_activate: ?*const fn (p_application: *gio.Application) callconv(.c) void,
    /// invoked on the primary instance when there are files to open
    f_open: ?*const fn (p_application: *gio.Application, p_files: [*]*gio.File, p_n_files: c_int, p_hint: [*:0]const u8) callconv(.c) void,
    /// invoked on the primary instance when a command-line is
    ///   not handled locally
    f_command_line: ?*const fn (p_application: *gio.Application, p_command_line: *gio.ApplicationCommandLine) callconv(.c) c_int,
    /// invoked (locally). The virtual function has the chance
    ///     to inspect (and possibly replace) command line arguments. See
    ///     `gio.Application.run` for more information. Also see the
    ///     `gio.Application.signals.handle`-local-options signal, which is a simpler
    ///     alternative to handling some commandline options locally
    f_local_command_line: ?*const fn (p_application: *gio.Application, p_arguments: *[*][*:0]u8, p_exit_status: *c_int) callconv(.c) c_int,
    /// invoked on the primary instance before 'activate', 'open',
    ///     'command-line' or any action invocation, gets the 'platform data' from
    ///     the calling instance
    f_before_emit: ?*const fn (p_application: *gio.Application, p_platform_data: *glib.Variant) callconv(.c) void,
    /// invoked on the primary instance after 'activate', 'open',
    ///     'command-line' or any action invocation, gets the 'platform data' from
    ///     the calling instance
    f_after_emit: ?*const fn (p_application: *gio.Application, p_platform_data: *glib.Variant) callconv(.c) void,
    /// invoked (locally) to add 'platform data' to be sent to
    ///     the primary instance when activating, opening or invoking actions
    f_add_platform_data: ?*const fn (p_application: *gio.Application, p_builder: *glib.VariantBuilder) callconv(.c) void,
    /// Used to be invoked on the primary instance when the use
    ///     count of the application drops to zero (and after any inactivity
    ///     timeout, if requested). Not used anymore since 2.32
    f_quit_mainloop: ?*const fn (p_application: *gio.Application) callconv(.c) void,
    /// Used to be invoked on the primary instance from
    ///     `gio.Application.run` if the use-count is non-zero. Since 2.32,
    ///     GApplication is iterating the main context directly and is not
    ///     using `run_mainloop` anymore
    f_run_mainloop: ?*const fn (p_application: *gio.Application) callconv(.c) void,
    /// invoked only on the registered primary instance immediately
    ///      after the main loop terminates
    f_shutdown: ?*const fn (p_application: *gio.Application) callconv(.c) void,
    /// invoked locally during registration, if the application is
    ///     using its D-Bus backend. You can use this to export extra objects on the
    ///     bus, that need to exist before the application tries to own the bus name.
    ///     The function is passed the `gio.DBusConnection` to to session bus, and the
    ///     object path that `gio.Application` will use to export its D-Bus API.
    ///     If this function returns `TRUE`, registration will proceed; otherwise
    ///     registration will abort. Since: 2.34
    f_dbus_register: ?*const fn (p_application: *gio.Application, p_connection: *gio.DBusConnection, p_object_path: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// invoked locally during unregistration, if the application
    ///     is using its D-Bus backend. Use this to undo anything done by
    ///     the `dbus_register` vfunc. Since: 2.34
    f_dbus_unregister: ?*const fn (p_application: *gio.Application, p_connection: *gio.DBusConnection, p_object_path: [*:0]const u8) callconv(.c) void,
    /// invoked locally after the parsing of the commandline
    ///  options has occurred. Since: 2.40
    f_handle_local_options: ?*const fn (p_application: *gio.Application, p_options: *glib.VariantDict) callconv(.c) c_int,
    /// invoked when another instance is taking over the name. Since: 2.60
    f_name_lost: ?*const fn (p_application: *gio.Application) callconv(.c) c_int,
    f_padding: [7]*anyopaque,

    pub fn as(p_instance: *ApplicationClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gio.ApplicationCommandLineClass`-struct
/// contains private data only.
pub const ApplicationCommandLineClass = extern struct {
    pub const Instance = gio.ApplicationCommandLine;

    f_parent_class: gobject.ObjectClass,
    f_print_literal: ?*const fn (p_cmdline: *gio.ApplicationCommandLine, p_message: [*:0]const u8) callconv(.c) void,
    f_printerr_literal: ?*const fn (p_cmdline: *gio.ApplicationCommandLine, p_message: [*:0]const u8) callconv(.c) void,
    f_get_stdin: ?*const fn (p_cmdline: *gio.ApplicationCommandLine) callconv(.c) ?*gio.InputStream,
    f_done: ?*const fn (p_cmdline: *gio.ApplicationCommandLine) callconv(.c) void,
    f_padding: [10]*anyopaque,

    pub fn as(p_instance: *ApplicationCommandLineClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ApplicationCommandLinePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ApplicationPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Provides an interface for asynchronous initializing object such that
/// initialization may fail.
pub const AsyncInitableIface = extern struct {
    pub const Instance = gio.AsyncInitable;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Starts initialization of the object.
    f_init_async: ?*const fn (p_initable: *gio.AsyncInitable, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes initialization of the object.
    f_init_finish: ?*const fn (p_initable: *gio.AsyncInitable, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,

    pub fn as(p_instance: *AsyncInitableIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Interface definition for `gio.AsyncResult`.
pub const AsyncResultIface = extern struct {
    pub const Instance = gio.AsyncResult;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Gets the user data passed to the callback.
    f_get_user_data: ?*const fn (p_res: *gio.AsyncResult) callconv(.c) ?*anyopaque,
    /// Gets the source object that issued the asynchronous operation.
    f_get_source_object: ?*const fn (p_res: *gio.AsyncResult) callconv(.c) ?*gobject.Object,
    /// Checks if a result is tagged with a particular source.
    f_is_tagged: ?*const fn (p_res: *gio.AsyncResult, p_source_tag: ?*anyopaque) callconv(.c) c_int,

    pub fn as(p_instance: *AsyncResultIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const BufferedInputStreamClass = extern struct {
    pub const Instance = gio.BufferedInputStream;

    f_parent_class: gio.FilterInputStreamClass,
    f_fill: ?*const fn (p_stream: *gio.BufferedInputStream, p_count: isize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) isize,
    f_fill_async: ?*const fn (p_stream: *gio.BufferedInputStream, p_count: isize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_fill_finish: ?*const fn (p_stream: *gio.BufferedInputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) isize,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *BufferedInputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const BufferedInputStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const BufferedOutputStreamClass = extern struct {
    pub const Instance = gio.BufferedOutputStream;

    f_parent_class: gio.FilterOutputStreamClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *BufferedOutputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const BufferedOutputStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CancellableClass = extern struct {
    pub const Instance = gio.Cancellable;

    f_parent_class: gobject.ObjectClass,
    f_cancelled: ?*const fn (p_cancellable: ?*gio.Cancellable) callconv(.c) void,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *CancellableClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CancellablePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const CharsetConverterClass = extern struct {
    pub const Instance = gio.CharsetConverter;

    f_parent_class: gobject.ObjectClass,

    pub fn as(p_instance: *CharsetConverterClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Provides an interface for converting data from one type
/// to another type. The conversion can be stateful
/// and may fail at any place.
pub const ConverterIface = extern struct {
    pub const Instance = gio.Converter;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Converts data.
    f_convert: ?*const fn (p_converter: *gio.Converter, p_inbuf: ?[*]u8, p_inbuf_size: usize, p_outbuf: [*]u8, p_outbuf_size: usize, p_flags: gio.ConverterFlags, p_bytes_read: *usize, p_bytes_written: *usize, p_error: ?*?*glib.Error) callconv(.c) gio.ConverterResult,
    /// Reverts the internal state of the converter to its initial state.
    f_reset: ?*const fn (p_converter: *gio.Converter) callconv(.c) void,

    pub fn as(p_instance: *ConverterIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ConverterInputStreamClass = extern struct {
    pub const Instance = gio.ConverterInputStream;

    f_parent_class: gio.FilterInputStreamClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ConverterInputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ConverterInputStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ConverterOutputStreamClass = extern struct {
    pub const Instance = gio.ConverterOutputStream;

    f_parent_class: gio.FilterOutputStreamClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ConverterOutputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ConverterOutputStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.Credentials`.
pub const CredentialsClass = opaque {
    pub const Instance = gio.Credentials;

    pub fn as(p_instance: *CredentialsClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Information about an annotation.
pub const DBusAnnotationInfo = extern struct {
    /// The reference count or -1 if statically allocated.
    f_ref_count: c_int,
    /// The name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".
    f_key: ?[*:0]u8,
    /// The value of the annotation.
    f_value: ?[*:0]u8,
    /// A pointer to a `NULL`-terminated array of pointers to `gio.DBusAnnotationInfo` structures or `NULL` if there are no annotations.
    f_annotations: ?[*]*gio.DBusAnnotationInfo,

    /// Looks up the value of an annotation.
    ///
    /// The cost of this function is O(n) in number of annotations.
    extern fn g_dbus_annotation_info_lookup(p_annotations: ?[*]*gio.DBusAnnotationInfo, p_name: [*:0]const u8) ?[*:0]const u8;
    pub const lookup = g_dbus_annotation_info_lookup;

    /// If `info` is statically allocated does nothing. Otherwise increases
    /// the reference count.
    extern fn g_dbus_annotation_info_ref(p_info: *DBusAnnotationInfo) *gio.DBusAnnotationInfo;
    pub const ref = g_dbus_annotation_info_ref;

    /// If `info` is statically allocated, does nothing. Otherwise decreases
    /// the reference count of `info`. When its reference count drops to 0,
    /// the memory used is freed.
    extern fn g_dbus_annotation_info_unref(p_info: *DBusAnnotationInfo) void;
    pub const unref = g_dbus_annotation_info_unref;

    extern fn g_dbus_annotation_info_get_type() usize;
    pub const getGObjectType = g_dbus_annotation_info_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Information about an argument for a method or a signal.
pub const DBusArgInfo = extern struct {
    /// The reference count or -1 if statically allocated.
    f_ref_count: c_int,
    /// Name of the argument, e.g. `unix_user_id`.
    f_name: ?[*:0]u8,
    /// D-Bus signature of the argument (a single complete type).
    f_signature: ?[*:0]u8,
    /// A pointer to a `NULL`-terminated array of pointers to `gio.DBusAnnotationInfo` structures or `NULL` if there are no annotations.
    f_annotations: ?[*]*gio.DBusAnnotationInfo,

    /// If `info` is statically allocated does nothing. Otherwise increases
    /// the reference count.
    extern fn g_dbus_arg_info_ref(p_info: *DBusArgInfo) *gio.DBusArgInfo;
    pub const ref = g_dbus_arg_info_ref;

    /// If `info` is statically allocated, does nothing. Otherwise decreases
    /// the reference count of `info`. When its reference count drops to 0,
    /// the memory used is freed.
    extern fn g_dbus_arg_info_unref(p_info: *DBusArgInfo) void;
    pub const unref = g_dbus_arg_info_unref;

    extern fn g_dbus_arg_info_get_type() usize;
    pub const getGObjectType = g_dbus_arg_info_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Struct used in `gio.dbusErrorRegisterErrorDomain`.
pub const DBusErrorEntry = extern struct {
    /// An error code.
    f_error_code: c_int,
    /// The D-Bus error name to associate with `error_code`.
    f_dbus_error_name: ?[*:0]const u8,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Base type for D-Bus interfaces.
pub const DBusInterfaceIface = extern struct {
    pub const Instance = gio.DBusInterface;

    /// The parent interface.
    f_parent_iface: gobject.TypeInterface,
    /// Returns a `gio.DBusInterfaceInfo`. See `gio.DBusInterface.getInfo`.
    f_get_info: ?*const fn (p_interface_: *gio.DBusInterface) callconv(.c) *gio.DBusInterfaceInfo,
    /// Gets the enclosing `gio.DBusObject`. See `gio.DBusInterface.getObject`.
    f_get_object: ?*const fn (p_interface_: *gio.DBusInterface) callconv(.c) ?*gio.DBusObject,
    /// Sets the enclosing `gio.DBusObject`. See `gio.DBusInterface.setObject`.
    f_set_object: ?*const fn (p_interface_: *gio.DBusInterface, p_object: ?*gio.DBusObject) callconv(.c) void,
    /// Gets a reference to the enclosing `gio.DBusObject`. See `gio.DBusInterface.dupObject`. Added in 2.32.
    f_dup_object: ?*const fn (p_interface_: *gio.DBusInterface) callconv(.c) ?*gio.DBusObject,

    pub fn as(p_instance: *DBusInterfaceIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Information about a D-Bus interface.
pub const DBusInterfaceInfo = extern struct {
    /// The reference count or -1 if statically allocated.
    f_ref_count: c_int,
    /// The name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".
    f_name: ?[*:0]u8,
    /// A pointer to a `NULL`-terminated array of pointers to `gio.DBusMethodInfo` structures or `NULL` if there are no methods.
    f_methods: ?[*]*gio.DBusMethodInfo,
    /// A pointer to a `NULL`-terminated array of pointers to `gio.DBusSignalInfo` structures or `NULL` if there are no signals.
    f_signals: ?[*]*gio.DBusSignalInfo,
    /// A pointer to a `NULL`-terminated array of pointers to `gio.DBusPropertyInfo` structures or `NULL` if there are no properties.
    f_properties: ?[*]*gio.DBusPropertyInfo,
    /// A pointer to a `NULL`-terminated array of pointers to `gio.DBusAnnotationInfo` structures or `NULL` if there are no annotations.
    f_annotations: ?[*]*gio.DBusAnnotationInfo,

    /// Builds a lookup-cache to speed up
    /// `gio.DBusInterfaceInfo.lookupMethod`,
    /// `gio.DBusInterfaceInfo.lookupSignal` and
    /// `gio.DBusInterfaceInfo.lookupProperty`.
    ///
    /// If this has already been called with `info`, the existing cache is
    /// used and its use count is increased.
    ///
    /// Note that `info` cannot be modified until
    /// `gio.DBusInterfaceInfo.cacheRelease` is called.
    extern fn g_dbus_interface_info_cache_build(p_info: *DBusInterfaceInfo) void;
    pub const cacheBuild = g_dbus_interface_info_cache_build;

    /// Decrements the usage count for the cache for `info` built by
    /// `gio.DBusInterfaceInfo.cacheBuild` (if any) and frees the
    /// resources used by the cache if the usage count drops to zero.
    extern fn g_dbus_interface_info_cache_release(p_info: *DBusInterfaceInfo) void;
    pub const cacheRelease = g_dbus_interface_info_cache_release;

    /// Appends an XML representation of `info` (and its children) to `string_builder`.
    ///
    /// This function is typically used for generating introspection XML
    /// documents at run-time for handling the
    /// `org.freedesktop.DBus.Introspectable.Introspect`
    /// method.
    extern fn g_dbus_interface_info_generate_xml(p_info: *DBusInterfaceInfo, p_indent: c_uint, p_string_builder: *glib.String) void;
    pub const generateXml = g_dbus_interface_info_generate_xml;

    /// Looks up information about a method.
    ///
    /// The cost of this function is O(n) in number of methods unless
    /// `gio.DBusInterfaceInfo.cacheBuild` has been used on `info`.
    extern fn g_dbus_interface_info_lookup_method(p_info: *DBusInterfaceInfo, p_name: [*:0]const u8) ?*gio.DBusMethodInfo;
    pub const lookupMethod = g_dbus_interface_info_lookup_method;

    /// Looks up information about a property.
    ///
    /// The cost of this function is O(n) in number of properties unless
    /// `gio.DBusInterfaceInfo.cacheBuild` has been used on `info`.
    extern fn g_dbus_interface_info_lookup_property(p_info: *DBusInterfaceInfo, p_name: [*:0]const u8) ?*gio.DBusPropertyInfo;
    pub const lookupProperty = g_dbus_interface_info_lookup_property;

    /// Looks up information about a signal.
    ///
    /// The cost of this function is O(n) in number of signals unless
    /// `gio.DBusInterfaceInfo.cacheBuild` has been used on `info`.
    extern fn g_dbus_interface_info_lookup_signal(p_info: *DBusInterfaceInfo, p_name: [*:0]const u8) ?*gio.DBusSignalInfo;
    pub const lookupSignal = g_dbus_interface_info_lookup_signal;

    /// If `info` is statically allocated does nothing. Otherwise increases
    /// the reference count.
    extern fn g_dbus_interface_info_ref(p_info: *DBusInterfaceInfo) *gio.DBusInterfaceInfo;
    pub const ref = g_dbus_interface_info_ref;

    /// If `info` is statically allocated, does nothing. Otherwise decreases
    /// the reference count of `info`. When its reference count drops to 0,
    /// the memory used is freed.
    extern fn g_dbus_interface_info_unref(p_info: *DBusInterfaceInfo) void;
    pub const unref = g_dbus_interface_info_unref;

    extern fn g_dbus_interface_info_get_type() usize;
    pub const getGObjectType = g_dbus_interface_info_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.DBusInterfaceSkeleton`.
pub const DBusInterfaceSkeletonClass = extern struct {
    pub const Instance = gio.DBusInterfaceSkeleton;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    /// Returns a `gio.DBusInterfaceInfo`. See `gio.DBusInterfaceSkeleton.getInfo` for details.
    f_get_info: ?*const fn (p_interface_: *gio.DBusInterfaceSkeleton) callconv(.c) *gio.DBusInterfaceInfo,
    /// Returns a `gio.DBusInterfaceVTable`. See `gio.DBusInterfaceSkeleton.getVtable` for details.
    f_get_vtable: ?*const fn (p_interface_: *gio.DBusInterfaceSkeleton) callconv(.c) *gio.DBusInterfaceVTable,
    /// Returns a `glib.Variant` with all properties. See `gio.DBusInterfaceSkeleton.getProperties`.
    f_get_properties: ?*const fn (p_interface_: *gio.DBusInterfaceSkeleton) callconv(.c) *glib.Variant,
    /// Emits outstanding changes, if any. See `gio.DBusInterfaceSkeleton.flush`.
    f_flush: ?*const fn (p_interface_: *gio.DBusInterfaceSkeleton) callconv(.c) void,
    f_vfunc_padding: [8]*anyopaque,
    /// Signal class handler for the `gio.DBusInterfaceSkeleton.signals.g`-authorize-method signal.
    f_g_authorize_method: ?*const fn (p_interface_: *gio.DBusInterfaceSkeleton, p_invocation: *gio.DBusMethodInvocation) callconv(.c) c_int,
    f_signal_padding: [8]*anyopaque,

    pub fn as(p_instance: *DBusInterfaceSkeletonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const DBusInterfaceSkeletonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Virtual table for handling properties and method calls for a D-Bus
/// interface.
///
/// Since 2.38, if you want to handle getting/setting D-Bus properties
/// asynchronously, give `NULL` as your `get_property` or `set_property`
/// function. The D-Bus call will be directed to your `method_call` function,
/// with the provided `interface_name` set to "org.freedesktop.DBus.Properties".
///
/// Ownership of the `gio.DBusMethodInvocation` object passed to the
/// `method_call` function is transferred to your handler; you must
/// call one of the methods of `gio.DBusMethodInvocation` to return a reply
/// (possibly empty), or an error. These functions also take ownership
/// of the passed-in invocation object, so unless the invocation
/// object has otherwise been referenced, it will be then be freed.
/// Calling one of these functions may be done within your
/// `method_call` implementation but it also can be done at a later
/// point to handle the method asynchronously.
///
/// The usual checks on the validity of the calls is performed. For
/// `Get` calls, an error is automatically returned if the property does
/// not exist or the permissions do not allow access. The same checks are
/// performed for `Set` calls, and the provided value is also checked for
/// being the correct type.
///
/// For both `Get` and `Set` calls, the `gio.DBusMethodInvocation`
/// passed to the `method_call` handler can be queried with
/// `gio.DBusMethodInvocation.getPropertyInfo` to get a pointer
/// to the `gio.DBusPropertyInfo` of the property.
///
/// If you have readable properties specified in your interface info,
/// you must ensure that you either provide a non-`NULL` `get_property``get_property`
/// function or provide implementations of both the `Get` and `GetAll`
/// methods on org.freedesktop.DBus.Properties interface in your `method_call`
/// function. Note that the required return type of the `Get` call is
/// `(v)`, not the type of the property. `GetAll` expects a return value
/// of type `a{sv}`.
///
/// If you have writable properties specified in your interface info,
/// you must ensure that you either provide a non-`NULL` `set_property``set_property`
/// function or provide an implementation of the `Set` call. If implementing
/// the call, you must return the value of type `G_VARIANT_TYPE_UNIT`.
pub const DBusInterfaceVTable = extern struct {
    /// Function for handling incoming method calls.
    f_method_call: ?gio.DBusInterfaceMethodCallFunc,
    /// Function for getting a property.
    f_get_property: ?gio.DBusInterfaceGetPropertyFunc,
    /// Function for setting a property.
    f_set_property: ?gio.DBusInterfaceSetPropertyFunc,
    f_padding: [8]*anyopaque,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Information about a method on a D-Bus interface.
pub const DBusMethodInfo = extern struct {
    /// The reference count or -1 if statically allocated.
    f_ref_count: c_int,
    /// The name of the D-Bus method, e.g. `RequestName`.
    f_name: ?[*:0]u8,
    /// A pointer to a `NULL`-terminated array of pointers to `gio.DBusArgInfo` structures or `NULL` if there are no in arguments.
    f_in_args: ?[*]*gio.DBusArgInfo,
    /// A pointer to a `NULL`-terminated array of pointers to `gio.DBusArgInfo` structures or `NULL` if there are no out arguments.
    f_out_args: ?[*]*gio.DBusArgInfo,
    /// A pointer to a `NULL`-terminated array of pointers to `gio.DBusAnnotationInfo` structures or `NULL` if there are no annotations.
    f_annotations: ?[*]*gio.DBusAnnotationInfo,

    /// If `info` is statically allocated does nothing. Otherwise increases
    /// the reference count.
    extern fn g_dbus_method_info_ref(p_info: *DBusMethodInfo) *gio.DBusMethodInfo;
    pub const ref = g_dbus_method_info_ref;

    /// If `info` is statically allocated, does nothing. Otherwise decreases
    /// the reference count of `info`. When its reference count drops to 0,
    /// the memory used is freed.
    extern fn g_dbus_method_info_unref(p_info: *DBusMethodInfo) void;
    pub const unref = g_dbus_method_info_unref;

    extern fn g_dbus_method_info_get_type() usize;
    pub const getGObjectType = g_dbus_method_info_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Information about nodes in a remote object hierarchy.
pub const DBusNodeInfo = extern struct {
    /// The reference count or -1 if statically allocated.
    f_ref_count: c_int,
    /// The path of the node or `NULL` if omitted. Note that this may be a relative path. See the D-Bus specification for more details.
    f_path: ?[*:0]u8,
    /// A pointer to a `NULL`-terminated array of pointers to `gio.DBusInterfaceInfo` structures or `NULL` if there are no interfaces.
    f_interfaces: ?[*]*gio.DBusInterfaceInfo,
    /// A pointer to a `NULL`-terminated array of pointers to `gio.DBusNodeInfo` structures or `NULL` if there are no nodes.
    f_nodes: ?[*]*gio.DBusNodeInfo,
    /// A pointer to a `NULL`-terminated array of pointers to `gio.DBusAnnotationInfo` structures or `NULL` if there are no annotations.
    f_annotations: ?[*]*gio.DBusAnnotationInfo,

    /// Parses `xml_data` and returns a `gio.DBusNodeInfo` representing the data.
    ///
    /// The introspection XML must contain exactly one top-level
    /// `<node>` element.
    ///
    /// Note that this routine is using a
    /// [GMarkup](../glib/markup.html)-based
    /// parser that only accepts a subset of valid XML documents.
    extern fn g_dbus_node_info_new_for_xml(p_xml_data: [*:0]const u8, p_error: ?*?*glib.Error) ?*gio.DBusNodeInfo;
    pub const newForXml = g_dbus_node_info_new_for_xml;

    /// Appends an XML representation of `info` (and its children) to `string_builder`.
    ///
    /// This function is typically used for generating introspection XML documents at run-time for
    /// handling the `org.freedesktop.DBus.Introspectable.Introspect`  method.
    extern fn g_dbus_node_info_generate_xml(p_info: *DBusNodeInfo, p_indent: c_uint, p_string_builder: *glib.String) void;
    pub const generateXml = g_dbus_node_info_generate_xml;

    /// Looks up information about an interface.
    ///
    /// The cost of this function is O(n) in number of interfaces.
    extern fn g_dbus_node_info_lookup_interface(p_info: *DBusNodeInfo, p_name: [*:0]const u8) ?*gio.DBusInterfaceInfo;
    pub const lookupInterface = g_dbus_node_info_lookup_interface;

    /// If `info` is statically allocated does nothing. Otherwise increases
    /// the reference count.
    extern fn g_dbus_node_info_ref(p_info: *DBusNodeInfo) *gio.DBusNodeInfo;
    pub const ref = g_dbus_node_info_ref;

    /// If `info` is statically allocated, does nothing. Otherwise decreases
    /// the reference count of `info`. When its reference count drops to 0,
    /// the memory used is freed.
    extern fn g_dbus_node_info_unref(p_info: *DBusNodeInfo) void;
    pub const unref = g_dbus_node_info_unref;

    extern fn g_dbus_node_info_get_type() usize;
    pub const getGObjectType = g_dbus_node_info_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Base object type for D-Bus objects.
pub const DBusObjectIface = extern struct {
    pub const Instance = gio.DBusObject;

    /// The parent interface.
    f_parent_iface: gobject.TypeInterface,
    /// Returns the object path. See `gio.DBusObject.getObjectPath`.
    f_get_object_path: ?*const fn (p_object: *gio.DBusObject) callconv(.c) [*:0]const u8,
    /// Returns all interfaces. See `gio.DBusObject.getInterfaces`.
    f_get_interfaces: ?*const fn (p_object: *gio.DBusObject) callconv(.c) *glib.List,
    /// Returns an interface by name. See `gio.DBusObject.getInterface`.
    f_get_interface: ?*const fn (p_object: *gio.DBusObject, p_interface_name: [*:0]const u8) callconv(.c) ?*gio.DBusInterface,
    /// Signal handler for the `gio.DBusObject.signals.interface`-added signal.
    f_interface_added: ?*const fn (p_object: *gio.DBusObject, p_interface_: *gio.DBusInterface) callconv(.c) void,
    /// Signal handler for the `gio.DBusObject.signals.interface`-removed signal.
    f_interface_removed: ?*const fn (p_object: *gio.DBusObject, p_interface_: *gio.DBusInterface) callconv(.c) void,

    pub fn as(p_instance: *DBusObjectIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.DBusObjectManagerClient`.
pub const DBusObjectManagerClientClass = extern struct {
    pub const Instance = gio.DBusObjectManagerClient;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    /// Signal class handler for the `gio.DBusObjectManagerClient.signals.interface`-proxy-signal signal.
    f_interface_proxy_signal: ?*const fn (p_manager: *gio.DBusObjectManagerClient, p_object_proxy: *gio.DBusObjectProxy, p_interface_proxy: *gio.DBusProxy, p_sender_name: [*:0]const u8, p_signal_name: [*:0]const u8, p_parameters: *glib.Variant) callconv(.c) void,
    /// Signal class handler for the `gio.DBusObjectManagerClient.signals.interface`-proxy-properties-changed signal.
    f_interface_proxy_properties_changed: ?*const fn (p_manager: *gio.DBusObjectManagerClient, p_object_proxy: *gio.DBusObjectProxy, p_interface_proxy: *gio.DBusProxy, p_changed_properties: *glib.Variant, p_invalidated_properties: *const [*:0]const u8) callconv(.c) void,
    f_padding: [8]*anyopaque,

    pub fn as(p_instance: *DBusObjectManagerClientClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const DBusObjectManagerClientPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Base type for D-Bus object managers.
pub const DBusObjectManagerIface = extern struct {
    pub const Instance = gio.DBusObjectManager;

    /// The parent interface.
    f_parent_iface: gobject.TypeInterface,
    /// Virtual function for `gio.DBusObjectManager.getObjectPath`.
    f_get_object_path: ?*const fn (p_manager: *gio.DBusObjectManager) callconv(.c) [*:0]const u8,
    /// Virtual function for `gio.DBusObjectManager.getObjects`.
    f_get_objects: ?*const fn (p_manager: *gio.DBusObjectManager) callconv(.c) *glib.List,
    /// Virtual function for `gio.DBusObjectManager.getObject`.
    f_get_object: ?*const fn (p_manager: *gio.DBusObjectManager, p_object_path: [*:0]const u8) callconv(.c) ?*gio.DBusObject,
    /// Virtual function for `gio.DBusObjectManager.getInterface`.
    f_get_interface: ?*const fn (p_manager: *gio.DBusObjectManager, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8) callconv(.c) ?*gio.DBusInterface,
    /// Signal handler for the `gio.DBusObjectManager.signals.object`-added signal.
    f_object_added: ?*const fn (p_manager: *gio.DBusObjectManager, p_object: *gio.DBusObject) callconv(.c) void,
    /// Signal handler for the `gio.DBusObjectManager.signals.object`-removed signal.
    f_object_removed: ?*const fn (p_manager: *gio.DBusObjectManager, p_object: *gio.DBusObject) callconv(.c) void,
    /// Signal handler for the `gio.DBusObjectManager.signals.interface`-added signal.
    f_interface_added: ?*const fn (p_manager: *gio.DBusObjectManager, p_object: *gio.DBusObject, p_interface_: *gio.DBusInterface) callconv(.c) void,
    /// Signal handler for the `gio.DBusObjectManager.signals.interface`-removed signal.
    f_interface_removed: ?*const fn (p_manager: *gio.DBusObjectManager, p_object: *gio.DBusObject, p_interface_: *gio.DBusInterface) callconv(.c) void,

    pub fn as(p_instance: *DBusObjectManagerIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.DBusObjectManagerServer`.
pub const DBusObjectManagerServerClass = extern struct {
    pub const Instance = gio.DBusObjectManagerServer;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    f_padding: [8]*anyopaque,

    pub fn as(p_instance: *DBusObjectManagerServerClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const DBusObjectManagerServerPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.DBusObjectProxy`.
pub const DBusObjectProxyClass = extern struct {
    pub const Instance = gio.DBusObjectProxy;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    f_padding: [8]*anyopaque,

    pub fn as(p_instance: *DBusObjectProxyClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const DBusObjectProxyPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.DBusObjectSkeleton`.
pub const DBusObjectSkeletonClass = extern struct {
    pub const Instance = gio.DBusObjectSkeleton;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    /// Signal class handler for the `gio.DBusObjectSkeleton.signals.authorize`-method signal.
    f_authorize_method: ?*const fn (p_object: *gio.DBusObjectSkeleton, p_interface_: *gio.DBusInterfaceSkeleton, p_invocation: *gio.DBusMethodInvocation) callconv(.c) c_int,
    f_padding: [8]*anyopaque,

    pub fn as(p_instance: *DBusObjectSkeletonClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const DBusObjectSkeletonPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Information about a D-Bus property on a D-Bus interface.
pub const DBusPropertyInfo = extern struct {
    /// The reference count or -1 if statically allocated.
    f_ref_count: c_int,
    /// The name of the D-Bus property, e.g. "SupportedFilesystems".
    f_name: ?[*:0]u8,
    /// The D-Bus signature of the property (a single complete type).
    f_signature: ?[*:0]u8,
    /// Access control flags for the property.
    f_flags: gio.DBusPropertyInfoFlags,
    /// A pointer to a `NULL`-terminated array of pointers to `gio.DBusAnnotationInfo` structures or `NULL` if there are no annotations.
    f_annotations: ?[*]*gio.DBusAnnotationInfo,

    /// If `info` is statically allocated does nothing. Otherwise increases
    /// the reference count.
    extern fn g_dbus_property_info_ref(p_info: *DBusPropertyInfo) *gio.DBusPropertyInfo;
    pub const ref = g_dbus_property_info_ref;

    /// If `info` is statically allocated, does nothing. Otherwise decreases
    /// the reference count of `info`. When its reference count drops to 0,
    /// the memory used is freed.
    extern fn g_dbus_property_info_unref(p_info: *DBusPropertyInfo) void;
    pub const unref = g_dbus_property_info_unref;

    extern fn g_dbus_property_info_get_type() usize;
    pub const getGObjectType = g_dbus_property_info_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.DBusProxy`.
pub const DBusProxyClass = extern struct {
    pub const Instance = gio.DBusProxy;

    f_parent_class: gobject.ObjectClass,
    /// Signal class handler for the `gio.DBusProxy.signals.g`-properties-changed signal.
    f_g_properties_changed: ?*const fn (p_proxy: *gio.DBusProxy, p_changed_properties: *glib.Variant, p_invalidated_properties: *const [*:0]const u8) callconv(.c) void,
    /// Signal class handler for the `gio.DBusProxy.signals.g`-signal signal.
    f_g_signal: ?*const fn (p_proxy: *gio.DBusProxy, p_sender_name: [*:0]const u8, p_signal_name: [*:0]const u8, p_parameters: *glib.Variant) callconv(.c) void,
    f_padding: [32]*anyopaque,

    pub fn as(p_instance: *DBusProxyClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const DBusProxyPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Information about a signal on a D-Bus interface.
pub const DBusSignalInfo = extern struct {
    /// The reference count or -1 if statically allocated.
    f_ref_count: c_int,
    /// The name of the D-Bus signal, e.g. "NameOwnerChanged".
    f_name: ?[*:0]u8,
    /// A pointer to a `NULL`-terminated array of pointers to `gio.DBusArgInfo` structures or `NULL` if there are no arguments.
    f_args: ?[*]*gio.DBusArgInfo,
    /// A pointer to a `NULL`-terminated array of pointers to `gio.DBusAnnotationInfo` structures or `NULL` if there are no annotations.
    f_annotations: ?[*]*gio.DBusAnnotationInfo,

    /// If `info` is statically allocated does nothing. Otherwise increases
    /// the reference count.
    extern fn g_dbus_signal_info_ref(p_info: *DBusSignalInfo) *gio.DBusSignalInfo;
    pub const ref = g_dbus_signal_info_ref;

    /// If `info` is statically allocated, does nothing. Otherwise decreases
    /// the reference count of `info`. When its reference count drops to 0,
    /// the memory used is freed.
    extern fn g_dbus_signal_info_unref(p_info: *DBusSignalInfo) void;
    pub const unref = g_dbus_signal_info_unref;

    extern fn g_dbus_signal_info_get_type() usize;
    pub const getGObjectType = g_dbus_signal_info_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Virtual table for handling subtrees registered with `gio.DBusConnection.registerSubtree`.
pub const DBusSubtreeVTable = extern struct {
    /// Function for enumerating child nodes.
    f_enumerate: ?gio.DBusSubtreeEnumerateFunc,
    /// Function for introspecting a child node.
    f_introspect: ?gio.DBusSubtreeIntrospectFunc,
    /// Function for dispatching a remote call on a child node.
    f_dispatch: ?gio.DBusSubtreeDispatchFunc,
    f_padding: [8]*anyopaque,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const DataInputStreamClass = extern struct {
    pub const Instance = gio.DataInputStream;

    f_parent_class: gio.BufferedInputStreamClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *DataInputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const DataInputStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const DataOutputStreamClass = extern struct {
    pub const Instance = gio.DataOutputStream;

    f_parent_class: gio.FilterOutputStreamClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *DataOutputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const DataOutputStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Provides an interface for socket-like objects which have datagram semantics,
/// following the Berkeley sockets API. The interface methods are thin wrappers
/// around the corresponding virtual methods, and no pre-processing of inputs is
/// implemented — so implementations of this API must handle all functionality
/// documented in the interface methods.
pub const DatagramBasedInterface = extern struct {
    pub const Instance = gio.DatagramBased;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Virtual method for `gio.DatagramBased.receiveMessages`.
    f_receive_messages: ?*const fn (p_datagram_based: *gio.DatagramBased, p_messages: [*]gio.InputMessage, p_num_messages: c_uint, p_flags: c_int, p_timeout: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Virtual method for `gio.DatagramBased.sendMessages`.
    f_send_messages: ?*const fn (p_datagram_based: *gio.DatagramBased, p_messages: [*]gio.OutputMessage, p_num_messages: c_uint, p_flags: c_int, p_timeout: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Virtual method for `gio.DatagramBased.createSource`.
    f_create_source: ?*const fn (p_datagram_based: *gio.DatagramBased, p_condition: glib.IOCondition, p_cancellable: ?*gio.Cancellable) callconv(.c) *glib.Source,
    /// Virtual method for `gio.DatagramBased.conditionCheck`.
    f_condition_check: ?*const fn (p_datagram_based: *gio.DatagramBased, p_condition: glib.IOCondition) callconv(.c) glib.IOCondition,
    /// Virtual method for
    ///   `gio.DatagramBased.conditionWait`.
    f_condition_wait: ?*const fn (p_datagram_based: *gio.DatagramBased, p_condition: glib.IOCondition, p_timeout: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,

    pub fn as(p_instance: *DatagramBasedInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The virtual function table for `gio.DebugControllerDBus`.
pub const DebugControllerDBusClass = extern struct {
    pub const Instance = gio.DebugControllerDBus;

    /// The parent class.
    f_parent_class: gobject.ObjectClass,
    /// Default handler for the `gio.DebugControllerDBus.signals.authorize` signal.
    f_authorize: ?*const fn (p_controller: *gio.DebugControllerDBus, p_invocation: *gio.DBusMethodInvocation) callconv(.c) c_int,
    f_padding: [12]*anyopaque,

    pub fn as(p_instance: *DebugControllerDBusClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The virtual function table for `gio.DebugController`.
pub const DebugControllerInterface = extern struct {
    pub const Instance = gio.DebugController;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,

    pub fn as(p_instance: *DebugControllerInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const DesktopAppInfoClass = extern struct {
    pub const Instance = gio.DesktopAppInfo;

    f_parent_class: gobject.ObjectClass,

    pub fn as(p_instance: *DesktopAppInfoClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Interface that is used by backends to associate default
/// handlers with URI schemes.
pub const DesktopAppInfoLookupIface = extern struct {
    pub const Instance = gio.DesktopAppInfoLookup;

    f_g_iface: gobject.TypeInterface,
    /// Virtual method for
    ///  `gio.DesktopAppInfoLookup.getDefaultForUriScheme`.
    f_get_default_for_uri_scheme: ?*const fn (p_lookup: *gio.DesktopAppInfoLookup, p_uri_scheme: [*:0]const u8) callconv(.c) ?*gio.AppInfo,

    pub fn as(p_instance: *DesktopAppInfoLookupIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Interface for creating `gio.Drive` implementations.
pub const DriveIface = extern struct {
    pub const Instance = gio.Drive;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Signal emitted when the drive is changed.
    f_changed: ?*const fn (p_drive: *gio.Drive) callconv(.c) void,
    /// The removed signal that is emitted when the `gio.Drive` have been disconnected. If the recipient is holding references to the object they should release them so the object can be finalized.
    f_disconnected: ?*const fn (p_drive: *gio.Drive) callconv(.c) void,
    /// Signal emitted when the physical eject button (if any) of a drive have been pressed.
    f_eject_button: ?*const fn (p_drive: *gio.Drive) callconv(.c) void,
    /// Returns the name for the given `gio.Drive`.
    f_get_name: ?*const fn (p_drive: *gio.Drive) callconv(.c) [*:0]u8,
    /// Returns a `gio.Icon` for the given `gio.Drive`.
    f_get_icon: ?*const fn (p_drive: *gio.Drive) callconv(.c) *gio.Icon,
    /// Returns `TRUE` if the `gio.Drive` has mountable volumes.
    f_has_volumes: ?*const fn (p_drive: *gio.Drive) callconv(.c) c_int,
    /// Returns a list `glib.List` of `gio.Volume` for the `gio.Drive`.
    f_get_volumes: ?*const fn (p_drive: *gio.Drive) callconv(.c) *glib.List,
    /// Returns `TRUE` if the `gio.Drive` supports removal and insertion of media.
    f_is_media_removable: ?*const fn (p_drive: *gio.Drive) callconv(.c) c_int,
    /// Returns `TRUE` if the `gio.Drive` has media inserted.
    f_has_media: ?*const fn (p_drive: *gio.Drive) callconv(.c) c_int,
    /// Returns `TRUE` if the `gio.Drive` is capable of automatically detecting media changes.
    f_is_media_check_automatic: ?*const fn (p_drive: *gio.Drive) callconv(.c) c_int,
    /// Returns `TRUE` if the `gio.Drive` can eject media.
    f_can_eject: ?*const fn (p_drive: *gio.Drive) callconv(.c) c_int,
    /// Returns `TRUE` if the `gio.Drive` is capable of manually polling for media change.
    f_can_poll_for_media: ?*const fn (p_drive: *gio.Drive) callconv(.c) c_int,
    /// Ejects a `gio.Drive`.
    f_eject: ?*const fn (p_drive: *gio.Drive, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an eject operation.
    f_eject_finish: ?*const fn (p_drive: *gio.Drive, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Poll for media insertion/removal on a `gio.Drive`.
    f_poll_for_media: ?*const fn (p_drive: *gio.Drive, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes a media poll operation.
    f_poll_for_media_finish: ?*const fn (p_drive: *gio.Drive, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Returns the identifier of the given kind, or `NULL` if
    ///    the `gio.Drive` doesn't have one.
    f_get_identifier: ?*const fn (p_drive: *gio.Drive, p_kind: [*:0]const u8) callconv(.c) ?[*:0]u8,
    /// Returns an array strings listing the kinds
    ///    of identifiers which the `gio.Drive` has.
    f_enumerate_identifiers: ?*const fn (p_drive: *gio.Drive) callconv(.c) [*][*:0]u8,
    /// Gets a `gio.DriveStartStopType` with details about starting/stopping the drive. Since 2.22.
    f_get_start_stop_type: ?*const fn (p_drive: *gio.Drive) callconv(.c) gio.DriveStartStopType,
    /// Returns `TRUE` if a `gio.Drive` can be started. Since 2.22.
    f_can_start: ?*const fn (p_drive: *gio.Drive) callconv(.c) c_int,
    /// Returns `TRUE` if a `gio.Drive` can be started degraded. Since 2.22.
    f_can_start_degraded: ?*const fn (p_drive: *gio.Drive) callconv(.c) c_int,
    /// Starts a `gio.Drive`. Since 2.22.
    f_start: ?*const fn (p_drive: *gio.Drive, p_flags: gio.DriveStartFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes a start operation. Since 2.22.
    f_start_finish: ?*const fn (p_drive: *gio.Drive, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Returns `TRUE` if a `gio.Drive` can be stopped. Since 2.22.
    f_can_stop: ?*const fn (p_drive: *gio.Drive) callconv(.c) c_int,
    /// Stops a `gio.Drive`. Since 2.22.
    f_stop: ?*const fn (p_drive: *gio.Drive, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes a stop operation. Since 2.22.
    f_stop_finish: ?*const fn (p_drive: *gio.Drive, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Signal emitted when the physical stop button (if any) of a drive have been pressed. Since 2.22.
    f_stop_button: ?*const fn (p_drive: *gio.Drive) callconv(.c) void,
    /// Starts ejecting a `gio.Drive` using a `gio.MountOperation`. Since 2.22.
    f_eject_with_operation: ?*const fn (p_drive: *gio.Drive, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an eject operation using a `gio.MountOperation`. Since 2.22.
    f_eject_with_operation_finish: ?*const fn (p_drive: *gio.Drive, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Gets a key used for sorting `gio.Drive` instances or `NULL` if no such key exists. Since 2.32.
    f_get_sort_key: ?*const fn (p_drive: *gio.Drive) callconv(.c) ?[*:0]const u8,
    /// Returns a symbolic `gio.Icon` for the given `gio.Drive`. Since 2.34.
    f_get_symbolic_icon: ?*const fn (p_drive: *gio.Drive) callconv(.c) *gio.Icon,
    /// Returns `TRUE` if the `gio.Drive` and/or its media is considered removable by the user. Since 2.50.
    f_is_removable: ?*const fn (p_drive: *gio.Drive) callconv(.c) c_int,

    pub fn as(p_instance: *DriveIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// vtable for a `gio.DtlsClientConnection` implementation.
pub const DtlsClientConnectionInterface = extern struct {
    pub const Instance = gio.DtlsClientConnection;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,

    pub fn as(p_instance: *DtlsClientConnectionInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Virtual method table for a `gio.DtlsConnection` implementation.
pub const DtlsConnectionInterface = extern struct {
    pub const Instance = gio.DtlsConnection;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Check whether to accept a certificate.
    f_accept_certificate: ?*const fn (p_connection: *gio.DtlsConnection, p_peer_cert: *gio.TlsCertificate, p_errors: gio.TlsCertificateFlags) callconv(.c) c_int,
    /// Perform a handshake operation.
    f_handshake: ?*const fn (p_conn: *gio.DtlsConnection, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Start an asynchronous handshake operation.
    f_handshake_async: ?*const fn (p_conn: *gio.DtlsConnection, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finish an asynchronous handshake operation.
    f_handshake_finish: ?*const fn (p_conn: *gio.DtlsConnection, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Shut down one or both directions of the connection.
    f_shutdown: ?*const fn (p_conn: *gio.DtlsConnection, p_shutdown_read: c_int, p_shutdown_write: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Start an asynchronous shutdown operation.
    f_shutdown_async: ?*const fn (p_conn: *gio.DtlsConnection, p_shutdown_read: c_int, p_shutdown_write: c_int, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finish an asynchronous shutdown operation.
    f_shutdown_finish: ?*const fn (p_conn: *gio.DtlsConnection, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Set APLN protocol list (Since: 2.60)
    f_set_advertised_protocols: ?*const fn (p_conn: *gio.DtlsConnection, p_protocols: ?[*]const [*:0]const u8) callconv(.c) void,
    /// Get ALPN-negotiated protocol (Since: 2.60)
    f_get_negotiated_protocol: ?*const fn (p_conn: *gio.DtlsConnection) callconv(.c) ?[*:0]const u8,
    /// Retrieve TLS channel binding data (Since: 2.66)
    f_get_binding_data: ?*const fn (p_conn: *gio.DtlsConnection, p_type: gio.TlsChannelBindingType, p_data: *glib.ByteArray, p_error: ?*?*glib.Error) callconv(.c) c_int,

    pub fn as(p_instance: *DtlsConnectionInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// vtable for a `gio.DtlsServerConnection` implementation.
pub const DtlsServerConnectionInterface = extern struct {
    pub const Instance = gio.DtlsServerConnection;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,

    pub fn as(p_instance: *DtlsServerConnectionInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EmblemClass = opaque {
    pub const Instance = gio.Emblem;

    pub fn as(p_instance: *EmblemClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EmblemedIconClass = extern struct {
    pub const Instance = gio.EmblemedIcon;

    f_parent_class: gobject.ObjectClass,

    pub fn as(p_instance: *EmblemedIconClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const EmblemedIconPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Information about a specific attribute.
pub const FileAttributeInfo = extern struct {
    /// the name of the attribute.
    f_name: ?[*:0]u8,
    /// the `gio.FileAttributeType` type of the attribute.
    f_type: gio.FileAttributeType,
    /// a set of `gio.FileAttributeInfoFlags`.
    f_flags: gio.FileAttributeInfoFlags,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Acts as a lightweight registry for possible valid file attributes.
/// The registry stores Key-Value pair formats as `GFileAttributeInfos`.
pub const FileAttributeInfoList = extern struct {
    /// an array of `GFileAttributeInfos`.
    f_infos: ?*gio.FileAttributeInfo,
    /// the number of values in the array.
    f_n_infos: c_int,

    /// Creates a new file attribute info list.
    extern fn g_file_attribute_info_list_new() *gio.FileAttributeInfoList;
    pub const new = g_file_attribute_info_list_new;

    /// Adds a new attribute with `name` to the `list`, setting
    /// its `type` and `flags`.
    extern fn g_file_attribute_info_list_add(p_list: *FileAttributeInfoList, p_name: [*:0]const u8, p_type: gio.FileAttributeType, p_flags: gio.FileAttributeInfoFlags) void;
    pub const add = g_file_attribute_info_list_add;

    /// Makes a duplicate of a file attribute info list.
    extern fn g_file_attribute_info_list_dup(p_list: *FileAttributeInfoList) *gio.FileAttributeInfoList;
    pub const dup = g_file_attribute_info_list_dup;

    /// Gets the file attribute with the name `name` from `list`.
    extern fn g_file_attribute_info_list_lookup(p_list: *FileAttributeInfoList, p_name: [*:0]const u8) *const gio.FileAttributeInfo;
    pub const lookup = g_file_attribute_info_list_lookup;

    /// References a file attribute info list.
    extern fn g_file_attribute_info_list_ref(p_list: *FileAttributeInfoList) *gio.FileAttributeInfoList;
    pub const ref = g_file_attribute_info_list_ref;

    /// Removes a reference from the given `list`. If the reference count
    /// falls to zero, the `list` is deleted.
    extern fn g_file_attribute_info_list_unref(p_list: *FileAttributeInfoList) void;
    pub const unref = g_file_attribute_info_list_unref;

    extern fn g_file_attribute_info_list_get_type() usize;
    pub const getGObjectType = g_file_attribute_info_list_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Determines if a string matches a file attribute.
pub const FileAttributeMatcher = opaque {
    /// Creates a new file attribute matcher, which matches attributes
    /// against a given string. `GFileAttributeMatchers` are reference
    /// counted structures, and are created with a reference count of 1. If
    /// the number of references falls to 0, the `gio.FileAttributeMatcher` is
    /// automatically destroyed.
    ///
    /// The `attributes` string should be formatted with specific keys separated
    /// from namespaces with a double colon. Several "namespace::key" strings may be
    /// concatenated with a single comma (e.g. "standard::type,standard::is-hidden").
    /// The wildcard "*" may be used to match all keys and namespaces, or
    /// "namespace::*" will match all keys in a given namespace.
    ///
    /// ## Examples of file attribute matcher strings and results
    ///
    /// - `"*"`: matches all attributes.
    /// - `"standard::is-hidden"`: matches only the key is-hidden in the
    ///   standard namespace.
    /// - `"standard::type,unix::*"`: matches the type key in the standard
    ///   namespace and all keys in the unix namespace.
    extern fn g_file_attribute_matcher_new(p_attributes: [*:0]const u8) *gio.FileAttributeMatcher;
    pub const new = g_file_attribute_matcher_new;

    /// Checks if the matcher will match all of the keys in a given namespace.
    /// This will always return `TRUE` if a wildcard character is in use (e.g. if
    /// matcher was created with "standard::*" and `ns` is "standard", or if matcher was created
    /// using "*" and namespace is anything.)
    ///
    /// TODO: this is awkwardly worded.
    extern fn g_file_attribute_matcher_enumerate_namespace(p_matcher: *FileAttributeMatcher, p_ns: [*:0]const u8) c_int;
    pub const enumerateNamespace = g_file_attribute_matcher_enumerate_namespace;

    /// Gets the next matched attribute from a `gio.FileAttributeMatcher`.
    extern fn g_file_attribute_matcher_enumerate_next(p_matcher: *FileAttributeMatcher) ?[*:0]const u8;
    pub const enumerateNext = g_file_attribute_matcher_enumerate_next;

    /// Checks if an attribute will be matched by an attribute matcher. If
    /// the matcher was created with the "*" matching string, this function
    /// will always return `TRUE`.
    extern fn g_file_attribute_matcher_matches(p_matcher: *FileAttributeMatcher, p_attribute: [*:0]const u8) c_int;
    pub const matches = g_file_attribute_matcher_matches;

    /// Checks if an attribute matcher only matches a given attribute. Always
    /// returns `FALSE` if "*" was used when creating the matcher.
    extern fn g_file_attribute_matcher_matches_only(p_matcher: *FileAttributeMatcher, p_attribute: [*:0]const u8) c_int;
    pub const matchesOnly = g_file_attribute_matcher_matches_only;

    /// References a file attribute matcher.
    extern fn g_file_attribute_matcher_ref(p_matcher: *FileAttributeMatcher) *gio.FileAttributeMatcher;
    pub const ref = g_file_attribute_matcher_ref;

    /// Subtracts all attributes of `subtract` from `matcher` and returns
    /// a matcher that supports those attributes.
    ///
    /// Note that currently it is not possible to remove a single
    /// attribute when the `matcher` matches the whole namespace - or remove
    /// a namespace or attribute when the matcher matches everything. This
    /// is a limitation of the current implementation, but may be fixed
    /// in the future.
    extern fn g_file_attribute_matcher_subtract(p_matcher: ?*FileAttributeMatcher, p_subtract: ?*gio.FileAttributeMatcher) ?*gio.FileAttributeMatcher;
    pub const subtract = g_file_attribute_matcher_subtract;

    /// Prints what the matcher is matching against. The format will be
    /// equal to the format passed to `gio.FileAttributeMatcher.new`.
    /// The output however, might not be identical, as the matcher may
    /// decide to use a different order or omit needless parts.
    extern fn g_file_attribute_matcher_to_string(p_matcher: ?*FileAttributeMatcher) [*:0]u8;
    pub const toString = g_file_attribute_matcher_to_string;

    /// Unreferences `matcher`. If the reference count falls below 1,
    /// the `matcher` is automatically freed.
    extern fn g_file_attribute_matcher_unref(p_matcher: *FileAttributeMatcher) void;
    pub const unref = g_file_attribute_matcher_unref;

    extern fn g_file_attribute_matcher_get_type() usize;
    pub const getGObjectType = g_file_attribute_matcher_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// An interface for file descriptor based io objects.
pub const FileDescriptorBasedIface = extern struct {
    pub const Instance = gio.FileDescriptorBased;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Gets the underlying file descriptor.
    f_get_fd: ?*const fn (p_fd_based: *gio.FileDescriptorBased) callconv(.c) c_int,

    pub fn as(p_instance: *FileDescriptorBasedIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileEnumeratorClass = extern struct {
    pub const Instance = gio.FileEnumerator;

    f_parent_class: gobject.ObjectClass,
    f_next_file: ?*const fn (p_enumerator: *gio.FileEnumerator, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo,
    f_close_fn: ?*const fn (p_enumerator: *gio.FileEnumerator, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_next_files_async: ?*const fn (p_enumerator: *gio.FileEnumerator, p_num_files: c_int, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_next_files_finish: ?*const fn (p_enumerator: *gio.FileEnumerator, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List,
    f_close_async: ?*const fn (p_enumerator: *gio.FileEnumerator, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_close_finish: ?*const fn (p_enumerator: *gio.FileEnumerator, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,
    f__g_reserved6: ?*const fn () callconv(.c) void,
    f__g_reserved7: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FileEnumeratorClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileEnumeratorPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileIOStreamClass = extern struct {
    pub const Instance = gio.FileIOStream;

    f_parent_class: gio.IOStreamClass,
    f_tell: ?*const fn (p_stream: *gio.FileIOStream) callconv(.c) i64,
    f_can_seek: ?*const fn (p_stream: *gio.FileIOStream) callconv(.c) c_int,
    f_seek: ?*const fn (p_stream: *gio.FileIOStream, p_offset: i64, p_type: glib.SeekType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_can_truncate: ?*const fn (p_stream: *gio.FileIOStream) callconv(.c) c_int,
    f_truncate_fn: ?*const fn (p_stream: *gio.FileIOStream, p_size: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_query_info: ?*const fn (p_stream: *gio.FileIOStream, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo,
    f_query_info_async: ?*const fn (p_stream: *gio.FileIOStream, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_query_info_finish: ?*const fn (p_stream: *gio.FileIOStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo,
    f_get_etag: ?*const fn (p_stream: *gio.FileIOStream) callconv(.c) ?[*:0]u8,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FileIOStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileIOStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileIconClass = opaque {
    pub const Instance = gio.FileIcon;

    pub fn as(p_instance: *FileIconClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// An interface for writing VFS file handles.
pub const FileIface = extern struct {
    pub const Instance = gio.File;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Duplicates a `gio.File`.
    f_dup: ?*const fn (p_file: *gio.File) callconv(.c) *gio.File,
    /// Creates a hash of a `gio.File`.
    f_hash: ?*const fn (p_file: *gio.File) callconv(.c) c_uint,
    /// Checks equality of two given `GFiles`.
    f_equal: ?*const fn (p_file1: *gio.File, p_file2: *gio.File) callconv(.c) c_int,
    /// Checks to see if a file is native to the system.
    f_is_native: ?*const fn (p_file: *gio.File) callconv(.c) c_int,
    /// Checks to see if a `gio.File` has a given URI scheme.
    f_has_uri_scheme: ?*const fn (p_file: *gio.File, p_uri_scheme: [*:0]const u8) callconv(.c) c_int,
    /// Gets the URI scheme for a `gio.File`.
    f_get_uri_scheme: ?*const fn (p_file: *gio.File) callconv(.c) ?[*:0]u8,
    /// Gets the basename for a given `gio.File`.
    f_get_basename: ?*const fn (p_file: *gio.File) callconv(.c) ?[*:0]u8,
    /// Gets the current path within a `gio.File`.
    f_get_path: ?*const fn (p_file: *gio.File) callconv(.c) ?[*:0]u8,
    /// Gets a URI for the path within a `gio.File`.
    f_get_uri: ?*const fn (p_file: *gio.File) callconv(.c) [*:0]u8,
    /// Gets the parsed name for the `gio.File`.
    f_get_parse_name: ?*const fn (p_file: *gio.File) callconv(.c) [*:0]u8,
    /// Gets the parent directory for the `gio.File`.
    f_get_parent: ?*const fn (p_file: *gio.File) callconv(.c) ?*gio.File,
    /// Checks whether a `gio.File` contains a specified file.
    f_prefix_matches: ?*const fn (p_prefix: *gio.File, p_file: *gio.File) callconv(.c) c_int,
    /// Gets the path for a `gio.File` relative to a given path.
    f_get_relative_path: ?*const fn (p_parent: *gio.File, p_descendant: *gio.File) callconv(.c) ?[*:0]u8,
    /// Resolves a relative path for a `gio.File` to an absolute path.
    f_resolve_relative_path: ?*const fn (p_file: *gio.File, p_relative_path: [*:0]const u8) callconv(.c) *gio.File,
    /// Gets the child `gio.File` for a given display name.
    f_get_child_for_display_name: ?*const fn (p_file: *gio.File, p_display_name: [*:0]const u8, p_error: ?*?*glib.Error) callconv(.c) ?*gio.File,
    /// Gets a `gio.FileEnumerator` with the children of a `gio.File`.
    f_enumerate_children: ?*const fn (p_file: *gio.File, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileEnumerator,
    /// Asynchronously gets a `gio.FileEnumerator` with the children of a `gio.File`.
    f_enumerate_children_async: ?*const fn (p_file: *gio.File, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes asynchronously enumerating the children.
    f_enumerate_children_finish: ?*const fn (p_file: *gio.File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileEnumerator,
    /// Gets the `gio.FileInfo` for a `gio.File`.
    f_query_info: ?*const fn (p_file: *gio.File, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo,
    /// Asynchronously gets the `gio.FileInfo` for a `gio.File`.
    f_query_info_async: ?*const fn (p_file: *gio.File, p_attributes: [*:0]const u8, p_flags: gio.FileQueryInfoFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an asynchronous query info operation.
    f_query_info_finish: ?*const fn (p_file: *gio.File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo,
    /// Gets a `gio.FileInfo` for the file system `gio.File` is on.
    f_query_filesystem_info: ?*const fn (p_file: *gio.File, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo,
    /// Asynchronously gets a `gio.FileInfo` for the file system `gio.File` is on.
    f_query_filesystem_info_async: ?*const fn (p_file: *gio.File, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes asynchronously getting the file system info.
    f_query_filesystem_info_finish: ?*const fn (p_file: *gio.File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo,
    /// Gets a `gio.Mount` for the `gio.File`.
    f_find_enclosing_mount: ?*const fn (p_file: *gio.File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.Mount,
    /// Asynchronously gets the `gio.Mount` for a `gio.File`.
    f_find_enclosing_mount_async: ?*const fn (p_file: *gio.File, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes asynchronously getting the volume.
    f_find_enclosing_mount_finish: ?*const fn (p_file: *gio.File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.Mount,
    /// Sets the display name for a `gio.File`.
    f_set_display_name: ?*const fn (p_file: *gio.File, p_display_name: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.File,
    /// Asynchronously sets a `gio.File`'s display name.
    f_set_display_name_async: ?*const fn (p_file: *gio.File, p_display_name: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes asynchronously setting a `gio.File`'s display name.
    f_set_display_name_finish: ?*const fn (p_file: *gio.File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.File,
    /// Returns a list of `GFileAttributeInfos` that can be set.
    f_query_settable_attributes: ?*const fn (p_file: *gio.File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileAttributeInfoList,
    /// Asynchronously gets a list of `GFileAttributeInfos` that can be set.
    f__query_settable_attributes_async: ?*const fn () callconv(.c) void,
    /// Finishes asynchronously querying settable attributes.
    f__query_settable_attributes_finish: ?*const fn () callconv(.c) void,
    /// Returns a list of `gio.FileAttributeInfo` namespaces that are writable.
    f_query_writable_namespaces: ?*const fn (p_file: *gio.File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileAttributeInfoList,
    /// Asynchronously gets a list of `gio.FileAttributeInfo` namespaces that are writable.
    f__query_writable_namespaces_async: ?*const fn () callconv(.c) void,
    /// Finishes asynchronously querying the writable namespaces.
    f__query_writable_namespaces_finish: ?*const fn () callconv(.c) void,
    /// Sets a `gio.FileAttributeInfo`.
    f_set_attribute: ?*const fn (p_file: *gio.File, p_attribute: [*:0]const u8, p_type: gio.FileAttributeType, p_value_p: ?*anyopaque, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Sets a `gio.FileAttributeInfo` with information from a `gio.FileInfo`.
    f_set_attributes_from_info: ?*const fn (p_file: *gio.File, p_info: *gio.FileInfo, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Asynchronously sets a file's attributes.
    f_set_attributes_async: ?*const fn (p_file: *gio.File, p_info: *gio.FileInfo, p_flags: gio.FileQueryInfoFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes setting a file's attributes asynchronously.
    f_set_attributes_finish: ?*const fn (p_file: *gio.File, p_result: *gio.AsyncResult, p_info: **gio.FileInfo, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Reads a file asynchronously.
    f_read_fn: ?*const fn (p_file: *gio.File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInputStream,
    /// Asynchronously reads a file.
    f_read_async: ?*const fn (p_file: *gio.File, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes asynchronously reading a file.
    f_read_finish: ?*const fn (p_file: *gio.File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInputStream,
    /// Writes to the end of a file.
    f_append_to: ?*const fn (p_file: *gio.File, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileOutputStream,
    /// Asynchronously writes to the end of a file.
    f_append_to_async: ?*const fn (p_file: *gio.File, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an asynchronous file append operation.
    f_append_to_finish: ?*const fn (p_file: *gio.File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileOutputStream,
    /// Creates a new file.
    f_create: ?*const fn (p_file: *gio.File, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileOutputStream,
    /// Asynchronously creates a file.
    f_create_async: ?*const fn (p_file: *gio.File, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes asynchronously creating a file.
    f_create_finish: ?*const fn (p_file: *gio.File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileOutputStream,
    /// Replaces the contents of a file.
    f_replace: ?*const fn (p_file: *gio.File, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileOutputStream,
    /// Asynchronously replaces the contents of a file.
    f_replace_async: ?*const fn (p_file: *gio.File, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes asynchronously replacing a file.
    f_replace_finish: ?*const fn (p_file: *gio.File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileOutputStream,
    /// Deletes a file.
    f_delete_file: ?*const fn (p_file: *gio.File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Asynchronously deletes a file.
    f_delete_file_async: ?*const fn (p_file: *gio.File, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an asynchronous delete.
    f_delete_file_finish: ?*const fn (p_file: *gio.File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Sends a `gio.File` to the Trash location.
    f_trash: ?*const fn (p_file: *gio.File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Asynchronously sends a `gio.File` to the Trash location.
    f_trash_async: ?*const fn (p_file: *gio.File, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an asynchronous file trashing operation.
    f_trash_finish: ?*const fn (p_file: *gio.File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Makes a directory.
    f_make_directory: ?*const fn (p_file: *gio.File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Asynchronously makes a directory.
    f_make_directory_async: ?*const fn (p_file: *gio.File, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes making a directory asynchronously.
    f_make_directory_finish: ?*const fn (p_file: *gio.File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Makes a symbolic link. `NULL` if symbolic
    ///    links are unsupported.
    f_make_symbolic_link: ?*const fn (p_file: *gio.File, p_symlink_value: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Asynchronously makes a symbolic link
    f_make_symbolic_link_async: ?*const fn (p_file: *gio.File, p_symlink_value: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes making a symbolic link asynchronously.
    f_make_symbolic_link_finish: ?*const fn (p_file: *gio.File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Copies a file. `NULL` if copying is unsupported, which will
    ///     cause `GFile` to use a fallback copy method where it reads from the
    ///     source and writes to the destination.
    f_copy: ?*const fn (p_source: *gio.File, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Asynchronously copies a file.
    f_copy_async: ?*const fn (p_source: *gio.File, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an asynchronous copy operation.
    f_copy_finish: ?*const fn (p_file: *gio.File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Moves a file.
    f_move: ?*const fn (p_source: *gio.File, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Asynchronously moves a file. Since: 2.72
    f_move_async: ?*const fn (p_source: *gio.File, p_destination: *gio.File, p_flags: gio.FileCopyFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileProgressCallback, p_progress_callback_data: ?*anyopaque, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an asynchronous move operation. Since: 2.72
    f_move_finish: ?*const fn (p_file: *gio.File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Mounts a mountable object.
    f_mount_mountable: ?*const fn (p_file: *gio.File, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes a mounting operation.
    f_mount_mountable_finish: ?*const fn (p_file: *gio.File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.File,
    /// Unmounts a mountable object.
    f_unmount_mountable: ?*const fn (p_file: *gio.File, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an unmount operation.
    f_unmount_mountable_finish: ?*const fn (p_file: *gio.File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Ejects a mountable.
    f_eject_mountable: ?*const fn (p_file: *gio.File, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an eject operation.
    f_eject_mountable_finish: ?*const fn (p_file: *gio.File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Mounts a specified location.
    f_mount_enclosing_volume: ?*const fn (p_location: *gio.File, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes mounting a specified location.
    f_mount_enclosing_volume_finish: ?*const fn (p_location: *gio.File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Creates a `gio.FileMonitor` for the location.
    f_monitor_dir: ?*const fn (p_file: *gio.File, p_flags: gio.FileMonitorFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileMonitor,
    /// Creates a `gio.FileMonitor` for the location.
    f_monitor_file: ?*const fn (p_file: *gio.File, p_flags: gio.FileMonitorFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileMonitor,
    /// Open file read/write. Since 2.22.
    f_open_readwrite: ?*const fn (p_file: *gio.File, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileIOStream,
    /// Asynchronously opens file read/write. Since 2.22.
    f_open_readwrite_async: ?*const fn (p_file: *gio.File, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an asynchronous open read/write. Since 2.22.
    f_open_readwrite_finish: ?*const fn (p_file: *gio.File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileIOStream,
    /// Creates file read/write. Since 2.22.
    f_create_readwrite: ?*const fn (p_file: *gio.File, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileIOStream,
    /// Asynchronously creates file read/write. Since 2.22.
    f_create_readwrite_async: ?*const fn (p_file: *gio.File, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an asynchronous creates read/write. Since 2.22.
    f_create_readwrite_finish: ?*const fn (p_file: *gio.File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileIOStream,
    /// Replaces file read/write. Since 2.22.
    f_replace_readwrite: ?*const fn (p_file: *gio.File, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileIOStream,
    /// Asynchronously replaces file read/write. Since 2.22.
    f_replace_readwrite_async: ?*const fn (p_file: *gio.File, p_etag: ?[*:0]const u8, p_make_backup: c_int, p_flags: gio.FileCreateFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an asynchronous replace read/write. Since 2.22.
    f_replace_readwrite_finish: ?*const fn (p_file: *gio.File, p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileIOStream,
    /// Starts a mountable object. Since 2.22.
    f_start_mountable: ?*const fn (p_file: *gio.File, p_flags: gio.DriveStartFlags, p_start_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes a start operation. Since 2.22.
    f_start_mountable_finish: ?*const fn (p_file: *gio.File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Stops a mountable. Since 2.22.
    f_stop_mountable: ?*const fn (p_file: *gio.File, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes a stop operation. Since 2.22.
    f_stop_mountable_finish: ?*const fn (p_file: *gio.File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// a boolean that indicates whether the `gio.File` implementation supports thread-default contexts. Since 2.22.
    f_supports_thread_contexts: c_int,
    /// Unmounts a mountable object using a `gio.MountOperation`. Since 2.22.
    f_unmount_mountable_with_operation: ?*const fn (p_file: *gio.File, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an unmount operation using a `gio.MountOperation`. Since 2.22.
    f_unmount_mountable_with_operation_finish: ?*const fn (p_file: *gio.File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Ejects a mountable object using a `gio.MountOperation`. Since 2.22.
    f_eject_mountable_with_operation: ?*const fn (p_file: *gio.File, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an eject operation using a `gio.MountOperation`. Since 2.22.
    f_eject_mountable_with_operation_finish: ?*const fn (p_file: *gio.File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Polls a mountable object for media changes. Since 2.22.
    f_poll_mountable: ?*const fn (p_file: *gio.File, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes a poll operation for media changes. Since 2.22.
    f_poll_mountable_finish: ?*const fn (p_file: *gio.File, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Recursively measures the disk usage of `file`. Since 2.38
    f_measure_disk_usage: ?*const fn (p_file: *gio.File, p_flags: gio.FileMeasureFlags, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileMeasureProgressCallback, p_progress_data: ?*anyopaque, p_disk_usage: ?*u64, p_num_dirs: ?*u64, p_num_files: ?*u64, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Asynchronously recursively measures the disk usage of `file`. Since 2.38
    f_measure_disk_usage_async: ?*const fn (p_file: *gio.File, p_flags: gio.FileMeasureFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_progress_callback: ?gio.FileMeasureProgressCallback, p_progress_data: ?*anyopaque, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an asynchronous recursive measurement of the disk usage of `file`. Since 2.38
    f_measure_disk_usage_finish: ?*const fn (p_file: *gio.File, p_result: *gio.AsyncResult, p_disk_usage: ?*u64, p_num_dirs: ?*u64, p_num_files: ?*u64, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Queries whether a file exists. Since 2.84
    f_query_exists: ?*const fn (p_file: *gio.File, p_cancellable: ?*gio.Cancellable) callconv(.c) c_int,

    pub fn as(p_instance: *FileIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileInfoClass = opaque {
    pub const Instance = gio.FileInfo;

    pub fn as(p_instance: *FileInfoClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileInputStreamClass = extern struct {
    pub const Instance = gio.FileInputStream;

    f_parent_class: gio.InputStreamClass,
    f_tell: ?*const fn (p_stream: *gio.FileInputStream) callconv(.c) i64,
    f_can_seek: ?*const fn (p_stream: *gio.FileInputStream) callconv(.c) c_int,
    f_seek: ?*const fn (p_stream: *gio.FileInputStream, p_offset: i64, p_type: glib.SeekType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_query_info: ?*const fn (p_stream: *gio.FileInputStream, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo,
    f_query_info_async: ?*const fn (p_stream: *gio.FileInputStream, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_query_info_finish: ?*const fn (p_stream: *gio.FileInputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FileInputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileInputStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileMonitorClass = extern struct {
    pub const Instance = gio.FileMonitor;

    f_parent_class: gobject.ObjectClass,
    f_changed: ?*const fn (p_monitor: *gio.FileMonitor, p_file: *gio.File, p_other_file: *gio.File, p_event_type: gio.FileMonitorEvent) callconv(.c) void,
    f_cancel: ?*const fn (p_monitor: *gio.FileMonitor) callconv(.c) c_int,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FileMonitorClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileMonitorPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileOutputStreamClass = extern struct {
    pub const Instance = gio.FileOutputStream;

    f_parent_class: gio.OutputStreamClass,
    f_tell: ?*const fn (p_stream: *gio.FileOutputStream) callconv(.c) i64,
    f_can_seek: ?*const fn (p_stream: *gio.FileOutputStream) callconv(.c) c_int,
    f_seek: ?*const fn (p_stream: *gio.FileOutputStream, p_offset: i64, p_type: glib.SeekType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_can_truncate: ?*const fn (p_stream: *gio.FileOutputStream) callconv(.c) c_int,
    f_truncate_fn: ?*const fn (p_stream: *gio.FileOutputStream, p_size: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_query_info: ?*const fn (p_stream: *gio.FileOutputStream, p_attributes: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo,
    f_query_info_async: ?*const fn (p_stream: *gio.FileOutputStream, p_attributes: [*:0]const u8, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_query_info_finish: ?*const fn (p_stream: *gio.FileOutputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.FileInfo,
    f_get_etag: ?*const fn (p_stream: *gio.FileOutputStream) callconv(.c) ?[*:0]u8,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FileOutputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FileOutputStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FilenameCompleterClass = extern struct {
    pub const Instance = gio.FilenameCompleter;

    f_parent_class: gobject.ObjectClass,
    f_got_completion_data: ?*const fn (p_filename_completer: *gio.FilenameCompleter) callconv(.c) void,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FilenameCompleterClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FilterInputStreamClass = extern struct {
    pub const Instance = gio.FilterInputStream;

    f_parent_class: gio.InputStreamClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FilterInputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const FilterOutputStreamClass = extern struct {
    pub const Instance = gio.FilterOutputStream;

    f_parent_class: gio.OutputStreamClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *FilterOutputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gio.IOExtension` is an opaque data structure and can only be accessed
/// using the following functions.
pub const IOExtension = opaque {
    /// Gets the name under which `extension` was registered.
    ///
    /// Note that the same type may be registered as extension
    /// for multiple extension points, under different names.
    extern fn g_io_extension_get_name(p_extension: *IOExtension) [*:0]const u8;
    pub const getName = g_io_extension_get_name;

    /// Gets the priority with which `extension` was registered.
    extern fn g_io_extension_get_priority(p_extension: *IOExtension) c_int;
    pub const getPriority = g_io_extension_get_priority;

    /// Gets the type associated with `extension`.
    extern fn g_io_extension_get_type(p_extension: *IOExtension) usize;
    pub const getType = g_io_extension_get_type;

    /// Gets a reference to the class for the type that is
    /// associated with `extension`.
    extern fn g_io_extension_ref_class(p_extension: *IOExtension) *gobject.TypeClass;
    pub const refClass = g_io_extension_ref_class;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GIOExtensionPoint` provides a mechanism for modules to extend the
/// functionality of the library or application that loaded it in an
/// organized fashion.
///
/// An extension point is identified by a name, and it may optionally
/// require that any implementation must be of a certain type (or derived
/// thereof). Use `gio.IOExtensionPoint.register` to register an
/// extension point, and `gio.IOExtensionPoint.setRequiredType` to
/// set a required type.
///
/// A module can implement an extension point by specifying the
/// `gobject.Type` that implements the functionality. Additionally, each
/// implementation of an extension point has a name, and a priority. Use
/// `gio.IOExtensionPoint.implement` to implement an extension point.
///
/// ```c
/// GIOExtensionPoint *ep;
///
/// // Register an extension point
/// ep = g_io_extension_point_register ("my-extension-point");
/// g_io_extension_point_set_required_type (ep, MY_TYPE_EXAMPLE);
/// ```
///
/// ```c
/// // Implement an extension point
/// G_DEFINE_TYPE (MyExampleImpl, my_example_impl, MY_TYPE_EXAMPLE)
/// g_io_extension_point_implement ("my-extension-point",
///                                 my_example_impl_get_type (),
///                                 "my-example",
///                                 10);
/// ```
///
///  It is up to the code that registered the extension point how
///  it uses the implementations that have been associated with it.
///  Depending on the use case, it may use all implementations, or
///  only the one with the highest priority, or pick a specific
///  one by name.
///
///  To avoid opening all modules just to find out what extension
///  points they implement, GIO makes use of a caching mechanism,
///  see [gio-querymodules](gio-querymodules.html).
///  You are expected to run this command after installing a
///  GIO module.
///
///  The `GIO_EXTRA_MODULES` environment variable can be used to
///  specify additional directories to automatically load modules
///  from. This environment variable has the same syntax as the
///  `PATH`. If two modules have the same base name in different
///  directories, then the latter one will be ignored. If additional
///  directories are specified GIO will load modules from the built-in
///  directory last.
pub const IOExtensionPoint = opaque {
    /// Registers `type` as extension for the extension point with name
    /// `extension_point_name`.
    ///
    /// If `type` has already been registered as an extension for this
    /// extension point, the existing `gio.IOExtension` object is returned.
    extern fn g_io_extension_point_implement(p_extension_point_name: [*:0]const u8, p_type: usize, p_extension_name: [*:0]const u8, p_priority: c_int) *gio.IOExtension;
    pub const implement = g_io_extension_point_implement;

    /// Looks up an existing extension point.
    extern fn g_io_extension_point_lookup(p_name: [*:0]const u8) *gio.IOExtensionPoint;
    pub const lookup = g_io_extension_point_lookup;

    /// Registers an extension point.
    extern fn g_io_extension_point_register(p_name: [*:0]const u8) *gio.IOExtensionPoint;
    pub const register = g_io_extension_point_register;

    /// Finds a `gio.IOExtension` for an extension point by name.
    extern fn g_io_extension_point_get_extension_by_name(p_extension_point: *IOExtensionPoint, p_name: [*:0]const u8) *gio.IOExtension;
    pub const getExtensionByName = g_io_extension_point_get_extension_by_name;

    /// Gets a list of all extensions that implement this extension point.
    /// The list is sorted by priority, beginning with the highest priority.
    extern fn g_io_extension_point_get_extensions(p_extension_point: *IOExtensionPoint) *glib.List;
    pub const getExtensions = g_io_extension_point_get_extensions;

    /// Gets the required type for `extension_point`.
    extern fn g_io_extension_point_get_required_type(p_extension_point: *IOExtensionPoint) usize;
    pub const getRequiredType = g_io_extension_point_get_required_type;

    /// Sets the required type for `extension_point` to `type`.
    /// All implementations must henceforth have this type.
    extern fn g_io_extension_point_set_required_type(p_extension_point: *IOExtensionPoint, p_type: usize) void;
    pub const setRequiredType = g_io_extension_point_set_required_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IOModuleClass = opaque {
    pub const Instance = gio.IOModule;

    pub fn as(p_instance: *IOModuleClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Represents a scope for loading IO modules. A scope can be used for blocking
/// duplicate modules, or blocking a module you don't want to load.
///
/// The scope can be used with `gio.ioModulesLoadAllInDirectoryWithScope`
/// or `gio.ioModulesScanAllInDirectoryWithScope`.
pub const IOModuleScope = opaque {
    /// Create a new scope for loading of IO modules. A scope can be used for
    /// blocking duplicate modules, or blocking a module you don't want to load.
    ///
    /// Specify the `G_IO_MODULE_SCOPE_BLOCK_DUPLICATES` flag to block modules
    /// which have the same base name as a module that has already been seen
    /// in this scope.
    extern fn g_io_module_scope_new(p_flags: gio.IOModuleScopeFlags) *gio.IOModuleScope;
    pub const new = g_io_module_scope_new;

    /// Block modules with the given `basename` from being loaded when
    /// this scope is used with `gio.ioModulesScanAllInDirectoryWithScope`
    /// or `gio.ioModulesLoadAllInDirectoryWithScope`.
    extern fn g_io_module_scope_block(p_scope: *IOModuleScope, p_basename: [*:0]const u8) void;
    pub const block = g_io_module_scope_block;

    /// Free a module scope.
    extern fn g_io_module_scope_free(p_scope: *IOModuleScope) void;
    pub const free = g_io_module_scope_free;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Opaque class for defining and scheduling IO jobs.
pub const IOSchedulerJob = opaque {
    /// Used from an I/O job to send a callback to be run in the thread
    /// that the job was started from, waiting for the result (and thus
    /// blocking the I/O job).
    extern fn g_io_scheduler_job_send_to_mainloop(p_job: *IOSchedulerJob, p_func: glib.SourceFunc, p_user_data: ?*anyopaque, p_notify: ?glib.DestroyNotify) c_int;
    pub const sendToMainloop = g_io_scheduler_job_send_to_mainloop;

    /// Used from an I/O job to send a callback to be run asynchronously in
    /// the thread that the job was started from. The callback will be run
    /// when the main loop is available, but at that time the I/O job might
    /// have finished. The return value from the callback is ignored.
    ///
    /// Note that if you are passing the `user_data` from `gio.ioSchedulerPushJob`
    /// on to this function you have to ensure that it is not freed before
    /// `func` is called, either by passing `NULL` as `notify` to
    /// `gio.ioSchedulerPushJob` or by using refcounting for `user_data`.
    extern fn g_io_scheduler_job_send_to_mainloop_async(p_job: *IOSchedulerJob, p_func: glib.SourceFunc, p_user_data: ?*anyopaque, p_notify: ?glib.DestroyNotify) void;
    pub const sendToMainloopAsync = g_io_scheduler_job_send_to_mainloop_async;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IOStreamAdapter = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IOStreamClass = extern struct {
    pub const Instance = gio.IOStream;

    f_parent_class: gobject.ObjectClass,
    f_get_input_stream: ?*const fn (p_stream: *gio.IOStream) callconv(.c) *gio.InputStream,
    f_get_output_stream: ?*const fn (p_stream: *gio.IOStream) callconv(.c) *gio.OutputStream,
    f_close_fn: ?*const fn (p_stream: *gio.IOStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_close_async: ?*const fn (p_stream: *gio.IOStream, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_close_finish: ?*const fn (p_stream: *gio.IOStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,
    f__g_reserved6: ?*const fn () callconv(.c) void,
    f__g_reserved7: ?*const fn () callconv(.c) void,
    f__g_reserved8: ?*const fn () callconv(.c) void,
    f__g_reserved9: ?*const fn () callconv(.c) void,
    f__g_reserved10: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *IOStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const IOStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GIconIface is used to implement GIcon types for various
/// different systems. See `gio.ThemedIcon` and `gio.LoadableIcon` for
/// examples of how to implement this interface.
pub const IconIface = extern struct {
    pub const Instance = gio.Icon;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// A hash for a given `gio.Icon`.
    f_hash: ?*const fn (p_icon: *gio.Icon) callconv(.c) c_uint,
    /// Checks if two `GIcons` are equal.
    f_equal: ?*const fn (p_icon1: ?*gio.Icon, p_icon2: ?*gio.Icon) callconv(.c) c_int,
    /// Serializes a `gio.Icon` into tokens. The tokens must not
    /// contain any whitespace. Don't implement if the `gio.Icon` can't be
    /// serialized (Since 2.20).
    f_to_tokens: ?*const fn (p_icon: *gio.Icon, p_tokens: *glib.PtrArray, p_out_version: *c_int) callconv(.c) c_int,
    /// Constructs a `gio.Icon` from tokens. Set the `glib.Error` if
    /// the tokens are malformed. Don't implement if the `gio.Icon` can't be
    /// serialized (Since 2.20).
    f_from_tokens: ?*const fn (p_tokens: *[*:0]u8, p_num_tokens: c_int, p_version: c_int, p_error: ?*?*glib.Error) callconv(.c) ?*gio.Icon,
    /// Serializes a `gio.Icon` into a `glib.Variant`. Since: 2.38
    f_serialize: ?*const fn (p_icon: *gio.Icon) callconv(.c) ?*glib.Variant,

    pub fn as(p_instance: *IconIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const InetAddressClass = extern struct {
    pub const Instance = gio.InetAddress;

    f_parent_class: gobject.ObjectClass,
    f_to_string: ?*const fn (p_address: *gio.InetAddress) callconv(.c) [*:0]u8,
    f_to_bytes: ?*const fn (p_address: *gio.InetAddress) callconv(.c) *const u8,

    pub fn as(p_instance: *InetAddressClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const InetAddressMaskClass = extern struct {
    pub const Instance = gio.InetAddressMask;

    f_parent_class: gobject.ObjectClass,

    pub fn as(p_instance: *InetAddressMaskClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const InetAddressMaskPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const InetAddressPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const InetSocketAddressClass = extern struct {
    pub const Instance = gio.InetSocketAddress;

    f_parent_class: gio.SocketAddressClass,

    pub fn as(p_instance: *InetSocketAddressClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const InetSocketAddressPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Provides an interface for initializing object such that initialization
/// may fail.
pub const InitableIface = extern struct {
    pub const Instance = gio.Initable;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Initializes the object.
    f_init: ?*const fn (p_initable: *gio.Initable, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,

    pub fn as(p_instance: *InitableIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Structure used for scatter/gather data input when receiving multiple
/// messages or packets in one go. You generally pass in an array of empty
/// `GInputVectors` and the operation will use all the buffers as if they
/// were one buffer, and will set `bytes_received` to the total number of bytes
/// received across all `GInputVectors`.
///
/// This structure closely mirrors `struct mmsghdr` and `struct msghdr` from
/// the POSIX sockets API (see `man 2 recvmmsg`).
///
/// If `address` is non-`NULL` then it is set to the source address the message
/// was received from, and the caller must free it afterwards.
///
/// If `control_messages` is non-`NULL` then it is set to an array of control
/// messages received with the message (if any), and the caller must free it
/// afterwards. `num_control_messages` is set to the number of elements in
/// this array, which may be zero.
///
/// Flags relevant to this message will be returned in `flags`. For example,
/// `MSG_EOR` or `MSG_TRUNC`.
pub const InputMessage = extern struct {
    /// return location
    ///   for a `gio.SocketAddress`, or `NULL`
    f_address: ?**gio.SocketAddress,
    /// pointer to an
    ///   array of input vectors
    f_vectors: ?[*]gio.InputVector,
    /// the number of input vectors pointed to by `vectors`
    f_num_vectors: c_uint,
    /// will be set to the number of bytes that have been
    ///   received
    f_bytes_received: usize,
    /// collection of `gio.SocketMsgFlags` for the received message,
    ///   outputted by the call
    f_flags: c_int,
    /// return location for a
    ///   caller-allocated array of `GSocketControlMessages`, or `NULL`
    f_control_messages: ?[*]**gio.SocketControlMessage,
    /// return location for the number of
    ///   elements in `control_messages`
    f_num_control_messages: ?*c_uint,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const InputStreamClass = extern struct {
    pub const Instance = gio.InputStream;

    f_parent_class: gobject.ObjectClass,
    f_read_fn: ?*const fn (p_stream: *gio.InputStream, p_buffer: ?*anyopaque, p_count: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) isize,
    f_skip: ?*const fn (p_stream: *gio.InputStream, p_count: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) isize,
    f_close_fn: ?*const fn (p_stream: *gio.InputStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_read_async: ?*const fn (p_stream: *gio.InputStream, p_buffer: ?*[*]u8, p_count: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_read_finish: ?*const fn (p_stream: *gio.InputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) isize,
    f_skip_async: ?*const fn (p_stream: *gio.InputStream, p_count: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_skip_finish: ?*const fn (p_stream: *gio.InputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) isize,
    f_close_async: ?*const fn (p_stream: *gio.InputStream, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_close_finish: ?*const fn (p_stream: *gio.InputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *InputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const InputStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Structure used for scatter/gather data input.
/// You generally pass in an array of `GInputVectors`
/// and the operation will store the read data starting in the
/// first buffer, switching to the next as needed.
pub const InputVector = extern struct {
    /// Pointer to a buffer where data will be written.
    f_buffer: ?*anyopaque,
    /// the available size in `buffer`.
    f_size: usize,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The virtual function table for `gio.ListModel`.
pub const ListModelInterface = extern struct {
    pub const Instance = gio.ListModel;

    /// parent `gobject.TypeInterface`
    f_g_iface: gobject.TypeInterface,
    /// the virtual function pointer for `gio.ListModel.getItemType`
    f_get_item_type: ?*const fn (p_list: *gio.ListModel) callconv(.c) usize,
    /// the virtual function pointer for `gio.ListModel.getNItems`
    f_get_n_items: ?*const fn (p_list: *gio.ListModel) callconv(.c) c_uint,
    /// the virtual function pointer for `gio.ListModel.getItem`
    f_get_item: ?*const fn (p_list: *gio.ListModel, p_position: c_uint) callconv(.c) ?*gobject.Object,

    pub fn as(p_instance: *ListModelInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ListStoreClass = extern struct {
    pub const Instance = gio.ListStore;

    f_parent_class: gobject.ObjectClass,

    pub fn as(p_instance: *ListStoreClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Interface for icons that can be loaded as a stream.
pub const LoadableIconIface = extern struct {
    pub const Instance = gio.LoadableIcon;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Loads an icon.
    f_load: ?*const fn (p_icon: *gio.LoadableIcon, p_size: c_int, p_type: ?*[*:0]u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.InputStream,
    /// Loads an icon asynchronously.
    f_load_async: ?*const fn (p_icon: *gio.LoadableIcon, p_size: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an asynchronous icon load.
    f_load_finish: ?*const fn (p_icon: *gio.LoadableIcon, p_res: *gio.AsyncResult, p_type: ?*[*:0]u8, p_error: ?*?*glib.Error) callconv(.c) ?*gio.InputStream,

    pub fn as(p_instance: *LoadableIconIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MemoryInputStreamClass = extern struct {
    pub const Instance = gio.MemoryInputStream;

    f_parent_class: gio.InputStreamClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *MemoryInputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MemoryInputStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The virtual function table for `gio.MemoryMonitor`.
pub const MemoryMonitorInterface = extern struct {
    pub const Instance = gio.MemoryMonitor;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// the virtual function pointer for the
    ///  `gio.MemoryMonitor.signals.low`-memory-warning signal.
    f_low_memory_warning: ?*const fn (p_monitor: *gio.MemoryMonitor, p_level: gio.MemoryMonitorWarningLevel) callconv(.c) void,

    pub fn as(p_instance: *MemoryMonitorInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MemoryOutputStreamClass = extern struct {
    pub const Instance = gio.MemoryOutputStream;

    f_parent_class: gio.OutputStreamClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *MemoryOutputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MemoryOutputStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuAttributeIterClass = extern struct {
    pub const Instance = gio.MenuAttributeIter;

    f_parent_class: gobject.ObjectClass,
    f_get_next: ?*const fn (p_iter: *gio.MenuAttributeIter, p_out_name: ?*[*:0]const u8, p_value: ?**glib.Variant) callconv(.c) c_int,

    pub fn as(p_instance: *MenuAttributeIterClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuAttributeIterPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuLinkIterClass = extern struct {
    pub const Instance = gio.MenuLinkIter;

    f_parent_class: gobject.ObjectClass,
    f_get_next: ?*const fn (p_iter: *gio.MenuLinkIter, p_out_link: ?*[*:0]const u8, p_value: ?**gio.MenuModel) callconv(.c) c_int,

    pub fn as(p_instance: *MenuLinkIterClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuLinkIterPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuModelClass = extern struct {
    pub const Instance = gio.MenuModel;

    f_parent_class: gobject.ObjectClass,
    f_is_mutable: ?*const fn (p_model: *gio.MenuModel) callconv(.c) c_int,
    f_get_n_items: ?*const fn (p_model: *gio.MenuModel) callconv(.c) c_int,
    f_get_item_attributes: ?*const fn (p_model: *gio.MenuModel, p_item_index: c_int, p_attributes: **glib.HashTable) callconv(.c) void,
    f_iterate_item_attributes: ?*const fn (p_model: *gio.MenuModel, p_item_index: c_int) callconv(.c) *gio.MenuAttributeIter,
    f_get_item_attribute_value: ?*const fn (p_model: *gio.MenuModel, p_item_index: c_int, p_attribute: [*:0]const u8, p_expected_type: ?*const glib.VariantType) callconv(.c) ?*glib.Variant,
    f_get_item_links: ?*const fn (p_model: *gio.MenuModel, p_item_index: c_int, p_links: **glib.HashTable) callconv(.c) void,
    f_iterate_item_links: ?*const fn (p_model: *gio.MenuModel, p_item_index: c_int) callconv(.c) *gio.MenuLinkIter,
    f_get_item_link: ?*const fn (p_model: *gio.MenuModel, p_item_index: c_int, p_link: [*:0]const u8) callconv(.c) ?*gio.MenuModel,

    pub fn as(p_instance: *MenuModelClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MenuModelPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Interface for implementing operations for mounts.
pub const MountIface = extern struct {
    pub const Instance = gio.Mount;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Changed signal that is emitted when the mount's state has changed.
    f_changed: ?*const fn (p_mount: *gio.Mount) callconv(.c) void,
    /// The unmounted signal that is emitted when the `gio.Mount` have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.
    f_unmounted: ?*const fn (p_mount: *gio.Mount) callconv(.c) void,
    /// Gets a `gio.File` to the root directory of the `gio.Mount`.
    f_get_root: ?*const fn (p_mount: *gio.Mount) callconv(.c) *gio.File,
    /// Gets a string containing the name of the `gio.Mount`.
    f_get_name: ?*const fn (p_mount: *gio.Mount) callconv(.c) [*:0]u8,
    /// Gets a `gio.Icon` for the `gio.Mount`.
    f_get_icon: ?*const fn (p_mount: *gio.Mount) callconv(.c) *gio.Icon,
    /// Gets the UUID for the `gio.Mount`. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns `NULL` if there is no UUID available.
    f_get_uuid: ?*const fn (p_mount: *gio.Mount) callconv(.c) ?[*:0]u8,
    /// Gets a `gio.Volume` the mount is located on. Returns `NULL` if the `gio.Mount` is not associated with a `gio.Volume`.
    f_get_volume: ?*const fn (p_mount: *gio.Mount) callconv(.c) ?*gio.Volume,
    /// Gets a `gio.Drive` the volume of the mount is located on. Returns `NULL` if the `gio.Mount` is not associated with a `gio.Drive` or a `gio.Volume`. This is convenience method for getting the `gio.Volume` and using that to get the `gio.Drive`.
    f_get_drive: ?*const fn (p_mount: *gio.Mount) callconv(.c) ?*gio.Drive,
    /// Checks if a `gio.Mount` can be unmounted.
    f_can_unmount: ?*const fn (p_mount: *gio.Mount) callconv(.c) c_int,
    /// Checks if a `gio.Mount` can be ejected.
    f_can_eject: ?*const fn (p_mount: *gio.Mount) callconv(.c) c_int,
    /// Starts unmounting a `gio.Mount`.
    f_unmount: ?*const fn (p_mount: *gio.Mount, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an unmounting operation.
    f_unmount_finish: ?*const fn (p_mount: *gio.Mount, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Starts ejecting a `gio.Mount`.
    f_eject: ?*const fn (p_mount: *gio.Mount, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an eject operation.
    f_eject_finish: ?*const fn (p_mount: *gio.Mount, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Starts remounting a `gio.Mount`.
    f_remount: ?*const fn (p_mount: *gio.Mount, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes a remounting operation.
    f_remount_finish: ?*const fn (p_mount: *gio.Mount, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Starts guessing the type of the content of a `gio.Mount`.
    ///     See `gio.Mount.guessContentType` for more information on content
    ///     type guessing. This operation was added in 2.18.
    f_guess_content_type: ?*const fn (p_mount: *gio.Mount, p_force_rescan: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes a content type guessing operation. Added in 2.18.
    f_guess_content_type_finish: ?*const fn (p_mount: *gio.Mount, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?[*][*:0]u8,
    /// Synchronous variant of `guess_content_type`. Added in 2.18
    f_guess_content_type_sync: ?*const fn (p_mount: *gio.Mount, p_force_rescan: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?[*][*:0]u8,
    /// The ::pre-unmount signal that is emitted when the `gio.Mount` will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file.
    f_pre_unmount: ?*const fn (p_mount: *gio.Mount) callconv(.c) void,
    /// Starts unmounting a `gio.Mount` using a `gio.MountOperation`. Since 2.22.
    f_unmount_with_operation: ?*const fn (p_mount: *gio.Mount, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an unmounting operation using a `gio.MountOperation`. Since 2.22.
    f_unmount_with_operation_finish: ?*const fn (p_mount: *gio.Mount, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Starts ejecting a `gio.Mount` using a `gio.MountOperation`. Since 2.22.
    f_eject_with_operation: ?*const fn (p_mount: *gio.Mount, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an eject operation using a `gio.MountOperation`. Since 2.22.
    f_eject_with_operation_finish: ?*const fn (p_mount: *gio.Mount, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Gets a `gio.File` indication a start location that can be use as the entry point for this mount. Since 2.24.
    f_get_default_location: ?*const fn (p_mount: *gio.Mount) callconv(.c) *gio.File,
    /// Gets a key used for sorting `gio.Mount` instance or `NULL` if no such key exists. Since 2.32.
    f_get_sort_key: ?*const fn (p_mount: *gio.Mount) callconv(.c) ?[*:0]const u8,
    /// Gets a symbolic `gio.Icon` for the `gio.Mount`. Since 2.34.
    f_get_symbolic_icon: ?*const fn (p_mount: *gio.Mount) callconv(.c) *gio.Icon,

    pub fn as(p_instance: *MountIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MountOperationClass = extern struct {
    pub const Instance = gio.MountOperation;

    f_parent_class: gobject.ObjectClass,
    f_ask_password: ?*const fn (p_op: *gio.MountOperation, p_message: [*:0]const u8, p_default_user: [*:0]const u8, p_default_domain: [*:0]const u8, p_flags: gio.AskPasswordFlags) callconv(.c) void,
    f_ask_question: ?*const fn (p_op: *gio.MountOperation, p_message: [*:0]const u8, p_choices: [*][*:0]const u8) callconv(.c) void,
    f_reply: ?*const fn (p_op: *gio.MountOperation, p_result: gio.MountOperationResult) callconv(.c) void,
    f_aborted: ?*const fn (p_op: *gio.MountOperation) callconv(.c) void,
    f_show_processes: ?*const fn (p_op: *gio.MountOperation, p_message: [*:0]const u8, p_processes: *glib.Array, p_choices: [*][*:0]const u8) callconv(.c) void,
    f_show_unmount_progress: ?*const fn (p_op: *gio.MountOperation, p_message: [*:0]const u8, p_time_left: i64, p_bytes_left: i64) callconv(.c) void,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,
    f__g_reserved6: ?*const fn () callconv(.c) void,
    f__g_reserved7: ?*const fn () callconv(.c) void,
    f__g_reserved8: ?*const fn () callconv(.c) void,
    f__g_reserved9: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *MountOperationClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const MountOperationPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NativeSocketAddressClass = extern struct {
    pub const Instance = gio.NativeSocketAddress;

    f_parent_class: gio.SocketAddressClass,

    pub fn as(p_instance: *NativeSocketAddressClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NativeSocketAddressPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NativeVolumeMonitorClass = extern struct {
    pub const Instance = gio.NativeVolumeMonitor;

    f_parent_class: gio.VolumeMonitorClass,
    f_get_mount_for_mount_path: ?*const fn (p_mount_path: [*:0]const u8, p_cancellable: *gio.Cancellable) callconv(.c) *gio.Mount,

    pub fn as(p_instance: *NativeVolumeMonitorClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NetworkAddressClass = extern struct {
    pub const Instance = gio.NetworkAddress;

    f_parent_class: gobject.ObjectClass,

    pub fn as(p_instance: *NetworkAddressClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NetworkAddressPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The virtual function table for `gio.NetworkMonitor`.
pub const NetworkMonitorInterface = extern struct {
    pub const Instance = gio.NetworkMonitor;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// the virtual function pointer for the
    ///  GNetworkMonitor::network-changed signal.
    f_network_changed: ?*const fn (p_monitor: *gio.NetworkMonitor, p_network_available: c_int) callconv(.c) void,
    /// the virtual function pointer for `gio.NetworkMonitor.canReach`
    f_can_reach: ?*const fn (p_monitor: *gio.NetworkMonitor, p_connectable: *gio.SocketConnectable, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// the virtual function pointer for
    ///  `gio.NetworkMonitor.canReachAsync`
    f_can_reach_async: ?*const fn (p_monitor: *gio.NetworkMonitor, p_connectable: *gio.SocketConnectable, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// the virtual function pointer for
    ///  `gio.NetworkMonitor.canReachFinish`
    f_can_reach_finish: ?*const fn (p_monitor: *gio.NetworkMonitor, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,

    pub fn as(p_instance: *NetworkMonitorInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NetworkServiceClass = extern struct {
    pub const Instance = gio.NetworkService;

    f_parent_class: gobject.ObjectClass,

    pub fn as(p_instance: *NetworkServiceClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const NetworkServicePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Structure used for scatter/gather data output when sending multiple
/// messages or packets in one go. You generally pass in an array of
/// `GOutputVectors` and the operation will use all the buffers as if they
/// were one buffer.
///
/// If `address` is `NULL` then the message is sent to the default receiver
/// (as previously set by `gio.Socket.connect`).
pub const OutputMessage = extern struct {
    /// a `gio.SocketAddress`, or `NULL`
    f_address: ?*gio.SocketAddress,
    /// pointer to an array of output vectors
    f_vectors: ?*gio.OutputVector,
    /// the number of output vectors pointed to by `vectors`.
    f_num_vectors: c_uint,
    /// initialize to 0. Will be set to the number of bytes
    ///     that have been sent
    f_bytes_sent: c_uint,
    /// a pointer
    ///   to an array of `GSocketControlMessages`, or `NULL`.
    f_control_messages: ?[*]*gio.SocketControlMessage,
    /// number of elements in `control_messages`.
    f_num_control_messages: c_uint,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const OutputStreamClass = extern struct {
    pub const Instance = gio.OutputStream;

    f_parent_class: gobject.ObjectClass,
    f_write_fn: ?*const fn (p_stream: *gio.OutputStream, p_buffer: ?[*]u8, p_count: usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) isize,
    f_splice: ?*const fn (p_stream: *gio.OutputStream, p_source: *gio.InputStream, p_flags: gio.OutputStreamSpliceFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) isize,
    f_flush: ?*const fn (p_stream: *gio.OutputStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_close_fn: ?*const fn (p_stream: *gio.OutputStream, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_write_async: ?*const fn (p_stream: *gio.OutputStream, p_buffer: ?[*]u8, p_count: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_write_finish: ?*const fn (p_stream: *gio.OutputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) isize,
    f_splice_async: ?*const fn (p_stream: *gio.OutputStream, p_source: *gio.InputStream, p_flags: gio.OutputStreamSpliceFlags, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_splice_finish: ?*const fn (p_stream: *gio.OutputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) isize,
    f_flush_async: ?*const fn (p_stream: *gio.OutputStream, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_flush_finish: ?*const fn (p_stream: *gio.OutputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_close_async: ?*const fn (p_stream: *gio.OutputStream, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_close_finish: ?*const fn (p_stream: *gio.OutputStream, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_writev_fn: ?*const fn (p_stream: *gio.OutputStream, p_vectors: [*]const gio.OutputVector, p_n_vectors: usize, p_bytes_written: ?*usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_writev_async: ?*const fn (p_stream: *gio.OutputStream, p_vectors: [*]const gio.OutputVector, p_n_vectors: usize, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_writev_finish: ?*const fn (p_stream: *gio.OutputStream, p_result: *gio.AsyncResult, p_bytes_written: ?*usize, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,
    f__g_reserved6: ?*const fn () callconv(.c) void,
    f__g_reserved7: ?*const fn () callconv(.c) void,
    f__g_reserved8: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *OutputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const OutputStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Structure used for scatter/gather data output.
/// You generally pass in an array of `GOutputVectors`
/// and the operation will use all the buffers as if they were
/// one buffer.
pub const OutputVector = extern struct {
    /// Pointer to a buffer of data to read.
    f_buffer: ?*const anyopaque,
    /// the size of `buffer`.
    f_size: usize,

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PermissionClass = extern struct {
    pub const Instance = gio.Permission;

    f_parent_class: gobject.ObjectClass,
    f_acquire: ?*const fn (p_permission: *gio.Permission, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_acquire_async: ?*const fn (p_permission: *gio.Permission, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_acquire_finish: ?*const fn (p_permission: *gio.Permission, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_release: ?*const fn (p_permission: *gio.Permission, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_release_async: ?*const fn (p_permission: *gio.Permission, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_release_finish: ?*const fn (p_permission: *gio.Permission, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_reserved: [16]*anyopaque,

    pub fn as(p_instance: *PermissionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const PermissionPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The interface for pollable input streams.
///
/// The default implementation of `can_poll` always returns `TRUE`.
///
/// The default implementation of `read_nonblocking` calls
/// `gio.PollableInputStream.isReadable`, and then calls
/// `gio.InputStream.read` if it returns `TRUE`. This means you only need
/// to override it if it is possible that your `is_readable`
/// implementation may return `TRUE` when the stream is not actually
/// readable.
pub const PollableInputStreamInterface = extern struct {
    pub const Instance = gio.PollableInputStream;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Checks if the `gio.PollableInputStream` instance is actually pollable
    f_can_poll: ?*const fn (p_stream: *gio.PollableInputStream) callconv(.c) c_int,
    /// Checks if the stream is readable
    f_is_readable: ?*const fn (p_stream: *gio.PollableInputStream) callconv(.c) c_int,
    /// Creates a `glib.Source` to poll the stream
    f_create_source: ?*const fn (p_stream: *gio.PollableInputStream, p_cancellable: ?*gio.Cancellable) callconv(.c) *glib.Source,
    /// Does a non-blocking read or returns
    ///   `G_IO_ERROR_WOULD_BLOCK`
    f_read_nonblocking: ?*const fn (p_stream: *gio.PollableInputStream, p_buffer: ?*[*]u8, p_count: usize, p_error: ?*?*glib.Error) callconv(.c) isize,

    pub fn as(p_instance: *PollableInputStreamInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The interface for pollable output streams.
///
/// The default implementation of `can_poll` always returns `TRUE`.
///
/// The default implementation of `write_nonblocking` calls
/// `gio.PollableOutputStream.isWritable`, and then calls
/// `gio.OutputStream.write` if it returns `TRUE`. This means you only
/// need to override it if it is possible that your `is_writable`
/// implementation may return `TRUE` when the stream is not actually
/// writable.
///
/// The default implementation of `writev_nonblocking` calls
/// `gio.PollableOutputStream.writeNonblocking` for each vector, and converts
/// its return value and error (if set) to a `gio.PollableReturn`. You should
/// override this where possible to avoid having to allocate a `glib.Error` to return
/// `G_IO_ERROR_WOULD_BLOCK`.
pub const PollableOutputStreamInterface = extern struct {
    pub const Instance = gio.PollableOutputStream;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Checks if the `gio.PollableOutputStream` instance is actually pollable
    f_can_poll: ?*const fn (p_stream: *gio.PollableOutputStream) callconv(.c) c_int,
    /// Checks if the stream is writable
    f_is_writable: ?*const fn (p_stream: *gio.PollableOutputStream) callconv(.c) c_int,
    /// Creates a `glib.Source` to poll the stream
    f_create_source: ?*const fn (p_stream: *gio.PollableOutputStream, p_cancellable: ?*gio.Cancellable) callconv(.c) *glib.Source,
    /// Does a non-blocking write or returns
    ///   `G_IO_ERROR_WOULD_BLOCK`
    f_write_nonblocking: ?*const fn (p_stream: *gio.PollableOutputStream, p_buffer: ?[*]u8, p_count: usize, p_error: ?*?*glib.Error) callconv(.c) isize,
    /// Does a vectored non-blocking write, or returns
    ///   `G_POLLABLE_RETURN_WOULD_BLOCK`
    f_writev_nonblocking: ?*const fn (p_stream: *gio.PollableOutputStream, p_vectors: [*]const gio.OutputVector, p_n_vectors: usize, p_bytes_written: ?*usize, p_error: ?*?*glib.Error) callconv(.c) gio.PollableReturn,

    pub fn as(p_instance: *PollableOutputStreamInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The virtual function table for `gio.PowerProfileMonitor`.
pub const PowerProfileMonitorInterface = extern struct {
    pub const Instance = gio.PowerProfileMonitor;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,

    pub fn as(p_instance: *PowerProfileMonitorInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.ProxyAddress`.
pub const ProxyAddressClass = extern struct {
    pub const Instance = gio.ProxyAddress;

    f_parent_class: gio.InetSocketAddressClass,

    pub fn as(p_instance: *ProxyAddressClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.ProxyAddressEnumerator`.
pub const ProxyAddressEnumeratorClass = extern struct {
    pub const Instance = gio.ProxyAddressEnumerator;

    f_parent_class: gio.SocketAddressEnumeratorClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,
    f__g_reserved6: ?*const fn () callconv(.c) void,
    f__g_reserved7: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ProxyAddressEnumeratorClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ProxyAddressEnumeratorPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ProxyAddressPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Provides an interface for handling proxy connection and payload.
pub const ProxyInterface = extern struct {
    pub const Instance = gio.Proxy;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Connect to proxy server and wrap (if required) the `connection`
    ///           to handle payload.
    f_connect: ?*const fn (p_proxy: *gio.Proxy, p_connection: *gio.IOStream, p_proxy_address: *gio.ProxyAddress, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.IOStream,
    /// Same as `connect` but asynchronous.
    f_connect_async: ?*const fn (p_proxy: *gio.Proxy, p_connection: *gio.IOStream, p_proxy_address: *gio.ProxyAddress, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Returns the result of `connect_async`
    f_connect_finish: ?*const fn (p_proxy: *gio.Proxy, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.IOStream,
    /// Returns whether the proxy supports hostname lookups.
    f_supports_hostname: ?*const fn (p_proxy: *gio.Proxy) callconv(.c) c_int,

    pub fn as(p_instance: *ProxyInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The virtual function table for `gio.ProxyResolver`.
pub const ProxyResolverInterface = extern struct {
    pub const Instance = gio.ProxyResolver;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// the virtual function pointer for `gio.ProxyResolver.isSupported`
    f_is_supported: ?*const fn (p_resolver: *gio.ProxyResolver) callconv(.c) c_int,
    /// the virtual function pointer for `gio.ProxyResolver.lookup`
    f_lookup: ?*const fn (p_resolver: *gio.ProxyResolver, p_uri: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?[*][*:0]u8,
    /// the virtual function pointer for
    ///  `gio.ProxyResolver.lookupAsync`
    f_lookup_async: ?*const fn (p_resolver: *gio.ProxyResolver, p_uri: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// the virtual function pointer for
    ///  `gio.ProxyResolver.lookupFinish`
    f_lookup_finish: ?*const fn (p_resolver: *gio.ProxyResolver, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?[*][*:0]u8,

    pub fn as(p_instance: *ProxyResolverInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The virtual function table for `gio.RemoteActionGroup`.
pub const RemoteActionGroupInterface = extern struct {
    pub const Instance = gio.RemoteActionGroup;

    f_g_iface: gobject.TypeInterface,
    /// the virtual function pointer for `gio.RemoteActionGroup.activateActionFull`
    f_activate_action_full: ?*const fn (p_remote: *gio.RemoteActionGroup, p_action_name: [*:0]const u8, p_parameter: ?*glib.Variant, p_platform_data: *glib.Variant) callconv(.c) void,
    /// the virtual function pointer for `gio.RemoteActionGroup.changeActionStateFull`
    f_change_action_state_full: ?*const fn (p_remote: *gio.RemoteActionGroup, p_action_name: [*:0]const u8, p_value: *glib.Variant, p_platform_data: *glib.Variant) callconv(.c) void,

    pub fn as(p_instance: *RemoteActionGroupInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ResolverClass = extern struct {
    pub const Instance = gio.Resolver;

    f_parent_class: gobject.ObjectClass,
    f_reload: ?*const fn (p_resolver: *gio.Resolver) callconv(.c) void,
    f_lookup_by_name: ?*const fn (p_resolver: *gio.Resolver, p_hostname: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List,
    f_lookup_by_name_async: ?*const fn (p_resolver: *gio.Resolver, p_hostname: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_lookup_by_name_finish: ?*const fn (p_resolver: *gio.Resolver, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List,
    f_lookup_by_address: ?*const fn (p_resolver: *gio.Resolver, p_address: *gio.InetAddress, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?[*:0]u8,
    f_lookup_by_address_async: ?*const fn (p_resolver: *gio.Resolver, p_address: *gio.InetAddress, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_lookup_by_address_finish: ?*const fn (p_resolver: *gio.Resolver, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?[*:0]u8,
    f_lookup_service: ?*const fn (p_resolver: *gio.Resolver, p_rrname: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List,
    f_lookup_service_async: ?*const fn (p_resolver: *gio.Resolver, p_rrname: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_lookup_service_finish: ?*const fn (p_resolver: *gio.Resolver, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List,
    f_lookup_records: ?*const fn (p_resolver: *gio.Resolver, p_rrname: [*:0]const u8, p_record_type: gio.ResolverRecordType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List,
    f_lookup_records_async: ?*const fn (p_resolver: *gio.Resolver, p_rrname: [*:0]const u8, p_record_type: gio.ResolverRecordType, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_lookup_records_finish: ?*const fn (p_resolver: *gio.Resolver, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List,
    f_lookup_by_name_with_flags_async: ?*const fn (p_resolver: *gio.Resolver, p_hostname: [*:0]const u8, p_flags: gio.ResolverNameLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    f_lookup_by_name_with_flags_finish: ?*const fn (p_resolver: *gio.Resolver, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List,
    f_lookup_by_name_with_flags: ?*const fn (p_resolver: *gio.Resolver, p_hostname: [*:0]const u8, p_flags: gio.ResolverNameLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List,

    pub fn as(p_instance: *ResolverClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ResolverPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Applications and libraries often contain binary or textual data that is
/// really part of the application, rather than user data. For instance
/// [`GtkBuilder`](https://docs.gtk.org/gtk4/class.Builder.html) `.ui` files,
/// splashscreen images, `gio.Menu` markup XML, CSS files, icons, etc.
/// These are often shipped as files in `$datadir/appname`, or manually
/// included as literal strings in the code.
///
/// The `GResource` API and the
/// [`glib-compile-resources`](glib-compile-resources.html) program provide a
/// convenient and efficient alternative to this which has some nice properties.
/// You maintain the files as normal files, so it’s easy to edit them, but during
/// the build the files are combined into a binary bundle that is linked into the
/// executable. This means that loading the resource files are efficient (as they
/// are already in memory, shared with other instances) and simple (no need to
/// check for things like I/O errors or locate the files in the filesystem). It
/// also makes it easier to create relocatable applications.
///
/// Resource files can also be marked as compressed. Such files will be included
/// in the resource bundle in a compressed form, but will be automatically
/// uncompressed when the resource is used. This is very useful e.g. for larger
/// text files that are parsed once (or rarely) and then thrown away.
///
/// Resource files can also be marked to be preprocessed, by setting the value of the
/// `preprocess` attribute to a comma-separated list of preprocessing options.
/// The only options currently supported are:
///
///  - `xml-stripblanks` which will use the [`xmllint`](man:xmllint(1)) command
///    to strip ignorable whitespace from the XML file. For this to work,
///    the `XMLLINT` environment variable must be set to the full path to
///    the xmllint executable, or xmllint must be in the `PATH`; otherwise
///    the preprocessing step is skipped.
///
///  - `to-pixdata` (deprecated since gdk-pixbuf 2.32) which will use the
///    `gdk-pixbuf-pixdata` command to convert images to the [`GdkPixdata`](https://docs.gtk.org/gdk-pixbuf/class.Pixdata.html)
///    format, which allows you to create pixbufs directly using the data inside
///    the resource file, rather than an (uncompressed) copy of it. For this, the
///    `gdk-pixbuf-pixdata` program must be in the `PATH`, or the
///    `GDK_PIXBUF_PIXDATA` environment variable must be set to the full path to
///    the `gdk-pixbuf-pixdata` executable; otherwise the resource compiler will
///    abort. `to-pixdata` has been deprecated since gdk-pixbuf 2.32, as
///    `GResource` supports embedding modern image formats just as well. Instead
///    of using it, embed a PNG or SVG file in your `GResource`.
///
///  - `json-stripblanks` which will use the
///    [`json-glib-format`](man:json-glib-format(1)) command to strip ignorable
///    whitespace from the JSON file. For this to work, the `JSON_GLIB_FORMAT`
///    environment variable must be set to the full path to the
///    `json-glib-format` executable, or it must be in the `PATH`; otherwise the
///    preprocessing step is skipped. In addition, at least version 1.6 of
///    `json-glib-format` is required.
///
/// Resource files will be exported in the `GResource` namespace using the
/// combination of the given `prefix` and the filename from the `file` element.
/// The `alias` attribute can be used to alter the filename to expose them at a
/// different location in the resource namespace. Typically, this is used to
/// include files from a different source directory without exposing the source
/// directory in the resource namespace, as in the example below.
///
/// Resource bundles are created by the
/// [`glib-compile-resources`](glib-compile-resources.html) program
/// which takes an XML file that describes the bundle, and a set of files that
/// the XML references. These are combined into a binary resource bundle.
///
/// An example resource description:
/// ```xml
/// <?xml version="1.0" encoding="UTF-8"?>
/// <gresources>
///   <gresource prefix="/org/gtk/Example">
///     <file>data/splashscreen.png</file>
///     <file compressed="true">dialog.ui</file>
///     <file preprocess="xml-stripblanks">menumarkup.xml</file>
///     <file alias="example.css">data/example.css</file>
///   </gresource>
/// </gresources>
/// ```
///
/// This will create a resource bundle with the following files:
/// ```
/// /org/gtk/Example/data/splashscreen.png
/// /org/gtk/Example/dialog.ui
/// /org/gtk/Example/menumarkup.xml
/// /org/gtk/Example/example.css
/// ```
///
/// Note that all resources in the process share the same namespace, so use
/// Java-style path prefixes (like in the above example) to avoid conflicts.
///
/// You can then use [`glib-compile-resources`](glib-compile-resources.html) to
/// compile the XML to a binary bundle that you can load with
/// `gio.Resource.load`. However, it’s more common to use the
/// `--generate-source` and `--generate-header` arguments to create a source file
/// and header to link directly into your application.
/// This will generate ``get_resource``, ``register_resource`` and
/// ``unregister_resource`` functions, prefixed by the `--c-name` argument passed
/// to [`glib-compile-resources`](glib-compile-resources.html). ``get_resource``
/// returns the generated `GResource` object. The register and unregister
/// functions register the resource so its files can be accessed using
/// `gio.resourcesLookupData`.
///
/// Once a `GResource` has been created and registered all the data in it can be
/// accessed globally in the process by using API calls like
/// `gio.resourcesOpenStream` to stream the data or
/// `gio.resourcesLookupData` to get a direct pointer to the data. You can
/// also use URIs like `resource:///org/gtk/Example/data/splashscreen.png` with
/// `gio.File` to access the resource data.
///
/// Some higher-level APIs, such as [`GtkApplication`](https://docs.gtk.org/gtk4/class.Application.html),
/// will automatically load resources from certain well-known paths in the
/// resource namespace as a convenience. See the documentation for those APIs
/// for details.
///
/// There are two forms of the generated source, the default version uses the
/// compiler support for constructor and destructor functions (where available)
/// to automatically create and register the `GResource` on startup or library
/// load time. If you pass `--manual-register`, two functions to
/// register/unregister the resource are created instead. This requires an
/// explicit initialization call in your application/library, but it works on all
/// platforms, even on the minor ones where constructors are not supported.
/// (Constructor support is available for at least Win32, Mac OS and Linux.)
///
/// Note that resource data can point directly into the data segment of e.g. a
/// library, so if you are unloading libraries during runtime you need to be very
/// careful with keeping around pointers to data from a resource, as this goes
/// away when the library is unloaded. However, in practice this is not generally
/// a problem, since most resource accesses are for your own resources, and
/// resource data is often used once, during parsing, and then released.
///
/// # Overlays
///
/// When debugging a program or testing a change to an installed version, it is
/// often useful to be able to replace resources in the program or library,
/// without recompiling, for debugging or quick hacking and testing purposes.
/// Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment
/// variable to selectively overlay resources with replacements from the
/// filesystem.  It is a `G_SEARCHPATH_SEPARATOR`-separated list of substitutions
/// to perform during resource lookups. It is ignored when running in a setuid
/// process.
///
/// A substitution has the form
///
/// ```
/// /org/gtk/libgtk=/home/desrt/gtk-overlay
/// ```
///
/// The part before the `=` is the resource subpath for which the overlay
/// applies.  The part after is a filesystem path which contains files and
/// subdirectories as you would like to be loaded as resources with the
/// equivalent names.
///
/// In the example above, if an application tried to load a resource with the
/// resource path `/org/gtk/libgtk/ui/gtkdialog.ui` then `GResource` would check
/// the filesystem path `/home/desrt/gtk-overlay/ui/gtkdialog.ui`.  If a file was
/// found there, it would be used instead.  This is an overlay, not an outright
/// replacement, which means that if a file is not found at that path, the
/// built-in version will be used instead.  Whiteouts are not currently
/// supported.
///
/// Substitutions must start with a slash, and must not contain a trailing slash
/// before the `=`.  The path after the slash should ideally be absolute, but
/// this is not strictly required.  It is possible to overlay the location of a
/// single resource with an individual file.
pub const Resource = opaque {
    /// Loads a binary resource bundle and creates a `gio.Resource`
    /// representation of it, allowing you to query it for data.
    ///
    /// If you want to use this resource in the global resource namespace you need
    /// to register it with `gio.resourcesRegister`.
    ///
    /// If `filename` is empty or the data in it is corrupt,
    /// `G_RESOURCE_ERROR_INTERNAL` will be returned. If `filename` doesn’t exist, or
    /// there is an error in reading it, an error from `glib.MappedFile.new`
    /// will be returned.
    extern fn g_resource_load(p_filename: [*:0]const u8, p_error: ?*?*glib.Error) ?*gio.Resource;
    pub const load = g_resource_load;

    /// Creates a `gio.Resource` from a reference to the binary resource bundle.
    ///
    /// This will keep a reference to `data` while the resource lives, so
    /// the data should not be modified or freed.
    ///
    /// If you want to use this resource in the global resource namespace you need
    /// to register it with `gio.resourcesRegister`.
    ///
    /// Note: `data` must be backed by memory that is at least pointer aligned.
    /// Otherwise this function will internally create a copy of the memory since
    /// GLib 2.56, or in older versions fail and exit the process.
    ///
    /// If `data` is empty or corrupt, `G_RESOURCE_ERROR_INTERNAL` will be returned.
    extern fn g_resource_new_from_data(p_data: *glib.Bytes, p_error: ?*?*glib.Error) ?*gio.Resource;
    pub const newFromData = g_resource_new_from_data;

    /// Returns all the names of children at the specified `path` in the resource.
    ///
    /// The return result is a `NULL` terminated list of strings which should
    /// be released with `glib.strfreev`.
    ///
    /// If `path` is invalid or does not exist in the `gio.Resource`,
    /// `G_RESOURCE_ERROR_NOT_FOUND` will be returned.
    ///
    /// `lookup_flags` controls the behaviour of the lookup.
    extern fn g_resource_enumerate_children(p_resource: *Resource, p_path: [*:0]const u8, p_lookup_flags: gio.ResourceLookupFlags, p_error: ?*?*glib.Error) ?[*][*:0]u8;
    pub const enumerateChildren = g_resource_enumerate_children;

    /// Looks for a file at the specified `path` in the resource and
    /// if found returns information about it.
    ///
    /// `lookup_flags` controls the behaviour of the lookup.
    ///
    /// The only error this can return is `G_RESOURCE_ERROR_NOT_FOUND`, if `path` was
    /// not found in `resource`.
    extern fn g_resource_get_info(p_resource: *Resource, p_path: [*:0]const u8, p_lookup_flags: gio.ResourceLookupFlags, p_size: ?*usize, p_flags: ?*u32, p_error: ?*?*glib.Error) c_int;
    pub const getInfo = g_resource_get_info;

    /// Returns whether the specified `path` in the resource
    /// has children.
    extern fn g_resource_has_children(p_resource: *Resource, p_path: [*:0]const u8) c_int;
    pub const hasChildren = g_resource_has_children;

    /// Looks for a file at the specified `path` in the resource and
    /// returns a `glib.Bytes` that lets you directly access the data in
    /// memory.
    ///
    /// The data is always followed by a zero byte, so you
    /// can safely use the data as a C string. However, that byte
    /// is not included in the size of the `glib.Bytes`.
    ///
    /// For uncompressed resource files this is a pointer directly into
    /// the resource bundle, which is typically in some read-only data section
    /// in the program binary. For compressed files, memory is allocated on
    /// the heap and the data is automatically uncompressed.
    ///
    /// `lookup_flags` controls the behaviour of the lookup.
    ///
    /// This can return error `G_RESOURCE_ERROR_NOT_FOUND` if `path` was not found in
    /// `resource`, or `G_RESOURCE_ERROR_INTERNAL` if decompression of a compressed
    /// resource failed.
    extern fn g_resource_lookup_data(p_resource: *Resource, p_path: [*:0]const u8, p_lookup_flags: gio.ResourceLookupFlags, p_error: ?*?*glib.Error) ?*glib.Bytes;
    pub const lookupData = g_resource_lookup_data;

    /// Looks for a file at the specified `path` in the resource and
    /// returns a `gio.InputStream` that lets you read the data.
    ///
    /// `lookup_flags` controls the behaviour of the lookup.
    ///
    /// The only error this can return is `G_RESOURCE_ERROR_NOT_FOUND`, if `path` was
    /// not found in `resource`.
    extern fn g_resource_open_stream(p_resource: *Resource, p_path: [*:0]const u8, p_lookup_flags: gio.ResourceLookupFlags, p_error: ?*?*glib.Error) ?*gio.InputStream;
    pub const openStream = g_resource_open_stream;

    /// Atomically increments the reference count of `resource` by one.
    ///
    /// This function is threadsafe and may be called from any thread.
    extern fn g_resource_ref(p_resource: *Resource) *gio.Resource;
    pub const ref = g_resource_ref;

    /// Atomically decrements the reference count of `resource` by one.
    ///
    /// If the reference count drops to 0, all memory allocated by the resource is
    /// released. This function is threadsafe and may be called from any
    /// thread.
    extern fn g_resource_unref(p_resource: *Resource) void;
    pub const unref = g_resource_unref;

    extern fn g_resource_get_type() usize;
    pub const getGObjectType = g_resource_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Provides an interface for implementing seekable functionality on I/O Streams.
pub const SeekableIface = extern struct {
    pub const Instance = gio.Seekable;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Tells the current location within a stream.
    f_tell: ?*const fn (p_seekable: *gio.Seekable) callconv(.c) i64,
    /// Checks if seeking is supported by the stream.
    f_can_seek: ?*const fn (p_seekable: *gio.Seekable) callconv(.c) c_int,
    /// Seeks to a location within a stream.
    f_seek: ?*const fn (p_seekable: *gio.Seekable, p_offset: i64, p_type: glib.SeekType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Checks if truncation is supported by the stream.
    f_can_truncate: ?*const fn (p_seekable: *gio.Seekable) callconv(.c) c_int,
    /// Truncates a stream.
    f_truncate_fn: ?*const fn (p_seekable: *gio.Seekable, p_offset: i64, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,

    pub fn as(p_instance: *SeekableIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.SettingsBackend`.
pub const SettingsBackendClass = extern struct {
    pub const Instance = gio.SettingsBackend;

    f_parent_class: gobject.ObjectClass,
    /// virtual method to read a key's value
    f_read: ?*const fn (p_backend: *gio.SettingsBackend, p_key: [*:0]const u8, p_expected_type: *const glib.VariantType, p_default_value: c_int) callconv(.c) *glib.Variant,
    /// virtual method to get if a key is writable
    f_get_writable: ?*const fn (p_backend: *gio.SettingsBackend, p_key: [*:0]const u8) callconv(.c) c_int,
    /// virtual method to change key's value
    f_write: ?*const fn (p_backend: *gio.SettingsBackend, p_key: [*:0]const u8, p_value: *glib.Variant, p_origin_tag: ?*anyopaque) callconv(.c) c_int,
    /// virtual method to change a tree of keys
    f_write_tree: ?*const fn (p_backend: *gio.SettingsBackend, p_tree: *glib.Tree, p_origin_tag: ?*anyopaque) callconv(.c) c_int,
    /// virtual method to reset state
    f_reset: ?*const fn (p_backend: *gio.SettingsBackend, p_key: [*:0]const u8, p_origin_tag: ?*anyopaque) callconv(.c) void,
    /// virtual method to subscribe to key changes
    f_subscribe: ?*const fn (p_backend: *gio.SettingsBackend, p_name: [*:0]const u8) callconv(.c) void,
    /// virtual method to unsubscribe to key changes
    f_unsubscribe: ?*const fn (p_backend: *gio.SettingsBackend, p_name: [*:0]const u8) callconv(.c) void,
    /// virtual method to sync state
    f_sync: ?*const fn (p_backend: *gio.SettingsBackend) callconv(.c) void,
    /// virtual method to get permission of a key
    f_get_permission: ?*const fn (p_backend: *gio.SettingsBackend, p_path: [*:0]const u8) callconv(.c) *gio.Permission,
    /// virtual method to read user's key value
    f_read_user_value: ?*const fn (p_backend: *gio.SettingsBackend, p_key: [*:0]const u8, p_expected_type: *const glib.VariantType) callconv(.c) *glib.Variant,
    f_padding: [23]*anyopaque,

    pub fn as(p_instance: *SettingsBackendClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SettingsBackendPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SettingsClass = extern struct {
    pub const Instance = gio.Settings;

    f_parent_class: gobject.ObjectClass,
    f_writable_changed: ?*const fn (p_settings: *gio.Settings, p_key: [*:0]const u8) callconv(.c) void,
    f_changed: ?*const fn (p_settings: *gio.Settings, p_key: [*:0]const u8) callconv(.c) void,
    f_writable_change_event: ?*const fn (p_settings: *gio.Settings, p_key: glib.Quark) callconv(.c) c_int,
    f_change_event: ?*const fn (p_settings: *gio.Settings, p_keys: *const glib.Quark, p_n_keys: c_int) callconv(.c) c_int,
    f_padding: [20]*anyopaque,

    pub fn as(p_instance: *SettingsClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SettingsPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The `gio.SettingsSchemaSource` and `GSettingsSchema` APIs provide a
/// mechanism for advanced control over the loading of schemas and a
/// mechanism for introspecting their content.
///
/// Plugin loading systems that wish to provide plugins a way to access
/// settings face the problem of how to make the schemas for these
/// settings visible to GSettings.  Typically, a plugin will want to ship
/// the schema along with itself and it won't be installed into the
/// standard system directories for schemas.
///
/// `gio.SettingsSchemaSource` provides a mechanism for dealing with this
/// by allowing the creation of a new ‘schema source’ from which schemas can
/// be acquired.  This schema source can then become part of the metadata
/// associated with the plugin and queried whenever the plugin requires
/// access to some settings.
///
/// Consider the following example:
///
/// ```c
/// typedef struct
/// {
///    …
///    GSettingsSchemaSource *schema_source;
///    …
/// } Plugin;
///
/// Plugin *
/// initialise_plugin (const gchar *dir)
/// {
///   Plugin *plugin;
///
///   …
///
///   plugin->schema_source =
///     g_settings_schema_source_new_from_directory (dir,
///       g_settings_schema_source_get_default (), FALSE, NULL);
///
///   …
///
///   return plugin;
/// }
///
/// …
///
/// GSettings *
/// plugin_get_settings (Plugin      *plugin,
///                      const gchar *schema_id)
/// {
///   GSettingsSchema *schema;
///
///   if (schema_id == NULL)
///     schema_id = plugin->identifier;
///
///   schema = g_settings_schema_source_lookup (plugin->schema_source,
///                                             schema_id, FALSE);
///
///   if (schema == NULL)
///     {
///       … disable the plugin or abort, etc …
///     }
///
///   return g_settings_new_full (schema, NULL, NULL);
/// }
/// ```
///
/// The code above shows how hooks should be added to the code that
/// initialises (or enables) the plugin to create the schema source and
/// how an API can be added to the plugin system to provide a convenient
/// way for the plugin to access its settings, using the schemas that it
/// ships.
///
/// From the standpoint of the plugin, it would need to ensure that it
/// ships a gschemas.compiled file as part of itself, and then simply do
/// the following:
///
/// ```c
/// {
///   GSettings *settings;
///   gint some_value;
///
///   settings = plugin_get_settings (self, NULL);
///   some_value = g_settings_get_int (settings, "some-value");
///   …
/// }
/// ```
///
/// It's also possible that the plugin system expects the schema source
/// files (ie: `.gschema.xml` files) instead of a `gschemas.compiled` file.
/// In that case, the plugin loading system must compile the schemas for
/// itself before attempting to create the settings source.
pub const SettingsSchema = opaque {
    /// Get the ID of `schema`.
    extern fn g_settings_schema_get_id(p_schema: *SettingsSchema) [*:0]const u8;
    pub const getId = g_settings_schema_get_id;

    /// Gets the key named `name` from `schema`.
    ///
    /// It is a programmer error to request a key that does not exist.  See
    /// `gio.SettingsSchema.listKeys`.
    extern fn g_settings_schema_get_key(p_schema: *SettingsSchema, p_name: [*:0]const u8) *gio.SettingsSchemaKey;
    pub const getKey = g_settings_schema_get_key;

    /// Gets the path associated with `schema`, or `NULL`.
    ///
    /// Schemas may be single-instance or relocatable.  Single-instance
    /// schemas correspond to exactly one set of keys in the backend
    /// database: those located at the path returned by this function.
    ///
    /// Relocatable schemas can be referenced by other schemas and can
    /// therefore describe multiple sets of keys at different locations.  For
    /// relocatable schemas, this function will return `NULL`.
    extern fn g_settings_schema_get_path(p_schema: *SettingsSchema) ?[*:0]const u8;
    pub const getPath = g_settings_schema_get_path;

    /// Checks if `schema` has a key named `name`.
    extern fn g_settings_schema_has_key(p_schema: *SettingsSchema, p_name: [*:0]const u8) c_int;
    pub const hasKey = g_settings_schema_has_key;

    /// Gets the list of children in `schema`.
    ///
    /// You should free the return value with `glib.strfreev` when you are done
    /// with it.
    extern fn g_settings_schema_list_children(p_schema: *SettingsSchema) [*][*:0]u8;
    pub const listChildren = g_settings_schema_list_children;

    /// Introspects the list of keys on `schema`.
    ///
    /// You should probably not be calling this function from "normal" code
    /// (since you should already know what keys are in your schema).  This
    /// function is intended for introspection reasons.
    extern fn g_settings_schema_list_keys(p_schema: *SettingsSchema) [*][*:0]u8;
    pub const listKeys = g_settings_schema_list_keys;

    /// Increase the reference count of `schema`, returning a new reference.
    extern fn g_settings_schema_ref(p_schema: *SettingsSchema) *gio.SettingsSchema;
    pub const ref = g_settings_schema_ref;

    /// Decrease the reference count of `schema`, possibly freeing it.
    extern fn g_settings_schema_unref(p_schema: *SettingsSchema) void;
    pub const unref = g_settings_schema_unref;

    extern fn g_settings_schema_get_type() usize;
    pub const getGObjectType = g_settings_schema_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gio.SettingsSchemaKey` is an opaque data structure and can only be accessed
/// using the following functions.
pub const SettingsSchemaKey = opaque {
    /// Gets the default value for `key`.
    ///
    /// Note that this is the default value according to the schema.  System
    /// administrator defaults and lockdown are not visible via this API.
    extern fn g_settings_schema_key_get_default_value(p_key: *SettingsSchemaKey) *glib.Variant;
    pub const getDefaultValue = g_settings_schema_key_get_default_value;

    /// Gets the description for `key`.
    ///
    /// If no description has been provided in the schema for `key`, returns
    /// `NULL`.
    ///
    /// The description can be one sentence to several paragraphs in length.
    /// Paragraphs are delimited with a double newline.  Descriptions can be
    /// translated and the value returned from this function is is the
    /// current locale.
    ///
    /// This function is slow.  The summary and description information for
    /// the schemas is not stored in the compiled schema database so this
    /// function has to parse all of the source XML files in the schema
    /// directory.
    extern fn g_settings_schema_key_get_description(p_key: *SettingsSchemaKey) ?[*:0]const u8;
    pub const getDescription = g_settings_schema_key_get_description;

    /// Gets the name of `key`.
    extern fn g_settings_schema_key_get_name(p_key: *SettingsSchemaKey) [*:0]const u8;
    pub const getName = g_settings_schema_key_get_name;

    /// Queries the range of a key.
    ///
    /// This function will return a `glib.Variant` that fully describes the range
    /// of values that are valid for `key`.
    ///
    /// The type of `glib.Variant` returned is `(sv)`. The string describes
    /// the type of range restriction in effect. The type and meaning of
    /// the value contained in the variant depends on the string.
    ///
    /// If the string is `'type'` then the variant contains an empty array.
    /// The element type of that empty array is the expected type of value
    /// and all values of that type are valid.
    ///
    /// If the string is `'enum'` then the variant contains an array
    /// enumerating the possible values. Each item in the array is
    /// a possible valid value and no other values are valid.
    ///
    /// If the string is `'flags'` then the variant contains an array. Each
    /// item in the array is a value that may appear zero or one times in an
    /// array to be used as the value for this key. For example, if the
    /// variant contained the array `['x', 'y']` then the valid values for
    /// the key would be `[]`, `['x']`, `['y']`, `['x', 'y']` and
    /// `['y', 'x']`.
    ///
    /// Finally, if the string is `'range'` then the variant contains a pair
    /// of like-typed values -- the minimum and maximum permissible values
    /// for this key.
    ///
    /// This information should not be used by normal programs.  It is
    /// considered to be a hint for introspection purposes.  Normal programs
    /// should already know what is permitted by their own schema.  The
    /// format may change in any way in the future -- but particularly, new
    /// forms may be added to the possibilities described above.
    ///
    /// You should free the returned value with `glib.Variant.unref` when it is
    /// no longer needed.
    extern fn g_settings_schema_key_get_range(p_key: *SettingsSchemaKey) *glib.Variant;
    pub const getRange = g_settings_schema_key_get_range;

    /// Gets the summary for `key`.
    ///
    /// If no summary has been provided in the schema for `key`, returns
    /// `NULL`.
    ///
    /// The summary is a short description of the purpose of the key; usually
    /// one short sentence.  Summaries can be translated and the value
    /// returned from this function is is the current locale.
    ///
    /// This function is slow.  The summary and description information for
    /// the schemas is not stored in the compiled schema database so this
    /// function has to parse all of the source XML files in the schema
    /// directory.
    extern fn g_settings_schema_key_get_summary(p_key: *SettingsSchemaKey) ?[*:0]const u8;
    pub const getSummary = g_settings_schema_key_get_summary;

    /// Gets the `glib.VariantType` of `key`.
    extern fn g_settings_schema_key_get_value_type(p_key: *SettingsSchemaKey) *const glib.VariantType;
    pub const getValueType = g_settings_schema_key_get_value_type;

    /// Checks if the given `value` is within the
    /// permitted range for `key`.
    ///
    /// It is a programmer error if `value` is not of the correct type — you
    /// must check for this first.
    extern fn g_settings_schema_key_range_check(p_key: *SettingsSchemaKey, p_value: *glib.Variant) c_int;
    pub const rangeCheck = g_settings_schema_key_range_check;

    /// Increase the reference count of `key`, returning a new reference.
    extern fn g_settings_schema_key_ref(p_key: *SettingsSchemaKey) *gio.SettingsSchemaKey;
    pub const ref = g_settings_schema_key_ref;

    /// Decrease the reference count of `key`, possibly freeing it.
    extern fn g_settings_schema_key_unref(p_key: *SettingsSchemaKey) void;
    pub const unref = g_settings_schema_key_unref;

    extern fn g_settings_schema_key_get_type() usize;
    pub const getGObjectType = g_settings_schema_key_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// This is an opaque structure type.  You may not access it directly.
pub const SettingsSchemaSource = opaque {
    /// Gets the default system schema source.
    ///
    /// This function is not required for normal uses of `gio.Settings` but it
    /// may be useful to authors of plugin management systems or to those who
    /// want to introspect the content of schemas.
    ///
    /// If no schemas are installed, `NULL` will be returned.
    ///
    /// The returned source may actually consist of multiple schema sources
    /// from different directories, depending on which directories were given
    /// in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
    /// lookups performed against the default source should probably be done
    /// recursively.
    extern fn g_settings_schema_source_get_default() ?*gio.SettingsSchemaSource;
    pub const getDefault = g_settings_schema_source_get_default;

    /// Attempts to create a new schema source corresponding to the contents
    /// of the given directory.
    ///
    /// This function is not required for normal uses of `gio.Settings` but it
    /// may be useful to authors of plugin management systems.
    ///
    /// The directory should contain a file called `gschemas.compiled` as
    /// produced by the [glib-compile-schemas][glib-compile-schemas] tool.
    ///
    /// If `trusted` is `TRUE` then `gschemas.compiled` is trusted not to be
    /// corrupted. This assumption has a performance advantage, but can result
    /// in crashes or inconsistent behaviour in the case of a corrupted file.
    /// Generally, you should set `trusted` to `TRUE` for files installed by the
    /// system and to `FALSE` for files in the home directory.
    ///
    /// In either case, an empty file or some types of corruption in the file will
    /// result in `G_FILE_ERROR_INVAL` being returned.
    ///
    /// If `parent` is non-`NULL` then there are two effects.
    ///
    /// First, if `gio.SettingsSchemaSource.lookup` is called with the
    /// `recursive` flag set to `TRUE` and the schema can not be found in the
    /// source, the lookup will recurse to the parent.
    ///
    /// Second, any references to other schemas specified within this
    /// source (ie: `child` or `extends`) references may be resolved
    /// from the `parent`.
    ///
    /// For this second reason, except in very unusual situations, the
    /// `parent` should probably be given as the default schema source, as
    /// returned by `gio.settingsSchemaSourceGetDefault`.
    extern fn g_settings_schema_source_new_from_directory(p_directory: [*:0]const u8, p_parent: ?*gio.SettingsSchemaSource, p_trusted: c_int, p_error: ?*?*glib.Error) ?*gio.SettingsSchemaSource;
    pub const newFromDirectory = g_settings_schema_source_new_from_directory;

    /// Lists the schemas in a given source.
    ///
    /// If `recursive` is `TRUE` then include parent sources.  If `FALSE` then
    /// only include the schemas from one source (ie: one directory).  You
    /// probably want `TRUE`.
    ///
    /// Non-relocatable schemas are those for which you can call
    /// `gio.Settings.new`.  Relocatable schemas are those for which you must
    /// use `gio.Settings.newWithPath`.
    ///
    /// Do not call this function from normal programs.  This is designed for
    /// use by database editors, commandline tools, etc.
    extern fn g_settings_schema_source_list_schemas(p_source: *SettingsSchemaSource, p_recursive: c_int, p_non_relocatable: *[*][*:0]u8, p_relocatable: *[*][*:0]u8) void;
    pub const listSchemas = g_settings_schema_source_list_schemas;

    /// Looks up a schema with the identifier `schema_id` in `source`.
    ///
    /// This function is not required for normal uses of `gio.Settings` but it
    /// may be useful to authors of plugin management systems or to those who
    /// want to introspect the content of schemas.
    ///
    /// If the schema isn't found directly in `source` and `recursive` is `TRUE`
    /// then the parent sources will also be checked.
    ///
    /// If the schema isn't found, `NULL` is returned.
    extern fn g_settings_schema_source_lookup(p_source: *SettingsSchemaSource, p_schema_id: [*:0]const u8, p_recursive: c_int) ?*gio.SettingsSchema;
    pub const lookup = g_settings_schema_source_lookup;

    /// Increase the reference count of `source`, returning a new reference.
    extern fn g_settings_schema_source_ref(p_source: *SettingsSchemaSource) *gio.SettingsSchemaSource;
    pub const ref = g_settings_schema_source_ref;

    /// Decrease the reference count of `source`, possibly freeing it.
    extern fn g_settings_schema_source_unref(p_source: *SettingsSchemaSource) void;
    pub const unref = g_settings_schema_source_unref;

    extern fn g_settings_schema_source_get_type() usize;
    pub const getGObjectType = g_settings_schema_source_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SimpleActionGroupClass = extern struct {
    pub const Instance = gio.SimpleActionGroup;

    f_parent_class: gobject.ObjectClass,
    f_padding: [12]*anyopaque,

    pub fn as(p_instance: *SimpleActionGroupClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SimpleActionGroupPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SimpleAsyncResultClass = opaque {
    pub const Instance = gio.SimpleAsyncResult;

    pub fn as(p_instance: *SimpleAsyncResultClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SimpleProxyResolverClass = extern struct {
    pub const Instance = gio.SimpleProxyResolver;

    f_parent_class: gobject.ObjectClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SimpleProxyResolverClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SimpleProxyResolverPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SocketAddressClass = extern struct {
    pub const Instance = gio.SocketAddress;

    f_parent_class: gobject.ObjectClass,
    f_get_family: ?*const fn (p_address: *gio.SocketAddress) callconv(.c) gio.SocketFamily,
    f_get_native_size: ?*const fn (p_address: *gio.SocketAddress) callconv(.c) isize,
    f_to_native: ?*const fn (p_address: *gio.SocketAddress, p_dest: ?*anyopaque, p_destlen: usize, p_error: ?*?*glib.Error) callconv(.c) c_int,

    pub fn as(p_instance: *SocketAddressClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.SocketAddressEnumerator`.
pub const SocketAddressEnumeratorClass = extern struct {
    pub const Instance = gio.SocketAddressEnumerator;

    f_parent_class: gobject.ObjectClass,
    /// Virtual method for `gio.SocketAddressEnumerator.next`.
    f_next: ?*const fn (p_enumerator: *gio.SocketAddressEnumerator, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.SocketAddress,
    /// Virtual method for `gio.SocketAddressEnumerator.nextAsync`.
    f_next_async: ?*const fn (p_enumerator: *gio.SocketAddressEnumerator, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Virtual method for `gio.SocketAddressEnumerator.nextFinish`.
    f_next_finish: ?*const fn (p_enumerator: *gio.SocketAddressEnumerator, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.SocketAddress,

    pub fn as(p_instance: *SocketAddressEnumeratorClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SocketClass = extern struct {
    pub const Instance = gio.Socket;

    f_parent_class: gobject.ObjectClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,
    f__g_reserved6: ?*const fn () callconv(.c) void,
    f__g_reserved7: ?*const fn () callconv(.c) void,
    f__g_reserved8: ?*const fn () callconv(.c) void,
    f__g_reserved9: ?*const fn () callconv(.c) void,
    f__g_reserved10: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SocketClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SocketClientClass = extern struct {
    pub const Instance = gio.SocketClient;

    f_parent_class: gobject.ObjectClass,
    f_event: ?*const fn (p_client: *gio.SocketClient, p_event: gio.SocketClientEvent, p_connectable: *gio.SocketConnectable, p_connection: *gio.IOStream) callconv(.c) void,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SocketClientClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SocketClientPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Provides an interface for returning a `gio.SocketAddressEnumerator`
/// and `gio.ProxyAddressEnumerator`
pub const SocketConnectableIface = extern struct {
    pub const Instance = gio.SocketConnectable;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Creates a `gio.SocketAddressEnumerator`
    f_enumerate: ?*const fn (p_connectable: *gio.SocketConnectable) callconv(.c) *gio.SocketAddressEnumerator,
    /// Creates a `gio.ProxyAddressEnumerator`
    f_proxy_enumerate: ?*const fn (p_connectable: *gio.SocketConnectable) callconv(.c) *gio.SocketAddressEnumerator,
    /// Format the connectable’s address as a string for debugging.
    ///    Implementing this is optional. (Since: 2.48)
    f_to_string: ?*const fn (p_connectable: *gio.SocketConnectable) callconv(.c) [*:0]u8,

    pub fn as(p_instance: *SocketConnectableIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SocketConnectionClass = extern struct {
    pub const Instance = gio.SocketConnection;

    f_parent_class: gio.IOStreamClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,
    f__g_reserved6: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SocketConnectionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SocketConnectionPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.SocketControlMessage`.
pub const SocketControlMessageClass = extern struct {
    pub const Instance = gio.SocketControlMessage;

    f_parent_class: gobject.ObjectClass,
    /// gets the size of the message.
    f_get_size: ?*const fn (p_message: *gio.SocketControlMessage) callconv(.c) usize,
    /// gets the protocol of the message.
    f_get_level: ?*const fn (p_message: *gio.SocketControlMessage) callconv(.c) c_int,
    /// gets the protocol specific type of the message.
    f_get_type: ?*const fn (p_message: *gio.SocketControlMessage) callconv(.c) c_int,
    /// Writes out the message data.
    f_serialize: ?*const fn (p_message: *gio.SocketControlMessage, p_data: *anyopaque) callconv(.c) void,
    /// Tries to deserialize a message.
    f_deserialize: ?*const fn (p_level: c_int, p_type: c_int, p_size: usize, p_data: *anyopaque) callconv(.c) *gio.SocketControlMessage,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SocketControlMessageClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SocketControlMessagePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.SocketListener`.
pub const SocketListenerClass = extern struct {
    pub const Instance = gio.SocketListener;

    f_parent_class: gobject.ObjectClass,
    /// virtual method called when the set of socket listened to changes
    f_changed: ?*const fn (p_listener: *gio.SocketListener) callconv(.c) void,
    f_event: ?*const fn (p_listener: *gio.SocketListener, p_event: gio.SocketListenerEvent, p_socket: *gio.Socket) callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,
    f__g_reserved6: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SocketListenerClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SocketListenerPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SocketPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.SocketService`.
pub const SocketServiceClass = extern struct {
    pub const Instance = gio.SocketService;

    f_parent_class: gio.SocketListenerClass,
    /// signal emitted when new connections are accepted
    f_incoming: ?*const fn (p_service: *gio.SocketService, p_connection: *gio.SocketConnection, p_source_object: *gobject.Object) callconv(.c) c_int,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,
    f__g_reserved6: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *SocketServiceClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const SocketServicePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A single target host/port that a network service is running on.
///
/// SRV (service) records are used by some network protocols to provide
/// service-specific aliasing and load-balancing. For example, XMPP
/// (Jabber) uses SRV records to locate the XMPP server for a domain;
/// rather than connecting directly to ‘example.com’ or assuming a
/// specific server hostname like ‘xmpp.example.com’, an XMPP client
/// would look up the `xmpp-client` SRV record for ‘example.com’, and
/// then connect to whatever host was pointed to by that record.
///
/// You can use `gio.Resolver.lookupService` or
/// `gio.Resolver.lookupServiceAsync` to find the `GSrvTarget`s
/// for a given service. However, if you are simply planning to connect
/// to the remote service, you can use `gio.NetworkService`’s
/// `gio.SocketConnectable` interface and not need to worry about
/// `GSrvTarget` at all.
pub const SrvTarget = opaque {
    /// Sorts `targets` in place according to the algorithm in RFC 2782.
    extern fn g_srv_target_list_sort(p_targets: *glib.List) *glib.List;
    pub const listSort = g_srv_target_list_sort;

    /// Creates a new `gio.SrvTarget` with the given parameters.
    ///
    /// You should not need to use this; normally `GSrvTargets` are
    /// created by `gio.Resolver`.
    extern fn g_srv_target_new(p_hostname: [*:0]const u8, p_port: u16, p_priority: u16, p_weight: u16) *gio.SrvTarget;
    pub const new = g_srv_target_new;

    /// Copies `target`
    extern fn g_srv_target_copy(p_target: *SrvTarget) *gio.SrvTarget;
    pub const copy = g_srv_target_copy;

    /// Frees `target`
    extern fn g_srv_target_free(p_target: *SrvTarget) void;
    pub const free = g_srv_target_free;

    /// Gets `target`'s hostname (in ASCII form; if you are going to present
    /// this to the user, you should use `glib.hostnameIsAsciiEncoded` to
    /// check if it contains encoded Unicode segments, and use
    /// `glib.hostnameToUnicode` to convert it if it does.)
    extern fn g_srv_target_get_hostname(p_target: *SrvTarget) [*:0]const u8;
    pub const getHostname = g_srv_target_get_hostname;

    /// Gets `target`'s port
    extern fn g_srv_target_get_port(p_target: *SrvTarget) u16;
    pub const getPort = g_srv_target_get_port;

    /// Gets `target`'s priority. You should not need to look at this;
    /// `gio.Resolver` already sorts the targets according to the algorithm in
    /// RFC 2782.
    extern fn g_srv_target_get_priority(p_target: *SrvTarget) u16;
    pub const getPriority = g_srv_target_get_priority;

    /// Gets `target`'s weight. You should not need to look at this;
    /// `gio.Resolver` already sorts the targets according to the algorithm in
    /// RFC 2782.
    extern fn g_srv_target_get_weight(p_target: *SrvTarget) u16;
    pub const getWeight = g_srv_target_get_weight;

    extern fn g_srv_target_get_type() usize;
    pub const getGObjectType = g_srv_target_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `GStaticResource` is an opaque data structure and can only be accessed
/// using the following functions.
pub const StaticResource = extern struct {
    f_data: ?*const u8,
    f_data_len: usize,
    f_resource: ?*gio.Resource,
    f_next: ?*gio.StaticResource,
    f_padding: ?*anyopaque,

    /// Finalizes a `gio.Resource` initialized by
    /// `gio.StaticResource.init`.
    ///
    /// This is normally used by code generated by
    /// [`glib-compile-resources`](glib-compile-resources.html)
    /// and is not typically used by other code.
    extern fn g_static_resource_fini(p_static_resource: *StaticResource) void;
    pub const fini = g_static_resource_fini;

    /// Gets the `gio.Resource` that was registered by a call to
    /// `gio.StaticResource.init`.
    ///
    /// This is normally used by code generated by
    /// [`glib-compile-resources`](glib-compile-resources.html)
    /// and is not typically used by other code.
    extern fn g_static_resource_get_resource(p_static_resource: *StaticResource) *gio.Resource;
    pub const getResource = g_static_resource_get_resource;

    /// Initializes a `gio.Resource` from static data using a
    /// `gio.StaticResource`.
    ///
    /// This is normally used by code generated by
    /// [`glib-compile-resources`](glib-compile-resources.html)
    /// and is not typically used by other code.
    extern fn g_static_resource_init(p_static_resource: *StaticResource) void;
    pub const init = g_static_resource_init;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TaskClass = opaque {
    pub const Instance = gio.Task;

    pub fn as(p_instance: *TaskClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TcpConnectionClass = extern struct {
    pub const Instance = gio.TcpConnection;

    f_parent_class: gio.SocketConnectionClass,

    pub fn as(p_instance: *TcpConnectionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TcpConnectionPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TcpWrapperConnectionClass = extern struct {
    pub const Instance = gio.TcpWrapperConnection;

    f_parent_class: gio.TcpConnectionClass,

    pub fn as(p_instance: *TcpWrapperConnectionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TcpWrapperConnectionPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ThemedIconClass = opaque {
    pub const Instance = gio.ThemedIcon;

    pub fn as(p_instance: *ThemedIconClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ThreadedResolverClass = extern struct {
    pub const Instance = gio.ThreadedResolver;

    f_parent_class: gio.ResolverClass,

    pub fn as(p_instance: *ThreadedResolverClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ThreadedSocketServiceClass = extern struct {
    pub const Instance = gio.ThreadedSocketService;

    f_parent_class: gio.SocketServiceClass,
    f_run: ?*const fn (p_service: *gio.ThreadedSocketService, p_connection: *gio.SocketConnection, p_source_object: *gobject.Object) callconv(.c) c_int,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *ThreadedSocketServiceClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ThreadedSocketServicePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Provides an interface for describing TLS-related types.
pub const TlsBackendInterface = extern struct {
    pub const Instance = gio.TlsBackend;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// returns whether the backend supports TLS.
    f_supports_tls: ?*const fn (p_backend: *gio.TlsBackend) callconv(.c) c_int,
    /// returns the `gio.TlsCertificate` implementation type
    f_get_certificate_type: ?*const fn () callconv(.c) usize,
    /// returns the `gio.TlsClientConnection` implementation type
    f_get_client_connection_type: ?*const fn () callconv(.c) usize,
    /// returns the `gio.TlsServerConnection` implementation type
    f_get_server_connection_type: ?*const fn () callconv(.c) usize,
    /// returns the `gio.TlsFileDatabase` implementation type.
    f_get_file_database_type: ?*const fn () callconv(.c) usize,
    /// returns a default `gio.TlsDatabase` instance.
    f_get_default_database: ?*const fn (p_backend: *gio.TlsBackend) callconv(.c) *gio.TlsDatabase,
    /// returns whether the backend supports DTLS
    f_supports_dtls: ?*const fn (p_backend: *gio.TlsBackend) callconv(.c) c_int,
    /// returns the `gio.DtlsClientConnection` implementation type
    f_get_dtls_client_connection_type: ?*const fn () callconv(.c) usize,
    /// returns the `gio.DtlsServerConnection` implementation type
    f_get_dtls_server_connection_type: ?*const fn () callconv(.c) usize,

    pub fn as(p_instance: *TlsBackendInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TlsCertificateClass = extern struct {
    pub const Instance = gio.TlsCertificate;

    f_parent_class: gobject.ObjectClass,
    f_verify: ?*const fn (p_cert: *gio.TlsCertificate, p_identity: ?*gio.SocketConnectable, p_trusted_ca: ?*gio.TlsCertificate) callconv(.c) gio.TlsCertificateFlags,
    f_padding: [8]*anyopaque,

    pub fn as(p_instance: *TlsCertificateClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TlsCertificatePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// vtable for a `gio.TlsClientConnection` implementation.
pub const TlsClientConnectionInterface = extern struct {
    pub const Instance = gio.TlsClientConnection;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Copies session state from one `gio.TlsClientConnection` to another.
    f_copy_session_state: ?*const fn (p_conn: *gio.TlsClientConnection, p_source: *gio.TlsClientConnection) callconv(.c) void,

    pub fn as(p_instance: *TlsClientConnectionInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The class structure for the `gio.TlsConnection` type.
pub const TlsConnectionClass = extern struct {
    pub const Instance = gio.TlsConnection;

    /// The parent class.
    f_parent_class: gio.IOStreamClass,
    /// Check whether to accept a certificate.
    f_accept_certificate: ?*const fn (p_connection: *gio.TlsConnection, p_peer_cert: *gio.TlsCertificate, p_errors: gio.TlsCertificateFlags) callconv(.c) c_int,
    /// Perform a handshake operation.
    f_handshake: ?*const fn (p_conn: *gio.TlsConnection, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Start an asynchronous handshake operation.
    f_handshake_async: ?*const fn (p_conn: *gio.TlsConnection, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finish an asynchronous handshake operation.
    f_handshake_finish: ?*const fn (p_conn: *gio.TlsConnection, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Retrieve TLS channel binding data (Since: 2.66)
    f_get_binding_data: ?*const fn (p_conn: *gio.TlsConnection, p_type: gio.TlsChannelBindingType, p_data: *glib.ByteArray, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Get ALPN-negotiated protocol (Since: 2.70)
    f_get_negotiated_protocol: ?*const fn (p_conn: *gio.TlsConnection) callconv(.c) ?[*:0]const u8,
    f_padding: [6]*anyopaque,

    pub fn as(p_instance: *TlsConnectionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TlsConnectionPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The class for `gio.TlsDatabase`. Derived classes should implement the various
/// virtual methods. _async and _finish methods have a default
/// implementation that runs the corresponding sync method in a thread.
pub const TlsDatabaseClass = extern struct {
    pub const Instance = gio.TlsDatabase;

    f_parent_class: gobject.ObjectClass,
    /// Virtual method implementing
    ///  `gio.TlsDatabase.verifyChain`.
    f_verify_chain: ?*const fn (p_self: *gio.TlsDatabase, p_chain: *gio.TlsCertificate, p_purpose: [*:0]const u8, p_identity: ?*gio.SocketConnectable, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseVerifyFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) gio.TlsCertificateFlags,
    /// Virtual method implementing
    ///  `gio.TlsDatabase.verifyChainAsync`.
    f_verify_chain_async: ?*const fn (p_self: *gio.TlsDatabase, p_chain: *gio.TlsCertificate, p_purpose: [*:0]const u8, p_identity: ?*gio.SocketConnectable, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseVerifyFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Virtual method implementing
    ///  `gio.TlsDatabase.verifyChainFinish`.
    f_verify_chain_finish: ?*const fn (p_self: *gio.TlsDatabase, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) gio.TlsCertificateFlags,
    /// Virtual method implementing
    ///  `gio.TlsDatabase.createCertificateHandle`.
    f_create_certificate_handle: ?*const fn (p_self: *gio.TlsDatabase, p_certificate: *gio.TlsCertificate) callconv(.c) ?[*:0]u8,
    /// Virtual method implementing
    ///  `gio.TlsDatabase.lookupCertificateForHandle`.
    f_lookup_certificate_for_handle: ?*const fn (p_self: *gio.TlsDatabase, p_handle: [*:0]const u8, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.TlsCertificate,
    /// Virtual method implementing
    ///  `gio.TlsDatabase.lookupCertificateForHandleAsync`.
    f_lookup_certificate_for_handle_async: ?*const fn (p_self: *gio.TlsDatabase, p_handle: [*:0]const u8, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Virtual method implementing
    ///  `gio.TlsDatabase.lookupCertificateForHandleFinish`.
    f_lookup_certificate_for_handle_finish: ?*const fn (p_self: *gio.TlsDatabase, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.TlsCertificate,
    /// Virtual method implementing
    ///  `gio.TlsDatabase.lookupCertificateIssuer`.
    f_lookup_certificate_issuer: ?*const fn (p_self: *gio.TlsDatabase, p_certificate: *gio.TlsCertificate, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*gio.TlsCertificate,
    /// Virtual method implementing
    ///  `gio.TlsDatabase.lookupCertificateIssuerAsync`.
    f_lookup_certificate_issuer_async: ?*const fn (p_self: *gio.TlsDatabase, p_certificate: *gio.TlsCertificate, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Virtual method implementing
    ///  `gio.TlsDatabase.lookupCertificateIssuerFinish`.
    f_lookup_certificate_issuer_finish: ?*const fn (p_self: *gio.TlsDatabase, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*gio.TlsCertificate,
    /// Virtual method implementing
    ///  `gio.TlsDatabase.lookupCertificatesIssuedBy`.
    f_lookup_certificates_issued_by: ?*const fn (p_self: *gio.TlsDatabase, p_issuer_raw_dn: *glib.ByteArray, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List,
    /// Virtual method implementing
    ///  `gio.TlsDatabase.lookupCertificatesIssuedByAsync`.
    f_lookup_certificates_issued_by_async: ?*const fn (p_self: *gio.TlsDatabase, p_issuer_raw_dn: *glib.ByteArray, p_interaction: ?*gio.TlsInteraction, p_flags: gio.TlsDatabaseLookupFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Virtual method implementing
    ///  `gio.TlsDatabase.lookupCertificatesIssuedByFinish`.
    f_lookup_certificates_issued_by_finish: ?*const fn (p_self: *gio.TlsDatabase, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) ?*glib.List,
    f_padding: [16]*anyopaque,

    pub fn as(p_instance: *TlsDatabaseClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TlsDatabasePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Provides an interface for `gio.TlsFileDatabase` implementations.
pub const TlsFileDatabaseInterface = extern struct {
    pub const Instance = gio.TlsFileDatabase;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    f_padding: [8]*anyopaque,

    pub fn as(p_instance: *TlsFileDatabaseInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The class for `gio.TlsInteraction`. Derived classes implement the various
/// virtual interaction methods to handle TLS interactions.
///
/// Derived classes can choose to implement whichever interactions methods they'd
/// like to support by overriding those virtual methods in their class
/// initialization function. If a derived class implements an async method,
/// it must also implement the corresponding finish method.
///
/// The synchronous interaction methods should implement to display modal dialogs,
/// and the asynchronous methods to display modeless dialogs.
///
/// If the user cancels an interaction, then the result should be
/// `G_TLS_INTERACTION_FAILED` and the error should be set with a domain of
/// `G_IO_ERROR` and code of `G_IO_ERROR_CANCELLED`.
pub const TlsInteractionClass = extern struct {
    pub const Instance = gio.TlsInteraction;

    f_parent_class: gobject.ObjectClass,
    /// ask for a password synchronously. If the implementation
    ///     returns `G_TLS_INTERACTION_HANDLED`, then the password argument should
    ///     have been filled in by using `gio.TlsPassword.setValue` or a similar
    ///     function.
    f_ask_password: ?*const fn (p_interaction: *gio.TlsInteraction, p_password: *gio.TlsPassword, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) gio.TlsInteractionResult,
    /// ask for a password asynchronously.
    f_ask_password_async: ?*const fn (p_interaction: *gio.TlsInteraction, p_password: *gio.TlsPassword, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// complete operation to ask for a password asynchronously.
    ///     If the implementation returns `G_TLS_INTERACTION_HANDLED`, then the
    ///     password argument of the async method should have been filled in by using
    ///     `gio.TlsPassword.setValue` or a similar function.
    f_ask_password_finish: ?*const fn (p_interaction: *gio.TlsInteraction, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) gio.TlsInteractionResult,
    /// ask for a certificate synchronously. If the
    ///     implementation returns `G_TLS_INTERACTION_HANDLED`, then the connection
    ///     argument should have been filled in by using
    ///     `gio.TlsConnection.setCertificate`.
    f_request_certificate: ?*const fn (p_interaction: *gio.TlsInteraction, p_connection: *gio.TlsConnection, p_flags: gio.TlsCertificateRequestFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) gio.TlsInteractionResult,
    /// ask for a certificate asynchronously.
    f_request_certificate_async: ?*const fn (p_interaction: *gio.TlsInteraction, p_connection: *gio.TlsConnection, p_flags: gio.TlsCertificateRequestFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// complete operation to ask for a certificate
    ///     asynchronously. If the implementation returns `G_TLS_INTERACTION_HANDLED`,
    ///     then the connection argument of the async method should have been
    ///     filled in by using `gio.TlsConnection.setCertificate`.
    f_request_certificate_finish: ?*const fn (p_interaction: *gio.TlsInteraction, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) gio.TlsInteractionResult,
    f_padding: [21]*anyopaque,

    pub fn as(p_instance: *TlsInteractionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TlsInteractionPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.TlsPassword`.
pub const TlsPasswordClass = extern struct {
    pub const Instance = gio.TlsPassword;

    f_parent_class: gobject.ObjectClass,
    /// virtual method for `gio.TlsPassword.getValue`
    f_get_value: ?*const fn (p_password: *gio.TlsPassword, p_length: ?*usize) callconv(.c) [*]const u8,
    /// virtual method for `gio.TlsPassword.setValue`
    f_set_value: ?*const fn (p_password: *gio.TlsPassword, p_value: [*]u8, p_length: isize, p_destroy: ?glib.DestroyNotify) callconv(.c) void,
    /// virtual method for `gio.TlsPassword.getWarning` if no
    ///  value has been set using `gio.TlsPassword.setWarning`
    f_get_default_warning: ?*const fn (p_password: *gio.TlsPassword) callconv(.c) [*:0]const u8,
    f_padding: [4]*anyopaque,

    pub fn as(p_instance: *TlsPasswordClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const TlsPasswordPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// vtable for a `gio.TlsServerConnection` implementation.
pub const TlsServerConnectionInterface = extern struct {
    pub const Instance = gio.TlsServerConnection;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,

    pub fn as(p_instance: *TlsServerConnectionInterface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UnixConnectionClass = extern struct {
    pub const Instance = gio.UnixConnection;

    f_parent_class: gio.SocketConnectionClass,

    pub fn as(p_instance: *UnixConnectionClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UnixConnectionPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Class structure for `gio.UnixCredentialsMessage`.
pub const UnixCredentialsMessageClass = extern struct {
    pub const Instance = gio.UnixCredentialsMessage;

    f_parent_class: gio.SocketControlMessageClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *UnixCredentialsMessageClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UnixCredentialsMessagePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UnixFDListClass = extern struct {
    pub const Instance = gio.UnixFDList;

    f_parent_class: gobject.ObjectClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *UnixFDListClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UnixFDListPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UnixFDMessageClass = extern struct {
    pub const Instance = gio.UnixFDMessage;

    f_parent_class: gio.SocketControlMessageClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *UnixFDMessageClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UnixFDMessagePrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UnixInputStreamClass = extern struct {
    pub const Instance = gio.UnixInputStream;

    f_parent_class: gio.InputStreamClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *UnixInputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UnixInputStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Defines a Unix mount entry (e.g. `/media/cdrom`).
/// This corresponds roughly to a mtab entry.
pub const UnixMountEntry = opaque {
    /// Gets a `giounix.MountEntry` for a given mount path.
    ///
    /// If `time_read` is set, it will be filled with a Unix timestamp for checking
    /// if the mounts have changed since with
    /// `GioUnix.mountEntriesChangedSince`.
    ///
    /// If more mounts have the same mount path, the last matching mount
    /// is returned.
    ///
    /// This will return `NULL` if there is no mount point at `mount_path`.
    extern fn g_unix_mount_entry_at(p_mount_path: [*:0]const u8, p_time_read: ?*u64) ?*gio.UnixMountEntry;
    pub const at = g_unix_mount_entry_at;

    /// Gets a `giounix.MountEntry` for a given file path.
    ///
    /// If `time_read` is set, it will be filled with a Unix timestamp for checking
    /// if the mounts have changed since with
    /// `GioUnix.mountEntriesChangedSince`.
    ///
    /// If more mounts have the same mount path, the last matching mount
    /// is returned.
    ///
    /// This will return `NULL` if looking up the mount entry fails, if
    /// `file_path` doesn’t exist or there is an I/O error.
    extern fn g_unix_mount_entry_for(p_file_path: [*:0]const u8, p_time_read: ?*u64) ?*gio.UnixMountEntry;
    pub const @"for" = g_unix_mount_entry_for;

    /// Compares two Unix mounts.
    extern fn g_unix_mount_entry_compare(p_mount1: *UnixMountEntry, p_mount2: *gio.UnixMountEntry) c_int;
    pub const compare = g_unix_mount_entry_compare;

    /// Makes a copy of `mount_entry`.
    extern fn g_unix_mount_entry_copy(p_mount_entry: *UnixMountEntry) *gio.UnixMountEntry;
    pub const copy = g_unix_mount_entry_copy;

    /// Frees a Unix mount.
    extern fn g_unix_mount_entry_free(p_mount_entry: *UnixMountEntry) void;
    pub const free = g_unix_mount_entry_free;

    /// Gets the device path for a Unix mount.
    extern fn g_unix_mount_entry_get_device_path(p_mount_entry: *UnixMountEntry) [*:0]const u8;
    pub const getDevicePath = g_unix_mount_entry_get_device_path;

    /// Gets the filesystem type for the Unix mount.
    extern fn g_unix_mount_entry_get_fs_type(p_mount_entry: *UnixMountEntry) [*:0]const u8;
    pub const getFsType = g_unix_mount_entry_get_fs_type;

    /// Gets the mount path for a Unix mount.
    extern fn g_unix_mount_entry_get_mount_path(p_mount_entry: *UnixMountEntry) [*:0]const u8;
    pub const getMountPath = g_unix_mount_entry_get_mount_path;

    /// Gets a comma separated list of mount options for the Unix mount.
    ///
    /// For example: `rw,relatime,seclabel,data=ordered`.
    ///
    /// This is similar to `giounix.MountPoint.getOptions`, but it takes
    /// a `giounix.MountEntry` as an argument.
    extern fn g_unix_mount_entry_get_options(p_mount_entry: *UnixMountEntry) ?[*:0]const u8;
    pub const getOptions = g_unix_mount_entry_get_options;

    /// Gets the root of the mount within the filesystem. This is useful e.g. for
    /// mounts created by bind operation, or btrfs subvolumes.
    ///
    /// For example, the root path is equal to `/` for a mount created by
    /// `mount /dev/sda1 /mnt/foo` and `/bar` for
    /// `mount --bind /mnt/foo/bar /mnt/bar`.
    extern fn g_unix_mount_entry_get_root_path(p_mount_entry: *UnixMountEntry) ?[*:0]const u8;
    pub const getRootPath = g_unix_mount_entry_get_root_path;

    /// Guesses whether a Unix mount entry can be ejected.
    extern fn g_unix_mount_entry_guess_can_eject(p_mount_entry: *UnixMountEntry) c_int;
    pub const guessCanEject = g_unix_mount_entry_guess_can_eject;

    /// Guesses the icon of a Unix mount entry.
    extern fn g_unix_mount_entry_guess_icon(p_mount_entry: *UnixMountEntry) *gio.Icon;
    pub const guessIcon = g_unix_mount_entry_guess_icon;

    /// Guesses the name of a Unix mount entry.
    ///
    /// The result is a translated string.
    extern fn g_unix_mount_entry_guess_name(p_mount_entry: *UnixMountEntry) [*:0]u8;
    pub const guessName = g_unix_mount_entry_guess_name;

    /// Guesses whether a Unix mount entry should be displayed in the UI.
    extern fn g_unix_mount_entry_guess_should_display(p_mount_entry: *UnixMountEntry) c_int;
    pub const guessShouldDisplay = g_unix_mount_entry_guess_should_display;

    /// Guesses the symbolic icon of a Unix mount entry.
    extern fn g_unix_mount_entry_guess_symbolic_icon(p_mount_entry: *UnixMountEntry) *gio.Icon;
    pub const guessSymbolicIcon = g_unix_mount_entry_guess_symbolic_icon;

    /// Checks if a Unix mount is mounted read only.
    extern fn g_unix_mount_entry_is_readonly(p_mount_entry: *UnixMountEntry) c_int;
    pub const isReadonly = g_unix_mount_entry_is_readonly;

    /// Checks if a Unix mount is a system mount.
    ///
    /// This is the Boolean OR of
    /// `GioUnix.isSystemFsType`, `GioUnix.isSystemDevicePath` and
    /// `GioUnix.isMountPathSystemInternal` on `mount_entry`’s properties.
    ///
    /// The definition of what a ‘system’ mount entry is may change over time as new
    /// file system types and device paths are ignored.
    extern fn g_unix_mount_entry_is_system_internal(p_mount_entry: *UnixMountEntry) c_int;
    pub const isSystemInternal = g_unix_mount_entry_is_system_internal;

    extern fn g_unix_mount_entry_get_type() usize;
    pub const getGObjectType = g_unix_mount_entry_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UnixMountMonitorClass = opaque {
    pub const Instance = gio.UnixMountMonitor;

    pub fn as(p_instance: *UnixMountMonitorClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Defines a Unix mount point (e.g. `/dev`).
/// This corresponds roughly to a fstab entry.
pub const UnixMountPoint = opaque {
    /// Gets a `giounix.MountPoint` for a given mount path.
    ///
    /// If `time_read` is set, it will be filled with a Unix timestamp for checking if
    /// the mount points have changed since with
    /// `GioUnix.mountPointsChangedSince`.
    ///
    /// If more mount points have the same mount path, the last matching mount point
    /// is returned.
    extern fn g_unix_mount_point_at(p_mount_path: [*:0]const u8, p_time_read: ?*u64) ?*gio.UnixMountPoint;
    pub const at = g_unix_mount_point_at;

    /// Compares two Unix mount points.
    extern fn g_unix_mount_point_compare(p_mount1: *UnixMountPoint, p_mount2: *gio.UnixMountPoint) c_int;
    pub const compare = g_unix_mount_point_compare;

    /// Makes a copy of `mount_point`.
    extern fn g_unix_mount_point_copy(p_mount_point: *UnixMountPoint) *gio.UnixMountPoint;
    pub const copy = g_unix_mount_point_copy;

    /// Frees a Unix mount point.
    extern fn g_unix_mount_point_free(p_mount_point: *UnixMountPoint) void;
    pub const free = g_unix_mount_point_free;

    /// Gets the device path for a Unix mount point.
    extern fn g_unix_mount_point_get_device_path(p_mount_point: *UnixMountPoint) [*:0]const u8;
    pub const getDevicePath = g_unix_mount_point_get_device_path;

    /// Gets the file system type for the mount point.
    extern fn g_unix_mount_point_get_fs_type(p_mount_point: *UnixMountPoint) [*:0]const u8;
    pub const getFsType = g_unix_mount_point_get_fs_type;

    /// Gets the mount path for a Unix mount point.
    extern fn g_unix_mount_point_get_mount_path(p_mount_point: *UnixMountPoint) [*:0]const u8;
    pub const getMountPath = g_unix_mount_point_get_mount_path;

    /// Gets the options for the mount point.
    extern fn g_unix_mount_point_get_options(p_mount_point: *UnixMountPoint) ?[*:0]const u8;
    pub const getOptions = g_unix_mount_point_get_options;

    /// Guesses whether a Unix mount point can be ejected.
    extern fn g_unix_mount_point_guess_can_eject(p_mount_point: *UnixMountPoint) c_int;
    pub const guessCanEject = g_unix_mount_point_guess_can_eject;

    /// Guesses the icon of a Unix mount point.
    extern fn g_unix_mount_point_guess_icon(p_mount_point: *UnixMountPoint) *gio.Icon;
    pub const guessIcon = g_unix_mount_point_guess_icon;

    /// Guesses the name of a Unix mount point.
    ///
    /// The result is a translated string.
    extern fn g_unix_mount_point_guess_name(p_mount_point: *UnixMountPoint) [*:0]u8;
    pub const guessName = g_unix_mount_point_guess_name;

    /// Guesses the symbolic icon of a Unix mount point.
    extern fn g_unix_mount_point_guess_symbolic_icon(p_mount_point: *UnixMountPoint) *gio.Icon;
    pub const guessSymbolicIcon = g_unix_mount_point_guess_symbolic_icon;

    /// Checks if a Unix mount point is a loopback device.
    extern fn g_unix_mount_point_is_loopback(p_mount_point: *UnixMountPoint) c_int;
    pub const isLoopback = g_unix_mount_point_is_loopback;

    /// Checks if a Unix mount point is read only.
    extern fn g_unix_mount_point_is_readonly(p_mount_point: *UnixMountPoint) c_int;
    pub const isReadonly = g_unix_mount_point_is_readonly;

    /// Checks if a Unix mount point is mountable by the user.
    extern fn g_unix_mount_point_is_user_mountable(p_mount_point: *UnixMountPoint) c_int;
    pub const isUserMountable = g_unix_mount_point_is_user_mountable;

    extern fn g_unix_mount_point_get_type() usize;
    pub const getGObjectType = g_unix_mount_point_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UnixOutputStreamClass = extern struct {
    pub const Instance = gio.UnixOutputStream;

    f_parent_class: gio.OutputStreamClass,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *UnixOutputStreamClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UnixOutputStreamPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UnixSocketAddressClass = extern struct {
    pub const Instance = gio.UnixSocketAddress;

    f_parent_class: gio.SocketAddressClass,

    pub fn as(p_instance: *UnixSocketAddressClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const UnixSocketAddressPrivate = opaque {
    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const VfsClass = extern struct {
    pub const Instance = gio.Vfs;

    f_parent_class: gobject.ObjectClass,
    f_is_active: ?*const fn (p_vfs: *gio.Vfs) callconv(.c) c_int,
    f_get_file_for_path: ?*const fn (p_vfs: *gio.Vfs, p_path: [*:0]const u8) callconv(.c) *gio.File,
    f_get_file_for_uri: ?*const fn (p_vfs: *gio.Vfs, p_uri: [*:0]const u8) callconv(.c) *gio.File,
    f_get_supported_uri_schemes: ?*const fn (p_vfs: *gio.Vfs) callconv(.c) [*]const [*:0]const u8,
    f_parse_name: ?*const fn (p_vfs: *gio.Vfs, p_parse_name: [*:0]const u8) callconv(.c) *gio.File,
    f_local_file_add_info: ?*const fn (p_vfs: *gio.Vfs, p_filename: [*:0]const u8, p_device: u64, p_attribute_matcher: *gio.FileAttributeMatcher, p_info: *gio.FileInfo, p_cancellable: ?*gio.Cancellable, p_extra_data: ?*anyopaque, p_free_extra_data: *glib.DestroyNotify) callconv(.c) void,
    f_add_writable_namespaces: ?*const fn (p_vfs: *gio.Vfs, p_list: *gio.FileAttributeInfoList) callconv(.c) void,
    f_local_file_set_attributes: ?*const fn (p_vfs: *gio.Vfs, p_filename: [*:0]const u8, p_info: *gio.FileInfo, p_flags: gio.FileQueryInfoFlags, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) callconv(.c) c_int,
    f_local_file_removed: ?*const fn (p_vfs: *gio.Vfs, p_filename: [*:0]const u8) callconv(.c) void,
    f_local_file_moved: ?*const fn (p_vfs: *gio.Vfs, p_source: [*:0]const u8, p_dest: [*:0]const u8) callconv(.c) void,
    f_deserialize_icon: ?*const fn (p_vfs: *gio.Vfs, p_value: *glib.Variant) callconv(.c) *gio.Icon,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,
    f__g_reserved6: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *VfsClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Interface for implementing operations for mountable volumes.
pub const VolumeIface = extern struct {
    pub const Instance = gio.Volume;

    /// The parent interface.
    f_g_iface: gobject.TypeInterface,
    /// Changed signal that is emitted when the volume's state has changed.
    f_changed: ?*const fn (p_volume: *gio.Volume) callconv(.c) void,
    /// The removed signal that is emitted when the `gio.Volume` have been removed. If the recipient is holding references to the object they should release them so the object can be finalized.
    f_removed: ?*const fn (p_volume: *gio.Volume) callconv(.c) void,
    /// Gets a string containing the name of the `gio.Volume`.
    f_get_name: ?*const fn (p_volume: *gio.Volume) callconv(.c) [*:0]u8,
    /// Gets a `gio.Icon` for the `gio.Volume`.
    f_get_icon: ?*const fn (p_volume: *gio.Volume) callconv(.c) *gio.Icon,
    /// Gets the UUID for the `gio.Volume`. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns `NULL` if there is no UUID available.
    f_get_uuid: ?*const fn (p_volume: *gio.Volume) callconv(.c) ?[*:0]u8,
    /// Gets a `gio.Drive` the volume is located on. Returns `NULL` if the `gio.Volume` is not associated with a `gio.Drive`.
    f_get_drive: ?*const fn (p_volume: *gio.Volume) callconv(.c) ?*gio.Drive,
    /// Gets a `gio.Mount` representing the mounted volume. Returns `NULL` if the `gio.Volume` is not mounted.
    f_get_mount: ?*const fn (p_volume: *gio.Volume) callconv(.c) ?*gio.Mount,
    /// Returns `TRUE` if the `gio.Volume` can be mounted.
    f_can_mount: ?*const fn (p_volume: *gio.Volume) callconv(.c) c_int,
    /// Checks if a `gio.Volume` can be ejected.
    f_can_eject: ?*const fn (p_volume: *gio.Volume) callconv(.c) c_int,
    /// Mounts a given `gio.Volume`.
    ///     `gio.Volume` implementations must emit the `gio.MountOperation.signals.aborted`
    ///     signal before completing a mount operation that is aborted while
    ///     awaiting input from the user through a `gio.MountOperation` instance.
    f_mount_fn: ?*const fn (p_volume: *gio.Volume, p_flags: gio.MountMountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes a mount operation.
    f_mount_finish: ?*const fn (p_volume: *gio.Volume, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Ejects a given `gio.Volume`.
    f_eject: ?*const fn (p_volume: *gio.Volume, p_flags: gio.MountUnmountFlags, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an eject operation.
    f_eject_finish: ?*const fn (p_volume: *gio.Volume, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Returns the [identifier](`volume`-identifiers) of the given kind, or `NULL` if
    ///    the `gio.Volume` doesn't have one.
    f_get_identifier: ?*const fn (p_volume: *gio.Volume, p_kind: [*:0]const u8) callconv(.c) ?[*:0]u8,
    /// Returns an array strings listing the kinds
    ///    of [identifiers](`volume`-identifiers) which the `gio.Volume` has.
    f_enumerate_identifiers: ?*const fn (p_volume: *gio.Volume) callconv(.c) [*][*:0]u8,
    /// Returns `TRUE` if the `gio.Volume` should be automatically mounted.
    f_should_automount: ?*const fn (p_volume: *gio.Volume) callconv(.c) c_int,
    /// Returns the activation root for the `gio.Volume` if it is known in advance or `NULL` if
    ///   it is not known.
    f_get_activation_root: ?*const fn (p_volume: *gio.Volume) callconv(.c) ?*gio.File,
    /// Starts ejecting a `gio.Volume` using a `gio.MountOperation`. Since 2.22.
    f_eject_with_operation: ?*const fn (p_volume: *gio.Volume, p_flags: gio.MountUnmountFlags, p_mount_operation: ?*gio.MountOperation, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) callconv(.c) void,
    /// Finishes an eject operation using a `gio.MountOperation`. Since 2.22.
    f_eject_with_operation_finish: ?*const fn (p_volume: *gio.Volume, p_result: *gio.AsyncResult, p_error: ?*?*glib.Error) callconv(.c) c_int,
    /// Gets a key used for sorting `gio.Volume` instance or `NULL` if no such key exists. Since 2.32.
    f_get_sort_key: ?*const fn (p_volume: *gio.Volume) callconv(.c) ?[*:0]const u8,
    /// Gets a symbolic `gio.Icon` for the `gio.Volume`. Since 2.34.
    f_get_symbolic_icon: ?*const fn (p_volume: *gio.Volume) callconv(.c) *gio.Icon,

    pub fn as(p_instance: *VolumeIface, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const VolumeMonitorClass = extern struct {
    pub const Instance = gio.VolumeMonitor;

    f_parent_class: gobject.ObjectClass,
    f_volume_added: ?*const fn (p_volume_monitor: *gio.VolumeMonitor, p_volume: *gio.Volume) callconv(.c) void,
    f_volume_removed: ?*const fn (p_volume_monitor: *gio.VolumeMonitor, p_volume: *gio.Volume) callconv(.c) void,
    f_volume_changed: ?*const fn (p_volume_monitor: *gio.VolumeMonitor, p_volume: *gio.Volume) callconv(.c) void,
    f_mount_added: ?*const fn (p_volume_monitor: *gio.VolumeMonitor, p_mount: *gio.Mount) callconv(.c) void,
    f_mount_removed: ?*const fn (p_volume_monitor: *gio.VolumeMonitor, p_mount: *gio.Mount) callconv(.c) void,
    f_mount_pre_unmount: ?*const fn (p_volume_monitor: *gio.VolumeMonitor, p_mount: *gio.Mount) callconv(.c) void,
    f_mount_changed: ?*const fn (p_volume_monitor: *gio.VolumeMonitor, p_mount: *gio.Mount) callconv(.c) void,
    f_drive_connected: ?*const fn (p_volume_monitor: *gio.VolumeMonitor, p_drive: *gio.Drive) callconv(.c) void,
    f_drive_disconnected: ?*const fn (p_volume_monitor: *gio.VolumeMonitor, p_drive: *gio.Drive) callconv(.c) void,
    f_drive_changed: ?*const fn (p_volume_monitor: *gio.VolumeMonitor, p_drive: *gio.Drive) callconv(.c) void,
    f_is_supported: ?*const fn () callconv(.c) c_int,
    f_get_connected_drives: ?*const fn (p_volume_monitor: *gio.VolumeMonitor) callconv(.c) *glib.List,
    f_get_volumes: ?*const fn (p_volume_monitor: *gio.VolumeMonitor) callconv(.c) *glib.List,
    f_get_mounts: ?*const fn (p_volume_monitor: *gio.VolumeMonitor) callconv(.c) *glib.List,
    f_get_volume_for_uuid: ?*const fn (p_volume_monitor: *gio.VolumeMonitor, p_uuid: [*:0]const u8) callconv(.c) ?*gio.Volume,
    f_get_mount_for_uuid: ?*const fn (p_volume_monitor: *gio.VolumeMonitor, p_uuid: [*:0]const u8) callconv(.c) ?*gio.Mount,
    f_adopt_orphan_mount: ?*const fn (p_mount: *gio.Mount, p_volume_monitor: *gio.VolumeMonitor) callconv(.c) *gio.Volume,
    f_drive_eject_button: ?*const fn (p_volume_monitor: *gio.VolumeMonitor, p_drive: *gio.Drive) callconv(.c) void,
    f_drive_stop_button: ?*const fn (p_volume_monitor: *gio.VolumeMonitor, p_drive: *gio.Drive) callconv(.c) void,
    f__g_reserved1: ?*const fn () callconv(.c) void,
    f__g_reserved2: ?*const fn () callconv(.c) void,
    f__g_reserved3: ?*const fn () callconv(.c) void,
    f__g_reserved4: ?*const fn () callconv(.c) void,
    f__g_reserved5: ?*const fn () callconv(.c) void,
    f__g_reserved6: ?*const fn () callconv(.c) void,

    pub fn as(p_instance: *VolumeMonitorClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ZlibCompressorClass = extern struct {
    pub const Instance = gio.ZlibCompressor;

    f_parent_class: gobject.ObjectClass,

    pub fn as(p_instance: *ZlibCompressorClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

pub const ZlibDecompressorClass = extern struct {
    pub const Instance = gio.ZlibDecompressor;

    f_parent_class: gobject.ObjectClass,

    pub fn as(p_instance: *ZlibDecompressorClass, comptime P_T: type) *P_T {
        return gobject.ext.as(P_T, p_instance);
    }

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// An enumeration for well-known message buses.
pub const BusType = enum(c_int) {
    starter = -1,
    none = 0,
    system = 1,
    session = 2,
    _,

    extern fn g_bus_type_get_type() usize;
    pub const getGObjectType = g_bus_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Results returned from `gio.Converter.convert`.
pub const ConverterResult = enum(c_int) {
    @"error" = 0,
    converted = 1,
    finished = 2,
    flushed = 3,
    _,

    extern fn g_converter_result_get_type() usize;
    pub const getGObjectType = g_converter_result_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Enumeration describing different kinds of native credential types.
pub const CredentialsType = enum(c_int) {
    invalid = 0,
    linux_ucred = 1,
    freebsd_cmsgcred = 2,
    openbsd_sockpeercred = 3,
    solaris_ucred = 4,
    netbsd_unpcbid = 5,
    apple_xucred = 6,
    win32_pid = 7,
    _,

    extern fn g_credentials_type_get_type() usize;
    pub const getGObjectType = g_credentials_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Error codes for the `G_DBUS_ERROR` error domain.
pub const DBusError = enum(c_int) {
    failed = 0,
    no_memory = 1,
    service_unknown = 2,
    name_has_no_owner = 3,
    no_reply = 4,
    io_error = 5,
    bad_address = 6,
    not_supported = 7,
    limits_exceeded = 8,
    access_denied = 9,
    auth_failed = 10,
    no_server = 11,
    timeout = 12,
    no_network = 13,
    address_in_use = 14,
    disconnected = 15,
    invalid_args = 16,
    file_not_found = 17,
    file_exists = 18,
    unknown_method = 19,
    timed_out = 20,
    match_rule_not_found = 21,
    match_rule_invalid = 22,
    spawn_exec_failed = 23,
    spawn_fork_failed = 24,
    spawn_child_exited = 25,
    spawn_child_signaled = 26,
    spawn_failed = 27,
    spawn_setup_failed = 28,
    spawn_config_invalid = 29,
    spawn_service_invalid = 30,
    spawn_service_not_found = 31,
    spawn_permissions_invalid = 32,
    spawn_file_invalid = 33,
    spawn_no_memory = 34,
    unix_process_id_unknown = 35,
    invalid_signature = 36,
    invalid_file_content = 37,
    selinux_security_context_unknown = 38,
    adt_audit_data_unknown = 39,
    object_path_in_use = 40,
    unknown_object = 41,
    unknown_interface = 42,
    unknown_property = 43,
    property_read_only = 44,
    _,

    /// Creates a D-Bus error name to use for `error`. If `error` matches
    /// a registered error (cf. `gio.dbusErrorRegisterError`), the corresponding
    /// D-Bus error name will be returned.
    ///
    /// Otherwise the a name of the form
    /// `org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE`
    /// will be used. This allows other GDBus applications to map the error
    /// on the wire back to a `glib.Error` using `gio.dbusErrorNewForDbusError`.
    ///
    /// This function is typically only used in object mappings to put a
    /// `glib.Error` on the wire. Regular applications should not use it.
    extern fn g_dbus_error_encode_gerror(p_error: *const glib.Error) [*:0]u8;
    pub const encodeGerror = g_dbus_error_encode_gerror;

    /// Gets the D-Bus error name used for `error`, if any.
    ///
    /// This function is guaranteed to return a D-Bus error name for all
    /// `GErrors` returned from functions handling remote method calls
    /// (e.g. `gio.DBusConnection.callFinish`) unless
    /// `gio.dbusErrorStripRemoteError` has been used on `error`.
    extern fn g_dbus_error_get_remote_error(p_error: *const glib.Error) ?[*:0]u8;
    pub const getRemoteError = g_dbus_error_get_remote_error;

    /// Checks if `error` represents an error received via D-Bus from a remote peer. If so,
    /// use `gio.dbusErrorGetRemoteError` to get the name of the error.
    extern fn g_dbus_error_is_remote_error(p_error: *const glib.Error) c_int;
    pub const isRemoteError = g_dbus_error_is_remote_error;

    /// Creates a `glib.Error` based on the contents of `dbus_error_name` and
    /// `dbus_error_message`.
    ///
    /// Errors registered with `gio.dbusErrorRegisterError` will be looked
    /// up using `dbus_error_name` and if a match is found, the error domain
    /// and code is used. Applications can use `gio.dbusErrorGetRemoteError`
    /// to recover `dbus_error_name`.
    ///
    /// If a match against a registered error is not found and the D-Bus
    /// error name is in a form as returned by `gio.dbusErrorEncodeGerror`
    /// the error domain and code encoded in the name is used to
    /// create the `glib.Error`. Also, `dbus_error_name` is added to the error message
    /// such that it can be recovered with `gio.dbusErrorGetRemoteError`.
    ///
    /// Otherwise, a `glib.Error` with the error code `G_IO_ERROR_DBUS_ERROR`
    /// in the `G_IO_ERROR` error domain is returned. Also, `dbus_error_name` is
    /// added to the error message such that it can be recovered with
    /// `gio.dbusErrorGetRemoteError`.
    ///
    /// In all three cases, `dbus_error_name` can always be recovered from the
    /// returned `glib.Error` using the `gio.dbusErrorGetRemoteError` function
    /// (unless `gio.dbusErrorStripRemoteError` hasn't been used on the returned error).
    ///
    /// This function is typically only used in object mappings to prepare
    /// `glib.Error` instances for applications. Regular applications should not use
    /// it.
    extern fn g_dbus_error_new_for_dbus_error(p_dbus_error_name: [*:0]const u8, p_dbus_error_message: [*:0]const u8) *glib.Error;
    pub const newForDbusError = g_dbus_error_new_for_dbus_error;

    extern fn g_dbus_error_quark() glib.Quark;
    pub const quark = g_dbus_error_quark;

    /// Creates an association to map between `dbus_error_name` and
    /// `GErrors` specified by `error_domain` and `error_code`.
    ///
    /// This is typically done in the routine that returns the `glib.Quark` for
    /// an error domain.
    extern fn g_dbus_error_register_error(p_error_domain: glib.Quark, p_error_code: c_int, p_dbus_error_name: [*:0]const u8) c_int;
    pub const registerError = g_dbus_error_register_error;

    /// Helper function for associating a `glib.Error` error domain with D-Bus error names.
    ///
    /// While `quark_volatile` has a `volatile` qualifier, this is a historical
    /// artifact and the argument passed to it should not be `volatile`.
    extern fn g_dbus_error_register_error_domain(p_error_domain_quark_name: [*:0]const u8, p_quark_volatile: *usize, p_entries: [*]const gio.DBusErrorEntry, p_num_entries: c_uint) void;
    pub const registerErrorDomain = g_dbus_error_register_error_domain;

    /// Does nothing if `error` is `NULL`. Otherwise sets `*error` to
    /// a new `glib.Error` created with `gio.dbusErrorNewForDbusError`
    /// with `dbus_error_message` prepend with `format` (unless `NULL`).
    extern fn g_dbus_error_set_dbus_error(p_error: **glib.Error, p_dbus_error_name: [*:0]const u8, p_dbus_error_message: [*:0]const u8, p_format: ?[*:0]const u8, ...) void;
    pub const setDbusError = g_dbus_error_set_dbus_error;

    /// Like `gio.DBusError.setDbusError` but intended for language bindings.
    extern fn g_dbus_error_set_dbus_error_valist(p_error: **glib.Error, p_dbus_error_name: [*:0]const u8, p_dbus_error_message: [*:0]const u8, p_format: ?[*:0]const u8, p_var_args: std.builtin.VaList) void;
    pub const setDbusErrorValist = g_dbus_error_set_dbus_error_valist;

    /// Looks for extra information in the error message used to recover
    /// the D-Bus error name and strips it if found. If stripped, the
    /// message field in `error` will correspond exactly to what was
    /// received on the wire.
    ///
    /// This is typically used when presenting errors to the end user.
    extern fn g_dbus_error_strip_remote_error(p_error: *glib.Error) c_int;
    pub const stripRemoteError = g_dbus_error_strip_remote_error;

    /// Destroys an association previously set up with `gio.dbusErrorRegisterError`.
    extern fn g_dbus_error_unregister_error(p_error_domain: glib.Quark, p_error_code: c_int, p_dbus_error_name: [*:0]const u8) c_int;
    pub const unregisterError = g_dbus_error_unregister_error;

    extern fn g_dbus_error_get_type() usize;
    pub const getGObjectType = g_dbus_error_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Enumeration used to describe the byte order of a D-Bus message.
pub const DBusMessageByteOrder = enum(c_int) {
    big_endian = 66,
    little_endian = 108,
    _,

    extern fn g_dbus_message_byte_order_get_type() usize;
    pub const getGObjectType = g_dbus_message_byte_order_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Header fields used in `gio.DBusMessage`.
pub const DBusMessageHeaderField = enum(c_int) {
    invalid = 0,
    path = 1,
    interface = 2,
    member = 3,
    error_name = 4,
    reply_serial = 5,
    destination = 6,
    sender = 7,
    signature = 8,
    num_unix_fds = 9,
    _,

    extern fn g_dbus_message_header_field_get_type() usize;
    pub const getGObjectType = g_dbus_message_header_field_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Message types used in `gio.DBusMessage`.
pub const DBusMessageType = enum(c_int) {
    invalid = 0,
    method_call = 1,
    method_return = 2,
    @"error" = 3,
    signal = 4,
    _,

    extern fn g_dbus_message_type_get_type() usize;
    pub const getGObjectType = g_dbus_message_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gio.DataStreamByteOrder` is used to ensure proper endianness of streaming data sources
/// across various machine architectures.
pub const DataStreamByteOrder = enum(c_int) {
    big_endian = 0,
    little_endian = 1,
    host_endian = 2,
    _,

    extern fn g_data_stream_byte_order_get_type() usize;
    pub const getGObjectType = g_data_stream_byte_order_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gio.DataStreamNewlineType` is used when checking for or setting the line endings for a given file.
pub const DataStreamNewlineType = enum(c_int) {
    lf = 0,
    cr = 1,
    cr_lf = 2,
    any = 3,
    _,

    extern fn g_data_stream_newline_type_get_type() usize;
    pub const getGObjectType = g_data_stream_newline_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Enumeration describing how a drive can be started/stopped.
pub const DriveStartStopType = enum(c_int) {
    unknown = 0,
    shutdown = 1,
    network = 2,
    multidisk = 3,
    password = 4,
    _,

    extern fn g_drive_start_stop_type_get_type() usize;
    pub const getGObjectType = g_drive_start_stop_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GEmblemOrigin is used to add information about the origin of the emblem
/// to `gio.Emblem`.
pub const EmblemOrigin = enum(c_int) {
    unknown = 0,
    device = 1,
    livemetadata = 2,
    tag = 3,
    _,

    extern fn g_emblem_origin_get_type() usize;
    pub const getGObjectType = g_emblem_origin_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used by `gio.File.setAttributesFromInfo` when setting file attributes.
pub const FileAttributeStatus = enum(c_int) {
    unset = 0,
    set = 1,
    error_setting = 2,
    _,

    extern fn g_file_attribute_status_get_type() usize;
    pub const getGObjectType = g_file_attribute_status_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The data types for file attributes.
pub const FileAttributeType = enum(c_int) {
    invalid = 0,
    string = 1,
    byte_string = 2,
    boolean = 3,
    uint32 = 4,
    int32 = 5,
    uint64 = 6,
    int64 = 7,
    object = 8,
    stringv = 9,
    _,

    extern fn g_file_attribute_type_get_type() usize;
    pub const getGObjectType = g_file_attribute_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Specifies what type of event a monitor event is.
pub const FileMonitorEvent = enum(c_int) {
    changed = 0,
    changes_done_hint = 1,
    deleted = 2,
    created = 3,
    attribute_changed = 4,
    pre_unmount = 5,
    unmounted = 6,
    moved = 7,
    renamed = 8,
    moved_in = 9,
    moved_out = 10,
    _,

    extern fn g_file_monitor_event_get_type() usize;
    pub const getGObjectType = g_file_monitor_event_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Indicates the file's on-disk type.
///
/// On Windows systems a file will never have `G_FILE_TYPE_SYMBOLIC_LINK` type;
/// use `gio.FileInfo` and `G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK` to determine
/// whether a file is a symlink or not. This is due to the fact that NTFS does
/// not have a single filesystem object type for symbolic links - it has
/// files that symlink to files, and directories that symlink to directories.
/// `gio.FileType` enumeration cannot precisely represent this important distinction,
/// which is why all Windows symlinks will continue to be reported as
/// `G_FILE_TYPE_REGULAR` or `G_FILE_TYPE_DIRECTORY`.
pub const FileType = enum(c_int) {
    unknown = 0,
    regular = 1,
    directory = 2,
    symbolic_link = 3,
    special = 4,
    shortcut = 5,
    mountable = 6,
    _,

    extern fn g_file_type_get_type() usize;
    pub const getGObjectType = g_file_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Indicates a hint from the file system whether files should be
/// previewed in a file manager. Returned as the value of the key
/// `G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW`.
pub const FilesystemPreviewType = enum(c_int) {
    if_always = 0,
    if_local = 1,
    never = 2,
    _,

    extern fn g_filesystem_preview_type_get_type() usize;
    pub const getGObjectType = g_filesystem_preview_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Error codes returned by GIO functions.
///
/// Note that this domain may be extended in future GLib releases. In
/// general, new error codes either only apply to new APIs, or else
/// replace `G_IO_ERROR_FAILED` in cases that were not explicitly
/// distinguished before. You should therefore avoid writing code like
/// ```
/// if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
///   {
///     // Assume that this is EPRINTERONFIRE
///     ...
///   }
/// ```
/// but should instead treat all unrecognized error codes the same as
/// `G_IO_ERROR_FAILED`.
///
/// See also `gio.PollableReturn` for a cheaper way of returning
/// `G_IO_ERROR_WOULD_BLOCK` to callers without allocating a `glib.Error`.
pub const IOErrorEnum = enum(c_int) {
    failed = 0,
    not_found = 1,
    exists = 2,
    is_directory = 3,
    not_directory = 4,
    not_empty = 5,
    not_regular_file = 6,
    not_symbolic_link = 7,
    not_mountable_file = 8,
    filename_too_long = 9,
    invalid_filename = 10,
    too_many_links = 11,
    no_space = 12,
    invalid_argument = 13,
    permission_denied = 14,
    not_supported = 15,
    not_mounted = 16,
    already_mounted = 17,
    closed = 18,
    cancelled = 19,
    pending = 20,
    read_only = 21,
    cant_create_backup = 22,
    wrong_etag = 23,
    timed_out = 24,
    would_recurse = 25,
    busy = 26,
    would_block = 27,
    host_not_found = 28,
    would_merge = 29,
    failed_handled = 30,
    too_many_open_files = 31,
    not_initialized = 32,
    address_in_use = 33,
    partial_input = 34,
    invalid_data = 35,
    dbus_error = 36,
    host_unreachable = 37,
    network_unreachable = 38,
    connection_refused = 39,
    proxy_failed = 40,
    proxy_auth_failed = 41,
    proxy_need_auth = 42,
    proxy_not_allowed = 43,
    broken_pipe = 44,
    not_connected = 45,
    message_too_large = 46,
    no_such_device = 47,
    destination_unset = 48,
    _,

    pub const connection_closed = IOErrorEnum.broken_pipe;
    extern fn g_io_error_enum_get_type() usize;
    pub const getGObjectType = g_io_error_enum_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags for use with `gio.IOModuleScope.new`.
pub const IOModuleScopeFlags = enum(c_int) {
    none = 0,
    block_duplicates = 1,
    _,

    extern fn g_io_module_scope_flags_get_type() usize;
    pub const getGObjectType = g_io_module_scope_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Memory availability warning levels.
///
/// Note that because new values might be added, it is recommended that applications check
/// `gio.MemoryMonitorWarningLevel` as ranges, for example:
/// ```
/// if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
///   drop_caches ();
/// ```
pub const MemoryMonitorWarningLevel = enum(c_int) {
    low = 50,
    medium = 100,
    critical = 255,
    _,

    extern fn g_memory_monitor_warning_level_get_type() usize;
    pub const getGObjectType = g_memory_monitor_warning_level_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gio.MountOperationResult` is returned as a result when a request for
/// information is send by the mounting operation.
pub const MountOperationResult = enum(c_int) {
    handled = 0,
    aborted = 1,
    unhandled = 2,
    _,

    extern fn g_mount_operation_result_get_type() usize;
    pub const getGObjectType = g_mount_operation_result_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The host's network connectivity state, as reported by `gio.NetworkMonitor`.
pub const NetworkConnectivity = enum(c_int) {
    local = 1,
    limited = 2,
    portal = 3,
    full = 4,
    _,

    extern fn g_network_connectivity_get_type() usize;
    pub const getGObjectType = g_network_connectivity_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Priority levels for `GNotifications`.
pub const NotificationPriority = enum(c_int) {
    normal = 0,
    low = 1,
    high = 2,
    urgent = 3,
    _,

    extern fn g_notification_priority_get_type() usize;
    pub const getGObjectType = g_notification_priority_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gio.PasswordSave` is used to indicate the lifespan of a saved password.
///
/// `Gvfs` stores passwords in the Gnome keyring when this flag allows it
/// to, and later retrieves it again from there.
pub const PasswordSave = enum(c_int) {
    never = 0,
    for_session = 1,
    permanently = 2,
    _,

    extern fn g_password_save_get_type() usize;
    pub const getGObjectType = g_password_save_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Return value for various IO operations that signal errors via the
/// return value and not necessarily via a `glib.Error`.
///
/// This enum exists to be able to return errors to callers without having to
/// allocate a `glib.Error`. Allocating `GErrors` can be quite expensive for
/// regularly happening errors like `G_IO_ERROR_WOULD_BLOCK`.
///
/// In case of `G_POLLABLE_RETURN_FAILED` a `glib.Error` should be set for the
/// operation to give details about the error that happened.
pub const PollableReturn = enum(c_int) {
    failed = 0,
    ok = 1,
    would_block = -27,
    _,

    extern fn g_pollable_return_get_type() usize;
    pub const getGObjectType = g_pollable_return_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// An error code used with `G_RESOLVER_ERROR` in a `glib.Error` returned
/// from a `gio.Resolver` routine.
pub const ResolverError = enum(c_int) {
    not_found = 0,
    temporary_failure = 1,
    internal = 2,
    _,

    /// Gets the `gio.Resolver` Error Quark.
    extern fn g_resolver_error_quark() glib.Quark;
    pub const quark = g_resolver_error_quark;

    extern fn g_resolver_error_get_type() usize;
    pub const getGObjectType = g_resolver_error_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The type of record that `gio.Resolver.lookupRecords` or
/// `gio.Resolver.lookupRecordsAsync` should retrieve. The records are returned
/// as lists of `glib.Variant` tuples. Each record type has different values in
/// the variant tuples returned.
///
/// `G_RESOLVER_RECORD_SRV` records are returned as variants with the signature
/// `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
/// weight, a `guint16` with the port, and a string of the hostname.
///
/// `G_RESOLVER_RECORD_MX` records are returned as variants with the signature
/// `(qs)`, representing a `guint16` with the preference, and a string containing
/// the mail exchanger hostname.
///
/// `G_RESOLVER_RECORD_TXT` records are returned as variants with the signature
/// `(as)`, representing an array of the strings in the text record. Note: Most TXT
/// records only contain a single string, but
/// [RFC 1035](https://tools.ietf.org/html/rfc1035`section`-3.3.14) does allow a
/// record to contain multiple strings. The RFC which defines the interpretation
/// of a specific TXT record will likely require concatenation of multiple
/// strings if they are present, as with
/// [RFC 7208](https://tools.ietf.org/html/rfc7208`section`-3.3).
///
/// `G_RESOLVER_RECORD_SOA` records are returned as variants with the signature
/// `(ssuuuuu)`, representing a string containing the primary name server, a
/// string containing the administrator, the serial as a `guint32`, the refresh
/// interval as a `guint32`, the retry interval as a `guint32`, the expire timeout
/// as a `guint32`, and the TTL as a `guint32`.
///
/// `G_RESOLVER_RECORD_NS` records are returned as variants with the signature
/// `(s)`, representing a string of the hostname of the name server.
pub const ResolverRecordType = enum(c_int) {
    srv = 1,
    mx = 2,
    txt = 3,
    soa = 4,
    ns = 5,
    _,

    extern fn g_resolver_record_type_get_type() usize;
    pub const getGObjectType = g_resolver_record_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// An error code used with `G_RESOURCE_ERROR` in a `glib.Error` returned
/// from a `gio.Resource` routine.
pub const ResourceError = enum(c_int) {
    not_found = 0,
    internal = 1,
    _,

    /// Gets the `gio.Resource` Error Quark.
    extern fn g_resource_error_quark() glib.Quark;
    pub const quark = g_resource_error_quark;

    extern fn g_resource_error_get_type() usize;
    pub const getGObjectType = g_resource_error_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes an event occurring on a `gio.SocketClient`. See the
/// `gio.SocketClient.signals.event` signal for more details.
///
/// Additional values may be added to this type in the future.
pub const SocketClientEvent = enum(c_int) {
    resolving = 0,
    resolved = 1,
    connecting = 2,
    connected = 3,
    proxy_negotiating = 4,
    proxy_negotiated = 5,
    tls_handshaking = 6,
    tls_handshaked = 7,
    complete = 8,
    _,

    extern fn g_socket_client_event_get_type() usize;
    pub const getGObjectType = g_socket_client_event_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The protocol family of a `gio.SocketAddress`. (These values are
/// identical to the system defines `AF_INET`, `AF_INET6` and `AF_UNIX`,
/// if available.)
pub const SocketFamily = enum(c_int) {
    invalid = 0,
    unix = 1,
    ipv4 = 2,
    ipv6 = 10,
    _,

    extern fn g_socket_family_get_type() usize;
    pub const getGObjectType = g_socket_family_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Describes an event occurring on a `gio.SocketListener`. See the
/// `gio.SocketListener.signals.event` signal for more details.
///
/// Additional values may be added to this type in the future.
pub const SocketListenerEvent = enum(c_int) {
    binding = 0,
    bound = 1,
    listening = 2,
    listened = 3,
    _,

    extern fn g_socket_listener_event_get_type() usize;
    pub const getGObjectType = g_socket_listener_event_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A protocol identifier is specified when creating a `gio.Socket`, which is a
/// family/type specific identifier, where 0 means the default protocol for
/// the particular family/type.
///
/// This enum contains a set of commonly available and used protocols. You
/// can also pass any other identifiers handled by the platform in order to
/// use protocols not listed here.
pub const SocketProtocol = enum(c_int) {
    unknown = -1,
    default = 0,
    tcp = 6,
    udp = 17,
    sctp = 132,
    _,

    extern fn g_socket_protocol_get_type() usize;
    pub const getGObjectType = g_socket_protocol_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when creating a `gio.Socket`. Some protocols may not implement
/// all the socket types.
pub const SocketType = enum(c_int) {
    invalid = 0,
    stream = 1,
    datagram = 2,
    seqpacket = 3,
    _,

    extern fn g_socket_type_get_type() usize;
    pub const getGObjectType = g_socket_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The client authentication mode for a `gio.TlsServerConnection`.
pub const TlsAuthenticationMode = enum(c_int) {
    none = 0,
    requested = 1,
    required = 2,
    _,

    extern fn g_tls_authentication_mode_get_type() usize;
    pub const getGObjectType = g_tls_authentication_mode_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags for `gio.TlsInteraction.requestCertificate`,
/// `gio.TlsInteraction.requestCertificateAsync`, and
/// `gio.TlsInteraction.invokeRequestCertificate`.
pub const TlsCertificateRequestFlags = enum(c_int) {
    none = 0,
    _,

    extern fn g_tls_certificate_request_flags_get_type() usize;
    pub const getGObjectType = g_tls_certificate_request_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// An error code used with `G_TLS_CHANNEL_BINDING_ERROR` in a `glib.Error` to
/// indicate a TLS channel binding retrieval error.
pub const TlsChannelBindingError = enum(c_int) {
    not_implemented = 0,
    invalid_state = 1,
    not_available = 2,
    not_supported = 3,
    general_error = 4,
    _,

    /// Gets the TLS channel binding error quark.
    extern fn g_tls_channel_binding_error_quark() glib.Quark;
    pub const quark = g_tls_channel_binding_error_quark;

    extern fn g_tls_channel_binding_error_get_type() usize;
    pub const getGObjectType = g_tls_channel_binding_error_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The type of TLS channel binding data to retrieve from `gio.TlsConnection`
/// or `gio.DtlsConnection`, as documented by RFC 5929 or RFC 9266. The
/// [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929`section`-5)
/// binding type is not currently implemented.
pub const TlsChannelBindingType = enum(c_int) {
    unique = 0,
    server_end_point = 1,
    exporter = 2,
    _,

    extern fn g_tls_channel_binding_type_get_type() usize;
    pub const getGObjectType = g_tls_channel_binding_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags for `gio.TlsDatabase.lookupCertificateForHandle`,
/// `gio.TlsDatabase.lookupCertificateIssuer`,
/// and `gio.TlsDatabase.lookupCertificatesIssuedBy`.
pub const TlsDatabaseLookupFlags = enum(c_int) {
    none = 0,
    keypair = 1,
    _,

    extern fn g_tls_database_lookup_flags_get_type() usize;
    pub const getGObjectType = g_tls_database_lookup_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// An error code used with `G_TLS_ERROR` in a `glib.Error` returned from a
/// TLS-related routine.
pub const TlsError = enum(c_int) {
    unavailable = 0,
    misc = 1,
    bad_certificate = 2,
    not_tls = 3,
    handshake = 4,
    certificate_required = 5,
    eof = 6,
    inappropriate_fallback = 7,
    bad_certificate_password = 8,
    _,

    /// Gets the TLS error quark.
    extern fn g_tls_error_quark() glib.Quark;
    pub const quark = g_tls_error_quark;

    extern fn g_tls_error_get_type() usize;
    pub const getGObjectType = g_tls_error_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gio.TlsInteractionResult` is returned by various functions in `gio.TlsInteraction`
/// when finishing an interaction request.
pub const TlsInteractionResult = enum(c_int) {
    unhandled = 0,
    handled = 1,
    failed = 2,
    _,

    extern fn g_tls_interaction_result_get_type() usize;
    pub const getGObjectType = g_tls_interaction_result_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The TLS or DTLS protocol version used by a `gio.TlsConnection` or
/// `gio.DtlsConnection`. The integer values of these versions are sequential
/// to ensure newer known protocol versions compare greater than older
/// known versions. Any known DTLS protocol version will compare greater
/// than any SSL or TLS protocol version. The protocol version may be
/// `G_TLS_PROTOCOL_VERSION_UNKNOWN` if the TLS backend supports a newer
/// protocol version that GLib does not yet know about. This means that
/// it's possible for an unknown DTLS protocol version to compare less
/// than the TLS protocol versions.
pub const TlsProtocolVersion = enum(c_int) {
    unknown = 0,
    ssl_3_0 = 1,
    tls_1_0 = 2,
    tls_1_1 = 3,
    tls_1_2 = 4,
    tls_1_3 = 5,
    dtls_1_0 = 201,
    dtls_1_2 = 202,
    _,

    extern fn g_tls_protocol_version_get_type() usize;
    pub const getGObjectType = g_tls_protocol_version_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// When to allow rehandshaking. See
/// `gio.TlsConnection.setRehandshakeMode`.
pub const TlsRehandshakeMode = enum(c_int) {
    never = 0,
    safely = 1,
    unsafely = 2,
    _,

    extern fn g_tls_rehandshake_mode_get_type() usize;
    pub const getGObjectType = g_tls_rehandshake_mode_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// The type of name used by a `gio.UnixSocketAddress`.
/// `G_UNIX_SOCKET_ADDRESS_PATH` indicates a traditional unix domain
/// socket bound to a filesystem path. `G_UNIX_SOCKET_ADDRESS_ANONYMOUS`
/// indicates a socket not bound to any name (eg, a client-side socket,
/// or a socket created with `socketpair`).
///
/// For abstract sockets, there are two incompatible ways of naming
/// them; the man pages suggest using the entire `struct sockaddr_un`
/// as the name, padding the unused parts of the `sun_path` field with
/// zeroes; this corresponds to `G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED`.
/// However, many programs instead just use a portion of `sun_path`, and
/// pass an appropriate smaller length to `bind` or `connect`. This is
/// `G_UNIX_SOCKET_ADDRESS_ABSTRACT`.
pub const UnixSocketAddressType = enum(c_int) {
    invalid = 0,
    anonymous = 1,
    path = 2,
    abstract = 3,
    abstract_padded = 4,
    _,

    extern fn g_unix_socket_address_type_get_type() usize;
    pub const getGObjectType = g_unix_socket_address_type_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Used to select the type of data format to use for `gio.ZlibDecompressor`
/// and `gio.ZlibCompressor`.
pub const ZlibCompressorFormat = enum(c_int) {
    zlib = 0,
    gzip = 1,
    raw = 2,
    _,

    extern fn g_zlib_compressor_format_get_type() usize;
    pub const getGObjectType = g_zlib_compressor_format_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when creating a `gio.AppInfo`.
pub const AppInfoCreateFlags = packed struct(c_uint) {
    needs_terminal: bool = false,
    supports_uris: bool = false,
    supports_startup_notification: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: AppInfoCreateFlags = @bitCast(@as(c_uint, 0));
    pub const flags_needs_terminal: AppInfoCreateFlags = @bitCast(@as(c_uint, 1));
    pub const flags_supports_uris: AppInfoCreateFlags = @bitCast(@as(c_uint, 2));
    pub const flags_supports_startup_notification: AppInfoCreateFlags = @bitCast(@as(c_uint, 4));
    extern fn g_app_info_create_flags_get_type() usize;
    pub const getGObjectType = g_app_info_create_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used to define the behaviour of a `gio.Application`.
pub const ApplicationFlags = packed struct(c_uint) {
    is_service: bool = false,
    is_launcher: bool = false,
    handles_open: bool = false,
    handles_command_line: bool = false,
    send_environment: bool = false,
    non_unique: bool = false,
    can_override_app_id: bool = false,
    allow_replacement: bool = false,
    replace: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_flags_none: ApplicationFlags = @bitCast(@as(c_uint, 0));
    pub const flags_default_flags: ApplicationFlags = @bitCast(@as(c_uint, 0));
    pub const flags_is_service: ApplicationFlags = @bitCast(@as(c_uint, 1));
    pub const flags_is_launcher: ApplicationFlags = @bitCast(@as(c_uint, 2));
    pub const flags_handles_open: ApplicationFlags = @bitCast(@as(c_uint, 4));
    pub const flags_handles_command_line: ApplicationFlags = @bitCast(@as(c_uint, 8));
    pub const flags_send_environment: ApplicationFlags = @bitCast(@as(c_uint, 16));
    pub const flags_non_unique: ApplicationFlags = @bitCast(@as(c_uint, 32));
    pub const flags_can_override_app_id: ApplicationFlags = @bitCast(@as(c_uint, 64));
    pub const flags_allow_replacement: ApplicationFlags = @bitCast(@as(c_uint, 128));
    pub const flags_replace: ApplicationFlags = @bitCast(@as(c_uint, 256));
    extern fn g_application_flags_get_type() usize;
    pub const getGObjectType = g_application_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// `gio.AskPasswordFlags` are used to request specific information from the
/// user, or to notify the user of their choices in an authentication
/// situation.
pub const AskPasswordFlags = packed struct(c_uint) {
    need_password: bool = false,
    need_username: bool = false,
    need_domain: bool = false,
    saving_supported: bool = false,
    anonymous_supported: bool = false,
    tcrypt: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_need_password: AskPasswordFlags = @bitCast(@as(c_uint, 1));
    pub const flags_need_username: AskPasswordFlags = @bitCast(@as(c_uint, 2));
    pub const flags_need_domain: AskPasswordFlags = @bitCast(@as(c_uint, 4));
    pub const flags_saving_supported: AskPasswordFlags = @bitCast(@as(c_uint, 8));
    pub const flags_anonymous_supported: AskPasswordFlags = @bitCast(@as(c_uint, 16));
    pub const flags_tcrypt: AskPasswordFlags = @bitCast(@as(c_uint, 32));
    extern fn g_ask_password_flags_get_type() usize;
    pub const getGObjectType = g_ask_password_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used in `gio.busOwnName`.
pub const BusNameOwnerFlags = packed struct(c_uint) {
    allow_replacement: bool = false,
    replace: bool = false,
    do_not_queue: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: BusNameOwnerFlags = @bitCast(@as(c_uint, 0));
    pub const flags_allow_replacement: BusNameOwnerFlags = @bitCast(@as(c_uint, 1));
    pub const flags_replace: BusNameOwnerFlags = @bitCast(@as(c_uint, 2));
    pub const flags_do_not_queue: BusNameOwnerFlags = @bitCast(@as(c_uint, 4));
    extern fn g_bus_name_owner_flags_get_type() usize;
    pub const getGObjectType = g_bus_name_owner_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used in `gio.busWatchName`.
pub const BusNameWatcherFlags = packed struct(c_uint) {
    auto_start: bool = false,
    _padding1: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: BusNameWatcherFlags = @bitCast(@as(c_uint, 0));
    pub const flags_auto_start: BusNameWatcherFlags = @bitCast(@as(c_uint, 1));
    extern fn g_bus_name_watcher_flags_get_type() usize;
    pub const getGObjectType = g_bus_name_watcher_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when calling a `gio.Converter.convert`.
pub const ConverterFlags = packed struct(c_uint) {
    input_at_end: bool = false,
    flush: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: ConverterFlags = @bitCast(@as(c_uint, 0));
    pub const flags_input_at_end: ConverterFlags = @bitCast(@as(c_uint, 1));
    pub const flags_flush: ConverterFlags = @bitCast(@as(c_uint, 2));
    extern fn g_converter_flags_get_type() usize;
    pub const getGObjectType = g_converter_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used in `gio.DBusConnection.call` and similar APIs.
pub const DBusCallFlags = packed struct(c_uint) {
    no_auto_start: bool = false,
    allow_interactive_authorization: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: DBusCallFlags = @bitCast(@as(c_uint, 0));
    pub const flags_no_auto_start: DBusCallFlags = @bitCast(@as(c_uint, 1));
    pub const flags_allow_interactive_authorization: DBusCallFlags = @bitCast(@as(c_uint, 2));
    extern fn g_dbus_call_flags_get_type() usize;
    pub const getGObjectType = g_dbus_call_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Capabilities negotiated with the remote peer.
pub const DBusCapabilityFlags = packed struct(c_uint) {
    unix_fd_passing: bool = false,
    _padding1: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: DBusCapabilityFlags = @bitCast(@as(c_uint, 0));
    pub const flags_unix_fd_passing: DBusCapabilityFlags = @bitCast(@as(c_uint, 1));
    extern fn g_dbus_capability_flags_get_type() usize;
    pub const getGObjectType = g_dbus_capability_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when creating a new `gio.DBusConnection`.
pub const DBusConnectionFlags = packed struct(c_uint) {
    authentication_client: bool = false,
    authentication_server: bool = false,
    authentication_allow_anonymous: bool = false,
    message_bus_connection: bool = false,
    delay_message_processing: bool = false,
    authentication_require_same_user: bool = false,
    cross_namespace: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: DBusConnectionFlags = @bitCast(@as(c_uint, 0));
    pub const flags_authentication_client: DBusConnectionFlags = @bitCast(@as(c_uint, 1));
    pub const flags_authentication_server: DBusConnectionFlags = @bitCast(@as(c_uint, 2));
    pub const flags_authentication_allow_anonymous: DBusConnectionFlags = @bitCast(@as(c_uint, 4));
    pub const flags_message_bus_connection: DBusConnectionFlags = @bitCast(@as(c_uint, 8));
    pub const flags_delay_message_processing: DBusConnectionFlags = @bitCast(@as(c_uint, 16));
    pub const flags_authentication_require_same_user: DBusConnectionFlags = @bitCast(@as(c_uint, 32));
    pub const flags_cross_namespace: DBusConnectionFlags = @bitCast(@as(c_uint, 64));
    extern fn g_dbus_connection_flags_get_type() usize;
    pub const getGObjectType = g_dbus_connection_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags describing the behavior of a `gio.DBusInterfaceSkeleton` instance.
pub const DBusInterfaceSkeletonFlags = packed struct(c_uint) {
    handle_method_invocations_in_thread: bool = false,
    _padding1: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: DBusInterfaceSkeletonFlags = @bitCast(@as(c_uint, 0));
    pub const flags_handle_method_invocations_in_thread: DBusInterfaceSkeletonFlags = @bitCast(@as(c_uint, 1));
    extern fn g_dbus_interface_skeleton_flags_get_type() usize;
    pub const getGObjectType = g_dbus_interface_skeleton_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Message flags used in `gio.DBusMessage`.
pub const DBusMessageFlags = packed struct(c_uint) {
    no_reply_expected: bool = false,
    no_auto_start: bool = false,
    allow_interactive_authorization: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: DBusMessageFlags = @bitCast(@as(c_uint, 0));
    pub const flags_no_reply_expected: DBusMessageFlags = @bitCast(@as(c_uint, 1));
    pub const flags_no_auto_start: DBusMessageFlags = @bitCast(@as(c_uint, 2));
    pub const flags_allow_interactive_authorization: DBusMessageFlags = @bitCast(@as(c_uint, 4));
    extern fn g_dbus_message_flags_get_type() usize;
    pub const getGObjectType = g_dbus_message_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when constructing a `gio.DBusObjectManagerClient`.
pub const DBusObjectManagerClientFlags = packed struct(c_uint) {
    do_not_auto_start: bool = false,
    _padding1: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: DBusObjectManagerClientFlags = @bitCast(@as(c_uint, 0));
    pub const flags_do_not_auto_start: DBusObjectManagerClientFlags = @bitCast(@as(c_uint, 1));
    extern fn g_dbus_object_manager_client_flags_get_type() usize;
    pub const getGObjectType = g_dbus_object_manager_client_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags describing the access control of a D-Bus property.
pub const DBusPropertyInfoFlags = packed struct(c_uint) {
    readable: bool = false,
    writable: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: DBusPropertyInfoFlags = @bitCast(@as(c_uint, 0));
    pub const flags_readable: DBusPropertyInfoFlags = @bitCast(@as(c_uint, 1));
    pub const flags_writable: DBusPropertyInfoFlags = @bitCast(@as(c_uint, 2));
    extern fn g_dbus_property_info_flags_get_type() usize;
    pub const getGObjectType = g_dbus_property_info_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when constructing an instance of a `gio.DBusProxy` derived class.
pub const DBusProxyFlags = packed struct(c_uint) {
    do_not_load_properties: bool = false,
    do_not_connect_signals: bool = false,
    do_not_auto_start: bool = false,
    get_invalidated_properties: bool = false,
    do_not_auto_start_at_construction: bool = false,
    no_match_rule: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: DBusProxyFlags = @bitCast(@as(c_uint, 0));
    pub const flags_do_not_load_properties: DBusProxyFlags = @bitCast(@as(c_uint, 1));
    pub const flags_do_not_connect_signals: DBusProxyFlags = @bitCast(@as(c_uint, 2));
    pub const flags_do_not_auto_start: DBusProxyFlags = @bitCast(@as(c_uint, 4));
    pub const flags_get_invalidated_properties: DBusProxyFlags = @bitCast(@as(c_uint, 8));
    pub const flags_do_not_auto_start_at_construction: DBusProxyFlags = @bitCast(@as(c_uint, 16));
    pub const flags_no_match_rule: DBusProxyFlags = @bitCast(@as(c_uint, 32));
    extern fn g_dbus_proxy_flags_get_type() usize;
    pub const getGObjectType = g_dbus_proxy_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when sending `GDBusMessages` on a `gio.DBusConnection`.
pub const DBusSendMessageFlags = packed struct(c_uint) {
    preserve_serial: bool = false,
    _padding1: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: DBusSendMessageFlags = @bitCast(@as(c_uint, 0));
    pub const flags_preserve_serial: DBusSendMessageFlags = @bitCast(@as(c_uint, 1));
    extern fn g_dbus_send_message_flags_get_type() usize;
    pub const getGObjectType = g_dbus_send_message_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when creating a `gio.DBusServer`.
pub const DBusServerFlags = packed struct(c_uint) {
    run_in_thread: bool = false,
    authentication_allow_anonymous: bool = false,
    authentication_require_same_user: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: DBusServerFlags = @bitCast(@as(c_uint, 0));
    pub const flags_run_in_thread: DBusServerFlags = @bitCast(@as(c_uint, 1));
    pub const flags_authentication_allow_anonymous: DBusServerFlags = @bitCast(@as(c_uint, 2));
    pub const flags_authentication_require_same_user: DBusServerFlags = @bitCast(@as(c_uint, 4));
    extern fn g_dbus_server_flags_get_type() usize;
    pub const getGObjectType = g_dbus_server_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when subscribing to signals via `gio.DBusConnection.signalSubscribe`.
pub const DBusSignalFlags = packed struct(c_uint) {
    no_match_rule: bool = false,
    match_arg0_namespace: bool = false,
    match_arg0_path: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: DBusSignalFlags = @bitCast(@as(c_uint, 0));
    pub const flags_no_match_rule: DBusSignalFlags = @bitCast(@as(c_uint, 1));
    pub const flags_match_arg0_namespace: DBusSignalFlags = @bitCast(@as(c_uint, 2));
    pub const flags_match_arg0_path: DBusSignalFlags = @bitCast(@as(c_uint, 4));
    extern fn g_dbus_signal_flags_get_type() usize;
    pub const getGObjectType = g_dbus_signal_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags passed to `gio.DBusConnection.registerSubtree`.
pub const DBusSubtreeFlags = packed struct(c_uint) {
    dispatch_to_unenumerated_nodes: bool = false,
    _padding1: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: DBusSubtreeFlags = @bitCast(@as(c_uint, 0));
    pub const flags_dispatch_to_unenumerated_nodes: DBusSubtreeFlags = @bitCast(@as(c_uint, 1));
    extern fn g_dbus_subtree_flags_get_type() usize;
    pub const getGObjectType = g_dbus_subtree_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when starting a drive.
pub const DriveStartFlags = packed struct(c_uint) {
    _padding0: bool = false,
    _padding1: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: DriveStartFlags = @bitCast(@as(c_uint, 0));
    extern fn g_drive_start_flags_get_type() usize;
    pub const getGObjectType = g_drive_start_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags specifying the behaviour of an attribute.
pub const FileAttributeInfoFlags = packed struct(c_uint) {
    copy_with_file: bool = false,
    copy_when_moved: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: FileAttributeInfoFlags = @bitCast(@as(c_uint, 0));
    pub const flags_copy_with_file: FileAttributeInfoFlags = @bitCast(@as(c_uint, 1));
    pub const flags_copy_when_moved: FileAttributeInfoFlags = @bitCast(@as(c_uint, 2));
    extern fn g_file_attribute_info_flags_get_type() usize;
    pub const getGObjectType = g_file_attribute_info_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when copying or moving files.
pub const FileCopyFlags = packed struct(c_uint) {
    overwrite: bool = false,
    backup: bool = false,
    nofollow_symlinks: bool = false,
    all_metadata: bool = false,
    no_fallback_for_move: bool = false,
    target_default_perms: bool = false,
    target_default_modified_time: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: FileCopyFlags = @bitCast(@as(c_uint, 0));
    pub const flags_overwrite: FileCopyFlags = @bitCast(@as(c_uint, 1));
    pub const flags_backup: FileCopyFlags = @bitCast(@as(c_uint, 2));
    pub const flags_nofollow_symlinks: FileCopyFlags = @bitCast(@as(c_uint, 4));
    pub const flags_all_metadata: FileCopyFlags = @bitCast(@as(c_uint, 8));
    pub const flags_no_fallback_for_move: FileCopyFlags = @bitCast(@as(c_uint, 16));
    pub const flags_target_default_perms: FileCopyFlags = @bitCast(@as(c_uint, 32));
    pub const flags_target_default_modified_time: FileCopyFlags = @bitCast(@as(c_uint, 64));
    extern fn g_file_copy_flags_get_type() usize;
    pub const getGObjectType = g_file_copy_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when an operation may create a file.
pub const FileCreateFlags = packed struct(c_uint) {
    private: bool = false,
    replace_destination: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: FileCreateFlags = @bitCast(@as(c_uint, 0));
    pub const flags_private: FileCreateFlags = @bitCast(@as(c_uint, 1));
    pub const flags_replace_destination: FileCreateFlags = @bitCast(@as(c_uint, 2));
    extern fn g_file_create_flags_get_type() usize;
    pub const getGObjectType = g_file_create_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags that can be used with `gio.File.measureDiskUsage`.
pub const FileMeasureFlags = packed struct(c_uint) {
    _padding0: bool = false,
    report_any_error: bool = false,
    apparent_size: bool = false,
    no_xdev: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: FileMeasureFlags = @bitCast(@as(c_uint, 0));
    pub const flags_report_any_error: FileMeasureFlags = @bitCast(@as(c_uint, 2));
    pub const flags_apparent_size: FileMeasureFlags = @bitCast(@as(c_uint, 4));
    pub const flags_no_xdev: FileMeasureFlags = @bitCast(@as(c_uint, 8));
    extern fn g_file_measure_flags_get_type() usize;
    pub const getGObjectType = g_file_measure_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used to set what a `gio.FileMonitor` will watch for.
pub const FileMonitorFlags = packed struct(c_uint) {
    watch_mounts: bool = false,
    send_moved: bool = false,
    watch_hard_links: bool = false,
    watch_moves: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: FileMonitorFlags = @bitCast(@as(c_uint, 0));
    pub const flags_watch_mounts: FileMonitorFlags = @bitCast(@as(c_uint, 1));
    pub const flags_send_moved: FileMonitorFlags = @bitCast(@as(c_uint, 2));
    pub const flags_watch_hard_links: FileMonitorFlags = @bitCast(@as(c_uint, 4));
    pub const flags_watch_moves: FileMonitorFlags = @bitCast(@as(c_uint, 8));
    extern fn g_file_monitor_flags_get_type() usize;
    pub const getGObjectType = g_file_monitor_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when querying a `gio.FileInfo`.
pub const FileQueryInfoFlags = packed struct(c_uint) {
    nofollow_symlinks: bool = false,
    _padding1: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: FileQueryInfoFlags = @bitCast(@as(c_uint, 0));
    pub const flags_nofollow_symlinks: FileQueryInfoFlags = @bitCast(@as(c_uint, 1));
    extern fn g_file_query_info_flags_get_type() usize;
    pub const getGObjectType = g_file_query_info_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GIOStreamSpliceFlags determine how streams should be spliced.
pub const IOStreamSpliceFlags = packed struct(c_uint) {
    close_stream1: bool = false,
    close_stream2: bool = false,
    wait_for_both: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: IOStreamSpliceFlags = @bitCast(@as(c_uint, 0));
    pub const flags_close_stream1: IOStreamSpliceFlags = @bitCast(@as(c_uint, 1));
    pub const flags_close_stream2: IOStreamSpliceFlags = @bitCast(@as(c_uint, 2));
    pub const flags_wait_for_both: IOStreamSpliceFlags = @bitCast(@as(c_uint, 4));
    extern fn g_io_stream_splice_flags_get_type() usize;
    pub const getGObjectType = g_io_stream_splice_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when mounting a mount.
pub const MountMountFlags = packed struct(c_uint) {
    _padding0: bool = false,
    _padding1: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: MountMountFlags = @bitCast(@as(c_uint, 0));
    extern fn g_mount_mount_flags_get_type() usize;
    pub const getGObjectType = g_mount_mount_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when an unmounting a mount.
pub const MountUnmountFlags = packed struct(c_uint) {
    force: bool = false,
    _padding1: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: MountUnmountFlags = @bitCast(@as(c_uint, 0));
    pub const flags_force: MountUnmountFlags = @bitCast(@as(c_uint, 1));
    extern fn g_mount_unmount_flags_get_type() usize;
    pub const getGObjectType = g_mount_unmount_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GOutputStreamSpliceFlags determine how streams should be spliced.
pub const OutputStreamSpliceFlags = packed struct(c_uint) {
    close_source: bool = false,
    close_target: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: OutputStreamSpliceFlags = @bitCast(@as(c_uint, 0));
    pub const flags_close_source: OutputStreamSpliceFlags = @bitCast(@as(c_uint, 1));
    pub const flags_close_target: OutputStreamSpliceFlags = @bitCast(@as(c_uint, 2));
    extern fn g_output_stream_splice_flags_get_type() usize;
    pub const getGObjectType = g_output_stream_splice_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags to modify lookup behavior.
pub const ResolverNameLookupFlags = packed struct(c_uint) {
    ipv4_only: bool = false,
    ipv6_only: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_default: ResolverNameLookupFlags = @bitCast(@as(c_uint, 0));
    pub const flags_ipv4_only: ResolverNameLookupFlags = @bitCast(@as(c_uint, 1));
    pub const flags_ipv6_only: ResolverNameLookupFlags = @bitCast(@as(c_uint, 2));
    extern fn g_resolver_name_lookup_flags_get_type() usize;
    pub const getGObjectType = g_resolver_name_lookup_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GResourceFlags give information about a particular file inside a resource
/// bundle.
pub const ResourceFlags = packed struct(c_uint) {
    compressed: bool = false,
    _padding1: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: ResourceFlags = @bitCast(@as(c_uint, 0));
    pub const flags_compressed: ResourceFlags = @bitCast(@as(c_uint, 1));
    extern fn g_resource_flags_get_type() usize;
    pub const getGObjectType = g_resource_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// GResourceLookupFlags determine how resource path lookups are handled.
pub const ResourceLookupFlags = packed struct(c_uint) {
    _padding0: bool = false,
    _padding1: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: ResourceLookupFlags = @bitCast(@as(c_uint, 0));
    extern fn g_resource_lookup_flags_get_type() usize;
    pub const getGObjectType = g_resource_lookup_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used when creating a binding. These flags determine in which
/// direction the binding works. The default is to synchronize in both
/// directions.
pub const SettingsBindFlags = packed struct(c_uint) {
    get: bool = false,
    set: bool = false,
    no_sensitivity: bool = false,
    get_no_changes: bool = false,
    invert_boolean: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_default: SettingsBindFlags = @bitCast(@as(c_uint, 0));
    pub const flags_get: SettingsBindFlags = @bitCast(@as(c_uint, 1));
    pub const flags_set: SettingsBindFlags = @bitCast(@as(c_uint, 2));
    pub const flags_no_sensitivity: SettingsBindFlags = @bitCast(@as(c_uint, 4));
    pub const flags_get_no_changes: SettingsBindFlags = @bitCast(@as(c_uint, 8));
    pub const flags_invert_boolean: SettingsBindFlags = @bitCast(@as(c_uint, 16));
    extern fn g_settings_bind_flags_get_type() usize;
    pub const getGObjectType = g_settings_bind_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags used in `gio.Socket.receiveMessage` and `gio.Socket.sendMessage`.
/// The flags listed in the enum are some commonly available flags, but the
/// values used for them are the same as on the platform, and any other flags
/// are passed in/out as is. So to use a platform specific flag, just include
/// the right system header and pass in the flag.
pub const SocketMsgFlags = packed struct(c_uint) {
    oob: bool = false,
    peek: bool = false,
    dontroute: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: SocketMsgFlags = @bitCast(@as(c_uint, 0));
    pub const flags_oob: SocketMsgFlags = @bitCast(@as(c_uint, 1));
    pub const flags_peek: SocketMsgFlags = @bitCast(@as(c_uint, 2));
    pub const flags_dontroute: SocketMsgFlags = @bitCast(@as(c_uint, 4));
    extern fn g_socket_msg_flags_get_type() usize;
    pub const getGObjectType = g_socket_msg_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags to define the behaviour of a `gio.Subprocess`.
///
/// Note that the default for stdin is to redirect from `/dev/null`.  For
/// stdout and stderr the default are for them to inherit the
/// corresponding descriptor from the calling process.
///
/// Note that it is a programmer error to mix 'incompatible' flags.  For
/// example, you may not request both `G_SUBPROCESS_FLAGS_STDOUT_PIPE` and
/// `G_SUBPROCESS_FLAGS_STDOUT_SILENCE`.
pub const SubprocessFlags = packed struct(c_uint) {
    stdin_pipe: bool = false,
    stdin_inherit: bool = false,
    stdout_pipe: bool = false,
    stdout_silence: bool = false,
    stderr_pipe: bool = false,
    stderr_silence: bool = false,
    stderr_merge: bool = false,
    inherit_fds: bool = false,
    search_path_from_envp: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: SubprocessFlags = @bitCast(@as(c_uint, 0));
    pub const flags_stdin_pipe: SubprocessFlags = @bitCast(@as(c_uint, 1));
    pub const flags_stdin_inherit: SubprocessFlags = @bitCast(@as(c_uint, 2));
    pub const flags_stdout_pipe: SubprocessFlags = @bitCast(@as(c_uint, 4));
    pub const flags_stdout_silence: SubprocessFlags = @bitCast(@as(c_uint, 8));
    pub const flags_stderr_pipe: SubprocessFlags = @bitCast(@as(c_uint, 16));
    pub const flags_stderr_silence: SubprocessFlags = @bitCast(@as(c_uint, 32));
    pub const flags_stderr_merge: SubprocessFlags = @bitCast(@as(c_uint, 64));
    pub const flags_inherit_fds: SubprocessFlags = @bitCast(@as(c_uint, 128));
    pub const flags_search_path_from_envp: SubprocessFlags = @bitCast(@as(c_uint, 256));
    extern fn g_subprocess_flags_get_type() usize;
    pub const getGObjectType = g_subprocess_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags to define future `gio.TestDBus` behaviour.
pub const TestDBusFlags = packed struct(c_uint) {
    _padding0: bool = false,
    _padding1: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: TestDBusFlags = @bitCast(@as(c_uint, 0));
    extern fn g_test_dbus_flags_get_type() usize;
    pub const getGObjectType = g_test_dbus_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// A set of flags describing TLS certification validation. This can be
/// used to describe why a particular certificate was rejected (for
/// example, in `gio.TlsConnection.signals.accept`-certificate).
///
/// GLib guarantees that if certificate verification fails, at least one
/// flag will be set, but it does not guarantee that all possible flags
/// will be set. Accordingly, you may not safely decide to ignore any
/// particular type of error. For example, it would be incorrect to mask
/// `G_TLS_CERTIFICATE_EXPIRED` if you want to allow expired certificates,
/// because this could potentially be the only error flag set even if
/// other problems exist with the certificate.
pub const TlsCertificateFlags = packed struct(c_uint) {
    unknown_ca: bool = false,
    bad_identity: bool = false,
    not_activated: bool = false,
    expired: bool = false,
    revoked: bool = false,
    insecure: bool = false,
    generic_error: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_no_flags: TlsCertificateFlags = @bitCast(@as(c_uint, 0));
    pub const flags_unknown_ca: TlsCertificateFlags = @bitCast(@as(c_uint, 1));
    pub const flags_bad_identity: TlsCertificateFlags = @bitCast(@as(c_uint, 2));
    pub const flags_not_activated: TlsCertificateFlags = @bitCast(@as(c_uint, 4));
    pub const flags_expired: TlsCertificateFlags = @bitCast(@as(c_uint, 8));
    pub const flags_revoked: TlsCertificateFlags = @bitCast(@as(c_uint, 16));
    pub const flags_insecure: TlsCertificateFlags = @bitCast(@as(c_uint, 32));
    pub const flags_generic_error: TlsCertificateFlags = @bitCast(@as(c_uint, 64));
    pub const flags_validate_all: TlsCertificateFlags = @bitCast(@as(c_uint, 127));
    extern fn g_tls_certificate_flags_get_type() usize;
    pub const getGObjectType = g_tls_certificate_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Flags for `gio.TlsDatabase.verifyChain`.
pub const TlsDatabaseVerifyFlags = packed struct(c_uint) {
    _padding0: bool = false,
    _padding1: bool = false,
    _padding2: bool = false,
    _padding3: bool = false,
    _padding4: bool = false,
    _padding5: bool = false,
    _padding6: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: TlsDatabaseVerifyFlags = @bitCast(@as(c_uint, 0));
    extern fn g_tls_database_verify_flags_get_type() usize;
    pub const getGObjectType = g_tls_database_verify_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Various flags for the password.
pub const TlsPasswordFlags = packed struct(c_uint) {
    _padding0: bool = false,
    retry: bool = false,
    many_tries: bool = false,
    final_try: bool = false,
    pkcs11_user: bool = false,
    pkcs11_security_officer: bool = false,
    pkcs11_context_specific: bool = false,
    _padding7: bool = false,
    _padding8: bool = false,
    _padding9: bool = false,
    _padding10: bool = false,
    _padding11: bool = false,
    _padding12: bool = false,
    _padding13: bool = false,
    _padding14: bool = false,
    _padding15: bool = false,
    _padding16: bool = false,
    _padding17: bool = false,
    _padding18: bool = false,
    _padding19: bool = false,
    _padding20: bool = false,
    _padding21: bool = false,
    _padding22: bool = false,
    _padding23: bool = false,
    _padding24: bool = false,
    _padding25: bool = false,
    _padding26: bool = false,
    _padding27: bool = false,
    _padding28: bool = false,
    _padding29: bool = false,
    _padding30: bool = false,
    _padding31: bool = false,

    pub const flags_none: TlsPasswordFlags = @bitCast(@as(c_uint, 0));
    pub const flags_retry: TlsPasswordFlags = @bitCast(@as(c_uint, 2));
    pub const flags_many_tries: TlsPasswordFlags = @bitCast(@as(c_uint, 4));
    pub const flags_final_try: TlsPasswordFlags = @bitCast(@as(c_uint, 8));
    pub const flags_pkcs11_user: TlsPasswordFlags = @bitCast(@as(c_uint, 16));
    pub const flags_pkcs11_security_officer: TlsPasswordFlags = @bitCast(@as(c_uint, 32));
    pub const flags_pkcs11_context_specific: TlsPasswordFlags = @bitCast(@as(c_uint, 64));
    extern fn g_tls_password_flags_get_type() usize;
    pub const getGObjectType = g_tls_password_flags_get_type;

    test {
        @setEvalBranchQuota(100_000);
        std.testing.refAllDecls(@This());
    }
};

/// Asynchronously connects to the message bus specified by `bus_type`.
///
/// When the operation is finished, `callback` will be invoked. You can
/// then call `gio.busGetFinish` to get the result of the operation.
///
/// This is an asynchronous failable function. See `gio.busGetSync` for
/// the synchronous version.
extern fn g_bus_get(p_bus_type: gio.BusType, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
pub const busGet = g_bus_get;

/// Finishes an operation started with `gio.busGet`.
///
/// The returned object is a singleton, that is, shared with other
/// callers of `gio.busGet` and `gio.busGetSync` for `bus_type`. In the
/// event that you need a private message bus connection, use
/// `gio.dbusAddressGetForBusSync` and
/// `gio.DBusConnection.newForAddress` with
/// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
/// G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
///
/// Note that the returned `gio.DBusConnection` object will (usually) have
/// the `gio.DBusConnection.properties.exit`-on-close property set to `TRUE`.
extern fn g_bus_get_finish(p_res: *gio.AsyncResult, p_error: ?*?*glib.Error) ?*gio.DBusConnection;
pub const busGetFinish = g_bus_get_finish;

/// Synchronously connects to the message bus specified by `bus_type`.
/// Note that the returned object may shared with other callers,
/// e.g. if two separate parts of a process calls this function with
/// the same `bus_type`, they will share the same object.
///
/// This is a synchronous failable function. See `gio.busGet` and
/// `gio.busGetFinish` for the asynchronous version.
///
/// The returned object is a singleton, that is, shared with other
/// callers of `gio.busGet` and `gio.busGetSync` for `bus_type`. In the
/// event that you need a private message bus connection, use
/// `gio.dbusAddressGetForBusSync` and
/// `gio.DBusConnection.newForAddress` with
/// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
/// G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
///
/// Note that the returned `gio.DBusConnection` object will (usually) have
/// the `gio.DBusConnection.properties.exit`-on-close property set to `TRUE`.
extern fn g_bus_get_sync(p_bus_type: gio.BusType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.DBusConnection;
pub const busGetSync = g_bus_get_sync;

/// Starts acquiring `name` on the bus specified by `bus_type` and calls
/// `name_acquired_handler` and `name_lost_handler` when the name is
/// acquired respectively lost. Callbacks will be invoked in the thread-default
/// main context (see `glib.MainContext.pushThreadDefault`)
/// of the thread you are calling this function from.
///
/// You are guaranteed that one of the `name_acquired_handler` and `name_lost_handler`
/// callbacks will be invoked after calling this function - there are three
/// possible cases:
///
/// - `name_lost_handler` with a `NULL` connection (if a connection to the bus
///   can't be made).
///
/// - `bus_acquired_handler` then `name_lost_handler` (if the name can't be
///   obtained)
///
/// - `bus_acquired_handler` then `name_acquired_handler` (if the name was
///   obtained).
///
/// When you are done owning the name, just call `gio.busUnownName`
/// with the owner id this function returns.
///
/// If the name is acquired or lost (for example another application
/// could acquire the name if you allow replacement or the application
/// currently owning the name exits), the handlers are also invoked.
/// If the `gio.DBusConnection` that is used for attempting to own the name
/// closes, then `name_lost_handler` is invoked since it is no longer
/// possible for other processes to access the process.
///
/// You cannot use `gio.busOwnName` several times for the same name (unless
/// interleaved with calls to `gio.busUnownName`) - only the first call
/// will work.
///
/// Another guarantee is that invocations of `name_acquired_handler`
/// and `name_lost_handler` are guaranteed to alternate; that
/// is, if `name_acquired_handler` is invoked then you are
/// guaranteed that the next time one of the handlers is invoked, it
/// will be `name_lost_handler`. The reverse is also true.
///
/// If you plan on exporting objects (using e.g.
/// `gio.DBusConnection.registerObject`), note that it is generally too late
/// to export the objects in `name_acquired_handler`. Instead, you can do this
/// in `bus_acquired_handler` since you are guaranteed that this will run
/// before `name` is requested from the bus.
///
/// This behavior makes it very simple to write applications that wants
/// to [own names](dbus-name-owning.html`d`-bus-name-owning) and export objects.
/// Simply register objects to be exported in `bus_acquired_handler` and
/// unregister the objects (if any) in `name_lost_handler`.
extern fn g_bus_own_name(p_bus_type: gio.BusType, p_name: [*:0]const u8, p_flags: gio.BusNameOwnerFlags, p_bus_acquired_handler: ?gio.BusAcquiredCallback, p_name_acquired_handler: ?gio.BusNameAcquiredCallback, p_name_lost_handler: ?gio.BusNameLostCallback, p_user_data: ?*anyopaque, p_user_data_free_func: ?glib.DestroyNotify) c_uint;
pub const busOwnName = g_bus_own_name;

/// Like `gio.busOwnName` but takes a `gio.DBusConnection` instead of a
/// `gio.BusType`.
extern fn g_bus_own_name_on_connection(p_connection: *gio.DBusConnection, p_name: [*:0]const u8, p_flags: gio.BusNameOwnerFlags, p_name_acquired_handler: ?gio.BusNameAcquiredCallback, p_name_lost_handler: ?gio.BusNameLostCallback, p_user_data: ?*anyopaque, p_user_data_free_func: ?glib.DestroyNotify) c_uint;
pub const busOwnNameOnConnection = g_bus_own_name_on_connection;

/// Version of `gio.busOwnNameOnConnection` using closures instead of
/// callbacks for easier binding in other languages.
extern fn g_bus_own_name_on_connection_with_closures(p_connection: *gio.DBusConnection, p_name: [*:0]const u8, p_flags: gio.BusNameOwnerFlags, p_name_acquired_closure: ?*gobject.Closure, p_name_lost_closure: ?*gobject.Closure) c_uint;
pub const busOwnNameOnConnectionWithClosures = g_bus_own_name_on_connection_with_closures;

/// Version of `gio.busOwnName` using closures instead of callbacks for
/// easier binding in other languages.
extern fn g_bus_own_name_with_closures(p_bus_type: gio.BusType, p_name: [*:0]const u8, p_flags: gio.BusNameOwnerFlags, p_bus_acquired_closure: ?*gobject.Closure, p_name_acquired_closure: ?*gobject.Closure, p_name_lost_closure: ?*gobject.Closure) c_uint;
pub const busOwnNameWithClosures = g_bus_own_name_with_closures;

/// Stops owning a name.
///
/// Note that there may still be D-Bus traffic to process (relating to owning
/// and unowning the name) in the current thread-default `glib.MainContext` after
/// this function has returned. You should continue to iterate the `glib.MainContext`
/// until the `glib.DestroyNotify` function passed to `gio.busOwnName` is called, in
/// order to avoid memory leaks through callbacks queued on the `glib.MainContext`
/// after it’s stopped being iterated.
extern fn g_bus_unown_name(p_owner_id: c_uint) void;
pub const busUnownName = g_bus_unown_name;

/// Stops watching a name.
///
/// Note that there may still be D-Bus traffic to process (relating to watching
/// and unwatching the name) in the current thread-default `glib.MainContext` after
/// this function has returned. You should continue to iterate the `glib.MainContext`
/// until the `glib.DestroyNotify` function passed to `gio.busWatchName` is called, in
/// order to avoid memory leaks through callbacks queued on the `glib.MainContext`
/// after it’s stopped being iterated.
extern fn g_bus_unwatch_name(p_watcher_id: c_uint) void;
pub const busUnwatchName = g_bus_unwatch_name;

/// Starts watching `name` on the bus specified by `bus_type` and calls
/// `name_appeared_handler` and `name_vanished_handler` when the name is
/// known to have an owner respectively known to lose its
/// owner. Callbacks will be invoked in the thread-default main context
/// (see `glib.MainContext.pushThreadDefault`)
/// of the thread you are calling this function from.
///
/// You are guaranteed that one of the handlers will be invoked after
/// calling this function. When you are done watching the name, just
/// call `gio.busUnwatchName` with the watcher id this function
/// returns.
///
/// If the name vanishes or appears (for example the application owning
/// the name could restart), the handlers are also invoked. If the
/// `gio.DBusConnection` that is used for watching the name disconnects, then
/// `name_vanished_handler` is invoked since it is no longer
/// possible to access the name.
///
/// Another guarantee is that invocations of `name_appeared_handler`
/// and `name_vanished_handler` are guaranteed to alternate; that
/// is, if `name_appeared_handler` is invoked then you are
/// guaranteed that the next time one of the handlers is invoked, it
/// will be `name_vanished_handler`. The reverse is also true.
///
/// This behavior makes it very simple to write applications that want
/// to take action when a certain [name exists](dbus-name-watching.html`d`-bus-name-watching).
/// Basically, the application should create object proxies in
/// `name_appeared_handler` and destroy them again (if any) in
/// `name_vanished_handler`.
extern fn g_bus_watch_name(p_bus_type: gio.BusType, p_name: [*:0]const u8, p_flags: gio.BusNameWatcherFlags, p_name_appeared_handler: ?gio.BusNameAppearedCallback, p_name_vanished_handler: ?gio.BusNameVanishedCallback, p_user_data: ?*anyopaque, p_user_data_free_func: ?glib.DestroyNotify) c_uint;
pub const busWatchName = g_bus_watch_name;

/// Like `gio.busWatchName` but takes a `gio.DBusConnection` instead of a
/// `gio.BusType`.
extern fn g_bus_watch_name_on_connection(p_connection: *gio.DBusConnection, p_name: [*:0]const u8, p_flags: gio.BusNameWatcherFlags, p_name_appeared_handler: ?gio.BusNameAppearedCallback, p_name_vanished_handler: ?gio.BusNameVanishedCallback, p_user_data: ?*anyopaque, p_user_data_free_func: ?glib.DestroyNotify) c_uint;
pub const busWatchNameOnConnection = g_bus_watch_name_on_connection;

/// Version of `gio.busWatchNameOnConnection` using closures instead of callbacks for
/// easier binding in other languages.
extern fn g_bus_watch_name_on_connection_with_closures(p_connection: *gio.DBusConnection, p_name: [*:0]const u8, p_flags: gio.BusNameWatcherFlags, p_name_appeared_closure: ?*gobject.Closure, p_name_vanished_closure: ?*gobject.Closure) c_uint;
pub const busWatchNameOnConnectionWithClosures = g_bus_watch_name_on_connection_with_closures;

/// Version of `gio.busWatchName` using closures instead of callbacks for
/// easier binding in other languages.
extern fn g_bus_watch_name_with_closures(p_bus_type: gio.BusType, p_name: [*:0]const u8, p_flags: gio.BusNameWatcherFlags, p_name_appeared_closure: ?*gobject.Closure, p_name_vanished_closure: ?*gobject.Closure) c_uint;
pub const busWatchNameWithClosures = g_bus_watch_name_with_closures;

/// Checks if a content type can be executable. Note that for instance
/// things like text files can be executables (i.e. scripts and batch files).
extern fn g_content_type_can_be_executable(p_type: [*:0]const u8) c_int;
pub const contentTypeCanBeExecutable = g_content_type_can_be_executable;

/// Compares two content types for equality.
extern fn g_content_type_equals(p_type1: [*:0]const u8, p_type2: [*:0]const u8) c_int;
pub const contentTypeEquals = g_content_type_equals;

/// Tries to find a content type based on the mime type name.
extern fn g_content_type_from_mime_type(p_mime_type: [*:0]const u8) ?[*:0]u8;
pub const contentTypeFromMimeType = g_content_type_from_mime_type;

/// Gets the human readable description of the content type.
extern fn g_content_type_get_description(p_type: [*:0]const u8) [*:0]u8;
pub const contentTypeGetDescription = g_content_type_get_description;

/// Gets the generic icon name for a content type.
///
/// See the
/// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
/// specification for more on the generic icon name.
extern fn g_content_type_get_generic_icon_name(p_type: [*:0]const u8) ?[*:0]u8;
pub const contentTypeGetGenericIconName = g_content_type_get_generic_icon_name;

/// Gets the icon for a content type.
extern fn g_content_type_get_icon(p_type: [*:0]const u8) *gio.Icon;
pub const contentTypeGetIcon = g_content_type_get_icon;

/// Get the list of directories which MIME data is loaded from. See
/// `gio.contentTypeSetMimeDirs` for details.
extern fn g_content_type_get_mime_dirs() [*]const [*:0]const u8;
pub const contentTypeGetMimeDirs = g_content_type_get_mime_dirs;

/// Gets the mime type for the content type, if one is registered.
extern fn g_content_type_get_mime_type(p_type: [*:0]const u8) ?[*:0]u8;
pub const contentTypeGetMimeType = g_content_type_get_mime_type;

/// Gets the symbolic icon for a content type.
extern fn g_content_type_get_symbolic_icon(p_type: [*:0]const u8) *gio.Icon;
pub const contentTypeGetSymbolicIcon = g_content_type_get_symbolic_icon;

/// Guesses the content type based on example data. If the function is
/// uncertain, `result_uncertain` will be set to `TRUE`. Either `filename`
/// or `data` may be `NULL`, in which case the guess will be based solely
/// on the other argument.
extern fn g_content_type_guess(p_filename: ?[*:0]const u8, p_data: ?[*]const u8, p_data_size: usize, p_result_uncertain: ?*c_int) [*:0]u8;
pub const contentTypeGuess = g_content_type_guess;

/// Tries to guess the type of the tree with root `root`, by
/// looking at the files it contains. The result is an array
/// of content types, with the best guess coming first.
///
/// The types returned all have the form x-content/foo, e.g.
/// x-content/audio-cdda (for audio CDs) or x-content/image-dcf
/// (for a camera memory card). See the
/// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
/// specification for more on x-content types.
///
/// This function is useful in the implementation of
/// `gio.Mount.guessContentType`.
extern fn g_content_type_guess_for_tree(p_root: *gio.File) [*][*:0]u8;
pub const contentTypeGuessForTree = g_content_type_guess_for_tree;

/// Determines if `type` is a subset of `supertype`.
extern fn g_content_type_is_a(p_type: [*:0]const u8, p_supertype: [*:0]const u8) c_int;
pub const contentTypeIsA = g_content_type_is_a;

/// Determines if `type` is a subset of `mime_type`.
/// Convenience wrapper around `gio.contentTypeIsA`.
extern fn g_content_type_is_mime_type(p_type: [*:0]const u8, p_mime_type: [*:0]const u8) c_int;
pub const contentTypeIsMimeType = g_content_type_is_mime_type;

/// Checks if the content type is the generic "unknown" type.
/// On UNIX this is the "application/octet-stream" mimetype,
/// while on win32 it is "*" and on OSX it is a dynamic type
/// or octet-stream.
extern fn g_content_type_is_unknown(p_type: [*:0]const u8) c_int;
pub const contentTypeIsUnknown = g_content_type_is_unknown;

/// Set the list of directories used by GIO to load the MIME database.
/// If `dirs` is `NULL`, the directories used are the default:
///
///  - the `mime` subdirectory of the directory in `$XDG_DATA_HOME`
///  - the `mime` subdirectory of every directory in `$XDG_DATA_DIRS`
///
/// This function is intended to be used when writing tests that depend on
/// information stored in the MIME database, in order to control the data.
///
/// Typically, in case your tests use `G_TEST_OPTION_ISOLATE_DIRS`, but they
/// depend on the system’s MIME database, you should call this function
/// with `dirs` set to `NULL` before calling `glib.testInit`, for instance:
///
/// ```
///   // Load MIME data from the system
///   g_content_type_set_mime_dirs (NULL);
///   // Isolate the environment
///   g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
///
///   …
///
///   return g_test_run ();
/// ```
extern fn g_content_type_set_mime_dirs(p_dirs: ?[*]const [*:0]const u8) void;
pub const contentTypeSetMimeDirs = g_content_type_set_mime_dirs;

/// Gets a list of strings containing all the registered content types
/// known to the system. The list and its data should be freed using
/// `g_list_free_full (list, g_free)`.
extern fn g_content_types_get_registered() *glib.List;
pub const contentTypesGetRegistered = g_content_types_get_registered;

/// Escape `string` so it can appear in a D-Bus address as the value
/// part of a key-value pair.
///
/// For instance, if `string` is `/run/bus-for-:0`,
/// this function would return `/run/bus-for-`@"3A0"``,
/// which could be used in a D-Bus address like
/// `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-`@"3A0"``.
extern fn g_dbus_address_escape_value(p_string: [*:0]const u8) [*:0]u8;
pub const dbusAddressEscapeValue = g_dbus_address_escape_value;

/// Synchronously looks up the D-Bus address for the well-known message
/// bus instance specified by `bus_type`. This may involve using various
/// platform specific mechanisms.
///
/// The returned address will be in the
/// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`).
extern fn g_dbus_address_get_for_bus_sync(p_bus_type: gio.BusType, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?[*:0]u8;
pub const dbusAddressGetForBusSync = g_dbus_address_get_for_bus_sync;

/// Asynchronously connects to an endpoint specified by `address` and
/// sets up the connection so it is in a state to run the client-side
/// of the D-Bus authentication conversation. `address` must be in the
/// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`).
///
/// When the operation is finished, `callback` will be invoked. You can
/// then call `gio.dbusAddressGetStreamFinish` to get the result of
/// the operation.
///
/// This is an asynchronous failable function. See
/// `gio.dbusAddressGetStreamSync` for the synchronous version.
extern fn g_dbus_address_get_stream(p_address: [*:0]const u8, p_cancellable: ?*gio.Cancellable, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque) void;
pub const dbusAddressGetStream = g_dbus_address_get_stream;

/// Finishes an operation started with `gio.dbusAddressGetStream`.
///
/// A server is not required to set a GUID, so `out_guid` may be set to `NULL`
/// even on success.
extern fn g_dbus_address_get_stream_finish(p_res: *gio.AsyncResult, p_out_guid: ?*[*:0]u8, p_error: ?*?*glib.Error) ?*gio.IOStream;
pub const dbusAddressGetStreamFinish = g_dbus_address_get_stream_finish;

/// Synchronously connects to an endpoint specified by `address` and
/// sets up the connection so it is in a state to run the client-side
/// of the D-Bus authentication conversation. `address` must be in the
/// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`).
///
/// A server is not required to set a GUID, so `out_guid` may be set to `NULL`
/// even on success.
///
/// This is a synchronous failable function. See
/// `gio.dbusAddressGetStream` for the asynchronous version.
extern fn g_dbus_address_get_stream_sync(p_address: [*:0]const u8, p_out_guid: ?*[*:0]u8, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) ?*gio.IOStream;
pub const dbusAddressGetStreamSync = g_dbus_address_get_stream_sync;

/// This is a language binding friendly version of `gio.dbusEscapeObjectPathBytestring`.
extern fn g_dbus_escape_object_path(p_s: [*:0]const u8) [*:0]u8;
pub const dbusEscapeObjectPath = g_dbus_escape_object_path;

/// Escapes `bytes` for use in a D-Bus object path component.
/// `bytes` is an array of zero or more nonzero bytes in an
/// unspecified encoding, followed by a single zero byte.
///
/// The escaping method consists of replacing all non-alphanumeric
/// characters (see `g_ascii_isalnum`) with their hexadecimal value
/// preceded by an underscore (`_`). For example:
/// `foo.bar.baz` will become `foo_2ebar_2ebaz`.
///
/// This method is appropriate to use when the input is nearly
/// a valid object path component but is not when your input
/// is far from being a valid object path component.
/// Other escaping algorithms are also valid to use with
/// D-Bus object paths.
///
/// This can be reversed with `gio.dbusUnescapeObjectPath`.
extern fn g_dbus_escape_object_path_bytestring(p_bytes: [*]const u8) [*:0]u8;
pub const dbusEscapeObjectPathBytestring = g_dbus_escape_object_path_bytestring;

/// Generate a D-Bus GUID that can be used with
/// e.g. `gio.DBusConnection.new`.
///
/// See the
/// [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html`uuids`)
/// regarding what strings are valid D-Bus GUIDs. The specification refers to
/// these as ‘UUIDs’ whereas GLib (for historical reasons) refers to them as
/// ‘GUIDs’. The terms are interchangeable.
///
/// Note that D-Bus GUIDs do not follow
/// [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122).
extern fn g_dbus_generate_guid() [*:0]u8;
pub const dbusGenerateGuid = g_dbus_generate_guid;

/// Converts a `gobject.Value` to a `glib.Variant` of the type indicated by the `type`
/// parameter.
///
/// The conversion is using the following rules:
///
/// - `G_TYPE_STRING`: 's', 'o', 'g' or 'ay'
/// - `G_TYPE_STRV`: 'as', 'ao' or 'aay'
/// - `G_TYPE_BOOLEAN`: 'b'
/// - `G_TYPE_UCHAR`: 'y'
/// - `G_TYPE_INT`: 'i', 'n'
/// - `G_TYPE_UINT`: 'u', 'q'
/// - `G_TYPE_INT64`: 'x'
/// - `G_TYPE_UINT64`: 't'
/// - `G_TYPE_DOUBLE`: 'd'
/// - `G_TYPE_VARIANT`: Any `glib.VariantType`
///
/// This can fail if e.g. `gvalue` is of type `G_TYPE_STRING` and `type`
/// is 'i', i.e. `G_VARIANT_TYPE_INT32`. It will also fail for any `gobject.Type`
/// (including e.g. `G_TYPE_OBJECT` and `G_TYPE_BOXED` derived-types) not
/// in the table above.
///
/// Note that if `gvalue` is of type `G_TYPE_VARIANT` and its value is
/// `NULL`, the empty `glib.Variant` instance (never `NULL`) for `type` is
/// returned (e.g. 0 for scalar types, the empty string for string types,
/// '/' for object path types, the empty array for any array type and so on).
///
/// See the `gio.dbusGvariantToGvalue` function for how to convert a
/// `glib.Variant` to a `gobject.Value`.
extern fn g_dbus_gvalue_to_gvariant(p_gvalue: *const gobject.Value, p_type: *const glib.VariantType) *glib.Variant;
pub const dbusGvalueToGvariant = g_dbus_gvalue_to_gvariant;

/// Converts a `glib.Variant` to a `gobject.Value`. If `value` is floating, it is consumed.
///
/// The rules specified in the `gio.dbusGvalueToGvariant` function are
/// used - this function is essentially its reverse form. So, a `glib.Variant`
/// containing any basic or string array type will be converted to a `gobject.Value`
/// containing a basic value or string array. Any other `glib.Variant` (handle,
/// variant, tuple, dict entry) will be converted to a `gobject.Value` containing that
/// `glib.Variant`.
///
/// The conversion never fails - a valid `gobject.Value` is always returned in
/// `out_gvalue`.
extern fn g_dbus_gvariant_to_gvalue(p_value: *glib.Variant, p_out_gvalue: *gobject.Value) void;
pub const dbusGvariantToGvalue = g_dbus_gvariant_to_gvalue;

/// Checks if `string` is a
/// [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`).
///
/// This doesn't check if `string` is actually supported by `gio.DBusServer`
/// or `gio.DBusConnection` - use `gio.dbusIsSupportedAddress` to do more
/// checks.
extern fn g_dbus_is_address(p_string: [*:0]const u8) c_int;
pub const dbusIsAddress = g_dbus_is_address;

/// Check whether `string` is a valid D-Bus error name.
///
/// This function returns the same result as `gio.dbusIsInterfaceName`,
/// because D-Bus error names are defined to have exactly the
/// same syntax as interface names.
extern fn g_dbus_is_error_name(p_string: [*:0]const u8) c_int;
pub const dbusIsErrorName = g_dbus_is_error_name;

/// Checks if `string` is a D-Bus GUID.
///
/// See the documentation for `gio.dbusGenerateGuid` for more information about
/// the format of a GUID.
extern fn g_dbus_is_guid(p_string: [*:0]const u8) c_int;
pub const dbusIsGuid = g_dbus_is_guid;

/// Checks if `string` is a valid D-Bus interface name.
extern fn g_dbus_is_interface_name(p_string: [*:0]const u8) c_int;
pub const dbusIsInterfaceName = g_dbus_is_interface_name;

/// Checks if `string` is a valid D-Bus member (e.g. signal or method) name.
extern fn g_dbus_is_member_name(p_string: [*:0]const u8) c_int;
pub const dbusIsMemberName = g_dbus_is_member_name;

/// Checks if `string` is a valid D-Bus bus name (either unique or well-known).
extern fn g_dbus_is_name(p_string: [*:0]const u8) c_int;
pub const dbusIsName = g_dbus_is_name;

/// Like `gio.dbusIsAddress` but also checks if the library supports the
/// transports in `string` and that key/value pairs for each transport
/// are valid. See the specification of the
/// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html`addresses`).
extern fn g_dbus_is_supported_address(p_string: [*:0]const u8, p_error: ?*?*glib.Error) c_int;
pub const dbusIsSupportedAddress = g_dbus_is_supported_address;

/// Checks if `string` is a valid D-Bus unique bus name.
extern fn g_dbus_is_unique_name(p_string: [*:0]const u8) c_int;
pub const dbusIsUniqueName = g_dbus_is_unique_name;

/// Unescapes an string that was previously escaped with
/// `gio.dbusEscapeObjectPath`. If the string is in a format that could
/// not have been returned by `gio.dbusEscapeObjectPath`, this function
/// returns `NULL`.
///
/// Encoding alphanumeric characters which do not need to be
/// encoded is not allowed (e.g `_63` is not valid, the string
/// should contain `c` instead).
extern fn g_dbus_unescape_object_path(p_s: [*:0]const u8) ?[*]u8;
pub const dbusUnescapeObjectPath = g_dbus_unescape_object_path;

/// Converts `errno.h` error codes into GIO error codes.
///
/// The fallback value `G_IO_ERROR_FAILED` is returned for error codes not
/// currently handled (but note that future GLib releases may return a more
/// specific value instead).
///
/// As `errno` is global and may be modified by intermediate function
/// calls, you should save its value immediately after the call returns,
/// and use the saved value instead of `errno`:
///
///
/// ```
///   int saved_errno;
///
///   ret = read (blah);
///   saved_errno = errno;
///
///   g_io_error_from_errno (saved_errno);
/// ```
extern fn g_io_error_from_errno(p_err_no: c_int) gio.IOErrorEnum;
pub const ioErrorFromErrno = g_io_error_from_errno;

/// Converts `glib.FileError` error codes into GIO error codes.
extern fn g_io_error_from_file_error(p_file_error: glib.FileError) gio.IOErrorEnum;
pub const ioErrorFromFileError = g_io_error_from_file_error;

/// Gets the GIO Error Quark.
extern fn g_io_error_quark() glib.Quark;
pub const ioErrorQuark = g_io_error_quark;

/// Loads all the modules in the specified directory.
///
/// If don't require all modules to be initialized (and thus registering
/// all gtypes) then you can use `gio.ioModulesScanAllInDirectory`
/// which allows delayed/lazy loading of modules.
extern fn g_io_modules_load_all_in_directory(p_dirname: [*:0]const u8) *glib.List;
pub const ioModulesLoadAllInDirectory = g_io_modules_load_all_in_directory;

/// Loads all the modules in the specified directory.
///
/// If don't require all modules to be initialized (and thus registering
/// all gtypes) then you can use `gio.ioModulesScanAllInDirectory`
/// which allows delayed/lazy loading of modules.
extern fn g_io_modules_load_all_in_directory_with_scope(p_dirname: [*:0]const u8, p_scope: *gio.IOModuleScope) *glib.List;
pub const ioModulesLoadAllInDirectoryWithScope = g_io_modules_load_all_in_directory_with_scope;

/// Scans all the modules in the specified directory, ensuring that
/// any extension point implemented by a module is registered.
///
/// This may not actually load and initialize all the types in each
/// module, some modules may be lazily loaded and initialized when
/// an extension point it implements is used with e.g.
/// `gio.IOExtensionPoint.getExtensions` or
/// `gio.IOExtensionPoint.getExtensionByName`.
///
/// If you need to guarantee that all types are loaded in all the modules,
/// use `gio.ioModulesLoadAllInDirectory`.
extern fn g_io_modules_scan_all_in_directory(p_dirname: [*:0]const u8) void;
pub const ioModulesScanAllInDirectory = g_io_modules_scan_all_in_directory;

/// Scans all the modules in the specified directory, ensuring that
/// any extension point implemented by a module is registered.
///
/// This may not actually load and initialize all the types in each
/// module, some modules may be lazily loaded and initialized when
/// an extension point it implements is used with e.g.
/// `gio.IOExtensionPoint.getExtensions` or
/// `gio.IOExtensionPoint.getExtensionByName`.
///
/// If you need to guarantee that all types are loaded in all the modules,
/// use `gio.ioModulesLoadAllInDirectory`.
extern fn g_io_modules_scan_all_in_directory_with_scope(p_dirname: [*:0]const u8, p_scope: *gio.IOModuleScope) void;
pub const ioModulesScanAllInDirectoryWithScope = g_io_modules_scan_all_in_directory_with_scope;

/// Cancels all cancellable I/O jobs.
///
/// A job is cancellable if a `gio.Cancellable` was passed into
/// `gio.ioSchedulerPushJob`.
extern fn g_io_scheduler_cancel_all_jobs() void;
pub const ioSchedulerCancelAllJobs = g_io_scheduler_cancel_all_jobs;

/// Schedules the I/O job to run in another thread.
///
/// `notify` will be called on `user_data` after `job_func` has returned,
/// regardless whether the job was cancelled or has run to completion.
///
/// If `cancellable` is not `NULL`, it can be used to cancel the I/O job
/// by calling `gio.Cancellable.cancel` or by calling
/// `gio.ioSchedulerCancelAllJobs`.
extern fn g_io_scheduler_push_job(p_job_func: gio.IOSchedulerJobFunc, p_user_data: ?*anyopaque, p_notify: ?glib.DestroyNotify, p_io_priority: c_int, p_cancellable: ?*gio.Cancellable) void;
pub const ioSchedulerPushJob = g_io_scheduler_push_job;

/// Creates a keyfile-backed `gio.SettingsBackend`.
///
/// The filename of the keyfile to use is given by `filename`.
///
/// All settings read to or written from the backend must fall under the
/// path given in `root_path` (which must start and end with a slash and
/// not contain two consecutive slashes).  `root_path` may be `"/"`.
///
/// If `root_group` is non-`NULL` then it specifies the name of the keyfile
/// group used for keys that are written directly below `root_path`.  For
/// example, if `root_path` is `"/apps/example/"` and `root_group` is
/// `"toplevel"`, then setting the key `"/apps/example/enabled"` to true will
/// cause the following to appear in the keyfile:
///
/// ```
/// [toplevel]
/// enabled=true
/// ```
///
/// If `root_group` is `NULL` then it is not permitted to store keys
/// directly below the `root_path`.
///
/// For keys not stored directly below `root_path` (ie: in a sub-path),
/// the name of the subpath (with the final slash stripped) is used as
/// the name of the keyfile group.  To continue the example, if
/// `"/apps/example/profiles/default/font-size"` were set to
/// `12` then the following would appear in the keyfile:
///
/// ```
/// [profiles/default]
/// font-size=12
/// ```
///
/// The backend will refuse writes (and return writability as being
/// false) for keys outside of `root_path` and, in the event that
/// `root_group` is `NULL`, also for keys directly under `root_path`.
/// Writes will also be refused if the backend detects that it has the
/// inability to rewrite the keyfile (ie: the containing directory is not
/// writable).
///
/// There is no checking done for your key namespace clashing with the
/// syntax of the key file format.  For example, if you have `[` or `]`
/// characters in your path names or `=` in your key names you may be in
/// trouble.
///
/// The backend reads default values from a keyfile called `defaults` in
/// the directory specified by the `GKeyfileSettingsBackend:defaults-dir`
/// property, and a list of locked keys from a text file with the name `locks` in
/// the same location.
extern fn g_keyfile_settings_backend_new(p_filename: [*:0]const u8, p_root_path: [*:0]const u8, p_root_group: ?[*:0]const u8) *gio.SettingsBackend;
pub const keyfileSettingsBackendNew = g_keyfile_settings_backend_new;

/// Creates a memory-backed `gio.SettingsBackend`.
///
/// This backend allows changes to settings, but does not write them
/// to any backing storage, so the next time you run your application,
/// the memory backend will start out with the default values again.
extern fn g_memory_settings_backend_new() *gio.SettingsBackend;
pub const memorySettingsBackendNew = g_memory_settings_backend_new;

/// Initializes the platform networking libraries (eg, on Windows, this
/// calls `WSAStartup`). GLib will call this itself if it is needed, so
/// you only need to call it if you directly call system networking
/// functions (without calling any GLib networking functions first).
extern fn g_networking_init() void;
pub const networkingInit = g_networking_init;

/// Creates a readonly `gio.SettingsBackend`.
///
/// This backend does not allow changes to settings, so all settings
/// will always have their default values.
extern fn g_null_settings_backend_new() *gio.SettingsBackend;
pub const nullSettingsBackendNew = g_null_settings_backend_new;

/// Utility method for `gio.PollableInputStream` and `gio.PollableOutputStream`
/// implementations. Creates a new `glib.Source` that expects a callback of
/// type `gio.PollableSourceFunc`. The new source does not actually do
/// anything on its own; use `glib.Source.addChildSource` to add other
/// sources to it to cause it to trigger.
extern fn g_pollable_source_new(p_pollable_stream: *gobject.Object) *glib.Source;
pub const pollableSourceNew = g_pollable_source_new;

/// Utility method for `gio.PollableInputStream` and `gio.PollableOutputStream`
/// implementations. Creates a new `glib.Source`, as with
/// `gio.pollableSourceNew`, but also attaching `child_source` (with a
/// dummy callback), and `cancellable`, if they are non-`NULL`.
extern fn g_pollable_source_new_full(p_pollable_stream: *gobject.Object, p_child_source: ?*glib.Source, p_cancellable: ?*gio.Cancellable) *glib.Source;
pub const pollableSourceNewFull = g_pollable_source_new_full;

/// Tries to read from `stream`, as with `gio.InputStream.read` (if
/// `blocking` is `TRUE`) or `gio.PollableInputStream.readNonblocking`
/// (if `blocking` is `FALSE`). This can be used to more easily share
/// code between blocking and non-blocking implementations of a method.
///
/// If `blocking` is `FALSE`, then `stream` must be a
/// `gio.PollableInputStream` for which `gio.PollableInputStream.canPoll`
/// returns `TRUE`, or else the behavior is undefined. If `blocking` is
/// `TRUE`, then `stream` does not need to be a `gio.PollableInputStream`.
extern fn g_pollable_stream_read(p_stream: *gio.InputStream, p_buffer: [*]u8, p_count: usize, p_blocking: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
pub const pollableStreamRead = g_pollable_stream_read;

/// Tries to write to `stream`, as with `gio.OutputStream.write` (if
/// `blocking` is `TRUE`) or `gio.PollableOutputStream.writeNonblocking`
/// (if `blocking` is `FALSE`). This can be used to more easily share
/// code between blocking and non-blocking implementations of a method.
///
/// If `blocking` is `FALSE`, then `stream` must be a
/// `gio.PollableOutputStream` for which
/// `gio.PollableOutputStream.canPoll` returns `TRUE` or else the
/// behavior is undefined. If `blocking` is `TRUE`, then `stream` does not
/// need to be a `gio.PollableOutputStream`.
extern fn g_pollable_stream_write(p_stream: *gio.OutputStream, p_buffer: [*]u8, p_count: usize, p_blocking: c_int, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) isize;
pub const pollableStreamWrite = g_pollable_stream_write;

/// Tries to write `count` bytes to `stream`, as with
/// `gio.OutputStream.writeAll`, but using `gio.pollableStreamWrite`
/// rather than `gio.OutputStream.write`.
///
/// On a successful write of `count` bytes, `TRUE` is returned, and
/// `bytes_written` is set to `count`.
///
/// If there is an error during the operation (including
/// `G_IO_ERROR_WOULD_BLOCK` in the non-blocking case), `FALSE` is
/// returned and `error` is set to indicate the error status,
/// `bytes_written` is updated to contain the number of bytes written
/// into the stream before the error occurred.
///
/// As with `gio.pollableStreamWrite`, if `blocking` is `FALSE`, then
/// `stream` must be a `gio.PollableOutputStream` for which
/// `gio.PollableOutputStream.canPoll` returns `TRUE` or else the
/// behavior is undefined. If `blocking` is `TRUE`, then `stream` does not
/// need to be a `gio.PollableOutputStream`.
extern fn g_pollable_stream_write_all(p_stream: *gio.OutputStream, p_buffer: [*]u8, p_count: usize, p_blocking: c_int, p_bytes_written: *usize, p_cancellable: ?*gio.Cancellable, p_error: ?*?*glib.Error) c_int;
pub const pollableStreamWriteAll = g_pollable_stream_write_all;

/// Returns all the names of children at the specified `path` in the set of
/// globally registered resources.
///
/// The return result is a `NULL` terminated list of strings which should
/// be released with `glib.strfreev`.
///
/// `lookup_flags` controls the behaviour of the lookup.
extern fn g_resources_enumerate_children(p_path: [*:0]const u8, p_lookup_flags: gio.ResourceLookupFlags, p_error: ?*?*glib.Error) ?[*][*:0]u8;
pub const resourcesEnumerateChildren = g_resources_enumerate_children;

/// Looks for a file at the specified `path` in the set of
/// globally registered resources and if found returns information about it.
///
/// `lookup_flags` controls the behaviour of the lookup.
extern fn g_resources_get_info(p_path: [*:0]const u8, p_lookup_flags: gio.ResourceLookupFlags, p_size: ?*usize, p_flags: ?*u32, p_error: ?*?*glib.Error) c_int;
pub const resourcesGetInfo = g_resources_get_info;

/// Returns whether the specified `path` in the set of
/// globally registered resources has children.
extern fn g_resources_has_children(p_path: [*:0]const u8) c_int;
pub const resourcesHasChildren = g_resources_has_children;

/// Looks for a file at the specified `path` in the set of
/// globally registered resources and returns a `glib.Bytes` that
/// lets you directly access the data in memory.
///
/// The data is always followed by a zero byte, so you
/// can safely use the data as a C string. However, that byte
/// is not included in the size of the `glib.Bytes`.
///
/// For uncompressed resource files this is a pointer directly into
/// the resource bundle, which is typically in some read-only data section
/// in the program binary. For compressed files we allocate memory on
/// the heap and automatically uncompress the data.
///
/// `lookup_flags` controls the behaviour of the lookup.
extern fn g_resources_lookup_data(p_path: [*:0]const u8, p_lookup_flags: gio.ResourceLookupFlags, p_error: ?*?*glib.Error) ?*glib.Bytes;
pub const resourcesLookupData = g_resources_lookup_data;

/// Looks for a file at the specified `path` in the set of
/// globally registered resources and returns a `gio.InputStream`
/// that lets you read the data.
///
/// `lookup_flags` controls the behaviour of the lookup.
extern fn g_resources_open_stream(p_path: [*:0]const u8, p_lookup_flags: gio.ResourceLookupFlags, p_error: ?*?*glib.Error) ?*gio.InputStream;
pub const resourcesOpenStream = g_resources_open_stream;

/// Registers the resource with the process-global set of resources.
///
/// Once a resource is registered the files in it can be accessed
/// with the global resource lookup functions like
/// `gio.resourcesLookupData`.
extern fn g_resources_register(p_resource: *gio.Resource) void;
pub const resourcesRegister = g_resources_register;

/// Unregisters the resource from the process-global set of resources.
extern fn g_resources_unregister(p_resource: *gio.Resource) void;
pub const resourcesUnregister = g_resources_unregister;

/// Reports an error in an asynchronous function in an idle function by
/// directly setting the contents of the `gio.AsyncResult` with the given error
/// information.
extern fn g_simple_async_report_error_in_idle(p_object: ?*gobject.Object, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque, p_domain: glib.Quark, p_code: c_int, p_format: [*:0]const u8, ...) void;
pub const simpleAsyncReportErrorInIdle = g_simple_async_report_error_in_idle;

/// Reports an error in an idle function. Similar to
/// `gio.simpleAsyncReportErrorInIdle`, but takes a `glib.Error` rather
/// than building a new one.
extern fn g_simple_async_report_gerror_in_idle(p_object: ?*gobject.Object, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque, p_error: *const glib.Error) void;
pub const simpleAsyncReportGerrorInIdle = g_simple_async_report_gerror_in_idle;

/// Reports an error in an idle function. Similar to
/// `gio.simpleAsyncReportGerrorInIdle`, but takes over the caller's
/// ownership of `error`, so the caller does not have to free it any more.
extern fn g_simple_async_report_take_gerror_in_idle(p_object: ?*gobject.Object, p_callback: ?gio.AsyncReadyCallback, p_user_data: ?*anyopaque, p_error: *glib.Error) void;
pub const simpleAsyncReportTakeGerrorInIdle = g_simple_async_report_take_gerror_in_idle;

/// Determines if `mount_path` is considered an implementation of the
/// OS.
///
/// This is primarily used for hiding mountable and mounted volumes
/// that only are used in the OS and has little to no relevance to the
/// casual user.
extern fn g_unix_is_mount_path_system_internal(p_mount_path: [*:0]const u8) c_int;
pub const unixIsMountPathSystemInternal = g_unix_is_mount_path_system_internal;

/// Determines if `device_path` is considered a block device path which is only
/// used in implementation of the OS.
///
/// This is primarily used for hiding mounted volumes that are intended as APIs
/// for programs to read, and system administrators at a shell; rather than
/// something that should, for example, appear in a GUI. For example, the Linux
/// `/proc` filesystem.
///
/// The list of device paths considered ‘system’ ones may change over time.
extern fn g_unix_is_system_device_path(p_device_path: [*:0]const u8) c_int;
pub const unixIsSystemDevicePath = g_unix_is_system_device_path;

/// Determines if `fs_type` is considered a type of file system which is only
/// used in implementation of the OS.
///
/// This is primarily used for hiding mounted volumes that are intended as APIs
/// for programs to read, and system administrators at a shell; rather than
/// something that should, for example, appear in a GUI. For example, the Linux
/// `/proc` filesystem.
///
/// The list of file system types considered ‘system’ ones may change over time.
extern fn g_unix_is_system_fs_type(p_fs_type: [*:0]const u8) c_int;
pub const unixIsSystemFsType = g_unix_is_system_fs_type;

/// Gets a `giounix.MountEntry` for a given mount path.
///
/// If `time_read` is set, it will be filled with a Unix timestamp for checking
/// if the mounts have changed since with
/// `GioUnix.mountEntriesChangedSince`.
///
/// If more mounts have the same mount path, the last matching mount
/// is returned.
///
/// This will return `NULL` if there is no mount point at `mount_path`.
extern fn g_unix_mount_at(p_mount_path: [*:0]const u8, p_time_read: ?*u64) ?*gio.UnixMountEntry;
pub const unixMountAt = g_unix_mount_at;

/// Compares two Unix mounts.
extern fn g_unix_mount_compare(p_mount1: *gio.UnixMountEntry, p_mount2: *gio.UnixMountEntry) c_int;
pub const unixMountCompare = g_unix_mount_compare;

/// Makes a copy of `mount_entry`.
extern fn g_unix_mount_copy(p_mount_entry: *gio.UnixMountEntry) *gio.UnixMountEntry;
pub const unixMountCopy = g_unix_mount_copy;

/// Checks if the Unix mounts have changed since a given Unix time.
///
/// This can only work reliably if a `giounix.MountMonitor` is running in
/// the process, otherwise changes in the mount entries file (such as
/// `/proc/self/mountinfo` on Linux) cannot be detected and, as a result, this
/// function has to conservatively always return `TRUE`.
///
/// It is more efficient to use `giounix.MountMonitor.signals.mounts_changed` to
/// be signalled of changes to the mount entries, rather than polling using this
/// function. This function is more appropriate for infrequently determining
/// cache validity.
extern fn g_unix_mount_entries_changed_since(p_time: u64) c_int;
pub const unixMountEntriesChangedSince = g_unix_mount_entries_changed_since;

/// Gets a list of `giounix.MountEntry` instances representing the Unix
/// mounts.
///
/// If `time_read` is set, it will be filled with the mount timestamp, allowing
/// for checking if the mounts have changed with
/// `GioUnix.mountEntriesChangedSince`.
extern fn g_unix_mount_entries_get(p_time_read: ?*u64) *glib.List;
pub const unixMountEntriesGet = g_unix_mount_entries_get;

/// Gets an array of `gio.UnixMountEntry`s containing the Unix mounts
/// listed in `table_path`.
///
/// This is a generalized version of `GioUnix.mountEntriesGet`, mainly
/// intended for internal testing use. Note that `GioUnix.mountEntriesGet`
/// may parse multiple hierarchical table files, so this function is not a direct
/// superset of its functionality.
///
/// If there is an error reading or parsing the file, `NULL` will be returned
/// and both out parameters will be set to `0`.
extern fn g_unix_mount_entries_get_from_file(p_table_path: [*:0]const u8, p_time_read_out: ?*u64, p_n_entries_out: ?*usize) ?[*]*gio.UnixMountEntry;
pub const unixMountEntriesGetFromFile = g_unix_mount_entries_get_from_file;

/// Gets a `giounix.MountEntry` for a given file path.
///
/// If `time_read` is set, it will be filled with a Unix timestamp for checking
/// if the mounts have changed since with
/// `GioUnix.mountEntriesChangedSince`.
///
/// If more mounts have the same mount path, the last matching mount
/// is returned.
///
/// This will return `NULL` if looking up the mount entry fails, if
/// `file_path` doesn’t exist or there is an I/O error.
extern fn g_unix_mount_for(p_file_path: [*:0]const u8, p_time_read: ?*u64) ?*gio.UnixMountEntry;
pub const unixMountFor = g_unix_mount_for;

/// Frees a Unix mount.
extern fn g_unix_mount_free(p_mount_entry: *gio.UnixMountEntry) void;
pub const unixMountFree = g_unix_mount_free;

/// Gets the device path for a Unix mount.
extern fn g_unix_mount_get_device_path(p_mount_entry: *gio.UnixMountEntry) [*:0]const u8;
pub const unixMountGetDevicePath = g_unix_mount_get_device_path;

/// Gets the filesystem type for the Unix mount.
extern fn g_unix_mount_get_fs_type(p_mount_entry: *gio.UnixMountEntry) [*:0]const u8;
pub const unixMountGetFsType = g_unix_mount_get_fs_type;

/// Gets the mount path for a Unix mount.
extern fn g_unix_mount_get_mount_path(p_mount_entry: *gio.UnixMountEntry) [*:0]const u8;
pub const unixMountGetMountPath = g_unix_mount_get_mount_path;

/// Gets a comma separated list of mount options for the Unix mount.
///
/// For example: `rw,relatime,seclabel,data=ordered`.
///
/// This is similar to `giounix.MountPoint.getOptions`, but it takes
/// a `giounix.MountEntry` as an argument.
extern fn g_unix_mount_get_options(p_mount_entry: *gio.UnixMountEntry) ?[*:0]const u8;
pub const unixMountGetOptions = g_unix_mount_get_options;

/// Gets the root of the mount within the filesystem. This is useful e.g. for
/// mounts created by bind operation, or btrfs subvolumes.
///
/// For example, the root path is equal to `/` for a mount created by
/// `mount /dev/sda1 /mnt/foo` and `/bar` for
/// `mount --bind /mnt/foo/bar /mnt/bar`.
extern fn g_unix_mount_get_root_path(p_mount_entry: *gio.UnixMountEntry) ?[*:0]const u8;
pub const unixMountGetRootPath = g_unix_mount_get_root_path;

/// Guesses whether a Unix mount entry can be ejected.
extern fn g_unix_mount_guess_can_eject(p_mount_entry: *gio.UnixMountEntry) c_int;
pub const unixMountGuessCanEject = g_unix_mount_guess_can_eject;

/// Guesses the icon of a Unix mount entry.
extern fn g_unix_mount_guess_icon(p_mount_entry: *gio.UnixMountEntry) *gio.Icon;
pub const unixMountGuessIcon = g_unix_mount_guess_icon;

/// Guesses the name of a Unix mount entry.
///
/// The result is a translated string.
extern fn g_unix_mount_guess_name(p_mount_entry: *gio.UnixMountEntry) [*:0]u8;
pub const unixMountGuessName = g_unix_mount_guess_name;

/// Guesses whether a Unix mount entry should be displayed in the UI.
extern fn g_unix_mount_guess_should_display(p_mount_entry: *gio.UnixMountEntry) c_int;
pub const unixMountGuessShouldDisplay = g_unix_mount_guess_should_display;

/// Guesses the symbolic icon of a Unix mount entry.
extern fn g_unix_mount_guess_symbolic_icon(p_mount_entry: *gio.UnixMountEntry) *gio.Icon;
pub const unixMountGuessSymbolicIcon = g_unix_mount_guess_symbolic_icon;

/// Checks if a Unix mount is mounted read only.
extern fn g_unix_mount_is_readonly(p_mount_entry: *gio.UnixMountEntry) c_int;
pub const unixMountIsReadonly = g_unix_mount_is_readonly;

/// Checks if a Unix mount is a system mount.
///
/// This is the Boolean OR of
/// `GioUnix.isSystemFsType`, `GioUnix.isSystemDevicePath` and
/// `GioUnix.isMountPathSystemInternal` on `mount_entry`’s properties.
///
/// The definition of what a ‘system’ mount entry is may change over time as new
/// file system types and device paths are ignored.
extern fn g_unix_mount_is_system_internal(p_mount_entry: *gio.UnixMountEntry) c_int;
pub const unixMountIsSystemInternal = g_unix_mount_is_system_internal;

/// Checks if the Unix mount points have changed since a given Unix time.
///
/// Unlike `GioUnix.mountEntriesChangedSince`, this function can work
/// reliably without a `giounix.MountMonitor` running, as it accesses the
/// static mount point information (such as `/etc/fstab` on Linux), which has a
/// valid modification time.
///
/// It is more efficient to use `giounix.MountMonitor.signals.mountpoints_changed`
/// to be signalled of changes to the mount points, rather than polling using
/// this function. This function is more appropriate for infrequently determining
/// cache validity.
extern fn g_unix_mount_points_changed_since(p_time: u64) c_int;
pub const unixMountPointsChangedSince = g_unix_mount_points_changed_since;

/// Gets a list of `giounix.MountPoint` instances representing the Unix
/// mount points.
///
/// If `time_read` is set, it will be filled with the mount timestamp, allowing
/// for checking if the mounts have changed with
/// `GioUnix.mountPointsChangedSince`.
extern fn g_unix_mount_points_get(p_time_read: ?*u64) *glib.List;
pub const unixMountPointsGet = g_unix_mount_points_get;

/// Gets an array of `gio.UnixMountPoint`s containing the Unix mount
/// points listed in `table_path`.
///
/// This is a generalized version of `GioUnix.mountPointsGet`, mainly
/// intended for internal testing use. Note that `GioUnix.mountPointsGet`
/// may parse multiple hierarchical table files, so this function is not a direct
/// superset of its functionality.
///
/// If there is an error reading or parsing the file, `NULL` will be returned
/// and both out parameters will be set to `0`.
extern fn g_unix_mount_points_get_from_file(p_table_path: [*:0]const u8, p_time_read_out: ?*u64, p_n_points_out: ?*usize) ?[*]*gio.UnixMountPoint;
pub const unixMountPointsGetFromFile = g_unix_mount_points_get_from_file;

/// Checks if the Unix mounts have changed since a given Unix time.
extern fn g_unix_mounts_changed_since(p_time: u64) c_int;
pub const unixMountsChangedSince = g_unix_mounts_changed_since;

/// Gets a list of `giounix.MountEntry` instances representing the Unix
/// mounts.
///
/// If `time_read` is set, it will be filled with the mount timestamp, allowing
/// for checking if the mounts have changed with
/// `GioUnix.mountEntriesChangedSince`.
extern fn g_unix_mounts_get(p_time_read: ?*u64) *glib.List;
pub const unixMountsGet = g_unix_mounts_get;

/// Gets an array of `gio.UnixMountEntry`s containing the Unix mounts
/// listed in `table_path`.
///
/// This is a generalized version of `GioUnix.mountEntriesGet`, mainly
/// intended for internal testing use. Note that `GioUnix.mountEntriesGet`
/// may parse multiple hierarchical table files, so this function is not a direct
/// superset of its functionality.
///
/// If there is an error reading or parsing the file, `NULL` will be returned
/// and both out parameters will be set to `0`.
extern fn g_unix_mounts_get_from_file(p_table_path: [*:0]const u8, p_time_read_out: ?*u64, p_n_entries_out: ?*usize) ?[*]*gio.UnixMountEntry;
pub const unixMountsGetFromFile = g_unix_mounts_get_from_file;

/// Type definition for a function that will be called back when an asynchronous
/// operation within GIO has been completed. `gio.AsyncReadyCallback`
/// callbacks from `gio.Task` are guaranteed to be invoked in a later
/// iteration of the thread-default main context
/// (see `glib.MainContext.pushThreadDefault`)
/// where the `gio.Task` was created. All other users of
/// `gio.AsyncReadyCallback` must likewise call it asynchronously in a
/// later iteration of the main context.
///
/// The asynchronous operation is guaranteed to have held a reference to
/// `source_object` from the time when the `*`_async`` function was called, until
/// after this callback returns.
pub const AsyncReadyCallback = *const fn (p_source_object: ?*gobject.Object, p_res: *gio.AsyncResult, p_data: ?*anyopaque) callconv(.c) void;

/// Invoked when a connection to a message bus has been obtained.
pub const BusAcquiredCallback = *const fn (p_connection: *gio.DBusConnection, p_name: [*:0]const u8, p_user_data: ?*anyopaque) callconv(.c) void;

/// Invoked when the name is acquired.
pub const BusNameAcquiredCallback = *const fn (p_connection: *gio.DBusConnection, p_name: [*:0]const u8, p_user_data: ?*anyopaque) callconv(.c) void;

/// Invoked when the name being watched is known to have to have an owner.
pub const BusNameAppearedCallback = *const fn (p_connection: *gio.DBusConnection, p_name: [*:0]const u8, p_name_owner: [*:0]const u8, p_user_data: ?*anyopaque) callconv(.c) void;

/// Invoked when the name is lost or `connection` has been closed.
pub const BusNameLostCallback = *const fn (p_connection: *gio.DBusConnection, p_name: [*:0]const u8, p_user_data: ?*anyopaque) callconv(.c) void;

/// Invoked when the name being watched is known not to have to have an owner.
///
/// This is also invoked when the `gio.DBusConnection` on which the watch was
/// established has been closed.  In that case, `connection` will be
/// `NULL`.
pub const BusNameVanishedCallback = *const fn (p_connection: *gio.DBusConnection, p_name: [*:0]const u8, p_user_data: ?*anyopaque) callconv(.c) void;

/// This is the function type of the callback used for the `glib.Source`
/// returned by `gio.Cancellable.sourceNew`.
pub const CancellableSourceFunc = *const fn (p_cancellable: ?*gio.Cancellable, p_data: ?*anyopaque) callconv(.c) c_int;

/// The type of the `get_property` function in `gio.DBusInterfaceVTable`.
pub const DBusInterfaceGetPropertyFunc = *const fn (p_connection: *gio.DBusConnection, p_sender: ?[*:0]const u8, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8, p_property_name: [*:0]const u8, p_error: **glib.Error, p_user_data: ?*anyopaque) callconv(.c) *glib.Variant;

/// The type of the `method_call` function in `gio.DBusInterfaceVTable`.
///
/// `interface_name` may be `NULL` if not specified by the sender, although it’s
/// encouraged for the sender to set it. If unset, and the object has only one
/// method (across all interfaces) matching `method_name`, that method is invoked.
/// Otherwise, behaviour is implementation defined. See the
/// [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html`message`-protocol-types-method).
/// It is recommended to return `gio.@"DBusError.UNKNOWN_METHOD"`.
pub const DBusInterfaceMethodCallFunc = *const fn (p_connection: *gio.DBusConnection, p_sender: ?[*:0]const u8, p_object_path: [*:0]const u8, p_interface_name: ?[*:0]const u8, p_method_name: [*:0]const u8, p_parameters: *glib.Variant, p_invocation: *gio.DBusMethodInvocation, p_user_data: ?*anyopaque) callconv(.c) void;

/// The type of the `set_property` function in `gio.DBusInterfaceVTable`.
pub const DBusInterfaceSetPropertyFunc = *const fn (p_connection: *gio.DBusConnection, p_sender: ?[*:0]const u8, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8, p_property_name: [*:0]const u8, p_value: *glib.Variant, p_error: **glib.Error, p_user_data: ?*anyopaque) callconv(.c) c_int;

/// Signature for function used in `gio.DBusConnection.addFilter`.
///
/// A filter function is passed a `gio.DBusMessage` and expected to return
/// a `gio.DBusMessage` too. Passive filter functions that don't modify the
/// message can simply return the `message` object:
/// ```
/// static GDBusMessage *
/// passive_filter (GDBusConnection *connection
///                 GDBusMessage    *message,
///                 gboolean         incoming,
///                 gpointer         user_data)
/// {
///   // inspect `message`
///   return message;
/// }
/// ```
/// Filter functions that wants to drop a message can simply return `NULL`:
/// ```
/// static GDBusMessage *
/// drop_filter (GDBusConnection *connection
///              GDBusMessage    *message,
///              gboolean         incoming,
///              gpointer         user_data)
/// {
///   if (should_drop_message)
///     {
///       g_object_unref (message);
///       message = NULL;
///     }
///   return message;
/// }
/// ```
/// Finally, a filter function may modify a message by copying it:
/// ```
/// static GDBusMessage *
/// modifying_filter (GDBusConnection *connection
///                   GDBusMessage    *message,
///                   gboolean         incoming,
///                   gpointer         user_data)
/// {
///   GDBusMessage *copy;
///   GError *error;
///
///   error = NULL;
///   copy = g_dbus_message_copy (message, &error);
///   // handle `error` being set
///   g_object_unref (message);
///
///   // modify `copy`
///
///   return copy;
/// }
/// ```
/// If the returned `gio.DBusMessage` is different from `message` and cannot
/// be sent on `connection` (it could use features, such as file
/// descriptors, not compatible with `connection`), then a warning is
/// logged to standard error. Applications can
/// check this ahead of time using `gio.DBusMessage.toBlob` passing a
/// `gio.DBusCapabilityFlags` value obtained from `connection`.
pub const DBusMessageFilterFunction = *const fn (p_connection: *gio.DBusConnection, p_message: *gio.DBusMessage, p_incoming: c_int, p_user_data: ?*anyopaque) callconv(.c) ?*gio.DBusMessage;

/// Function signature for a function used to determine the `gobject.Type` to
/// use for an interface proxy (if `interface_name` is not `NULL`) or
/// object proxy (if `interface_name` is `NULL`).
///
/// This function is called in the thread-default main context
/// (see `glib.MainContext.pushThreadDefault`)
/// that `manager` was constructed in.
pub const DBusProxyTypeFunc = *const fn (p_manager: *gio.DBusObjectManagerClient, p_object_path: [*:0]const u8, p_interface_name: ?[*:0]const u8, p_data: ?*anyopaque) callconv(.c) usize;

/// Signature for callback function used in `gio.DBusConnection.signalSubscribe`.
pub const DBusSignalCallback = *const fn (p_connection: *gio.DBusConnection, p_sender_name: ?[*:0]const u8, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8, p_signal_name: [*:0]const u8, p_parameters: *glib.Variant, p_user_data: ?*anyopaque) callconv(.c) void;

/// The type of the `dispatch` function in `gio.DBusSubtreeVTable`.
///
/// Subtrees are flat.  `node`, if non-`NULL`, is always exactly one
/// segment of the object path (ie: it never contains a slash).
pub const DBusSubtreeDispatchFunc = *const fn (p_connection: *gio.DBusConnection, p_sender: [*:0]const u8, p_object_path: [*:0]const u8, p_interface_name: [*:0]const u8, p_node: [*:0]const u8, p_out_user_data: *anyopaque, p_user_data: ?*anyopaque) callconv(.c) ?*const gio.DBusInterfaceVTable;

/// The type of the `enumerate` function in `gio.DBusSubtreeVTable`.
///
/// This function is called when generating introspection data and also
/// when preparing to dispatch incoming messages in the event that the
/// `G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES` flag is not
/// specified (ie: to verify that the object path is valid).
///
/// Hierarchies are not supported; the items that you return should not
/// contain the `/` character.
///
/// The return value will be freed with `glib.strfreev`.
pub const DBusSubtreeEnumerateFunc = *const fn (p_connection: *gio.DBusConnection, p_sender: [*:0]const u8, p_object_path: [*:0]const u8, p_user_data: ?*anyopaque) callconv(.c) [*][*:0]u8;

/// The type of the `introspect` function in `gio.DBusSubtreeVTable`.
///
/// Subtrees are flat.  `node`, if non-`NULL`, is always exactly one
/// segment of the object path (ie: it never contains a slash).
///
/// This function should return `NULL` to indicate that there is no object
/// at this node.
///
/// If this function returns non-`NULL`, the return value is expected to
/// be a `NULL`-terminated array of pointers to `gio.DBusInterfaceInfo`
/// structures describing the interfaces implemented by `node`.  This
/// array will have `gio.DBusInterfaceInfo.unref` called on each item
/// before being freed with `glib.free`.
///
/// The difference between returning `NULL` and an array containing zero
/// items is that the standard DBus interfaces will returned to the
/// remote introspector in the empty array case, but not in the `NULL`
/// case.
pub const DBusSubtreeIntrospectFunc = *const fn (p_connection: *gio.DBusConnection, p_sender: [*:0]const u8, p_object_path: [*:0]const u8, p_node: [*:0]const u8, p_user_data: ?*anyopaque) callconv(.c) ?[*]*gio.DBusInterfaceInfo;

/// This is the function type of the callback used for the `glib.Source`
/// returned by `gio.DatagramBased.createSource`.
pub const DatagramBasedSourceFunc = *const fn (p_datagram_based: *gio.DatagramBased, p_condition: glib.IOCondition, p_data: ?*anyopaque) callconv(.c) c_int;

/// During invocation, `gio.DesktopAppInfo.launchUrisAsManager` may
/// create one or more child processes.  This callback is invoked once
/// for each, providing the process ID.
pub const DesktopAppLaunchCallback = *const fn (p_appinfo: *gio.DesktopAppInfo, p_pid: glib.Pid, p_user_data: ?*anyopaque) callconv(.c) void;

/// This callback type is used by `gio.File.measureDiskUsage` to make
/// periodic progress reports when measuring the amount of disk spaced
/// used by a directory.
///
/// These calls are made on a best-effort basis and not all types of
/// `gio.File` will support them.  At the minimum, however, one call will
/// always be made immediately.
///
/// In the case that there is no support, `reporting` will be set to
/// `FALSE` (and the other values undefined) and no further calls will be
/// made.  Otherwise, the `reporting` will be `TRUE` and the other values
/// all-zeros during the first (immediate) call.  In this way, you can
/// know which type of progress UI to show without a delay.
///
/// For `gio.File.measureDiskUsage` the callback is made directly.  For
/// `gio.File.measureDiskUsageAsync` the callback is made via the
/// default main context of the calling thread (ie: the same way that the
/// final async result would be reported).
///
/// `current_size` is in the same units as requested by the operation (see
/// `G_FILE_MEASURE_APPARENT_SIZE`).
///
/// The frequency of the updates is implementation defined, but is
/// ideally about once every 200ms.
///
/// The last progress callback may or may not be equal to the final
/// result.  Always check the async result to get the final value.
pub const FileMeasureProgressCallback = *const fn (p_reporting: c_int, p_current_size: u64, p_num_dirs: u64, p_num_files: u64, p_data: ?*anyopaque) callconv(.c) void;

/// When doing file operations that may take a while, such as moving
/// a file or copying a file, a progress callback is used to pass how
/// far along that operation is to the application.
pub const FileProgressCallback = *const fn (p_current_num_bytes: i64, p_total_num_bytes: i64, p_data: ?*anyopaque) callconv(.c) void;

/// When loading the partial contents of a file with `gio.File.loadPartialContentsAsync`,
/// it may become necessary to determine if any more data from the file should be loaded.
/// A `gio.FileReadMoreCallback` function facilitates this by returning `TRUE` if more data
/// should be read, or `FALSE` otherwise.
pub const FileReadMoreCallback = *const fn (p_file_contents: [*:0]const u8, p_file_size: i64, p_callback_data: ?*anyopaque) callconv(.c) c_int;

/// I/O Job function.
///
/// Long-running jobs should periodically check the `cancellable`
/// to see if they have been cancelled.
pub const IOSchedulerJobFunc = *const fn (p_job: *gio.IOSchedulerJob, p_cancellable: ?*gio.Cancellable, p_data: ?*anyopaque) callconv(.c) c_int;

/// This is the function type of the callback used for the `glib.Source`
/// returned by `gio.PollableInputStream.createSource` and
/// `gio.PollableOutputStream.createSource`.
pub const PollableSourceFunc = *const fn (p_pollable_stream: *gobject.Object, p_data: ?*anyopaque) callconv(.c) c_int;

/// Changes the size of the memory block pointed to by `data` to
/// `size` bytes.
///
/// The function should have the same semantics as `realloc`.
pub const ReallocFunc = *const fn (p_data: ?*anyopaque, p_size: usize) callconv(.c) ?*anyopaque;

/// The type for the function that is used to convert from `gio.Settings` to
/// an object property. The `value` is already initialized to hold values
/// of the appropriate type.
pub const SettingsBindGetMapping = *const fn (p_value: *gobject.Value, p_variant: *glib.Variant, p_user_data: ?*anyopaque) callconv(.c) c_int;

/// The type for the function that is used to convert an object property
/// value to a `glib.Variant` for storing it in `gio.Settings`.
pub const SettingsBindSetMapping = *const fn (p_value: *const gobject.Value, p_expected_type: *const glib.VariantType, p_user_data: ?*anyopaque) callconv(.c) *glib.Variant;

/// The type of the function that is used to convert from a value stored
/// in a `gio.Settings` to a value that is useful to the application.
///
/// If the value is successfully mapped, the result should be stored at
/// `result` and `TRUE` returned.  If mapping fails (for example, if `value`
/// is not in the right format) then `FALSE` should be returned.
///
/// If `value` is `NULL` then it means that the mapping function is being
/// given a "last chance" to successfully return a valid value.  `TRUE`
/// must be returned in this case.
pub const SettingsGetMapping = *const fn (p_value: *glib.Variant, p_result: ?*anyopaque, p_user_data: ?*anyopaque) callconv(.c) c_int;

/// Simple thread function that runs an asynchronous operation and
/// checks for cancellation.
pub const SimpleAsyncThreadFunc = *const fn (p_res: *gio.SimpleAsyncResult, p_object: *gobject.Object, p_cancellable: ?*gio.Cancellable) callconv(.c) void;

/// This is the function type of the callback used for the `glib.Source`
/// returned by `gio.Socket.createSource`.
pub const SocketSourceFunc = *const fn (p_socket: *gio.Socket, p_condition: glib.IOCondition, p_data: ?*anyopaque) callconv(.c) c_int;

/// The prototype for a task function to be run in a thread via
/// `gio.Task.runInThread` or `gio.Task.runInThreadSync`.
///
/// If the return-on-cancel flag is set on `task`, and `cancellable` gets
/// cancelled, then the `gio.Task` will be completed immediately (as though
/// `gio.Task.returnErrorIfCancelled` had been called), without
/// waiting for the task function to complete. However, the task
/// function will continue running in its thread in the background. The
/// function therefore needs to be careful about how it uses
/// externally-visible state in this case. See
/// `gio.Task.setReturnOnCancel` for more details.
///
/// Other than in that case, `task` will be completed when the
/// `gio.TaskThreadFunc` returns, not when it calls a
/// `g_task_return_` function.
pub const TaskThreadFunc = *const fn (p_task: *gio.Task, p_source_object: *gobject.Object, p_task_data: ?*anyopaque, p_cancellable: ?*gio.Cancellable) callconv(.c) void;

/// This function type is used by `gio.Vfs.registerUriScheme` to make it
/// possible for a client to associate a URI scheme to a different `gio.File`
/// implementation.
///
/// The client should return a reference to the new file that has been
/// created for `uri`, or `NULL` to continue with the default implementation.
pub const VfsFileLookupFunc = *const fn (p_vfs: *gio.Vfs, p_identifier: [*:0]const u8, p_user_data: ?*anyopaque) callconv(.c) ?*gio.File;

/// The value returned by handlers of the signals generated by
/// the `gdbus-codegen` tool to indicate that a method call has been
/// handled by an implementation. It is equal to `TRUE`, but using
/// this macro is sometimes more readable.
///
/// In code that needs to be backwards-compatible with older GLib,
/// use `TRUE` instead, often written like this:
///
/// ```
///   g_dbus_method_invocation_return_error (invocation, ...);
///   return TRUE;    // handled
/// ```
pub const DBUS_METHOD_INVOCATION_HANDLED = true;
/// The value returned by handlers of the signals generated by
/// the `gdbus-codegen` tool to indicate that a method call has not been
/// handled by an implementation. It is equal to `FALSE`, but using
/// this macro is sometimes more readable.
///
/// In code that needs to be backwards-compatible with older GLib,
/// use `FALSE` instead.
pub const DBUS_METHOD_INVOCATION_UNHANDLED = false;
/// Extension point for debug control functionality.
/// See [Extending GIO](overview.html`extending`-gio).
pub const DEBUG_CONTROLLER_EXTENSION_POINT_NAME = "gio-debug-controller";
/// Extension point for default handler to URI association. See
/// [Extending GIO](overview.html`extending`-gio).
pub const DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME = "gio-desktop-app-info-lookup";
/// The string used to obtain a Unix device path with `gio.Drive.getIdentifier`.
pub const DRIVE_IDENTIFIER_KIND_UNIX_DEVICE = "unix-device";
/// A key in the "access" namespace for checking deletion privileges.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
///
/// This attribute will be `TRUE` if the user is able to delete the file.
pub const FILE_ATTRIBUTE_ACCESS_CAN_DELETE = "access::can-delete";
/// A key in the "access" namespace for getting execution privileges.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
///
/// This attribute will be `TRUE` if the user is able to execute the file.
pub const FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE = "access::can-execute";
/// A key in the "access" namespace for getting read privileges.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
///
/// This attribute will be `TRUE` if the user is able to read the file.
pub const FILE_ATTRIBUTE_ACCESS_CAN_READ = "access::can-read";
/// A key in the "access" namespace for checking renaming privileges.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
///
/// This attribute will be `TRUE` if the user is able to rename the file.
pub const FILE_ATTRIBUTE_ACCESS_CAN_RENAME = "access::can-rename";
/// A key in the "access" namespace for checking trashing privileges.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
///
/// This attribute will be `TRUE` if the user is able to move the file to
/// the trash.
pub const FILE_ATTRIBUTE_ACCESS_CAN_TRASH = "access::can-trash";
/// A key in the "access" namespace for getting write privileges.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
///
/// This attribute will be `TRUE` if the user is able to write to the file.
pub const FILE_ATTRIBUTE_ACCESS_CAN_WRITE = "access::can-write";
/// A key in the "dos" namespace for checking if the file's archive flag
/// is set.
///
/// This attribute is `TRUE` if the archive flag is set.
///
/// This attribute is only available for DOS file systems.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_DOS_IS_ARCHIVE = "dos::is-archive";
/// A key in the "dos" namespace for checking if the file is a NTFS mount point
/// (a volume mount or a junction point).
///
/// This attribute is `TRUE` if file is a reparse point of type
/// [IO_REPARSE_TAG_MOUNT_POINT](https://msdn.microsoft.com/en-us/library/dd541667.aspx).
///
/// This attribute is only available for DOS file systems.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT = "dos::is-mountpoint";
/// A key in the "dos" namespace for checking if the file's backup flag
/// is set.
///
/// This attribute is `TRUE` if the backup flag is set.
///
/// This attribute is only available for DOS file systems.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_DOS_IS_SYSTEM = "dos::is-system";
/// A key in the "dos" namespace for getting the file NTFS reparse tag.
///
/// This value is 0 for files that are not reparse points.
///
/// See the [Reparse Tags](https://msdn.microsoft.com/en-us/library/dd541667.aspx)
/// page for possible reparse tag values.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG = "dos::reparse-point-tag";
/// A key in the "etag" namespace for getting the value of the file's
/// entity tag.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
pub const FILE_ATTRIBUTE_ETAG_VALUE = "etag::value";
/// A key in the "filesystem" namespace for getting the number of bytes
/// of free space left on the file system.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT64`.
pub const FILE_ATTRIBUTE_FILESYSTEM_FREE = "filesystem::free";
/// A key in the "filesystem" namespace for checking if the file system
/// is read only.
///
/// Is set to `TRUE` if the file system is read only.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_FILESYSTEM_READONLY = "filesystem::readonly";
/// A key in the "filesystem" namespace for checking if the file system
/// is remote.
///
/// Is set to `TRUE` if the file system is remote.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_FILESYSTEM_REMOTE = "filesystem::remote";
/// A key in the "filesystem" namespace for getting the total size (in
/// bytes) of the file system, used in `gio.File.queryFilesystemInfo`.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT64`.
pub const FILE_ATTRIBUTE_FILESYSTEM_SIZE = "filesystem::size";
/// A key in the "filesystem" namespace for getting the file system's type.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
pub const FILE_ATTRIBUTE_FILESYSTEM_TYPE = "filesystem::type";
/// A key in the "filesystem" namespace for getting the number of bytes
/// used by data on the file system.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT64`.
pub const FILE_ATTRIBUTE_FILESYSTEM_USED = "filesystem::used";
/// A key in the "filesystem" namespace for hinting a file manager
/// application whether it should preview (e.g. thumbnail) files on the
/// file system.
///
/// The value for this key contain a `gio.FilesystemPreviewType`.
pub const FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW = "filesystem::use-preview";
/// A key in the "gvfs" namespace that gets the name of the current
/// GVFS backend in use.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
pub const FILE_ATTRIBUTE_GVFS_BACKEND = "gvfs::backend";
/// A key in the "id" namespace for getting a file identifier.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
///
/// An example use would be during listing files, to avoid recursive
/// directory scanning.
pub const FILE_ATTRIBUTE_ID_FILE = "id::file";
/// A key in the "id" namespace for getting the file system identifier.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
///
/// An example use would be during drag and drop to see if the source
/// and target are on the same filesystem (default to move) or not (default
/// to copy).
pub const FILE_ATTRIBUTE_ID_FILESYSTEM = "id::filesystem";
/// A key in the "mountable" namespace for checking if a file (of
/// type G_FILE_TYPE_MOUNTABLE) can be ejected.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT = "mountable::can-eject";
/// A key in the "mountable" namespace for checking if a file (of
/// type G_FILE_TYPE_MOUNTABLE) is mountable.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT = "mountable::can-mount";
/// A key in the "mountable" namespace for checking if a file (of
/// type G_FILE_TYPE_MOUNTABLE) can be polled.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL = "mountable::can-poll";
/// A key in the "mountable" namespace for checking if a file (of
/// type G_FILE_TYPE_MOUNTABLE) can be started.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_MOUNTABLE_CAN_START = "mountable::can-start";
/// A key in the "mountable" namespace for checking if a file (of
/// type G_FILE_TYPE_MOUNTABLE) can be started degraded.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED = "mountable::can-start-degraded";
/// A key in the "mountable" namespace for checking if a file (of
/// type G_FILE_TYPE_MOUNTABLE) can be stopped.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP = "mountable::can-stop";
/// A key in the "mountable" namespace for checking if a file (of
/// type G_FILE_TYPE_MOUNTABLE)  is unmountable.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT = "mountable::can-unmount";
/// A key in the "mountable" namespace for getting the HAL UDI for the mountable
/// file.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
pub const FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI = "mountable::hal-udi";
/// A key in the "mountable" namespace for checking if a file (of
/// type G_FILE_TYPE_MOUNTABLE) is automatically polled for media.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC = "mountable::is-media-check-automatic";
/// A key in the "mountable" namespace for getting the `gio.DriveStartStopType`.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE = "mountable::start-stop-type";
/// A key in the "mountable" namespace for getting the unix device.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE = "mountable::unix-device";
/// A key in the "mountable" namespace for getting the unix device file.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
pub const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE = "mountable::unix-device-file";
/// A key in the "owner" namespace for getting the file owner's group.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
pub const FILE_ATTRIBUTE_OWNER_GROUP = "owner::group";
/// A key in the "owner" namespace for getting the user name of the
/// file's owner.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
pub const FILE_ATTRIBUTE_OWNER_USER = "owner::user";
/// A key in the "owner" namespace for getting the real name of the
/// user that owns the file.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
pub const FILE_ATTRIBUTE_OWNER_USER_REAL = "owner::user-real";
/// A key in the "preview" namespace for getting a `gio.Icon` that can be
/// used to get preview of the file.
///
/// For example, it may be a low resolution thumbnail without metadata.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_OBJECT`.
///
/// The value for this key should contain a `gio.Icon`.
pub const FILE_ATTRIBUTE_PREVIEW_ICON = "preview::icon";
/// A key in the "recent" namespace for getting time, when the metadata for the
/// file in `recent:///` was last changed.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_INT64`.
pub const FILE_ATTRIBUTE_RECENT_MODIFIED = "recent::modified";
/// A key in the "selinux" namespace for getting the file's SELinux
/// context.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
///
/// Note that this attribute is only available if GLib has been built
/// with SELinux support.
pub const FILE_ATTRIBUTE_SELINUX_CONTEXT = "selinux::context";
/// A key in the "standard" namespace for getting the amount of disk space
/// that is consumed by the file (in bytes).
///
/// This will generally be larger than the file size (due to block size
/// overhead) but can occasionally be smaller (for example, for sparse files).
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT64`.
pub const FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE = "standard::allocated-size";
/// A key in the "standard" namespace for getting the content type of the file.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
///
/// The value for this key should contain a valid content type.
pub const FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE = "standard::content-type";
/// A key in the "standard" namespace for getting the copy name of the file.
///
/// The copy name is an optional version of the name. If available it's always
/// in UTF8, and corresponds directly to the original filename (only transcoded to
/// UTF8). This is useful if you want to copy the file to another filesystem that
/// might have a different encoding. If the filename is not a valid string in the
/// encoding selected for the filesystem it is in then the copy name will not be set.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
pub const FILE_ATTRIBUTE_STANDARD_COPY_NAME = "standard::copy-name";
/// A key in the "standard" namespace for getting the description of the file.
///
/// The description is a utf8 string that describes the file, generally containing
/// the filename, but can also contain further information. Example descriptions
/// could be "filename (on hostname)" for a remote file or "filename (in trash)"
/// for a file in the trash. This is useful for instance as the window title
/// when displaying a directory or for a bookmarks menu.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
pub const FILE_ATTRIBUTE_STANDARD_DESCRIPTION = "standard::description";
/// A key in the "standard" namespace for getting the display name of the file.
///
/// A display name is guaranteed to be in UTF-8 and can thus be displayed in
/// the UI. It is guaranteed to be set on every file.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
pub const FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME = "standard::display-name";
/// A key in the "standard" namespace for edit name of the file.
///
/// An edit name is similar to the display name, but it is meant to be
/// used when you want to rename the file in the UI. The display name
/// might contain information you don't want in the new filename (such as
/// "(invalid unicode)" if the filename was in an invalid encoding).
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
pub const FILE_ATTRIBUTE_STANDARD_EDIT_NAME = "standard::edit-name";
/// A key in the "standard" namespace for getting the fast content type.
///
/// The fast content type isn't as reliable as the regular one, as it
/// only uses the filename to guess it, but it is faster to calculate than the
/// regular content type.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
pub const FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE = "standard::fast-content-type";
/// A key in the "standard" namespace for getting the icon for the file.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_OBJECT`.
///
/// The value for this key should contain a `gio.Icon`.
pub const FILE_ATTRIBUTE_STANDARD_ICON = "standard::icon";
/// A key in the "standard" namespace for checking if a file is a backup file.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_STANDARD_IS_BACKUP = "standard::is-backup";
/// A key in the "standard" namespace for checking if a file is hidden.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_STANDARD_IS_HIDDEN = "standard::is-hidden";
/// A key in the "standard" namespace for checking if the file is a symlink.
/// Typically the actual type is something else, if we followed the symlink
/// to get the type.
///
/// On Windows NTFS mountpoints are considered to be symlinks as well.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_STANDARD_IS_SYMLINK = "standard::is-symlink";
/// A key in the "standard" namespace for checking if a file is virtual.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL = "standard::is-virtual";
/// A key in the "standard" namespace for checking if a file is
/// volatile. This is meant for opaque, non-POSIX-like backends to
/// indicate that the URI is not persistent. Applications should look
/// at `G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET` for the persistent URI.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_STANDARD_IS_VOLATILE = "standard::is-volatile";
/// A key in the "standard" namespace for getting the name of the file.
///
/// The name is the on-disk filename which may not be in any known encoding,
/// and can thus not be generally displayed as is. It is guaranteed to be set on
/// every file.
///
/// Use `G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME` if you need to display the
/// name in a user interface.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BYTE_STRING`.
pub const FILE_ATTRIBUTE_STANDARD_NAME = "standard::name";
/// A key in the "standard" namespace for getting the file's size (in bytes).
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT64`.
pub const FILE_ATTRIBUTE_STANDARD_SIZE = "standard::size";
/// A key in the "standard" namespace for setting the sort order of a file.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_INT32`.
///
/// An example use would be in file managers, which would use this key
/// to set the order files are displayed. Files with smaller sort order
/// should be sorted first, and files without sort order as if sort order
/// was zero.
pub const FILE_ATTRIBUTE_STANDARD_SORT_ORDER = "standard::sort-order";
/// A key in the "standard" namespace for getting the symbolic icon for the file.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_OBJECT`.
///
/// The value for this key should contain a `gio.Icon`.
pub const FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON = "standard::symbolic-icon";
/// A key in the "standard" namespace for getting the symlink target, if the file
/// is a symlink.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BYTE_STRING`.
pub const FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET = "standard::symlink-target";
/// A key in the "standard" namespace for getting the target URI for the file, in
/// the case of `G_FILE_TYPE_SHORTCUT` or `G_FILE_TYPE_MOUNTABLE` files.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
pub const FILE_ATTRIBUTE_STANDARD_TARGET_URI = "standard::target-uri";
/// A key in the "standard" namespace for storing file types.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
///
/// The value for this key should contain a `gio.FileType`.
pub const FILE_ATTRIBUTE_STANDARD_TYPE = "standard::type";
/// A key in the "thumbnail" namespace for checking if thumbnailing failed.
///
/// This attribute is `TRUE` if thumbnailing failed.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_THUMBNAILING_FAILED = "thumbnail::failed";
/// A key in the "thumbnail" namespace for checking if thumbnailing failed
/// for the large image.
///
/// This attribute is `TRUE` if thumbnailing failed.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE = "thumbnail::failed-large";
/// A key in the "thumbnail" namespace for checking if thumbnailing failed
/// for the normal image.
///
/// This attribute is `TRUE` if thumbnailing failed.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL = "thumbnail::failed-normal";
/// A key in the "thumbnail" namespace for checking if thumbnailing failed
/// for the x-large image.
///
/// This attribute is `TRUE` if thumbnailing failed.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE = "thumbnail::failed-xlarge";
/// A key in the "thumbnail" namespace for checking if thumbnailing failed
/// for the xx-large image.
///
/// This attribute is `TRUE` if thumbnailing failed.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE = "thumbnail::failed-xxlarge";
/// A key in the "thumbnail" namespace for checking whether the thumbnail is outdated.
///
/// This attribute is `TRUE` if the thumbnail is up-to-date with the file it represents,
/// and `FALSE` if the file has been modified since the thumbnail was generated.
///
/// If `G_FILE_ATTRIBUTE_THUMBNAILING_FAILED` is `TRUE` and this attribute is `FALSE`,
/// it indicates that thumbnailing may be attempted again and may succeed.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID = "thumbnail::is-valid";
/// A key in the "thumbnail" namespace for checking whether the large
/// thumbnail is outdated.
///
/// This attribute is `TRUE` if the large thumbnail is up-to-date with the file
/// it represents, and `FALSE` if the file has been modified since the thumbnail
/// was generated.
///
/// If `G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE` is `TRUE` and this attribute
/// is `FALSE`, it indicates that thumbnailing may be attempted again and may
/// succeed.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_LARGE = "thumbnail::is-valid-large";
/// A key in the "thumbnail" namespace for checking whether the normal
/// thumbnail is outdated.
///
/// This attribute is `TRUE` if the normal thumbnail is up-to-date with the file
/// it represents, and `FALSE` if the file has been modified since the thumbnail
/// was generated.
///
/// If `G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL` is `TRUE` and this attribute
/// is `FALSE`, it indicates that thumbnailing may be attempted again and may
/// succeed.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_NORMAL = "thumbnail::is-valid-normal";
/// A key in the "thumbnail" namespace for checking whether the x-large
/// thumbnail is outdated.
///
/// This attribute is `TRUE` if the x-large thumbnail is up-to-date with the file
/// it represents, and `FALSE` if the file has been modified since the thumbnail
/// was generated.
///
/// If `G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE` is `TRUE` and this attribute
/// is `FALSE`, it indicates that thumbnailing may be attempted again and may
/// succeed.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XLARGE = "thumbnail::is-valid-xlarge";
/// A key in the "thumbnail" namespace for checking whether the xx-large
/// thumbnail is outdated.
///
/// This attribute is `TRUE` if the x-large thumbnail is up-to-date with the file
/// it represents, and `FALSE` if the file has been modified since the thumbnail
/// was generated.
///
/// If `G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE` is `TRUE` and this attribute
/// is `FALSE`, it indicates that thumbnailing may be attempted again and may
/// succeed.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XXLARGE = "thumbnail::is-valid-xxlarge";
/// A key in the "thumbnail" namespace for getting the path to the thumbnail
/// image with the biggest size available.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BYTE_STRING`.
pub const FILE_ATTRIBUTE_THUMBNAIL_PATH = "thumbnail::path";
/// A key in the "thumbnail" namespace for getting the path to the large
/// thumbnail image.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BYTE_STRING`.
pub const FILE_ATTRIBUTE_THUMBNAIL_PATH_LARGE = "thumbnail::path-large";
/// A key in the "thumbnail" namespace for getting the path to the normal
/// thumbnail image.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BYTE_STRING`.
pub const FILE_ATTRIBUTE_THUMBNAIL_PATH_NORMAL = "thumbnail::path-normal";
/// A key in the "thumbnail" namespace for getting the path to the x-large
/// thumbnail image.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BYTE_STRING`.
pub const FILE_ATTRIBUTE_THUMBNAIL_PATH_XLARGE = "thumbnail::path-xlarge";
/// A key in the "thumbnail" namespace for getting the path to the xx-large
/// thumbnail image.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BYTE_STRING`.
pub const FILE_ATTRIBUTE_THUMBNAIL_PATH_XXLARGE = "thumbnail::path-xxlarge";
/// A key in the "time" namespace for getting the time the file was last
/// accessed.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT64`, and
/// contains the time since the file was last accessed, in seconds since the
/// UNIX epoch.
pub const FILE_ATTRIBUTE_TIME_ACCESS = "time::access";
/// A key in the "time" namespace for getting the nanoseconds of the time
/// the file was last accessed. This should be used in conjunction with
/// `G_FILE_ATTRIBUTE_TIME_ACCESS`. Corresponding `gio.FileAttributeType` is
/// `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_TIME_ACCESS_NSEC = "time::access-nsec";
/// A key in the "time" namespace for getting the microseconds of the time
/// the file was last accessed.
///
/// This should be used in conjunction with `G_FILE_ATTRIBUTE_TIME_ACCESS`.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_TIME_ACCESS_USEC = "time::access-usec";
/// A key in the "time" namespace for getting the time the file was last
/// changed.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT64`,
/// and contains the time since the file was last changed, in seconds since
/// the UNIX epoch.
///
/// This corresponds to the traditional UNIX ctime.
pub const FILE_ATTRIBUTE_TIME_CHANGED = "time::changed";
/// A key in the "time" namespace for getting the nanoseconds of the time
/// the file was last changed. This should be used in conjunction with
/// `G_FILE_ATTRIBUTE_TIME_CHANGED`. Corresponding `gio.FileAttributeType` is
/// `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_TIME_CHANGED_NSEC = "time::changed-nsec";
/// A key in the "time" namespace for getting the microseconds of the time
/// the file was last changed.
///
/// This should be used in conjunction with `G_FILE_ATTRIBUTE_TIME_CHANGED`.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_TIME_CHANGED_USEC = "time::changed-usec";
/// A key in the "time" namespace for getting the time the file was created.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT64`,
/// and contains the time since the file was created, in seconds since the UNIX
/// epoch.
///
/// This may correspond to Linux `stx_btime`, FreeBSD `st_birthtim`, NetBSD
/// `st_birthtime` or NTFS `ctime`.
pub const FILE_ATTRIBUTE_TIME_CREATED = "time::created";
/// A key in the "time" namespace for getting the nanoseconds of the time
/// the file was created. This should be used in conjunction with
/// `G_FILE_ATTRIBUTE_TIME_CREATED`. Corresponding `gio.FileAttributeType` is
/// `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_TIME_CREATED_NSEC = "time::created-nsec";
/// A key in the "time" namespace for getting the microseconds of the time
/// the file was created.
///
/// This should be used in conjunction with `G_FILE_ATTRIBUTE_TIME_CREATED`.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_TIME_CREATED_USEC = "time::created-usec";
/// A key in the "time" namespace for getting the time the file was last
/// modified.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT64`, and
/// contains the time since the file was modified, in seconds since the UNIX
/// epoch.
pub const FILE_ATTRIBUTE_TIME_MODIFIED = "time::modified";
/// A key in the "time" namespace for getting the nanoseconds of the time
/// the file was last modified. This should be used in conjunction with
/// `G_FILE_ATTRIBUTE_TIME_MODIFIED`. Corresponding `gio.FileAttributeType` is
/// `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_TIME_MODIFIED_NSEC = "time::modified-nsec";
/// A key in the "time" namespace for getting the microseconds of the time
/// the file was last modified.
///
/// This should be used in conjunction with `G_FILE_ATTRIBUTE_TIME_MODIFIED`.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_TIME_MODIFIED_USEC = "time::modified-usec";
/// A key in the "trash" namespace for getting the deletion date and time
/// of a file inside the `trash:///` folder.
///
/// The format of the returned string is `YYYY-MM-DDThh:mm:ss`.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_STRING`.
pub const FILE_ATTRIBUTE_TRASH_DELETION_DATE = "trash::deletion-date";
/// A key in the "trash" namespace for getting the number of (toplevel) items
/// that are present in the `trash:///` folder.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_TRASH_ITEM_COUNT = "trash::item-count";
/// A key in the "trash" namespace for getting the original path of a file
/// inside the `trash:///` folder before it was trashed.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BYTE_STRING`.
pub const FILE_ATTRIBUTE_TRASH_ORIG_PATH = "trash::orig-path";
/// A key in the "unix" namespace for getting the number of blocks allocated
/// for the file.
///
/// This attribute is only available for UNIX file systems.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT64`.
pub const FILE_ATTRIBUTE_UNIX_BLOCKS = "unix::blocks";
/// A key in the "unix" namespace for getting the block size for the file
/// system.
///
/// This attribute is only available for UNIX file systems.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_UNIX_BLOCK_SIZE = "unix::block-size";
/// A key in the "unix" namespace for getting the device id of the device the
/// file is located on (see `stat` documentation).
///
/// This attribute is only available for UNIX file systems.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_UNIX_DEVICE = "unix::device";
/// A key in the "unix" namespace for getting the group ID for the file.
///
/// This attribute is only available for UNIX file systems.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_UNIX_GID = "unix::gid";
/// A key in the "unix" namespace for getting the inode of the file.
///
/// This attribute is only available for UNIX file systems.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT64`.
pub const FILE_ATTRIBUTE_UNIX_INODE = "unix::inode";
/// A key in the "unix" namespace for checking if the file represents a
/// UNIX mount point.
///
/// This attribute is `TRUE` if the file is a UNIX mount point.
///
/// Since 2.58, `/` is considered to be a mount point.
///
/// This attribute is only available for UNIX file systems.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_BOOLEAN`.
pub const FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT = "unix::is-mountpoint";
/// A key in the "unix" namespace for getting the mode of the file
/// (e.g. whether the file is a regular file, symlink, etc).
///
/// See the documentation for ``lstat``: this attribute is equivalent to
/// the `st_mode` member of `struct stat`, and includes both the file type
/// and permissions.
///
/// This attribute is only available for UNIX file systems.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_UNIX_MODE = "unix::mode";
/// A key in the "unix" namespace for getting the number of hard links
/// for a file.
///
/// See the documentation for ``lstat``.
///
/// This attribute is only available for UNIX file systems.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_UNIX_NLINK = "unix::nlink";
/// A key in the "unix" namespace for getting the device ID for the file
/// (if it is a special file).
///
/// See the documentation for ``lstat``.
///
/// This attribute is only available for UNIX file systems.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_UNIX_RDEV = "unix::rdev";
/// A key in the "unix" namespace for getting the user ID for the file.
///
/// This attribute is only available for UNIX file systems.
///
/// Corresponding `gio.FileAttributeType` is `G_FILE_ATTRIBUTE_TYPE_UINT32`.
pub const FILE_ATTRIBUTE_UNIX_UID = "unix::uid";
/// Extension point for memory usage monitoring functionality.
/// See [Extending GIO](overview.html`extending`-gio).
pub const MEMORY_MONITOR_EXTENSION_POINT_NAME = "gio-memory-monitor";
/// The menu item attribute which holds the action name of the item.  Action
/// names are namespaced with an identifier for the action group in which the
/// action resides. For example, "win." for window-specific actions and "app."
/// for application-wide actions.
///
/// See also `gio.MenuModel.getItemAttribute` and `gio.MenuItem.setAttribute`.
pub const MENU_ATTRIBUTE_ACTION = "action";
/// The menu item attribute that holds the namespace for all action names in
/// menus that are linked from this item.
pub const MENU_ATTRIBUTE_ACTION_NAMESPACE = "action-namespace";
/// The menu item attribute which holds the icon of the item.
///
/// The icon is stored in the format returned by `gio.Icon.serialize`.
///
/// This attribute is intended only to represent 'noun' icons such as
/// favicons for a webpage, or application icons.  It should not be used
/// for 'verbs' (ie: stock icons).
pub const MENU_ATTRIBUTE_ICON = "icon";
/// The menu item attribute which holds the label of the item.
pub const MENU_ATTRIBUTE_LABEL = "label";
/// The menu item attribute which holds the target with which the item's action
/// will be activated.
///
/// See also `gio.MenuItem.setActionAndTarget`
pub const MENU_ATTRIBUTE_TARGET = "target";
/// The maximum number of entries in a menu section supported by
/// `gio.DBusConnection.exportMenuModel`.
///
/// The exact value of the limit may change in future GLib versions.
pub const MENU_EXPORTER_MAX_SECTION_SIZE = 1000;
/// The name of the link that associates a menu item with a section.  The linked
/// menu will usually be shown in place of the menu item, using the item's label
/// as a header.
///
/// See also `gio.MenuItem.setLink`.
pub const MENU_LINK_SECTION = "section";
/// The name of the link that associates a menu item with a submenu.
///
/// See also `gio.MenuItem.setLink`.
pub const MENU_LINK_SUBMENU = "submenu";
pub const NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME = "gio-native-volume-monitor";
/// Extension point for network status monitoring functionality.
/// See [Extending GIO](overview.html`extending`-gio).
pub const NETWORK_MONITOR_EXTENSION_POINT_NAME = "gio-network-monitor";
/// Extension point for power profile usage monitoring functionality.
/// See [Extending GIO](overview.html`extending`-gio).
pub const POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME = "gio-power-profile-monitor";
/// Extension point for proxy functionality.
/// See [Extending GIO](overview.html`extending`-gio).
pub const PROXY_EXTENSION_POINT_NAME = "gio-proxy";
/// Extension point for proxy resolving functionality.
/// See [Extending GIO](overview.html`extending`-gio).
pub const PROXY_RESOLVER_EXTENSION_POINT_NAME = "gio-proxy-resolver";
/// Extension point for `gio.SettingsBackend` functionality.
pub const SETTINGS_BACKEND_EXTENSION_POINT_NAME = "gsettings-backend";
/// Extension point for TLS functionality via `gio.TlsBackend`.
/// See [Extending GIO](overview.html`extending`-gio).
pub const TLS_BACKEND_EXTENSION_POINT_NAME = "gio-tls-backend";
/// The purpose used to verify the client certificate in a TLS connection.
/// Used by TLS servers.
pub const TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT = "1.3.6.1.5.5.7.3.2";
/// The purpose used to verify the server certificate in a TLS connection. This
/// is the most common purpose in use. Used by TLS clients.
pub const TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER = "1.3.6.1.5.5.7.3.1";
/// Extension point for `gio.Vfs` functionality.
/// See [Extending GIO](overview.html`extending`-gio).
pub const VFS_EXTENSION_POINT_NAME = "gio-vfs";
/// The string used to obtain the volume class with `gio.Volume.getIdentifier`.
///
/// Known volume classes include `device`, `network`, and `loop`. Other
/// classes may be added in the future.
///
/// This is intended to be used by applications to classify `gio.Volume`
/// instances into different sections - for example a file manager or
/// file chooser can use this information to show `network` volumes under
/// a "Network" heading and `device` volumes under a "Devices" heading.
pub const VOLUME_IDENTIFIER_KIND_CLASS = "class";
/// The string used to obtain a Hal UDI with `gio.Volume.getIdentifier`.
pub const VOLUME_IDENTIFIER_KIND_HAL_UDI = "hal-udi";
/// The string used to obtain a filesystem label with `gio.Volume.getIdentifier`.
pub const VOLUME_IDENTIFIER_KIND_LABEL = "label";
/// The string used to obtain a NFS mount with `gio.Volume.getIdentifier`.
pub const VOLUME_IDENTIFIER_KIND_NFS_MOUNT = "nfs-mount";
/// The string used to obtain a Unix device path with `gio.Volume.getIdentifier`.
pub const VOLUME_IDENTIFIER_KIND_UNIX_DEVICE = "unix-device";
/// The string used to obtain a UUID with `gio.Volume.getIdentifier`.
pub const VOLUME_IDENTIFIER_KIND_UUID = "uuid";
/// Extension point for volume monitor functionality.
/// See [Extending GIO](overview.html`extending`-gio).
pub const VOLUME_MONITOR_EXTENSION_POINT_NAME = "gio-volume-monitor";

test {
    @setEvalBranchQuota(100_000);
    std.testing.refAllDecls(@This());
    std.testing.refAllDecls(ext);
}
